- en: Interacting with the Virtual World - Part I
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to make our player character move using
    teleport locomotion and then by adding a more immersive seamless locomotion scheme.
    We gave our users feet. Now, in this chapter, we're going to give them hands.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start out by creating a new project using assets from the Marketplace
    to explore another way of starting up a VR project, and then we'll take the VRPawn
    we built in the preceding chapter and migrate it into this new project. Once we're
    set up, we'll begin by adding hands to the VRPawn and exploring ways of interacting
    with objects in the world.
  prefs: []
  type: TYPE_NORMAL
- en: This is important. As humans interacting with the world, we're most conscious
    of the way things appear as we look around, but we're nearly as conscious of our
    hands and what they're doing. VR developers call this *hand presence*, and when
    it's done right, it can contribute significantly to immersion. Think about it
    for a moment. Your hands are the part of your body that you're probably most aware
    of most of the time. How well we represent them in VR has a meaningful impact
    on how *embodied* we feel in the experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create Blueprint-driven virtual hands for our players
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use a construction script to customize an object when it's created in
    the world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use animation blend spaces and animation blueprints to animate our hands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up new inputs to drive our hands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get to it!
  prefs: []
  type: TYPE_NORMAL
- en: Starting a new project from existing work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's begin by creating a new project. We'll migrate the Pawn and game mode
    we made in the previous chapter into this one, and we'll add some scenery from
    the Marketplace. As you start to develop a library of elements you've developed
    yourself, or acquired through the Marketplace, this will become a common way of
    getting a new project going.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating Blueprints to a new project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Launch your current engine version, and in your Unreal Project Browser, create
    a new project with the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Blank Blueprint template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware target set to Mobile / Tablet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphics target set to Scalable 3D or 2D
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No starter content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put it wherever you'd like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take the pawn we created in the previous project and add it to
    this one. To do this, we''re going to have to jump back to our previous project
    to grab the assets we want to migrate:'
  prefs: []
  type: TYPE_NORMAL
- en: Select File | Open Project and browse to your previous project's `.uproject`
    file. Open it up. Your current project will close when you do this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once in your previous project, find the `BP_VRGameMode` blueprint we created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click it and select Asset Actions | Migrate..., as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9441816b-3345-4281-a762-a8ad4dbd1fdf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to the object you select, the Migrate... utility collects any other
    object that your selected object relies on to work. Because our Game Mode uses
    the VRPawn as its default pawn, the Migrate... utility will collect the pawn,
    as well as the teleport indicator we made for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99ea7613-1e40-499b-a43d-bf3f54d337bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Hit OK, and when you're asked where to put the new content, select your new
    project's `Content` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Great! Copies of your game mode and pawn have now been added to your new project.
  prefs: []
  type: TYPE_NORMAL
- en: We also mapped a few inputs, and we're going to need those too.
  prefs: []
  type: TYPE_NORMAL
- en: Copying input bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remember when we mentioned that input mappings are just text entries in `DefaultInput.ini`?
    Since we haven''t mapped any inputs in our new project, we can recreate the old
    project''s input bindings by just copying the `DefaultInput.ini` file. You could
    just as easily recreate the inputs using the Project Settings menu, but it''s
    faster to do it this way when you can get away with it:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to your old project's `Config` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `DefaultInput.ini` and copy it to your new project's `Config` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you open it up, you''ll see that it contains the input bindings we created,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a79d9be-4067-4c64-bccf-d0d76e8f8198.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up new project to use the migrated game mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve copied our Game Mode and our Pawn, and our input bindings have
    been set up, we can return to our new project:'
  prefs: []
  type: TYPE_NORMAL
- en: If you hit File | Recent Projects, it should be listed there, but if not, use
    File | Open Project to navigate to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s set up our project to use the game mode we just brought over:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Project Settings | Project | Maps & Modes, and under Default Modes, set
    Default GameMode to `BP_VRGameMode`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will cause this game mode to be used on any map in our project, unless
    we override it. As you'll recall, this game mode tells the project to load up
    our VRPawn.
  prefs: []
  type: TYPE_NORMAL
- en: Additional project settings for VR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remember to set those other VR-relevant settings we described in [Chapter 3](d32af29c-fd54-4d92-95df-30f74ad63a72.xhtml),
    *Hello World – Your First VR Project*, as well:'
  prefs: []
  type: TYPE_NORMAL
- en: Project Settings | Engine | Rendering | VR | Instanced Stereo: True
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Settings | Engine | Rendering | VR | Round Robin Occlusion Queries: True
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Settings | Engine | Rendering | Forward Renderer | Forward Shading: True
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Settings | Engine | Rendering | Default Settings | Anti-Aliasing Method: MSAA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Settings | Engine | Rendering | Default Settings | Ambient Occlusion
    Static Fraction: False
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Settings | Project | Description | Settings | Start in VR: True
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, remember that you shouldn't follow these blindly. For lots of VR projects,
    forward shading will be the way to go, but you should always put a little bit
    of thought into whether the particular thing you're doing would work better with
    the deferred shading model. (This may be the case if you're going to do a lot
    of dynamic lighting and reflective surfaces.) The same goes for the anti-aliasing
    method. MSAA is usually what you'll want if you're doing forward shading, but
    there are instances in which temporal anti-aliasing or FXAA will look better.
    Instanced Stereo is pretty much always something you'll want, and the same goes
    for the Round-Robin Occlusion Queries.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our migrated game mode and pawn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s test it before we do anything else:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag a Nav Mesh Bounds Volume onto the default map that opened with our project,
    and scale it to cover the entire floor. (Remember that you can hit *P* to view
    it.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch a VR Preview and verify that you can teleport around your map and use
    seamless movement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Excellent. This quick test allows us to verify that the game mode we brought
    over from the other project has loaded and it's spawning an instance of our VR
    Pawn at the player start.
  prefs: []
  type: TYPE_NORMAL
- en: Test things as you build them, a step at a time. It's far easier to find the
    source of a bug after a few changes than after a lot of changes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding scenery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s bring in some scenery so that we have a place to play:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up your Epic Games Launcher and in the Marketplace, search for Soul: City.
    (It''s free.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit Add To Project, and add it to the project you're working on now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once it's done, reopen your project if you closed it, and open Content | Soul
    City | Maps | LV_Soul_Slum_Mobile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Grab a coffee while your shaders compile. Now, we should set up our project
    to open this map automatically.
  prefs: []
  type: TYPE_NORMAL
- en: In Project Settings | Project | Maps & Modes, set Editor Startup Map and Game
    Default Map to `LV_Soul_Slum_Mobile`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a NavMesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're also going to need to add a Nav Mesh Bounds Volume to this scene so that
    we can teleport through it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you learned in the previous chapter, setting up a Bounds volume can be an
    involved process if you want to do it right. For our purposes here, we''re going
    to cheat a little and just drop a volume generally over the bulk of the scene.
    If you''d like to tune the volume further, you can scale it and place it more
    carefully, and use nav modifiers to exclude areas you don''t want. If you want
    to keep it simple, the following settings are good enough for what we''re focusing
    on here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76a5651a-2d5e-4e99-996d-cd9a2c9877aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Location: X=3600, Y=-1200, Z=0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scale: X=100, Y=40, Z=30'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1d22aac-c73c-448d-88fd-6469d6615a2b.png)'
  prefs: []
  type: TYPE_IMG
- en: Our NavMesh is kind of a shambles on this map. If you'd like to clean it up,
    feel free to apply the methods we talked about in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Launch a VR preview and explore the scene a bit. Hmm. Something''s wrong. Our
    input isn''t working correctly. Because we verified on the previous step that
    our pawn works and our input mappings are good, we know that''s not the problem.
    Let''s make sure we''re loading the correct pawn:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up your World Settings, and look at the Game Mode | Game Mode Override.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sure enough, there's another game mode being loaded there. Use the reset arrow
    to clear the overridden game mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's test again. That's much better. Now, we're able to navigate through the
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we''re here and able to walk around, let''s point out a few things about
    this environment. It''s not a perfect environment for a virtual reality project,
    and in this case, that gives us a few useful things to talk about:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scale matters in VR**: First, as we walk around, we can see that the scale
    of certain objects is inconsistent. Some of the staircases appear to be the correct
    size, while others are enormous. We''re not going to do anything about that here,
    but this is an important takeaway: the scale of the objects in your world matters
    a great deal in VR. People have an instinctive sense of how big things are, and
    VR gives them much stronger cues about the sizes of objects than flat screens
    do. If your scale is off, they''ll notice that in VR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lights can cause lens flares in VR**: The other potential issue is the bright
    neon lights. They make for a great-looking environment, but you''re probably noticing
    that they sometimes flare the Fresnel lenses in your headset from certain angles.
    We''re not saying you need to avoid bright lights or contrasts in your scenes,
    but be aware that they can sometimes call attention to the hardware. The takeaway
    here is that you always want to check your artwork in the VR headset in addition
    to the flat screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating hands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a scene to work with, let's get to the meat of this chapter
    and start setting up some interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Before we do anything else, let's improve the way we're representing the motion
    controllers in the scene. Currently, we're using debug meshes, which won't render
    correctly if our user is using a different headset from the one we used when we
    authored the scene. It was good enough to get us going, but now we need to replace
    it with something more permanent.
  prefs: []
  type: TYPE_NORMAL
- en: To get a hand mesh we can use, we're going to raid the VR Template. It's likely
    that, for many of your VR projects, you'll simply begin by creating a project
    based on the VR Template, or you'll migrate the entire MotionController Pawn Blueprint
    into a project you've created, but for our purposes here, we want to build the
    pawn ourselves so that we understand what's in it.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating hand meshes and animations from the VR Template project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you already have an example of the VR Template project created, use File
    > Open Project to open it up. If you don''t already have one, close your current
    project and from your Epic Launcher, launch the engine and create a new project
    using the VR Template. It doesn''t really matter what other settings you use for
    this one—we''re just here for the meshes:'
  prefs: []
  type: TYPE_NORMAL
- en: In the VR Template project's Content Browser, navigate to Content | VirtualReality
    | Mannequin | Animations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the three animation assets, right-click them, and select Asset Actions
    | Migrate. Ignore the blend space and animation blueprint for now—we''re going
    to learn how to make these ourselves:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0a11a901-3060-461a-93c6-d9dcad433527.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You''ll see that the Migrate utility has not only collected the animations
    you selected, but it also found the mesh, its physics asset, and its skeleton,
    along with its material and the textures that feed into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3c36a77-fa76-48cc-b883-8d50c91d3a9c.png)'
  prefs: []
  type: TYPE_IMG
- en: Select your current project's `Content` directory as your destination.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we've collected a few assets we can use, we're ready to return to our
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Hit File | Recent Projects, and open your previous project. (Use File | Open
    Project if it doesn't appear here.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding hand meshes to our motion controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in our current project, we should now have a `VirtualReality` directory
    in our Content Browser, with a `Mannequin` subdirectory containing `Animations`
    and the `Character` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Let's apply these hand meshes to our pawn's motion controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new Blueprint Actor class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we''re going to want to do is create a Blueprint to represent
    them, since we want to animate the hands to respond to the player''s actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in your project's `Blueprints` directory, and select Create Basic
    Asset | Blueprint Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Actor as its parent class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's name it `BP_VRHand`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open it up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We mentioned earlier in this book that a core principle of object-oriented development
    is that we pull things that belong together into self-contained objects that can
    handle their own behaviors. This is a good opportunity to do this, since we're
    about to link animated hand meshes with our motion controllers. We could absolutely
    get away with just adding a pair of skeletal mesh components to our pawn and attaching
    them to our motion controller components, but it's going to be much cleaner and
    ultimately easier to manage if we architect things a little better than that.
  prefs: []
  type: TYPE_NORMAL
- en: Adding motion controller and mesh components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add the components we''re going to need:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a MotionController component to your Components list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the new MotionController component selected, add a Skeletal Mesh component
    so that it becomes a child of the motion controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eb792426-2737-4b91-93b1-00d42b257e08.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's name it `HandMesh`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Skeletal Mesh component''s Details panel, set its Mesh | Skeletal Mesh
    property to `MannequinHand_Right`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5c3075ae-98fd-4640-ab12-49bd26d28e00.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding a Hand variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we''re going to reuse this VRHand for both the right and left hands,
    we need to set up a way for the object to know which hand it''s representing:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a variable to the Variables list of `BP_VRHand` and name it `Hand`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Variable Type to `EController Hand`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set its Instance Editable property to `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7b94bb57-afbb-4445-9514-c19532b567d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You''ll notice that, when you set Instance Editable to true, the eye icon next
    to the variable''s name is open. This indicates that this variable is allowed
    to be set to different values for each separate instance of the object in the
    world. Since we need one of these objects to be set to the right hand and the
    other to the left hand, this is what we want here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbc8ae17-185f-45c1-ab85-fef0003c6ff0.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have an instance-editable Hand variable indicating which hand this
    object is going to represent, we need to tell our MotionController component about
    that too. We're going to do this in the VRHand's Construction Script.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Construction Script to handle updates to the Hand variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you look at the Functions list for your `BP_VRHand` class, you''ll see that
    a Construction Script has been automatically created for you. This is a function
    that runs when the object is created or updated before gameplay has begun. Construction
    Scripts are very useful for synchronizing values that need to be lined up before
    the software runs. In our case, this is exactly what we want. If we change the
    value of this Hand variable, we want the motion controller''s motion source to
    change automatically to match up with it. Let''s make that happen:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up your BP_VRHand's Construction Script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a reference to your Motion Controller component into the Construction Script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag out its output and call `Set Motion Source` on it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d2af2436-de00-43e8-83a6-005e08e7b363.png)'
  prefs: []
  type: TYPE_IMG
- en: Drag a reference to the `Hand` variable into your Construction Script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag its output onto the `Motion Source` input. You''ll see a `Convert EControllerHand
    Enum to Name` node appear automatically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ae339c70-a222-433d-b502-8e0fdf873a8d.png)'
  prefs: []
  type: TYPE_IMG
- en: Some data types can be converted easily into other types. In this case, we're
    converting an enum into a name. **Enum** is short for **enumerator**. An enum
    is a special data type that allows us to create a predefined list of values and
    then use that collection of values as a data type. If you have a known set of
    possible values for a data type, it's far better to use an enum to list them than
    it is to use a name or a string. This prevents a typo from causing a value to
    fail, and compares much, much faster than a string comparison. It's generally
    pretty easy to turn enum values into human-readable values in Blueprint when we
    need them, as we're doing here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, connect your execution output of Construction Script to the `Set Motion
    Source` input, so that your whole Construction Script looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2896a453-4230-4ec2-950c-1d2509fcf690.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding BP_VRHand child actor components to your pawn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s return to our `BP_VRPawn` blueprint now:'
  prefs: []
  type: TYPE_NORMAL
- en: In its Components list, select your Camera Root component, and add a Child Actor
    Component as a child.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `Hand_L`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its Details, under Child Actor Component, set the Child Actor Class to `BP_VRHand`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Camera Root again so that it will be the parent of the next component
    we make, and add another Child Actor component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its class to `BP_VRHand`, and name it `Hand_R`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This time, below the Child Actor Class property, expand the Child Actor Template
    property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set Child Actor Template | Default | Hand to `Right`. (We're able to do this
    because we made this variable instance editable in the preceding steps.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to ensure that the BP_VRHand actors spawned by these components
    know that this pawn is their owner. This is required for the motion controllers
    to register correctly.
  prefs: []
  type: TYPE_NORMAL
- en: In `BP_VRPawn`, find Event BeginPlay in the Event Graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a reference to the `Hand_L` component you just created onto the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag its output and select Get Child Actor to get a reference to the `BP_VRHand`
    object it contains.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the Child Actor output and call Set Owner on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the graph and select Get a Reference to Self to create a Self
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag Self into the Set Owner node's New Owner input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the execution output from Set Tracking Origin into the Set Owner node's
    execution input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this for the `Hand_R` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d4ddcbbc-30f6-4049-abb1-553fb33c76e0.png)'
  prefs: []
  type: TYPE_IMG
- en: Before we do anything else, let's test it.
  prefs: []
  type: TYPE_NORMAL
- en: We should still see our old motion controllers rendered since we haven't gotten
    rid of them yet, but we should now see a pair of hands as well, and they should
    be moving correctly with our motion controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Our hands have a few problems we should fix, though.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing issues with Hand meshes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we look at our hands as they move with the motion controllers, we can see
    that they''re displaying at an unexpected angle:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fix this by setting the `HandMesh` component''s Transform | Rotation
    to 90° around the *X* axis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6c652d73-8d46-4c3e-a36f-193014a8facc.png)'
  prefs: []
  type: TYPE_IMG
- en: Second, they're both appearing as right hand meshes, even though one of them
    is bound to the left hand. We can fix this in our construction script too.
  prefs: []
  type: TYPE_NORMAL
- en: Drag out an `==` operator from our Hand variable's output. Test to see whether
    it's equal to Left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Branch node using this test result as its condition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a reference to your `Hand Mesh` into your construction script graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If Hand `==` Left, call `Set World Scale 3D` on your `Hand Mesh` to X=1.0,
    Y=1.0, and Z=-1.0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e87d46f2-d119-4c57-82b0-cd9807418627.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting the Hand mesh scale to -1 on its *Z* axis mirrors it along that axis,
    which is a spiffy way of creating a left-handed mesh from a right hand without
    having to create a second mesh.
  prefs: []
  type: TYPE_NORMAL
- en: 'Give it another try. The hands should now be angled better, and you should
    now have one left and one right hand. It''s still not perfect, though. The hand
    meshes aren''t quite in the right spot, and as a result, they don''t quite feel
    like our own hands:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `HandMesh` component from your Components list, and set its Details
    | Transform | Location to X=-13.0, Y=0.0, Z=-1.8.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Nudge these values around until they feel about right to you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting the angle of the hands right is very important in VR. As we discussed
    in [Chapter 1](8ad5a719-9b05-467c-ba9b-4467ce678145.xhtml), *Thinking in VR*,
    our proprioceptive sense of where our hands are is very strong, and if they look
    even a little bit out of place, they won't feel real. Take the time to find what
    feels natural here. It's a subtle detail, but it matters.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing references to our old motion controller components in blueprints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve got our hands in place, we need to remove the old, redundant
    motion controller components from our pawn and where we''re referring to them,
    replace those references with references to our new hands. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up your pawn blueprint and select its `MotionController_L` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click it and select Find References (Pressing *Alt* + *Shift* + *F* will
    do this as well):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e4099af1-18d8-4c1e-ad2e-3f87ff5c8511.png)'
  prefs: []
  type: TYPE_IMG
- en: A Find Results panel will open and show you where this component is being used
    in your blueprint. We can see from this list that `MotionController_L` is being
    used in one place in our graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click it to jump to where it''s being used in our Event Graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8874a793-6d8f-48e8-9662-b06486378b41.png)'
  prefs: []
  type: TYPE_IMG
- en: We want to replace our reference to `MotionController_L` with a reference to
    our newly created `Hand_L`.
  prefs: []
  type: TYPE_NORMAL
- en: Drag a reference to `Hand_L` onto your graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can't simply replace a reference to `MotionController_L` with a reference
    to our `Hand_L` object, because that object itself isn't moving with the controller.
    It contains a motion controller component, and the visible Hand Mesh is a child
    of that motion controller. We need to get a reference to that motion controller—or
    even better since the player can see it—to the hand mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a function to get our hand mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we need to do to get access to the internal components of our
    `VRHand` object is to get a reference to the child actor that''s contained within
    our Child Actor Component. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From `Hand_L`, drag out a connector and select Get Child Actor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8cf55bda-db79-4ec9-8c66-7390fe740f90.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember all of the times we mentioned that Unreal Engine is an object-oriented
    environment? We keep coming back to this because it's important. The Child Actor
    reference we just extracted from our Child Actor component is a reference to an
    `Actor` class. As we mentioned in the previous chapters, Actor is the parent class
    for any object that can be placed in the world. The `Actor` class, however, doesn't
    have a Hand Mesh component. It just has the basic stuff required to place any
    object in the world. A `BP_VRHand` object, which is a child of the `Actor` class,
    does contain this component. We need to tell Unreal that the actor we're working
    with in this case is a `BP_VRHand`. We do this using a `Cast` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag a connector from `Child Actor` and select `Cast to BP_VRHand`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a930e668-cc8e-4bb7-adba-4b43e9bed11a.png)'
  prefs: []
  type: TYPE_IMG
- en: This will create a `Cast` node. `Cast` nodes require an execution input because
    they're not guaranteed to succeed. If you try to cast some random actor to a `BP_VRHand`,
    it will fail, because the actor you gave it isn't a `VRHand`. The cast node doesn't
    turn the object into an actor of that type—it tells the system to treat the reference
    as the specified type if it actually is an instance of that type.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to deal with this execution line in a moment, but first, let's get
    the hand mesh from our object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag a connector from the `Cast` node''s `As BP_VRHand` output and select `Get
    HandMesh`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0a2437b2-0a7b-4e80-af3b-cc20b77b2c58.png)'
  prefs: []
  type: TYPE_IMG
- en: We can now feed this into the `GetWorldRotation` node that's currently reading
    from `MotionController_L`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag the `HandMesh` output into `GetWorldRotation`, replacing the old `MotionController_L`
    reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cbcdc4ce-9caf-419b-804d-d9a7d865691d.png)'
  prefs: []
  type: TYPE_IMG
- en: This isn't going to work yet, though, because we haven't connected the execution
    lines to our `Cast` node yet. If you try to compile this right now, you'll see
    a warning on the cast node and an error on `Get HandMesh` because of this.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways we could fix this. We could insert the Cast node into the
    main execution lines from our inputs, and only make the Add Movement Input calls
    if they succeed, but in our case here, there's a cleaner way. We can create a
    *Pure function* to perform the cast.
  prefs: []
  type: TYPE_NORMAL
- en: A **Pure function** is a function that doesn't change the state of the object
    that contains it, and because of this, it doesn't need to be placed into an execution
    line. In our case here, we're just getting a reference to the hand mesh—it doesn't
    matter when we do this because we're not changing anything. We're just reading
    a value, so as long as that happens before we need to use it, that's fine.
  prefs: []
  type: TYPE_NORMAL
- en: Select the Hand_L node, its Child Actor, the Cast, and the Get Hand Mesh nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click and select Collapse to Function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/45e5bf52-fdd9-48e1-abe8-96b05d235b3c.png)'
  prefs: []
  type: TYPE_IMG
- en: Name the function `GetHandMeshForHand`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set its Pure property to `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/87e12995-9226-4f80-a43c-aea3d1e5dbd2.png)'
  prefs: []
  type: TYPE_IMG
- en: You'll notice that, when you did this, the execution pins went away. Now, we
    have a simple, clean node we can use to get our Hand mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Let's improve it. We know we're going to need to do the same operation for the
    right hand, but it would be wasteful to make a second function to do an almost-identical
    job. Let's set this function up so that it can grab either hand.
  prefs: []
  type: TYPE_NORMAL
- en: With the function selected, find its Details | Inputs list, and hit the + button
    to create a new parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the parameter''s type to `EControllerHand` and name it `Hand`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0a989ac8-c9bd-40c1-b49f-a19793c8bac0.png)'
  prefs: []
  type: TYPE_IMG
- en: You'll see that your pure function node now has an input selector, and because
    the input we're using is an enumerator, it already knows what values are available.
    Useful, right?
  prefs: []
  type: TYPE_NORMAL
- en: This is yet another reason why enumerators are superior to strings as data types.
    Please, oh please, with very few exceptions, don't use strings as data types.
    They're slow and massively prone to user error.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to update our function to use this new input.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Get Hand Mesh for Hand` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right now, we're getting a reference to Hand_L, regardless of what the user
    selects for the `Hand` input. It's time to fix that.
  prefs: []
  type: TYPE_NORMAL
- en: Drag a connector from your `Hand` input and create a Select node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the return value from the Select node into the Target input of Child Actor,
    replacing the input from `Hand_L`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the Hand_L reference and feed its output into the selector's Left input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an instance of Hand_R onto the graph and feed it into the selector's Right
    input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can leave the rest of the inputs as Null, as we''re not using them here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5fdf49b6-7ab3-485e-a103-d81a355e8561.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, if the user feeds Left into the `Hand` argument, the `Hand_L` reference
    will be used, and if they feed in Right, it will read from `Hand_R`. We're not
    safely handling cases where the user passes in any other value here, so the function
    would throw an error if the user selected Gun or some other input. Technically,
    this would probably be fine in this case since we know exactly what inputs we
    plan to give it, but for the sake of good practice, let's make it safer.
  prefs: []
  type: TYPE_NORMAL
- en: If we pass a value into the Select node that isn't Left or Right, it's going
    to return a Null (empty) reference. Trying to read a value from an empty reference
    is a bad thing to do. In C++, it will crash your application. In Blueprint, it
    will just throw an error, but it's still not good practice to let it happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag an output from the Select node, and create an IsValid node. You have two
    versions here. Use the macro version (the one with the question mark), as this
    will give you convenient execution pins you can use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7251e35e-efe5-49d3-85bc-1717f72d8d6c.png)'
  prefs: []
  type: TYPE_IMG
- en: Drag the execution pin from the function input into the Exec pin on the `IsValid`
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the IsValid output into your Cast node's input so that the IsValid check
    will happen before the cast is attempted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag out from the Is Not Valid output and select Add Return Node. Don't connect
    anything to the Hand Mesh output here. This will return a Null (empty) value if
    the user passes a bad input into the `Hand` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While we're at it, we should also connect our `Cast` node's Cast Failed output
    to this empty return node, so if the cast fails, it won't try to get the HandMesh
    from a bad object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The completed function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/deb1bd24-1277-4f47-a527-f8b9bc6ae32a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ve now created a pure function that returns the HandMesh contained within
    the child actor component for the supplied hand. Here it is in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c805256e-7c12-4d21-a1b3-eb890a1280d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we've created a clean, easy-to-use function to get our Hand mesh, let's
    use it to replace our `MotionController_R` references as well.
  prefs: []
  type: TYPE_NORMAL
- en: From your Components list, right-click `MotionController_R` and select Find
    References. You'll see that we're using it in two places.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click the first use to jump to that part of the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an instance of the `GetHandMeshForHand` function onto the graph where `MotionController_R`
    is currently being used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Hand drop-down menu, select Right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Press *Ctrl* + drag the output connection from `MotionController_R` onto the
    output connection from `GetHandMeshForHand`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f007673f-122d-4c2f-8b7f-15d946e2d39b.png)'
  prefs: []
  type: TYPE_IMG
- en: Pressing *Ctrl* + dragging is a fast way to move all of the connections to a
    Blueprint node from one pin to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your graph should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c6f288d-c718-4e35-b153-77990fd27829.png)'
  prefs: []
  type: TYPE_IMG
- en: Do the same for the other reference to `MotionController_R`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Components list, delete the `MotionController_L` and `MotionController_R`
    components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test it out. Your motion controllers should be working as they did before, but
    the hand meshes have now replaced the old controller meshes.
  prefs: []
  type: TYPE_NORMAL
- en: Animating our hands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's get our hands to change their posture based on the player's input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we''re going to need to do here is tell the hand when the player
    wants to do something with it. Let''s do this by creating a pair of functions
    on the `BP_VRHand` that can be called from outside:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up your `BP_VRHand` Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new function in its Functions list. Call it `Grab Actor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another function called `Release Actor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside each of these functions, create a Print String node with the name of
    the function in it. Since we''re not going to make these functions do anything
    just yet, we want to be able to see when they''re being called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a2664fdd-60c1-4a9c-8240-40bbe9386e41.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's do a better job of organizing our functions and variables. We haven't
    been doing this yet, but it's good practice.
  prefs: []
  type: TYPE_NORMAL
- en: For both of these functions, set their Details | Graph | Category to `Grabbing`.
    After you've used a category name once, it will appear in the drop-down list for
    other functions and variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A quick word about access specifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we''re here, take note of the Access Specifier property for these functions.
    By default, it''s set to Public. In this case, this is what we want, but let''s
    take a moment to talk about what these access specifiers mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public** functions can be called from outside the class. So, if I create
    a `Foo` class with a public function called `Bar`, I can grab an instance of `Foo`
    from some other blueprint and call its `Bar` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private** functions cannot be called from outside the class. Let''s say that
    the `Bar` function is an internal operation that the `Foo` class uses as part
    of some other operation, and it shouldn''t be called from outside. In that instance,
    the function should be set to private so that nobody else will try to call it
    from outside and it won''t clutter the list of available actions for the class
    in other contexts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protected** functions cannot be called from outside the class, but can be
    called from within child objects of the class. If the `FooChild` class inherited
    from the `Foo` class, and the `Bar` function was private in the `Foo` class, `FooChild`
    would not be allowed to call it. If it was protected, then `FooChild` could call
    it, but it still couldn''t be called from outside the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your general rule of thumb should be to make every function private unless you
    intend to call it from outside the class. Unreal defaults to making functions
    public because this is easy for developers who may not understand access specifiers
    yet, but now that you do, you should be making everything private unless you have
    a reason not to. Early on in your development, when your application is still
    small, this won't make much of a difference, but once it gets big, it will. It's
    a big time saver and debugging aid to be able to look at a function and know that
    it's safe to change it because you can be sure that nobody else is using it.
  prefs: []
  type: TYPE_NORMAL
- en: For these two functions we just created, the default `Public` access specifier
    is correct, because we intend to call them from the pawn.
  prefs: []
  type: TYPE_NORMAL
- en: Calling our grab functions from the pawn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For now, we can close out of `BP_VRHand` and open up `BP_VRPawn`. Before we
    can do much with our pawn, though, we're going to need to add a few more action
    mappings to our project's inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new input action mappings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to do this just as we''ve done previously, using the Input UI
    in our Project Settings. Keep it somewhere in the back of your mind as well that
    these settings are just reading and writing your `DefaultInput.ini`. It''s pretty
    much always a good idea to do your work here, but worthwhile to know what''s really
    happening when you make changes in this interface. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Project Settings | Engine | Input, and expand the Action Mappings list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new Action Mapping named `GrabLeft`, and bind it to `MotionController
    (L) Trigger`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add another new action named `GrabRight`, and bind it to `MotionController
    (R) Trigger`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ccdde9ce-9074-4ea7-b642-99596fbc5ab6.png)'
  prefs: []
  type: TYPE_IMG
- en: Close your project settings and return to your `BP_VRPawn` blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding handlers for new action mappings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve created new input actions in our project settings, let''s get
    our pawn listening for them:'
  prefs: []
  type: TYPE_NORMAL
- en: In your pawn's Event Graph, add an InputAction GrabLeft.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a reference to your Hand_L child actor component onto the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `Get Child Actor` on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Cast` the Child Actor''s output to a `BP_VRHand`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connector from the As BP_VRHand output from the `Cast` node, and call
    `Grab Actor`. You're able to call this function here because we made it public.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `Cast` node from the input action's Pressed output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Call `Grab Actor` if the cast succeeds. The blueprint editor will probably
    connect this for you automatically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d151b385-8798-4c44-9fd8-90f5bc799408.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see here that we stacked the inputs on top of the Cast node. This is
    purely a visual organization strategy. It's often a convenient way of organizing
    your nodes to make it clear that the whole cluster is really just referring to
    a single object.
  prefs: []
  type: TYPE_NORMAL
- en: Drag a marquee over the `Hand_L` node, its `Get Child Actor` call, and the `Cast`
    to select all three nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click them and select Collapse to Macro.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new macro `GetHand_L`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new macro will have automatically inserted itself where these nodes originally
    stood.
  prefs: []
  type: TYPE_NORMAL
- en: Hit *Ctrl* + *W* to duplicate the macro.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the input action's Released output to the new macro's input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `Release Actor` on the As BP_VRHand output from the macro.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we open up the `GetHand_L` macro, we will see that it contains the nodes
    we previously had sitting loose in our graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e49d15fe-cf98-4750-b332-8e5d69738f76.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that we're not doing anything if the cast fails, and in this case,
    that's what we want. If, for some reason, the `Hand_L` class's child actor changed
    or wasn't set, we don't want to try to make any calls on it.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to make the distinction that *macros are not functions*. They
    look like functions and can often be used to do similar jobs, but a macro is really
    just an instruction to the Blueprint compiler to paste its contents into the graph
    where the macro appears. It doesn't have the ability to house local variables
    the way a function does. Macros are very simple—just an automated copy and paste.
    Some developers will advise you to avoid macros outright. This is definitely good
    advice if your understanding of how macros differ from functions is fuzzy, but
    if you understand how they work, they can be very useful. As a good rule of thumb,
    keep your macros very small. If you're doing a lot of work in a macro, you're
    really telling the compiler to paste a ton of nodes into your graph, and it should
    probably be a function in that case. Treat macros as a way of making a reusable
    node that does a simple job. Use them for readability and to make your code easier
    to modify later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s repeat this for our right controller input:'
  prefs: []
  type: TYPE_NORMAL
- en: Select your `GetHand_L` macro from your Macros list, and hit *Ctrl* + *W* to
    duplicate it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the new macro `GetHand_R`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside it, replace the `Hand_L` reference with a reference to `Hand_R`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag two instances of `GetHand_R` onto your graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect them to the InputAction GrabRight node's Pressed and Released pins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `GrabActor` and `ReleaseActor` on their outputs, like you did previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your completed graph should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66bc4299-e3d8-486d-b5b1-6e91e615f55b.png)'
  prefs: []
  type: TYPE_IMG
- en: If you're thinking that we could have copied our GetMeshForHand function and
    modified it to return the `BP_VRHand` reference directly, you're right. We could
    also have modified that function outright and moved the Get HandMesh calls we
    made in the teleport functions outside. There are often many right ways to do
    the same job. In this instance, where we're just doing a simple cast, a pair of
    macros is a nice way of keeping our blueprint readable.
  prefs: []
  type: TYPE_NORMAL
- en: Let's test it. If we've done everything right, we should now see `Grab Actor`
    and `Release Actor` messages appearing in our view when we squeeze and release
    the triggers.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing grab animations in the Hand blueprints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've set up our inputs and set up the `VRPawn` to pass them along
    to their respective motion controllers, let's get those motion controllers animating
    when these inputs are received.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s jump back into our `BP_VRHand` Blueprint:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Variables list of `BP_VRHand`, add a new Boolean variable named `bWantsToGrip`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit *Alt* + drag a setter for `bWantsToGrip` into the `Grab Actor` function
    graph. Set it to true when `Grab Actor` is called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hit *Alt* + drag a setter for `bWantsToGrip` into `Release Actor`. Set it to
    false here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/30920426-f0e5-4583-8f94-8a4ffcc5077b.png)'
  prefs: []
  type: TYPE_IMG
- en: Pressing *Ctrl*+ dragging a variable automatically creates a getter for that
    variable. Pressing *Alt* + dragging a variable creates a setter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Animation Blueprint for the hand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unreal uses Animation Blueprints to control animations on Skeletal Meshes.
    We''re going to need one for our hand:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your content browser, right-click in your project''s `Blueprints` directory,
    and select Create Advanced Asset | Animation | Animation Blueprint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a5a02e55-f40b-4e57-9b53-5db05d8bc15d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A dialog will appear asking for the animation Blueprint''s parent class and
    for the target skeleton it''s going to control:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/655b5933-2b45-4868-a9b4-44ab8f1e4dea.png)'
  prefs: []
  type: TYPE_IMG
- en: Leave the parent class empty, and select `MannequinHand_Right_Skeleton` as its
    Target Skeleton.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `ABP_MannequinHand_Right`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a blend space for our hand animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we want our hand animations to respond to this value. Since we want to
    be able to blend smoothly between different animation poses, our best tool for
    this job is a *Blend Space*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have two types of Blend Space available to you. There''s the standard Blend
    Space, which blends two different axes (this is commonly used for aiming poses
    in shooters), and a simpler blend space that just blends along one axis. This
    is the one we want. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in your `Blueprints` directory, and select Create Advanced Asset
    | Animation | Blend Space 1D.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A dialog will appear asking what skeleton this Blend Space will apply to. Select
    `MannequinHand_Right_Skeleton`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name it `BS_HandGrip`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/184020ca-e2d9-4ae6-9aa3-8087c0660880.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open up the blend space we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/06d88057-4706-4024-b71a-94cae11d2b99.png)'
  prefs: []
  type: TYPE_IMG
- en: The Blend Space editor consists of an Asset Details panel on the left, a preview
    window, the Sample Point workspace at the bottom,
  prefs: []
  type: TYPE_NORMAL
- en: and an animation asset browser in the lower right.
  prefs: []
  type: TYPE_NORMAL
- en: In the lower right-hand corner, you can see the list of animations we migrated
    from the VR template for our hand. It's simply displaying any animation in the
    `Content` directories that's mapped to the Hand Mesh's skeleton.
  prefs: []
  type: TYPE_NORMAL
- en: In the bottom center under the preview, we can see the workspace where we're
    going to construct our blend.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do here is set up the axis we''re going to use for
    our blend. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: In the upper-left corner, find Asset Details | Axis Settings, and expand the
    Horizontal Axis block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Name to `Grip`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Maximum Axis Value to 1.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we have a place to put our animation poses.
  prefs: []
  type: TYPE_NORMAL
- en: From the Asset Browser, drag `MannequinHand_Right_Open` onto the workspace until
    it snaps onto the 0.0 grid line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag `MannequinHand_Right_Grab` onto the 1.0 line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag `MannequinHand_Right_CanGrab` into the middle, at 0.5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Test it out by holding down the *Shift* key and dragging on the workspace.
    We can blend seamlessly between the three animation poses we applied to the Grip
    axis by changing its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d741c4b4-7018-4d3a-87a7-787919687114.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's get this working in our Animation Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring the blend space into the animation blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now use the blend space we just created as an asset in its animation
    blueprint. The animation blueprint is a powerful tool the allows you to control
    the way animations are played on a skeletal mesh. It''s split into two main sections:'
  prefs: []
  type: TYPE_NORMAL
- en: The Anim Graph, which takes animation inputs and processes them to calculate
    the mesh pose on every frame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Event Graph, which behaves similarly to the Blueprints you've already authored
    and is used to process the data that the animation blueprint is going to use to
    decide what animations to play
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s learn how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the animation blueprint we created a moment ago.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Looking at its My Blueprint | Graphs block, you can see that in addition to
    the familiar EventGraph we find in all of our blueprint assets, there's a second
    graph, called AnimGraph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click My Blueprint | Graphs | AnimGraph to open it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/84dbed4f-c0cc-4291-80a3-9abb1beb7b13.png)'
  prefs: []
  type: TYPE_IMG
- en: The **Anim Graph** is responsible for determining the animation pose of its
    controlled skeletal mesh on each tick. We can see here that we have a Blueprint
    graph, but it's different from the event graphs we're used to. Everything in the
    Anim Graph leads to that Final Animation Pose and is used to decide what it's
    going to be. We're not going to go deeply into Animation Blueprints here, as their
    setup is a deep subject and outside the scope of this book but they're worth learning
    about. The Anim Graph for our hands is going to be fairly simple.
  prefs: []
  type: TYPE_NORMAL
- en: From your Content Browser, grab the `BS_HandGrip` Blend Space we created a moment
    ago and drag it onto the Anim Graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag its Animation Pose output to the Result Animation Pose input on the Final
    Animation Pose node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag out a connector from the Grip input on your `BS_HandGrip` node, and promote
    it to a variable. Name the variable `Grip`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/11ba613e-f7c9-434b-b104-50bfbd5481ee.png)'
  prefs: []
  type: TYPE_IMG
- en: Set the `Grip` variable's Slider Range and Value Range minimum values to 0 and
    maximum values to 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compile the blueprint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8fa7f696-3317-4530-bda9-5501bc4bf680.png)'
  prefs: []
  type: TYPE_IMG
- en: In the lower-right corner of the window, you will see an Anim Preview Editor
    tab. The variables you create in your animation blueprint appear here, and you
    can change their values in real time to see how they would affect your animation.
    (You're not actually changing the default value of the variable here—you're just
    previewing the system's behavior with different values.) Give it a try. Mouse
    into the `Grip` value and drag it around to slide between 0.0 and 1.0\. You'll
    see that it's driving the blend space we created, which in turn is driving the
    final animation pose. You can close and open the hand by changing the value of
    the `Grip` float.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get this responding to our user's input.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the animation blueprint to our hand blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to tell our `BP_VRHand` actor that the `HandMesh` component should
    use our new animation blueprint to drive its animation state:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up `BP_VRHand` and select the `HandMesh` Skeletal Mesh component from the
    Components list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its Details | Animation, verify that its Animation Mode is set to Use Animation
    Blueprint. (It should be by default.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the Anim Class drop-down menu to select your new animation blueprint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6c8249e3-562d-453c-b432-6729b49b8199.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's drive the Grip value on the animation blueprint we just connected.
  prefs: []
  type: TYPE_NORMAL
- en: Find the Event Tick in event graph of `BP_VRHand`, or create it if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a reference to `Hand Mesh` onto the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connector from `Hand Mesh` and call `Get Anim Instance` on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a Skeletal Mesh being controlled by an animation blueprint, the Anim Instance
    is going to be a reference to that animation blueprint. Now, since we need to
    access a specific member of that blueprint, we need to cast the anim instance
    to the specific animation blueprint class we're using.
  prefs: []
  type: TYPE_NORMAL
- en: Drag a connector from the `Get Anim Instance` return value and `cast` it to
    our new animation Blueprint class (`ABP_MannequinHand_Right`.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the As ABP_Mannequin Hand Right output, call `Set Grip`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit *Ctrl* + drag `bWantsToGrip` onto the graph to get its value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connector from `bWantsToGrip` and create a `Select` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Select node's Return Value to Set Grip's Grip input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the True value on the Select node to 1.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your graph should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/842e2e06-7fb2-4e94-97b8-a0ef3bfc0327.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's run it and test it out. Okay, good. Our hands are responding to our input.
    They don't look great doing it yet, but we can see that the basics are working.
    When we squeeze the trigger on a motion controller, that input sets `bWantsToGrip`
    to `true`, and on the Tick Event of VRHand, we're setting the value of the Grip
    variable on our Animation Blueprint to 0.0 or 1.0, based on the current value
    of `bWantsToGrip`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's improve things a bit and set the system up to be more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new enumerator for our grip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, we're just driving the `Grip` value on the hand's animation blueprint
    directly, but it really makes more sense to let the animation blueprint handle
    this, and just tell it what's going on. The system that handles animation, after
    all, should be responsible for deciding how it wants to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s give ourselves an easy way to communicate our grip state to the animation
    blueprint. An **enumeration** is ideal for this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click in your Blueprints directory, and select Create Advanced Asset
    | Blueprints | Enumeration. Name it `EGripState`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/278490f6-fac8-4fd3-a042-d0b33c65650b.png)'
  prefs: []
  type: TYPE_IMG
- en: Open up the new enumerator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its Enumerators list, hit New to create a new entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the new entry''s Display Name to `Open`. You can leave its description
    blank:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3cdc8e91-ad75-4e80-9598-23cbb8e5fa23.png)'
  prefs: []
  type: TYPE_IMG
- en: Create another enumerator entry, and name it `Gripping`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the enumerator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we've created a new data type that we can use to store information and
    pass it in and out of objects. Let's add it to our animation blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Open up your animation blueprint and add a new variable to its Variables list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Variable Type to `EGripState`, and name it `GripState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember a moment ago when we noticed that the animation blueprint contained
    two graphs—the **Anim Graph** and an **Event Graph**? Now, we're going to begin
    to make use of the event graph. This is a powerful system. It allows us to keep
    our game logic where it belongs, in the gameplay objects, and keep our animation
    logic where it belongs, in the animation blueprint. We can pass a value into the
    animation blueprint, and then in its event graph, determine what we want it to
    do with that input.
  prefs: []
  type: TYPE_NORMAL
- en: In your animation blueprint's Event Graph, find the Event Blueprint Update Animation
    node, or create one if it isn't already present. This is the equivalent of a tick
    event in an animation blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Ctrl* + drag a reference to your new `Grip State` variable onto the event
    graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connector from its output and create a Select node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll notice that, when you create a Select node from an enum, it''s automatically
    populated with that enum''s available values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cdb551b-0401-4a4a-9fc5-0bd87b47550d.png)'
  prefs: []
  type: TYPE_IMG
- en: Hit *Alt* + drag a reference to the `Grip` variable onto the graph to create
    a setter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the output from the Select node into the Grip setter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Gripping value to 1.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Anim Preview editor, verify that changing Grip State from Open to Gripping
    closes the hand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d8db3fd1-d162-4914-8d4d-cc181a27e8fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s update `BP_VRHand` to send the enum value instead of a grip value:'
  prefs: []
  type: TYPE_NORMAL
- en: Back in your BP_VRHand's `Event Tick`, delete the `Grip` setter and the select
    node feeding it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag out a connector from the `Cast` output, and select `Set Grip State`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag out a new Select node from your `bWantsToGrip` getter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the Select node's output into the `GripState` setter's input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the True value of the Select node to `Gripping`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your graph should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fbb76612-c5de-4a92-b0db-3cacfab3b726.png)'
  prefs: []
  type: TYPE_IMG
- en: Test it out. There's no visible change, right? What we've done here is set up
    our graphs so that we can now modify them more easily. Now that we've verified
    that the new setup is working the same way the old one did, let's jump back into
    the animation blueprint and improve the way we handle its input.
  prefs: []
  type: TYPE_NORMAL
- en: Smoothing out our grip animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Snapping between the open and closed animation poses looks awful. Let''s smooth
    this out by transitioning between the values over time:'
  prefs: []
  type: TYPE_NORMAL
- en: Jump back to your animation blueprint's Event Graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click and add an `FInterp to Constant` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag your `Grip` variable onto its Current input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the output of your Grip State Select node onto its Target input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the Delta Time X value from `Event Blueprint Update Animation` into its
    Delta Time input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag out a connector from its `Interp Speed` input and promote it to a variable
    named `Interp Speed`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the Blueprint and set `Interp Speed` to 7.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the output from `FInterpToConstant` to the `Grip` setter''s input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/382eb742-d26e-4433-a126-cb9f18fba11e.png)'
  prefs: []
  type: TYPE_IMG
- en: Test it out. That's much better. Now, our hand is interpolating between poses
    instead of just snapping to the value. What's happening here is the Interp to
    Constant node is managing a smooth transition to a new target value that was selected
    by Grip State over the duration specified by InterpSpeed. If we want the transition
    to happen faster, we can just reduce Interp Speed. If we want it longer, just
    make Interp Speed larger.
  prefs: []
  type: TYPE_NORMAL
- en: As simple as this example is, it begins to show the power and flexibility animation
    blueprints provide. We can easily communicate state information from the VRHand
    blueprint, telling the animation blueprint what we're trying to do, and then do
    whatever we'd like to do to illustrate that state in the animation blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was another involved chapter. We did a lot here. We began by creating a
    new project and migrating our VRPawn blueprints, along with their required objects,
    into the new project. We learned a quick way of recreating input bindings by copying
    the contents of `DefaultInput.ini` to a new project. We then added the Soul:City
    assets and maps to our project and set up a navmesh so that we could explore it.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we got to the meat of this chapter. We scavenged a hand mesh from the
    VR Template project and created a `Blueprint` class to drive their behavior. We
    learned how to use construction scripts to change objects when they're created,
    both in the editor and in-game. We learned how to create child actor components
    inside our pawn and how to use them in blueprints. We learned how to create an
    animation blend space and an animation blueprint to animate our hand meshes and
    how to use an enumerator to pass state information into the animation blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to learn how to use these hands to pick up
    objects. We'll learn how to use blueprint interfaces to enable function calls
    to be made on a wide variety of objects and how to detect actors we can pick up.
    We'll also learn a bit about using haptic feedback effects to indicate to players
    when they've made contact with an object they can pick up.
  prefs: []
  type: TYPE_NORMAL
