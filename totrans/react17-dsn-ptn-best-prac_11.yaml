- en: Making Your Components Look Beautiful
  prefs: []
  type: TYPE_NORMAL
- en: Our journey into React best practices and design patterns has now reached the
    point where we want to make our components look beautiful. To do that, we will
    go through all the reasons why regular CSS may not be the best approach for styling
    components, and we will check out various alternative solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with inline styles, then Radium, CSS modules, and `styled-components`,
    this chapter will guide you through the magical world of CSS in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Common problems with regular CSS at scale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What it means to use inline styles in React and the downsides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the Radium library can help fix issues of inline styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up a project from scratch using Webpack and CSS modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Features of CSS modules and why they represent a great solution to avoid global
    CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`styled-components`, a new library that offers a modern approach to styling
    React components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js 12+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter in the book''s GitHub repository: [https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter08).'
  prefs: []
  type: TYPE_NORMAL
- en: CSS in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the community, everyone agrees that a revolution took place in the styling
    of React components in November 2014, when  Christopher Chedeaugave a talk at
    the NationJS conference.
  prefs: []
  type: TYPE_NORMAL
- en: Also known as  **vjeux** on the internet,  Christopher  works at Facebook and
    contributes to React. In his talk, he went through all the problems related to
    CSS on the scale  that they were facing at Facebook. It is worth understanding
    all of them because some are  pretty  common and they will help us  introduce  concepts
    such as  inline styles and  locally scoped class names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of the issues with CSS, basically problems with CSS
    at scale:'
  prefs: []
  type: TYPE_NORMAL
- en: Global namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dead code elimination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-deterministic resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first well-known problem of CSS is that all the selectors are global. No
    matter how we organize our styles, using namespaces or a procedure such as the
    **Block,** **Element,** **Modifier** (**BEM**) methodology, in the end, we are
    always polluting the global namespace, which we all know is wrong. It is not only
    wrong in principle, but it also leads to many errors in big code bases, and it
    makes maintainability very hard in the long term. Working with big teams, it is
    non-trivial to know whether a particular class or element has already been styled,
    and most of the time, we tend to add more classes instead of reusing existing
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: The second problem with CSS regards the definition of the dependencies. It is
    very hard, in fact, to state clearly  that a particular component depends on a
    specific CSS and that the CSS has to be loaded for the style to be applied. Since
    styles are global, any style from any file can be applied to any element, and
    losing control is very easy.
  prefs: []
  type: TYPE_NORMAL
- en: The third is that frontend developers tend to use preprocessors to be able to
    split their CSS into submodules, but in the end, a big, global CSS bundle is generated
    for the browser. Since CSS code bases tend to become huge quickly, we lose control
    over them, and the third problem is to do with  **dead code elimination**. It
    is not easy to  identify quickly  which styles belong to which component, and
    this makes deleting code incredibly hard. In fact, due to the cascading nature
    of CSS, removing a selector or a rule can result in an unintended result within
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Another pain of working with CSS concerns the minification of the selectors
    and the class names, both in the CSS and in the JavaScript application. It might
    seem an easy task but it is not, especially when classes are applied on the fly
    or concatenated in the client; this is the fourth problem.
  prefs: []
  type: TYPE_NORMAL
- en: Not being able to minify and optimize class names is pretty bad for performance,
    and it can make a huge difference to the size of the CSS. Another pretty common
    operation that is non-trivial with regular CSS is sharing constants between the
    styles and the client application. We often need to know the height of a header,
    for example, to recalculate the position of other elements that depend on it.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, we read the value in the client using the JavaScript APIs, but the
    optimal solution would be to share constants and avoid doing expensive calculations
    at runtime. This represents the fifth problem that vjeux and the other developers
    at Facebook tried to solve.
  prefs: []
  type: TYPE_NORMAL
- en: The sixth issue concerns the non-deterministic resolution of CSS. In fact, in
    CSS, the order matters, and if the CSS is loaded on demand, the order is not guaranteed,
    which leads to the wrong styles being applied to the elements.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose, for example, that we want to optimize the way we request CSS, loading
    the CSS related to a particular page only when the users navigate to it. If the
    CSS related to this last page has some rules that also apply to the elements of
    different pages, the fact that it has been loaded last could affect the styling
    of the rest of the app. For example, if the user goes back to the previous page,
    they might see a page with a UI that is slightly different than the first time
    they visited it.
  prefs: []
  type: TYPE_NORMAL
- en: It is incredibly hard to control all the various combinations of styles, rules,
    and navigation paths, but again, being able to load the CSS when needed could
    have a critical impact on the performance of a web application.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, the seventh problem of CSS, according to  Christopher Chedeau,
    is related to isolation. In CSS, it is almost impossible to achieve proper isolation
    between files or components. Selectors are global, and they can easily be overwritten.
    It is tricky to predict the final style of an element just by knowing the class
    names applied to it because styles are not isolated and other rules in other parts
    of the application can affect unrelated elements. This can be solved by using
    inline styles.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will look at what it means to use inline styles
    with React and the benefits and downsides of it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and implementing inline styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The official React documentation suggests developers use inline styles to style
    their React components. This seems  odd  because we all learned in past years
    that separating the concerns is important and we should not mix markup and CSS.
  prefs: []
  type: TYPE_NORMAL
- en: React tries to change the concept of separation of concerns by moving it from
    the separation of technologies to the separation of components. Separating markup,
    styling, and logic into different files when they are tightly coupled and where
    one cannot work without the other is just an illusion. Even if it helps keep the
    project structure cleaner, it does not give any real benefit.
  prefs: []
  type: TYPE_NORMAL
- en: In React, we compose components to  create  applications where components are
    a fundamental unit of our structure. We should be able to move components across
    the application, and they should provide the same result regarding both logic
    and UI, no matter where they get rendered.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the reasons why collocating the styles within our components
    and applying them using inline styles on the elements could make sense in React.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at an example of what it means to use the style attribute
    of the nodes to apply the styling to our components in React. We are going to
    create a button with the text  `Click me!` and we are going to apply color and
    background color to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is pretty easy to style elements with inline styles in React.
    We just have to create an object where the attributes are the CSS rules, and the
    values are the values we would use in a regular CSS file.
  prefs: []
  type: TYPE_NORMAL
- en: The only differences are that the hyphenated CSS rules must be camelCased to
    be JavaScript-compliant, and the values are strings, so they have to be wrapped
    in quote marks.
  prefs: []
  type: TYPE_NORMAL
- en: There are some exceptions regarding the vendor prefixes. For example, if we  want  to
    define a transition on  `webkit`, we should use the `WebkitTransition` attribute,
    where the  `webkit`  prefix begins with a capital letter. This rule applies to
    all the vendor prefixes, except  for  `ms`, which is lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: Other use cases are numbers – they can be written without quotes or units of
    measurement and, by default, they are treated as pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following rule applies a height of  `100` pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By using inline styles, we can also do things that are hard to implement with
    regular CSS. For example, we can recalculate some  CSS  values on the client at
    runtime, which is a very powerful concept, as you will see in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you want to create a form field in which the font size changes according
    to its value. So, if the value of the field is `24`, the font size is going to
    be 24 pixels. With normal CSS, this behavior is almost impossible to reproduce
    without putting in  a huge  effort and duplicated code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how easy it is to use inline styles instead, by creating a `FontSize`
    component first and then declare a value state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We implement a simple change handler, where we use the target attribute of
    the event to retrieve the current value of the field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we render the input file of the `number` type, which is a controlled
    component because we keep its value updated by using the state. It also has an
    event handler, which is fired every time the value of the field changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, we use the style attribute of the field to set its  `font-size`
    value. As you can see, we are using the camelCased version of the CSS rule to
    follow the React convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Rendering the preceding component, we can see an input field, which changes
    its font size according to its value. The way it works is that when the value
    changes, we store the new value of the field inside the state. Modifying the state
    forces the component to re-render, and we use the new state value to set the display
    value of the field and its font size; it's easy and powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Every solution in computer science has its downsides, and it always represents
    a trade-off. In the case of inline styles, unfortunately, the problems are many.
  prefs: []
  type: TYPE_NORMAL
- en: For example, with inline styles, it is not possible to use pseudo-selectors
    (for example,  `:hover`) and pseudo-elements, which is a pretty significant limitation
    if you are creating a UI with interactions and animations.
  prefs: []
  type: TYPE_NORMAL
- en: There are some workarounds and, for example, you can always create real elements
    instead of pseudo ones, but for the pseudo-classes, it is necessary to use JavaScript
    to simulate the CSS behavior, which is not optimal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same applies to  **media queries**, which cannot be  defined  using inline
    styles, and it makes it harder to create responsive web applications. Since styles
    are declared using JavaScript objects, it is also not possible to use style fallbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript objects cannot have two attributes with the same name. Style fallbacks
    should be avoided, but it is always good to have the ability to use them if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Another feature of  CSS that it is not possible to emulate using inline styles
    is  **animations**. The workaround here is to define animations globally and use
    them inside the style attribute of the elements. With inline styles, whenever
    we need to override a style with regular CSS, we are always forced to use the  `!important`  keyword,
    which is bad practice because it prevents any other style from being applied to
    the element.
  prefs: []
  type: TYPE_NORMAL
- en: The most difficult thing that happens to work  with  inline styles is debugging.
    We tend to use class names to find elements in the browser DevTools to debug and
    check which styles have been applied. With inline styles, all the styles of the
    items are listed in their `style` attribute, which makes it very hard to check
    and debug the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the button that we created earlier in this section is rendered
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: By itself, it does not seem very hard to read, but if you imagine you have hundreds
    of elements and hundreds of styles, you realize that the problem becomes very
    complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you are debugging a list where every single item has the same `style`
    attribute, and if you modify one on the fly to check the result in the browser,
    you will see that you are applying the styles only to it and not to all the other
    siblings, even if they share the same style.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, if we render our application on the server-side (we will
    cover this topic in  *Chapter 9*, *Server-Side Rendering for Fun and Profit*),
    the size of the page is bigger when using inline styles.
  prefs: []
  type: TYPE_NORMAL
- en: With inline styles, we are putting all the content of the CSS into the markup,
    which adds an extra number of bytes to the file that we send to the clients and
    makes the web application appear slower. Compression algorithms can help with
    that because they can easily compress similar patterns, and, in some cases, loading
    the critical path CSS is a good solution; but in  general, we should try to avoid
    it.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that inline styles give more problems than the problems they try
    to solve. For this reason, the community created different tools to solve the
    problems of inline styles but keeping the styles inside the components, or local
    to the components, to get the best of both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: After  Christopher Chedeau's  talk, a lot of developers started talking about
    inline styles, and many solutions and experiments have been made to find new ways
    of writing CSS in JavaScript. In the beginning, there were two or three solutions,
    while today there are more than 40.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will go through the most popular solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Radium library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first libraries that were created to solve the problems of inline
    styles that we encountered in the previous section is **Radium**. It is maintained
    by the great developers at  Formidable Labs, and it is still one of the most popular
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at how  Radium  works, which problems it solves,
    and why it is a great library to use in conjunction with React for styling components.
    We are going to create a very simple button, similar to the one we built in the
    example earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with a basic button without styling, and we will add some basic
    styling, as well as pseudo-classes and media queries, so that we can learn about
    the main features of the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The button we will start with is created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we have to install Radium using `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the installation is complete, we can import the library and wrap the button
    in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The  `Radium`  function is a **Higher-Order Component** (**HOC**) (see  *Chapter
    4*, *Exploring All Composition Patterns*), which extends the functionalities of
    `Button`, returning a new enhanced component. If we render the button  inside  the
    browser, we will not see anything in particular at the moment, because we are
    not applying any styles to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a simple style object, where we set the background color,
    the padding, the size, and a couple of other CSS properties. As we saw in the
    previous section, inline styles in React are defined using JavaScript objects
    with camelCased CSS properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet is no different from plain inline styles with React,
    and if we pass it to our button as follows, we can see all the styles applied
    to the button inside the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The only difference you can see here is that there is a `data-radium` attribute
    set to  `true`  attached to the element.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have seen that inline styles do not let us define any pseudo-classes;
    let's take a look at how to solve the problem using Radium.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using pseudo-classes, such as  `:hover`, with Radium is pretty straightforward.
    We have to create a  `:hover`  property inside our style object, and Radium will
    do the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you apply this style object to your button and render it on the screen, you
    can see that passing the mouse over the button results in a button with white
    text, as opposed to the default black one. That is great! We can use pseudo-classes
    and inline styles together.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you open your DevTools and try to force  the  `:hover`  status in
    the  `Styles` panel, you will see that nothing happens. The reason you can see
    the hover effect but you cannot simulate it with  CSS  is that Radium uses JavaScript
    to apply and remove the hover state defined in the `style` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you hover over the element with the DevTools open, you can see that the
    `style` string changes and the color gets added to it dynamically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The way Radium works is by adding an event handler for each one of the events
    that can trigger the behavior of pseudo-classes and listening to them.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as one of the events gets fired, Radium changes the state of the component,
    which re-renders with the right style for the state. This might seem weird in
    the beginning, but there are no real downsides to this approach, and the difference
    regarding performance is not perceivable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add new pseudo-classes, for example,  `:active`, and they will work
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Another critical feature that Radium enables is media queries. Media queries
    are crucial for creating responsive applications, and Radium again uses JavaScript
    to enable that CSS feature in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how it works – the API is pretty similar; we have to create
    a new attribute on our style object and nest the styles that must be applied when
    the media query matches inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There is one thing we must do to make media queries work, and that is wrapping
    our application in the  `StyleRoot`  component provided by Radium.
  prefs: []
  type: TYPE_NORMAL
- en: For the media queries to work properly, especially  with  server-side rendering,
    Radium will inject the rules related to the media query in a style element inside
    the **Document Object Model** (**DOM**), with all the properties set as  `!important`.
  prefs: []
  type: TYPE_NORMAL
- en: This is to avoid flickering between the different styles that are applied to
    the document before the library figures out which is the matching query. Implementing
    the styles inside a `style` element prevents this by letting the browser do its
    regular job.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the idea is to import the  `Radium.StyleRoot`  component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can wrap our entire application inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result of this, if you open the DevTools, you can see that Radium injected
    the following style into the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rmq-1d8d7428` class has been applied to the button automatically as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you now resize the browser window, you can see that the button becomes smaller
    for small screens, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to learn how to use the CSS modules.
  prefs: []
  type: TYPE_NORMAL
- en: Using CSS modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you feel that inline styles are not a suitable solution for your project
    and your team, but you still want to keep the styles as close as possible to your
    components, there is a solution for you, called **CSS modules**. The CSS modules
    are CSS files in which all class names and animation names are scoped locally
    by default. Let's see how we can use them in our projects; but first, we need
    to configure Webpack.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack 5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before diving into CSS modules and learning how they work, it is important to
    understand how they were created and the tools that support it.
  prefs: []
  type: TYPE_NORMAL
- en: In  *Chapter 2*,  *Cleaning Up Your Code*, we looked at how we can write ES6
    code and transpile it using Babel and its presets. As soon as the application
    grows, you may want to split  your  code base into modules as well.
  prefs: []
  type: TYPE_NORMAL
- en: You can use Webpack or Browserify to divide the application into small modules
    that you can import whenever you need them, while still creating a big bundle
    for the browser. These tools are called  **module bundlers**, and what they do
    is load all the dependencies of your application into a single bundle that can
    be executed in the browser, which does not have any concept of modules (yet).
  prefs: []
  type: TYPE_NORMAL
- en: In the React world, Webpack is especially popular because it offers many interesting
    and useful features, with the first one being the concept of loaders. With Webpack,
    you can potentially load any dependencies other than JavaScript, if there is a
    loader for it. For example, you can load JSON files, as well as images and other
    assets, inside the bundle.
  prefs: []
  type: TYPE_NORMAL
- en: In May 2015, Mark Dalgleish, one of the creators of CSS modules, figured out
    that you could import CSS inside a Webpack bundle as well, and he pushed the concept
    forward. He thought that, since the  CSS  could be imported locally into a component,
    all the imported class names could be locally scoped as well, this is great because
    this will isolate the styles.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will look at how to set up a very simple Webpack application,
    using Babel to transpile the JavaScript and the CSS modules to load our locally
    scoped CSS into the bundle. We will also go through all the features of CSS modules
    and look at the problems they can solve. The first thing to do is move to an empty
    folder and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will create a  `package.json` file with some defaults.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is time to install the dependencies, with the first one being `webpack`
    and the second being `webpack-dev-server`, which we will use to run the application
    locally and to create the bundle on the fly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Webpack is installed, it is time to install Babel and its loader. Since
    we are using Webpack to create the bundle, we will use the Babel loader to transpile
    our ES6 code within Webpack itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we install `style-loader` and the CSS loader, which are the two loaders
    we need to enable the CSS modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one more thing to do to make things easier, and that is to install
    `html-webpack-plugin`, which is a plugin that can create an HTML page to host
    our JavaScript application on the fly, just by looking into the Webpack configuration
    and without us needing to create a regular file. Also, we need to install the
    `fork-ts-checker-webpack-plugin` package to make TypeScript work with Webpack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, we install `react` and `react-dom` to use them in our simple
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now that all the dependencies are installed, it is time to  configure  everything
    to make it work.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to create a `.babelrc` file in your root path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to do is add an  `npm`  script in  `package.json`  to run the  `webpack-dev-server`,
    which will serve the application in development:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In Webpack 5, you need to use this way to call `webpack` instead of `webpack-dev-server`
    but you still need to have this package installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Webpack needs a configuration file to know how to handle the different types
    of dependencies we are using in our application, and to do so, we must create
    a file called `webpack.config.js`, which exports an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The object we export represents the configuration object used by Webpack to
    create the bundle, and it can have different properties depending on the size
    and the features of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to keep our example very simple, so we are going to add three attributes.
    The first one is `entry`, which tells Webpack where the main file of our application
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The second one is `module`, which is where we tell Webpack how to load the
    external dependencies. It has an attribute called `rules`, where we set a specific
    loader for each one of the file types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We are saying that the files that match the `.ts` or `.tsx` regular expression
    are loaded using `ts-loader` so that they get transpiled and loaded into the bundle.
  prefs: []
  type: TYPE_NORMAL
- en: You may also have noticed that we added our presets in the `.babelrc` file.
    As we saw in  *Chapter 2*,  *Cleaning Up Your Code*,  the presets are sets of
    configuration options that instruct Babel on how to deal with the different types
    of syntax (for example, TSX).
  prefs: []
  type: TYPE_NORMAL
- en: The second entry in the `rules` array tells Webpack what to do when a CSS file
    is imported, and it uses `css-loader` with the `modules` flag enabled to activate
    CSS modules. The result of the transformation is then passed to `style-loader`,
    which injects the styles into the header of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we enable the HTML plugin to generate the page for us, adding the
    `script` tag automatically using the entry path we specified earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete `webpack.config.js` should be as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to configure TypeScript, you need this `tsconfig.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to import `css` files using TypeScript, you need to create a declarations
    file at `src/declarations.d.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to create the main file at `src/index.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you need to create the initial HTML file at `src/index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We are done, and if we run the `npm run dev` command in the terminal and point
    the browser to `http://localhost:8080`, we should be able to see the following
    markup being served:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Perfect – our React application is working! Let's see now how we can add some
    CSS to our project.
  prefs: []
  type: TYPE_NORMAL
- en: Locally scoped CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, it is time to create our app, which will consist of a  simple button, of
    the same sort we used in previous examples. We will use it to show all the features
    of the CSS modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the `src/index.tsx`  file, which is the entry we specified in
    the Webpack configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create a simple button. As usual, we are going to start with a
    non-styled button, and we will add the styles step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can render the button into the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose we want to apply some styles to the button – a background color,
    the size, and so on. We create a regular CSS file, called  `index.css`, and we
    put the following class into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now, we said that with CSS modules we could import the CSS files into the JavaScript;
    let's look at how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside our  `index.js` file where we defined the button component, we can add
    the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The result of this  `import`  statement is a `styles` object, where all the
    attributes are the classes defined in `index.css`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run  `console.log(styles)`, we can see the following object in the DevTools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: So, we have an object where the attributes are the class names and the values
    are (apparently) random strings. We will see later that they are non-random, but
    let's check what we can do with that object first.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the object to set the class name attribute of our button, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If we go back to the browser, we can now see that the styles we defined in
    `index.css`  have been applied to the button. This is not magic, because if we
    check in DevTools, the class that has been applied to the element is the same
    string that''s attached to the `style` object we imported inside our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the header section of the page, we can now see that the same
    class name has also been injected into the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is how the CSS and the style loaders work.
  prefs: []
  type: TYPE_NORMAL
- en: The CSS loader lets you import the CSS files into your JavaScript modules and,
    when the module flag is activated, all the class names are locally scoped to the
    module they are imported into. As we mentioned previously, the string we imported
    was non-random, but it is generated using the hash of the file and some other
    parameters in a way that is unique within the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `style-loader` takes the result of the CSS module's transformation
    and injects the styles inside the header section of the page. This is very powerful
    because we have the full power and expressiveness of the CSS, combined with the
    advantages of having locally scoped class names and explicit dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned at the beginning of this chapter, CSS is global, and that makes
    it very hard to maintain in large applications. With CSS modules, class names
    are locally scoped and they cannot clash with other class names in different parts
    of the application, enforcing a deterministic result.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, explicitly importing the CSS dependencies inside our components helps
    us see clearly which components need which CSS. It is also very useful for eliminating
    dead code because when we delete a component for any reason, we can tell exactly
    which CSS it was using.
  prefs: []
  type: TYPE_NORMAL
- en: CSS modules are regular CSS, so we can use pseudo-classes, media queries, and
    animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can add CSS rules such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be transformed into the following code and injected into the document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The class names get created and they get replaced everywhere the button is used,
    making it reliable and local, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, those class names are great, but they make debugging
    pretty  hard  because we cannot easily tell which classes generated the hash.
    What we can do in development mode is add a special configuration parameter, with
    which we can choose the pattern that's used to produce the scoped class names.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can change the value of the loader as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here,  `localIdentName`  is the parameter, and  `[local]`  and  `[hash:base64:5]`  are
    placeholders for the original class name value and a five-character hash. Other
    available placeholders are `[path]`, which represents the path of the CSS file,
    and `[name]`, which is the name of the source CSS file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activating the previous configuration option, the result we have in the browser
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This is way more readable and easier to debug.
  prefs: []
  type: TYPE_NORMAL
- en: In production, we do not need class names like this, and we are more interested
    in performance, so we may want shorter class names and hashes.
  prefs: []
  type: TYPE_NORMAL
- en: With Webpack, it is pretty straightforward  because  we can have multiple configuration
    files that can be used in the different stages of our application life cycle.
    Also, in production, we may want to extract the CSS file instead of injecting
    it into the browser from the bundle so that we can have a lighter bundle and cache
    the CSS on a Content Delivery Network for better performance.
  prefs: []
  type: TYPE_NORMAL
- en: To do that, you need to install another Webpack plugin, called `mini-css-extract-plugin`,
    which can write an actual CSS file, putting in all the scoped classes that were
    generated from CSS modules.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of features of CSS modules that are worth mentioning.
  prefs: []
  type: TYPE_NORMAL
- en: The first one is the  `global`  keyword. Prefixing  any  class  with  `:global`,
    in fact, means asking CSS modules not to scope the current selector locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say we change our CSS as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This is good if you want to apply styles that cannot be scoped locally, such
    as third-party widgets.
  prefs: []
  type: TYPE_NORMAL
- en: My favorite feature of CSS modules is  **composition**. With composition, we
    can extract classes from the same file or external dependencies and get all the
    styles applied to the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, extract the rule to set the background to red from the rules for
    the button into a separate block, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then compose it inside our button in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The result is that all the rules of the button and all the rules of the  `composes`  declaration
    are applied to the element.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very powerful feature and it works in a fascinating way. You might
    expect that all the composed classes are duplicated inside the classes  where  they
    are referenced as SASS  `@extend`  does, but that is not the case. Simply put,
    all the composed class names are applied one after the other on the component
    in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our specific case, we would have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the CSS that is injected into the page is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our CSS class names have unique names, which is good to isolate
    our styles. Now, let's take a look at the Atomic CSS modules.
  prefs: []
  type: TYPE_NORMAL
- en: Atomic CSS modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It should be clear how composition works and why it is a  very  powerful feature
    of CSS modules. At YPlan, the company where I worked when I started writing this
    book, we tried to push it a step further, combining the  power  of  `composes`  with
    the flexibility of  **Atomic CSS**  (also known as  **Functional CSS**).
  prefs: []
  type: TYPE_NORMAL
- en: Atomic CSS is a way to use CSS where every class has a single rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can create a class to set `margin-bottom`  to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use another one to set `font-weight` to `600`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can apply all those atomic classes to the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This technique is controversial and particularly efficient at the same time.
    It is hard to start using it because you end up having too many classes in your
    markup, which makes it hard to predict the final result. If you think about it,
    it is pretty similar to inline styles, because you apply one class per rule, apart
    from the fact that you are using a shorter class name as a proxy.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest argument against Atomic CSS is usually that you are moving the styling
    logic from the CSS to the markup, which is wrong. Classes are defined in CSS files,
    but they are composed in the views, and every time you have to modify the style
    of an element, you end up editing the markup.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we tried using Atomic CSS for a bit and we found that it
    makes prototyping incredibly fast.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, when all the base rules have been generated, applying those classes
    to the elements and creating new styles is a very quick process, which is good.
    Second, using Atomic CSS, we can control the size of the CSS file, because as
    soon as we create new components with their styles, we are using existing classes
    and we do not need to create new ones, which is great for performance.
  prefs: []
  type: TYPE_NORMAL
- en: So, we tried to solve the problems of  Atomic  CSS using CSS modules and we
    called the technique  **Atomic CSS modules**.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, you start creating your base CSS classes (for example, `mb0`), and
    then, instead of applying the class names one by one in the markup, you compose
    them into placeholder classes using CSS modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This is great because you still keep the styling logic inside the CSS, and the
    CSS module's  `composes`  does the job for you by applying all the single classes
    in the markup.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Here, `title`, `mb0`, and `fw6` are all applied automatically to the element.
    They are scoped locally as well, so we have all the advantages of CSS modules.
  prefs: []
  type: TYPE_NORMAL
- en: React CSS modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Last but not least, there is a great library that can help us work with CSS
    modules. You may have noticed how we were using a `style` object to load all the
    classes of the CSS, and because JavaScript does not support hyphenated attributes,
    we are forced to use a camelCased class name.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if we are referencing a class name that does not exist in the CSS file,
    there is no way to know it, and  `undefined`  is added to the list of classes.
    For these and other useful features, we may want to try a package that makes working
    with CSS modules even smoother.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at what this means by going back to the  `index.tsx` file we were
    using previously in this section with plain CSS modules, and changing it to use
    React CSS modules instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The package is called  `react-css-modules`, and the first thing we must do
    is install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the package is installed, we import it inside our `index.tsx` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We use it as an HOC, passing to it the `Button` component we want to enhance
    and the `styles` object we imported from the CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have to change the implementation of the button to  avoid  using the
    `styles` object. With React CSS modules, we use the  `styleName`  property, which
    is transformed into a regular class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The great thing about this is that we can use the class name as a string (for
    example,  `"button"`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: If we now render `EnhancedButton`  into the DOM, we will see that nothing has
    really changed from before, which means that the library works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we try to change the  `styleName`  property to reference a non-existing
    class name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see the following error in the console of the browser by doing so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This is particularly helpful when the code base grows and we have multiple developers
    working on different components and styles.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing styled-components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a library that is very promising because it takes into account all
    the problems other libraries have encountered in styling components. Different
    paths have been followed for writing  CSS  in JavaScript, and many solutions have
    been tried, so now the time is ripe for a library that takes all the learning
    and then builds something on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The library is conceived and maintained by two popular developers in the JavaScript
    community:  *Glenn Maddern*  and  *Max Stoiberg*. It represents a very modern
    approach to the problem, and it uses edge features of ES2015 and some advanced
    techniques that have been applied to React to provide a complete solution for
    styling.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how it is possible to create the same button we saw in the previous
    sections, and check whether all the CSS features we are interested in (for example,
    pseudo-classes and media queries) work with `styled-components`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to install the library by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the library is installed, we have to import it inside our component''s
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: At that point, we can use the `styled` function to create  any  element by using  `styled.elementName`,
    where  `elementName`  can be a  `div`, a button, or any other valid DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing to do is to define the style of the element  we  are creating
    and to do so, we use  an ES6 feature called **t****agged template literals**,
    which is a way of passing template strings to a function without them being interpolated
    beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the function receives the actual template with all the JavaScript
    expressions, and this makes the library able to use the full power of JavaScript
    to apply the styles to the elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a simple button with a basic styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This *kind-of-weird* syntax returns a proper React component called  `Button`,  which
    renders a button element and applies to it all the styles defined in the template.
    The way the styles are applied is by creating a unique class name, adding it to
    the element, and then injecting the corresponding style in the head of the document.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the component that gets rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The style that gets added to the page is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The good thing about `styled-components` is that it supports almost all the
    features of CSS, which makes it a good candidate to be used in a real-world application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, it supports pseudo-classes using a SASS-like syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'It also supports media queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: There are many other features that this library can bring to your project.
  prefs: []
  type: TYPE_NORMAL
- en: For example, once you have created the button, you can easily override its styles
    and use it multiple times with different properties. Inside the templates, it
    is also possible to use the props that the component received and change the style
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Another great feature is  **theming**. Wrapping your  components  in a `ThemeProvider`
    component, you can inject a theme property down to the three component's children,
    which makes it extremely easy to create UIs where part of the style is shared
    between components and some other properties depend on the currently selected
    theme.
  prefs: []
  type: TYPE_NORMAL
- en: No doubt `styled-components` library is a game-changer when you are taking your
    styles to the next level, at the beginning could seem weird because the way is
    implementing styles with components, but once you get used to I guarantee will
    be your favorite styles package.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at a lot of interesting topics. We started by going
    through the problems of CSS at scale, specifically, the problems that they had
    at Facebook while dealing with CSS. We learned how inline styles work in React
    and why it is good to co-locate the styles within components. We also looked at
    the limitations of inline styles. Then, we moved on to Radium, which solves the
    main problems of inline styles, giving us a clear interface to write our CSS in
    JavaScript. For those who think that inline styles are a bad solution, we moved
    into the world of CSS modules, setting up a simple project from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the CSS files into our components makes the dependencies clear, and
    scoping the class names locally avoids clashes. We looked at how CSS module's
    `composes`  is a great feature, and how we can use it in conjunction with Atomic
    CSS to create a framework for quick prototyping.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we had a quick look at `styled-components`, which is a very promising
    library and is meant to change the way we approach the styling of components  completely.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you have learned about a lot of ways to work with CSS styles with React
    from inline styles to CSS modules or using a library such as `styled-components`.
    In the next chapter, we are going to learn how to implement and get the benefits
    from server-side rendering.
  prefs: []
  type: TYPE_NORMAL
