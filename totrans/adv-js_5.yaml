- en: '*Chapter 5*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Explain functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the key concepts of functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply functional programming concepts to your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build new code bases in the functional programming style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter explains types of programming, including Object-oriented programming
    and Functional Programming, and how to work with different types of functions.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first chapter, we covered many of the new and powerful features released
    in ES6\. We discussed the evolution of JavaScript and highlighted the key additions
    in ES6\. We discussed scope rules, variable declaration, arrow functions, template
    literals, enhanced object properties, destructuring assignment, classes and modules,
    transpiling, and iterators and generators.
  prefs: []
  type: TYPE_NORMAL
- en: In the second chapter, we covered JavaScript's asynchronous programming paradigm.
    We discussed the JavaScript event loop, callbacks, promises, and the async/await
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: In the third chapter, we learned about the Document Object Model (DOM), the
    JavaScript Event object, and the jQuery library.
  prefs: []
  type: TYPE_NORMAL
- en: In the fourth chapter, we discussed testing JavaScript code. We covered the
    reasons for testing and ways to go about adding tests to code. Then, we discussed
    different types of code tests and how they can be applied to your code base. Finally,
    we discussed various JavaScript code-testing frameworks and how tests can be built
    inÂ them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover the functional programming coding principles.
    In the first topic, we will define Object-oriented programming and functional
    programming, discuss the differences between the two, and outline the reasons
    why we use functional programming. Then, in the subsequent sections, we will discuss
    each of the key concepts of functional programming. For each key concept, we will
    outline the definition and show its application to functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Functional Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many different ways to approach software design and construction.
    The two most well-known design philosophies, or programming paradigms, are **Object-oriented
    programming (OOP)** and **Functional Programming (FP)**. A programming paradigm
    is a way of thinking about software design and construction. Programming paradigms
    are based on several defining principles and are used to organize and characterize
    the design and construction of software applications. Functional Programming is
    a programming paradigm focused on building software through expressions and declarations.
    In this section, we will discuss the very basics of Object-Oriented Programming
    and Functional Programming, and compare the two programming paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Object-Oriented Programming (OOP)** is a programming paradigm based on objects
    and statements. Objects are programming abstractions used to organize pieces of
    an application. In OOP, objects usually contain and store data in attributes,
    have procedures they can run in methods, and have some notion of **this** or **self**,
    a way for the object to reference itself. Generally, objects come in the form
    of classes. A **class** can be thought of as the definition of an object, with
    its attributes, methods, and **this** scope. An **object** is the instantiation
    of a class. In OOP, statements are instruction-driven code. This will be covered
    more in the *Declarative Versus Imperative* topic. Many programming languages
    work well for OOP software development. The most popular OOP languages are C++,
    Java, and Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Functional Programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Functional Programming (FP)** is a programming paradigm based on expressions
    and declarations instead of objects and statements. In short, this means that
    FP relies on functions instead of objects to organize code and build applications.
    Functional Programming is thought to have originated from lambda calculus, which
    was created in the 1930s. Functional Programming relies on seven key concepts:
    **declarative functions**, **pure functions**, **higher order functions**, **shared
    state**, **immutability**, **side effects**, and **function composition**. Each
    of these concepts will be covered in a subsequent topic in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Functional Programming is designed to be more concise, predictable, and testable.
    These benefits, however, can result in FP code being denser than other coding
    paradigms. Some of the most common Functional Programming languages are JavaScript,
    PHP, and Python.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative Versus Imperative
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two general ways to think about writing code: **Declarative** and
    **Imperative**. Code written in the Functional Programming paradigm should be
    declarative.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Declarative code** is code that expresses the logic of a computation without
    describing its control flow. Imperative code is code that uses statements to change
    a program''s state.'
  prefs: []
  type: TYPE_NORMAL
- en: These definitions are difficult to understand if you have never studied declarative
    and imperative code before. Declarative code is generally used with Functional
    Programming and imperative code is generally used with Object-Oriented Programming.
    There is no "right answer" when deciding which coding style to use; they both
    have their trade-offs. However, declarative code fits the Functional Programming
    paradigm better than imperative.
  prefs: []
  type: TYPE_NORMAL
- en: Imperative Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Imperative code** is most common in OOP. The technical definition is complicated,
    but we can simplify it. An imperative approach to coding is about HOW you solve
    the problem. Consider finding a table at a restaurant. You approach the host/hostess
    and say "I see that the table in the corner is empty. My wife and I are going
    to walk over and sit down." This is an imperative approach because you describe
    exactly how you are going go from the host/hostess to getting a table for your
    party.'
  prefs: []
  type: TYPE_NORMAL
- en: Declarative Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Declarative programming is most common in FP. The declarative approach to coding
    can be simplified as WHAT we need to do. Consider the restaurant example from
    the previous paragraph. A declarative approach to getting a table would be to
    approach the host/hostess and say "table for two please." We describe what we
    need, not every step we will take to get the table. Declarative programming is
    the act of conforming to the mental model of the developer rather than the operational
    model of the machine. From these definitions and metaphors, we can conclude that
    declarative programming is an abstraction of some imperative implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s move from the metaphor to actual code. Consider the code shown
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 5.1: Declarative versus imperative functions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we create two functions to add the values in an array.
    The first function, `addImperative`, is an imperative approach to this problem.
    The code states exactly how the array will be added, step by step. The second
    function, `addDeclarative`, is a declarative approach to the same problem. The
    code states how the array will be added. It abstracts out much of the imperative
    solution (`for` loop) by using the JavaScript array reduce operation.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to begin writing declarative code instead of imperative code
    is by creating functions. These functions should abstract away the step-by-step
    nature of the imperative parts of your code. Consider array operations such as
    `find`, `map`, and `reduce`. These functions are all array member functions that
    are declarative. They abstract away the step-by-step nature of iterating over
    an array. Using them will help introduce declarative concepts into your code and
    reduce some of the imperative code that you write.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 28: Building Imperative and Declarative Functions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your research team has obtained a list of values from your latest experiment;
    however, due to a calibration error, only some of the data can be used and any
    data that can be used needs to be scaled. You must build a utility function that
    takes in an array, filters out any values less than or equal to 0, scales the
    remaining values by multiplying them by `2`, and returns the final results. First,
    build an imperative function to do this, then build a declarative function to
    do the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create functions using imperative and declarative coding practices, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a function called `imperative` that takes the following approach:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take in an array argument called `arr`. Create an array called `filtered` that
    will hold the filtered values.
  prefs: []
  type: TYPE_NORMAL
- en: Create a `for` loop to step through the input array, `arr`. For each item, check
    the array item value. If greater than `0`, push the value to the filtered array.
  prefs: []
  type: TYPE_NORMAL
- en: Create a `for` loop to step through the filtered array. For each item, multiply
    it by `2` and save it back in the filtered array in the same index.
  prefs: []
  type: TYPE_NORMAL
- en: Return the filtered array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a function called `declarative` that does the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filter the input array with `Array.filter()`. In the filter's `callback` function,
    check whether the value is greater than `0`. If it is, return true; otherwise,
    return false.
  prefs: []
  type: TYPE_NORMAL
- en: Chain a map call to the `filter` output.
  prefs: []
  type: TYPE_NORMAL
- en: Map the filtered array with `Array.map()`.
  prefs: []
  type: TYPE_NORMAL
- en: In the callback, multiply each value by `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Return the modified array.
  prefs: []
  type: TYPE_NORMAL
- en: Create a test value array with values from `-5` to `+5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `imperative` with the values array and log the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `declarative` with the values array and log the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code**'
  prefs: []
  type: TYPE_NORMAL
- en: index.js
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 5.2: Imperative and declarative code comparison'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: https://bit.ly/2skAnic
  prefs: []
  type: TYPE_NORMAL
- en: '**Outcome**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Test values output'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_5.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.1: Test values output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 5.2: The modified array output'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_5.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.2: The modified array output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You have successfully utilized imperative and declarative coding practices to
    write functions.
  prefs: []
  type: TYPE_NORMAL
- en: Pure Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Pure functions** are a key component of Functional Programming. A pure function
    can be defined as a function that does not have any effect on or make use of any
    state outside of the function. A function must meet three key criteria to be considered
    pure:'
  prefs: []
  type: TYPE_NORMAL
- en: A function must always return the same output, when given the same inputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function must have no side effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function must have referential transparency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Same Output Given Same Input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Given a set of input values, a pure function must always return the same value
    when provided those input values. This sounds much more complicated than it is.
    Simply put, the output of a pure function cannot change unless the input values
    are changed. This means that a function''s internal code cannot depend on any
    program state outside of the function. A pure function cannot use any variable
    from outside the function to make calculations or code path decisions. An example
    of this is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 5.3: Relying on an external state'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we create a variable called state with the `prop1`
    property set to `5`. We then define two functions that return the strings `Valid`
    or `Invalid`, depending on a value comparison. In the first function, `notPure`,
    we check the `prop1` value of the state and return a value based on that. In the
    second function, pure, we check the value passed into the function to decide what
    to return. The first function is not a pure function. It relies on a state outside
    of the function to determine the return value of the function. The second function
    is pure because it relies on the input value of the function, not the global state
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: No Side Effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A pure function must have no side effects. This simply means that a pure function
    cannot modify any objects or values passed in by reference. Side effects will
    be discussed in more detail in the *Side Effects* topic. In JavaScript, only objects
    and arrays can be passed into functions by reference. A pure function cannot modify
    these objects or arrays in any way. If your function needs to update or modify
    an array or object internally, we must first create a copy of the array/object.
    It is important to note that, in JavaScript, copying an object or array only copies
    the first level of the entity. This means that if an array or object has arrays
    or objects nested in it, these nested references will not be copied. When the
    copied object is by reference by reference, the nested objects will not have been
    copied, and will also be passed. This means that a nested reference, if not explicitly
    copied, can cause a side effect. To properly copy an object, we must create a
    deep copy. A deep copy of an object is a copy that duplicates all nested references.
    This can be done recursively or through the Node.js `deepcopy` module. An example
    of side effects is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 5.4: Avoiding side effects'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we define two functions, `notPure` and `pure`. Both
    functions add a property to the `input` object passed into the function. The impure
    version of the function (`notPure()`) modifies the `input` object in place. Because
    objects are passed by reference, this update will be seen in all other scopes
    where the object is used. This is a side effect. The pure version of the function
    (`pure()`) creates a deep copy of the object with JSON operations and then adds
    a new property to the new object and returns the new object. Since the object
    was cloned, the original object is not modified. No side effect is created.
  prefs: []
  type: TYPE_NORMAL
- en: Referential Transparency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Referential transparency** is a property of pure functions that makes figuring
    out theÂ function behavior simpler. If a function has referential transparency,
    a call to that function can be replaced with the function call''s resultant value
    (the value returned by the function) without changing the meaning of the code.
    In short, this means that functions should return values that make sense in the
    context of the code they are being used in, and they should not depend on or modify
    states outsideÂ of the function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing pure functions gives us two key benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is that pure functions are very easy to unit test. Pure functions
    do not rely on external states, so there is no other context to consider when
    writing tests. We only need to consider the input and output values.
  prefs: []
  type: TYPE_NORMAL
- en: Second, pure functions make code simpler and more flexible. Pure functions do
    not rely on outside states and do not create side effects. This means that they
    can be used in any special context. They can be used in more places and are therefore
    more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 29: Building Pure Controllers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have been hired as a developer to upgrade an online store's shopping cart
    implementation. Build a function to add items to the shopping cart. Your function
    should be pure. You can assume there is a global array, called `cart`, that contains
    the shopping cart. The function should, at a minimum, take in an item (string)
    and a quantity (`number`). Create the function in the provided file (`exercise-test.js`)
    with the function name `addItem()`. The file will have basic tests to test purity.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build part of an application with pure function concepts, perform the followingÂ steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the test file at **exercises/exercise29/exercise-test.js**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a function called `addItem` that takes in three parameters: `cart`,
    `item`, and `quantity`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Duplicate the `cart` passed into the function and save the duplicated value
    into a variable called `newCart`. Duplicate the `cart` with one of the following
    methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use JSON operations for the simplest duplication: `JSON.parse( JSON.stringify(
    cart ) )`.'
  prefs: []
  type: TYPE_NORMAL
- en: Step through the original cart array with a loop and push each item to a new
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Use `cart.map( () => {} )` since all items in the array are simple types.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `rest/spread` operator, `newCart= [ ...cart ]`, because all items are
    simple types.
  prefs: []
  type: TYPE_NORMAL
- en: Push the item passed into the function, onto the `cart` array, `quantity` number
    of times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the `newCart` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the code provided in `exercise-test.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If an error is thrown, fix the bug in the code and run the test again.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code**'
  prefs: []
  type: TYPE_NORMAL
- en: exercise-solution.js
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 5.5: Function purity testing'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: https://bit.ly/2H2TXJG
  prefs: []
  type: TYPE_NORMAL
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: Returning the new cart array'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_5.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.3: Returning the new cart array'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You have successfully applied the concept of pure functions to build part of
    an application.
  prefs: []
  type: TYPE_NORMAL
- en: Higher Order Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we learned in the first topic, a higher order function is a function that
    either takes another function in as an input argument or returns another function
    as the return value. Nearly all asynchronous code in JavaScript makes use of higher
    order functions by passing callback functions in as input arguments. Aside from
    their prolific use in JavaScript, higher order functions are a key part of Functional
    Programming and are used for three key benefits: abstraction, utilities, and complexity
    reduction.'
  prefs: []
  type: TYPE_NORMAL
- en: Higher order functions are very important for abstraction. Abstraction is a
    way to hide the internal workings or details of a procedure. For example, consider
    the process of cooking a meal from a recipe. A recipe may require you to chop
    a food item. What is chopping? It is an abstraction of an action. The action and
    steps to complete the action are to take a knife, place it over the food item,
    and press downward. Then, move the knife a short distance along the food item
    and repeat the process until no large pieces remain. Chopping is an abstraction
    of this action. It is simpler and quicker to say "chop the carrot" instead of
    the long-form description. As with preparing food, code uses abstraction to wrap
    a complicated procedure and hide the internal workings of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Higher order functions can be very useful for creating functional utilities.
    As programmers, we often create utility functions that are designed to perform
    an action on a set of values. Often, we want to maximize flexibility and create
    functions that work over a wide range of potential input values or formats. Creating
    higher order utility functions that take in some parameters and return a new function
    can be a great way to do this. These functions are often called closures in JavaScript.
    Consider the functions shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 5.6: Higher order utilities'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we have created two utility functions for sorting
    arrays of objects by the value stored in the specified field. The utility functions
    both need the field to be specified. Where they differ is the return value. `SortObjField1`
    is a higher order function that takes in the field name and returns a closure
    function. The closure function takes in the two objects we are trying to sort
    and returns the sorting value. The second helper function, `sortObjField2`, takes
    in the field and the two objects at once and returns the sorting value. The higher
    order utility function is much more powerful because we do not need to know all
    of the values at the same time. We can pass `sortObjField( 'field' )` as a parameter
    to another function to be used in another part of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Higher order functions are also very useful for reducing complexity. Code that
    is longer and more complex is more prone to having bugs. Higher order functions
    abstract away the internal workings of complex parts of the code and can use utility
    functions to reduce the lines of code that need to be written. Both of these effects
    will reduce the size of your code base and therefore reduce the complexity. Making
    the code simpler will help to reduce the time you must spend fixing bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 30: Editing Object Arrays'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The aim is to apply the concepts of higher order functions to edit arrays of
    objects. To edit the arrays using the necessary functions, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an array called `data` that contains the following data: `[ { f1: 6,
    f2: 3 }, { f1: 12, f2: 0 }, { f1: 9, f2: 1 }, { f1: 6, f2: 7 } ]`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function called `swap` that takes in two arguments, `key1` and `key2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `return` statement to the `swap` function. The `return` statement should
    return a function. This function should take in one argument, `obj`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the returned function, using array destructuring, swap the values of
    `key1` and `key2` stored in `obj`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hint: Use `[a, b] = [b, a]` to swap values with array destructuring.'
  prefs: []
  type: TYPE_NORMAL
- en: Return the modified object, `obj`, from the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the data array by calling the `map` function on `data`. Pass a call to
    swap, with the parameters `f1` and `f2`, as the argument for the map function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hint: `data.map( swap( ''f1'', ''f2'' ) );`'
  prefs: []
  type: TYPE_NORMAL
- en: Log the output of the call to `data.map()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code**'
  prefs: []
  type: TYPE_NORMAL
- en: '**index.js**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: https://bit.ly/2D0t70K
  prefs: []
  type: TYPE_NORMAL
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: Final Output](image/Figure_5.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Final Output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Youâve successfully applied the concepts of higher order functions to edit arrays
    ofÂ objects.
  prefs: []
  type: TYPE_NORMAL
- en: Shared State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **shared state** is any variable, object, or memory space that exists in
    a shared scope. Any non-constant variable used by multiple separate scopes, including
    the global scope and closure scopes, is considered to be in a shared state. In
    functional programming, shared states should be avoided. A shared state prevents
    a function from being pure. When the shared state rule is violated and the program
    modifies a variable, a side effect is created. In OOP, shared states are often
    passed around as objects. OOP functions may modify the shared state. This is very
    much against functional programming rules. An example of a shared state is shown
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 5.7: Shared state'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding example, we have a variable in the global scope called `state`.
    In our function called `doSomething`, we reference the variable state to make
    a logical code decision. Since the `state` variable was defined outside of the
    scope of our `doSomething` function and is not an immutable object (an object
    whose state cannot be modified after it has been created), it is considered a
    shared state. This is something that should be avoided in Functional Programming
    because it prevents our functions from being pure.
  prefs: []
  type: TYPE_NORMAL
- en: Shared states must be avoided for several reasons. First, a shared state can
    make it difficult to understand a function. To truly understand how a function
    works and what the output results will be given an input, we must understand the
    entire state that the function operates under. If our function uses a shared state,
    we have a much more complex state to understand before we can properly understand
    the function. It is very difficult to understand a shared state in detail. To
    properly understand a shared state, you must understand how the state is updated
    and how it is used in every function it is shared with.
  prefs: []
  type: TYPE_NORMAL
- en: While it may not sound like a major drawback at first, not understanding how
    our functions work will result in slower development, more bugs, and inadequate
    testing. Shared states slow down development simply because we must take more
    time to understand the functions that rely on them. If we do not take the time
    to understand the shared states and functions that rely on them, then it is likely
    that we will not write code that is efficient and bug-free. This will obviously
    lead to more time spent debugging and refactoring code. Functions that are not
    fully understood tend to be more bug-ridden. If we do not fully understand how
    the function needs to operate under all of the possibilities and limitations defined
    in the shared states, it is likely that we will forget to handle edge cases in
    our development. If these bugs are not found, then faulty code could be released.
    Finally, not understanding functions makes it nearly impossible to fully test
    a function. To fully test any function, we must understand exactly how it will
    operate under all conditions, or in other words, under all states it could be
    called under.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 31: Fixing Shared States'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The aim is to refactor code to remove shared states. To properly refactor the
    code, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the file at `exercises/exercise31/exercise.js`. You will be updating this
    file to solve the exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the code in the file opened in *step 1* and observe the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `getOlder` function declaration to take in a parameter called `age`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the body of `getOlder` to return `age+1` or `++age` instead of modifying
    theÂ global variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `formatName` function declaration to take in two parameters, `first`Â and
    `last`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the body of `formatName` to return the `Mrs. ${first} ${last}` string,Â where
    first and last are the values stored in the input parameters `first`Â andÂ `last`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the call to the `getOlder` function and pass in `person.age` as the parameter.
    Save the returned value into `person.age`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the function call to `formatName` and pass in `person.firstName` and
    `person.lastName` as the parameters. Save the value returned in `person.name`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the code and compare the output to the output from *step 2*. They should
    be the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code**'
  prefs: []
  type: TYPE_NORMAL
- en: '**solution.js**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: https://bit.ly/2CZwyoC
  prefs: []
  type: TYPE_NORMAL
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5: Final Output'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_5.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.5: Final Output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Youâve successfully managed to refactor code to remove shared states.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Immutability is a very simple concept but very important to Functional Programming.
    The textbook definition of **immutability** is simply "something that is not changeable."
    In programming, we use the word to mean objects and variables whose state cannot
    be changed after they have been created.
  prefs: []
  type: TYPE_NORMAL
- en: In software development, values can be passed into functions by reference. When
    a variable is passed by reference, it means that a reference to the memory location
    (a pointer) is passed instead of the serialized value of the object contained
    at that location in memory. Since all of the pointers for a variable passed by
    reference point to the same block of memory, any update to the value of the variable
    passed by reference will be seen by any pointer pointing to that block of memory.
    Any variable passed by reference instead of by value can be considered a shared
    state, since it can be modified by multiple separate scopes. It is important to
    write functions that prevent the mutation of data because any change to values
    passed by reference will act as a change to the shared state. Modifying the variables
    passed by reference will violate the principles of Functional Programming and
    will lead to side effects.
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, the concept of immutability generally applies to variables that
    are passed into, and returned by, functions. In JavaScript, simple types (string,
    number, bool) are passed by value, and complex types (objects, arrays, and so
    on) are passed by reference. Any changes to these complex data types will affect
    all occurrences because they are all essentially just pointers to the same block
    of memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript support for immutability is not very complete. JavaScript does not
    have built-in immutable arrays or objects. It is important to note that the variable
    creation keyword, `const`, will not create an immutable object or array. As discussed
    in the very first chapter, const simply locks the name binding so that the name
    binding cannot be reassigned. It does not prevent the object referenced by the
    variable from being modified. Immutable objects in JavaScript can be created in
    twoÂ ways: with the `freeze` function and with third-party libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Immutable objects can be created with the freeze function. `freeze` is a function
    on the global `Object prototype ( Object.freeze()` ). It takes in a single argument,
    the object to be frozen, and returns that same object. Freeze prevents anything
    from being added to, removed from, or modified in the object. If an array is frozen,
    it will lock the element values and prevent elements from being added to or removed
    from the array. It is important to note that the freeze function is only a shallow
    freeze. Objects and arrays nested as properties (in objects) or elements (in arrays)
    will not be frozen by the `freeze` function. If you want to fully freeze all nested
    properties, you must write a helper function that traverses the object or array
    tree, freezing each nested level, or find a third-party library. The use of `Object.freeze()`
    is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 5.8: Freezing an object'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Immutability in JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Several third-party libraries exist to add immutable functionality to JavaScript.
    There are two libraries that are generally accepted as the best immutability libraries
    in JavaScript. They are **Mori** and **Immutable**. Mori is a library that brings
    ClojurScript's persistent data structures and immutability to JavaScript. **Immutable**
    is Facebook's implementation of an immutability library with a JS API that brings
    many immutable data structures to JavaScript. Both libraries are considered to
    be very efficient and are commonly used in many large projects.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For more information about Mori and Immutable, along with full documentation,
    see the library pages at [https://github.com/swannodette/mori](https://github.com/swannodette/mori)
    and [http://facebook.github.io/immutable-js/](http://facebook.github.io/immutable-js/).
  prefs: []
  type: TYPE_NORMAL
- en: There is one final way to obtain immutability in JavaScript; however, it is
    not true immutability. To avoid using third-party libraries or freezing any object
    or array passed to a function, we can simply create a copy of any variable passed
    by reference and modify the copy instead of the original. This will prevent the
    shared state issue of passing data by reference, but it comes with a memory efficiency
    and inefficiency trade-off. Simply assigning the reference to a new variable will
    not duplicate the data. We can duplicate an object or array in one of three waysâwith
    aÂ third-party library, by traversing the object tree, or by using JSON operations.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party libraries exist to create deep copies of objects. This is generally
    the simplest approach to copying objects. We can also traverse the object's tree
    and copy every value and property into a new object. This will generally require
    us to write and test our own function. Finally, we can use the JSON operations
    stringify and parse to duplicate an object. This is done by first stringifying
    an object, then parsing the string (`JSON.parse( JSON.stringify( obj ) )`). JSON
    operations are usually the simplest approach to duplicating objects, but they
    come with the most drawbacks and limitations. If the object has non-JSON-compatible
    properties, such as functions or classes, this approach will not work. It is also
    very inefficient to convert the entire object into a string and then parse that
    entire string into an object. For small objects, this may not affect performance,
    but if you must copy aÂ large object, it is not recommended that you use this method
    because it is aÂ blocking operation.
  prefs: []
  type: TYPE_NORMAL
- en: Side Effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **side effect** is any secondary effect or reaction that comes from an action
    we take. Side effects can be either good or bad, but are generally unintended.
    In functional programming, side effects are any state change that can be seen
    outside of a function call, with the exception of the function return value. According
    to the rules of functional programming, functions are not allowed to modify any
    states outside of the function. If the function modifies a state, intentionally
    or unintentionally, this is considered a side effect because it breaks the tenets
    of functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Side effects are bad because they make a program more complex. As discussed
    earlier, shared states increase program complexity. Side effects in functions
    modify shared states and therefore increase complexity. Side effects, intentional
    or otherwise, can make code much harder to test and debug. The following list
    shows a simple breakdown of the most common causes of side effects in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying any external state (variable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two variable types include global variables and variables in the parent
    function scope.
  prefs: []
  type: TYPE_NORMAL
- en: The first bullet in this list should be self-explanatory from the definition
    of FP side effects. A change to any external state, including any variable outside
    of the function's scope, is a side effect. It does not matter what level of scope
    the variable has. It can be in the global scope or anywhere up the parent function
    scope tree; any change to a variable not directly scoped in the function is considered
    a side effect.
  prefs: []
  type: TYPE_NORMAL
- en: Input/output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list includes logging to a console, writing to a screen or display, file
    I/O operations, network operations, HTTP requests, message queues, and database
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: The second bullet point in the side effect list is not as intuitive. Consider
    I/O operations for a moment. What do they do? They modify some external resource.
    This could be the contents of the console, the view or display shown on a web
    page, a file in the filesystem, or an external resource only accessed over the
    network. These external resources are not directly scoped to the block of code
    that is modifying them, and they can be modified and viewed from other completely
    unrelated applications. By definition, resources such as the filesystem and console
    are shared states. Modifications to these resources count as side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Starting or ending external processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third bullet point in the side effect list is similar to the second. Starting
    an external process, such as a helper thread to offload some large, synchronous
    amount of work, creates a side effect. When we start a new process, we are directly
    changing the state of our system. A new thread is created and it is outside of
    the scope of the function that created it. By definition, this is a side effect.
  prefs: []
  type: TYPE_NORMAL
- en: Calling any other function with side effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth item in the side effect list is also less intuitive. Any function
    that calls aÂ function with a side effect is considered to have a side effect.
    Consider a program setup where function A calls function B, and function B causes
    a change to the global state. This change to the global state can be prompted
    by either a direct call to function B or by calling function A, which eventually
    calls function B and changes the state. Since a call to function A will still
    result in a global state change, even though the code in function A does not directly
    modify the global state, function AÂ isÂ still considered to have a side effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'While writing FP code, we must consider the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: If any I/O operation causes a side effect, how can we apply FPÂ principles to
    writing useful code without side effects? Since I/O operations cause side effects,
    won't every network call or file system operation used in our code cause a side
    effect? Yes. Side effects from I/O will be caused and they are unavoidable. The
    solution to this issue is to isolate side-effect code from the rest of the software.
    Any code that has a side effect or relies on modules or operations withÂ side effects
    (database operations and so on) must be isolated from code that does not. This
    is usually done with modules. Most frontend and backend frameworks encourage us
    to separate state management from the rest of our code by using modules. Code
    that causes side effects is removed and put into its own module soÂ that the rest
    of the code base can be tested and maintained without side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Side Effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is almost impossible to write a full application without side effects. Web
    applications/servers must handle/make HTTP requests - side effect by definition.
    In order to achieve this, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Isolate code with side effects from the rest of the code base.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separate state management code and code with side effects from the rest of application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These methods make testing and debugging easier.
  prefs: []
  type: TYPE_NORMAL
- en: Function Composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Function composition** is the final key to understanding functional programming.
    Function composition takes many of the concepts learned in this chapter and nicely
    wraps them in the core of functional programming. The widely used definition of
    function composition is that function composition is a mathematical concept that
    allows you to combine multiple functions to create a new function. This definition
    tells us what function composition is, but doesn''t really give us any sense of
    how to compose functions or why we need to use it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we know from the definition, function composition is the act of combining
    functions to create a new one. What does this mean exactly? In mathematics, we
    often see functions composed like so: f(g(x)). If this is not familiar to you,
    in the expression f(g(x)), we pass the variable x into the function g and then
    pass the result of g(x) into the function f. The expression f(g(x)) is evaluated
    from the inside out, from right to left, in the order x, g, f. Every instance
    where the input parameter is used in function g, we can substitute in the value
    of x. Every instance where the input parameter is used in function f, we can substitute
    in the value of g(x). Now, let''s consider this method of function composition
    with code. Consider the code in the following snippet :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 5.10: Function composition'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we create a function to multiply a value by 2 and
    a function to add two numbers. We can use these functions to calculate a value
    in two ways. First, we use these functions independently, one at a time. This
    requires us to create a variable and save the output of the first function, call
    the second function with that value, and then save the result of the second function
    into a variable. This requires two lines of code and two variables. Our second
    option for calculating a value is by using function composition. We simply need
    to call one function inside the input argument of the second function and save
    the resultant variable. This requires one line of code and one variable. As we
    can see from the code in the snippet, using function composition will help simplify
    our code and reduce the number of lines of code we need to write.
  prefs: []
  type: TYPE_NORMAL
- en: Function composition is very useful for reducing the number of lines of code
    we need to write, as well as reducing the complexity of our code. When writing
    code in the Functional Programming paradigm, it is important to recognize instances
    when we can use function composition to our advantage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 5: Recursive Immutability'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You are building an application in JavaScript and your team has been told it
    cannot use any third-party libraries for security reasons. You must now use FP
    principles for this application and need an algorithm to create immutable objects
    and arrays. Create a recursive function that enforces the immutability of objects
    and arrays at all levels of nesting with `Object.freeze()`. For simplicity, you
    can assume there are no null value or classes nested in the objects. Write your
    function in `'Lesson 5/topic f - immutability/activity-test.js'`. This file contains
    code to test your implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To force immutability in objects, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a function called `immutable` that takes in a single argument, `data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Freeze the `data` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop through object values and recursively call the immutable function for each.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Outcome**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6: Returning the new cart array](image/Figure_5.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: Returning the new cart array'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You have successfully demonstrated forcing immutability in objects.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 291.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Functional Programming** is a programming paradigm that focuses on expressions
    and declarations to design an application and build a code base. Functional Programming
    is one of the hot new programming styles and is considered the best style for
    programming in JavaScript. Functional Programming can help our JavaScript be more
    concise, predictable, and testable. Functional Programming is built on seven key
    concepts: declarative functions, pure functions, higher order functions, shared
    state, immutability, side effects, and function composition.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Declarative functions** focus on what the solution or goal is, instead of
    how we get the solution. Declarative functions are designed to abstract away a
    lot of the imperative approach to code. They help developers code more in keeping
    with the mental model of the developer, instead of the operational model of the
    machine running the code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pure functions** are intended to make our code easier to test, easier to
    debug, and more flexible and reusable. All functions we write in JavaScript should
    strive to be pure. Pure functions must always return the same output value when
    given the same input values. They cannot cause any side effects by modifying external
    states and must have referential transparency.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Higher order functions** are one of the most common types of functions used
    in JavaScript asynchronous programming. A higher order function is any function
    that takes a function as an input and returns a function as an output. Higher
    order functions are very useful for abstraction of code, complexity reduction,
    and utility function creation and management. They are the key to closures, which
    allow us toÂ be very flexible with our code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shared states** are one of the most important things to avoid in Functional
    Programming. A shared state is any non-constant variable or non-immutable object
    or memory space that exists in a shared scope. The shared scope could be aÂ global
    scope or any scope up the parent function scope tree. Shared states preventÂ functions
    from being pure and can result in more bugs, inadequate testing, and slower development.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Immutability** is the lack of ability to change something. In JavaScript,
    all variables that are passed by reference should be made immutable. Changes to
    mutable variables passed by reference can cause side effects and unintentionally
    modify states that are not supposed to be shared. Immutability in JavaScript can
    be obtained with the `Object.freeze()` function, third-party libraries, and JSON
    operations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Side effects** in JavaScript are any state change that can be seen from outside
    of a function call, excluding the function''s return value. A side effect can
    be caused by any modification to a shared state variable, any I/O operation, any
    external process execution, or by calling any function with a side effect. It
    can be very difficult to fully eliminate side effects from JavaScript applications.
    To minimize the effect of side effects, we must isolate any code with a side effect
    from the rest of the code base. Code that causes side effects should be moved
    into modules for isolation purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function composition** is the final key concept of Functional Programming.
    We can create complicated and powerful functions simply by combining simpler functions
    in new ways. Function composition is designed to help abstract and reduce the
    complexity of our code.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will be introduced to the basic concepts of server-side
    JavaScript and build a Node.js and Express server.
  prefs: []
  type: TYPE_NORMAL
