- en: Event Registration App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hopefully, you had a lot of fun creating memes and sharing them with your friends!
    You successfully built a Meme Creator in the previous project using HTML5 canvas.
    You also used flexbox to design the page layout and learned a few things regarding
    ES6 modules.
  prefs: []
  type: TYPE_NORMAL
- en: The most important part of the previous chapter was the development environment
    we created with Webpack. It lets us develop applications faster with `HotModuleReplacement`,
    create an optimized production build with single file assets and reduced code
    size, and also hides the original source code from the user, while we can use
    source maps to debug the original code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have module support, we can use it to create modular functions,
    which will allow us to write reusable code that can be used across different parts
    of the project or can also be used with a different project. In this chapter,
    you are going to build an Event Registration app while learning the following
    concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing ES6 modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form validation with JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with dynamic data (data loaded from the server)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making AJAX requests using fetch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with asynchronous functions using Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating charts using Chart.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event - JS meetup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the scenario for our project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You are organizing a JavaScript meetup in your locality. You have invited people
    from schools, colleges, and offices, who are all interested in JavaScript. You
    need to create a website for attendees to register for the event. The website
    should have the following functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: A form to help users register for the event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A page that shows statistics on the number of users interested in the event
    as a chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An about page with event details and the location of the event embedded as a
    Google Map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, most of the people will be using mobile phones to register for the event.
    So, the application should be fully responsive.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the app should look on mobiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Initial project setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started with the project, open up the starter files for Chapter 3 in
    VSCode. Create a `.env` file with the values from the `.env.example` file. Assign
    the following values to each environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NODE_ENV=dev`: Should be set to `production` when generating a build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SERVER_URL=http://localhost:3000`: We will soon have a server running in this
    URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GMAP_KEY`: We are going to use the Google Maps API in this project. You need
    to generate your unique API key to use Google Maps. See: [https://developers.google.com/maps/documentation/javascript/get-api-key](https://developers.google.com/maps/documentation/javascript/get-api-key) to
    generate your API key and add the key to this environment variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Earlier in [Chapter 2](part0046.html#1BRPS0-f852807d0cb141b58fff8f992d32cbb7),
    *Building a Meme Creator*, I mentioned that you cannot access your JavaScript
    variables inside HTML when the modules are bundled with Webpack. In [Chapter 1](part0022.html#KVCC0-f852807d0cb141b58fff8f992d32cbb7),
    *Building a ToDo List*, we used the HTML attribute to call a JavaScript function.
    This might look useful, but it will also expose our object structure to users
    (I'm referring to other developers visiting your page). Users can get a clear
    idea of how the `ToDoClass` class is structured by inspecting the object using
    Chrome DevTools. This should be prevented while building large-scale applications.
    Hence, Webpack does not allow variables to be present in the global scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some plugins will need variables or objects to be present in the global scope
    (like the Google Maps API we are going to use). For this purpose, Webpack provides
    an option to expose some selected objects as libraries to the global scope (inside
    HTML). See the `webpack.config.js` file in the starter files. In the `output`
    section, I have added `library: ''bundle''`, which means if we add the `export`
    keyword to any function, variable or object, they will be accessible inside the
    `bundle` object in the global scope. We will see how to use it while adding Google
    Maps to our app.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the environment variables ready, open up the terminal in the
    project root folder and run `npm install` to install all the dependencies. Once
    the dependencies are installed, hit `npm run watch` in the terminal to start the
    Webpack dev server. You can now see the page in the localhost URL printed by Webpack
    in the console (`http://localhost:8080/`). Take a look at all the pages.
  prefs: []
  type: TYPE_NORMAL
- en: Adding styles to the page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the moment, the page is responsive, since it is built with Bootstrap. However,
    we still need to add a few style changes to the form. It is currently very large
    on desktop screens. Also, we need to align the title to the center of the page.
    Let's add styles for the `index.html` page.
  prefs: []
  type: TYPE_NORMAL
- en: 'To align the form and its title to the center of the page, in the `styles.css`
    file (`src/css/styles.css`), add the following code (make sure the Webpack dev
    server is running):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The styles will be reflected immediately on the page, since `HotModuleReplacement`
    is enabled in Webpack (no more reloading!). Now, add some margin to the title
    and set a minimum width for the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the form will have a minimum width of `500px`. However, we are facing another
    problem! Since the form will always have `500px`, it will go out of the screen
    on mobile devices (mobile users are our primary audience). We need to use media
    queries to overcome this problem. Media queries allow us to add CSS depending
    on the type of medium the page is viewed on. In our case, we need to change `min-width`
    on mobiles. To query mobile devices, add the following style below the previous
    styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will check whether the device width is less than `736px` (usually, mobiles
    fall under this category), and then add `min-width` of `90vw`. `vw` stands for
    the viewport width. `90vw` means 90% of the size of the width of the viewport
    (here, the viewport is the screen).
  prefs: []
  type: TYPE_NORMAL
- en: More information on using media queries can be found on this w3schools page: [https://www.w3schools.com/css/css_rwd_mediaqueries.asp](https://www.w3schools.com/css/css_rwd_mediaqueries.asp).
  prefs: []
  type: TYPE_NORMAL
- en: 'I have used a loading indicator image on the `index.html` and `status.html`
    pages. To specify a size for the image without breaking its original aspect ratio,
    use `max-width` and `max-height` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: See the status page. The loading indicator size will be reduced. We have added
    the necessary styles for our application. Now, it's time to make it work using
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Validating and submitting the form using JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTML Forms are the most important part of web applications, where user input
    is recorded. In our JS Meetup app, we got a nice looking form built with the help
    of Bootstrap. Let''s explore what the form contains using the `index.html` file.
    The form contains four compulsory fields:'
  prefs: []
  type: TYPE_NORMAL
- en: Name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email Address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Phone Number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Age
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And it also contains three optional fields (two of whose values are preselected):'
  prefs: []
  type: TYPE_NORMAL
- en: The user's profession
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: His experience level in JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments on what he expects to learn from this event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since profession and experience level options are preselected with a default
    value, they aren't marked as compulsory to the user. But, during validation, we
    need to consider them as compulsory fields. Only the comments field is optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how our form should work:'
  prefs: []
  type: TYPE_NORMAL
- en: The user fills up all the form details and clicks Submit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The form details will be validated and if any required fields are missing, it
    will highlight the fields with a red border
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the form values are valid, it will then proceed to submit the form to the
    server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the form is submitted, the user will receive a notification that the form
    has been submitted successfully and the form entries will be cleared
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript was initially used as a language for doing form validation in HTML.
    Over the course of time, it has evolved into a full-fledged web application development
    language. Web applications built with JavaScript make a lot of requests to the
    server to provide dynamic data to the user. Such network requests are always asynchronous
    and need to be handled properly.
  prefs: []
  type: TYPE_NORMAL
- en: HTML forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we implement our form validation logic, let''s look into the normal
    workings of the form. Click Submit in the current form. You should get a blank
    page with a message saying Cannot POST /register. That is Webpack dev server''s
    message saying there are no routes configured for `/register` with the `POST`
    method. This is because, in `index.html`, the form is created with the following
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This means the form's action when the Submit button is clicked to send data
    to the `/register` page with the `POST` method. While making network requests,
    `GET` and `POST` are two commonly used HTTP methods or verbs. The `GET` method
    cannot have a request body, so all the data is transmitted via URL as query parameters.
    However, the `POST` method can have a request body, where data can be sent as
    form data or a JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: There are different HTTP methods used for communicating with the server. Check
    out the following REST API Tutorial page for more information on HTTP methods: [http://www.restapitutorial.com/lessons/httpmethods.html](http://www.restapitutorial.com/lessons/httpmethods.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the form sends data in the form of form data using the `POST` method.
    In your `index.html` file, change the form method attribute to `get` and reload
    the page (the Webpack dev server does not automatically reload changes to HTML
    files). Now, click submit. You should see a similar blank page, but the form details
    are now being sent on the URL itself. The URL will now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: All the fields are empty except profession and experience, since they are preselected.
    The form values are added at the end of the route `/register`, followed by a `?`
    symbol, which specifies the next text is the query parameter and the form values
    are separated using the `&` symbol. Since a `GET` request sends data in the URL
    itself, it is not suitable for sending confidential data, such as login details
    or the user details that we are going to send in this form. Hence, the `POST`
    method is chosen to do a form submit. Change the method to post in your `index.html`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to inspect data that is sent using the `POST` request. Open
    Chrome DevTools and select the Network tab. Now type in some details in your form
    and click submit. You should see a new entry in your network requests list with
    the name `register`. If you click on it, it will open a new panel with the request
    details. The request data will be present in the headers tab in the Form Data
    section. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Chrome DevTools has a lot of tools for working with network requests. We are
    only using it to inspect our sent data. But there is a lot more stuff you can
    do with it. As per the preceding image, you can see the form values I have typed
    in my form in the form data section in the Headers tab.
  prefs: []
  type: TYPE_NORMAL
- en: Visit the following Google Developers page: [https://developers.google.com/web/tools/chrome-devtools/](https://developers.google.com/web/tools/chrome-devtools/)
    to learn more on using Chrome DevTools.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have a good idea of how submitting a form works. We do not have any
    pages created in the `/register` route and submitting a form by redirecting it
    to a separate page is no longer a good user experience (we are in the era of **Single-Page
    Applications** (**SPAs**)). Taking this into account, I have created a small Node.js
    server app, which can receive form requests. We are going to disable the default
    form submit action and will be submitting the form with JavaScript as an AJAX
    request.
  prefs: []
  type: TYPE_NORMAL
- en: Reading form data in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Time to code! Keep Webpack dev server running with the `npm run watch` command
    (the `NODE_ENV` variable should be `dev`). Open the project folder in VSCode and
    open the `home.js` file from the `src/js/` directory. I have already added a reference
    to `dist/home.js` in the `index.html` file. I would have also added code to import
    the `general.js` file in `home.js`. Now, add the following code below the import
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new class `Home` and will create a new instance of it when
    the page has completed loading. We need not assign the instance object to any
    variables because we are not going to use it inside the HTML file like we did
    in the ToDo list app. Everything will be handled from JavaScript itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first step is to create a reference to all the input fields in the form
    and the form itself. This includes the form itself and the loading indicator that
    is currently hidden in the page using the `.hidden` Bootstrap class. Add the following
    code to the class''s constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As I mentioned while building the Meme Creator, it is best to store references
    to DOM elements in variables prefixed with  the `$` symbol. Now, we can easily
    identify variables having references to DOM elements from other variables. This
    is purely for development efficiency and is not a strict rule you need to follow.
    In the preceding code, for experience radio buttons, the reference of only the
    first radio button is stored. This is for resetting the radio buttons; to read
    the value of the selected radio buttons, a different method needs to be used.
  prefs: []
  type: TYPE_NORMAL
- en: We can now access all the DOM elements within our `Home` class. The one event
    that is going to trigger the entire form validation process is when the form is
    submitted. The form submit event happens when a DOM element with the attribute
    `type="submit"` inside the `<form>` element is clicked. In our case, the `<button>`
    element contains this attribute and is referenced as the `$submit` variable. Even
    though `$submit` triggers the submit event, the event belongs to the entire form,
    that is, `$form` variable. Hence, we need to add an event listener to `this.$form`
    in our class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are only going to have a single event listener. So, just add the following
    code to the constructor after the preceding variables are declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will attach an event listener to the form and will call the `onFormSubmit()`
    method of the class when the form is submitted with the form submit event as its
    parameter. So, let''s create the `onFormSubmit()` method inside our `Home` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`event.preventDefault()` will prevent the default event action from happening.
    In our case, it will prevent the submission of the form. Open the page in Chrome (`http://localhost:8080/`)
    and try clicking Submit now. If no action occurs, then great! Our JavaScript code
    is blocking the form from being submitted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this function for initiating form validation. The first step in
    form validation is to read the values of all the input elements in the form. Create
    a new method `getFormValues()` inside the `Home` class, which will return the
    values of form fields as a JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'See how I used `document.querySelector()` to read the value of the checked
    radio button? The function is self-explanatory itself. I have added `parseInt()`,
    since the value will be returned as a string and needs to be converted to Int
    for validation purposes. Create a variable inside the `onFormSubmit()` method
    to store the values of all the fields in the form. Your `onFormSubmit()` method
    will now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Try printing the `formValues` variable in the Chrome DevTools console using
    `console.log(formValues)`. You should see all the fields with their respective
    values in a JSON object. Now that we have the required values, our next step is
    to validate the data.
  prefs: []
  type: TYPE_NORMAL
- en: In our JS Meetup app, we only have a single form. But in larger applications,
    you might have more than one form in different parts of the application that do
    the same thing. However, due to design purposes, the forms will have different
    HTML classes and IDs but the form values will remain the same. In such cases,
    the validation logic can be reused across the app. This is a perfect opportunity
    to build your first reusable JavaScript module.
  prefs: []
  type: TYPE_NORMAL
- en: Form validation module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By using Webpack, we now have the ability to create separate modules and import
    them in JavaScript. However, we need some kind of approach to organizing our created
    modules. As the size of the application grows, you might have tens or even hundreds
    of modules. Organizing them in such a way that they can be easily identified will
    greatly help your team, as they will be able to easily find a module when needed
    instead of recreating a module with the same functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our application, let''s create a new folder inside the `src/js/` directory
    called `services`. This directory will contain all the reusable modules. Now,
    inside the `services` directory, create another directory called `formValidation`,
    inside which we will create the `validateRegistrationForm.js` file. Your project
    `src/js/` directory will now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, imagine yourself as a different developer who is looking at this code for
    the first time. Inside the `js` directory, there is another directory called `services`.
    Inside that, `formValidation` is available as a service. You now know that there
    is a service for form validation. If you look inside this directory, it will have
    the `validateRegistrationForm.js` file, which informs you of the purpose of this
    module just by its filename.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to create a validation module for a login form (just an imaginary
    scenario), simply create another file inside the `formValidation` directory with
    the name `validateLoginForm.js`. This way, your code will be easily maintainable
    and scalable by reusing all the modules to a maximum.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry about long filenames! Maintainable code is more important, but if
    the filename is long it makes it easy to understand the purpose of that file.
    But if you are working in a team, stick to the rules of the lint tools used by
    your team.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to build the module! In the `validateRegistrationForm.js` file you just
    created, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Having the same name for the module's file and its default exported item will
    make import statements look easier to understand. You will see that when you import
    this module into your `home.js` file. The preceding function will accept the `formValues`
    (which we read from the form in the previous section) JSON object as the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we write this function, we need to set up validation logic for each
    of the input fields as separate functions. These functions will return true when
    the input satisfies the validation criteria. Let''s start with validating the
    username. Below `validateRegistrationForm()`, create a new function `validateUserName()`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We use this function to check whether the username is at least `3` characters
    long. We use the conditional operator to return `true` if the length is greater
    than `3` and `false` if it is smaller.
  prefs: []
  type: TYPE_NORMAL
- en: We have used conditional operator `()?:` once before in the ToDo list app. If
    you are still having problems understanding this operator, visit the following
    MDN page: [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make this function event shorter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This way, JavaScript will automatically evaluate whether the length is greater
    than three and assign true or false based on the result. Now, to validate the
    email address, we need to use regular expressions. We used a regular expression
    to change the mime type of the image in the Meme Creator app. This time, we'll
    look into how regular expressions work.
  prefs: []
  type: TYPE_NORMAL
- en: Working with regular expressions in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regular expressions (RegExp) are basically a definition of a pattern (such
    as a sequence of characters, numbers, and so on) that can be searched within other
    text. For example, say you need to find all the words in a paragraph that start
    with the letter *a*. Then, in JavaScript, you define the pattern as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Regular expressions are always defined inside `/ /`. In the preceding code
    snippet, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`^` means in the beginning of'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+` means having at least one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This regular expression will match strings that start with the letter *a*.
    You can test these statements in: [https://jsfiddle.net/](https://jsfiddle.net/).
    To test a string with this regular expression, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To validate the email address, use the following function, which contains a
    regular expression to validate an email address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t be overwhelmed by the RegExp, it is something commonly available on
    the internet. Whenever you need regular expressions for common formats, such as
    an email address or phone number, you can find them on the internet. To validate
    a mobile number, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This validates whether the phone number is in the format of `XXX-XXX-XXXX` (this
    format is given in the placeholder of the form).
  prefs: []
  type: TYPE_NORMAL
- en: You will have to write your own regular expressions if your requirement is very
    specific. At that time, refer to the following page: [https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions](https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions).
  prefs: []
  type: TYPE_NORMAL
- en: Email address is validated by default in the form, since the email input field's
    type attribute is set to email. However, it is necessary to validate it in JavaScript,
    as not all browsers might support this attribute and the HTML can be easily edited
    from the Chrome DevTools. The same applies to other fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'To validate age, let''s assume the user should be in the age group 10-25 years:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To validate profession, the accepted values for profession are `school`, `college`, `trainee`,
    and `employee`. They are the values of the `<option>` element of the profession
    selection field in your `index.html` file. To validate `profession`, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript arrays have a method called `indexOf()`. It accepts an array element
    as a parameter and returns the index of the element within the array. However,
    if the element is not present in the array, it returns `-1`. We can use this function
    to check whether the value of profession is one of the accepted values by finding
    its index within the array and checking whether the index is greater than `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to validate experience, the values of the experience radio buttons
    are 1, 2, and 3\. So, experience should be a number between 0-4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the comments field is optional, we do not need to have validation logic
    for this field. Now, inside the `validateRegistrationForm()` function which we
    created initially, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The result object now contains the validation status (`true`/`false`) of each
    of the form inputs. Check whether the form is valid overall. The form is valid
    only if all the properties of the result object is `true`. To check whether all
    the properties of the result object are `true`, we need to use a `for`/`in` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for`/`in` loop iterates over the properties of the object. Since all the
    properties of the `result` object need to be `true`, create a variable `isValid`
    with the initial value `true`. Now, iterate over all the properties of the `result`
    object and simply AND (`&&`) the values with the `isValid` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Generally, you access the property of an object using the dot notation (`.`).
    However, since we are using the `for`/`in` loop, the property name is stored in
    the variable `field`. In this case, we need to access the property using the bracket
    notation `result[field]` if `field` contains the value `age`; this is equivalent
    to `result.age` in dot notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `isValid` variable will be only `true` when all the properties of the result
    object are `true`. This way, we have both the form''s validation status and the
    individual field''s status. The `validateRegistrationForm()` function will return
    both the `isValid` variable and the `result` object as properties of another object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We are using the ES6 feature object literal property value shorthand here. Our
    form validation module is ready! We can import this module into our `home.js`
    file and use it with the Event Registration app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `home.js` file, before the class `Home`, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inside the class `Home` in the `onFormSubmit()` method, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It calls the `validateRegistrationForm()` module we created before with `formValues`
    as its parameter and stores the returned value in the `formStatus` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, it checks whether the entire form is valid using the value of `formStatus.isValid`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is `true`, it calls a method `clearErrors()` to clear all the error highlights
    in the UI (our HTML form) and then calls another method `submitForm()` to submit
    the form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is `false` (the form is not valid), it calls the `clearErrors()` method
    to clear the form and then calls the `highlightErrors()` method with `formStatus.result`,
    which contains validation details of individual fields as a parameter to highlight
    the fields that have errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to create the methods that are being called in the preceding code inside
    the `Home` class, since they are methods of the `Home` class. The working of the
    `clearErrors()` and `highlightErrors()` methods are straightforward. `clearErrors`
    simply removes the `.has-error` class from the parent `<div>` of the input field.
    While `highlightError` adds the `.has-error` class to the parent `<div>` if the
    input field fails validation (if the result of the field is `false`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the `clearErrors()` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for the `highlightErrors()` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, leave the `submitForm()` method empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Open the form on your browser (hopefully you left the Webpack dev server running).
    Try entering some values in the input fields and click Submit. If you entered
    valid input values, it shouldn't perform any action. If you entered invalid input
    entries (as per our validation logic), the input field will be highlighted with
    a red border, since we added the `.has-error` Bootstrap class to the field's parent
    element. If you correct the field with a valid value and click submit again, the
    error should disappear, since we used the `clearErrors()` method to clear all
    the old error highlighting.
  prefs: []
  type: TYPE_NORMAL
- en: Submitting the form using AJAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now in the second half of the form section, submitting the form. We have
    disabled the default submit behavior of our form and we now need to implement
    an AJAX form to submit logic.
  prefs: []
  type: TYPE_NORMAL
- en: AJAX is the abbreviation for **Asynchronous JavaScript And XML** (**AJAX**).
    It is not a programming tool, but it is a concept by which you make a network
    request, get data from the server, and update certain parts of your website without
    having to reload the entire page.
  prefs: []
  type: TYPE_NORMAL
- en: The name Asynchronous JavaScript And XML might sound confusing but, initially,
    XML was widely used to exchange data with the server. We can also use JSON/normal
    text to exchange data with the server.
  prefs: []
  type: TYPE_NORMAL
- en: For submitting the form to the server, I have created a small Node.js server
    (built using express framework) that pretends to save your form details and returns
    a success message. The server is available in `Chapter03` folder of the code files.
    To start the server, simply run `npm install` inside the server's directory, followed
    by the `npm start` command. This will start the server in the `http://localhost:3000/` URL.
    If you open this URL in the browser, you will see a blank page with the message
    Cannot GET /; this means the server is running properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server has two API endpoints, one of which we need to communicate with
    to send the details of the user. This is how the registration API endpoint works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In a real-world JavaScript application, you will have to work with a lot of
    network requests like this. Most of your user actions will trigger an API call
    which needs to be processed by the server. In our scenario, we need to call the
    preceding API to register the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s strategize how the API call should work:'
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, this event is going to be asynchronous. We need to use
    a new concept of ES6, called Promises, to handle this API call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to have another API call in the next section. It's better to create
    the API call as a module-like form validation module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must validate whether the registration is successful in the server using
    the server's response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the whole API call will take some time, we should also show a loading
    indicator to the user during the process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if the registration is successful, we should immediately notify the
    user and clear the form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making network requests in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript has `XMLHttpRequest` for making AJAX network requests. A new specification
    called fetch is introduced in ES6, which makes working with network requests more
    modern and efficient with Promises support. Other than these two methods, jQuery
    has the `$.ajax()` method, which is widely used for making network requests. `Axios.js`
    is another `npm` package that is also widely used for making network requests.
  prefs: []
  type: TYPE_NORMAL
- en: We will use fetch in our application for making network requests.
  prefs: []
  type: TYPE_NORMAL
- en: Fetch does not work with Internet Explorer and requires polyfills. Check out: [https://caniuse.com/](https://caniuse.com/)
    for the browser compatibility of any new `HTML/CSS/Javascript` components you'd
    like to use.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Promise?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll probably be wondering by now what it is that I'm calling a Promise? Well,
    a Promise, as it sounds, is a Promise made by JavaScript that the asynchronous
    function will complete execution at some point.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we came across an asynchronous event: reading the
    contents of a file using `FileReader`. This is how `FileReader` worked:'
  prefs: []
  type: TYPE_NORMAL
- en: It starts reading the file. Since reading is an asynchronous event, other JavaScript
    code will continue execution while reading is still happening.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You might be wondering, w*hat if I need to execute some code only after the
    event is complete?* This is how `FileReader` handles it:'
  prefs: []
  type: TYPE_NORMAL
- en: Once the reading is complete, `FileReader` fires a `load` event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also has an `onload()` method that listens for the `load` event and, when
    the `load` event is triggered, the `onload()` method will start executing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we need to put our required code inside the `onload()` method and it will
    execute only after `FileReader` has completed reading the file contents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This might look like an easier way to handle asynchronous events, but imagine
    if there are multiple asynchronous events that need to happen one after another!
    How many events would you have to fire and how many event listeners would you
    need to keep track of? This will result in code that is very difficult to understand.
    Also, event listeners in JavaScript are expensive resources (they consume a lot
    of memory) and they must be minimized as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Callback functions are used a lot to handle asynchronous events. But if you
    have a lot of asynchronous functions happening one after another, your code will
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: After writing lot of callbacks, your closing brackets will be arranged like
    a pyramid. This is called callback hell. Callback hell is messy and should be
    avoided when building applications. So, callbacks are not useful here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter Promises, a new way to deal with asynchronous events. This is how a JavaScript
    `Promise` works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: A `Promise` constructor creates a function with two parameters, resolve and
    reject, which are functions. Then, `Promise` will return the value only when resolve
    or reject is called. Resolve is called when the asynchronous code is executed
    successfully, and reject is called when an error occurs. Here, `Promise` returns
    a value, `5`, when the asynchronous logic is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Say you have a function called `theAsyncCode()`, which does some asynchronous
    stuff. You also have another function `onlyAfterAsync()` that needs to run strictly
    only after `theAsyncCode()` and uses the value returned by `theAsyncCode()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how you deal with these two functions with Promises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'First, `theAsyncCode()` should return a `Promise` instead of a value. Your
    asynchronous code should be written inside that `Promise`. Then, you write the
    `onlyAfterAsync()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the preceding functions one after another, we need to chain them
    using the `Promise.then().catch()` statements. Here, `Promise` is returned by
    the `theAsyncCode()` function. Hence, the code should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When `theAsyncCode()` executes `resolve(5)`, the `then` method is automatically
    called with the resolved value as its parameter. We can now execute the `onlyAfterAsync()`
    method inside the `then` method. If `theAsyncCode()` executes `reject('an error')`
    instead of `resolve(5)`, it will trigger the `catch` method instead of `then`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have another function, `theAsyncCode2()`, which uses the data returned
    by `theAsyncCode()`, it should be executed before the `onlyAfterAsync()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You just need to update your `.then().catch()` chain, such that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This way, all three functions will be executed one after another. If either
    `theAsyncCode()` or `theAsyncCode2()` returns with `reject()`, then the `catch`
    statement will be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we only need to call a function with the resolved value of the previous
    function in the chain as the parameter, we can further simplify the chain as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This will give the same result. I have set up a small JS fiddle at: [https://jsfiddle.net/jjq60Ly6/4/](https://jsfiddle.net/jjq60Ly6/4/),
    where you can experience the working of Promises in action. Visit the JS fiddle,
    open the Chrome DevTools console, and click Run at the top-left of the JS fiddle
    page. You should see the `console.log` statements printed from the three functions
    in order. Feel free to edit the fiddle and experiment with the Promises.
  prefs: []
  type: TYPE_NORMAL
- en: Shortly after finishing this chapter, ES8 was announced, which confirmed the
    `async` functions to be part of the JavaScript language. ES8's `async` and `await`
    keywords provide an even simpler way to resolve Promises instead of the `.then().catch()`
    chain we used in ES6\. To learn using the `async` functions, go to the following
    MDN page: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the API call module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use a POST API call to register our users. However, in the status section
    of the app, we need to use a `GET` request to show the statistic data of the people
    interested in the event. So, we are going to build a generic API call module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the API call module, inside the `services` directory, create another
    directory called `api` and, inside it, create `apiCall.js`. The structure of your
    `services` directory should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `apiCall.js file`, create the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding function, route is a required parameter, while body and method
    have their default values defined. This means they are optional. If you call the
    function with only one argument, the other two parameters will use their default
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If you call the function with all three parameters, it will work like a normal
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Default parameters are also introduced only in ES6\. We are using default parameters
    because a `GET` request does not require a body attribute. It only sends the data
    as query parameters in the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen the workings of `GET` and `POST` requests in action in
    the default form''s Submit section. Let''s construct an `apiCall` function that
    can do both `GET` and `POST` requests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `apiCall` function, create a new `Promise` object with the name `request`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The fetch API accepts two parameters as input and returns `Promise`, which resolves
    when the network request is complete. The first parameter is the request URL and
    the second parameter contains an object with information regarding the request,
    such as `headers`, `cors`, `method`, `body`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the request details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write the following code inside the request `Promise`. First, since we are
    working with JSON data, we need to create a header with the content type `application/json`.
    We can use the `Headers` constructor for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, using the `headers` created earlier and the `method` variable from the
    parameter, we create the `requestDetails` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that I have included `mode: ''cors''` in `requestDetails`. **Cross-Origin
    Resource Sharing** (**CORS**) allows servers to do cross-domain data transfers
    securely. Imagine you have a website running in `www.mysite.org`. You need to
    make an API call (network request) to another server running in `www.anothersite.org`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, it is a cross-origin request. To make a cross-origin request, the server
    in `www.anothersite.org` must have the `Access-Control-Allow-Origin` headers set
    to allow `www.mysite.org`. Otherwise, browsers will block the cross-origin request
    to prevent unauthorized access to another server. The request from `www.mysite.org`
    should also include `mode: ''cors''` in its request details.'
  prefs: []
  type: TYPE_NORMAL
- en: In our Event Registration app, the Webpack dev server is running in `http://localhost:8080/`,
    while the Node.js server is running in `http://localhost:3000/`. Hence, it is
    a cross-origin request. I have already enabled `Access-Control-Allow-Origin` and
    set `Access-Control-Allow-Headers` so that it won't cause any problems with the
    `apiCall` function.
  prefs: []
  type: TYPE_NORMAL
- en: Detailed information on CORS requests can be found in the following MDN page: [https://developer.mozilla.org/en/docs/Web/HTTP/Access_control_CORS](https://developer.mozilla.org/en/docs/Web/HTTP/Access_control_CORS).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `requestDetails` object should also include a body of the request. However,
    the body should only be included for the `POST` request. Hence, it can be written
    below the `requestDetails` object declaration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This will add the body property for the `POST` requests. To do the fetch request,
    we need to construct the request URL. We have already set the environment variable
    `SERVER_URL=http://localhost:3000`, which Webpack will transform into a global
    variable `SERVER_URL` accessible everywhere inside the JavaScript code. The route
    is passed in the `apiCall()` function''s parameter. The fetch request can be constructed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Here's what the `handleErrors` function does. It will check whether the response
    returned by the server is successful (`response.ok`). If so, it will decode the
    response and return it (`response.json()`). Otherwise, it will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can further simplify the Promise chain using the method we discussed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Fetch has a small problem. It cannot handle timeouts by itself. Imagine the
    server facing a problem and being unable to return a request. In that scenario,
    the fetch will never resolve. To avoid this, we need to do a workaround. Below
    the `request` Promise, create another `Promise` called `timeout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a constant `timeoutDuration` on top of the `apiCall.js` file outside
    the `apicall()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This constant is placed on top of the file so that we can easily change the
    timeout duration in future (easier code maintainability). `timeout` is a simple
    Promise that automatically rejects after a time of 5 seconds (from the `timeoutDuration`
    constant). I have created the server in a way that it responds after 3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, JavaScript has a cool way to resolve multiple Promises, the `Promise.race()`
    method. As the name suggests, this will make two Promises run simultaneously and
    accept the value of the one that is resolved/rejected first. This way, if the
    server doesn''t respond within 3 seconds, a timeout will happen in 5 seconds and
    `apiCall` will be rejected with a timeout! To do this, add the following code
    within the `apiCall()` function after the `request` and `timeout` Promises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `apiCall()` function as a whole returns a Promise which is the resolved
    value of either the `request` or `timeout` Promise (depends on which one of them
    is executed faster). That's it! Our `apiCall` module is now ready to be used within
    our Event Registration app.
  prefs: []
  type: TYPE_NORMAL
- en: If you find the `apiCall` function difficult to understand and follow, read
    it again with the `apiCall.js` file from the `Chapter03` completed code files
    as reference. It will make the explanation much simpler.To learn Promises in detail
    with more examples, read the following Google Developers page: [https://developers.google.com/web/fundamentals/getting-started/primers/promises](https://developers.google.com/web/fundamentals/getting-started/primers/promises)
    and MDN page: [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise).
  prefs: []
  type: TYPE_NORMAL
- en: Other network request methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these links to learn about other plugins/APIs to make network requests
    in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: jQuery, the `$.ajax()` method: [http://api.jquery.com/jquery.ajax/](http://api.jquery.com/jquery.ajax/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XMLHttpRequest`: [https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest](https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Axios.js`: [https://github.com/mzabriskie/axios](https://github.com/mzabriskie/axios)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make fetch work with Internet Explorer, read the following page on how to
    add `polyfill` for fetch: [https://github.com/github/fetch/](https://github.com/github/fetch/).
  prefs: []
  type: TYPE_NORMAL
- en: Back to the form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step to start submitting is to hide the submit button and replace
    it with a loading indicator. This way, the user can''t accidentally click Submit
    twice. Also, the loading indicator serves as an indication that a process is happening
    in the background. In the `home.js` file, inside the `submitForm()` method, add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This will hide the submit button and display the loading indicator. To make
    `apiCall`, we need to import the `apiCall` function and notify the user that the
    request has been completed. I have added a package called `toastr` in the `package.json`
    file. It should have been installed already when you ran the `npm install` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the `home.js` file, add the following import statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This will import `toastr` and its styles file (`toastr.less`), along with the
    recently created `apiCall` module. Now, inside the `submitForm()` method, add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `apiCall()` returns a Promise, we are using a `Promise.then().catch()`
    chain here. When the registration is a success, `toastr` will show a success toast
    in the top-right corner of the page with the message sent by the server. If a
    problem occurs, it will simply show an error toast. Also, we need to clear the
    form using the `this.resetForm()` method. Add the `resetForm()` method inside
    the `Home` class with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Go back to the Event Registration page in Chrome and try submitting the form.
    If all the values are valid, it should successfully submit the form with a success
    toast message and the form values will be reset to their initial values. In real-world
    applications, the server will send a confirmation mail to the user. However, server-side
    coding is beyond the scope of this book. But I would like to explain this a little
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Try turning off the Node.js server and submitting the form. It should throw
    an error. You have successfully completed building your Event Registration form
    while learning some advanced concepts in JavaScript. Now, let's move on to the
    second page of our application--the status page, where we need to show a chart
    for registered user statistics.
  prefs: []
  type: TYPE_NORMAL
- en: Adding charts to the website using Chart.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just created a nice little registration form for our users. It's now time
    to work with the second section of our Event Registration app. The status page
    shows a chart for the number of people interested in the event based on experience,
    profession, and age. If you open the status page now, it should show a data loading...
    message with the loading indicator image. But I have built all the necessary components
    needed for this page in the `status.html` file. They are all currently hidden
    using Bootstrap's `.hidden` class.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what's present in the `status.html` file. Try removing the `.hidden`
    class from each of the following sections to see how they look in the web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'First is the loading indicator section which is currently being displayed on
    the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'It is followed by a section containing an error message to be showed when the
    API call fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'After the preceding sections, we have a tabs section which will provide the
    user with an option to switch between different charts. The code will look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The tabs are nothing but an unordered list with the classes `.nav` and `.nav-tabs`,
    which are styled by Bootstrap into tabs. The tab sections are list items with
    the class `.active` to highlight a selected tab section (`role="presentation"`
    is used for accessibility options). Inside the list items, there are anchor tags
    with an empty `href` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have our chart area with three canvas elements to display charts
    for the three different categories mentioned in the preceding tabs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'As we saw in the previous chapter, canvas elements are best for displaying
    graphics on a web page, since editing the DOM elements is an expensive operation.
    Chart.js uses the canvas element to display the given data as a chart. Let''s strategize
    how the status page should work:'
  prefs: []
  type: TYPE_NORMAL
- en: The loading indicator should be shown while the API call is made to fetch statistic
    data from the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the data is retrieved successfully, the loading indicator should be hidden
    and the tabs section and chart area should become visible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only the canvas corresponding to the selected tab should be visible; other canvas
    elements should be hidden
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pie chart should be added to the canvas using the Chart.js plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If data retrieval fails, all the sections should be hidden and the error section
    should be shown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alright! Let''s get to work. Open the `status.js` file which I already added
    as a reference in `status.html`. Create a class `Status` with a reference to all
    the required DOM elements in its constructor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'I have also created a class variable `statisticData` which can be used for
    storing the data that will be retrieved from the API call. Also, add the code
    to create an instance for the class when the page loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step to our status page is to make a network request to the get required
    data from the server. I have created the following API endpoint in the Node.js
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The server will return the data containing the number of people who are interested
    based on their experience, profession, and age in a format suitable for use with
    Chart.js. Let''s use the `apiCall` module we built before to make this network
    request. In your `status.js` file, first add the following import statement above
    the `Status` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, add the following method inside the `Status` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we can use the `apiCall()` function with only a single parameter,
    because we are making a `GET` request and we have already defined the default
    parameters of the `apiCall()` function as `body = {}` and `method = ''GET''`.
    This way, we don''t have to specify the body and method parameters while making
    a `GET` request. Inside your constructor, add the `this.loadData()` method so
    that it will make the network request automatically when the page loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Now, look at the web page in Chrome. After three seconds, it should show the
    tabs. At the moment, clicking the tabs will only reload the page. We'll handle
    this after creating the charts.
  prefs: []
  type: TYPE_NORMAL
- en: Adding charts to the canvas elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have the required data in our class variable `statisticData`, with which
    the charts should be rendered. I have already added Chart.js to the project dependencies
    in the `package.json` file and it should have been installed when you executed
    the `npm install` command. Let''s import Chart.js into our project by adding the
    following code at the top of the `status.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: It is not compulsory to add the `import` statements only on top of the file.
    However, adding the `import` statements on top gives us a clear view of all the
    dependencies of the module in the current file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chart.js provides a constructor with which we can create a new chart. The `Chart`
    constructor has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter of the `Chart` constructor should be a reference to the
    canvas element and the second parameter is the JSON object with two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: The `type` property should contain the type of graph that we need to use in
    our project. We need to use a pie chart in our project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `data` property should contain the datasets needed to create the graph as
    an object in a format based on the type of graph. In our case, for the pie chart,
    the required format is specified in the Chart.js documentation on the following
    page: [http://www.chartjs.org/docs/latest/charts/doughnut.html](http://www.chartjs.org/docs/latest/charts/doughnut.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The data object will have the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The data object has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: A `datasets` property with an array of another object having the `data`, `backgroundColor`,
    and `borderColor` as arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `labels` property with an array of labels in the same order as that of the
    array of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The created charts will automatically occupy the entire space provided by their
    parent element. Create the following functions inside the `Status` class to load
    `Chart` into the status page:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a chart based on experience, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create a chart based on profession, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create a chart based on age, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'These functions should be called when the data is loaded into the `statisticData`
    variable. So, the best place to call them is after the API call has been a success.
    In the `loadData()` method, add the following code, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the status page in Chrome. You should see three charts rendered on
    the page. The charts have occupied the entire width of their parent element. To
    reduce their size, add the following style to your `styles.css` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This should reduce the size of the charts. The best part about Chart.js is that
    it is responsive by default. Try resizing the page in Chrome's responsive design
    mode. You should see the charts being resized when the height and width of the
    page are changed. We have now added three charts on our status page.
  prefs: []
  type: TYPE_NORMAL
- en: For our final step, we need the tabs to toggle the appearance of the chart so
    that only one chart is visible at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up tab sections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tabs should work such that only one of the charts is visible at a given
    time. Also, the selected tab should be marked active using the `.active` class.
    A simple solution to this problem is hiding all the charts, removing `.active`
    from all the tab items, and then adding `.active` only to the clicked tab item
    and displaying the required chart. This way, we can easily get the required tab
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a method inside the `Status` class to clear the selected tabs
    and hide all the charts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a method to add event listeners to the clicked tab items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Also, call the preceding method inside `constructor` using `this.addEventListeners();`
    so that the event listeners are attached when the page loads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever we click one of the tab items, it will call the respective load chart
    function. Say we clicked the Experience tab. This would call the `loadExperience()`
    method with `event` as a parameter. But we might want to call this function after
    the API call to load the chart without the event parameter. To make `loadExperience()`
    work in both scenarios, modify the method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding function:'
  prefs: []
  type: TYPE_NORMAL
- en: The event parameter is defined with a default value of `null`. If `loadExperience()`
    is called with the event parameter (when the user clicks on the tab), the `if(event)`
    condition will pass and `event.preventDefault()` will stop the default click action
    of the anchor tag. This will prevent the page from reloading.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `this.loadExperience()` is called from within the `apiCall` promise chain,
    it will not have the `event` parameter and the value of the event defaults to
    `null`. The `if(event)` condition will fail (since `null` is a falsy value) and
    `event.preventDefault()` won't be executed. This will prevent an exception, since
    `event` is not defined in this scenario.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, `this.hideCharts()` is called, which will hide all the charts and
    remove `.active` from all the tabs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next two lines will remove `.hidden` from the experience chart's canvas
    and add the `.active` class to the Experience Tab.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `apiCall` function's `then` chain, remove `this.loadAge()` and `this.loadProfession()` so
    that only the experience chart will be loaded first (since it is the first tab).
  prefs: []
  type: TYPE_NORMAL
- en: If you open Google Chrome and click on the Experience tab, it should re-render the
    graph without refreshing the page. This is because we added `event.preventDefault()`
    to stop the default action in the `loadExperience()` method and used Chart.js
    to render the graph when the tab was clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the same logic in `loadAge()` and `loadProfession()`, we can now easily
    make the tabs work as expected. In your `loadAge()` method add the event handling
    code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, In the `loadProfession()` method add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Open Chrome. Click on the tabs to check whether all of them are working properly.
    If so, you have successfully completed the status page! Chart.js is responsive
    by default; hence, if you resize the page, it will resize the pie chart automatically.
    Now, one last page remains, in which you need to add Google Maps to display the
    event location. In normal JavaScript, adding Google Maps is straightforward. But,
    in our case, since we are using Webpack to bundle our JavaScript code, we need
    to add one small step to the normal process (Google Maps need to access a JavaScript
    variable inside HTML!).
  prefs: []
  type: TYPE_NORMAL
- en: Chart.js has eight types of charts. Do try each of them at: [http://www.chartjs.org/](http://www.chartjs.org/),
    and if you are looking for a more advanced Charting and Graphics library, check
    out `D3.js` (**Data-Driven Documents**) at: [https://d3js.org/](https://d3js.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Adding Google Maps to the web page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `about.html` file in VSCode or your text editor. It will have two paragraph `<p>`
    tags, in which you can add some information regarding your event. After that,
    there will be a `<div>` element with the ID `#map`, which is supposed to show
    the location of your event in a map.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have asked you to generate an API key to use Google Maps before. If you haven''t
    generated it, please get one from: [https://developers.google.com/maps/documentation/javascript/get-api-key](https://developers.google.com/maps/documentation/javascript/get-api-key)
    and add it to your `.env` file''s `GMAP_KEY` variable. According to the Google
    Maps documentation, to add a Map with a marker to your web page, you must include
    the following script on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `async` and `defer` attributes of the `<script>` tag will load the
    script asynchronously and make sure it is executed only after the document is
    loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'To know more about the workings of `async` and `defer`, refer to the following
    w3schools pages. For Async: [https://www.w3schools.com/tags/att_script_async.asp](https://www.w3schools.com/tags/att_script_async.asp)
    and for Defer: [https://www.w3schools.com/tags/att_script_defer.asp](https://www.w3schools.com/tags/att_script_defer.asp).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look into the `src` attribute. Here, there is a URL, followed by two query
    parameters, key and callback. Key is where you need to include your Google Maps
    API key, and callback should be a function that needs to be executed once the
    script has completed loaded (the script is loading asynchronously). The challenge
    lies in that the script needs to be included in the HTML where our JavaScript
    variables are not accessible (we are Webpack users now!).
  prefs: []
  type: TYPE_NORMAL
- en: But, as I have explained before, in the `webpack.config.js` file, I have added
    the `output.library` property, which will expose the objects, functions, or variables
    that are marked with the keyword `export` in the entry files of Webpack to the
    HTML by making their scope global (changing their scope from `const` or `let`
    to `var`). However, they are not directly accessible by their names. The value
    of `output.library` I have given is `bundle`. So, the things that are marked with
    the `export` keyword will be available as a property of the `bundle` object.
  prefs: []
  type: TYPE_NORMAL
- en: Open the Event Registration app in Chrome and open your Chrome DevTools console.
    If you type `bundle` into your console, you can see that it prints out an empty
    object. This is because we haven't made any exports from the *Webpack's entry
    files* (we did some exports in `apiCall.js` and `registrationForm.js` but those
    files are not in the `webpack.config.js` entry property). Hence, we only have
    an empty bundle object at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s think of a way to successfully include the Google Maps script in our
    web app:'
  prefs: []
  type: TYPE_NORMAL
- en: The API key is currently available as a global variable `GMAP_KEY` in our JavaScript
    code. So, it would be better to create the script element from the JavaScript
    and append it to the HTML when the page has loaded. This way, we don't have to
    export the API key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the callback function, we will create a JavaScript function and export it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open the `about.js` file in VSCode and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: When the page has finished loading, it will create a new script element `document.createElement('script')` and
    store it in `$script` constant object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we add the `src` attribute to the `$script` object with the value as the
    required script URL. Note that I have included the `GMAP_KEY` variable in the
    key and `bundle.initMap` as the callback function (since we are exporting `initMap`
    in `about.js`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it will append the script to the body element as a child. This will
    make the Google Maps script work as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We didn't need `async` or `defer` here, since load the script only after the
    page has loaded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In your Chrome DevTools console, while you are on the about page, try typing
    `bundle` again. This time, you should see an object printed with `initMap` as
    one of its properties.
  prefs: []
  type: TYPE_NORMAL
- en: In our ToDo List app, we created HTML elements by writing the HTML code directly
    in template strings. It is very efficient for constructing a large number of HTML
    elements. However, for smaller elements, it is better to use the `document.createElement()`
    method, since it makes the code more readable and easy to understand when there
    are a lot of attributes to that element that need dynamic values.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Google Maps with a marker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have successfully included the Google Maps script on the page. When the Google
    Maps script finishes loading, it will call the `initMap` function we declared
    in the `about.js` file. Now, we will use that function to create the map with
    a marker pointing to the location of the JS Meetup Event.
  prefs: []
  type: TYPE_NORMAL
- en: The process of adding Google Maps with a marker and more functionalities is
    well explained in the Google Maps documentation, available at: [https://developers.google.com/maps/documentation/javascript/adding-a-google-map](https://developers.google.com/maps/documentation/javascript/adding-a-google-map).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Google Maps script we included earlier provides us with a few constructors
    that can create `map`, `Marker`, and `infowindow`. To add a simple Google Maps
    with `marker`, add the following code inside the `initMap()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Replace the `lat` and `lng` values in the preceding code with the latitude and
    longitude of your event location and change the content of the `infowindow` object
    with the address and contact details for the event location. Now, open the `about.html`
    page on Google Chrome; you should see the map with a marker at your event's location.
    The information window will be open by default.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have successfully built your Event Registration app! But,
    before we start inviting people to the event, there is one more thing you need
    to do in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a production build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have noticed something about both the Meme Creator and the Event Registration
    apps. The apps load plain HTML first; after that, styles are loaded. This makes
    the applications look plain for a moment. This problem does not exist in the ToDo
    List app because we load CSS first in the ToDo List app. In the Meme Creator app,
    there was an optional section called *Optimizing Webpack builds for different
    environments*. This might be a good time to read it. If you haven't read it yet,
    go back, give that section a read, and come back to generate the production build.
  prefs: []
  type: TYPE_NORMAL
- en: So far, our app has been working in a development environment. Remember? In
    the `.env` file, I told you to set `NODE_ENV=dev`. This is because, when you set
    `NODE_ENV=production` as per the `webpack.config.js` file I created, Webpack will
    go into production mode. The `npm run watch` command is used to run the Webpack
    dev server to create a development server for our use. In your `package.json`
    file, there should be another command called `webpack`. This command is used to
    generate production builds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `webpack.config.js` file included in this project has a lot of plugins
    that are used to optimize the code and make the app loading times faster for the
    end user. `npm run watch` will not work properly, only when `NODE_ENV` is production,
    since there are a lot of plugins included to do production optimizations. To generate
    a production build for your Event Registration app, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the value of the `NODE_ENV` variable in your `.env` file to `production`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the following command `npm run webpack` from your project root folder in
    the terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will take a while for the command to finish execution, but once it's done,
    you should see a number of files in your project `/dist` folder. There will be
    JS files, CSS files, and `.map` files that contain source map information for
    the generated CSS and JS files. JS files will be compressed and well minified
    so that loading and execution times are very fast. There will also be a fonts
    directory containing the fonts used by Bootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have only included the JS file in the HTML, since it contains the
    CSS code too. However, it is the reason why the page shows blank HTML without
    CSS when it starts loading. The CSS file should be included before the `<body>`
    element so that it will load first and the page style will be uniform when it
    is loading (see how we included CSS files in [Chapter 1](part0022.html#KVCC0-f852807d0cb141b58fff8f992d32cbb7),
    *Building a ToDo List App*). For the production build, we need to remove references
    to old JS files and include the newly generated CSS and JS files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `dist/` directory, there will be a `manifest.json` file that contains
    the list of files generated for every entry in Webpack. `manifest.json` should
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The prefix numbers are just hash values and they might be different for you;
    don''t worry about that. Now, include the CSS and JS files for each HTML file.
    For example, take the `status.html` file and add the CSS and JS files in the status
    property of the preceding `manifest.json` file, such that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Repeat the same process for other HTML files and then your production build
    will be ready! You cannot use Webpack dev server now, so you could use the `http-server`
    tool to open the web page or directly open the HTML file with Chrome (I'd recommend
    using `http-server`). This time, while the page is loading, you won't see the
    HTML page without styles, since CSS is loaded before the body elements.
  prefs: []
  type: TYPE_NORMAL
- en: Shipping the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have learned how to generate production builds, what if you want
    to send this code to someone else? Say the DevOps team or the server administrator.
    In this case, if you are using version control, add the `dist/` directory, the
    `node_modules/` directory, and the `.env` files to your ignore list. Send the
    code without these two directories and the `.env` file. The other person should
    be able to figure out which environment variables to use using the `.env.example`
    file, creating the `.env` file, and also using the `npm install` and `npm run
    webpack` commands to generate the `node_modules/` and `dist/` directories.
  prefs: []
  type: TYPE_NORMAL
- en: For all the other steps, neatly document the procedure in a `README.md` file
    in your project root folder and send it along with the other files.
  prefs: []
  type: TYPE_NORMAL
- en: The main reason why sharing the `.env` file should be avoided is because the
    environment variables might contain sensitive information and should not be transported
    or stored in version control as plain text.
  prefs: []
  type: TYPE_NORMAL
- en: You have now learned about generating production builds for your applications
    built with Webpack. Now, the Meme Creator app does not have a production build
    yet! I'll let you use the `webpack.config.js` file used in this chapter as a reference.
    So, go ahead and create a production build for your Meme Creator.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well done! You just built a really useful Event Registration app. Along the
    way, you have learned some really advanced concepts of JavaScript, such as building
    ES6 Modules for reusable code, making asynchronous AJAX calls with fetch, and
    handling asynchronous code using Promises. You also used the Chart.js library
    to build charts to visually display the data and, finally, created a production-ready
    build with Webpack.
  prefs: []
  type: TYPE_NORMAL
- en: Having learned all these concepts, you are no longer a beginner in JavaScript;
    you can proudly call yourself a pro! But, apart from these concepts, there's still
    a lot going on with modern JavaScript. As I told you before, JavaScript is no
    longer a scripting language used only for form validation on browsers. In the
    next chapter, we are going to build a peer-to-peer video calling application using
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
