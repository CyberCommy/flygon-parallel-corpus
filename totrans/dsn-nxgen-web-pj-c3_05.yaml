- en: Chapter 5. An Image Gallery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Image galleries are nowadays a common component of a website. In this chapter,
    we''ll discover how we can implement a range of transition effects and several
    navigation modes using *only* CSS properties. We''ll start by implementing a basic
    transition effect using a series of images, then we''ll develop a pure CSS structure
    to let the user select his preferred navigation mode and transition effect and,
    finally, we''ll add more complex transition effects. The following is a list of
    the topics we''ll cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A basic gallery HTML structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing opacity transition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing slide transition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3D transformations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the slideshow mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating previous and next arrow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS preprocessors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As in the previous chapters, we will first define a basic HTML structure on
    which we will build our project. So let''s create a new folder for this project
    with a file named `index.html` containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As in the previous chapters, we are using the Yahoo! Reset CSS stylesheet as
    well as Lea Verou's Prefix Free library. You can copy `prefixfree.js` from the
    previous chapter's example, or download it from [http://leaverou.github.com/prefixfree/](http://leaverou.github.com/prefixfree/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure we defined contains a few radio buttons divided into two groups:
    `mode` and `controls`. In this project, we''ll learn how to change the behavior
    of our gallery to reflect the choices made by our users. The default settings,
    the ones we''re going to implement first, concern an opacity transition and a
    bullet-based navigation system.'
  prefs: []
  type: TYPE_NORMAL
- en: Next there are anchors in a quantity equal to the number of images we want to
    display. Then, within a `section` element, we have a `figure` element for each
    image, and an `a` element pointing to the anchors previously defined.
  prefs: []
  type: TYPE_NORMAL
- en: What we're going to implement consists of activating a particular image when
    the corresponding `a` element is pressed. To do so, we'll use the already introduced
    `:target` pseudo-selector in conjunction with some other little useful tricks,
    but first we have to spend a little time defining the base CSS structure.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the basic CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we have to center our project in the middle of the browser''s
    viewport and then style the radio buttons a bit. To do this we write a few lines
    of CSS in `application.css`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Good! Now let''s assign the corresponding image to each `figure` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that in a real-world example, we would probably have inserted these
    images dynamically via a `style` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can test the success of this setup phase using a CSS3-compliant browser.
    At this point we haven't added any behavior to the radio buttons, so we expect
    only to see the image within `#shot5` without any kind of interaction or animation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying the basic CSS](img/3264OT_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Styling the bullets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start applying some style to the `a` elements. We created the bullets
    first because they are the default representation. Our bullets will be visible
    as a set of hollow, clickable circles below the image as are often found in online
    slideshows. We can use some rounded borders for the circles and apply a `background`
    rule when the element has been clicked upon. To intercept this state, we'll use
    the `:target` pseudo-selector on the corresponding `a` element that we have inserted
    at the top of our page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We decided to set the bullets to `display:inline-block` in order to benefit
    from the space that this property injects between the elements when some space
    is left between their tags, as we saw in [Chapter 3](ch03.html "Chapter 3. Omni
    Menu"), *Omni Menu*.
  prefs: []
  type: TYPE_NORMAL
- en: Next we used the `:target` pseudo-selector in conjunction with the proximity
    one, `~`, to define a rule that matches the bullet that points to the current
    anchor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now everything is ready and we can start working on our first transition effect:
    opacity.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing opacity transition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The opacity effect is the simplest, all we have to do is to hide all the elements
    through the property `opacity:0`, except the one that corresponds to the clicked
    bullet. To obtain a nice fading effect, we can then specify a transition period
    between the two states using the `transition` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'A trick we have to implement here is to attach this behavior only when the
    **opacity** radio button is selected in our settings panel. To accomplish this,
    we can place another selector, `#opacity:checked`, before the rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We basically used the same trick as earlier, plus we added a rule to set `opacity:1`
    to the first image if no bullets are selected. To accomplish this, we used the
    `+` selector to specifically match five sequential `a` elements that aren't `:target`.
  prefs: []
  type: TYPE_NORMAL
- en: Well done! If we run the project in a browser, we can test the effect and notice
    how this works *only* if the corresponding radio button is selected.
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing opacity transition](img/3264OT_05_01_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A final note before moving ahead, the selectors we created for this project
    are quite complex and, if used extensively in big applications, may introduce
    performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to implement a new effect: slide!'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing slide transition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A slide effect is basically a transition where one element moves outside the
    user''s view, sliding in one direction while another moves in. To implement this
    effect, we have to work on two different animations: slide in and slide out. The
    basic idea to make this effect work is similar to the previous one, although slightly
    more complicated. To achieve the slide-in effect, we have to move all the pictures
    outside the section viewport, say `left:-500px` and then, when the corresponding
    bullet is clicked, take the selected picture and move it to the opposite side
    (`left:500px`) using an animation that then moves it to the correct position (`left:0`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve the slide-out effect, we can then use another animation that starts
    from `left:0px` to `left:-500px`. The following is the complete CSS snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We used `overflow:hidden` to hide the images outside the section viewport. The
    `slideout` animation is added to all the elements except the selected one, so
    when an element exits from the selected state, the animation gets activated and
    moves the element to `left:-500px` smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot taken from a CSS3-compliant browser (for example,
    Chrome, Firefox, IE10, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing slide transition](img/3264OT_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we''re ready to code the third transition effect: cube! But first, in order
    to better understand the next step, let''s spend some time introducing the basics
    of 3D transformations.'
  prefs: []
  type: TYPE_NORMAL
- en: 3D transformations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3D transformations introduce a big leap-forward in designing websites. We can
    now experiment with moving and animating elements such as `div`, `img`, or even
    `video` in a 3D space that benefits from GPU acceleration (for most browsers).
    The first thing we have to deal with once we decide to introduce 3D effects is
    the **perspective**.
  prefs: []
  type: TYPE_NORMAL
- en: The value we set for the `perspective` property specifies to the browser how
    to render elements with a position on the z axis equal to 0 (or not set). For
    example, `perspective:300px` means that an element with z = 0 (or not set) is
    drawn as if it is 300 px away from the viewport. This, of course, affects the
    way the elements are rendered when rotated.
  prefs: []
  type: TYPE_NORMAL
- en: Next comes a useful property whose purpose is to tell the browser to apply 3D
    transformations. This property is called `transform-style` and its value can either
    be `flat` or `preserve-3d`. When the value is `flat`, the elements with transformations
    that affect rotation on the x or y axis do not have perspective, but when the
    value is `preserve-3d` they actually behave like real 3D surfaces. This property
    also applies to all the element's children.
  prefs: []
  type: TYPE_NORMAL
- en: Finally come the transformations. Here the property to use is the same as for
    the 2D ones, `transform`, but there are some new keywords that can be chosen as
    a value.
  prefs: []
  type: TYPE_NORMAL
- en: The transformation origin is set by default to the center of the element with
    z = 0, but can be adjusted using the `transform-origin` property.
  prefs: []
  type: TYPE_NORMAL
- en: With these notions in mind, we can start defining the cube effect that basically
    operates like the slide one but, of course, taking advantage of the 3D transform
    mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We set `perspective` and `transform-style` to the parent elements of those we
    want to transform. Then we define an origin that is centered on the `figure` elements
    but shifted 250 px away from the viewport.
  prefs: []
  type: TYPE_NORMAL
- en: Then we apply a rotating transformation around the y axis using the same mechanism
    as we did earlier with the `slidein` animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final touch, we tell the browser not to show the pictures when they''re
    rotating opposite to the user''s point of view. This is done with the `backface-visibility:
    hidden` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick refresh in the browser and the result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![3D transformations](img/3264OT_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Chrome automatically disables 3D effects if the hardware of the PC running the
    browser doesn't have a GPU. To check if this behavior has been triggered, we can
    write `about:GPU` in the address bar.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the slideshow mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we''re ready to implement the remaining two modes: slideshow and arrows.
    Let''s begin with slideshow. All we have to do here is define an animation for
    each effect (**opacity**, **slidein**, and **cube**) and trigger it, paying attention
    to specifying a different delay (using the `animation-delay` property) to each
    `figure` element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with this last part and define a different delay for each `figure`
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If each animation lasts for 4 seconds (1.5 seconds to animate in, 1 second still,
    and 1.5 seconds to animate out), we need the second `figure` element to start
    after 2.5 seconds, exactly when the first one begins its exit animation. Later
    in this chapter, we'll learn how to make this CSS code adapt to a different number
    of images.
  prefs: []
  type: TYPE_NORMAL
- en: We can then repeat this step for the remaining `figure` elements and come out
    with the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: The highlighted part is used to hide the bullets because they are not necessary
    during the slideshow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Good! Now we have to write the animations. Let''s start with the opacity animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have to check that both the **opacity** and **animate** radio buttons are
    checked. Given this state, we can set the animation to `opacity` and choose a
    duration that is the value of the `animation-delay` property of the last `figure`
    element, `#shot5`, (10 seconds) plus its animation time (4 seconds) minus the
    time this animation overlaps the previous one (1.5 seconds).
  prefs: []
  type: TYPE_NORMAL
- en: Next we define some keyframes transforming the timing into a percentage (for
    example, 12% of 12.5 seconds = 1.5 seconds).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also easily extend this behavior for the two remaining animations, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For the sliding effect, we start with the picture outside the visible area.
    Then we move it until it becomes completely visible. Lastly, after a while, we
    move it again out of the visible area, but from the other side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For the rotating cube effect we basically do the same, but instead of using
    the `left` property we use the `transform: rotate()` one, and instead of sliding
    in the picture (-500 px, then 0 px, and finally 500 px) we rotate the cube (90
    degrees, then 0 degrees, and finally -90 degrees).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Previous and next arrows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ok, here comes the trickiest part: to create the arrows. What we are going
    to do in order to accomplish this task is:'
  prefs: []
  type: TYPE_NORMAL
- en: Use CSS to transform each bullet into an arrow sign by changing its shape and
    using a nice background image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move all the arrows to the left of the picture, one above the other. In this
    way, the only visible arrow will be the one corresponding to the picture with
    the highest index.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hide the arrow corresponding to the selected image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move all the arrows that follow the one corresponding to the selected image
    to the right, one above the other. In this way, on the left side there will remain
    only those arrows that correspond to the pictures with index lower than the selected
    one (for example, if we select picture number three, only the arrows of pictures
    number one and two will stay on the left, with the arrow of picture number two
    on the top of the stack).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick the arrow that follows the one corresponding to the selected image and
    change its `z-index` value in order to put it on top of the right stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the corresponding CSS code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Previous and next arrows](img/3264OT_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: CSS preprocessors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll try to address the biggest issue with this project:
    the whole stylesheet is strictly dependent upon how many images are displayed
    in the gallery. Every effect is tailored around this number, and so adding a new
    image can cause a lot of work in our CSS.'
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem we can use a **CSS preprocessor**, which lets us create
    a file in a language that includes some facilities such as loops and variables,
    and one that can be compiled into a CSS stylesheet.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use Sass for this project. To install it, you need to first install Ruby
    ([http://www.ruby-lang.sorg/en/downloads/](http://www.ruby-lang.sorg/en/downloads/))
    and then type `gem install sass` from a terminal emulator within your project
    directory (depending on your operating system, you may need to use `sudo gem install
    sass` instead).
  prefs: []
  type: TYPE_NORMAL
- en: Once this installation is complete, due to the fact that SCSS is a *superset*
    of CSS3, we can create an `scss/application.scss` file by duplicating the content
    of `css/application.css`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we can prepend the whole code with a variable to contain the number of
    pictures our gallery currently holds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now every time in the CSS we encounter a structure like the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can change the code in a way that it generates the right number of selectors
    depending on `$number_of_images`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Handling special cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few special cases, though, one of them is when we encounter a CSS
    selector that contains a string token repeated the number of times equal to the
    number of images. For example, the following line of CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To transform the previous code into its variable-driven version, we have to
    create a function, a small piece of code that returns a string. We can write it
    just above the variable''s declaration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can define a new variable that contains the string `a:not(:target)`
    repeated the number of times equal to the pictures in our gallery. So the new
    variable section in the `.scss` file will look like the following CSS snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the previous CSS snippet can be transformed into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Another thing we have to take care of is the timing of our animations. We have
    to dynamically calculate the total duration of the animation as well as the percentage
    of the three keyframes (enter animation, still, and exit animation) starting from
    the number of images in our gallery. To do so, we have to define a few extra variables
    just before the end of the `Variables` section of our `application.scss` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the previous few lines, we defined the total duration of the animation and
    then we converted the timings of the animation (1.5 seconds to animate in, 1 second
    still, and 1.5 seconds to animate out) into a percentage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, we have to run through our `.scss` code and transform each
    `animation-duration: 12.5s;` into `animation-duration: $animation_duration;`.
    We also have to change `@keyframes opacity`, `@keyframes slide`, and `@keyframes
    cube` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The complete version of the `application.scss` file is available with the sources
    of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile our `application.scss` file into `application.css`, we can invoke
    the following command using a terminal emulator from the root of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: By using these simple translating rules, we can transform our CSS into a very
    flexible SCSS. To prove it, we can try to remove a `figure` element from the HTML
    (with its corresponding `a` elements), change `$number_of_images:` to `4`, recompile
    `application.scss`, and notice how the whole project keeps working smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Support for older browsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Internet Explorer version 9 or below doesn''t support CSS3 transition, nor
    CSS3 3D transforms, so this project can hardy be emulated on those browsers. We
    can however implement basic picture navigation while hiding all the other options.
    To achieve this, let''s take advantage one more time of the conditional comments
    and substitute `<html>` with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we need to add support for Internet Explorer 8 to some CSS3 selectors
    we used during the project. To do so, we have to add a library called Selectivizr
    ([http://selectivizr.com/](http://selectivizr.com/)) that uses JavaScript to support
    most of the new CSS3 selectors. Selectivizr depends on jQuery, so we need to add
    it too. Lastly, we need to use a polyfill to make Internet Explorer 8 support
    the new HTML5 elements. The following is the snippet of code required to insert
    these three libraries, we need to add it just before the end of the `head` section
    in `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can add a few CSS lines to hide everything except the first `figure`
    element when the `.lteie9` class is present. Additionally, we can take advantage
    of Sass in order to trigger `display:block` on the `figure` element corresponding
    to the selected bullet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSS3 provides new, simplified methods to create stunning galleries without the
    use of JavaScript. Understandably, these techniques do not work with older non-CSS3-compliant
    browsers but we can detect these browsers and create fallback solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we saw how we can create cool interaction mechanisms using
    only CSS3\. Additionally, we discovered a nice way to generate CSS statically
    starting from a more flexible language.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, we tried three cool animation effects. These can be easily
    mixed or new ones can be created by, for example, changing `rotateX` with `rotateY`,
    or `left` with `top`. In the next chapter, we'll explore how to obtain interesting
    parallax effects.
  prefs: []
  type: TYPE_NORMAL
