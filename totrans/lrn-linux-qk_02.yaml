- en: Climbing the Tree
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will climb a very special tree, which is the Linux filesystem.
    During this climbing journey, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: The Linux filesystem hierarchy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the root directory?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Absolute versus Relative paths.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to navigate the Linux filesystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Linux filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Alright, you are at the root of the tree and ready to climb up. In Linux, just
    like an actual tree, the beginning of the filesystem starts at the root directory.
    You can use the `cd` command followed by a forward slash to get to the root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `cd` command is short for **Change Directory** and is one of the most used
    commands in Linux. You can't move around in Linux without it. It's like your limbs
    (arms and legs), can you climb a tree without your limbs?
  prefs: []
  type: TYPE_NORMAL
- en: 'The forward slash character represents the root directory. Now to make sure
    you''re at the root directory, you can run `pwd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: And sure enough, we are at the root of the Linux filesystem. Whenever you are
    lost and you don't know where you are, `pwd` is here to rescue you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, while we are still at the root directory, let''s see what''s in there!
    Run the `ls` command to view the contents of the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To have a better view of the contents, you can use the long listing `-l` option
    with the `ls` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This output gives you a lot of valuable information that we will discuss in
    detail in the upcoming chapters. But for now, we focus on the first letter in
    the first column of the output. Take a look at the first column of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You will see that the first letter is `d`, which means that the file is a directory.
    The first letter reveals the file type. The last column of the output displays
    the filename.
  prefs: []
  type: TYPE_NORMAL
- en: '**OTHER FILES!**'
  prefs: []
  type: TYPE_NORMAL
- en: You will have more files under your root (`/`) directory. I have only chosen
    the most important and common ones that should exist on every Linux distribution.
    So don't freak out when you see way more files than those listed in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now each one of these directories has a special purpose, as you can see in
    the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `/` | This is the root of your filesystem, where everything begins. |'
  prefs: []
  type: TYPE_TB
- en: '| `/etc` | This directory contains system configuration files. |'
  prefs: []
  type: TYPE_TB
- en: '| `/home` | This is the default home directory for all users (except the root
    user). |'
  prefs: []
  type: TYPE_TB
- en: '| `/root` | This is the home directory for the root user. |'
  prefs: []
  type: TYPE_TB
- en: '| `/dev` | This is where your devices such as your hard disks, USB drives,
    and optical drives reside on your system. |'
  prefs: []
  type: TYPE_TB
- en: '| `/opt` | This is where you can install additional 3rd party software. |'
  prefs: []
  type: TYPE_TB
- en: '| `/bin` | This is where essential binaries (programs) reside on your system.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `/sbin` | This is where system binaries (programs) that are typically used
    by the system administrator are stored. |'
  prefs: []
  type: TYPE_TB
- en: '| `/tmp` | This is where temporary files are stored; they are usually deleted
    after a system reboot, so never store important files here! |'
  prefs: []
  type: TYPE_TB
- en: '| `/var` | This directory contains files that may change in size, such as mail
    spools and log files. |'
  prefs: []
  type: TYPE_TB
- en: '| `/boot` | All the files required for your system to boot are stored here.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `/lib` | This directory contains libraries needed by the essential binaries
    in the `/bin` and `/sbin` directories. A library is basically a set of precompiled
    functions that can be used by a program. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc` | This is where information about running processes is stored. |'
  prefs: []
  type: TYPE_TB
- en: '| `/usr` | This directory contains files and utilities that are shared between
    users. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2: Linux Directories Explained'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also run the `man hier` command to read more about the Linux filesystem
    hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Alright, now let's do further climbing on the Linux directory tree. Take a look
    at *figure 1*, and you will understand why we choose a tree to describe the structure
    of the Linux filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79a50d42-f14e-4fe6-a412-62b50953310c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: The Linux directory tree'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure only features very few files and by no means is a representation
    for the whole directory tree, as the Linux filesystem literally contains thousands
    of files. So you can think of the preceding figure as a subtree of the actual
    Linux directory tree.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating through the directory tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Alright, let''s do more climbing. For example, let''s climb to the `/home`
    directory to see how many users we have on the system. You can do that by simply
    running the `cd /home` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice how your command prompt changes as it's now showing that you are at the
    home directory.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53676501-79e3-4dbd-97d3-a5d42af9fc78.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: You are now at /home'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s run `ls` to view the contents of the `/home` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: These are the two users on my system (besides the root user). The `/root` is
    the home directory for the root user. You probably have only one user in `/home`;
    you will learn later in the book how to add other users to your system.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHO IS ROOT?**'
  prefs: []
  type: TYPE_NORMAL
- en: The root user is a superuser who is allowed to do anything on the system. The
    root user can install software, add users, manage disk partitions, etc. The home
    directory of the root user is `/root`, which is NOT to be confused with `/` (the
    root of the filesystem).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want proof that you are currently at the `/home` directory, you can
    run the `pwd` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Sure enough! We are at the `/home` directory. Now let''s climb to the home
    directory of user `elliot`. Now, believe it or not, there are two ways to navigate
    to `elliot`''s home directory. You can simply run the `cd elliot` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can run the `cd /home/elliot` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/7254d293-d5d7-4f55-aa19-27333469d3d1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: Now you are at /home/elliot'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that both commands have landed us in `elliot`'s home directory. However,
    running `cd elliot` is much easier than running `cd /home/elliot`, of course.
  prefs: []
  type: TYPE_NORMAL
- en: Well, think about it, we were initially at the `/home` directory, and that's
    why we were able to run `cd elliot` to land in `/home/elliot`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in other situations, we would be forced to use the full path (absolute
    path) `/home/elliot` to reach our destination. To demonstrate, let''s first change
    to the `/etc` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/54cd2e8c-6b0e-42cb-b217-160e38baf5a4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: Now you are at /etc'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5392da2b-ffd7-48bb-82ce-cebea60f31c5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: You want to go to /home/elliot'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figures 4* and *5* help you visualize it. You are at `/etc` and you want to
    go to `/home/elliot`. To get to `elliot`''s home directory, we can no longer use
    a short path (relative path) by running the `cd elliot` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the Shell got mad and returned an error `bash: cd: elliot:
    No such file or directory`. In this case, we have to use the full path (absolute
    path)`/home/elliot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In case you haven't noticed by now, we have been using the forward slash (`/`)
    as a directory separator.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE DIRECTORY SEPARATOR**'
  prefs: []
  type: TYPE_NORMAL
- en: In Linux, the forward slash (`/`) is the directory separator or sometimes referred
    to as the path separator. In Windows, it's the other way around because a backward
    slash (`\`) is used instead as a directory separator. However, be careful since
    the leading forward slash is the root of our filesystem. For example, in `/home/elliot/Desktop`,
    only the second and third forward slashes are directory separators, but the first
    forward slash represents the root of the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: It's crucial to realize the difference between absolute paths and relative paths.
  prefs: []
  type: TYPE_NORMAL
- en: '**ABSOLUTE VERSUS RELATIVE PATHS**'
  prefs: []
  type: TYPE_NORMAL
- en: An absolute path of a file is simply the full path of that file and, it **ALWAYS**
    begins with a leading forward slash. For example, `/opt/- google/chrome` is an
    example of an absolute path.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a relative path of a file never starts with the root directory
    and is always relative to the current working directory. For example, if you are
    currently at `/var`, then `log/boot.log` is a valid relative path.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, if you want to distinguish between a relative path and an
    absolute path, look and see if the path starts with the root directory (forward
    slash); if it does, then you can conclude the path is absolute, otherwise, the
    path is relative.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows you the relative path `Desktop/hello.txt` and will
    only work if your current working directory is `/home/elliot`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb656147-eb70-42d1-b62e-030c994f0873.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: This Is a Relative Path'
  prefs: []
  type: TYPE_NORMAL
- en: The following image shows you the absolute path `/home/elliot/Desktop` and will
    always work regardless of your current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64478dee-c47a-46c2-b446-6f439ad8fda7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: This Is an Absolute Path'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s climb to Elliot''s `Desktop` directory to see what he has there.
    We will use an absolute path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We follow it with a `pwd` to confirm that we are indeed in the desired directory.
    Now let''s run `ls` to view the contents of Elliot''s desktop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the file `hello.txt` is on Elliot's desktop, so we can actually
    see it right there on the desktop.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8f7032f-daed-4827-a8f0-7cc625997a36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8: Elliot''s desktop'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the preceding image, there is a file named `hello.txt` on
    Elliot''s desktop. You can use the `cat` command to view the contents of a text
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you open the file `hello.txt` on the desktop, you will see the same contents,
    of course, as you can see in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e97ae210-c57e-4df2-8c73-c1305666bf74.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9: The contents of hello.txt'
  prefs: []
  type: TYPE_NORMAL
- en: Parent and current directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two special directories under every directory in the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: Current working directory represented by one dot (`.`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parent directory represented by two dots (`..`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/525d4989-07bd-4e5a-96aa-8831c012a775.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10: Visualizing Parent and Current Directories'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s easy to understand both directories by going through a few examples.
    To demonstrate, let''s first change to `/home/elliot` so that it becomes our current
    working directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the `cd .` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you would expect, nothing happened! We are still at `/home/elliot`, and that
    is because one dot (`.`) represents the current working directory. It's like if
    you told someone, "Go where you are!"
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run the `cd ..` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We moved back one directory! In other words, we changed to the parent directory
    of `/home/elliot`, which is `/home`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run another `cd ..`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed we keep going back, and now we are at the root of our directory tree.
    Well, let''s run `cd ..` one more time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Hmmm, we are at the same directory! Our path didn't change, and that's because
    we are at the root of our directory tree already, so we can't go any further back.
    As a result, the root directory (`/`) is the only directory where the **parent
    directory = current directory**, and you can visualize it by looking at *figure
    10*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also insert the directory separator `cd ../..` to move back two directories
    at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can also run `cd ../../..` to move back three directories and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Moving around quickly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now I will show you some cool tricks that will make you fast and efficient in
    navigating the Linux directory tree.
  prefs: []
  type: TYPE_NORMAL
- en: Go back home!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s change to the `/var/log` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now run the `cd ~` command to go to your home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'WOW! Let''s do it again, but this time, we switch to user `angela`. In case
    you don''t know, the character is called tilde and should be located next to your
    number *1* key on your keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice here I used two new commands. The `whoami` command prints the name of
    the currently logged-in user. I also used the switch user `su` command to switch
    to user `angela`. You can use the `su` command to switch to any user on your system;
    you just need to run `su`, followed by the username.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as user `angela`, I will navigate to the `/var/log` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then I run the `cd ~` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Boom! I am at Angela's home directory. Regardless of your current working directory,
    running the `cd ~` command will land you straight to your home directory.
  prefs: []
  type: TYPE_NORMAL
- en: Take me back!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, what if `angela` wants to go back as quickly as possible to her previous
    working directory?
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the `cd -` command is the fastest method that will land `angela` back
    to her previous working directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Cool! `angela` is back in `/var/log`. So anytime you want to go back to your
    previous working directory, just run the `cd -` command.
  prefs: []
  type: TYPE_NORMAL
- en: Hidden Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current directory `.` and the parent directory `..` exist under each directory
    in the Linux filesystem. But how come we can't see them when we run the `ls` command?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, I even tried to run `ls -l` and still can't see the current
    directory or the parent directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to use the `-a` option with the `ls` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Hooray! Now you can see all the files. The `-a` option shows you all the files,
    including hidden files and of course you can use the full option name `--all`,
    which will do the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: It turns out that any filename that starts with `.` (a dot) is hidden.
  prefs: []
  type: TYPE_NORMAL
- en: Hidden filenames start with `.`
  prefs: []
  type: TYPE_NORMAL
- en: Any filename that starts with a dot is hidden. That's why current and parent
    directories are hidden.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate further, go to your user home directory and run the `ls` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the `ls -a` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can now see the hidden files in your home directory! Notice all the hidden
    filenames start with a dot.
  prefs: []
  type: TYPE_NORMAL
- en: Passing command arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we ran the `ls` command only on the current working directory. However,
    you can list the contents of any directory without having to change to it. For
    example, if your current working directory is `/home/elliot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can list all the files in `/home/angela` by running the `ls -a /home/angela`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: I was able to list the contents of `/home/angela` while still being in `/home/elliot`.
    This is possible because the `ls` command accepts any file as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT IS AN ARGUMENT?**'
  prefs: []
  type: TYPE_NORMAL
- en: An argument, also called a command-line argument, is simply any filename or
    data that is provided to a command as an input.![](img/1605fa32-1bc3-4a70-a403-d093fab29d97.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11: Linux Command Structure'
  prefs: []
  type: TYPE_NORMAL
- en: You can see in the preceding image the general structure of a Linux command.
  prefs: []
  type: TYPE_NORMAL
- en: In Linux terminology, we use the verb **pass** when talking about command options
    and arguments. To use the correct Linux terminology, for example, in the preceding
    image, we say, "We passed the `/home/angela` directory as an argument to the `ls`
    command."
  prefs: []
  type: TYPE_NORMAL
- en: You will often find Linux users very keen on using the right terminology. Moreover,
    using the proper terminology can help you pass a job interview and land your dream
    job!
  prefs: []
  type: TYPE_NORMAL
- en: Notice in the preceding figure, we used the plural nouns *options* and *arguments*.
    That's because some commands can accept multiple options and arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can do a long listing for all the files in `/home/angela` by
    running the `ls -a -l /home/angela` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'So now you see a long listing of all the files in `/home/angela` including
    the hidden files, also notice that the ordering of the options doesn''t matter
    here, so if you run the `ls -l -a /home/angela` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the same result. This was an example of passing two commands options,
    what about passing two arguments? Well, you can do a long listing for all the
    files in `/home/angela` and `/home/elliot` at the same time by passing `/home/elliot`
    as a second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: So now, you can see the contents of both the `/home/elliot` and `/home/angela`
    directories at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The touch command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s do a long listing for all the files in `/home/elliot` one more time
    to discuss something very important:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Focus on the last two columns of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Jan 20 16:26` | `.` |'
  prefs: []
  type: TYPE_TB
- en: '| `Jan 17 04:37` | `..` |'
  prefs: []
  type: TYPE_TB
- en: '| `Jan 20 13:43` | `.bash_history` |'
  prefs: []
  type: TYPE_TB
- en: '| `Dec 26 23:47` | `.bash_logout` |'
  prefs: []
  type: TYPE_TB
- en: '| `Dec 26 23:47` | `.bashrc` |'
  prefs: []
  type: TYPE_TB
- en: '| `Jan 19 14:20` | `Desktop` |'
  prefs: []
  type: TYPE_TB
- en: '| `Apr 4 2018` | `.profile` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3: Last Two Columns of ls -a -l /home/elliot'
  prefs: []
  type: TYPE_NORMAL
- en: You already know that the last column of the output (2nd column of `Table 3`)
    shows the filenames, but what about all these dates that are displayed in the
    preceding column (1st column of `Table 3`)?
  prefs: []
  type: TYPE_NORMAL
- en: The dates in the first column of `Table 3` represent the last modification time
    of each file, which is the last time a file was modified (edited).
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `touch` command to change the modification time of a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, let''s first get the modification time on `elliot`''s `Desktop`
    directory, you can do that by running the `ls -l -d /home/elliot/Desktop` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Notice we used the `-d` option, so it does a long listing on the directory `/home/elliot/Desktop`
    instead of listing the contents of the directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last modification time is shown to be: `Jan 19 14:20`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if you run the `touch /home/elliot/Desktop` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You will see that the last modification time of the directory `/home/elliot/Desktop`
    has now changed to `Jan 20 19:42`, which reflects the current time.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you will get a different result on your system because you will not
    be running the command at the same time as me.
  prefs: []
  type: TYPE_NORMAL
- en: Ok, great, so now we understand that the `touch` command can be used to update
    a file's modification time. Can it do something else? Hmmm, let's see.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we try to update the modification time of a file that doesn''t exist?
    What will happen? The only way to know is to try it. Notice that user `elliot`
    has only one visible (not hidden) file in his home directory, which happens to
    be the `Desktop` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now watch what will happen when user `elliot` runs the `touch blabla` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: It created an empty file named `blabla`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do two things with the `touch` command:'
  prefs: []
  type: TYPE_NORMAL
- en: You can update the last modification and access times of existing files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can create new empty files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `touch` command can only create regular files; it cannot create directories.
    Also, notice that it updates modification and access times, so what is the difference?
  prefs: []
  type: TYPE_NORMAL
- en: Modification Time > Last time a file was changed or modified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access Time > Last time a file was accessed (read).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By default, the `touch` command changes both the modification and access times
    of a file. I have created three files in `elliot`''s home directory: `file1`,
    `file2`, and `file3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now to change only the modification time of `file1`. We pass the `-m` option
    to the `touch` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the modification time of `file1` has now changed. I promised
    you I would only change the modification time, right? If you pass the `-u` option
    along with the `-l` option to the `ls` command, you will get the last access times
    instead of the modification times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the last modification time of `file1` is changed to `Jan 25
    23:08`, but the access time is left unchanged: `Feb 29 2004`. Now this time around,
    let''s only change the access time of `file2`. To do this, we pass the `-a` option
    to the `touch` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the modification time of `file2` was left unchanged, but the
    access time is changed to the current time. Now to change both the modification
    and access times of `file3`, you can run the `touch` command with no options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! You can also pass the `-t` option to the `ls` command to list the
    files sorted by modification times, newest first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add the `-u` option to sort by access times instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also pass the `-r` option to reverse the sorting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Making directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create directories in Linux, we use the `mkdir` command, which is short for
    **make directory**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `elliot`''s desktop, let''s create a directory named `games` by running
    the `mkdir games` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Notice that my current working directory is `/home/elliot/Destkop`; that's why
    I was able to use a relative path.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53b62972-d736-4a08-87ed-b880f540c414.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12: games Directory Created on the Desktop'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create multiple directories at the same time. For example, you
    can create three directories – `Music`, `Movies`, and `Books` – on your desktop
    by running the `mkdir Music Movies Books` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/ce2df5e4-c1ec-4ecd-afb5-0789d584b925.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13: Directories Created on the Desktop'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `-p` option to create a whole path of directories. For
    example, you can create the path `/home/elliot/dir1/dir2/dir3` by running the
    `mkdir -p dir1/dir2/dir3` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: It created `dir1` in the `/home/elliot` directory, and then it created `dir2`
    inside of `dir1`, and finally, it created `dir3` inside of `dir2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the recursive `-R` option to do a recursive listing on `/home/elliot/dir1`
    and see all the files underneath `/home/elliot/dir1` without the hassle of changing
    to each directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it listed all the files under `/home/elliot/dir1`. It even displayed
    the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create a new directory with multiple subdirectories by including
    them inside a pair of curly brackets and each subdirectory separated by a comma
    like in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we created `dir4`, and inside it, we created three directories
    – `dir5`, `dir6`, and `dir7`.
  prefs: []
  type: TYPE_NORMAL
- en: Combining command options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have learned a lot of different options that you can use with the `ls` command.
    `Table 4` summarizes all the options we have used so far.
  prefs: []
  type: TYPE_NORMAL
- en: '| **ls option** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| `-l` | Long and detailed listing of files. |'
  prefs: []
  type: TYPE_TB
- en: '| `-a` | List the hidden files. |'
  prefs: []
  type: TYPE_TB
- en: '| `-d` | List directories themselves, not their contents. |'
  prefs: []
  type: TYPE_TB
- en: '| `-t` | Sort files by modification times. |'
  prefs: []
  type: TYPE_TB
- en: '| `-u` | When used with `-l`, it shows access times instead of modification
    times. When used with `-lt`, it will sort by, and show, access times. |'
  prefs: []
  type: TYPE_TB
- en: '| `-r` | Will reverse listing order. |'
  prefs: []
  type: TYPE_TB
- en: '| `-R` | List subdirectories recursively. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4: Popular ls Command Options'
  prefs: []
  type: TYPE_NORMAL
- en: You will often be wanting to use two or more command options at a time. For
    example, `ls -a -l` is commonly used to do a long listing for all the files in
    a directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, `ls -l -a -t -r` is a very popular combination because sometimes you
    would want to see the listing of the files sorted by modification times (oldest
    first). For that reason, combining the command options is more efficient and so
    running the `ls -latr` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Will yield the same result as running the `ls -l -a -t -r` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Before this chapter comes to an end, I want to show you a pretty cool tip.
    First, let''s create a directory named `averylongdirectoryname`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '**Tab Completion** is one of the most useful features in the Linux command
    line. You can use this to feature to let the shell automatically complete (suggest)
    command names and file paths. To demonstrate, type (don''t run) the following
    text on your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now press the *Tab* key on your keyboard, and the shell will automatically
    complete the directory name for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Pretty cool! Alright, this takes us to the end of this chapter, and it's time
    for you to do the lovely knowledge check.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the following exercises, open up your terminal and try to solve the following
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Do a long listing for all the files in `/var/log`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the contents of the file `/etc/hostname`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create three files – `file1`, `file2`, and `file3` – in `/home/elliot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List all the files (including hidden files) of `elliot`'s home directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a directory named `fsociety` in `/home/elliot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`/home/root` is the home directory of the root user.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`dir1/dir2/dir3` is an example of an absolute path.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/home/elliot/Desktop` is an example of an absolute path.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`touch -m file1` will update `file1` access time.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`mkdir dir1 dir2 dir3` will create three directories – `dir1`, `dir2`, and
    `dir3`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
