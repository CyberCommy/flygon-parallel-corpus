- en: Why Not Automate Your Marketing Campaign?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes, which are related to
    a marketing campaign:'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the opportunities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating personalized coupon codes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending a notification to the customer on their preferred channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing sales information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a sales report
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create a whole marketing campaign, going through each
    of the automatic steps we'll take. We will leverage all the concepts and recipes
    throughout the book in a single project that will require different steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example. For our project, our company  wishes to set up up a
    marketing campaign to improve engagement and sales. A very laudable effort. To
    do so, we can divide the action into several steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We want to detect the best moment to launch the campaign, so we will be notified
    from different sources about keywords that will help us make an informed decision
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The campaign will include the generation of individual codes to be sent to potential
    customers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parts of these codes will be sent directly to users over their preferred channel,
    text message or email
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To monitor the result of the campaign, the sales information will be compiled
    and a sales report will be generated
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This chapter will go through each of these steps and present a combined solution
    based on modules and techniques that have been introduced in the book.
  prefs: []
  type: TYPE_NORMAL
- en: While these examples have been created with real-life requirements in mind,
    take into account that your specific environment will always surprise you. Don't
    be afraid to experiment, tweak, and improve your system as you learn more about
    it. Iterating is the way to create great systems.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get to it!
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the opportunities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we present a marketing campaign that is divided into several
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Detect the best moment to launch the campaign
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate individual codes to be sent to potential customers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the codes directly to users over their preferred channel, text message
    or email
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collate the results of the campaign and generate a sales report with analysis
    of the results
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This recipe shows step 1 of the campaign.
  prefs: []
  type: TYPE_NORMAL
- en: Our first stage is to detect the best time to launch a campaign. To do so, we
    will monitor a list of news sites, searching for news containing one of our defined
    keywords. Any article that matches these keywords will be added to a report that
    will be sent in an email.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will use several external modules previously presented in
    the book, `delorean`, `requests`, and `BeautifulSoup`. We need to add them to
    our virtual environment if not already there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You need to make a list of RSS feeds, from which we will put our data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we use the following feeds, which are all technology feeds
    in well-known news sites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://feeds.reuters.com/reuters/technologyNews](http://feeds.reuters.com/reuters/technologyNews)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://rss.nytimes.com/services/xml/rss/nyt/Technology.xml](http://rss.nytimes.com/services/xml/rss/nyt/Technology.xml)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://feeds.bbci.co.uk/news/science_and_environment/rss.xml](http://feeds.bbci.co.uk/news/science_and_environment/rss.xml)'
  prefs: []
  type: TYPE_NORMAL
- en: Download the `search_keywords.py` script, which will perform the actions, from
    GitHub at [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/search_keywords.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/search_keywords.py).
  prefs: []
  type: TYPE_NORMAL
- en: You also need to download the email templates, which can be found at [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/email_styling.html](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/email_styling.html)
    and [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/email_template.md](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/email_template.md).
  prefs: []
  type: TYPE_NORMAL
- en: There is a config template in [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/config-opportunity.ini](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/config-opportunity.ini).
  prefs: []
  type: TYPE_NORMAL
- en: You need a valid username and password for an email service. Check the *Sending
    an individual email* recipe in [Chapter 8](aefbed90-7a63-4611-b430-85d216ab03c0.xhtml), *Dealing
    with Communication Channels*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a `config-opportunity.ini` file, which should be in the following format.
    Remember to fill it with your details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can use the template from  GitHub at [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/config-opportunity.ini](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/config-opportunity.ini)
    to search for the keyword `cpu`and some test feeds. Remember to fill in the `EMAIL`
    fields with your own account details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call the script to produce the email and report:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the `to` email, and you should receive a report with the articles found.
    It should be something similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/83e66ce4-be5b-46e2-96f3-5a4c5390865c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After creating the proper configuration for the script in step 1, web scraping
    and sending an email with the results is done in step 2 by calling `search_keywords.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `search_keywords.py` script. The code is structured
    into the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The `IMPORTS` section makes available all the Python modules to be used later.
    It also defines `EmailConfig namedtuple` to help with handling the email parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`READ TEMPLATES` retrieves the email templates and stores them for later use
    in the `EMAIL_TEMPLATE` and `EMAIL_STYLING` constants.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__main__` block starts the process by, getting the configuration parameters,
    parsing the config file, and then calling the main function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `main` function combines the other functions. First, it retrieves the articles,
    and then it obtains the body and sends the email.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_articles` walks through all the feeds, discards any article that is over
    a week old, retrieves each of them, and searches for a match on the keywords.
    All the matched articles are returned, including information about the link and
    a summary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compose_email_body` uses the email templates to compile the email body. Notice
    that the template is in Markdown and it gets parsed into HTML, to give the same
    information in plain-text and in HTML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`send_email` gets the body information, as well as required info such as the
    username/password, and finally sends the email.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main challenges in retrieving information from different sources
    is to parse the text in all cases. Some of the feeds may return information in
    different formats.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in our example you can see that the Reuters feed summary includes
    HTML information that gets rendered in the resulting email. If you have that kind
    of problem, you may need to process the returned data further, until it becomes
    consistent. This may be highly dependent on the expected quality of the resulting
    report.
  prefs: []
  type: TYPE_NORMAL
- en: When developing automatic tasks, especially when dealing with multiple input
    sources, expect to spend a lot of time cleaning the input in a way that's consistent.
    But, on the other hand, find a balance and keep in mind the final recipient. If
    the email is to be received, for example, by yourself or an understanding teammate,
    you can be a little bit more permissive than in the case of an important client.
  prefs: []
  type: TYPE_NORMAL
- en: Another possibility is to increase the complexity of the match. In this recipe,
    the check is done with a simple `in`, but remember that all the techniques in
    [Chapter 1](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml), *Let Us Begin Our Automation
    Journey, * including all the regular expression capabilities, are available for
    you to use.
  prefs: []
  type: TYPE_NORMAL
- en: This script is automatable through a cron job as described in [Chapter 2](6b1d9f13-f2de-41f1-a87b-6896ceb7b280.xhtml),
    *Automating Tasks Made Easy*. Try to run it every week!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Adding command line arguments* recipe in [Chapter 1](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml), *Let
    Us Begin Our Automation Journey*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Introducing regular expressions recipe in [Chapter 1](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml), *Let
    Us Begin Our Automation Journey*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Preparing a task* recipe in [Chapter 2](6b1d9f13-f2de-41f1-a87b-6896ceb7b280.xhtml), *Automating
    Tasks Made Easy*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Setting up a cron job* in [Chapter 2](6b1d9f13-f2de-41f1-a87b-6896ceb7b280.xhtml), *Automating
    Tasks Made Easy*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Parsing HTML* in [Chapter 3](d640524b-3aa3-406e-a6d4-842bc61c4658.xhtml), *Building
    Your First Web Scraping Application*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Crawling the web* recipe in [Chapter 3](d640524b-3aa3-406e-a6d4-842bc61c4658.xhtml), *Building
    Your First Web Scraping Application*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Subscribing to feeds recipe in  [Chapter 3](d640524b-3aa3-406e-a6d4-842bc61c4658.xhtml), *Building
    Your First Web Scraping Application*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Sending an individual email recipe in [Chapter 8](aefbed90-7a63-4611-b430-85d216ab03c0.xhtml), *Dealing
    with Communication Channels*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating personalized coupon codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are presenting a marketing campaign divided into steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Detect the best moment to launch the campaign
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate individual codes to be sent to potential customers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the codes directly to users over their preferred channel, text message
    or email
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collect the results of the campaign
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a sales report with analysis of the results
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This recipe shows step 2 of the campaign.
  prefs: []
  type: TYPE_NORMAL
- en: 'After an opportunity is detected, we decide to generate a campaign for all
    customers. To direct promotions and avoid duplication, we will generate a million
    unique coupons, divided into three batches:'
  prefs: []
  type: TYPE_NORMAL
- en: Half of the codes will be printed and distributed in a marketing action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 300,000 codes will be reserved to be used later if the campaign hits some goals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remainder 200,000 will be directed to customers through SMS and emails,
    as we will see later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These coupons can be redeemed in the online system. Our task will be to generate
    the proper codes, which should meet the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The codes need to be unique
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The codes need to be printable and easy to read, as some customers will be dictating
    them over the phone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There should be a quick way of discarding codes before checking them (avoiding
    spam attacks)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The codes should be presented in a CSV format for printing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Download the `create_personalised_coupons.py` script, which will generate the
    coupons in CSV files, from GitHub at [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/create_personalised_coupons.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/create_personalised_coupons.py).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Call the `create_personalised_coupons.py` script. It will take a minute or
    two to run, depending on your computer speed. It will display the generated codes
    onscreen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Check it created three CSV files with the codes `codes_batch_1.csv`, `codes_batch_2.csv`,
    and `codes_batch_3.csv`, each with the proper number of codes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that each of the batch files contains unique codes. Your codes will be
    unique and different from the ones displayed here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Step 1 calls the script that generates all the codes, and step 2 checks that
    the results are correct. Step 3 shows the format in which the codes are stored.
    Let's analyze the `create_personalised_coupons.py` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, it has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The different functions work together to create a code. `random_code ` generates
    a combination of random letters and numbers, taken from `CHARACTERS`.  This string
    contains all the valid characters to choose from.
  prefs: []
  type: TYPE_NORMAL
- en: The selection of characters is defined as symbols that are easy to print and
    not mistake for each other. For example, it will be difficult to distinguish between
    a letter O and the number 0, or the number 1 and the letter I, depending on the
    font. This may depend on the specifics, so check printing tests if necessary to
    tailor the characters. But avoid using all letter and numbers, as it may cause
    confusion. Increase the length of the codes if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The `checksum` function generates, based on two codes, an extra digit that is
    derived from the two codes. This process is called **hashing**, and it's a well
    known process in computing, especially for cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: The basic function of hashing is to produce an output from an input that is
    smaller and is not reversible, meaning it's very difficult to guess unless the
    input is known. Hashing has a lot of common applications in computing, normally
    under the hood. For example, Python dictionaries make extensive use of hashing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our recipe, we''ll use SHA256, a well known fast hashing algorithm included
    in the Python `hashlib` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Both codes are added as input, and the resulting two hex digits of the hash
    are applied over `CHARACTERS` to obtain one of the available characters. The digits
    get transformed into a number (as they are in base 16) and we apply the `modulo`
    operator to be sure to obtain one of the available characters.
  prefs: []
  type: TYPE_NORMAL
- en: The objective of this checksum is to be able to quickly check whether a code
    looks like it is correct and discard possible spam. We can produce the operation
    again over a code to see whether the checksum is the same. Note that this is not
    a cryptographic hash, as no secret is required at any point of the operation.
    Given this specific use case, this (low) level of security is probably fine for
    our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography is a much bigger theme and ensuring that security is strong can
    be difficult. The main strategy in cryptography involving hashing is probably
    to store just the hash to avoid storing passwords in a readable format. You can
    read a quick intro to that here: [https://crackstation.net/hashing-security.htm](https://crackstation.net/hashing-security.htm).
  prefs: []
  type: TYPE_NORMAL
- en: The `generate_code` function then produces a random code, composed of four digits,
    then five digits, and then two digits of the checksum, divided by dashes. The
    first digit is generated with the first nine digits in order (four then five),
    and the second reversing them (five then four).
  prefs: []
  type: TYPE_NORMAL
- en: The `check_code` function reverses the process and returns `True` if the code
    is correct, and `False` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: With the basic elements in place, the script starts by defining the required
    batches—500,000, 300,000, and 200,000.
  prefs: []
  type: TYPE_NORMAL
- en: All the codes are generated in the same pool, called `codes`. This is to avoid
    duplicates between pools. Note that, due to the randomness of the process, we
    can't rule out the possibility of generating a duplicated code, though this is
    small. We allow to retry up to three times to avoid generating a duplicate code.
    The codes are added to a set accumulator to guarantee their uniqueness and to
    speed up checking whether a code is already there.
  prefs: []
  type: TYPE_NORMAL
- en: '`sets` are another of the places where Python uses hashing under the hood,
    so it hashes the element to be added and compares it with the hashes of the elements
    already there. This makes checking in sets very quick.'
  prefs: []
  type: TYPE_NORMAL
- en: To be sure that the process is correct, each code is verified and printed to
    display progress while generating the code and allow inspecting that everything
    is working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the codes are divided into the proper number of batches and each one
    is saved in an individual `.csv` file. The codes are removed removed one by one
    from `codes` using `.pop()` until the `batch` has the proper size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note how the previous line creates a batch of the proper size of rows with a
    single element. Each row is still a list, as it should be for a CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: Then, a file is created and, using a `csv.writer`, the codes are stored as rows.
  prefs: []
  type: TYPE_NORMAL
- en: As a final test, the remaining `codes` are verified to be empty.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, a direct approach has been used in the flow. This is in opposition
    to the principles presented in the *Preparing a task to run* recipe in [Chapter
    2](6b1d9f13-f2de-41f1-a87b-6896ceb7b280.xhtml), *Automating Tasks Made Easy*.
    Notice that, compared with the tasks presented there, this script is aimed to
    be run a single time to produce the codes, and that's it. It also uses defined
    constants, such as `BATCHES`, for configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Given that it is a unique task, designed to be run once, spending time structuring
    it into a reusable component is probably not the best use of our time.
  prefs: []
  type: TYPE_NORMAL
- en: Over-engineering is definitively possible, and choosing between a pragmatic
    design and a more future-facing approach may not be easy. Be realistic about maintenance
    costs and try to find your own balance.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, the design in this recipe on the checksum is aimed to give
    a minimum way to check whether a code is totally made up or looks legit. Given
    that codes will be checked against a system, this seems like a sensible approach,
    but be aware of your particular use case.
  prefs: []
  type: TYPE_NORMAL
- en: Our code space is of `22 characters ** 9 digits = 1,207,269,217,792 possible
    codes`, meaning the probability of guessing one of the million generated is very
    small. Is also not very likely to produce the same code twice, but nevertheless,
    we protected our code against that with up to three retries.
  prefs: []
  type: TYPE_NORMAL
- en: These kinds of checks, as well as checking that each code verifies and that
    we end up with no remaining codes, are very useful when developing this kind of
    script. It ensures that we are going in the right direction and things are going
    according to plan. Just be aware that `asserts` may not be executed in some conditions.
  prefs: []
  type: TYPE_NORMAL
- en: As described in the Python documentation, `assert` commands are ignored if the
    Python code is optimized (run with the `-O` command). See the documentation here [https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement](https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement).
    This is normally not done, but can be confusing if that's the case. Avoid depending
    heavily on `asserts`.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the basics of cryptography is not as difficult as you may assume. There
    are a small number of basic schema that are well known and easily learned. A good
    introduction article is this one, [https://thebestvpn.com/cryptography/](https://thebestvpn.com/cryptography/).
    Python also has a good number of cryptographic functions integrated; see the documentation
    at [https://docs.python.org/3/library/crypto.html](https://docs.python.org/3/library/crypto.html).
    The best approach is to find a good book and know that, while it's a difficult
    subject to truly master, it is definitely approachable.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Introducing regular expressions* recipe in [Chapter 1](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml),
    *Let Us Begin Our Automation Journey *
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reading CSV files* recipe in [Chapter 4](e8536572-46e4-41ec-87b8-7f775fd61e63.xhtml), *Searching
    and Reading Local Files*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending a notification to the customer on their preferred channel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are presenting a marketing campaign divided into several
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Detect the best moment to launch the campaign
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate individual codes to be sent to potential customers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the codes directly to users over their preferred channel, text message
    or email
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collect the results of the campaign
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a sales report with analysis of the results
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This recipe shows step 3 of the campaign.
  prefs: []
  type: TYPE_NORMAL
- en: Once our codes are created for direct marketing, we need to distribute them
    to our customers.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, from an input from a CSV file with the information of all customers
    and their preferred contact methods, we will fill the file with the codes generated
    previously, and then send a notification through the proper method that will include
    the promotional code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will use several modules already presented—`delorean`, `requests`,
    and `twilio`. We need to add them to our virtual environment if not already there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We need to define a `config-channel.ini` file with our credentials for the services
    to use, Mailgun and Twilio. A template of this file can be found in GitHub here: [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/config-channel.ini](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/config-channel.ini).
  prefs: []
  type: TYPE_NORMAL
- en: For information on how to obtain the credentials, refer to the *Sending notifications
    via emails* and *Producing SMS* recipes [Chapter 8](aefbed90-7a63-4611-b430-85d216ab03c0.xhtml), *Dealing
    with Communication Channels*
  prefs: []
  type: TYPE_NORMAL
- en: 'The file has the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For a description of all the contacts to target, we need to generate a CSV
    file, `notifications.csv`, in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Contact Method | Target | Status | Code | Timestamp |'
  prefs: []
  type: TYPE_TB
- en: '| John Smith | PHONE | +1-555-12345678 | `NOT-SENT` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Paul Smith | EMAIL | `paul.smith@test.com` | `NOT-SENT` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| … |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: Note that the `Code` column is empty, and all statuses should be `NOT-SENT`
    or empty.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a test account in Twilio and Mailgun, be aware of its limitations.
    For example, Twilio only allows you to send messages to authenticated phone numbers.
    You can create a small CSV with only two or three contacts to test the script.
  prefs: []
  type: TYPE_NORMAL
- en: The coupon codes to be used should be ready in a CSV file. You can generate
    several batches with the `create_personalised_coupons.py` script, available in
    GitHub at [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/create_personalised_coupons.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/create_personalised_coupons.py).
  prefs: []
  type: TYPE_NORMAL
- en: Download the script to be used, `send_notifications.py`, from GitHub at [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/send_notifications.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/send_notifications.py).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run `send_notifications.py` to see its options and usage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the codes to the `notifications.csv` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, send the notifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Check the emails and phones to verify the messages were received.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Step 1 shows the use of the script. The general idea is to call it several times,
    the first to fill it with codes, and the second to send the messages. If there's
    an error, the script can be executed again, and only messages not previously sent
    will be retried.
  prefs: []
  type: TYPE_NORMAL
- en: The `notifications.csv` file gets the codes that will be injected in step 2\.
    The codes are finally sent in step 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze the code of `send_notifications.py`. Only the most relevant
    bits are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The main function goes through the file line by line and analyzes what to do
    in each case. If the entry is `SENT`, it skips it. If it has no code, it tries
    to fill it. If it tries to send it, it will attach the timestamp to record when
    it was sent or tried to be sent.
  prefs: []
  type: TYPE_NORMAL
- en: For each entry, the whole file is saved again in a file called `save_file`.
    Notice how the file cursor is positioned at the start of the file, the file is
    written, and then flushed to disk. This makes the file overwritten on each entry
    operation, without having to close and open the file again.
  prefs: []
  type: TYPE_NORMAL
- en: Why write the whole file for each entry? This is to allow you to retry. If one
    of the entries produces an unexpected error or a timeout, or even if there's a
    general failure, all the progress and previous codes will be marked as `SENT`
    already, and not sent a second time. This means the operation can be retried needed.
    For a huge number of entries, this is a good way of ensuring that a problem in
    the middle of the process doesn't make us resend messages to our customers.
  prefs: []
  type: TYPE_NORMAL
- en: For each code to be sent, the `send_notification` function decides to call either `send_phone_notification`
    or `send_email_notification`. It appends the current time in both cases.
  prefs: []
  type: TYPE_NORMAL
- en: Both `send` functions return an error if they can't send the message. This allows
    you to mark it in the resulting `notifications.csv` and retry it later.
  prefs: []
  type: TYPE_NORMAL
- en: The `notifications.csv` file can also be changed manually. For example, imagine
    there's a typo in an email and that's the reason for the error. It can be changed
    and retried.
  prefs: []
  type: TYPE_NORMAL
- en: '`send_email_notification` sends the message based on the Mailgun interface.
    For more information, refer to the *Sending notifications via emails* recipe in
    [Chapter 8](aefbed90-7a63-4611-b430-85d216ab03c0.xhtml), *Dealing with Communication
    Channels*. Note that the email sent here is text only.'
  prefs: []
  type: TYPE_NORMAL
- en: '`send_phone_notification` sends the message based on the Twilio interface. For
    more information, refer to the *Producing SMS* recipe in [Chapter 8](aefbed90-7a63-4611-b430-85d216ab03c0.xhtml),
    *Dealing with Communication Channels*.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The format of the timestamp has been deliberately written in ISO format, as
    it is a parsable format. This means that we can get back a proper object in an
    easy way, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This allows you to easily parse the timestamp back and forth.
  prefs: []
  type: TYPE_NORMAL
- en: ISO 8601 time format is well supported in most programming languages and very
    precisely defines the time, as it includes the time zone. It is an excellent choice
    for recording times, if you can use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The strategy used in `send_notification` to route the notifications is an interesting
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `METHOD` dictionary assigns each of the possible `Contact Method` to a function
    that has the same definition, accepting both an entry and a config.
  prefs: []
  type: TYPE_NORMAL
- en: Then, based on the specific method, the function is retrieved from the dictionary
    and called. Note the `method` variable contains the correct function to call.
  prefs: []
  type: TYPE_NORMAL
- en: This acts in a similar way to the `switch` operation that is available in other
    programming languages. It is also possible to achieve this through `if…else` blocks.
    For simple cases like this code, the dictionary method makes the code very readable.
  prefs: []
  type: TYPE_NORMAL
- en: The `invalid_method` function is used as a default. If the `Contact Method`
    is not one of the available ones (`PHONE` or `EMAIL`), a `KeyError` will be raised,
    captured, and the result will be defined as `INVALID METHOD`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Sending notifications via emails* recipe in [Chapter 8](aefbed90-7a63-4611-b430-85d216ab03c0.xhtml), *Dealing
    with Communication Channels *
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Producing SMS* recipe in [Chapter 8](aefbed90-7a63-4611-b430-85d216ab03c0.xhtml), *Dealing
    with Communication Channels *
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing sales information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are presenting a marketing campaign divided into several
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Detect the best moment to launch the campaign
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate individual codes to be sent to potential customers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the codes directly to users over their preferred channel, text message
    or email
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collect the results of the campaign
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a sales report with analysis of the results
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This recipe shows step 4 of the campaign.
  prefs: []
  type: TYPE_NORMAL
- en: After sending the information to users, we need to collect the sales log from
    the shops to monitor how it is going and how big the campaign's impact is.
  prefs: []
  type: TYPE_NORMAL
- en: The sales logs are reported as individual files from each of the associated
    shops, so in this recipe we'll see how to aggregate all the info into a spreadsheet
    to be able to treat the information as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we need to install the following modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can obtain a test structure and test logs for this recipe from GitHub at [https://github.com/PacktPublishing/Python-Automation-Cookbook/tree/master/Chapter09/sales](https://github.com/PacktPublishing/Python-Automation-Cookbook/tree/master/Chapter09/sales).
    Please download the full `sales` directory, which contains a lot of test logs. To
    display the structure, we'll use the `tree` command ([http://mama.indstate.edu/users/ice/tree/](http://mama.indstate.edu/users/ice/tree/)),
    which is installed by default in Linux and can be installed using `brew` in macOs
    ([https://brew.sh/](https://brew.sh/)). You can use a graphical tool to inspect
    the directory as well.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also need the `sale_log.py` module and the `parse_sales_log.py` script,
    available in GitHub at [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/parse_sales_log.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/parse_sales_log.py).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check the structure of the `sales` directory. Each subdirectory represents
    a shop that has submitted its sales logs for the period:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Check  the log files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `parse_sales_log.py` script to generate the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the generated Excel result, `report.xlsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f0a6152c-2b86-4262-9f0f-cf5283ba2602.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Steps 1 and 2 show how the data is structured. Step 3 calls `parse_sales_log.py `
    to read all the log files and parse them, and then stores them in an Excel spreadsheet.
    The contents of the spreadsheet are displayed in step 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how `parse_sales_log.py` is structured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The command line arguments are explained in [Chapter 1](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml),
    *Let Us Begin Our Automation Journey*. Note that the imports include `SaleLog`.
  prefs: []
  type: TYPE_NORMAL
- en: The main function walks through the whole directory and grabs all the files
    through `os.walk`. You can get more information about `os.walk` in [Chapter 2](6b1d9f13-f2de-41f1-a87b-6896ceb7b280.xhtml),
    *Automating Tasks Made Easy*. Each file is then passed to `get_logs_from_file`
    to parse its logs and add them to the global `logs` list.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the specific shop is stored in the last subdirectory, so it is extracted
    with `os.path.basename`.
  prefs: []
  type: TYPE_NORMAL
- en: Once the list of logs has been completed, a new Excel sheet is created using
    the `openpyxl` module. The `SaleLog` module has a `.row_header` method to add
    the first row, and then all the logs are converted to row format using `.row`.
    Finally, the file is saved.
  prefs: []
  type: TYPE_NORMAL
- en: 'To parse the logs, we make a module called `sale_log.py`. This abstracts parsing
    and dealing with a row. Most of it is straightforward and it structures each of
    the different parameters properly, but the parse method requires a bit of attention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`sale_log.py` is a *classmethod*, meaning that it can be used by calling `SaleLog.parse`,
    and it returns a new element of the class.'
  prefs: []
  type: TYPE_NORMAL
- en: Classmethodsare called with a first argument that stores the class, instead
    of the object normally stored in `self`. The convention is to use `cls` to represent
    it. Calling `cls(...) ` at the end is equivalent to `SaleFormat(...)`, so it calls
    the `__init__` method.
  prefs: []
  type: TYPE_NORMAL
- en: The method uses the `parse` module to retrieve the values from the template.
    Note how two elements, `timestamp` and `price`, have custom parsing. The `delorean` module helps
    us with parsing the date, and the price is better described as a `Decimal` to
    keep the proper resolution. The custom filters are applied in the `formats` argument.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Decimal` type is described in detail in the Python documentation here: [https://docs.python.org/3/library/decimal.html](https://docs.python.org/3/library/decimal.html).
  prefs: []
  type: TYPE_NORMAL
- en: The full `openpyxl` can be found here:[ https://openpyxl.readthedocs.io/en/stable/](https://openpyxl.readthedocs.io/en/stable/).
    Also, check [Chapter 6](404a9dc7-22f8-463c-9f95-b480dc17518d.xhtml), *Fun with
    Spreadsheets*, for more examples on how to use the module.
  prefs: []
  type: TYPE_NORMAL
- en: The full `parse` documentation can be found here: [https://github.com/r1chardj0n3s/parse](https://github.com/r1chardj0n3s/parse).
    [Chapter 1](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml), *Let Us Begin Our Automation
    Journey*, also describes this module in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using a third-party tool—parse* recipe in [Chapter 1](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml), *Let
    Us Begin Our Automation Journey  *
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Crawling and searching directories* recipe in [Chapter 4](e8536572-46e4-41ec-87b8-7f775fd61e63.xhtml), *Searching
    and Reading Local Files*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reading text files* recipe in [Chapter 4](e8536572-46e4-41ec-87b8-7f775fd61e63.xhtml), *Searching
    and Reading Local Files*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Updating an Excel spreadsheet* recipe in [Chapter 6](404a9dc7-22f8-463c-9f95-b480dc17518d.xhtml), *Fun
    with Spreadsheets*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a sales report
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are presenting a marketing campaign divided in several
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Detect the best moment to launch the campaign
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate individual codes to be sent to potential customers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the codes directly to users over their preferred channel, text message
    or email
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collect the results of the campaign
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a sales report with analysis of the results
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This recipe shows step 5 of the campaign.
  prefs: []
  type: TYPE_NORMAL
- en: As the final step, all the information about each of the sales is aggregated
    and displayed in a sales report.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll see how to leverage reading from spreadsheets, creating
    PDFs, and producing graphs to generate a comprehensive report automatically in
    order to analyze the performance of our campaign.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll require the following modules in our virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We'll need the `sale_log.py` module available in GitHub at [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/sale_log.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/sale_log.py).
  prefs: []
  type: TYPE_NORMAL
- en: The input spreadsheet is generated in the previous recipe, preparing sales information.
    Check there for more information.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the script to generate the input spreadsheet, `parse_sales_log.py`,
    from GitHub at [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/parse_sales_log.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/parse_sales_log.py).
  prefs: []
  type: TYPE_NORMAL
- en: Download the raw log files from GitHub at [https://github.com/PacktPublishing/Python-Automation-Cookbook/tree/master/Chapter09/sales](https://github.com/PacktPublishing/Python-Automation-Cookbook/tree/master/Chapter09/sales).
    Please download the full `sales` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Download the `generate_sales_report.py` script from GitHub at [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/generate_sales_report.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter09/generate_sales_report.py).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check the input file and the use of `generate_sales_report.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `generate_sales_report.py` script with the input file and an output
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the `output.pdf` output file. It will contain three pages, the first
    a brief summary and the second and third graphs with the sales by day and by shop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d1492287-b767-48b3-b522-fa5c294f4eb2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The second page shows a graph of sales by day:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/28b396ae-1c0d-4831-b27d-843ca484f302.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The third page divides the sales by shop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b3cbce7b-0a65-40b0-adff-515c6d66bee8.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Step 1 shows how to use the script and step 2 calls it on the input file. Let''s
    take a look at the basic structure of the `generate_sales_report.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There are two key elements—the aggregation of the logs in different ways (by
    shop and by day) and the generation of a summary in each case. The summary is
    generated with `generate_summary`, which, from a list of logs, generates a dictionary
    with its aggregated information. The aggregation of the logs is done in different
    styles in the `aggregate_by` functions.
  prefs: []
  type: TYPE_NORMAL
- en: '`generate_summary` produces a dictionary with the aggregated information, including
    start and end time, total income of all logs, total units, average discount, and
    a breakdown of the same data by product.'
  prefs: []
  type: TYPE_NORMAL
- en: The script is better understood by starting at the end. The main functions join
    all the different operations. Read each of the logs and transform them into native `SaleLog`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, it generates each of the pages into an intermediate PDF file:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief, generated by `create_summary_brief` over a general summary of all the
    data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logs are `aggregate_by_day`. A summary is created and a graph is produced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logs are `aggregate_by_shop`. A summary is created and a graph is produced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the intermediate PDF pages are joined, using `PyPDF2`, into a single file.
    Finally, the intermediate pages are deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Both `aggregate_by_day` and `aggregate_by_shop` return a list with a summary
    of each of the elements. In `aggregate_by_day`, we detect when a day ends by using
    `.end_of_day` to differentiate one day from another.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `graph` function does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Prepares all the data that is going to be displayed. That includes the number
    of units per tag (day or shop), and the total income per tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creates a top graph with the total income, split by product into stacked bars.
    To be able to do this, at the same time the total income is calculated, the baseline
    (the position where the next stack is located) is calculated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It divides the bottom part of the graph into as many graphs as there are products,
    and displays the number of units sold on each one, per tag (day or shop).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a better display, the graph is defined to be the size of an A4 sheet. It
    also allows us, using `skip_labels`, to print one of each *X* label on the second
    graph on the *X* axis to avoid overlapping. This is useful when displaying the
    days, and it's set to show only one label per week.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting graph is saved to a file.
  prefs: []
  type: TYPE_NORMAL
- en: '`create_summary_brief` uses the `fpdf` module to save a text PDF page with
    the total summary information.'
  prefs: []
  type: TYPE_NORMAL
- en: The template and information in `create_summary_brief` has been left deliberately
    simple to avoid complicating this recipe, but it can be complicated with better
    descriptive text and formatting. Refer to [Chapter 5](d628b5e8-8d78-4884-905c-18b393bfcb47.xhtml), *Generating Fantastic
    Reports*, for more details on how to use `fpdf`*.*
  prefs: []
  type: TYPE_NORMAL
- en: As shown before, the `main` function groups all the PDF pages and joins them
    into a single document, removing the intermediate pages later.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The reports included in this recipe could be expanded. For example, the average
    discount could be calculated in each of the pages and displayed as a line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Be careful not to put too much information in a single graph, though. It may
    reduce the readability. In this case, another graph is probably a better way of
    displaying it.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful to print the legend before creating the second axis, or it will display
    only the information on the second axis.
  prefs: []
  type: TYPE_NORMAL
- en: The size and orientation of the graphs can determine whether to use more labels
    or fewer, so they are clear and readable. This is demonstrated in the use of `skip_labels`
    to avoid clutter. Keep an eye on the resulting graphics and try to adapt to possible
    problems in that area by changing sizes or limiting labels in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a possible limit is to have no more than three products, as printing
    four graphs in the second row in our graphs will probably make the text illegible.
    Feel free to experiment and check the limits of the code.
  prefs: []
  type: TYPE_NORMAL
- en: The complete `matplotlib` documentation can be found at [https://matplotlib.org/](https://matplotlib.org/).
  prefs: []
  type: TYPE_NORMAL
- en: The `delorean` documentation can be found here: [https://delorean.readthedocs.io/en/latest/](https://delorean.readthedocs.io/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: All the documentation for `openpyxl` is available at [https://openpyxl.readthedocs.io/en/stable/](https://openpyxl.readthedocs.io/en/stable/).
  prefs: []
  type: TYPE_NORMAL
- en: The full documentation for the PDF manipulation modules can be found for PyPDF2
    at [https://pythonhosted.org/PyPDF2/](https://pythonhosted.org/PyPDF2/) and  for
    `pyfdf` at [https://pyfpdf.readthedocs.io/en/latest/](https://pyfpdf.readthedocs.io/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: This recipe makes use of different concepts and techniques that are available
    in [Chapter 5](d628b5e8-8d78-4884-905c-18b393bfcb47.xhtml), *Generating Fantastic
    Reports*, for PDF creation and manipulation, [Chapter 6](404a9dc7-22f8-463c-9f95-b480dc17518d.xhtml),
    *Fun with Spreadsheets*, for spreadsheet reading, and [Chapter 7](2f949287-3e2a-4aaa-b59c-e2662522f2c5.xhtml),
    *Developing Stunning Graphs*, for graph creation. Check them out to know more.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Aggregating PDF* reports recipe in [Chapter 5](d628b5e8-8d78-4884-905c-18b393bfcb47.xhtml), *Generating
    Fantastic Reports*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reading an Excel* spreadsheet recipe in [Chapter 6](404a9dc7-22f8-463c-9f95-b480dc17518d.xhtml), *Fun
    with Spreadsheets*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Drawing stacked bars* recipe in [Chapter 7](2f949287-3e2a-4aaa-b59c-e2662522f2c5.xhtml),
    *Developing Stunning Graphs*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Displaying multiple lines* recipe in [Chapter 7](2f949287-3e2a-4aaa-b59c-e2662522f2c5.xhtml), *Developing
    Stunning Graphs*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Adding legends and annotations* recipe in [Chapter 7](2f949287-3e2a-4aaa-b59c-e2662522f2c5.xhtml), *Developing
    Stunning Graphs*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Combining graphs* recipe in [Chapter 7](2f949287-3e2a-4aaa-b59c-e2662522f2c5.xhtml), *Developing
    Stunning Graphs*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Saving charts* recipe in [Chapter 7](2f949287-3e2a-4aaa-b59c-e2662522f2c5.xhtml), *Developing
    Stunning Graphs*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
