- en: Advanced IRQ Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux is a system on which devices notify the kernel about particular events
    by means of IRQs. The CPU exposes IRQ lines, shared or not, and used by connected
    devices, so that when a device needs the CPU it sends a request to the CPU. When
    the CPU gets this request it stops its actual job and saves its context, in order
    to serve the request issued by the device. After serving the device, its state
    is restored back to exactly where it stopped when the interruption occurred. There
    are so many IRQ lines, that another device is responsible for them to the CPU.
    That device is the interrupt controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00034.gif)'
  prefs: []
  type: TYPE_IMG
- en: Interrupt controller and IRQ lines
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only can devices raise interrupts, some processor operations can do that
    too. There are two different kinds of interrupts:'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous interrupts called **exceptions** , produced by the CPU while processing
    instructions. These are **non-maskable interrupts** (**NMI** ), and result from
    a critical malfunction such as hardware failure. They are always processed by
    the CPU.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Asynchronous interrupts called **interrupts** , are issued by other hardware
    devices. These are normal and maskable interrupts. It is what we will discuss
    in the next sections of this chapter. Therefore, let us go a bit deeper into exceptions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Exceptions are consequences of programming errors handled by the kernel, which
    sends a signal to the program and tries to recover from the error. These are classified
    in two categories, enumerated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Processor-detected exceptions** : Those the CPU generates in response to
    an anomalous condition, and it is divided into three groups:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faults, which can generally be corrected (bogus instruction).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traps, which occur in user process (invalid memory access, division by zero),
    are also a mechanism to switch to kernel mode in response to a system call. If
    the kernel code does cause a trap, it immediately panics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aborts, the serious errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Programmed exception** : These are requested by the programmer, handled like
    a trap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following array lists unmaskable interrupts (for more details refer to
    [http://wiki.osdev.org/Exceptions](http://wiki.osdev.org/Exceptions) ):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interrupt number** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Divide by zero error |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Debug exception |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | NMI interrupt |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Breakpoint |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | INTO Â­detected overflow |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | BOUND range exceeded |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Invalid opcode |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | Coprocessor (device) not available |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | Double fault |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | Coprocessor segment overrun |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | Invalid task state segment |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | Segment not present |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | Stack fault |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | General protection fault |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | Page fault |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | Reserved |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | Coprocessor error |'
  prefs: []
  type: TYPE_TB
- en: '| 17 - 31 | Reserved |'
  prefs: []
  type: TYPE_TB
- en: '| 32 - 255 | Maskable interrupts |'
  prefs: []
  type: TYPE_TB
- en: NMIs are enough to cover the whole exception list. Back to maskable interrupts,
    their number depends on the number of devices connected, and how they actually
    share those IRQ lines. Sometimes, they are not enough and some of them need multiplexing.
    The commonly used method is by means of a GPIO controller, which also acts as
    an interrupt controller. In this chapter, we will deal with the API that the kernel
    offers to manage IRQ and the ways by which multiplexing can be done, and get deeper
    in interrupt controller driver writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, in this chapter the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Interrupt controllers and interrupt multiplexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced peripheral IRQs management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interrupt requests and propagations (chained or nested)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPIOLIB irqchip API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling interrupt controllers from DT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplexing interrupts and interrupt controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having a single interrupt from the CPU is usually not enough. Most systems
    have tens and hundreds of them. Now comes interrupt controller, allowing them
    to be multiplexed. Very often architecture or platform-specific offers specific
    facilities, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Masking/unmasking individual interrupts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting priorities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMP affinity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exotic things like wake-up interrupts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IRQ management and interrupt controller drivers both rely on the IRQ domain,
    its turn built on top of the following structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`struct irq_chip` : This structure implements a set of methods describing how
    to drive the interrupt controller, and which are directly called by core IRQ code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct irqdomain` structure, which provides:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer to the firmware node for a given interrupt controller (fwnode)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method to convert a firmware description of an IRQ into an ID local to this
    interrupt controller (hwirq)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way to retrieve the Linux view of an IRQ from hwirq
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct irq_desc` : This structure is the Linux''s view of an interrupt, containing
    all the core stuff, and one to one mapping to the Linux interrupt number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct irq_action` : This structure Linux uses to describe an IRQ handler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct irq_data` : This is embedded in the `struct irq_desc` structure, and
    contains:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data that is relevant to the `irq_chip` managing this interrupt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both the Linux IRQ number and the hwirq
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer to the `irq_chip`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Almost every `irq_chip` call is given an `irq_data` as a parameter, from which
    you can obtain the corresponding `irq_desc` .
  prefs: []
  type: TYPE_NORMAL
- en: 'All the preceding structures are part of the IRQ domain API. An interrupt controller
    is represented in the kernel by an instance of `struct irq_chip` structure, which
    describes the actual hardware device, and some methods used by the IRQ core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the meaning of elements in the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`parent_device` : This is a pointer to the parent of this irqchip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` : This is the name for `/proc/interrupts` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_enable` : This hook enables the interrupt, and its default value is `chip->unmask`
    if `NULL` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_disable` : This disables the interrupt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***** `irq_ack` : This is the start of a new interrupt. Some controllers do
    not need this. Linux calls this function as soon as an interrupt is raised, far
    before it is serviced. Some implementations map this function to `chip->disable()`
    , so that another interrupt request on the line will not cause another interrupt
    until after the current interrupt request has been serviced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_mask` : This is the hook that masks an interrupt source in the hardware,
    so that it cannot be raised anymore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_unmask` : This hook unmasks an interrupt source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_eoi` : eoi stands for **end of interrupt** . Linux invokes this hook right
    after an IRQ servicing completes. One uses this function to reconfigure the controller
    as necessary in order to receive another interrupt request on that line. Some
    implementations map this function to `chip->enable()` to reverse operations done
    in `chip->ack()` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_set_affinity` : This sets the CPU affinity only on SMP machines. In SMP
    environments, this function sets the CPU on which the interrupt will be serviced.
    This function isn''t used in single processor machines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_retrigger` : This retriggers the interrupt in the hardware, which resends
    an IRQ to the CPU.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_set_type` : This sets the flow type (IRQ_TYPE_LEVEL/ and so on) of an
    IRQ.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_set_wake` : This enables/disables power-management wake-on of an IRQ.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_bus_lock` : This functions to lock access to slow bus (I2C) chips. Locking
    a mutex here is sufficient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_bus_sync_unlock` : This functions to sync and unlock slow bus (I2C) chips.
    Unlock the mutex previously locked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_get_irqchip_state` and `irq_set_irqchip_state` : These respectively return
    or set the internal state of an interrupt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each interrupt controller is given a domain, which is for the controller what
    an address space is for a process (see [Chapter 11](http://kernel) , *Kernel Memory
    Management* ). The interrupt controller domain is described in the kernel as an
    instance of `struct irq_domain` structure. It manages mappings between hardware
    IRQ and Linux IRQ (that is, virtual IRQ). It is the hardware interrupt number
    translation object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`name` is the name of the interrupt domain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ops` is a pointer to the irq_domain methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`host_data` is private data pointer for use by the owner. Not touched by the
    irqdomain core code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flags` is host per `irq_domain` flags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fwnode` is optional. It is a pointer to DT nodes associated with the `irq_domain`
    . Used when decoding DT interrupt specifiers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An interrupt controller driver creates and registers an `irq_domain` by calling
    one of the `irq_domain_add_<mapping_method>()` functions, where `<mapping_method>`
    is the method by which hwirq should be mapped to Linux IRQ. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`irq_domain_add_linear()` : This uses a fixed size table indexed by the hwirq
    number. When a hwirq is mapped, an `irq_desc` is allocated for the hwirq, and
    the IRQ number is stored in the table. This linear mapping is suitable for fixed
    and small numbers of hwirq (~ < 256). The inconvenience of this mapping is the
    table size, being as large as the largest possible hwirq number. Therefore, IRQ
    number lookup time is fixed, and `irq_desc` are allocated for in-use IRQs only.
    The majority of drivers should use the linear map. This function has the following
    prototype:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`irq_domain_add_tree()` : This is where the `irq_domain` maintains the mapping
    between Linux IRQs and hwirq numbers in a radix tree. When a hwirq is mapped,
    an `irq_desc` is allocated and the hwirq is used as the lookup key for the radix
    tree. The tree map is a good choice if the hwirq number can be very large since
    it does not need to allocate a table as large as the largest hwirq number. The
    disadvantage is that hwirq to IRQ number lookup is dependent on how many entries
    are in the table. Very few drivers should need this mapping. It has the following
    prototype:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`irq_domain_add_nomap()` : You will probably never use this method. Nonetheless,
    its entire description is available in *Documentation/IRQ-domain.txt* , in the
    kernel source tree. Its prototype is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`of_node` is a pointer to interrupt controller''s DT node. `size` represents
    the number of interrupts in the domain. `ops` represents map/unmap domain callbacks,
    and `host_data` is the controller''s private data pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the IRQ domain began empty at creation time (no mapping), you should
    use `irq_create_mapping()` function in order to create mapping and assign it to
    the domain. In the next section, will we decide the right place in the code to
    create mappings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`domain` : This is the domain to which this hardware interrupt belongs, or
    `NULL` for default domain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hwirq` : This is the hardware IRQ number in that domain space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When writing driver for GPIO controllers that are also interrupt controllers,
    `irq_create_mapping()` is called from within `gpio_chip.to_irq()` callback function,
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Other people prefer creating the mapping in advance for each hwirq inside the
    `probe` function like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: hwirq is the GPIO offset from the gpiochip.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a mapping for the hwirq doesn''t already exist, the function will allocate
    a new Linux `irq_desc` structure, associate it with the hwirq, and call the `irq_domain_ops.map()`
    (by means of the `irq_domain_associate()` function) callback so that the driver
    can perform any required hardware setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`.map()` : This creates or updates a mapping between a **virtual irq** (**virq**
    ) number and a hwirq number. This is called only once for a given mapping. It
    generally maps the virq with a given handler using `irq_set_chip_and_handler*`
    , so that, calling `generic_handle_irq()` or `handle_nested_irq` will trigger
    the right handler. The magic here is called the `irq_set_chip_and_handler()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'where:'
  prefs: []
  type: TYPE_NORMAL
- en: '`irq` : This is the Linux IRQ given as parameter to `map()` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chip` : This is your `irq_chip` . Some controllers are quite dumb and need
    almost nothing in their `irq_chip` structure. In this case, you should pass `dummy_irq_chip`
    defined in `kernel/irq/dummychip.c` , which is a kernel `irq_chip` structure defined
    for such controllers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handle` : This determines the wrapper function that will call the real handler
    register using `request_irq()` . Its value depends on the IRQ being edge or level-triggered.
    In either case, `handle` should be set to `handle_edge_irq` , or `handle_level_irq`
    . Both are kernel helper functions that do some trick before and after calling
    the real IRQ handler. An example is shown as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`xlate` : Given a DT node and interrupt specifier, this hook decodes the hardware
    IRQ number and Linux IRQ type value. Depending on the `#interrupt-cells` specified
    in your DT controller node, the kernel provides a generics translation function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_domain_xlate_twocell()` : Generic translation function is for direct two
    cell binding. DT IRQ specifier which works with two cell bindings where the cell
    values map directly to the hwirq number and Linux irq flags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_domain_xlate_onecell()` : Generic xlate for direct one cell bindings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_domain_xlate_onetwocell():` Generic xlate for one or two cell bindings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of domain operation is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When an interrupt is received, `irq_find_mapping()` function should be used
    to find the Linux IRQ number from the hwirq number. Of course, the mapping must
    exist prior to being returned. A Linux IRQ number is always tied to a `struct
    irq_desc` structure, which is the structure by which Linux describes an IRQ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Some fields that are not described here are internal, and are used by the IRQ
    core:'
  prefs: []
  type: TYPE_NORMAL
- en: '`irq_common_data` is a per IRQ and chip data passed down to chip functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kstat_irqs` is per CPU IRQ statistics since boot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handle_irq` is high level IRQ events handler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`action` represents the list of the IRQ action for this descriptor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irqs_unhandled` is the stats field for spurious unhandled interrupts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lock` represents locking for SMP'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`threads_active` is the number of IRQ action threads currently running for
    this descriptor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wait_for_threads` represents the wait queue for `sync_irq` to wait for threaded
    handlers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nr_actions` is the number of installed actions on this descriptor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no_suspend_depth` and `force_resume_depth` represents the number of `irqactions`
    on a IRQ descriptor with `IRQF_NO_SUSPEND` or `IRQF_FORCE_RESUME` flags set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dir` represents `/proc/irq/ procfs` entry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` names the flow handler, visible in `/proc/interrupts` output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `irq_desc.action` field is a list of `irqaction` structures, each of which
    records the address of an interrupt handler for the associated interrupt source.
    Each call to the kernel's `request_irq()` function (or the threaded version `o`
    ) creates an add one `struct irqaction` structure to the end of the list. For
    example, for a shared interrupt, this field will contain as many IRQ actions as
    there are handlers registered;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`handler` is the non-threaded (hard) interrupt handler function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` is the device''s name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dev_id` is a cookie to identify the device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`percpu_dev_id` is a cookie to identify the device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`next` is a pointer to the next IRQ action for shared interrupts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq` is the Linux interrupt number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flags` represent the IRQ''s flags (see `IRQF_*` )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thread_fn` is the threaded interrupt handler function for threaded interrupts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thread` is a pointer to the thread structure in case of threaded interrupts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thread_flags` represents the flags related to thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thread_mask` is a bitmask for keeping track of thread activity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dir` points to the `/proc/irq/NN/<name>/` entry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interrupt handlers referenced by the `irqaction.handler` field are simply functions
    associated with the handling of interrupts from particular external devices, and
    they have minimal knowledge (if any) of the means by which those interrupt requests
    are delivered to the host microprocessor. They are not microprocessor-level interrupt
    service routines, and therefore do not exit through RTE or similar interrupt-related
    opcodes. This makes interrupt-driven device drivers largely portable across different
    microprocessor architectures
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the definition of important fields of the `struct irq_data`
    structure, which is a per IRQ chip data passed down to chip functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`irq` is the interrupt number (Linux IRQ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hwirq` is the hardware interrupt number, local to the `irq_data.domain` interrupt
    domain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`common` points to data shared by all irqchips'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chip` represents the low level interrupt controller hardware access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`domain` represents the interrupt translation domain, responsible for mapping
    between the hwirq number and the Linux irq number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chip_data` is a platform-specific per-chip private data for the chip methods,
    to allow shared chip implementations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced peripheral IRQs management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](text00063.html) , *Kernel Facilities and Helper Functions* ,
    we introduced peripheral IRQs, using `request_irq()` and `request_threaded_irq()`
    . With `request_irq()` , one registers a handler (top half) that will be executed
    in atomic context, from which one can schedule a bottom half using one of a differing
    mechanism discussed in that same chapter. On the other hand, with `request_thread_irq()`
    , one can provide top and bottom halves to the function, so that the former will
    be run as hardirq handler, which may decide to raise the second and threaded handler,
    which will be run in a kernel thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with those approaches is that sometimes, drivers requesting an
    IRQ do not know about the nature of the interrupt that provides this IRQ line,
    especially when the interrupt controller is a discrete chip (typically a GPIO
    expander connected over SPI or I2C buses). Now comes `request_any_context_irq()`
    , function with which drivers requesting an IRQ know whether the handler will
    run in a thread context or not, and call `request_threaded_irq()` or `request_irq()`
    accordingly. It means that whether the IRQ associated to our device comes from
    an interrupt controller that may not sleep (memory mapped one) or from one that
    can sleep (behind I2C/SPI bus), there will be no need to change the code. Its
    prototype is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the meaning of each parameter in the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`irq` represents the interrupt line to allocate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handler` is the function to be called when the IRQ occurs. Depending on the
    context, this function may run as hardirq or may be threaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flags` represents the interrupt type flags. It is the same as those in `request_irq()`
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` will be used for debug purposes to name the interrupt in `/proc/interrupts`
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dev_id` is a cookie passed back to the handler function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`request_any_context_irq()` means that one can either get a hardirq or a treaded
    one. It works like the usual `request_irq()` , except that it checks whether the
    IRQ level is configured as nested or not, and calls the right backend. In other
    words, it selects either a hardIRQ or threaded handling method depending on the
    context. This function returns a negative value on failure. On success, it returns
    either `IRQC_IS_HARDIRQ` or `IRQC_IS_NESTED` . The following is a use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is an excerpt of the driver sample of an input device driver.
    Actually, it is the one used in the next chapter. The advantage using `request_any_context_irq()`
    is that, one does not need to care about what can be done in the IRQ handler,
    as the context in which the handler will run depends on the interrupt controller
    that provides the IRQ line. In our example, if the GPIO below to a controller
    seating on an I2C or SPI bus, the handler will be threaded. Otherwise, the handler
    will run in hardirq.
  prefs: []
  type: TYPE_NORMAL
- en: Interrupt request and propagation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us consider the following figure, which represents a chained IRQ flow
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00035.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Interrupt requests are always performed on Linux IRQ (not hwirq). The general
    function to request IRQ on Linux is `request_threaded_irq()` or `request_irq()`
    , which internally calls the former:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When called, the function extracts the `struct irq_desc` associated with the
    IRQ using the `irq_to_desc()` macro. It then allocates a new `struct irqaction`
    structure and sets it up, filling parameters such as handler, flags, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That same function finally inserts/registers the descriptor in the proper IRQ
    list by invoking `__setup_irq()` (by means of `setup_irq()` ) function, defined
    in `kernel/irq/manage.c` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when an IRQ is raised, the kernel executes a few assembler codes in order
    to save the current state, and jumps to the arch specific handler, `handle_arch_irq`
    , which is set with the `handle_irq` field of `struct machine_desc` of our platform
    in the `setup_arch()` function, in `arch/arm/kernel/setup.c` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For SoCs that use ARM GIC, `handle_irq` callback is set with `gic_handle_irq`
    , in either `drivers/irqchip/irq-gic.c` , or `drivers/irqchip/irq-gic-v3.c` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`gic_handle_irq()` calls `handle_domain_irq()` , which executes `generic_handle_irq()`
    , its turn calling `generic_handle_irq_desc()` that ends by calling `desc->handle_irq()`
    . Have a look at `include/linux/irqdesc.h` for the last call and `arch/arm/kernel/irq.c`
    for other function calls. `handle_irq` is the actual call for the flow handler,
    which we registered as `mcp23016_irq_handler` .'
  prefs: []
  type: TYPE_NORMAL
- en: '`gic_hande_irq()` is a GIC interrupt handler. `generic_handle_irq()` will execute
    the handler of the SoC''s GPIO4 IRQ, which will look for GPIOs pin responsible
    for the interrupt, and call `generic_handle_irq_desc()` , and so on. Now that
    you are familiar with interrupt propagation, let us switch to a practical example
    by writing our own interrupt controller.'
  prefs: []
  type: TYPE_NORMAL
- en: Chaining IRQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section describes how interrupt handlers of a parent, call the child''s
    interrupt handlers, in turn calling their child''s interrupt handlers, and so
    on. The kernel offers two approaches on how to call interrupt handlers for child
    devices in the IRQ handler of the parent (interrupt controller) device. These
    are the chained and nested methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Chained interrupts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This approach is used for SoC's internal GPIO controller, which are memory mapped
    and whose access does not sleep. Chained means that those interrupts are just
    chains of function calls (for example, SoC's GPIO module interrupt handler is
    being called from GIC interrupt handler, just as a function call). `generic_handle_irq()`
    is used for interrupts chaining child IRQ handlers and are called inside of the
    parent hwirq handler. Even from within the child interrupt handlers, we still
    are in atomic context (HW interrupt). One cannot call functions that may sleep.
  prefs: []
  type: TYPE_NORMAL
- en: Nested interrupts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This method is used by controllers that sit on slow buses, like I2C (for example,
    GPIO expander), and whose access may sleep (I2C functions may sleep). Nested means
    those interrupts handlers that do not run in the HW context (they are not really
    hwirq, they are not in atomic context), but they are threaded instead, and can
    be preempted (or interrupted by another interrupt). `handle_nested_irq()` is used
    for creating nested interrupt child IRQs. Handlers are being called inside of
    the new thread created by the `handle_nested_irq()` function; we need them to
    be run in process context, so that we can call sleeping bus functions (like I2C
    functions that may sleep).
  prefs: []
  type: TYPE_NORMAL
- en: Case study â GPIO and IRQ chip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us consider the following figure that ties an interrupt controller device
    to another one, which we will use to describe interrupt multiplexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: mcp23016 IRQ flow
  prefs: []
  type: TYPE_NORMAL
- en: Consider that you have configured `io_1` and `io_2` as interrupts. Even if interrupt
    happens on `io_1` or `io_2` , the same interrupt line will be triggered to the
    interrupt controller. Now the GPIO driver has to figure out reading the interrupt
    status register of the GPIO to find which interrupt (`io_1` or `io_2` ) has really
    fired. Therefore, in this case a single interrupt line is a multiplex for 16 GPIO
    interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us mangle the original driver of the mcp23016 written in [Chapter 15](text00371.html)
    , *GPIO Controller Drivers â gpio_chip* in order to support IRQ domain API first,
    which will let it act as an interrupt controller as well. The second part will
    introduce the new and recommended gpiolib irqchip API. This will be used as a
    step-by-step guide to write the interrupt controller driver, at least for the
    GPIO controller:'
  prefs: []
  type: TYPE_NORMAL
- en: Legacy GPIO and IRQ chip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step, allocate a `struct irq_domain` to our gpiochip that will store
    the mapping between hwirq and virq. The linear mapping is suitable for us. We
    do that in the `probe` function. That domain will hold the number of IRQ our drivers
    wish to provide. For example, for an I/O expander, the number of IRQs could be
    the number of GPIOs the expander provides:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`host_data` parameter is `NULL` . Therefore, you can pass whatever data structure
    you need. Prior to allocating the domain, our domain ops structure should be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And prior to filling our IRQ domain ops structure, we must define at least
    the `.map()` callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Our controller is not smart enough. There is then no need to set up an `irq_chip`
    . We will use the one provided by the kernel for this kind of chip: `dummy_irq_chip`
    . Some controllers are smart enough and need an `irq_chip` to be set up. Have
    a look in `drivers/gpio/gpio-mcp23s08.c` .'
  prefs: []
  type: TYPE_NORMAL
- en: The next ops callback is `.xlate` . Here again, we use a helper provided by
    the kernel. `irq_domain_xlate_twocell` is a helper able to parse an interrupt
    specifier with two cells. We can add this `interrupt-cells = <2>;` in our controller
    DT node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to fill the domain with IRQ mappings, using `irq_create_mapping()`
    function. In our driver, will do it in the `gpiochip.to_irq` callback, so that
    whenever someone will call `gpio{d}_to_irq()` on the GPIO, the mapping will be
    returned if it exists, or it will be created if it doesn''t:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We could have done that for each GPIO in the `probe` function, and just call
    `irq_find_mapping()` in `.to_irq` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now still in the `probe` function, we need to register our controller''s IRQ
    handler, which in turn is responsible for calling the right handler that raised
    the interrupt on its pins:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `mcp23016` should have been defined prior to registering the IRQ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`handle_nested_irq()` already descried in the preceding section will create
    a dedicated thread for each handler registered.'
  prefs: []
  type: TYPE_NORMAL
- en: New gpiolib irqchip API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost every GPIO controller driver was using IRQ domain for the same purpose.
    Instead of each of them rolling their own irqdomain handling and so on, kernel
    developers decided to move that code to gpiolib framework, by means of `GPIOLIB_IRQCHIP`
    Kconfig symbol, in order to harmonize the development and avoid redundant code.
  prefs: []
  type: TYPE_NORMAL
- en: That portion of code helps in handling management of GPIO irqchips and the associated
    `irq_domain` and resource allocation callbacks, as well as their setup, using
    the reduced set of helper functions. These are `gpiochip_irqchip_add()` and `gpiochip_set_chained_irqchip()`
    .
  prefs: []
  type: TYPE_NORMAL
- en: '`gpiochip_irqchip_add():` This adds an irqchip to a gpiochip. What this function
    does:'
  prefs: []
  type: TYPE_NORMAL
- en: Sets `gpiochip.to_irq` field to `gpiochip_to_irq` , which is an IRQ callback
    that just returns `irq_find_mapping(chip->irqdomain, offset);`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocates an irq_domain to the gpiochip using `irq_domain_add_simple()` function,
    passing a kernel IRQ core `irq_domain_ops` called `gpiochip_domain_ops` and defined
    in `drivers/gpio/gpiolib.c`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create mapping from 0 to `gpiochip.ngpio` using `irq_create_mapping()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Its prototype is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Where `gpiochip` is our GPIO chip, the one to add the irqchip to, `irqchip`
    is the irqchip to add to the gpiochip. `first_irq` if not dynamically assigned,
    is the base (first) IRQ to allocate gpiochip IRQs from. `handler` is the IRQ handler
    to use (often a predefined IRQ core function), and `type` is the default type
    for IRQs on this irqchip, pass `IRQ_TYPE_NONE` to have the core avoid setting
    up any default type in the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: This function will handle two celled simple IRQs (because it sets `irq_domain_ops.xlate`
    to `irq_domain_xlate_twocell` ) and assumes all the pins on the gpiochip can generate
    a unique IRQ.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`gpiochip_set_chained_irqchip()` : This function sets a chained irqchip to
    a `gpio_chip` from a parent IRQ and passes a pointer to the `struct gpio_chip`
    as handler data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`parent_irq` is the IRQ number to which this chip is connected. In case of
    our mcp23016 as shown in the figure in the section *Case study-GPIO and IRQ chip*
    , it corresponds to the IRQ of `gpio4_29` line. In other words, it is the parent
    IRQ number for this chained irqchip. `parent_handler` is the parent interrupt
    handler for the accumulated IRQ coming out of the gpiochip. If the interrupt is
    nested rather than cascaded (chained), pass `NULL` in this handler argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this new API, the only code to add to our `probe` function is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'IRQ core does everything for us. No need to define even the `gpiochip.to_irq`
    function, since the API already sets it. Our example uses the IRQ core `dummy_irq_chip`
    , but one could have defined its own as well. Since the v4.10 version of the kernel,
    two other functions have been added: these are `gpiochip_irqchip_add_nested()`
    and `gpiochip_set_nested_irqchip()` . Have a look at *Documentation/gpio/driver.txt*
    for more details. A driver that uses this API in the same kernel version is `drivers/gpio/gpio-mcp23s08.c`
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Interrupt controller and DT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will declare our controller in the DT. If you remember in [Chapter 6](text00162.html)
    : *The Concept of Device Tree* , every interrupt controller must have the Boolean
    property interrupt-controller set. The second mandatory Boolean property is `gpio-controller`
    , since it is a GPIO controller too. We need to define how many cells are needed
    for an interrupt specifier for our device. Since we have set the `irq_domain_ops.xlate`
    field to `irq_domain_xlate_twocell` , `#interrupt-cells` should be 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`interrupt-parent` and `interrupts` properties are describing interrupt line
    connection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let us say that we have a driver for mcp23016 and drivers for two
    other devices: `foo_device` and `bar_device` , all running in the CPU of course.
    In the `foo_device` driver, one wants to request interrupt for events when `foo_device`
    changes level on the `io_2` pin of mcp23016\. The `bar_device` driver requires
    `io_8` and `io_12` respectively for reset and power GPIOs. Let us declare this
    in the DT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now IRQ multiplexing has no more secrets for you. We discussed the most important
    elements of IRQ management under Linux systems, the IRQ domain API. You have the
    basics to develop interrupt controller drivers, as well as managing their binding
    from within the DT. IRQ propagation has been discussed in order to understand
    what happens from the request to the handling. This chapter will help you to understand
    the interrupt driven part of the next chapter, which deals with input device drivers.
  prefs: []
  type: TYPE_NORMAL
