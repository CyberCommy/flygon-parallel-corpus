- en: Chapter 7. Injection and Overflow Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All websites in this day and age provide dynamic responses to users that are
    informed by some external database or inferred from a process external to the
    HTMLÂ itself. On the clients, this is typically cordoned off and restricted to
    the **Domain Object Model** (**DOM**) space of the browser, but on the servers
    the variety and scope of these intertwined processes become exceedingly hard to
    manage. With all of a typical enterprise's defences tuned to permit application-bound
    traffic into the web tier, and the web tier, in turn, trusted to access the application
    and database tiers, hackers have learned to web tier into their stooge. The web
    tier unwittingly becomes an insider threat, and with it comes all privileged access
    and trust relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Injections are a powerful and common form of compromising the client-server
    connection and can be used to both expose unintended information as well as to
    impact the performance of the application itself. Where XSSÂ attacks focus on
    injecting scripts to coax clients into doing the attacker's bidding, other injection
    types focus on going directly after the backend data. When we're testing or attacking
    a web application, compromising a user's host is useful, but a slew of server-side
    injections can entice the web application to do a hacker's bidding directly. These
    **injection attacks** vary in application but exploit weaknesses in the web application's
    ability to validate user input and mask error handling. Attackers are motivated
    by a number of outcomes, but in addition to stealing the data or intellectual
    property behind the application come more destructive outcomes â�� destruction
    or corruption of the data, ruining the application's usability and undermining
    its trusted status amongst the users and company it serves.
  prefs: []
  type: TYPE_NORMAL
- en: The most concerning aspect of injections is that they are easy to implement
    and that a ton of websites are vulnerable. A quick look at the **Google Hacking
    DB** (**GHDB**) or **Shodan.io** can readily expose millions of servers that lack
    in protection.
  prefs: []
  type: TYPE_NORMAL
- en: We should certainly include a cursory look at these **Open Source Intelligence**
    (**OSINT**) repositories as black hat hackers certainly are using them. Focused
    scanning using **Burp Suite**, **Zed Access Proxy** (**ZAP**), **Arachni**, and
    other tools can help us uncover a wider array of potential issues in our specific
    targets, as can some smart hands-on with the portals themselves. **Structured
    Query Language** (**SQL**), **eXtensible Markup Language** (**XML**) **Path Language**
    (**XPath**), **Lightweight Directory Access Protocol** (**LDAP**), command/executable,
    and **Hyper Text Transport Protocol** (**HTTP**) injections present the most commonly
    seen threats, but vary in their impact and location.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll learn about and implement each of the major categories
    of injection and input manipulation attacks and learn how to use several tools
    to both identify the vulnerabilities and exploit their weakness.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will help us:'
  prefs: []
  type: TYPE_NORMAL
- en: Uncover and test against various forms of injection (blind, classic, compound)
    against various databases including SQL, Oracle, and LDAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the need for performing code injection to result in stack, buffer,
    and heap overflows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to conduct HTTP verb tampering and parameter pollution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use select and use the correct tool from a list including recon-ng,
    BBQSQL, SQLMap, SQLninja, and others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting some fun into your testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Injection attacks are numerous, but because they all insert code that they
    know will be transported into the application or database tiers for execution,
    they have an impact that earns injections a #1 ranking from the OWASP Top 10\.
    We''ll cover the big ones here, but know that the scanning and testing approaches
    are very similar, in that we''ll leverage automation to both probe each portal
    for signs of weakness and to pass best-practice based strings against any potential
    flaws to test against them. Before we get into the varieties of injection, it
    helps to step back and look at how OWASP characterizes them. The following screenshot
    comes from their latest release candidateÂ of the **OWASP 2017 Top 10**Â **List**
    ([https://github.com/OWASP/Top10/blob/master/2017/OWASP%20Top%2010%20-%202017%20RC1-English.pdf](https://github.com/OWASP/Top10/blob/master/2017/OWASP%20Top%2010%20-%202017%20RC1-English.pdf)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: OWASP's Injection Attack Characterization.
  prefs: []
  type: TYPE_NORMAL
- en: 'OWASP''s concerns with these attacks are many, but their ease of use by hackers
    and their potential impact make them a grave concern for application developers.
    Web technologies rely heavily on dynamic content and this puts that reliance in
    the cross-hairs of hackers who understand that that dynamic aspect makes them
    ripe for injection. The following table can help us understand the basic scopes
    of each attack, their relative difficulty, and the typical weak spots in which
    they are found:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Injection type** | **Detection difficulty** | **Exploit difficulty** |
    **Potential impact** | **End Goal/Affected Components** |'
  prefs: []
  type: TYPE_TB
- en: '| **SQL injection** | Hard â�� BlindEasy - Classic | Medium | Very serious
    | Database enumerationSQL-backed frameworksOracle applications |'
  prefs: []
  type: TYPE_TB
- en: '| **XML (XPath) injection** | Moderate | Easy | Serious | XML-stored data Enumeration,
    corruption, destruction of data |'
  prefs: []
  type: TYPE_TB
- en: '| **LDAP injection** | Very easy | Easy | Moderate (varies) | Credentials,
    usually for escalation or new account generation |'
  prefs: []
  type: TYPE_TB
- en: '| **Command injection** | Hard | Medium | Very serious | Application tierSlip
    in command to run malicious code for destructive means or lateral movement |'
  prefs: []
  type: TYPE_TB
- en: '| **Buffer overflow** | Medium | Medium | Very serious | Application tierRepoint
    instructions to execute malicious code for destructive means or lateral movement
    |'
  prefs: []
  type: TYPE_TB
- en: '| **HTTP injection** | Easy | Very Easy | Low | Web or application tiers Force
    execution of functions inside web server or application |'
  prefs: []
  type: TYPE_TB
- en: Is SQL any good?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: As injections go, **SQL Injection** (**SQLI**) is the belle of the ball. While
    differences exist between SQL database technologies, most subscribe to a common
    foundation of syntax (defined by the **American National Standards Institute**
    (**ANSI**), vocabulary and organization, which makes learning and adapting to
    a new one straightforward and efficient.Â  Used in relational databases, it is
    the workhorse in modern database operations, responsible for storing, manipulating,
    and querying databases from adjacent applications or interfaces. There are a lot
    of free resources that are worth digging into to better understand SQL, and the
    **World Wide Web Consortium**'s site ([https://www.w3schools.com/sql/](https://www.w3schools.com/sql/))Â 
    is a fantastic start â�� we won't go into any depth on the underlying language.
  prefs: []
  type: TYPE_NORMAL
- en: Statistically speaking, over 98% of web applications are backed by databases
    containing the information users are after. Of these, SQL variants are by far
    the most popular. These same aspects make it very easy for hackers to detect and
    exploit these databases using common libraries of queries and tricks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t let these statistics and the potential impact fool you though: SQLI
    attacks are rampant and increasing in number each year, despite the attention
    they garner and the fundamental precautions that can be taken to eliminate or
    drastically reduce their potential to an application. As we''ll see here, revealing
    and exploiting SQL injection vulnerabilities is a relatively easy task.'
  prefs: []
  type: TYPE_NORMAL
- en: A crash course in DBs gone bad
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Relational databases provide a table-like framework within which data is stored.
    SQL is the syntax by which we read and write to these tables, and websites can
    allow their users to render useful data by building a query and subsequently presenting
    the results. What could ever go wrong?
  prefs: []
  type: TYPE_NORMAL
- en: Well, many databases are instantiated by system administrators or engineers
    without a background in the particular database technology. Chances are your technophobe
    relatives have even installed a database as the underlying component of an application
    on their own personal computer. And chances are just as high that whoever embedded
    the database in a larger application did so without delving too far into the detailed
    hardening of the database.Â  Simple things such as default administrator accounts,
    ports, and so on aren't always cleaned up prior to being embedded within the parent
    application. These same issues arise with web application databases in organizations
    without database-focused personnel.
  prefs: []
  type: TYPE_NORMAL
- en: Web applications vary in the way they solicit queries from the users and pass
    them along to the database. Many using **PHP Hypertext Preprocessor** (**PHP**)
    for their dynamic content pass the queries along via the **Uniform Request Locator**
    (**URL**) string and thus are very easy to modify for our own purposes while avoiding
    meaningful validation. Other sites strongly enforce and sanitize underlying SQL
    queries by restricting users to building their searches through pre-canned components
    in drop-down lists, radio buttons, and check boxes. These restrictive query building
    approaches are much harder to exploit, and recommended for safe application development
    wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: A high-level view of how that happens is shown in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_07_02.png)'
  prefs: []
  type: TYPE_IMG
- en: The anatomy of a SQL injection attack
  prefs: []
  type: TYPE_NORMAL
- en: Types of SQLI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Given how diverse SQL is and how many ways there are to implement it, it stands
    to reason there will be some different ways to implement SQLI. Like XSS, there
    are a couple of ways we can look at this, but SQLI can vary greatly, and thus
    can be characterized in different ways.Â  Rather than looking at their persistence
    and location, as in XSS, we can differentiate SQLI by looking at a few *tells*
    or characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: The way in which the SQLI is delivered (via forms, drop-downs, cookie manipulation,
    URL mods, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of input we submit in the first place (strings versus values)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we receive the data back (also called the data extraction channel)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the response is crafted (returning an error or otherwise hiding any faults)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of queries needed to influence the application or database to arrive
    at a result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We won't cover all of these categories exhaustively, but we'll discuss the go-to
    types and how they fit into the categories above. In addition, I'll show some
    examples using our trusty OWASP **Broken Web Application** (**BWA**) **Virtual
    Machine** (**VM**) and we'll see how we approach each of the categories in turn,
    both in the actual injection technique as well as with a tool that can automate
    its use.
  prefs: []
  type: TYPE_NORMAL
- en: In-band or classic SQLI
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**In-band SQLIÂ **is the easiest and most common mode of SQLI, often referred
    to as the **classic SQLI** type. In-band better describes the way the attack is
    carried out. In-band SQLI involves both launching the attack (nefarious SQL queries)
    and receiving the response (that query''s results) via the same channel. Hackers
    can use these attacks in a couple of ways.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Error-based SQLI**: Hackers can probe an application with strings that are
    meant to error out of the responses that reveal much about the structure and policies
    of the website but help map out and enumerate the database that the application
    is using. The example from Mutillidae below shows a statement that when injected
    in a request will induce a detailed error, which can in effect tell us what information
    lies beneath:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Union-based SQLI**: In a more surgical approach, hackers (us) may have already
    scoped out the database and now will be looking to combine separate statements
    (using a *union* statement) into a single request to coax unanticipated results
    from the application. In doing this, they can piggyback a probing query with something
    more expected by the application and, in returning the result, actually give up
    the goods!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blind SQLI
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Blind SQLI** is like the database version of the childhood game *hot or cold*.
    If you''ve never played it, the kid who hid the toy provides hints to the searcher
    by saying *hot* with varying levels of enthusiasm as the searcher gets closer,
    and *cold* when they are trending away from the hidden objective. So it goes with
    Blind SQLI: when a database won''t just spell it out for you, and the application
    developer is hiding error details, you can sometimes get all of your information
    by inferring the answers and asking the right *true or false* questions. Sure,
    it will be easier to obtain the data outright via one of the classic SQLI modes
    but, by using queries as a sort of true/false probe, hackers can systematically
    enumerate a database without so much as returning a single piece of data. That
    being said, there are two main types of blind SQLI.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content-based blind SQLI**: In this type of SQLI, the hacker is trying to
    use queries to infer the existence of a data type, entry, or structure in the
    database by seeing whether the application kicks back an error or not, or different
    errors based on a true or false condition. A MySQL example from the Mutillidae
    application is shown below:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Time-based blind SQLI**: An alternative form of blind SQLI helps overcome
    any error screening that the web tier does by manipulating timing-based commands
    in the query. When we marry a time-based command to a boolean (also known as conditional)
    query and notice that the error is kicked back after observing the time specified,
    this now becomes our true/false litmus test. SQL has some wait and sleep statements
    that are sometimes accepted; when coupled with a query that the database might
    not want to return the outright answer on, the delay can be all of the answers
    we need to enumerate the contents. An example is shown following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: No matter how you approach blind SQLI, it is pretty labor-intensive, and not
    something you want to do manually in the real world; finding each letter in a
    table using true/false tests and stepping through an entire alphabet is good work
    for high-performance computing, not a human. As such, it is recommended that you
    only attempt blind SQLI when other options are not present. Tools such as SQLMap
    and SQLninja can assist in automating this, but as we'll see shortly, blind SQLI
    scanning can be a long and drawn out process.
  prefs: []
  type: TYPE_NORMAL
- en: Stacked or compound SQLI
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once you understand the classic and blind SQLI methods, it doesn't take a huge
    leap to understand how you can make compound statements and stack multiple requests
    together to not only map our targets' databases, but to also manipulate, corrupt,
    or destroy stored data and eventually run code on the databases. You can pair
    data extraction union-based SQLI, for instance, with a command immediately following
    it to remove the data from the source table. **Netsparker** ([https://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/](https://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/))
    and **PenTestMonkey** ([http://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet](http://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet))
    both offer cheat sheets that do a wonderful job of introducing the many ways Stacked
    SQLI can be used for good (or evil) across multiple database types. The potential
    to do harm here is huge, and so using standard Kali-provided tools (or other **Dynamic
    Application Security Test** or **DAST** suites) to scan and test is preferred
    over engineering your own exploits.
  prefs: []
  type: TYPE_NORMAL
- en: SQLI tool school
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we know how to tell what each SQLI injection type is doing to its targets
    and how it is helping the hacker, we need to have some methods to actually detect
    and exploit these vulnerabilities. Injection attacks, as we're seeing, have a
    pretty broad spectrum of implementations and impacts, and as you might expect
    there are a plethora of tools out there to answer the needs of pen testers and
    hackers. My goal, however, is to get you a solid foundation of tools that can
    provide coverage everywhere and buy you time while you learn and specialize as
    needed. In this section, we'll see how to carry identify and exploit SQLI vulns
    using SQLMap, BBQSQL, SQLNinja, and some good old fashioned browser magic.
  prefs: []
  type: TYPE_NORMAL
- en: Old-school SQLI via browsers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'All joking aside, experienced hackers will write scripts to spider applications
    for all potential page hosting forms, later visiting each to tinker with them
    and get some idea as to whether SQLI is possible. Scanning tools are fun and all,
    but nothing demonstrates how serious an attack is to a customer better than using
    nothing more than a browser to gain access, escalate privileges, or render sensitive
    data. As an example, if we wanted to try and coax a page to reveal its query syntax,
    we might force an error, as shown in following screenshot,Â in which the database
    tries to tell us how to correct it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_07_03.png)'
  prefs: []
  type: TYPE_IMG
- en: Forcing a SQL Error
  prefs: []
  type: TYPE_NORMAL
- en: 'When we click on the **`Login`** button, our helpful database spills the beans
    and we realize exactly what the query we are trying to attack is, as shown in
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_07_04.png)'
  prefs: []
  type: TYPE_IMG
- en: Â The SQL error is so helpful!
  prefs: []
  type: TYPE_NORMAL
- en: 'Close up, the query we''re dealing with is simply going after a field called
    `username` in a table called `accounts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at this simple query, and applying some SQL knowledge gleaned from
    a SQLI cheat sheet or from actual academic knowledge of the syntax, it is apparent
    that this query managed to break us out of a query and as a next step we should
    try to both spoof a valid username and attempt to skip the password. We can do
    this by entering in a new string, where `'' or 1=1 --Â ` will use the logical
    operation to ensure that the username exists, and the double hyphen with a trailing
    space tells SQL to skip the following field; in this case, it conveniently skips
    our pesky password field. The new query looks like this when we enter that string
    into the username field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This little bit of SQL knowledge provided us with a pretty crucial victory
    this time: we are now logged in as admin, as seen in following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_07_05.png)'
  prefs: []
  type: TYPE_IMG
- en: The reason SQLI is so feared.
  prefs: []
  type: TYPE_NORMAL
- en: I think we can both agree that this is pretty convenient â�� the intentionally
    vulnerable Mutillidae application was a pushover. Admin was returned because,
    as is the case with most databases that haven't been hardened, the admin user
    was the first entry in the user database. Real-world SQLI, however, can be just
    this simple assuming the hacker has the in-depth SQL knowledge and a willingness
    to tinker around and interpret the errors the web application kicks back. A tool
    that can be very helpful in this is the Firebug Firefox browser plugin ([https://addons.mozilla.org/en-US/firefox/addon/firebug/](https://addons.mozilla.org/en-US/firefox/addon/firebug/)),
    which can help you unveil password fields and assist in injecting SQL queries
    even in fields that are normally obscured. If you have a lot of other tasks to
    tackle and cannot bear the hands-on time, there are some helpful tools that iterate
    those queries and interpret the responses for us.
  prefs: []
  type: TYPE_NORMAL
- en: Stepping it up with SQLMap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's take a look at how a tool we've already gotten familiar with, Burp Suite,
    can be used to feed one of Kali's most venerable tools in SQLI, **SQLMap**, to
    assist inÂ checking for all sorts of SQLI. Just a warning â�� while Burp is about
    as quick and versatile as tools get, SQLMap takes a long time to get through its
    many tests. The test run for this chapter took well over 10 hours on a souped
    up VM (4 cores, 8 GB of RAM) but it is well worth the wait.Â  Lets check out how
    this process works.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we''ll need to dust off the cobwebs and start up Burp Suite,
    making it our proxy and allowing it to intercept our requests. Having done that,
    we can surf to the same login page we''ve been picking on, enter in some guest
    credentials, and capture the request in our **`Proxy`** tab and **`Intercept`**
    sub-tab (as shown in following screenshot). Notice that this picks up our false
    credentials in the last line, as well as other important formatting and syntax
    details that SQLMap will likely need to do its work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_07_06.png)'
  prefs: []
  type: TYPE_IMG
- en: Capturing our request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conveniently, Burp Suite allows us to directly save it into a file for SQLMap
    to use (as shown in following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_07_07.png)'
  prefs: []
  type: TYPE_IMG
- en: Saving our request for SQLMap to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using your favorite editor (**nano** in my case) you can change the credential
    fields to two single quotes each, as seen in following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_07_08.png)'
  prefs: []
  type: TYPE_IMG
- en: Â Editing the request before passing it to SQLMap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can execute `SQLMap` and pass your response file to it, as well as
    set up any other options you are interested in, using the `SQLMap` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now we should see `SQLMap` do its thing as we see in following screenshot, testing
    for all sorts of vulnerabilities and footprinting our target for us from a SQL
    perspective.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_07_09.png)'
  prefs: []
  type: TYPE_IMG
- en: Â SQLMap testing in process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need to respond to some of the questions that come up, but in these
    practice scenarios it is usually fine to answer yes to everything. After a long
    and intense scanning period, `SQLMap` will respond with a summary of the injections
    it seems to think the application is potentially susceptible to, and then a characterization
    of the database and web application itself, as seen in following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_07_10.png)'
  prefs: []
  type: TYPE_IMG
- en: SQLMap's output reveals the SQLI types and server info.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may recognize the preceding injection points I provided them as examples
    to some of the types earlier in this chapter. These can be directly inserted into
    requests via Burp or ZAP and immediately verified.
  prefs: []
  type: TYPE_NORMAL
- en: Cooking up some menu-driven SQLI with BBQSQL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: SQLMap is a great tool for exhaustive discovery, but sometimes you yearn for
    a menu-driven approach to actually exploit something in particular, especially
    around Blind SQLI. If you aren't a SQL expert but know you need a specific exploit
    mocked up from a certain host, you can customize a Blind SQLI exploit using **BBQSQL**([https://github.com/Neohapsis/bbqsql](https://github.com/Neohapsis/bbqsql))
    a tool developed by Neohapsis (now a part of Cisco). If you are a big fan of the
    **Social Engineering Toolkit** (**SET**), and you want to exploit Blind SQLI fast,
    then BBQSQL is for you! Let's take a quick look at how to configure it and use
    it for your own purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start up BBQSQL, we don''t need to capture a request for an effective analysis,
    but it helps to have a test request copied to help structure the attack.Â  We
    can just start it up via the GUI shortcut or at the CLI using `bbqsql`. The start
    page (shown in the following screenshot) is very familiar to SET users, and this
    helps get us up and rolling a lot easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_07_11.png)'
  prefs: []
  type: TYPE_IMG
- en: BBQSQL Start-up menu (outlined in blue).
  prefs: []
  type: TYPE_NORMAL
- en: Stepping through each of the menus (see following screenshot), most of the basic
    parameters are in the HTTP options. This is where we can enter in the URL, any
    input fields, and the custom agents and any proxy information we may want to use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_07_12.png)'
  prefs: []
  type: TYPE_IMG
- en: BBQSQL HTTP Menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'BBQSQL-specific parameters are the heart of BBQSQL''s engine. The important
    or most essential options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Technique**: Defines whether this is a true/false test (`binary_search`)
    or a frequency/time based test that counts occurrences (`frequency_search`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Comparison attribute**: This is what we are telling BBQSQL to look for and
    that it will use to differentiate true and false. Size, text strings, values,
    and many other types of comparison are available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency**: BBQSQL''s speed is a direct result of the concurrency it supports,
    which allows it to uncover database contents at a blistering rate as compared
    to other methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hooks file**: You can decorate your attacks with hooks, a game-changing Python-defined
    feature not seen in other tools, in that they allow for all sorts of manipulation
    that may need to happen in the process of sending injection requests, such as
    encryption, looping, encoding, or masking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query**: While other SQLI tools deal in specifics per database platform,
    BBQSQL instead opts for pseudocode to allow you to craft exploits that work across
    SQL types, even Oracle. These queries can be used in either the URL, cookies,
    or the data itself (see the following screenshot).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B03918_07_13.png)'
  prefs: []
  type: TYPE_IMG
- en: BBQSQL Options menu.
  prefs: []
  type: TYPE_NORMAL
- en: I highly recommend practicing not only against the Mutillidae app, but the rest
    of the apps offered on the OWASP BWA VM such as the **Damn Vulnerable Web Application**
    (**DVWA**) or from newly posted applications from [http://www.vulnhub.com](http://www.vulnhub.com).
  prefs: []
  type: TYPE_NORMAL
- en: Another tool worth looking into for Microsoft SQL-based projects is **SQLninja**
    ([http://sqlninja.sourceforge.net/index.html](http://sqlninja.sourceforge.net/index.html)
    ), a Perl-based tool that is available in Kali Linux. SQLninja does a wonderful
    job exploiting and injecting into that specific subset of databases based on detection
    results from other tools. We did not cover that tool here due to its narrower
    scope, but for those efforts where the target's database is Microsoft-based, it
    can be invaluable!
  prefs: []
  type: TYPE_NORMAL
- en: SQLI goes high-class with Oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If SQL injections are most common and easily implemented, Oracle injections
    are their rich and exclusive cousin. Oracle databases demand a licensing cost
    and premium knowledge over their more common and widespread SQL relatives.Â  This
    relegates them to more expensive web application solutions, so they are encountered
    most often in larger enterprises or those willing to pay for the greater innate
    scalability and enterprise-class support.
  prefs: []
  type: TYPE_NORMAL
- en: 'It stands to reason that Oracle injection attacks are worth knowing or having
    in your tool box. Why is that? Scans returning a result identifying Oracle as
    the underlying DB framework might as well advertise the higher value of their
    contents. The expense in establishing and maintaining them is usually justified
    given the value of what they are holding: Oracle DBs are trusted with some pretty
    sensitive and valuable information. So while we''ll see SQL injections more commonly,
    it takes minimal effort to learn the Oracle flavor and ensure we''re ready when
    the opportunity presents itself. Rest assured, our black hat adversaries are looking
    for these same paths into the applications, so we''d better beat them to it!'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: BBQSQL, SQLMap, and others all offer Oracle modules or extensions to ensure
    that they are covered as well.Â  The same processes used in hacking MySQL, PostgreSQL,
    and others are available in Oracle. Oracle also uses most of the ANSI instruction
    set, so while the differences in structure are worth noting, the tools should
    be able to assist.
  prefs: []
  type: TYPE_NORMAL
- en: The X-factor - XML and XPath injections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Some app developers are eschewing SQL for new, open-standards-based data structures
    written in XML. Why will someone choose this? Relational databases composed with
    SQL are certainly leveraging a very stable, mature technology, but sometimes data
    that has multiple indices of relationships is more compact when rendered and stored
    in XML. This needs to be balanced against the performance in the database tier.Â 
    Relational databases differentiate between variable types, which means they can
    provide optimized treatment of those based on whether they are a string, integer,
    Boolean, or others. XML treats everything like a string of text, so the burden
    is on the Application Tier to comb over the stored data and make manipulations
    with more complex logic and processing overhead. There is no 100% right answer
    â�� these factors will be weighed to determine the mix needed for each application.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to interacting with that data, one can use XML itself, or use
    **XML Path Lanuage** (**XPath**) to deliver SQL-like commands, requests, and operations
    to the stored data. XML was never really meant to be a data storage technology,
    but more a transmission/delivery standard. If the web application we are targeting
    will spend most of its time using SQL to extract or manipulate data that it just
    has to turn around and create an XML representation of, then just using XML throughout
    could be a huge help.Â  The good knews is that we have plenty of tools available
    for XML as well.Â  Burp Suite and OWASP ZAP will detect some XML injection flaws,
    and as with SQLI a browser or XML viewer can go a long way towards assisting with
    this.
  prefs: []
  type: TYPE_NORMAL
- en: XML injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'XMLÂ injections typically look to shim data into an XML element, whether it
    be in its **Node Attribute**, **Node Value**, or **CDATA** fields. In the following
    snippet, we see a simple entry for something I might be shopping for, but will
    love to get cheaper (this is a simulated scenario, I always pay fair prices for
    my beverages):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if I am not excited about paying for that, or will like to make it free,
    I could deliver a payload via XML that alters the game just a little bit.Â  Here
    is the payload I might shim into the server''s XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Which gives me the resulting code, surely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In reality, getting this sort of access via plain-old XML to a production server
    is highly unlikely.Â  This also means that not many Kali-hosted tools that in
    XML injection, but the foundation is solid for understanding what is a much more
    real possibility, the server using XPath to manipulate XML on the backend.
  prefs: []
  type: TYPE_NORMAL
- en: XPath injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**XPath** is what happens when XML guys get jealous of SQL and invent their
    own query language too.Â  The good news (for hackers) is that XPath has an all-or-nothing
    connotation, if you get some access, you get it all! Sorry XML people, this is
    what happens when you try to make a standard do too much. XPath, unlike SQL, lacks
    granular access control, so there are no tiers of privilege to navigate between,
    and if you can enumerate one character, you know you are able to capture all of
    them. Hopefully these tradeoffs are understood by our target''s developers, and
    protection via other means is put into place to prevent access or validate all
    transactions.'
  prefs: []
  type: TYPE_NORMAL
- en: XPath injections are pretty straightforward once you have that basis in SQLI.
    We're looking for escape characters that either expose the logic or, better yet,
    give us full up access. Â Let's first head into the **Broken Web App**'s (**BWAPP**)
    **`XML/XPath Injection (Login Form)`** bug page and bring up our portal, which
    I show how to find in following screenshot. This VM is included in the same OWASP
    BWA we've been using all along. You have probably noticed as much, but to state
    the obvious, the OWASP BWA VM is the single, most important training tool outside
    of Kali itself, and it is free!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_07_14.png)'
  prefs: []
  type: TYPE_IMG
- en: Finding the Broken Web App XPath Injection Page
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test for a lack of input validation for potential XPath injection if
    we just use our single quote character again and observe any errors (as shown
    in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_07_15.png)'
  prefs: []
  type: TYPE_IMG
- en: Error indicating XPath Injection possible
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of the `'' or 1=1 -â��` string we saw in SQL, we''re going to use the
    XPath variant of `'' or ''1''=''1` in both the **`Login`** and **`Password`**
    fields, which tells the XPath query *please look for this escape character, because
    1 equals 1 and so we are legit!*Â  We''d hope validation is being done to sanitize
    these inputs, but it is mind-boggling how many servers will kick back a login
    success like the one followingÂ when using this string in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_07_16.png)'
  prefs: []
  type: TYPE_IMG
- en: Logged in using XPath Injection
  prefs: []
  type: TYPE_NORMAL
- en: 'This process is great to understand using just a browser, but you can also
    do so much more when you let a tool help. **Recon-ng** is a fantastic CLI tool
    that provides a menu structure similar to Metasploit or Websploit that, together
    with the `xpath_bruter` module (wonderfully managed by Tim Tomes), helps automate
    the delivery of **Blind XPath injection** payloads for enumeration of a host.
    We''ll buddy up with Burp Suite too, so that we can harvest the inputs we''ll
    need. So enable proxies, strap in, and prepare to dominate the BWAPP! Let''s look
    first at what `recon-ng` needs from us in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_07_17.png)'
  prefs: []
  type: TYPE_IMG
- en: Recon-ng's XPath_Bruter Module
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume we are OSINT ninjas, and maybe we did a little social engineering
    and found out that Thor is a user and he has the rather naÃ¯ve password of Asgard.
    We can use this single set of credentials to set up our Blind XPath injection.
    From the `show options` command's output preceding, you can see we'll need a couple
    of things to get started. The following screenshotÂ highlights most of the required
    fields for us.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_07_18.png)'
  prefs: []
  type: TYPE_IMG
- en: Our Burp Suite Capture to seed Recon-NG
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we'll grab the **BASE_URL** (in red). Then you'll need the parametersÂ field,
    which is the piece of a URL string we're going to brute-force to enumerate the
    data (in green). We'll use the login parameter to toggle between true and false.
    Assuming you are able to intercept all of the requests now, you should see that
    this portal uses an HTTP GET message to submit queries (as seen in blue), which
    consequently means that the query is embedded within the URL sent to the server.
    Lastly, this particular portal uses cookies, so we can paste in the entire string
    (in purple) for that.
  prefs: []
  type: TYPE_NORMAL
- en: Recon-ng's `XPath-Bruter` module is going to want to know all of this, and it
    is also going to want to know how we tell a true and false apart (the `string`Â variable).
    So if I type what I know to be true credentials (our true condition) I get back
    Thor's secret message, so I can use the word `Earth` as my string. If I do a boolean
    `and` condition with a known false (1 most certainly doesn't equal 2 at the time
    of this book's writing), that string will not show up.Â
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s input those variables, take Burp and our proxy configuration out
    of the loop, and execute our Brute-Force attack! What we''ll see enumerated within
    minutes is seen in the following screenshot: the entire contents of the `heroes.xml`
    file containing all user accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_07_19.png)'
  prefs: []
  type: TYPE_IMG
- en: Enumerated XML from recon-ng's xpath_bruter module
  prefs: []
  type: TYPE_NORMAL
- en: You will find that other injection tools very much follow a similar approach.
    Detection techniques center around the trial-and-error process of finding strings
    that can help expose the flaws, while exploits (in ethical hacking) are usually
    focused on enumeration. Black hat hackers may use some of these tools for actual
    corruption, manipulation, or destruction of the data, but they are normally using
    custom Python or Ruby scripts to execute these malicious attacks, or leveraging
    frameworks offered on the Dark Web. One of the better tools for more advanced
    CLI-based injection testing is Wapiti ([http://wapiti.sourceforge.net/](http://wapiti.sourceforge.net/))
    as it can help in both SQL and XPath injection with a massive number of command
    line switches, options, and use cases supported.
  prefs: []
  type: TYPE_NORMAL
- en: Credential Jedi mind tricks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Database administrators, analytics experts, and data scientists get paid big
    bucks to help structure, manage, and provide access to data in various database
    types, and rightfully so. But even if an application doesn't use this technology,
    or an enterprise doesn't invest in these database types outright, I'd wager that
    they all have a database installed that is arguably more important to their inner
    workings right under their noses--credential databases. Anytime a customer is
    using **Microsoft Active Directory** (**AD**), one of the many flavors of **Lightweight
    Directory Application Protocol** (**LDAP**), or another **identity management
    system** (**IMS**), there is an underlying database that is just begging to be
    tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Credential database hacks can have varying objectives. The most straightforward
    ones look to find a legitimate user''s account to allow the hacker to impersonate
    users and access sensitive information. Others will look for default accounts
    that may not have been disabled or hidden and can then be used with impunity to
    carry out privileged access, administrative functions, or even create new shadow
    accounts that can be used as backdoors and protect the originally compromised
    account for later attempts. LDAP queries, like SQL and XPath, have a syntax of
    their own; like those other injection types, vulnerable queries that fail to sanitize
    data are subject to escape characters that can force logins or quickly escalate
    privileges.Â  Luckily for us, LDAP is much more specific in it''s use, so it has
    a much easier set of manual testing techniques than other types of injections
    might.Â  The flip side to that is that there are no widely used tools on the Kali
    distribution that focus specifically on LDAP Injection scanning or exploits. Burp
    Suite can provide some detection and general injection assistance, but for more
    information please refer to the OWASP guidance on LDAP injection: [https://www.owasp.org/index.php/Testing_for_LDAP_Injection_(OTG-INPVAL-006)](https://www.owasp.org/index.php/Testing_for_LDAP_Injection_(OTG-INPVAL-006)).'
  prefs: []
  type: TYPE_NORMAL
- en: Going beyond persuasion â�� Injecting for execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Ok, so we're done playing nice. Maybe an attacker has decided a website has
    nothing of value to them, but they want to deny its functions to legitimate users
    nonetheless. Maybe they are after this application and want to bring it down and
    render the application owner helpless.Â  Or worse yet, maybe they are just using
    this site to get to another one, and in compromising the application they hope
    to impact or laterally move to another. Whatever the motives, one class of injection
    attacks looks beyond convincing the application to cough up its secrets; they
    instead look to convince the server to run new code or execute commands that the
    application's developers had no intention of using or allowing.
  prefs: []
  type: TYPE_NORMAL
- en: We need to be able to find these attacks before the bad guys do. Data leakage
    is a huge concern, no doubt, but a complete crash or long-term compromise of the
    servers themselves threatens the very existence of the application and the company
    relying on it.
  prefs: []
  type: TYPE_NORMAL
- en: Code injections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A code injection is used to implement what are known as buffer overflow attacks.
    Rather than pop-up messages to demonstrate that the vulnerability exists, these
    attacks focus on using these cracks in the application''s security validation
    to execute arbitrary code that allows the attacker to take over their target,
    or use the compromised server as a pivot into the environment. Simply put, if
    a website is running on PHP or ASP and passes information via URL query, you can
    look for a code injection flaw by simply identifying the tell-tale string, showing
    that page redirection is accepted, in the source for our page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: While this is a pretty benign test path (we're not looking to do harm) we can
    exploit the vulnerability by altering the message and capturing the result for
    our customer. If it is possible to alter the behavior of the web server with a
    simple message, black hat hackers will attempt to run something truly malicious
    on that server using standard PHP functions in an effort to subvert or take over
    the web server itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'I modified the message to show the customer who is in charge using the following
    string, with the results shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B03918_07_20.png)'
  prefs: []
  type: TYPE_IMG
- en: Successful code injection
  prefs: []
  type: TYPE_NORMAL
- en: Overflowing fun
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several forms of code injection that cause buffer overflows,Â each
    focused on attacking a different service in the underlying web or Application
    Tier servers or in the application itself. Â Well-known overflow attacks are often
    unnoticed by the developers who are managing extensive reuse of libraries and
    therefore may not understand that the vulnerability is there. Â Even with this
    potential for issues, more is known about these, and so we must encourage our
    customers to be hyper vigilant in their patching and configuration management.
    Their own custom code and the programming languages they choose, however, lack
    that degree of scrutiny, and so without us helping test their application, they
    are going to be susceptible to the same types of attacks but through unique vectors.
  prefs: []
  type: TYPE_NORMAL
- en: The common categories we'll discuss in web pen test circles are the Stack, Heap,
    Format String, Unicode, and Integer types.
  prefs: []
  type: TYPE_NORMAL
- en: '**Stack overflows** are one of the more commonly exploited forms, and result
    when a loosely typed language such as C++ or ASP.NET are used and the developer
    fails to implement at leaseÂ input validation and/or stack integrity checking
    (also known as canary values) in their code.Â Because there is no validation of
    the type or size ofÂ user input, the attacker uses this to inject much longer
    strings into the stack, where the execution stack then overwrites adjacent memory
    space and thus allows the malicious code to find a home; the function that was
    called now points to the top of the malicious code''s memory space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some CPUs are capable of aiding in defense of these overflows, as they are more
    modern operating systems. It is well worth ensuring that web application teams
    are specifying hardware requirements and considering them within the Software
    Development Life Cycles specification and design phases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Heap overflows** are similar to stack overflows except that they are focused
    on space that is normally not protected by the hardware platform''s CPU. Heaps
    are dynamically allocated as a program is invoked, and the attacker takes advantage
    of this by using those loose rules to force an overflow that overwrites pointers
    and thus allows the hacker to redirect the CPU, pointing to malicious code of
    their own. These are pretty rare given their being addressed in the early 2000''s
    by Microsoft and Linux, but they are well worth checking for given their potential
    impact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Format string overflows** take advantage of poorly crafted system calls and
    functions used in code. Â C and C++ are notorious for having functions that can
    pass multiple variables of various types without being validated. These same function
    attributes may contain control instructions to the underlying function, so it
    is common to see format string injections exploit previously unused portions of
    those calls to force unanticipated behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unicode overflows** exploit the use of characters not in the standard alphabet
    of the programming language to trigger potential overflows. Not as common as the
    Heap and Stack types, they can be prevented using similar precautions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integer overflows** merely take advantage of poor validation in the integer
    inputs to an operation, such that they load the two variables with numbers they
    know will result in an answer that exceeds the allotted space, thus creating the
    overflow. Like Unicode, protection against the first three overflow types should
    prevent Integer Overflows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for the various forms of buffer overflow can be included in scans byÂ tools
    such as Burp Suite,Â w3af ([http://w3af.org](http://w3af.org)) and other full-featured
    DAST suites, but Metasploit can help craft all sorts of custom scripts to take
    advantage of them. A fantastic tutorial on this is covered at **Primal Security**
    ([http://www.primalsecurity.net/0x0-exploit-tutorial-buffer-overflow-vanilla-eip-overwrite-2/](http://www.primalsecurity.net/0x0-exploit-tutorial-buffer-overflow-vanilla-eip-overwrite-2/))
    and as you can see, there is a lot that goes into making a suitable buffer overflow
    attack happen.
  prefs: []
  type: TYPE_NORMAL
- en: Commix - Not-so-funny command injectionsÂ
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Command injection, on the other hand, does not look to inject code, reflect
    back to hosts, and alter the application's behavior. Command injection finds a
    window through an injectable command used in normal operation of the application
    that gives us some visibility or reach into the back end Web or Application Tier
    servers. The objective is to inject additional commands into the variable strings
    to run local commands on the host operating system, such as a `copy` command,
    reconfiguration of an interface, or worst case scenarios such asÂ `fdisk`. This
    is not your typical fun-loving hijinks â�� this is cruel stuff. A great discussion
    of this occurs in the OWASP OTG ([https://www.owasp.org/index.php/Command_Injection](https://www.owasp.org/index.php/Command_Injection)
    ) and the tool **Commix**Â (**Comm**and **I**njection E**x**ploiter) is included
    with Kali Linux just to be sure we're covered.
  prefs: []
  type: TYPE_NORMAL
- en: To use Commix, you will need the URL (we're using DVWA for this one), the cookie
    associated with your session (I again used Burp with the Intercept On), and the
    field you are fuzzing (IP in this case), and away you go; I got shell access in
    a hurry (as shown in the following screenshot)!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_07_21.png)'
  prefs: []
  type: TYPE_IMG
- en: Shell access through CommixÂ Code Injection
  prefs: []
  type: TYPE_NORMAL
- en: Down with HTTP?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: All of the attacks we've discussed so far in this chapter involve placing strings
    in form fields that we know can cause havoc on back end databases. Many web services
    now create dynamic headers based on user input and session state, and a new class
    of attacks has surfaced to take advantage of the holes this can potentially open
    up. When attackers put their mind to it, they can inject information into headers
    that are actually akin to XSS in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, HTTP is very rigorously mapped in its syntax, such that it treats
    carriage returns and line feeds as special delineation points between fields.
    An attacker might slip some of those in to inject their own arbitrary fields and
    deliver their payloads if the web server is not properly rejecting or sanitizing
    those inputs. This form of attack is called **HTTP response splitting**.
  prefs: []
  type: TYPE_NORMAL
- en: Another form of attack in this class involves **HTTP session fixing**, which
    is a means by which an attacker senses that a website authenticates users and
    uses a session ID, but fails to validate who is sending the session ID and thus
    treats anyone, both the attacker and the victim client, as legitimate participants
    (the web server is unable to differentiate between the two). Through social engineering,
    the attacker can then jump the gun and coerce the victim in to clicking on a link
    where the session ID is already chosen by the attacker. The victim then authenticates,
    basically telling the web server that this session ID is valid. The attacker has
    basically planted their own cookie and had the victim vouch for it.Â
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**HTTP Verb Tampering** is another concern, in that it takes advantage of a
    lack of input validation on HTTP requests and uses verbs (POST,Â HEAD, GET, TRACE,
    TRACK, PUT, DELETE, and so on, covered rather well by [http://www.restapitutorial.com/lessons/httpmethods.html](http://www.restapitutorial.com/lessons/httpmethods.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: These attack methods are very new and upcoming; outside suites such as Burp
    and Wapati, there are no specialized tools in Kali to specifically cover HTTP
    injection attacks. For more information, please visit the whitepaper produced
    by **Watchfire** ([http://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf](http://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Injection attacks are numerous and lethal. Given the sheer number of categories,
    methods, and objectives that attackers have to take advantage of these vulnerabilities,
    it is so wonderful that dynamic content is able to be secured. This class of attack
    can only be prevented through vigilant and best-practice-based segmentation, sanitization,
    and continuous penetration testing.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we looked at the various classes of injection attack, with
    SQL Injection, most likely the star of the show. Given the widespread use of SQL
    in modern application frameworks, it is understandable that more tools and attention
    are given to this form of injection. We'll see how long that lasts, however, as
    XML and XPath are seeing increased use with the explosion in processing capabilities
    and the need for streamlined access and portability. Additionally, more specialized
    injection techniques should not be omitted, as LDAP, command, and code injection
    flaws, while less frequently encountered, are potential nightmares to a company
    whose servers are found lacking in protection. All told, injection attacks can
    be time-consuming and tedious to test for, but adversaries only need one crack
    in the armor to get lucky.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a look at a more technically focused attack
    vector â�� cryptographic flaws and vulnerabilities. The web has been growing at
    an incredible rate at precisely the time when the general public has become aware
    of this dependence and insisted on privacy and confidentiality. Hackers are ahead
    of them in many ways, lying in wait with defeat mechanisms that can allow them
    to intercept, modify, or expose the contents of data flows and betray the trust
    web applications and clients need to have in each other to function properly.
    If you are ready for some spooky stuff, then follow me into [Chapter 8](000.html#),
    *Exploiting Trust ThroughÂ Cryptography Testing*!
  prefs: []
  type: TYPE_NORMAL
