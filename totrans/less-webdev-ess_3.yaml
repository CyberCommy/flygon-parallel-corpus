- en: Chapter 3. Nested Rules, Operations, and Built-in Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how *Less* helps you organize your CSS selectors
    more intuitively, makes inheritance clear, and makes your style sheets shorter.
    You will also learn about operations and built-in functions. Operations let you
    add, subtract, divide, and multiply property values and colors. They also give
    you the power to create complex relationships between properties. You will also
    learn how to set variables or guards using the built-in functions in your *Less*
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Nesting CSS rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using built-in functions in you code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using built-in functions in your mixins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The navigation structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the examples in this chapter, you will extend the layout from [Chapter
    2](ch02.html "Chapter 2. Using Variables and Mixins"), *Using Variables and Mixins*
    step by step with a navigation structure. You will build this navigation structure
    by styling an HTML list with *Less*. This navigation structure forms a menu in
    the sidebar of the layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final result will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The navigation structure](img/1465-03-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The final navigation menu built using *Less*
  prefs: []
  type: TYPE_NORMAL
- en: Nested rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will use the layout example from [Chapter 2](ch02.html "Chapter 2. Using
    Variables and Mixins"), *Using Variables and Mixins*, to study *nesting of rules*
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, you must first open `http://localhost/index.html` in your browser
    and then open `less/sidebar.less` in your text editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anchors are added to the menu items. This means that the HTML code of the side
    menu now looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You need a selector for each rule to style the different elements in CSS as
    can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, both the `ul` (including the `li` element and the `a` anchor)
    element and the `h2` element are the children of the `aside` element with the
    `#sidemenu` ID. CSS doesn''t reflect this relationship because it is currently
    in the format as shown in the preceding code. *Less* will help you to reflect
    this relationship in your code. In *Less*, you can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will compile straight into the following CSS syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The resulting CSS of your compiled *Less* code is exactly the same as your original
    CSS code. In *Less*, you refer to the `#sidemenu` ID only once, and due to the
    nesting of `h2` and `ul` inside `#sidemenu`, your code structure is intuitive
    and reflecting the **DOM structure** of your HTML code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep your code clean, a new `less/sidebar.less` file has been created. It
    contains the preceding *Less* code. Of course, this file should also be imported
    into `less/styles.less` using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Please also note that the sidebar is wrapped in a semantic HTML5 `aside` element
    instead of a `div` element. Although this is more semantic**,** you will find
    that your sidebar has floated to the left after you made these changes. To fix
    this, open `less/content.less` in your text editor. By studying the nesting of
    the CSS selectors in the *Less* code, you will find `aside float:right;` nested
    in the `.wrapper` container. If you move this `aside` rule inside the `#content`
    container, the syntax should look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `less/content.less` file, you will also find the line `h2 { color: @content-dark-color;
    }`, which is in contrast to what you will see in the `aside` element. The `h2`
    rule will still be overwritten by `#sidebar h2{ color: black; }`. The final rule
    contains a `#sidebar` selector and so it has a higher **CSS specificity**, as
    explained in the first chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Inspect the *Less* files, such as `less/header.less`, again and keep these brand
    new insights about nesting of CSS selectors in mind. You will see that nesting
    is already used frequently. For example, in `less/header.less`, the properties
    of the `h1` element are set by nesting.
  prefs: []
  type: TYPE_NORMAL
- en: A proper inspection of these files will also show you how mixins can be nested
    in classes and other mixins.
  prefs: []
  type: TYPE_NORMAL
- en: Mixins and classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The name of a mixin should always end with parentheses; otherwise, it is a
    normal **class**. Both mixins and classes can be nested in *Less*. Consider the
    difference in the following example *Less* code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This code gets compiled into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see how the properties of `.class-1` are copied into `.class-2` in
    the compiled CSS. When you add parentheses after `.class-1` in*Less* and make
    it a mixin, you should now consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will get compiled into the following CSS code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's go back to the example of the side navigation menu. When your menu is
    ready, you will find that the "navigating" text inside the `h2` heading element
    makes no sense. Unless you are visually impaired and use a screen reader, you
    can easily see the side menu is intended as navigation for the website. So, you
    can hide this heading but should keep it visible for **screen readers**. Setting
    `display:none` will hide the element from screen readers, while `visibility:hidden`
    will also hide the element but still takes space and so can mess up our design.
    Setting the `clip` property will help in this situation. You can find more details
    by visiting [http://a11yproject.com/posts/how-to-hide-content/](http://a11yproject.com/posts/how-to-hide-content/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the rule of precedence, you can write the following class using *Less*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the preceding class to `less/boxsizing.less` and rename this file as `less/basics.less`.
    Also, please don''t forget to rename the import statement in `less/styles.less`.
    Now you can use the following *Less* code to hide the `h2` heading element in
    the sidebar menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After performing these steps and compiling the *Less* code into the CSS code,
    the sidebar navigation will now look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mixins and classes](img/1465-03-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A styled navigation menu with hidden heading text
  prefs: []
  type: TYPE_NORMAL
- en: 'As `.screenreaders-only` is a class and not a mixin, and classes are compiled
    to your final CSS, not only can you use the `.screenreaders-only` class to add
    its properties to other classes in *Less*, but you can also use the class in your
    HTML directly, as shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When working with *Less*, you will often have to choose between specific compiled
    *Less* classes based on your project's HTML structure and a more generic solution
    that will be applied with a class inside your HTML code. Unfortunately, in these
    cases, there is no single solution. In general, DOM-specific code will generate
    more CSS code but will also keep your HTML clean and give you the opportunity
    to generate more semantic HTML code. Reusing your *Less* code won't always be
    simple for this option.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling your *Less* syntax as classes and using them in your HTML will make
    your code more reusable. On the other hand, it will mess up your HTML due to these
    classes. Also, the relationship between the CSS effects and HTML structure becomes
    less strict. This makes it more difficult to maintain or change.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `less/variables.less`, you should define a section for your sidebar, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding variables, the *Less* code in `less/sidebar.less` will now
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Classes and namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before finishing the menu, the *Less* code used to style the menu will be changed
    to a class first. The points to consider here have already been discussed. A navigation
    is a general structure that can be used in many projects. In the class structure,
    it can be used to style any HTML list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please create a new file for `less/nav.less` and write the following code into
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can turn every HTML list (`ul` or `ol`) in our HTML document into a
    navigation structure just by adding the `.nav` class to it. This can be done using
    the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Please notice that with this *Less* code, lists can''t be nested, and the items
    on the list should contain anchors (links). These requirements make it seem clear
    that this code can easily be (re)used in your other projects. *Less* also offers
    the possibility of defining **namespaces**. Namespaces can make your code more
    portable and are defined in the same way as CSS ID selectors. Namespaces start
    with a `#`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `#lessnamespace` namespace can now be used as an example, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, a namespace doesn''t differ from an ID selector. The `#lessnamespace`
    namespace can also be used directly in your HTML code, although this is not useful
    in most cases, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: HTML requires every ID to be defined only once, so you can't use the preceding
    HTML code more than once in your HTML document unless you append the ID to the
    body. Nevertheless, the preceding code shows that even specifically written *Less*
    code for a custom HTML DOM structure can be reused in other projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `#lessnamespace` namespace, as defined earlier, `.nav` is a class that
    makes direct usage possible. When `.nav` is changed to a mixin, it can only be
    reused in *Less,* as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will get compiled straight into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Operating on numbers, colors, and variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Less* has support for the basic arithmetic operations: addition (`+`), subtraction
    (`-`), multiplication (`*`), and division (`/`). In the strict-math mode, operations
    should be placed between parentheses. You can apply an operation on variables,
    values, and numbers. These will help you make relationships between variables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `less/footer.less` to immediately see the operation that you used, as
    in the following code, and its benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the `/` sign (division) has been used to give the footer
    columns one-third of the available width (as set by `@basic-width`). Using operations
    in your code feels so natural that you may not have even realized you have been
    using them until now. *Less* uses normal **order precedence**, where you can add
    extra parentheses to explicitly set precedence and avoid confusion. For instance,
    in *Less*, *3 + 3 * 3* gives *12*. So, *(3 + 3) * 3* equals *18,* as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will get compiled into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Less* operations can also be used for color manipulation and operations can
    be applied on values and colors with different units, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will get compiled into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The & symbol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `&` symbol plays a special and important role in *Less*. It refers to the
    parent of the current selector and you can use it to reverse the order of nesting
    and to extend or merge classes. You will see that the following example will tell
    you more than what can be expressed in a thousand words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will compile into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You can see that `.class2` becomes the parent of `.class1` when you use the
    `&` symbol after it. The `&` symbol can also be used in order to reference nesting
    that is outside the mixin.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `&` symbol can also be used to nest and append **pseudo classes** to a
    class. Later on, you will see that you can use it to append classes too. A simple
    example of this will be adding a `:hover` pseudo class triggered by a mouse hover
    to a link, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This code can be compiled into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open `less/mixins.less` in your text editor and find the **clearfix mixin**.
    The clearfix mixin uses the `&` symbol to append the `:hover`, `:after`, and `:before`
    pseudo classes to your elements, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With this new knowledge about the `&` symbol, it will now be easy for you to
    understand how to extend your example navigation menu with the `:hover` and `:active`
    (`.active`) states, and the following code shows you how your extended code will
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Open `http://localhost/indexnav.html` in your browser to inspect the results
    of the preceding syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `extend` pseudo-class is a *Less* pseudo-class and uses the same syntax
    as a CSS pseudo-class. The `extend` pseudo-class adds the selector to the **extended
    selector** list. Adding the selector to the selector list of a different class
    gives the selector the same properties as the extended class. Remember the `.hyperlink`
    class in a previous example? If you extend this class, then both classes will
    have the same properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will get compiled into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the nested `:hover` pseudo class is not covered in `.other-hyperlink`.
    To extend a class including the nested elements of the extended style, you will
    have to add the `all` keyword, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This code now gets compiled into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In cases where you nest the `:extend` statement, you have to use the `&` symbol
    as a reference, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In spite of the fact that the `extend` syntax mimics the syntax of the pseudo
    class, both of them can be combined as long as `:extend` is added at the end of
    the selector, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Property merging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Property merging** is useful if properties accept a **Comma Separated Value**
    (**CSV**). You will find this type of property mostly in CSS3, where borders,
    backgrounds, and transitions accept a CSV list. However, you will also find that
    the old-school `font-family` parameter accepts a list of font names that are separated
    by commas. Properties are merged by adding a plus sign (`+`) after their names,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will get compiled into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Built-in functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Less* supports many handy **built-in functions**. A built-in function can
    be used to manipulate *Less* values inside mixins and set the variables'' values.
    Last but not least, they can also be used in **guard expressions**. You will find
    the complete list of functions by visiting [http://lesscss.org/functions/](http://lesscss.org/functions/).'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you won't find them all, but you will learn how to use functions
    from all different groups. Functions can be grouped based on their input and output
    types, where these types are mathematical functions, color functions, list functions,
    string functions, and type functions. There is also a small number of functions
    that can't be grouped using the preceding classification.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Less* functions map native **JavaScript functions** and code in the first
    place because of the fact that *Less* has been written in JavaScript. Currently,
    JavaScript expressions can still be evaluated as values inside *Less* code, but
    this ability may be removed in future versions. JavaScript code should be wrapped
    between back quotes when used in your *Less* code, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This *Less* code, which includes JavaScript code, will compile into the following
    CSS code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Even though it is possible, try to avoid using JavaScript in your code. **Less
    compilers** written in other languages can't evaluate this code, so your code
    is not portable and is more difficult to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is no built-in *Less* function available for your purpose, try to
    write the equivalent of what you need in *Less* code. Since Version 1.6, there
    is a `max()` function, and previously, you could use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In particular, watch out when using the JavaScript environment in your *Less*
    code. Also, values such as `document.body.height` make no sense in your compiled
    and stateless CSS.
  prefs: []
  type: TYPE_NORMAL
- en: List functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Extract()` and `length()` are functions to get the values and the length of
    a CSV list. Together, these functions can be used to **iterate** as arrays over
    a CSV list.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember the loop used to set background images in [Chapter 2](ch02.html "Chapter 2. Using
    Variables and Mixins"), *Using Variables and Mixins*? Here, you will use the same
    technique to add icons before the links in the sidebar navigation.
  prefs: []
  type: TYPE_NORMAL
- en: This example uses icons from Font Awesome. Font Awesome is an iconic font that
    uses scalable vector icons which can be manipulated by CSS. Icons can be scaled
    or colored easily with CSS; also, loading the font requires only one HTTP request
    for all icons. Please refer to [http://fontawesome.io/](http://fontawesome.io/)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Font Awesome, reference its source first by adding the following line
    of code to the head section of your HTML document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Font Awesome and other iconic fonts can also be integrated and compiled into
    your project using *Less*. You will learn how to do this in [Chapter 4](ch04.html
    "Chapter 4. Avoid Reinventing the Wheel"), *Avoid Reinventing the Wheel*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your HTML, you can now use the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Icons are added with the CSS `:before` pseudo class, so the preceding HTML
    code can also be styled without a class by using the following *Less* code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A list of Font Awesome icons and their CSS content values can be found by visiting
    [http://astronautweb.co/snippet/font-awesome/](http://astronautweb.co/snippet/font-awesome/).
  prefs: []
  type: TYPE_NORMAL
- en: 'With this information about iconic fonts, you can construct a loop that adds
    icons to the list items of your navigation, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `@icon_: e(extract(@icons, @i));` line, `e()` is a **string function**,
    and this function is the equivalent of escaping using `~""`. Please also note
    that in the `content: "@{icon_}\00a0";` statement, `\00a0` only adds an extra
    space that separates the icon from the link.'
  prefs: []
  type: TYPE_NORMAL
- en: The icons in the `@icons` CSV list are randomly chosen. The recursive calling
    of the `add-icons-to-list()` mixin starts with the `.add-icons-to-list(length(@icons));`
    call, where `length(@icons)` returns the number of items in `@icons`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Less* code of the loop which adds icons to the list items should be added
    into `less/navicons.less`. After adding the code, open `http://localhost/indexnavicons.html`
    to see the results, which should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![List functions](img/1465-03-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Iconized hyperlinks built with Less and Font Awesome
  prefs: []
  type: TYPE_NORMAL
- en: 'The icon list in the preceding screenshot serves only for demonstration purposes,
    where, in fact, the icons are not even related to the hyperlinks. The absence
    of this relationship makes it difficult to find a use case at all. However, with
    your creative minds, I bet you can find one. Remember that CSS is used only for
    presentation and cannot modify HTML, so you can''t set the links themselves using
    *Less*. However, creating a relationship between the hyperlinks and icons that
    already exist is possible, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Here, `a[href*="linux"]` is a selector for all anchors with the word `linux`
    in their `href` attribute. After adding the preceding code to `less/styles.less`,
    you can view the results at `http://localhost/index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Using color functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Less* color functions can be split into functions for **color definition**,
    **blending, operations**, and **channel manipulation**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Colors are defined in **color channels.** An RGB color has three channels:
    red, green, and blue. CSS2 used this RGB definition to declare colors, and CSS3
    adds new definitions for color declaration. These new definitions, such as HSL
    and HSV, are nothing more than transformations of RGB values. The CSS3 color setting
    methods should be more intuitive and user friendly. For instance, HSL defines
    colors in three channels, which are hue, saturation, and lightness in this case.
    *Less* has built-in functions for channel manipulation of different types of color
    definitions. *Less* also supports different types of color definitions. Since
    CSS3, you can declare color values as hexadecimal colors, RGB colors, RGBA colors
    (RGB colors with an additional alpha channel that sets the opacity), HSL colors,
    and HSLA colors (HSL colors with an additional alpha channel that also sets the
    opacity). Of course, you are allowed to use the predefined cross-browser color
    names.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiled color values of *Less*''s color definitions are not always defined
    as a hexadecimal color in CSS code; if possible, the output of a color definition
    matches the CSS values, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding *Less* code becomes the following CSS code after compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Colors are a basic part of the design and styling of your website. Color functions
    can help you design your **color palettes** and make them dynamic. They will be
    used, for instance, to give elements a border color that is darker than the background
    color or to give elements contrasting colors that are based on a single input
    color.
  prefs: []
  type: TYPE_NORMAL
- en: The darken() and lighten() functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `darken()` and `lighten()` functions are two color functions that can be
    used to obtain a darker or lighter variant of the input color. You have seen how
    these functions have been used in the example layout from [Chapter 2](ch02.html
    "Chapter 2. Using Variables and Mixins"), *Using Variables and Mixins*. Now you
    can apply these functions on the website navigation menu you have built previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please open `less/variablesnav.less` in your text editor and define your menu
    variables that are dependent on the main `@menucolor` parameter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: After doing this, check your changes by opening `http://localhost/indexnav.html`
    in your browser. Now you can modify the look of your navigation by only changing
    the color defined by the `@menucolor` variable. You will also find that setting
    `@menucolor` to a light color, such as pink or yellow, makes your fonts unreadable
    due to the **contrast** between the background color and the font color not being
    high enough. High contrast plays an important role in web design. Designs with
    high contrast help you meet **accessibility** standards. High contrast not only
    helps visibly disabled or color blind people, it also influences those with normal
    vision, as humans are naturally in favor of high contrast color designs. This
    favor plays a role in the first impression of your website.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the right amount of contrast is not always easy. Also, in this case,
    you don't want to have to change all your font colors after changing the basic
    color. The `contrast()` function of *Less* will help you to choose a color that
    can easily be seen against a colored background. In accordance with WCAG 2.0 ([http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef](http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef)),
    this function compares the **luma** value and not the lightness of the colors.
    The `luma()` function itself is also a built-in color function.
  prefs: []
  type: TYPE_NORMAL
- en: The `contrast()` function accepts four parameters. The first parameter defines
    the color to be compared against; this is the background color in this particular
    case. The second and third parameters define the dark and light color, which are
    black and white by default. The fourth and last parameter sets a threshold. This
    threshold has been set to 43 percent by default and defines the luma (perceptual
    brightness). Colors above the threshold are considered as light, and `contrast()`
    returns the dark color that is already defined in the second parameter for these
    light colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, reopen `less/variablesnav.less` and change the navigating font colors
    according to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: To see more effects, change the `@menucolor` variable to different colors such
    as `yellow`, `pink`, `darkgreen`, or `black` and observe the change by opening
    `http://localhost/indexnav.html`. Keep in mind that the lightest color is white
    and the darkest is black, so `darken(black,10%);` or `lighten(white,10%);` won't
    have any effect.
  prefs: []
  type: TYPE_NORMAL
- en: Color manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, *Less* provides you with many functions to manipulate
    colors. This book is not about **color theory**, so it handles only some examples
    of color manipulation. You can find more information about color theory by visiting
    [http://www.packtpub.com/article/introduction-color-theory-lighting-basics-blender](http://www.packtpub.com/article/introduction-color-theory-lighting-basics-blender).
  prefs: []
  type: TYPE_NORMAL
- en: Color operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the `darken(), lighten()`, and `contrast()` functions, you have become
    acquainted with some of the color operations. Other operations include `saturate()`,
    `desaturate()`, `fadein()`, `fadeout()`, `fade()`, `spin()`, `mix()`, and `grayscale()`.
  prefs: []
  type: TYPE_NORMAL
- en: The functions mentioned earlier accept one or more color values, with the percentage
    as an input parameter, and return a color. Please note that the color ranges from
    white to black and does not wrap around. So, you can't, as mentioned earlier,
    darken the color black so that it becomes white.
  prefs: []
  type: TYPE_NORMAL
- en: If color definitions contain percentages, then the operations change them with
    the absolute percentage of the input parameter. So, `darken(hsl(90, 80%, 50%),
    20%)` becomes `#4d8a0f`; which equals `hsl(90, 80%,30%)` and *not* `hsl(90, 80%,10%)`.
    Of course, you will see the same effect as you manipulate the second channel,
    which defines saturation. For instance, `desaturate(hsl(45, 65%, 40%), 50%)` compiles
    into `#756e57;`, which equals `hsl(45, 15%, 40%)`.
  prefs: []
  type: TYPE_NORMAL
- en: The `mix()` function is the last example of color operations. The other functions
    are left for you as exercises.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This will again become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This mixture will also be shown in the following image :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Color operations](img/1465-03-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How a mixture of blue and yellow is presented using `mix(blue, yellow, 50%)`
  prefs: []
  type: TYPE_NORMAL
- en: Color blending with Less
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The color blending functions calculate a new color based on two input colors,
    where functions apply basic operations such as subtraction on the color channels
    of the input colors. Available functions, also called blend modes, include `multiply()`,
    `screen()`, `overlay()`, `softlight()`, `hardlight()`, `difference()`, `exclusion()`,
    `average()`, and `negation()`. Users of layered image editors such as Photoshop
    or GIMP will recognize these functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `difference()` function subtracts the second color from the first color
    on a channel-by-channel basis, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will become the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows how a mixture of orange and red would appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Color blending with Less](img/1465-03-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How a mixture of orange and red will appear using `difference(orange, red, 50%)`
  prefs: []
  type: TYPE_NORMAL
- en: Type functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type functions evaluate the type of the input value and return as `true` if
    the type matches the function. The functions that are available are `isnumber(),`
    `isstring()`, `iscolor()`, `iskeyword()`, `isurl()`, `ispixel()`, `isem()`, `ispercentage()`,
    and `isunit()`. Some example functions are shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Type functions are useful in defining guards. Please consider the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `default()` function is another built-in function that is not grouped in
    a function class. The `default()` function can be used inside a guard and returns
    as `true` when none of the other mixins match the caller. You can add a default
    mixin to the preceding mixins, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The box-shadow mixin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With all that you have learned about *Less*, you now can understand, build,
    and evaluate any complex *Less* code. To prove this, please open `less/mixins.less`
    and take a look at the box-shadow mixin (originally published on [lesscss.org](http://lesscss.org)),
    which looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: To fully understand these mixins, you will have to know the basics of **box-shadow**
    in CSS3\. The box-shadow properties accept a CSV list of shadows. A shadow consists
    of a list of two to four length values and a color. The first two length values
    describe the vertical and horizontal offsets related to the center of the box.
    These values are required but can be set to `0` to get an equal-size shadow around
    the box. The final values are optional and set the blur radius and the spread
    radius, respectively. The blur and spread radii are both `0` by default and give
    a sharp shadow, where the spread radius equals the blur radius.
  prefs: []
  type: TYPE_NORMAL
- en: Now you should be able to evaluate the mixin. You will see that the mixins form
    a guard. Both mixins accept two parameters. The first parameter is the length
    vector, which is described earlier; the second is a color or a percentage. If
    you recall that the `isnumber(40%)` call evaluates as `true` despite the ending
    percent sign. Calling `rgba(0, 0, 0, @alpha)` will give shades of gray depending
    on the value of `@alpha`. If you define the second parameter as a color, such
    as `blue` or `#0000ff`#, the `iscolor(@c)` guard will evaluate as `true`, and
    the first mixin will be compiled using your defined color.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you built a navigation menu with *Less*. The navigation contains,
    amongst other things, hovers, contrast colors, and icons that can all be set with
    a few basic settings. You have learned how to use nesting rules, mixins, and built-in
    functions in *Less*. At the end of the chapter, you have understood and used complex
    *Less* code. All this newly acquired knowledge will be very useful in the next
    chapter. In the next chapter, you will learn how to find and build reusable *Less*
    code. This will help you work faster and obtain better results.
  prefs: []
  type: TYPE_NORMAL
