- en: Chapter 5. Microservices Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapters, we explained how to install Docker, Composer, and Lumen,
    which will be necessary for each microservice. In this chapter, we will develop
    some parts of the *Finding secrets* application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will develop some of the more crucial parts, such as the
    routing, middleware, connection with a database, queues, and the communication
    between microservices of the Finding secrets application so that you will be able
    to develop the rest of the application in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of our application will have the following four microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User:** It manages the registration and account actions. It is also responsible
    for storing and managing our secrets wallet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secrets:** It generates random secrets around the world and also allows us
    to get information about each secret.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Location**: It checks the closest secrets and users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Battle:** It manages the battle between users. It also modifies the wallets
    to add and remove secrets after the battle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency management is a methodology that allows you to declare the libraries
    required for your project and makes it easier to install or update them. The most
    well-known tool for PHP is called **Composer**. In previous chapters, we gave
    a little overview about this tool.
  prefs: []
  type: TYPE_NORMAL
- en: For our project, we will need to use a single Composer setup for each microservice.
    When we installed Lumen, Composer did the work for us and created the configuration
    file, but now we will explain how it works in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have Docker installed and we are in the PHP-FPM container we want to
    work on, it is necessary to generate the `composer.json` file. This a configuration
    file for Composer where we define our project and all the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first 6 lines (name, description, keywords, license, and type) of the `composer.json` file
    are used to identify the project. It will be public if you share the project in
    any repository.
  prefs: []
  type: TYPE_NORMAL
- en: The `"require"` section defines the required libraries needed in our project
    and the version for each one. The `"require-dev"` is very similar, but they are
    the libraries that need to be installed on the development machines (for example,
    any test library).
  prefs: []
  type: TYPE_NORMAL
- en: The `"autoload"` and `"autoload-dev"` define the way that our classes will be
    loaded and the folders to be mapped on the project for different uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have this file created, we can execute the following command in our
    machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: At this point, composer will check our settings, and it will download all the
    required libraries, including Lumen.
  prefs: []
  type: TYPE_NORMAL
- en: There are other tools out there, but they aren't used as much and they are less
    flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routing is a mapping between the entry points of your application (requests)
    and a specific class and method in your source that executes your logic. For example,
    you can have defined in your application a mapping between the `/users` route
    and the method `list()` which is inside your `Users` class.  Once you have this
    mapping in place, as soon as your application receives a request for the route
    `/users`, it will execute all the logic you have inside the `list()` method (located
    in the `Users` class). Routing allows the API consumers to interact with your
    application. In microservices, the RESTful convention is the most used and we
    will follow it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP Methods**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GET:** It is used to retrieve information about a specified entity or collection
    of entities. The amount of data does not matter; we will use GET for one or many
    results, and also we can use filters in order to filter the results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**POST:** It is used to enter information in the application. It is also used
    to send new information in order to create new things or send a message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PUT:** It is used to update an entire entity already stored in the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PATCH:** It is used to partially update an entity already stored in the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DELETE:** It is used to remove an entity from the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The routes file in Lumen is located at `app/Http/routes.php`, so we will have
    one routes file for each microservice. For the `User` microservice, we will have
    the following endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the earlier piece of code, we defined our routes for the `User` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: In Lumen, the versioning for the API can be specified on the routes file by
    including `'prefix'`. This framework also allows us to have different API versions
    for the same microservice, so we do not need to modify an existing method to be
    used in a different version.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `''namespace''` defines the same namespace for all the methods included
    in the same group. The following lines define every entry point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For example, the preceding method is included in the group with the prefix `'api/v1'`;
    the verb is GET, and the entry point is `user/{id}`, so it could be retrieved
    executing an HTTP GET call to `http://localhost:8080/api/v1/user/123`. The `UserController@get` parameter
    defines where we need to develop the logic for this call--in this case, it is
    on the controller `UserController` and the method called `get`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Lumen, the standard folder to store all your controllers is `app/Http/Controllers`,
    so you only need to create the `app/Http/Controllers/UserController.php` file
    with your IDE with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defined all the methods we have specified in our `app/Http/routes.php`
    file. For example, we return a simple JSON to test whether each route works fine.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that the main language used in the communication between your microservices
    is JSON, so all our responses need to be in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Lumen, it is very easy to return a JSON response; you only need to use the
    `json()` method of the response instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If the value stored in our `$id` variable is `123`, the preceding sentence
    will return a well-formed JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have everything in place for our `User` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps, you are wondering what is the URI assigned to our `get()` method of
    the `User` microservice in our container environment. It is very easy to find
    it--simply open the `docker-compose.yml` file, and you can find the port mapping
    for the `microservice_user_nginx` container. The port mapping we have set up indicates
    that our localhost 8084 port will redirect the petitions to port 80 of the container.
    In summary, our URI will be `http://localhost:8084/api/v1/get/123`.
  prefs: []
  type: TYPE_NORMAL
- en: Postman
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our application based on microservices will not have a frontend part; the goal
    of the API Rest is to create microservices that can be consumed by different platforms
    (Web, iOS, or Android) just by calling the available methods in the routes file;
    so in order to execute the calls to our microservices, we will use Postman. It
    is a tool that allows you to execute the different calls including the parameters
    you need. Using Postman, it is possible to save the methods to use them in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download or install Postman from [https://www.getpostman.com](https://www.getpostman.com),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Postman](graphics/B06142_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Overview of the Postman tool
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the preceding Postman tool screenshot, it has many features,
    such as saving the requests or setting up different environments; but for now,
    we only need to know the basic functions to execute calls to our application,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the verb--GET, POST, PUT, PATCH, or DELETE. Some frameworks cannot reproduce
    PUT or PATCH calls, so you will need to set the verb POST instead, and include
    a parameter with key `_method` and value PUT or PATCH.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the request URL. It is the desired entry point for our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add more parameters, if necessary--for example, a parameter to filter results.
    For POST calls, the Body button will be enabled so that you can send parameters
    in the body request instead of the URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on SEND to execute the call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The response will appear providing the status code and time in seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we explained in the previous chapters, middleware are very useful in applications
    based on microservices. Let's explain how you can use them using Lumen.
  prefs: []
  type: TYPE_NORMAL
- en: Lumen has a directory to place all the middleware, so we will create a middleware
    on the `User` microservice to check whether the consumer has the provided `API_KEY`
    to communicate with our application.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To identify our consumers, we recommend that you use an `API_KEY`. This practice
    will avoid unwelcome consumers using our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we provided our customer with an `API_KEY` with the value `RSAy430_a3eGR`,
    and it is necessary to send this value in every single request to our application.
    We can use a middleware to check whether this `API_KEY` was provided. Create a
    file called `App\Http\Middleware\ApiKeyMiddleware.php`, and place this piece of
    code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have created our middleware, we have to add it to the application.
    To do this, include the following lines in the `bootstrap/app.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add the middleware to the `routes.php` file. It can be put in different
    places; you can put it in a single request or even in the entire group, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Give it a try on Postman; make an HTTP POST call to `http://localhost:8084/api/v1/user`
    . You will see a message that says `API_KEY invalid`. Now make the same call but
    add a parameter called `API_KEY` with the value `RSAy430_a3eGR`; the request passes
    the middleware and arrives at the function.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a microservice call
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to make a call, let's create a more complex example. We
    will build our battle system. As mentioned in the previous chapters, a battle
    is a fight between two players in order to get secrets from the loser. Our battle
    system will consist of three rounds, and in each round, there will be a dice throw;
    the user that wins the most rounds will be the winner and will get a secret from
    the loser's wallet.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We suggest using some testing development practices (TDD, BDD, or ATDD) as we
    explained before; you can see some examples in the preceding chapter. We will
    not include more tests in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Battle microservice, we can create a function for the battle in the
    `BattleController.php` file; let''s look at a valid structure method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not forget to add the endpoint on the `routes.php` file to link the URI
    to our method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the `duel` method for the Battle microservice will be available;
    give it a try with Postman.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will implement the duel. We need to create a new class for the dice.
    To store a new class, we will create a new folder called `Algorithm` in the root,
    and the file `Dice.php` will include the dice methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Once we have developed the `Dice` class, we will call it from the `BattleController`
    to see who wins a battle. The first thing is to include the `Dice` class on the
    `BattleController.php` file at the top, and then we can create an instance of
    the algorithm we will use for the duels (this is a good practice in order to change
    the duel system in the future; for example, if we want to use a duel based on
    energy points or card games, we would only need to change the `Dice` class for
    the new one).
  prefs: []
  type: TYPE_NORMAL
- en: 'The duel function will return a JSON with the battle results. Please look at
    the new highlighted code included on the `BattleController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Give it a try using Postman; remember that it is an HTTP POST request to the
    URI `http://localhost:8081/api/v1/battle/duel` (note that we set up the port 8081
    for the battle microservice on Docker), and it is necessary to send the parameters
    `userA` and `userB` with the usernames you want. If everything is correct, you
    should get a response similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Request life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The request life cycle is the map of a request until it is returned to the
    consumer as a response. It is interesting to understand this process in order
    to avoid issues during the request. Every framework has its own way of doing the
    request, but all of them are quite similar and follow some basic steps like Lumen
    does:'
  prefs: []
  type: TYPE_NORMAL
- en: Every request is managed by `public/index.php`. It does not have much code,
    it just loads the Composer-generated autoloader definition and creates the instance
    of the application from `bootstrap/app.php`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The request is sent to HTTP Kernel, which defines some necessary things such
    as error handling, logging, application environment, and other necessary tasks
    that should be added before the request is executed. HTTP Kernel also defines
    a list of middleware that the request must pass before retrieving the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the request passes the HTTP Kernel and arrives at the application, it reaches
    the routes and tries to match it with the correct one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It executes the controller and the code that correspond to the route and creates
    and returns a response object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The HTTP headers and the response object content is returned to the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is just a basic example of the request-response workflow; the real process
    is more complex. You should take into account that the HTTP Kernel is like a big
    black box that does things that are not visible to the developer in a first instance,
    so understanding this example is enough for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Communication between microservices with Guzzle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most important things in microservices is the communication between
    them. Most of the time a single microservice doesn't have all the information
    requested by the consumer, so the microservice needs to call to a different microservice
    to get the desired data.
  prefs: []
  type: TYPE_NORMAL
- en: For example, adhering to the last example for the duel between two users, if
    we want to give all the information about the users included in the battle in
    the same call and we don't  have a specific method to get the user information
    in the Battle microservice, we can request the user information from the user
    microservice. To achieve this, we can use the PHP core feature cURL or use an
    external library that wraps cURL, giving an easier interface as `GuzzleHttp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To include `GuzzleHttp` in our project, we only need to add the following line
    in the `composer.json` file of the Battle microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we save the changes, we can enter our PHP-FPM container and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`GuzzleHttp` will be installed and ready to use on the project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get the user information from the `User` microservice, we will build
    a method that will give the information to the `Battle` microservice. For now,
    we will store the user information in a database, so we have an array to store
    it. In the `app/Http/Controllers/UserController.php` of the `User` microservice,
    we will add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test this new method on Postman by doing a GET call to `http://localhost:8084/api/v1/user/2`; you
    should get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we know that the method to get the user information is working, we will call
    it from the `Battle` microservice. For security reasons, each container on Docker
    is isolated from the other containers, unless you specify that you want a connection
    in the links section of the `docker-composer.yml` file. To do so, use the following
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop Docker containers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit `docker-compose.yml` file by adding the following line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Start Docker containers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'From now on, the `Battle` microservice should be able to see the `User` microservice,
    so let''s call the `User` microservice in order to get the user information from
    the Battle microservice. To do this, we need to include the `GuzzleHttp\Client`
    in the `BattleController.php` file and create a Guzzle instance in the duel function
    to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have finished the modifications, we can test it on Postman again by
    executing the same call as before--`http://localhost:8081/api/v1/battle/duel`
    (remember to make an HTTP POST call and send the parameters `userA` with value
    1 and `userB` with value 2). The response should be similar to this (note that
    this time the user information is coming from the `User` microservice, although
    we are calling the `Battle` microservice):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Database operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we explained that you can have single or multiple
    databases for your application. This is one of the advantages of microservices;
    you can scale a single microservice when you realize that it is getting a big
    load by dividing the database into a single database for a specific microservice.
  prefs: []
  type: TYPE_NORMAL
- en: For our example, we will create a single database for the secrets microservice.
    For storage software, we decided to use **Percona** (a MySQL fork), but feel free
    to use any database you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a database container in Docker is very easy. We only need to edit
    our `docker-compose.yml` file, and change the links section of the `microservice_secret_fpm`
    service with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the changes we did, we are telling Docker that now our `microservice_secret_fpm`
    can communicate with our `microservice_secret_database` container. Let’s create
    our database container. To do this, we only need to define the service in the
    `docker-compose.yml` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we tell the application where Docker can find the `Dockerfile`
    where we set up some environment variables and also that we are mapping the port
    6666 of our machine to the default Percona port on the container. One important
    thing that you need to know about Docker and the Percona official image is that
    using some special environment variables, the container will create a database
    and some users for you.
  prefs: []
  type: TYPE_NORMAL
- en: You can find all the files you need in our Docker GitHub repository under the `chapter-05-basic-database` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our container ready, it's time to set up our database. Lumen
    provides us with a tool to make migrations and manage them, so we can know if
    we have our database up to date if we are working with a team. A **migration**
    is a script to create and roll back operations in our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a migration in Lumen, first you need to enter your secrets PHP-FPM container.
    To do this, you only need to open your terminal and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The above command creates an interactive terminal in the container and runs
    the bash console so that you can start typing your commands. Please ensure that
    you are on the project root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are on the project root, you need to create a migration; this can
    be done with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The above command will create an empty migration template in the `database/migrations/2016_11_09_200645_create_secrets_table.php`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding piece of code is the sample generated by the artisan command.
    As you can see, there are two methods in the migration script. Everything you
    write inside the `up()` method will be used when a migration is executed. In the
    case of doing a rollback, everything inside the `down()` method will be used to
    undo your changes. Let''s fill our migration script with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding sample is very easy to understand. In the `up()` method, we are
    creating a secrets table with some columns. It's a fast and easy way to create
    a table, which is similar to using a `CREATE TABLE` SQL statement. Our `down()`
    method will revert all our changes, and in our case, the way of reverting the
    changes is by removing the secrets table from our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you are ready to execute the migration from your terminal with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The migrate command will run the `up()` method of our migration script and create
    our secrets table.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to know the status of the execution of your migration scripts,
    you can perform a `php artisan migrate:status`, and the output will tell you the
    current status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you can connect with your favorite database client to the 6666
    port of your machine; our database will be there, ready to be used in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine now that you need to do a rollback of the changes done to your database;
    it is very easy to do it in Lumen, you only need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have created the table, we can populate our table by doing seed on
    Lumen or manually. Our recommendation is that you use seeds, as this is an easy
    way to keep track of any changes. To populate our new table, we only need to create
    a new file `database/seeds/SecretsTableSeeder.php` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding class, we defined a `run()` method, which will be executed
    every time we want to fill our database with some data. In our example, we added
    the different secrets we had hardcoded in our application. Now that we have our
    `SecretsTableSeeder` class ready, we need to edit the `database/seeds/DatabaseSeeder.php`
    to add a call to our custom seeder. If you change the `run()` method to match
    the following piece of code, your microservice will have some data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have everything in place, it''s time to execute the seeder, so go
    to the secrets PHP-FPM container again and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If `artisan` throws an error telling you that it can't find the table, it  is
    due to the composer autoloading system. Executing a `composer dump-autoload` will
    fix your problem, and you can run the `artisan` command again without any problems.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you will have your secrets table created and populated with some
    example records.
  prefs: []
  type: TYPE_NORMAL
- en: Working with databases in Lumen is out of the box and uses Eloquent as an ORM.
  prefs: []
  type: TYPE_NORMAL
- en: An **Object-Relational mapping** (**ORM**) is a programming model that transforms
    the database tables into entities that make the developer's work easier, allowing
    them to make basic queries faster and use less code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We recommend using an ORM in order to avoid syntax problems if you want to
    migrate the database to a different system in the future. As you know, the SQL
    languages have few differences among them--for example, the way to get a determinate
    number of rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: So, if you use an ORM, you do not need to remember the SQL syntax, because it
    abstracts the developer from the database operations and the developer only needs
    to think about the development.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are advantages of the ORM:'
  prefs: []
  type: TYPE_NORMAL
- en: The security in the data access layer against attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy and fast to work with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not matter what database you use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an ORM is recommended when we are developing a public API in order to
    avoid security problems and make the queries easier and clearer for the rest of
    the team.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up your Lumen project to work with Eloquent, you only need to open the
    `bootstrap/app.php` file and uncomment the following line (around line 28):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, you will need to set up the database parameters located in the `.env.example`
    file, you can find it in the root folder of each microservice. Once you finish
    editing the file, you need to rename it `.env` (removing `.example` from the file
    name):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are using the database, user, and password we set up in Docker
    in the beginning of the Database operations section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to work with our database, we need to create our models, and since
    we have a `finding_secrets` database, it makes sense to have a secret model in
    the `app/Models/Secret.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The preceding piece of code is very easy to understand; we only had to define
    the relationship between our model class and the database `$table` and the list
    of `$fillable` fields. This is the minimum you need for your model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fractal is a library that provides a presentation and transformation layer
    for our RESTful API. Using this library will keep our responses consistent, nice,
    and clean. To install this library, we only need to open the `composer.json` of
    our PHP-FPM containers, add `"league/fractal": "^0.14.0"` to the required list
    of elements and perform a `composer update`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another way of installing fractal is by running the following command on your
    PHP-FMP terminal: `composer require league/fractal` . Note that this command will
    use the latest version and might not work with our examples.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With fractal installed, now it''s time to define our secret transformer. You
    can think about the transformers as an easy way of having the transformation from
    your model to a consistent response in one place. Create the `app/Transformers/SecretTransformer.php`
    file with your IDE  with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code, we are specifying the transformation
    of the secrets model, and because we want all the locations grouped, we added
    all the location information of the secret inside the location key. In the future,
    if you need to add new fields or modify the structure, now that everything is
    in one place, it will make your life as a developer easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example purpose, we will modify the index method of our secrets controller
    to return a response from the database using fractal. Open your `app/Http/Controllers/SecretController.php`
    and insert the following uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you need to change the `index()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Firstly, we added some object instances that we will need to the method signature,
    and thanks to the dependency injection built in Lumen, we don''t need to do any
    more work. They will be ready to use inside our method. The definition of our
    method does the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Gets all the secret records from the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a collection of secrets using our transformer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fractal library creates a data array from our collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our controller returns our transformed collection as JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you give it a try with Postman, the response will be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: All our records are now returned from the database in a consistent way, all
    with the same structure inside our `"data"` response key.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following section, we will explain how to validate the input data in
    our microservice and how to manage the possible errors. It is important to filter
    the request we are receiving--not only to notify the consumer that the request
    was not valid, but also to avoid security problems or parameters that we are not
    expecting.
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lumen has a fantastic validation system, so we do not need to install anything
    to validate our data. Note that the following validation rules can be placed on
    the `routes.php` or on the controller inside every function. We will use it inside
    the function to be clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use our database for the validation system, we need to configure it. This
    is very simple; we just need to create a `config/database.php` file (and the folder)
    in our root with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you have to add the database line in the `bootstrap/app.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have done this, the Lumen validation system is ready. So, let''s write
    the rules to validate the POST method to create a new secret on the `Secrets`
    microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we confirm that the parameters should pass the rules.
    The field `'name'` is required; it is a string, and also it should be unique in
    the `secrets` table. The field's `'latitude'` and `'longitude'` are numeric and
    required too. Also, the `'location_name'` field is required and it is a string.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the Lumen documentation ([https://lumen.laravel.com/docs](https://lumen.laravel.com/docs)),
    you can check out all the available options to validate your inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try it out in your Postman; create a POST request with the following
    `application/json` parameters to check a failed insertion (note that you can also
    send it like form-data key values):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding request will try to validate a new secret with the same name
    as other previous records. From our validation rules, we are not allowing the
    consumers to create new secrets with the same name, so our microservice will respond
    with a `422` error with the following body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note that the status codes (or error codes) are very important to inform your
    consumers what happened with their requests; if everything is fine, it should
    respond with a `200` status code. Lumen returns a `200` status code by default.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 11](ch11.html "Chapter 11. Best Practices and Conventions"), *Best
    Practices and Conventions*, we will see a full list of all the available codes
    that you can use in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the validation rules pass, we should save the data on the database. This
    is very simple in Lumen, just do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: After this, we will have our new record available in the database. Lumen provides
    other methods to create for other tasks such as fill, update, or delete.
  prefs: []
  type: TYPE_NORMAL
- en: Manage exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is necessary to know that we have to manage the possible errors that happen
    in our application. To do this, Lumen provides us with a list of exceptions that
    can be used.
  prefs: []
  type: TYPE_NORMAL
- en: So, now we will try to get an exception when trying to call another microservice.
    To do this, we will call the secret microservice from the user microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please remember that for security reasons if you didn''t link a container with
    another container, they can''t see each other. Edit your `docker-compose.yml`
    and add the link from the `microservice_user_fpm` to the `microservice_secret_nginx`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you should start your containers again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Also, remember that we need to install `GuzzleHttp` as we did before on the
    `Battle` microservice and on the `User` microservice in order to call the `Secret`
    microservice.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a new function on the `User` microservice to show the secrets
    kept in a `user` wallet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this to `app/Http/routes.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will create the method to get a secret from the `user` wallet--for
    example, look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We are calling the `Secret` microservice, but we will modify the URI in order
    to get a `ConnectException`, so please modify it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Give it a try on Postman; you will receive a `ConnectException` error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, set the URI correctly again and put some wrong code on the secret microservice
    side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will return an error **500** for the secret microservice;
    but we are calling it from the `User` microservice, so now we will receive a `ServerException`
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are hundreds of kinds of errors that you can manage in your microservice
    by catching them. In Lumen, all the exceptions are handled by the `Handler` class
    (located at `app/Exceptions/Handler.php`). This class has two defined methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`report()`: This allows us to send our exceptions to external services--for
    example, a centralized logging system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`render()`: This transforms our exception into an HTTP response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will be updating the `render()` method to return custom error messages and
    error codes. Imagine that we want to catch a Guzzle `ConnectException` and return
    a more friendly and easy-to-manage error. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are detecting the Guzzle `ConnectException` and giving a custom error
    message and code. Using this strategy helps us to know what is failing and allows
    us to act according to the error we are dealing with. For example, we can assign
    the code `123` to all our connection errors; so, when we detect this issue, we
    can avoid a cascade failure in other services or notify the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Async and queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In microservices, the queues are one of the most important things that help
    increase the performance and reduce the execution time.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if you have to send an e-mail to a customer when the customer
    finishes the registration process of your application, the application does not
    need to send it at that moment; it can be put in a queue to be sent a few seconds
    later when the server is not as busy. Also, it is async because the customer does
    not need to wait for the e-mail. The application will display the message *Registration
    finished* and the e-mail will be put in the queue and processed at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is when you need to do very heavy workloads, so you can have
    a dedicated machine with better hardware to do the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most well-known in-memory data structure stores is **Redis**. You
    can use it as a database, a cache layer, as a message broker, or even as a queue
    storage. One of the key points of Redis is its support for different structure
    types, such as strings, hashes, lists, and sorted sets among others. This software
    was designed to be easy to manage and to have a high performance and, for these
    reasons, it is a de facto standard in the Web industry.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main uses of Redis is as a cache storage. You can store your data
    forever or add an expiration time,  without having to worry about how and when
    you need to remove the data; Redis will do it for you. Due to the easy use, great
    support and libraries available, Redis fits any project of any scale.
  prefs: []
  type: TYPE_NORMAL
- en: We will build an example on the `User` microservice to send e-mails using a
    queue built on top of Redis.
  prefs: []
  type: TYPE_NORMAL
- en: Lumen provides us with a queue system using the database; but there are other
    options available using external services. In our example, we will use Redis,
    so let's see the steps to install it on Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `docker-compose.yml` and add the following container description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'You also need to update the links section of the `microservice_user_fpm` container
    to match the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding pieces of code, we defined a new container for Redis, and
    we linked it to the `microservice_user_fpm` container. Now open the `microservices/user/redis/Dockerfile`
    file and add the following code to have the latest Redis version available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'To use Redis in our Lumen project, we need to install a few dependencies through
    composer. So, open your `composer.json` and add the following lines to the required
    section and do a composer update inside the user PHP-FPM container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'For email support, you only need to add the following line to the require section
    of your composer.json file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Redis is installed, we need to set up the environment. Firstly, we need
    to add the following lines on the `.env` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to add the Redis configuration on the `config/database.php` file;
    if you have any other databases added (for example, MySQL), put this after that,
    but inside the return array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Also, it is necessary to copy the `vendor/laravel/lumen-framework/config/queue.php`
    file to `config/queue.php`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, do not forget to register everything on the `bootstrap/app.php` file
    and add the following lines, so our application is able to read the configuration
    we just set up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: So now, we will explain how to build a queue in our `User` microservice. Imagine
    that in the application, when new users are created, we want to give them the
    first secret as a gift; so after the user creation, we will call the secret microservice
    in order to get the first secret for the user. This is not a priority, so that
    is the reason why we will use a queue to do this task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file on `app/Jobs/GiftJob.php` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: You can modify the class construction to pass data to your job, for example,
    an object instance with all the user information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to instance the job from our `app/Http/Controllers/UserController.php`
    controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the queue job is done, we have to start the queue worker in the background.
    The following code will do the work for you, and it will keep running until the
    thread dies, you can add a supervisor to ensure that the queue continues working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'You can give this a try on Postman by calling `http://localhost:8084/api/v1/user`.
    Once you call this, Lumen will put the work on Redis, and it will be available
    for the queue worker. Once the worker gets and processes the task from Redis,
    you will see the following next message in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Lumen provides us with more possibilities for the queues. For example, you can
    set priorities for the queue, specify a time-out for a job or even set a delay
    for the task. You can find this information in the Lumen documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many times consumers request the same things, and the application returns the
    same information. In this scenario, caching is the solution to avoid constantly
    processing the same request and returning the required data faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Caching is used for data that does not change frequently in order to have a
    precalculated response without processing the request. The workflow is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first time that the consumer requests some information, the application
    processes the request and gets the required data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It saves the required data for that request in the cache with an expiration
    time that we define.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It returns the data to the consumer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next time that a consumer requests something you need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether the request is in the application cache and it has not expired.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the data located in the cache.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, in our example, we will use caching in the location microservice in order
    to avoid requesting the closest secrets multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we need to use a cache layer for in our application is
    a container with Redis (you can find other cache software out there, but we decided
    to use Redis as it is very easy to install and use). Open the `docker-compose.yml`
    file and add the new container definition, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we add the container, you need to update the links section for the `microservice_location_fpm`
    definition to connect to our new Redis container as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, our `docker/microservices/location/redis/Dockerfile` file will
    only contain the following (feel free to add more things to the container if you
    want):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Do not forget to execute `docker-compose stop` to successfully kill all the
    containers and start them again with our changes with a `docker-compose up -d`.
    You can check whether the new container is running by executing `docker ps` in
    your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now is time to make some changes in the source of our location microservice
    to use our new cache layer. The first change we need to make is on the `composer.json`;
    add the following required libraries to the `"require"` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Once you make the changes to the `composer.json` file, remember to do a composer
    update to get the libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the location microservice `.env` file to add the Redis setup, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Since our environment variables are now set up, we need to create the `config/database.php`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we defined how to connect to our Redis container.
  prefs: []
  type: TYPE_NORMAL
- en: Lumen comes without the cache configuration, so you can copy the `vendor/laravel/lumen-framework/config/cache.php`
    file into `config/cache.php`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to make some small adjustments to our `bootstrap/app.php`--uncomment
    `$app->withFacades();` and add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We will change our `getClosestSecrets()` method to use cache instead of calculating
    the closest secrets every time. Open the `app/Http/Controllers/LocationController.php`
    file and add the required use for cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we changed the implementation of the method by adding
    the layer cache; so instead of always calculating the closest points, we first
    check on our cache with `remember()`. If nothing is returned from the cache, we
    make the calculation and store the result.
  prefs: []
  type: TYPE_NORMAL
- en: Another option for saving data in Lumen cache is to use `Cache::put('key', 'value',
    $expirationTime);` where the `$expirationTime` can be the time in minutes (integer)
    or a date object.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The key is defined by you, so a good practice is generating a key that you can
    remember in order to regenerate in the future. In our example, we defined the
    key using `L` (for location) and then the `latitude` and `longitude`. However,
    if you are going to save an ID, it should be included as part of the key.
  prefs: []
  type: TYPE_NORMAL
- en: Working with our cache layer is easy in Lumen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain elements from the cache, you can use `"get"`. It allows two parameters--the
    first one is to specify the key you want (and is required), and the second one
    is the value to use if the key is not stored in cache (and obviously is optional):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: A similar method to store data available is `Cache::forever($cacheKey, $cacheValue);`
    this call will store the `$cacheValue` identified by `$cacheKey` in our cache
    layer, forever, until you delete or update it.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't specify the expiration time for your stored elements, it is important
    to know how to remove them. In Lumen, you can do it with `Cache::forget($cacheKey);`
    if you know the `$cacheKey` assigned to an element. In the case of needing to
    remove all the elements stored in the cache, we can do this with a simple `Cache::flush();`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned how to develop the different parts of an application
    based on microservices. Now, you have the required knowledge to deal with database
    storage, cache, communication between microservices, queues, and the request workflow
    from the point of entry to the application (routes) and the validation of the
    data until the time it is given to the consumer. In the next chapter, you will
    learn how to monitor your application in order to avoid and fix issues that happen during
    the application execution process.
  prefs: []
  type: TYPE_NORMAL
