- en: Building a Meme Creator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the chapter name suggests, we are going to build a fun application in this
    chapter--a **Meme Creator**. Everyone loves memes! But that''s not the only reason
    we are building a Meme Creator. We are going to explore a few new things that
    are going to change the way you build web applications. Let''s see what''s in
    store:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to **CSS3 flexbox**. A new way to create responsive layouts on
    the web.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the **Webpack** module bundler to convert all your dependencies and code
    to static assets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **HTML5 canvas** for drawing graphics on the fly with JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a solid production build that is fully optimized, minified, and versioned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Previously, you successfully built a ToDo List app while learning the new ES6
    features of JavaScript. At the end of the chapter, you learned how to use Node
    and npm for web development. We have covered only the basics. We are yet to realize
    the full potential of using npm in our project. That's why, in this project, we
    are going to experiment with a powerful module bundler called Webpack. Before
    we begin with our experiment to build a fully automated development environment,
    let's set a few things up.
  prefs: []
  type: TYPE_NORMAL
- en: Initial project setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new folder for our Meme Creator application. Open up the folder in
    VSCode or any other text editor you are using for this project. Navigate to the
    folder in your terminal and run **`npm init`**. Just as we did in the previous
    chapter, fill in all the details asked for in the terminal, then hit *Enter* on
    Windows or *return* on Mac, and you will have your `package.json` file in the
    project root.
  prefs: []
  type: TYPE_NORMAL
- en: From the code files you downloaded for this book, open up the starter files
    folder for Chapter 2\. You will see an `index.html` file. Copy and paste it into
    your new project folder. That's all for the starter files provided with this chapter,
    because there is not going to be a default CSS file. We are going to build the
    UI from scratch!
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the files and folders we are going to use in this chapter. The folder
    structure should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, leave the JS files empty. We are going to work on the `styles.css`
    file. Open up `index.html` in your browser (try using the `http-server` package
    we installed globally in the previous chapter). You should see an awkward looking
    page with some default Bootstrap styles applied using Bootstrap''s classes. We
    are going to turn that page into a Meme Creator app, which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This web app is also going to be responsive. So, on your mobile devices, it
    should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: That blank box is going to be our canvas, which will preview the memes created
    with this app. Now that you have an idea of how the application will look, we'll
    start working on our `styles.css` file.
  prefs: []
  type: TYPE_NORMAL
- en: Responsive designing with flexbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you look into the `index.html` file of our previous chapter, you will see
    that there are classes, such as `col-md-2`, `col-xs-2`, `col-lg-2`, `col-sm-2`,
    and so on. They are Bootstrap's grid classes. The previous chapter's layout was
    designed using the Bootstrap grid system. The system divides the page into rows
    and 12 columns and allocates a specific number of columns to each `div` in a row
    depending on the screen size.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four different screen sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: Desktop (md)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tablets (sm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Phones (xs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large desktops (lg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, we are not going to use Bootstrap grids in this chapter. We are going
    to be using a new layout mode introduced in CSS3 called the flexbox. Flexbox or
    flexible box, as it sounds, provides a box model for creating layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Flexbox is a new layout system, which is actively being implemented by the browser
    vendors. Support is almost complete; it's time to adopt this standard in projects.
    A few problems still exist, such as IE 11 only having partial flexbox support
    and older versions of IE do not support flexbox. Visit [https://caniuse.com/](https://caniuse.com/)
    to check details on browser support for flexbox.
  prefs: []
  type: TYPE_NORMAL
- en: Flexbox - a quick introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the flexbox layout system, you declare a parent `div` with a CSS property
    `display: flex`, which allows you to control how you want to position its children
    elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you declare `display: flex`, the `div` element becomes a flexbox with
    two axes. The **Main axis** along with the content are placed with the **Cross
    axis**, which is perpendicular to the Main axis. You can use the following CSS
    properties in the parent flexbox to change the position of child elements (*flex
    items*):'
  prefs: []
  type: TYPE_NORMAL
- en: '**flex-direction**: Create the Main axis either horizontally (row) or vertically
    (column)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**justify-content**: Specify how flex items are placed on the Main axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**align-items**: Specify how flex items are placed on the Cross axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**flex-wrap**: Specify how to handle flex items when there is not enough space
    to display them in a single row'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also apply some flex properties to flex items, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**align-self**: Specify how to place the specific flex item on the Cross axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**flex**: The relative size of the flex item with respect to other flex items
    (if you have two items with `flex: 2` and `flex: 1` respectively, the first one
    will be twice the size of the second one)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All those should sound confusing, but the easiest way to understand flexbox
    is to use online flexbox playgrounds. Google some flexbox playgrounds available
    online to experience how different properties of flexbox work. One such playground
    can be found at [http://flexboxplayground.catchmyfame.com/](http://flexboxplayground.catchmyfame.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn flexbox, refer to the following pages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mozilla Developer Network: [https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'W3Schools: [https://www.w3schools.com/css/css3_flexbox.asp](https://www.w3schools.com/css/css3_flexbox.asp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Flexbox Froggy (a game for learning flexbox): [https://flexboxfroggy.com/](https://flexboxfroggy.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the time of writing this book, the latest version of Safari browser 10.1
    is having problems with the **flex-wrap** property, which is fixed in nightly
    builds. If you are using the same or an earlier version of the Safari browser,
    I'd recommend using Chrome for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the Meme Creator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our `index.html` file, our `<body>` element is divided into a navigation
    bar and `div` containing the contents of the website. The `div.body` element is
    further divided into `div.canvas-area` and `div.input-area`.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first part of our document's body is the navigation bar `<nav>`. The navigation
    bar usually contains the primary set of links for navigation in a website. Since
    we are building only a single page in this chapter, we can leave the navbar with
    only our page title.
  prefs: []
  type: TYPE_NORMAL
- en: The navigation bar is styled using Bootstrap. The class `.navbar` styles the
    respective element as the primary navigation bar of the page. The `.navbar-inverse`
    class adds a dark color to the navigation bar and the `.navbar-fixed-top` class
    attaches the navigation bar to the top of the screen using a fixed position. The
    contents of the navigation bar are wrapped inside a Bootstrap container (`div.container`).
    The page title is written inside `div.navbar-header` as an anchor tag with the
    class `.navbar-brand`, which instructs Bootstrap that this is the brand name/title
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Bootstrap navigation bar is highly customizable. To learn more about this
    topic, refer to W3Schools'' Bootstrap tutorial: [https://www.w3schools.com/bootstrap/](https://www.w3schools.com/bootstrap/)
    or Bootstrap''s official documentation: [http://getbootstrap.com/getting-started/](http://getbootstrap.com/getting-started/).'
  prefs: []
  type: TYPE_NORMAL
- en: Content area
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The navigation bar occupies a fixed position on top of the screen. Hence, it
    will overlap with the page''s content. Open up `styles.css` and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will add padding to the entire body section so that the navbar will not
    overlap with our content. Now, we need to convert our primary content area `div.body`
    to a flexbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will convert our `div.body` element into a flexbox that organizes its contents
    as a row (`flex-direction`) and wraps the contents to new rows if space is not
    available for entire rows (`flex-wrap`). Also, the contents will be surrounded
    by equal margin spaces horizontally (`justify-content`).
  prefs: []
  type: TYPE_NORMAL
- en: Guess what? We are done! Our primary layout is already complete! Switch to Chrome,
    hard-reload, and see that the contents are now aligned horizontally. Open up the
    responsive design mode; for mobile devices you will see that the row is automatically
    wrapped into two rows to display the content. Without flexbox, this would have
    taken thrice the amount of code to achieve the same layout. Flexbox greatly simplifies
    the layout process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our primary layout is complete, let''s add some styles to individual
    elements, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Making `.canvas-area` twice the size of the `.input-area`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a black border to the canvas element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Center-aligning the canvas and the form inputs in their respective areas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, we need to add a margin to both `.canvas-area` and `.input-area` so that
    there will be space between them when the row is wrapped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To achieve these styles, add the following CSS to your `styles.css` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The canvas area is still quite small, but we'll handle its size from our JavaScript
    code. So, now, we don't need to worry about the size of the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are almost done with our styles, except that the form inputs are now in
    different sizes. This happens because Bootstrap''s `.form-input` styles tell the
    respective `div` to occupy the entire width of its parent `div`. However, when
    we add `align-items: center` in our style, we are telling the parent `div` to
    assign a limited width so that the contents are not overlapped and are then centered
    inside the flexbox. So, the width of each element now differs based on its contents.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this problem, we simply need to specify a fixed width to the `.form-input`
    class. Also, let''s add some extra top margin to the download button. Add the
    following lines at the end of your `styles.css` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now we are done building the UI for our Meme Creator using flexbox. It's time
    to move on to the most important topic in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Due to its ease of use and a huge amount of features, the flexbox layout system
    is also being adopted in mobile application development. React Native uses flexbox
    to create a UI for Android and iOS apps. Facebook has also released open source
    libraries, such as `yoga` and `litho`, to use flexbox in native Android and iOS
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack module bundler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's finally time to set up our fully-featured development environment. You'll
    probably be wondering what Webpack is and what's it got to do with a development
    environment. Or perhaps, you are familiar with tools such as gulp or grunt and
    are wondering how Webpack is different from them.
  prefs: []
  type: TYPE_NORMAL
- en: If you have used gulp or grunt before, they are task runners. They execute a
    specific set of tasks to compile, transform, and minify your code. There is also
    a tool called **Browserify**, which lets you use `require()` in browsers. Usually,
    a development environment with gulp/grunt involves executing various commands
    using different sets of tools, such as Babel, Browserify, and so on, in a specific
    order to generate our desired output code. But Webpack is different. Unlike task
    runners, Webpack doesn't run a set of commands to build the code. Instead, it
    acts as a module bundler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Webpack goes through your JavaScript code and looks for `import`, `require`,
    and so on to find files dependent on it. Then, it loads the files into a dependency
    graph and, in turn, finds those files, dependencies. This process goes on until
    there are no more dependencies. Finally, it bundles the dependency files together
    with the initial file into a single file using the dependency graph it built.
    This functionality is very useful in modern JavaScript development, where everything
    is written as a module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00011.jpeg)Webpack is being adopted as the bundler of popular
    modern frameworks, such as React, Angular, and Vue. It is also a good skill to
    have on your resume.'
  prefs: []
  type: TYPE_NORMAL
- en: Modules in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember the ToDo List app we built in the previous chapter? We used npm to
    install Babel to transform our ES6 code to ES5\. Navigate to the `ToDo List` folder
    and open up the `node_modules` folder. You will find a huge list of folders containing
    various packages! Even though you installed only four packages, npm has traced
    out all the dependencies of the required packages and installed them along with
    the actual packages.
  prefs: []
  type: TYPE_NORMAL
- en: We only used those packages as dev-dependencies to compile our code. So, we
    didn't know how those packages are built. Those packages are built as modules.
    A module is an independent piece of reusable code that returns a value. The value
    can be an object, function, `string`, `int`, and so on. Modules are widely used
    for building large applications. Node.js comes with support for exporting and
    importing JavaScript modules which are currently unavailable in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can create a simple module in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the earlier mentioned function that returns a sum of two numbers.
    We are going to convert that function into a module. Create a new file `sum.js`
    and write the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all! You just need to add an `export` keyboard before the variable
    or object you would like to export and it will become a module which can be used
    in a different file. Imagine you have a file called `add.js`, where you need to
    find the sum of two numbers. You can import the `sum` module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can ignore the extension `.js` if you are importing a JavaScript file and
    use `import { sum } from ''./sum''`. You can also use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, import it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`module.exports` and the `require` keyword has been used by Node.js for importing
    and exporting JavaScript modules even since before ES6 was introduced. However,
    ES6 has a new module syntax using the keywords `import` and `export`. Webpack
    supports all types of imports and exports. For our project, we''ll stick with
    ES6 modules.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following file `sides.js`, which contains the number of sides
    of geometrical figures in more than one module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To import all of them into our file, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all the exported variables/objects from the `sides.js` file will be accessible
    inside the `sides` object. To get the value of `TRIANGLE`, just use `sides.LINE`.
    Also, note that `TRIANGLE` is marked default. A `default` export is useful when
    there are multiple modules in the same file. Type in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `side` will contain the value of the default export `TRIANGLE`. So, now
    `side = 3`. To import other modules along with the default module, you can use
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you want to import a module that is present inside the `node_modules`
    folder, you can ignore the relative file path (`./` part) completely and just
    type `import jquery from 'jquery';`. Node.js or Webpack will automatically find
    the nearest `node_modules` folder from the file's parent directories and automatically
    search for the required package. Just make sure you have installed the package
    using `npm install`.
  prefs: []
  type: TYPE_NORMAL
- en: That pretty much covers the basics of using modules in JavaScript. Now it's
    time to learn about the role of Webpack in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Bundling modules in Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start using Webpack, let''s first write some JavaScript code. Open up your
    `memes.js` file and `general.js` file. Write the following code in both files,
    which simply prints the respective filenames in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Usually, while building multiple page web applications that have a large number
    of HTML files, it's common to have a single JavaScript file that has code that
    requires being run on all the HTML files. We are going to use the `general.js`
    file for this purpose. Even though our Meme Creator has a single HTML file, we'll
    use the `general.js` file to include some common code and include the code for
    Meme Creator in the `memes.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why don''t we try importing the `general.js` file inside our `memes.js` file?
    Since `general.js` is not exporting any modules, simply type in the following
    code in your `memes.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Include a `script` tag with reference to `memes.js` file at the end of the
    `<body>` element in your `index.html` file and see the result in Chrome. If all
    goes well, you should see an error in Chrome''s console saying: Unexpected token
    import. This means that something didn''t go well for Chrome. Yup! Chrome doesn''t
    know how to use the `import` keyword. To use `import`, we need Webpack to bundle
    both the `general.js` and `meme.js` file together and serve it as a single file
    to Chrome.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install Webpack as a dev dependency for our project. Run the following
    command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Webpack is now installed as a dev dependency to our project. Webpack is also
    a command-line tool similar to Babel. To run Webpack, we need to use `npm` scripts.
    In your `package.json` file, below the test script, create the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the following command in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A new `memes.js` file will be created under the `dist/js/` directory. This
    file contains both the `general.js` and `memes.js` files bundled together. Open
    up the new JavaScript code in VSCode; you should see a large amount of code. No
    need to panic at this stage; that is the code used by Webpack to manage the scopes
    and properties of the bundled files. It''s something we don''t have to worry about
    at this point. If you scroll to the end of the file, you will see the `console.log`
    statements that we had written in both of our original files. Edit your script
    tag in `index.html` to include the new file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, reload the page in Chrome and you should see that the console statements
    from both the files are executed inside the `memes.js` file. We have successfully
    imported a JavaScript file inside our code. In our previous project, we set up
    the development environment so that the code will be compiled and served automatically
    whenever a change is made in the source file. To do ES6 to ES5 compilation and
    other tasks, we need to install a lot of packages and must give a lot of instructions
    to Webpack. For this purpose, create `webpack.config.js` in your project root
    folder and write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove all the options passed to Webpack in `package.json`. Now, your script
    inside `package.json` should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we haven''t passed any arguments to Webpack, it will look for the `webpack.config.js`
    file inside the directory from which it was executed. It will now read the configuration
    from the file we just created. The first line in our config file is to import
    Webpack using `require(''webpack'')`. We are still using Node.js to execute our
    code, so we should use `require` in our Webpack config file. We just need to export
    our configuration in this file as a JSON object. In the `module.exports` object,
    Here''s what each property is used for:'
  prefs: []
  type: TYPE_NORMAL
- en: '`context`: Is used to specify the absolute path from which the path of files
    in the entry section needs to be resolved. Here, `__dirname` is a constant that
    will automatically include the absolute path of the current directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entry`: Is used to specify all the files that need to be bundled using Webpack.
    It accepts string, array, and a JSON object. If you need Webpack to bundle a single
    entry file, just specify the file''s path as a string. Otherwise, use array or
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our case, we specify input files as objects in the form of `[name]: [path_of_the_file]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This [name] will be used in naming the output bundle of each file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output`: In the output, we need to specify the absolute path of the output
    directory, `dist` in our case, and the filename, which is `[name]`, we specified
    in the entry section, followed by the file-extension `[name].js`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run `npm run webpack` in the terminal. You should see two new files created
    in the `dist` directory: `general.js` and `memes.js`, which contain the bundled
    code from each of their respective source files. The `memes.js` file will include
    the code from the `general.js` file, so it''s enough to include only the `memes.js`
    file in your HTML.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have written the configuration for bundling our code, we'll use
    this configuration file to transform the ES6 syntax to ES5\. In Webpack, transformations
    are applied when the file is imported. To apply transformations, we need to use
    loaders.
  prefs: []
  type: TYPE_NORMAL
- en: Loaders in Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loaders are used for applying transformations to files before importing and
    bundling them. In Webpack, using different third-party loaders, we can transform
    any file and import it into our code. This goes for files written in other languages,
    such as TypeScript, Dart, and so on. We can even import CSS and images into our
    JS code. First, we'll use loaders to transform ES6 into ES5.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `memes.js` file, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple class using ES6 that has a `console.log` statement inside
    the constructor. We will use Webpack and `babel-loader` to transform this ES6
    code to ES5 form. To do so, install the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In your `webpack.config.js` file, add the following code below the output property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is how we should add a loader in Webpack. We need to create an array of
    rules inside the module section. The rule contains an array of configuration objects
    for the loaders. In our configuration, it will test the file to see whether it
    matches the regular expression `.js$`, that is, check whether the file is a JavaScript
    file using its extension. We have excluded the `node_modules` directory so that
    only our code will be evaluated for transformation.
  prefs: []
  type: TYPE_NORMAL
- en: If the imported file is a JavaScript file, Webpack will use `babel-loader` with
    the provided options. Here, in `options`, we instruct Babel to use `env` and `es2015`
    presets. The `es2015` preset will transpile the ES6 code into the ES5 format.
  prefs: []
  type: TYPE_NORMAL
- en: '`env` preset is more special. It is used for transpiling any ES version of
    javascript to the version supported by a specific environment (such as specific
    versions of Chrome and Firefox). If no configuration is provided, as in our earlier
    mentioned code, then it will make the JavaScript code (even ES8) work in almost
    all environments. More information on this preset can be found at [https://github.com/babel/babel-preset-env](https://github.com/babel/babel-preset-env).'
  prefs: []
  type: TYPE_NORMAL
- en: Since we are only going to use ES6 in this book, the `es2015` preset is enough
    for all the projects. However, if you want to learn ES7 and beyond in the future,
    do learn the working of the `env` preset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, let''s bundle our CSS code using Webpack. Bundling CSS code with
    Webpack has many advantages. Some of them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use only the required CSS code for each web page by importing it in respective
    JavaScript files. This will lead to easier and better dependency management and
    reduced file sizes per page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minification of CSS files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically add vendor-specific prefixes easily using autoprefixer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily compile stylesheets written using Sass, Less, Stylus, and so on to normal
    CSS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are even more advantages as to why you need to bundle your CSS code using
    Webpack. So, let''s start by bundling our `styles.css` file and then Bootstrap''s
    files. Install the following dependencies for implementing our loader for CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In our Webpack configuration, add the following object to the rules array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We are installing two loaders to bundle CSS files:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is `css-loader`. It resolves all the imports and `url()` using
    Webpack. It then returns the complete CSS file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`style-loader` will add the CSS to the page so that the styles are active on
    the page.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to run `css-loader` first, followed by `style-loader`, which uses the
    output returned by `css-loader`. To do that, we have written the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For a CSS file: `test: /\.css$/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the following loaders: `use: [''style-loader'', ''css-loader'']`. Webpack
    executes the loaders in a last to first order. So, first, `css-loader` will be
    executed and its output will be passed over to `style-loader`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open up your `general.js` file and add the following line at the beginning
    of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, remove the `<link>` attribute used to include the CSS file in your `index.html`
    page. Here''s the trick: the CSS file will be imported into the `general.js` file,
    which will in turn be imported into the `memes.js` file, which is the only file
    you need to include in `index.html`.'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create a large `webpack.config.js` file. If you face any problems,
    refer to the final `webpack.config.js` file we are creating at either: [https://goo.gl/Q8P4ta](https://goo.gl/Q8P4ta)
    or the book's code files under the `chapter02\webpack-dev-server` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Now is the time to see our application. Execute `npm run webpack` in your terminal
    and open up the website that only has a single `memes.js` file included in Chrome.
    You should see the exact page with no changes. All the dependencies are bundled
    into a single file--except Bootstrap!
  prefs: []
  type: TYPE_NORMAL
- en: Bundling Bootstrap in Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Time to bundle our final dependency into Webpack. Bootstrap consists of three
    parts. The first is Bootstrap''s CSS file, followed by jQuery and Bootstrap''s
    JavaScript file, which is dependent on jQuery. The last two files were ignored
    in this chapter''s `index.html` file, since we weren''t using them. But, since
    we are bundling our dependencies with Webpack, let''s just bring all of them together.
    For the first step, install our dependencies (these are not dev dependencies;
    hence, `-S` is used instead of `-D`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Bootstrap is written using **Less** instead of CSS. **Less** is a CSS pre-processor
    that extends CSS with more features, such as variables, mixins, and functions.
    To import Bootstrap''s less file using Webpack, we need another loader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install the less compiler and loader into our `node_modules`. Now,
    in our rules, modify the CSS rules into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This will add `less-loader` as the first option as a loader whenever CSS or
    a less file is detected by Webpack. Now, try `npm run webpack`. This time, you
    will get an error in the terminal saying "*You may need an appropriate loader
    to handle this file type*" for the fonts that are used by Bootstrap. Since Bootstrap
    is dependent on a lot of fonts, we need to create a separate loader to include
    them in our bundle. For this purpose, install the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And then include the following object in your rules array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This will tell Webpack if the file size is smaller than 10 KB. Then, simply
    inline the file into JavaScript as a data URL. Otherwise, move the file into the
    fonts folder and create a reference in JavaScript. This is useful to reduce a
    network overhead if the file is smaller than 10 KB. `url-loader` requires `file-loader`
    to be installed as a dependency. Once again, execute `npm run webpack` and, this
    time, your Bootstrap less file will be bundled successfully and you will be able
    to view your website in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: This may look like a lot of work for a few CSS and JS files. But, when you are
    working on large-scale applications, these configurations can save hours of development
    work. The biggest advantage of Webpack is that you can write the configuration
    for one project and use it for other projects. So, most of the work we do here
    will be done only once. We'll simply copy and use our `webpack.config.js` file
    in other projects.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned earlier, we didn't use Bootstrap's JS files in our application.
    However, we might need to use them for our applications in the future. Bootstrap
    requires jQuery to be available in global scope so that it's JavaScript files
    can be executed. However, Webpack does not expose the JavaScript variables it
    has bundled unless it is explicitly specified to expose them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make jQuery available in the global scope throughout our web application,
    we need to use a Webpack plugin. Plugins are different from loaders. We''ll see
    more about plugins in a moment. For now, add the following code after the module
    property of Webpack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `general.js` file, include the following line to import all the Bootstrap
    JavaScript files into our web app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This line will import Bootstrap's JavaScript files from the `node_modules` folder.
    You have now successfully bundled Bootstrap using Webpack. There is just one more
    loader that is commonly used `- img-loader`. There are scenarios when we include
    images in CSS and JavaScript. Using Webpack, we can automatically bundle the images
    while compressing the size of larger images during bundling.
  prefs: []
  type: TYPE_NORMAL
- en: 'To bundle images, we need to use `img-loader` and `url-loader` together. First,
    install `img-loader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following object to your rules list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now, execute `npm run webpack` and open up the website again. You have all your
    dependencies bundled inside a single JavaScript file `memes.js` and you are ready
    to go.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the `img-loader` binaries might fail during building depending on
    your operating system. In the latest version of Ubuntu, this is due to a missing
    package that can be downloaded and installed from: [https://packages.debian.org/jessie/amd64/libpng12-0/download](https://packages.debian.org/jessie/amd64/libpng12-0/download).
    In other operating systems, you have to manually find out why the build failed.
    If you cannot resolve the `img-loader` issue, do try to use a different loader
    or simply remove `img-loader` and only use `url-loader` for images.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins in Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike loaders, plugins are used to customize the Webpack build process. There
    are a lot of plugins that are built into Webpack. They can be accessed by `webpack.[plugin-name]`.
    We can also write our own functions as plugins.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on webpack's plugin system, refer to [https://webpack.js.org/configuration/plugins/](https://webpack.js.org/configuration/plugins/).
  prefs: []
  type: TYPE_NORMAL
- en: Webpack dev server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have created the Webpack configuration to compile our code, but
    it will be easier if we can serve the code as we did using `http-server`. `webpack-dev-server`
    is a small server written using Node.js and Express, which is used to serve the
    Webpack bundle. To use `webpack-dev-server`, we need to install it''s dependencies
    and update our npm scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following line to the npm scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `npm run watch`, we can now serve the files over a server on our
    localhost. `webpack-dev-server` does not write the bundled files to the disk.
    Instead, it will automatically serve them from memory. One great feature of `webpack-dev-server`
    is that it is able to do `HotModuleReplacement`, which will replace a part of
    code that has been changed without even reloading the page. To use `HotModuleReplacement`,
    add the following configurations to your Webpack configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Currently, `webpack-dev-server` is serving files from the root. But we need
    files to be served from the `dist` directory. To do that, we need to set `publicPath`
    in our output configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Delete your `dist` folder and run the `npm run watch` command. Your web app
    will now print a few extra messages in the console. These are from `webpack-dev-server`,
    which is listening for any file changes. Try changing a few lines in your CSS
    file. Your changes will be immediately, reflected without having to reload the
    page! This is very useful to see style changes immediately as soon as the code
    is saved. `HotModuleReplacement` is widely used in modern JavaScript frameworks,
    such as React, Angular, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are still missing `source-maps` in our code for debugging. To enable `source-maps`,
    Webpack provides a simple configuration option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'There are different types of source-maps that can be generated by Webpack depending
    on the time taken to generate them and the quality. Refer to this page for more
    information: [https://webpack.js.org/configuration/devtool/](https://webpack.js.org/configuration/devtool/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will only add source maps to the JS files. To add `source-maps` to CSS
    files, which also contains Bootstrap''s less files, change the CSS rules to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This rule will tell `less-loader` to add `source-maps` to the files compiled
    by it and pass it to `css-loader`, which will also pass the source maps to `style-loader`.
    Now, both your JS and CSS files will have source maps, making it easy to debug
    the application in Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have been following along, your Webpack configuration file should now
    look like the code in the following URL: [https://goo.gl/Q8P4ta](https://gist.github.com/DaniAkash/811221175c9ef5c292f0fd6f1cec5bc3).
    Your `package.json` file should look like: [https://goo.gl/m4Ib97](https://gist.github.com/DaniAkash/6ec06b68033a5fe46fa68bfe3ce492fd).
    These files are also included in the book''s code inside the `chapter02\webpack-dev-server`
    directory.'
  prefs: []
  type: TYPE_NORMAL
- en: We have used a lot of different loaders with Webpack, each of them having their
    own configuration options, many of which we did not discuss here. Do visit those
    packages, npm or GitHub pages to learn more about their configuration and customize
    them as per your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The upcoming section is optional. If you want to build the Meme Creator app,
    you can skip the next section and start with the development. The Webpack configuration
    you have now will be totally fine. However, the next section is important to learn
    more about Webpack and use it in production, so do come back to read about it
    later!
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing Webpack builds for different environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While working on large scale applications, there are usually different types
    of environments created for the application to run, such as development, testing,
    staging, production, and so on. Each environment has different configurations
    for the application and is useful for development and testing by different groups
    of people in the team.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine you have an API for payments in your app. During development,
    you will have sandbox credentials and, for testing, you have different credentials,
    and finally, for production, you have the actual credentials needed by the payment
    gateway. So, the application needs to use three different credentials for three
    different environments. It is also important not to commit sensitive information
    into your version control system.
  prefs: []
  type: TYPE_NORMAL
- en: So, how are we going to pass the credentials to the app without writing them
    in the code? That's where the concept of environment variables come in. The operating
    system will provide the values during compile time so that the build can be generated
    with values from different environment variables in different environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of creating environment variables is different for each operating
    system and it''s a tedious task to maintain these environment variables for each
    project. So, let''s simplify the process by using an `npm` package to load our
    environment variables from a `.env` file from our project root folder. In Node.js,
    you can access the environment variables in the `process.env` object. Here''s
    how you can read variables from `.env` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to install the following package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, create a `.env` file in your project root directory with
    the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This `.env` file contains three environment variables and their values. You
    should add the `.env` file to your `.gitignore` file if you are using Git or include
    it in the ignore list of your version control system. It''s also a good practice
    to create the `.env.example` file, which tells other developers what kind of environment
    variables are needed by the application. You can commit the `.env.example` file
    to your version control system. Our `.env.example` file should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: These environment variables can be read by Node.js, but they can't be read by
    our JavaScript code. So, we need Webpack to read these variables and provide them
    as global variables to the JavaScript code. It is recommended to keep the letters
    of the environment variable names in capital letters so that you can easily identify
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use `NODE_ENV` for detecting the environment type and to tell
    Webpack to generate an appropriate build for that environment, and we need to
    use other two environment variables in our JS code. In your `webpack.config.js`
    file, in the first line, include the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This will use the `dotenv` package we just installed and load the environment
    variables from the `.env` file in our project''s root directory. Now, the environment
    variables are accessible inside the Webpack configuration file in the `process.env`
    object. First, let''s set up a flag to check whether the current environment is
    production. Include the following code after the `require(''webpack'')` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `isProduction` will be set to true when `NODE_ENV` is set to production.
    To include the other two variables in our JavaScript code, we need to use `DefinePlugin`
    in Webpack. Inside the plugins array, add the following configuration object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`DefinePlugin` will define the constants at compile time, so you can change
    your environment variables depending on your environment and it will be reflected
    in the code. Make sure you stringify any value you pass to `DefinePlugin`. More
    information about this plugin can be found at: [https://webpack.js.org/plugins/define-plugin/](https://webpack.js.org/plugins/define-plugin/).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, inside your `memes.js` file's constructor, try `console.log(ENVIRONMENT,
    CONSTANT_VALUE);` and reload Chrome. You should see their values printed out in
    the console.
  prefs: []
  type: TYPE_NORMAL
- en: Since we set up a flag using the `isProduction` variable, we can use this variable
    to do various optimizations to the build only when the environment is production.
    Some of the common plugins used for optimizations in production builds are as
    follows.
  prefs: []
  type: TYPE_NORMAL
- en: Creating .env file in Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Windows do not allow you to create a `.env` file directly from the windows
    explorer since it will not allow file names starting with a dot. However, you
    will be able to create it from VSCode easily. First, open the project folder in
    VSCode using the menu option File | Open Folder...[Ctrl+K Ctrl+O] as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have opened the folder, click on the Explorer icon on the top left
    corner of the VSCode (or press *Ctrl*+*Shift*+*E*) to open the explorer panel.
    In the explorer panel, click on the New File button as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then simply type in the new file name `.env` as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Hit *Enter* to create the `.env` file and start editing it.
  prefs: []
  type: TYPE_NORMAL
- en: '`.env` files are read only when the Webpack-dev-server starts. So, if you make
    any changes to the `.env` files, you will have to kill the running Webpack-dev-server
    instance in the Terminal and restart it so that it will read the new values in
    `.env` files.'
  prefs: []
  type: TYPE_NORMAL
- en: UglifyJsPlugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a plugin that is used for compressing and minifying JavaScript files.
    This greatly reduces the size of the JavaScript code and increases the loading
    speed for end users. However, using this plugin during development will cause
    Webpack to slow down, since it adds an extra step to the build process (expensive
    task). Hence, `UglifyJsPlugin` is usually used only on production environments.
    To do so, add the following lines at the end of your Webpack configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This will push `UglifyJSPlugin` to the plugins array if the environment is set
    to production. More information regarding `UglifyJsPlugin` can be found at: [https://webpack.js.org/plugins/uglifyjs-webpack-plugin/](https://webpack.js.org/plugins/uglifyjs-webpack-plugin/).
  prefs: []
  type: TYPE_NORMAL
- en: PurifyCSSPlugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When building web applications, there will be a lot of styles that are defined
    in CSS but are never used in HTML. `PurifyCSSPlugin` will go through all the HTML
    files and remove any unnecessary CSS styles that we have defined before bundling
    the code. To use `PurifyCSSPlugin`, we need to install the `purifycss-webpack`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, import the plugin to your Webpack configuration file and use it
    as specified in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '`glob` is an inbuilt module in Node.js. We specify the paths of HTML using
    `glob.sync`, which resolves the regular expression into all the HTML files inside
    the specified directory. `PurifyCSSPlugin` will now use these HTML files to purify
    our styles. The `minimize` option will minify CSS along with purification. More
    information regarding `PurifyCSSPlugin` can be found at: [https://github.com/webpack-contrib/purifycss-webpack](https://github.com/webpack-contrib/purifycss-webpack).'
  prefs: []
  type: TYPE_NORMAL
- en: '`PurifyCSSplugin` is useful but it might cause problems with Bootstrap animations
    and some other plugins. Make sure you test it well before using it.'
  prefs: []
  type: TYPE_NORMAL
- en: ExtractTextPlugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In production, it is recommended to extract all your CSS code into a separate
    file. This is because CSS files need to be included at the beginning of the page
    so that page styles will be applied to HTML while it is loading. However, since
    we are bundling CSS together with JavaScript, we are including it at the end of
    the page. When the page is loading, it will look like a plain document till the
    CSS files are loaded.
  prefs: []
  type: TYPE_NORMAL
- en: '`ExtractTextPlugin` is used to overcome this problem. It will extract all the
    CSS files in JS code into separate files with the same name as the JS file it
    was bundled together with. We can now include that CSS file at the top of our
    HTML file, which makes the styles be loaded first. As usual, the first step is
    to install the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we need to create a new instance of `ExtractTextPlugin`, which
    we are going to use with our CSS files. Since we are also using less from Bootstrap,
    our configuration file should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We have created an instance of `ExtractTextPlugin` as `extractLess`. Since we
    are using `PurifyCSSPlugin`, make sure you include the `extractLess` object before
    we create an instance `PurifyCSSPlugin` in the plugins array.
  prefs: []
  type: TYPE_NORMAL
- en: More information regarding `PurifyCSSPlugin` can be found at: [https://github.com/webpack-contrib/purifycss-webpack](https://github.com/webpack-contrib/purifycss-webpack).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have added `ExtractTextPlugin`, Webpack will generate two files for
    each JavaScript file if the JavaScript file imports CSS. You will have to include
    the CSS files separately in your HTML. In our case, for `memes.js`, it will generate
    `memes.js` and `memes.css` in the `dist` directory, which needs to be included
    separately in the HTML file.
  prefs: []
  type: TYPE_NORMAL
- en: '`ExtractTextPlugin` will not work properly with Webpack `HotModuleReplacement`
    for CSS files. Hence, it''s best to include `ExtractTextPlugin` only in production.'
  prefs: []
  type: TYPE_NORMAL
- en: Cache busting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use caching with the static resources produced by Webpack, it's a good practice
    to append the filenames of the static resources with hashes. **[chunkhash]** will
    generate a content-dependent hash, which should be appended to the filename that
    acts as the cache buster. Whenever the content of the file changes, the hash will
    change, which will lead to new filenames and, hence, regenerating the cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'Only production builds need cache busting logic. Development builds do not
    need these configurations. Hence, we need to generate hashed filenames only at
    production. Also, we must generate a `manifest.json` file that contains the new
    filenames of the generated resources that must be inlined into the HTML file.
    Configurations for cache busting are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This will add a hash prefix to the filenames in production. However, `webpack.HotModuleReplacementPlugin()`
    does not work well with **[chunkhash]**, so `HotModuleReplacementPlugin` should
    not be used in our production environment. To generate the `manifest.json` file,
    add the following function as an element to the plugins array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Or it's better to add it next to `UglifyJSPlugin`, which gets executed only
    in production. This function will use the `fs` module in Node.js to write the
    generated files as a JSON file. For more information regarding this topic, refer
    to: [https://webpack.js.org/guides/caching/](https://webpack.js.org/guides/caching/).
  prefs: []
  type: TYPE_NORMAL
- en: Clean dist folder before generating a new build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we generate lot of builds with different hashed filenames, it is a good
    practice to delete the `dist` directory before running each build. `clean-webpack-plugin`
    does just that. It cleans the `dist` directory before new files are bundled. To
    use `clean-webpack-plugin`, run the following command inside the project root
    folder to install the plugin: :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following variables to your Webpack configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add `new CleanWebpackPlugin(pathsToClean, cleanOptions)` to your production
    plugins. Now, every time the production build is generated, the old `dist` folder
    will be deleted and a new folder will be created with the latest bundled files.
    More information regarding this plugin can be found at: [https://github.com/johnagan/clean-webpack-plugin](https://github.com/johnagan/clean-webpack-plugin).'
  prefs: []
  type: TYPE_NORMAL
- en: Source maps in production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Source maps provide us with an easy way to debug our compiled code. Browsers
    don''t load source maps until the development tool is opened. Hence, performance-wise
    source maps don''t cause any harm. However, if you need the original source code
    to be protected, then removing source maps is a good idea. You can also use private
    source maps by setting `sourceMappingURL` at the end of each bundled file to a
    restricted URL that can be used only by a trusted source (for example, source
    maps can be accessed only by developers within the company''s domain):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The complete Webpack configuration file with all the earlier mentioned optimizations
    will look as: [https://goo.gl/UDuUBu](https://goo.gl/UDuUBu). The dependencies
    used in this configuration can be found at: [https://goo.gl/PcHpZf](https://goo.gl/PcHpZf).
    These files are also included in this book's code files under the `Chapter02\webpack
    production optimized` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have just tried of lot of community created plugins and loaders for Webpack.
    Remember that there is more than one way to perform these tasks. So, be sure to
    check out a lot of new plugins/loaders created over time. This repository contains
    a curated list of Webpack resources: [https://github.com/webpack-contrib/awesome-webpack](https://github.com/webpack-contrib/awesome-webpack).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are using flexbox in the Meme Creator, some old browsers support flexbox
    with `vendor-prefixes`. Try adding vendor prefixes to your CSS using `postcss/autoprefixer`:
    [https://github.com/postcss/autoprefixer](https://github.com/postcss/autoprefixer).'
  prefs: []
  type: TYPE_NORMAL
- en: Building the Meme Creator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just built a nice little development environment using Webpack. It's time
    to put it into action. If you have done the production optimizations, make sure
    you have created the `.env` file in the project root folder and your `NODE_ENV`
    environment variable inside that file is not `production`. Simply set the value
    of `NODE_ENV=dev` while we are working on the application. We are going to build
    the Meme Creator now. Make sure you have included the `memes.js` and `memes.css`
    files (if you used `ExtractTextPlugin`) from the `dist` directory in your `index.html`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Open up the `memes.js` file in your text editor and keep `webpack-dev-server`
    running (`npm run watch`). Our first step is to create a reference to all the
    required DOM elements in variables in our class. We can then use the references
    to modify the elements later, from inside the class. Also, whenever we are creating
    a reference to DOM elements, it is good to have the variable names start with
    `$`. This way, we can easily know which variables contain values and which ones
    contain references to the DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: webpack-dev-server will print the URL in the console which you should open using
    Chrome to see your application. The URL will be http://localhost:8080/
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember how in the previous chapter, we used `document.getElementById()` to
    search through the DOM elements? JavaScript also has a better alternative that
    makes querying DOM elements simpler: the `document.querySelector()` method. The
    former allowed us to search a document only using `Id`, but `querySelector` allows
    us to query the document using `id`, class, and even the element''s name. For
    example, if you need to select the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'All of these will return the first element matching the query criteria. If
    you want to select multiple elements, you can use `document.querySelectorAll()`,
    which returns an array of references to all the matching DOM elements. In our
    constructor, write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a reference to all the required DOM elements in our class. Currently,
    our canvas is small; we didn''t specify its size using CSS because we need the
    page to be responsive. If users visits the page from a mobile device, we don''t
    want to show a horizontal scrollbar because the canvas has gone out of the screen
    due to its size. Hence, we will use JavaScript to create the canvas height and
    width depending on the screen size. We need to calculate the device width first.
    Add the following code above the `Memes` class (not inside the class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This will calculate the device''s width and store it in a constant `deviceWidth`.
    Inside the class, create the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: References to DOM elements contain the entire target element as a JavaScript
    object. It can be used in the same way we handle normal class objects. Modifications
    to references will be reflected in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: This will create a rectanglar canvas with height `480` and width `640` if the
    device's screen is large enough. Otherwise, it will create a square canvas with
    width `deviceWidth-30`. Refer to the image of the Meme Creator you saw earlier.
    The canvas will be rectangular for desktops and will become a square area with
    margin for mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.min(x, y)` will return the smallest of two numbers `x` and `y`. We reduced
    the width by `30` because we need to have space for the margins. Add `this.createCanvas()`
    inside the constructor and view the page in Chrome (Webpack will have reloaded
    the page for you). Try the responsive design mode to see how the canvas appears
    on mobile devices. Height and width are applied only when the page is loaded for
    the first time; hence, refresh the page when you are checking different devices.'
  prefs: []
  type: TYPE_NORMAL
- en: Our canvas area is ready; let's look at a few things about the new `<canvas>`
    element in HTML. Canvas is a container for graphics. We can use JavaScript to
    write graphics on the canvas element. Canvas has several methods for drawing,
    such as paths, shapes, text, and images. Also, rendering graphics in canvas is
    faster than using DOM elements. One more advantage of canvas is that we can convert
    the canvas content into an image. In real-world applications, where you have server-side
    APIs, you can use the server to render the images and text for the memes. But,
    since we are not going to use server-side in this chapter, canvas is our best
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit the **Mozilla Developer Network** (**MDN**) page: [https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial)
    for more information regarding the canvas element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the strategy for the Meme Creator:'
  prefs: []
  type: TYPE_NORMAL
- en: The canvas element just renders the graphics to its bitmap when instructed.
    We cannot detect any graphics that were previously drawn on it. This leaves us
    no option but to clear the canvas every time a new text or image is entered into
    the Meme Creator and render the whole canvas again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need event listeners to add text to the meme whenever the user is typing
    in the Top Text or Bottom Text input boxes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bottom Text is a compulsory field. The user cannot download the meme unless
    it is filled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user can select images of any size. If he selects a huge image, it shouldn't
    break our page layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Download Button should work like a download button!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have an idea for building the Meme Creator. Our first step is to create
    a function that renders the meme to the canvas. Inside the `Memes` class, create
    a function `createMeme()` that is going to contain our primary canvas renderer.
    For now, leave the function with a simple console statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Remember, we need to render the entire canvas every time a change happens. So,
    we need to attach event listeners to all the input elements. You can also use
    HTML event attributes such as `onchange` we used in the previous ToDo List app.
    But event listeners let us handle more than one event for an element. Hence, they
    are widely preferred. Also, since we are using Webpack to bundle the code, we
    cannot access the JavaScript variables or objects inside our HTML directly! This
    requires a little Webpack configuration change and it might not be needed at all.
    We will discuss this topic in detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to call `createMeme` whenever a text is entered into the `TopTextInput` and
    `BottomTextInput` areas. So, we need to attach an event listener that listens
    to the `keyup` event on these input boxes. Create the event listener function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Open Chrome and try typing in the text boxes while keeping the console open.
    You should see rendered being printed in the console every time you type a word.
    There is actually a better way to attach event listeners if you want to attach
    the same event listener to multiple elements. Simply use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It creates an array of reference objects to all the target input elements (`inputNodes`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `forEach()` method to loop through each element in the array and attach
    an event listener to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using the ES6 fat arrows, we achieved it in a single line without having
    to worry about binding the `this` object to the callback function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have also added `$imageInput` in `inputNodes`. This element is not going
    to be affected much with the `keyup` event, but we need this to be monitored when
    a user uploads a new image. Also, if the user copies and pastes text into the
    text inputs without pressing any keyboard buttons, we need to handle the change.
    Both of these scenarios can be handled using the `change` event. Add the following
    line to the `addEventListeners()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Whenever the user types in some text or uploads a new image, the `this.createMeme()`
    method will be automatically called.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering an image in the canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step to render something to the canvas is to use the `CanvasRenderingContext2D`
    interface to get the 2D rendering context for the target `<canvas>` element. Inside
    our `createMeme()` function, create a context to the canvas element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The `context` variable will now hold the object of the `CanvasRenderingContext2D`
    interface. To make rendering a little more efficient, we''ll add a condition to
    render only when a user has selected an image. We can do this by checking whether
    the reference to the image input has any files in it. We should start the rendering
    process only when there is a file selected in the input. To do so, check whether
    the input element contains any file objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, try typing some text into the input field. You should get an error in
    the console saying: Cannot read property ''getContext'' of undefined.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this moment, you should be asking the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Didn't we define `this.$canvas` to hold reference to our canvas element in our
    constructor?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are getting the context object from our canvas reference `this.$canvas`.
    But how could `this.$canvas` be undefined?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aren't we doing everything right?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To find the answers, we need to use the Chrome DevTools to figure out what
    went wrong in our code. Add the `debugger;` keyword right before the line causing
    the error (the line we define our context variable). Now, reload Chrome and start
    typing. Chrome''s debugger will have now paused the page execution and the sources
    tab will highlight the line in which the Chrome debugger has paused the execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The execution of the code is now paused. This means all the variables will
    now contain their values during execution. Hover your cursor over the `this` keyword
    in the line next to `debugger;`. Surprisingly, placing the cursor over this object
    will highlight the top Input text field in your website! Also, the information
    popup will also show this object containing reference to `input#topText.form-control`.
    Here is the problem: the `this` object no longer has reference to the class but
    has reference to a DOM element. We defined the `$canvas` variable inside the class;
    hence, `this.$canvas` is now undefined. We faced a similar problem with binding
    the `this` object in the previous project. Can you guess where we went wrong?'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s the line where we attached event listeners to our input elements in our
    `addEventListeners()` function. Since we are using ES6 fat arrows here, you might
    be wondering why `this` didn''t automatically inherit its value from the parent.
    It''s because, this time, we are sending `this.createMeme` as a parameter to the
    `addEventListener()` method of the target element. Hence, that input element becomes
    the new parent for inheriting the `this` object. To overcome this problem, change
    `this.createMeme` to `this.createMeme.bind(this)`, or for a cleaner syntax, add
    the following code as the first line of our `addEventListeners()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Now, `this.createMeme` can be used normally anywhere inside our `addEventListeners()`
    function. Try typing some text into the input boxes. This time, there shouldn't
    be any errors. Now, select an image from the source image input. Try typing some
    text. This time, you should see *rendering* text printed in the console. We are
    going to write the rendering code inside this `if` condition so that the meme
    renders only when an image is selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more thing! If you click the image input, it shows all the files in the
    disk. We only need the user to select the image files. In this case, add the `accept`
    attribute to the input element in `index.html` with the extensions that are allowed
    for the user to select. The new input element should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Reading a file using JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To read the selected image, we are going to use `FileReader`, which allows JavaScript
    to *asynchronously* read the contents of a file (either from a file or raw data).
    Note the term asynchronously; it means JavaScript will not wait for the `FileReader`
    code to complete execution. JavaScript will start the execution of the next line
    while `FileReader` is still reading the file. This is because JavaScript is a
    single-threaded language. It means all the operations, event listeners, functions,
    and so on, are executing in a single thread. If JS has to wait for the completion
    of `FileReader`, then the entire JavaScript code will be paused (just like how
    debugger pauses the execution of the script), since everything is running in a
    single thread.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this from happening, JavaScript does not simply wait for the event
    to complete, but runs the event simultaneously while executing the next lines
    of code. There are different ways in which we can handle asynchronous events.
    Generally, an asynchronous event is given a callback function (some lines of code
    that needs to be executed after the event is completed) or the asynchronous code
    will fire an event when the execution is complete and we can write a function
    to execute when that event is triggered. ES6 has a new way of dealing with asynchronous
    events, called Promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see more about using Promises in the next chapter. `FileReader` will
    fire a `load` event when it''s finished reading the file. `FileReader` also comes
    with the `onload` event handler to handle the `load` event. Inside the `if` statement,
    create a new `FileReader` object and assign it to variable reader using the `FileReader()`
    constructor. Here''s how we are going to handle the asynchronous `FileReader`
    logic: write the following code inside the `if` statement (remove the previous
    `console.log` statement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, try selecting an image in Chrome. You should see two statements printed
    in the console. This is what we have done in the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a new instance of `FileReader` in the reader variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then specified what the reader should do in the `onload` event handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we passed the file object of the selected image to the reader object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you might have guessed, JavaScript will execute `reader.readAsDataURL` first
    and find that it is an asynchronous event. So, while the `FileReader` is running,
    it will execute the next `console.log()` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `FileReader` has completed reading the file, it will fire the `load`
    event, which will call the corresponding `reader.onload` event handler. Now, the
    `console.log()` statement inside the `reader.onload` method will be executed.
    `reader.result` will now contain the image data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create an `Image` object using the result from `FileReader`. Create
    a new instance of the image using the `Image()` constructor (we should now write
    the code inside the `reader.onload` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, dynamically loading an image source is also an asynchronous
    event and we need to use the `onload` event handler provided by the `Image` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the image loaded, we need to resize the canvas to the image''s
    size. To do that, write the following code inside the `image.onload` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This will now resize the canvas to the size of the image. Once we have the
    canvas resized, our first step is to erase the canvas. The canvas object has the
    `clearRect()` method, which can be used to clear a rectangular area in the canvas.
    In our case, the rectangular area is the entire canvas. To clear the entire canvas,
    we need to use `clearRect()` with our canvas''s context object, which is the `context`
    variable we created earlier. After that, we need to load the image into the canvas.
    Write the following code inside the `image.onload` method right after assigning
    the canvas dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, try selecting an image. The image should be displayed in the canvas. This
    is what the previous code does:'
  prefs: []
  type: TYPE_NORMAL
- en: Clear a rectangular area in the canvas starting from the top-left coordinates
    `(0,0)`, that is, the *first two parameters* of the `clearRect()` method and then
    create a rectangle with its height and width equal to that of the canvas, that
    is, the last two parameters of the `clearRect()` method. This effectively clears
    the entire canvas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw an image onto the canvas using the image stored in the `image` object starting
    from the coordinates `(0,0)`. Since the canvas has the same dimensions as the
    image, the image will cover the entire canvas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering text on the canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have an image now, but we are still missing the top text and bottom text.
    Here are a few things we need as the text property:'
  prefs: []
  type: TYPE_NORMAL
- en: The font size should be responsive to the size of the image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The text should be center-aligned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The text should have margin space at the top and bottom of the image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The text should have a black stroke so that it can be seen clearly over the
    image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our first step, we need the font size to be responsive. If the user selects
    either a large image or a small one, we need to have a relative font size. Since
    we have the canvas height and width, we can use that to get a font size that is
    `4`% of the average of the image height and width. We can center align the text
    using the `textAlign` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we need to specify a baseline using the `textBaseline` property. It is
    used to position the text at the specified location. First, the canvas creates
    a baseline at the location we specify for the text. Then, it will write the text
    above, below, or over the baseline based on the value supplied to `textBaseline`.
    Write the following code inside the `image.onload` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We have specified the font to be `4`% of the average of the canvas height and
    width and set the font style to `sans-serif`. Also, by setting `textBaseline`
    to `top`, the baseline will be on top of the text, that is, the text will be rendered
    below the baseline.
  prefs: []
  type: TYPE_NORMAL
- en: Canvas does not have an option to apply stroke to the text. Hence, to create
    a white text with black stroke, we need to create two different texts, a black
    stroke text and a white fill text, with the line width of the stroke text being
    slightly bigger than the fill text, and place them one over another. This might
    sound like a complex task to do, but it's actually simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how a stroke text looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00017.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'This is how a fill text looks (in a gray background):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00018.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Create styles for the stroke text and fill text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the value for the top text and bottom text from the input fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'This will get the value from the input fields and automatically convert the
    text to uppercase letters. Finally, to render the text at the top and bottom of
    the canvas, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider `context.strokeText()`. This is how the text gets rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter of the `strokeText` method, `topText` contains the text
    to be rendered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second and third parameters contain the location where the text should start
    rendering. Along the *x *axis, the text should start rendering from the middle
    of the canvas (`this.$canvas.width/2`). The text will be center aligned and along
    the *y* axis from a height that is `5`% from the top of the canvas (`this.$canvas.height*(5/100)`).
    The text will be rendered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is exactly where we need the top text of the meme. For the bottom text,
    increase the height to `90`% from the top. The stroke text with black stroke will
    be below the fill text. Sometimes, ''M'' will have additional strokes over the
    text. This is because the place where two lines meet is not properly rounded.
    To do so, add the following line after the line specifying `fillStyle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, quickly switch to Chrome, select an image, and type some text! You have
    your very own Meme Creator! For reference, it should work like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, to download the meme, we need to convert the canvas into an image and
    attach the image as the attribute to the download button. Create a new function
    `downloadMeme()` inside the `Memes` class. In the `addEventListeners()` function,
    add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the `downloadMeme()` function, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, clicking the download button will convert the canvas into an image and
    let the browser download it. This is how the previous code works:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the canvas is converted into a 64-bit encoded png URL using the `toDataURL('image/png')`
    method and is stored in the `imageSource` constant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create another constant `att` that contains an HTML `'href'` attribute object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, change the value of the `att` object to the image URL stored in `imageSource`
    while changing the mime type from `data:image` to `data:application/octet-stream`.
    This step is necessary because most browsers display images directly instead of
    downloading them. By changing the mime type to `octet-stream` (used for binary
    files), we can trick the browser into thinking the file is not an image and, hence,
    download the file instead of viewing it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, assign the `att` object as an attribute of `$downloadButton`, which
    is an anchor tag with the `download` attribute. The value of the `download` attribute
    will be the default name of the downloaded image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `imageSource.replace()` method, a regular expression is used for changing
    the mime type of the image. We will discuss more on using regular expressions
    in the next chapter. To know more about regular expressions, visit the following
    MDN page: [https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions](https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before downloading the meme from the Meme Creator, we need to validate the
    form so that there must be an image selected and, at least, the bottom text box
    is filled in order to download the meme. We need to add the form validation code
    in the `downloadMeme()` function above the code to download the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The previous code will check for an image and text in the bottom text input
    box and stop `downloadMeme()` from continuing execution using the `return` keyword.
    Once an empty field has been found, it will add the `.has-error` class to the
    input's parent `div`, which, according to Bootstrap, highlights the input in a
    red border (we used it previously in the ToDo list app).
  prefs: []
  type: TYPE_NORMAL
- en: 'You might not get the highlight, because we are using `PurifyCSSPlugin` with
    Webpack, which filters out all the unwanted styles by referring `index.html`.
    Since the `.has-error` class is not present in `index.html` initially, its style
    definition is also removed from the bundled CSS. To overcome this problem, add
    all the classes you would like to add dynamically to a hidden `div` element in
    the page. Add the following line to our `index.html` file just above the `<script>`
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Now, the style definitions for `.has-error` will be included in the bundle and
    form validation will add a red border to the empty fields.
  prefs: []
  type: TYPE_NORMAL
- en: Making a canvas responsive to show large images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the user selects a large image (for example, an image the size of the screen),
    it will cause the layout to break. To prevent this from happening, we need to
    zoom out our canvas when large images are selected. We can zoom in or zoom out
    our canvas element by controlling its height and width in CSS. In the `Memes`
    class, create the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how `resizeCanvas()` works:'
  prefs: []
  type: TYPE_NORMAL
- en: This function will initially apply the height and width of the canvas in CSS
    to its actual height and width (so that the zoom level of the previous image is
    not remembered).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, it will check whether the height and width are either greater than the
    minimum of 1000px or `deviceWidth-30` (we already defined the `deviceWidth` constant).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the canvas size is greater than the given condition, we reduce the height
    and width by half and then assign the new values to the canvas's CSS (this will
    zoom out the canvas).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since it is a while loop, the operation is repeated until the canvas size goes
    below the condition, thus, effectively zooming out the canvas and preserving the
    page layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simply call `this.resizeCanvas(this.$canvas.height, this.$canvas.width)` inside
    the `image.onload` method after the code to render text in the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: '`height /= 2` is a shorthand used for `height = height / 2`. This is applicable
    for other arithmetic operators, such as `+`, `-`, `*`, and `%`.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Good work! You have built a Meme Creator that will now convert your images
    into memes. More importantly, you have a great development environment that will
    make app development with JavaScript even easier. Let''s review the things you
    have learned in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A short introduction to the flexbox layout system in CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to JavaScript modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module bundling with Webpack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Production optimizations to improve performance for users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using HTML5 canvas with JavaScript to draw graphics on a website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned quite a lot in this chapter. Especially about Webpack. It might seem
    a little overwhelming, but it is very useful in the long run. In the next chapter,
    we are going to see how to write modular code and reuse it across the application,
    which is now possible due to Webpack.
  prefs: []
  type: TYPE_NORMAL
