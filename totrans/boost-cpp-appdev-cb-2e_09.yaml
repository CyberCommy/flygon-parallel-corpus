- en: Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Storing a few elements in the sequence container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing most N elements in the sequence container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing strings in an ultra-fast manner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an unordered set and map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a map, where the value is also a key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using multi-index containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting benefits of a single linked list and memory pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using flat associative containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is devoted to the Boost containers and the things directly connected
    with them. It provides information about the Boost classes that can be used in
    every day programming, and that will make your code much faster, and the development
    of new applications easier.
  prefs: []
  type: TYPE_NORMAL
- en: Containers differ not only by functionality, but also by the efficiency (complexity)
    of some of its members. The knowledge about complexities is essential for writing
    fast applications. This chapter doesn't just introduce some new containers to
    you, it gives you tips on when and when not to use a specific type of container
    or its methods.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Storing a few elements in a sequence container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the past two decades, C++ programmers were using `std::vector` as a default
    sequence container. It is a fast container that does not do a lot of allocations,
    stores elements in a CPU cache friendly way and because container stores the elements
    contiguously `std::vector::data()` like functions allows to inter-operate with
    pure C functions.
  prefs: []
  type: TYPE_NORMAL
- en: But, we want more! There are cases when we do know the typical elements count
    to store in the vector, and we need to improve the performance of the vector by
    totally eliminating the memory allocations for that case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we are writing a high performance system for processing bank transactions.
    **Transaction** is a sequence of operations that must all succeed or fail if at
    least one of the operations failed. We know that the 99% of transactions consist
    of 8 or less operations and wish to speed up things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe requires only the basic knowledge of standard library and C++.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is going to be a simplest task of this book, thanks to the `Boost.Container`
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the appropriate header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace `std::vector` with `boost::container::small_vector` and drop the `reserve()`
    call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `boost::container::small_vector`'s second template parameter is the elements
    count to preallocate on a stack. So if most of the time we have to store 8 or
    less elements in the vector, we just put `8` as a second template parameter.
  prefs: []
  type: TYPE_NORMAL
- en: If we have to store more than 8 elements in the container, then the `small_vector`
    behaves exactly as `std::vector` and dynamically allocates a chunk of memory to
    store more than 8 elements. Just like `std::vector`, the `small_vector` is a sequence
    container with **random access iterators** that stores the elements consistently.
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, `boost::container::small_vector` is a container that behaves exactly
    as `std::vector`, but allows to avoid memory allocations for a compile time specified
    amount of elements.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A drawback of using `small_vector` is that our elements count assumption leaks
    into the function signature that accepts `small_vector` as a parameter. So if
    we have three functions specialized for `4`, `8`, and `16` elements, respectively,
    and all those functions process transactions using `execute_operations` from the
    preceding example, we''ll end up with multiple instantiations of the `execute_operations`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: That's not good! Now, we have multiple functions in our executable that do exactly
    the same thing and consist of almost exactly the same machine codes. This leads
    to bigger binaries, longer startup times of the executable, longer compile, and
    link times. Some compilers may eliminate the redundancy but chances are low.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the solution is very simple. `boost::container::small_vector` is derived
    from the `boost::container::small_vector_base` type that is independent from preallocated
    elements count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Now, we may use the new `execute_operations` function with any `boost::container::small_vector`
    without a risk of bloating the binary size.
  prefs: []
  type: TYPE_NORMAL
- en: C++17 has no `small_vector` like class. There are proposals to include `small_vector`
    to the next C++ standard that will be out somewhere around year 2020.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Boost.Container` library has a full reference documentation for many interesting
    classes at [http://boost.org/libs/container](http://boost.org/libs/container)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`small_vector` came to Boost from the **LLVM** project; you can read about
    the container at the origin site [http://llvm.org/docs/ProgrammersManual.html#llvm-adt-smallvector-h](http://llvm.org/docs/ProgrammersManual.html#llvm-adt-smallvector-h)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing at most N elements in the sequence container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s a question: what container should we use to return the sequence from
    function if we know that the sequence never has more than *N* elements and *N*
    is not big. For example, how we must write the `get_events()` function that returns
    at most five events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `std::vector<event>` allocates memory, so the code from earlier is not a
    good solution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`boost::array<event, 5>` does not allocate memory, but it constructs all the
    five elements. There''s no way to return less than five elements.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `boost::container::small_vector<event, 5>` does not allocate memory for
    five or less elements and allows us to return less than five elements. However,
    the solution is not perfect, because it is not obvious from the function interface
    that it never returns more than five elements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe requires only a basic knowledge of standard library and C++.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Boost.Container` has a container that perfectly satisfies our need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `boost::container::static_vector<T, N>` is a container that does not allocate
    memory and can hold no more than a compile-time-specified amount of elements.
    Think of it as of `boost::container::small_vector<T, N>` that just cannot dynamically
    allocate memory and any attempt to store more than *N* elements results in a `std::bad_alloc`
    exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Just like all the containers of the `Boost.Container` library, `static_vector`
    supports **move semantics** and emulates rvalue references using Boost.Move library
    if your compiler does not support rvalues.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::vector` allocates bigger chunks of memory if a user inserts an element
    and it is impossible to fit the new value into the already allocated memory. In
    that case, `std::vector` moves elements from the old location to the new one if
    the elements are nothrow move constructible. Otherwise, `std::vector` copies elements
    to a new location and after that calls destructor for each element in the old
    location.
  prefs: []
  type: TYPE_NORMAL
- en: Because of that, behavior `std::vector` has amortized constant complexity for
    many member functions. The `static_vector` never allocates memory so that it does
    not have to move or copy elements from an old location to a new one. Because of
    that, operations that have **amortized O(1)** complexity for `std::vector` have
    true O(1) complexity for `boost::container::static_vector`. This may be handy
    for some real-time applications; though, beware of exceptions!
  prefs: []
  type: TYPE_NORMAL
- en: 'Some people still prefer to pass output parameters by reference instead of
    returning them: `void get_events(static_vector<event, 5>& result_out)`. They think
    that this way, there''s a guarantee that no copying of result happens. Don''t
    do that, it makes things worse! C++ compilers have a whole bunch of optimizations,
    such as **Return Value Optimization** (**RVO**) and **Named Return Value Optimization**
    (**NRVO**); different platforms have agreements nailed down in ABI that code with
    `retun something;` does not result in an unnecessary copy and so forth. No copying
    happens already. However, when you pass a value, the reference compiler just does
    not see where the value came from and may assume that it aliases some other value
    in the scope. This may significantly degrade performance.'
  prefs: []
  type: TYPE_NORMAL
- en: C++17 has no `static_vector` class, and at this moment, there's no plan to add
    it into C++20.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The official documentation of `Boost.Container` has a detailed reference section
    that describes all the member functions of the `boost::container::static_vector`
    class. Refer to [http://boost.org/libs/container.](http://boost.org/libs/container)
  prefs: []
  type: TYPE_NORMAL
- en: "[\uFEFF](http://boost.org/libs/container)"
  prefs: []
  type: TYPE_NORMAL
- en: Comparing strings in an ultra-fast manner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a common task to manipulate strings. Here, we'll see how an operation
    of string comparison can be done quickly using some simple tricks. This recipe
    is a trampoline for the next one, where the techniques described here will be
    used to achieve constant time-complexity searches.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we need to make some class that is capable of quickly comparing strings
    for equality. We''ll make a template function to measure the speed of comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe requires only the basic knowledge of standard library and C++.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll make `std::string` a public field in our own class and add all the comparison
    code to our class, without writing helper methods to work with the stored `std::string`,
    as shown in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we''ll need the following header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create our `fast comparison_` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not forget to define the `equality comparisons` operators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And, that''s it! Now, we can run our tests and see the result using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The comparison of strings is slow because we are required to compare all the
    characters of the string one-by-one, if strings have equal length. Instead of
    doing that, we replace the comparison of strings with the comparison of integers.
    This is done via the `hash` function - the function that makes some short-fixed
    length representation of the string.
  prefs: []
  type: TYPE_NORMAL
- en: Let's talk about the `hash` values on apples. Imagine that you have two apples
    with labels, as shown in the following diagram, and you wish to check that the
    apples are of the same cultivar. The simplest way to compare those apples is by
    comparing them by labels. Otherwise, you'll lose a lot of time comparing the apples
    based on the color, size, form, and other parameters. Hash is something like a
    label that reflects the value of the object.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's move step bystep.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 1*, we include the header file that contains definitions of the `hash`
    functions. In *step 2*, we declare our new `string` class that contains `str_`,
    which is the original value of string and `comparison_`, which is the computed
    `hash` value. Note the construction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, `boost::hash<std::string>` is a structure, a functional object just like
    `std::negate<>`. That is why we need the first parenthesis--we construct that
    functional object. The second parenthesis with `s` inside is a call to `std::size_t
    operator()(const std::string& s)`, which computes the `hash` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, take a look at *step 3,* where we define `operator==`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Take additional care about the second part of the expression. Hashing operation
    loses information, which means that there is possibly more than one string that
    produces exactly the same `hash` value. It means that if hashes mismatch, there
    is a 100% guarantee that the strings does not match; otherwise, we are required
    to compare strings using the traditional methods.
  prefs: []
  type: TYPE_NORMAL
- en: Well, it's time to compare numbers. If we measure the execution time using the
    default comparison method, it'll give us 819 milliseconds; however, our hashing
    comparison works almost two times faster and finishes in 475 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++11 has the `hash` functional object; you may find it in the `<functional>`
    header in the `std::` namespace. Hashing in Boost and standard library is fast
    and reliable. It does not allocate additional memory and also does not have virtual
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may specialize hashing for your own types. In Boost, it is done via specializing
    the `hash_value` function in the namespace of a custom type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is different from standard library specialization of `std::hash`, where
    you are required to make template specialization of the `hash<>` structure in
    the `std::` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Hashing in Boost is defined for all the basic types (such as `int`, `float`,
    `double`, and `char`), for arrays, and for all the standard library containers,
    including `std::array`, `std::tuple`, and `std::type_index`. Some libraries also
    provide hash specializations, for example, the `Boost.Variant` library can hash
    any `boost::variant` classes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read the *Using unordered set and map* recipe in this chapter for more information
    about the hash functions' usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The official documentation of `Boost.Functional/Hash` will tell you how to combine
    multiple hashes and provide more examples; read about it at [http://boost.org/libs/functional/hash](http://boost.org/libs/functional/hash).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an unordered set and map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous recipe, we saw how string comparison can be optimized using
    hashing. After reading it, the following question may arise: can we make a container
    that will cache hashed values to use faster comparison?'
  prefs: []
  type: TYPE_NORMAL
- en: The answer is yes, and we can do much more. We may achieve almost constant search,
    insertion, and removal times for elements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge about C++ and STL containers are required. Reading the previous
    recipe will also help.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This will be the simplest of all recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: All you need to do is just include the `<boost/unordered_map.hpp>` header, if
    you wish to use maps. If we wish to use sets, include the `<boost/unordered_set.hpp>`
    header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, you are free to use `boost::unordered_map` instead of `std::map` and `boost::unordered_set`
    instead of `std::set`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unordered containers store values and remember the hash of each value. Now if
    you wish to find a value in them, they will compute the hash of that value and
    search for that hash in the container. After hash is found, containers check for
    equality of the found value and the searched value. Then, the iterator to the
    value or to the end of container is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Because the container may search for the constant width integral hash value,
    it may use some optimizations and algorithms suitable only for integers. Those
    algorithms guarantee constant search complexity O(1), when traditional `std::set`
    and `std::map` provide worse complexity O(log(N)), where *N* is the number of
    elements in the container. This leads us to a situation where the more the elements
    in traditional `std::set` or `std::map`, the slower it works. However, the performance
    of unordered containers does not depend on the element count.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such good performance never comes free of cost. In unordered containers, values
    are unordered (you are not surprised, are you?). It means that we''ll be elements
    of containers from `begin()` to `end()` will be the output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll get the following output for `std::set` and `boost::unordered_set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'So, how much does the performance differ? Usually, it depends on the implementation
    quality. I''ve got the following numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The performance was measured using for the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The code contains a lot of string constructions, so it is not 100% correct to
    measure the speedup using this test. It is here to show that unordered containers
    are usually faster than ordered ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, a task might arise where we need to use a user-defined type in unordered
    containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To do that, we need to write a comparison operator for that type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to specialize the hashing function for that type. If the type
    consists of multiple fields, we usually just need to combine hashes of all the
    fields that participate in `equality comparisons`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It is highly recommended to combine hashes using the `boost::hash_combine` function.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multiversions of containers are also available, `boost::unordered_multiset`
    is defined in the `<boost/unordered_set.hpp>` header, and `boost::unordered_multimap`
    is defined in the `<boost/unordered_map.hpp>` header. Just like in the case of
    a standard library, multiversions of containers are capable of storing multiple
    equal key values.
  prefs: []
  type: TYPE_NORMAL
- en: All the unordered containers allow you to specify your own hashing functor,
    instead of the default `boost::hash`. They also allow you to specialize your own
    equal comparison functor, instead of the default `std::equal_to`.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++11 has all the unordered containers of the Boost library. You may find them
    in the headers: `<unordered_set>` and `<unordered_map>`, in the `std::` namespace,
    instead of `boost::`. The Boost and the standard library versions may differ in
    performance, but must work in the same way. However, Boost''s unordered containers
    are available even on C++03/C++98 compilers and make use of the rvalue reference
    emulation of `Boost.Move`, so you may use those containers for the move-only classes
    even on pre-C++11 compilers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'C++11 has no `hash_combine` function, so you have to write your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Or just use `boost::hash_combine`.
  prefs: []
  type: TYPE_NORMAL
- en: Since Boost 1.64, unordered containers in Boost have the C++17's functionality
    for extracting and inserting nodes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipe *Using C++11 move emulation* in [Chapter 1](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Starting to Write Your Application*, for more details on rvalue reference emulation
    of `Boost.Move`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about the unordered containers is available on the official
    site at [http://boost.org/libs/unordered](http://boost.org/libs/unordered)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about combining hashes and computing hashes for ranges are
    available at [http://boost.org/libs/functional/hash](http://boost.org/libs/functional/hash)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a map, where value is also a key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several times in a year, we need something that may store and index a pair of
    values. Moreover, we need to get the first part of the pair using the second,
    and get the second part using the first. Confused? Let me show you an example.
    We create a vocabulary class. When the users put values into it, the class must
    return identifiers, and when the users put identifiers into it, the class must
    return values.
  prefs: []
  type: TYPE_NORMAL
- en: To be more practical, users are putting login names in our vocabulary and wish
    to get the unique identifier out of it. They also wish to get all the logins for
    an identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how it can be implemented using Boost.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge about standard library and templates is required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe is about the abilities of the `Boost.Bimap` library. Let''s see
    how it can be used to implement this task:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need the following includes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to make our vocabulary structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be filled using the following syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can work with the left part of it just like with a map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The right part is almost the same as the left:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to ensure that there is such a person in vocabulary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it, now if we put all the code (except includes) inside `int main()`,
    we''ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *step 2*, we define the `bimap` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The first template parameter tells that the first key must have type `std::string`,
    and should work as `std::set`. The second template parameter tells that the second
    key must have type `std::size_t`. Multiple first keys may have a single second
    key value, just like in `std::multimap`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We may specify the underlying behavior of `bimap` using classes from the `boost::bimaps::`
    namespace. We may use hash map as an underlying type for the first key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When we do not specify the behavior of the key and just specify its type, `Boost.Bimap`
    uses `boost::bimaps::set_of` as a default behavior. Just like in our example,
    we may try to express the following code using standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Using standard library it would look like a combination of the following two
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the preceding comments, a call to `name_id.left` (in *step
    4*) returns a reference to something with an interface close to `std::map<std::string,
    std::size_t>`. A call to `name_id.right` from *step 5* returns something with
    an interface close to `std::multimap<std::size_t, std::string>`.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6*, we work with a whole `bimap`, searching for a pair of keys and
    making sure that they are in the container.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unfortunately, C++17 has nothing close to `Boost.Bimap`. Here are some other
    bad news:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Boost.Bimap` does not support rvalue references, and on some compilers, insane
    amount of warnings is shown. Refer to your compilers'' documentation to get the
    information about suppressing specific warnings.'
  prefs: []
  type: TYPE_NORMAL
- en: Good news is that `Boost.Bimap` usually uses less memory than two standard library
    containers and makes searches as fast as standard library containers. It has no
    virtual function calls inside, but uses dynamic allocations.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next recipe, *Using multi-index containers*, will give you more information
    about multi-indexing, and about the Boost library that can be used instead of
    `Boost.Bimap`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the official documentation for more examples and information about `bimap`
    at [http://boost.org/libs/bimap](http://boost.org/libs/bimap)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using multi-index containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous recipe, we made some kind of vocabulary, which is good when
    we need to work with pairs. But, what if we need much more advanced indexing?
    Let''s make a program that indexes persons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We will need a lot of indexes, for example, by name, ID, height, and weight.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge about standard library containers and unordered maps is required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the indexes can be constructed and managed by a single `Boost.Multiindex`
    container.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we need a lot of includes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The hardest part is to construct `multi-index` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we may insert values into our `multi-index`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s construct a function for printing the index content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Print all the indexes as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Some code from the previous recipe can also be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we run our example, it will output the content of indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The hardest part here is a construction of multi-index type using `boost::multi_index::multi_index_container`.
    The first template parameter is a class that we are going to index. In our case,
    it is `person`. The second parameter is a type `boost::multi_index::indexed_by`,
    all the indexes must be described as a template parameter of that class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the first index description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The usage of the `boost::multi_index::ordered_unique` class means that the index
    must work like `std::set` and have all of its members. The `boost::multi_index::identity<person>`
    class means that the index must use the `operator <` of a `person` class for orderings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next table shows the relation between the `Boost.MultiIndex` types and
    the **STL containers**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| The `Boost.MultiIndex` types | STL containers |'
  prefs: []
  type: TYPE_TB
- en: '| `boost::multi_index::ordered_unique` | `std::set` |'
  prefs: []
  type: TYPE_TB
- en: '| `boost::multi_index::ordered_non_unique` | `std::multiset` |'
  prefs: []
  type: TYPE_TB
- en: '| `boost::multi_index::hashed_unique` | `std::unordered_set` |'
  prefs: []
  type: TYPE_TB
- en: '| `boost::multi_index::hashed_non_unique` | `std::unordered_mutiset` |'
  prefs: []
  type: TYPE_TB
- en: '| `boost::multi_index::sequenced` | `std::list` |'
  prefs: []
  type: TYPE_TB
- en: 'Take a look at the second index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `boost::multi_index::hashed_non_unique` type means that the index works
    like `std::set`, and `boost::multi_index::member<person, std::size_t, &person::id_>`
    means that the index must apply the hash function only to a single member field
    of the person structure to `person::id_`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining indexes won''t be a trouble now; so let''s take a look at the
    usage of indexes in the `print` function instead. Getting the type of iterator
    for a specific index is done using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks slightly overcomplicated because `Indexes` is a template parameter.
    The example would be simpler, if we could write this code in the scope of `indexes_t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `nth_index` member metafunction takes a zero-based number of index to use.
    In our example, index 1 is index of IDs, index 2 is index of heights, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at how to use `const_iterator_t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be simplified for `indexes_t` being in scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The function `get<indexNo>()` returns index. We may use that index almost like
    an STL container.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++17 has no multi-index library. The `Boost.MultiIndex` is a fast library that
    uses no virtual functions. The official documentation of `Boost.MultiIndex` contains
    performance and memory usage measures, showing that this library in most cases
    uses less memory than standard library based handwritten code. Unfortunately,
    `boost::multi_index::multi_index_container` does not support C++11 features and
    also has no rvalue references emulation using `Boost.Move`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The official documentation of `Boost.MultiIndex` contains tutorials, performance
    measures, examples, and other `Boost.Multiindex` libraries' description of useful
    features. Read about it at [http://boost.org/libs/multi_index.](http://boost.org/libs/multi_index)
  prefs: []
  type: TYPE_NORMAL
- en: Getting benefits of a single linked list and memory pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, we usually use `std::vector` when we need nonassociative and nonordered
    containers. This is recommended by *Andrei Alexandrescu* and *Herb Sutter* in
    the book *C++ Coding Standards*. Even those users who did not read the book usually
    use `std::vector`. Why? Well, `std::list` is slower and uses much more resources
    than `std::vector`. The `std::deque` container is very close to `std::vector`,
    but does not store values continuously.
  prefs: []
  type: TYPE_NORMAL
- en: If we need a container where erasing and inserting elements does not invalidate
    iterators, then we are forced to choose a slow `std::list`.
  prefs: []
  type: TYPE_NORMAL
- en: But wait, we may assemble a better solution using Boost!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good knowledge about standard library containers is required to understand the
    introduction part. After that, only basic knowledge of C++ and standard library
    containers is required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll be using two Boost libraries at the same time: `Boost.Pool`
    and a single linked list from `Boost.Container`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to describe the type of our list. This can be done as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We can work with our single linked list like with `std::list`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Some list-specific functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Memory must be freed using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we are using `std::list`, we may notice a slowdown because each node of
    the list needs separate allocation. It means that usually when we insert 10 elements
    into `std::list`, the container calls `new` 10 times. Also, the allocated nodes
    usually are located randomly in memory, which is not CPU cache friendly.
  prefs: []
  type: TYPE_NORMAL
- en: That is why we used Boost `::fast_pool_allocator<int>` from `Boost.Pool`. This
    allocator tries to allocate bigger blocks of memory, so that at a later stage,
    multiple nodes could be constructed without multiple calls to `new`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Boost.Pool` library has a drawback--it uses memory for internal needs.
    Usually, additional `sizeof(void*)` is used per element. To workaround that issue,
    we are using a single linked list from `Boost.Containers`.
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::container::slist` class is more compact, but its iterators can iterate
    only forward. *Step 3* is simple for those readers who are aware of standard library
    containers, so we move to *step 4* to see some `boost::container::slist` specific
    features. Since a single linked list iterator could iterate only forward, traditional
    algorithms of insertion and deletion take linear time O(N). That's because when
    we are erasing or inserting, the previous element of the list must be modified.
    To workaround that issue, the single linked list has methods `erase_after` and
    `insert_after` that work for a constant time O(1). These methods insert or erase
    elements right after the current position of the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: However, erasing and inserting values at the beginning of a single linked lists
    makes no big difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a careful look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: It is required because `boost::fast_pool_allocator` does not free memory, so
    we must do it by hand. The *Doing something at scope exit* recipe from [Chapter
    2](part0108.html#36VSO0-712b4ba1126a4c7c89e1d44de61b4bdd), *Managing Resources*,
    may be a help in freeing `Boost.Pool`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the execution times to feel the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As we may see, `slist_t` uses half the memory, and is twice as fast compared
    to the `std::list` class.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Boost.Container` library actually has an out-of-the-box solution, called
    `boost::container::stable_vector`. The latter allows random access to the elements,
    has random access iterators, but has most of the performance and memory usage
    drawbacks of `std::list`.
  prefs: []
  type: TYPE_NORMAL
- en: C++11 has `std::forward_list`, which is very close to `boost::containers::slist`.
    It also has the `*_after` methods, but has no `size()` method. C++11 and Boost
    versions of single linked list have the same performance and neither of them have
    virtual functions. However, the Boosts version is also usable on C++03 compilers,
    and even has support for rvalue references emulation via `Boost.Move`.
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::fast_pool_allocator` is not in C++17\. However, C++17 has a better
    solution! The header `<memory_resource>` contains useful stuff to work with polymorphic
    allocator, and in there you can find `std::pmr::synchronized_pool_resource`, `std::pmr::unsynchronized_pool_resource`,
    and `std::pmr::monotonic_buffer_resource`. Experiment with those to achieve even
    better performance.
  prefs: []
  type: TYPE_NORMAL
- en: Guessing why `boost::fast_pool_allocator` does not free the memory by itself?
    That's because C++03 has no stateful allocators, so the containers are not copying
    and storing allocators. That makes it impossible to implement a `boost::fast_pool_allocator`
    function that deallocates memory by itself.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The official documentation of `Boost.Pool` contains more examples and classes
    to work with memory pools. Follow the link [http://boost.org/libs/pool](http://boost.org/libs/pool)
    to read about it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using flat associative containers* recipe will introduce you to some more
    classes from `Boost.Container`. You can also read the official documentation of
    `Boost.Container` at [http://boost.org/libs/container](http://boost.org/libs/container)
    to study that library by yourself or to get full reference documentation of its
    classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Vector vs List*, and other interesting topics from *Bjarne Stroustrup*, the
    inventor of C++ programming language, can be found at [http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup-Cpp11-Style](http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup-Cpp11-Style)
    site.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using flat associative containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After reading the previous recipe, some of the readers may start using fast
    pool allocators everywhere; especially, for `std::set` and `std::map`. Well, I''m
    not going to stop you from doing that, but at least let''s take a look at an alternative:
    flat associative containers. These containers are implemented on top of the traditional
    vector container and store the values ordered.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic knowledge about standard library associative containers is required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The flat containers are part of the `Boost.Container` library. We already saw
    how to use some of its containers in the previous recipes. In this recipe, we''ll
    be using a `flat_set` associative container:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need to include only a single header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we are free to construct the flat container and experiment with
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Reserving space for elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Filling the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can work with it just like with `std::set`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Steps 1* and *2* are simple, but *step 3* requires attention. It is one of
    the most important steps while working with flat associative containers and `std::vector`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::container::flat_set` class stores its values ordered in vector,
    which means that any insertion or deletion of elements not on the end on the container
    takes liner time O(N), just like in case of `std::vector`. This is a necessary
    evil. But for that, we gain almost three times less memory usage per element,
    more processor cache friendly storage, and random access iterators. Take a look
    at *step 5*, `5.1`, where we were getting the distance between two iterators returned
    by calls to the `lower_bound` member functions. Getting distance with flat set
    takes constant time O(1), while the same operation on iterators of `std::set`
    takes linear time O(N). In case of `5.1`, getting the distance using `std::set`
    would be 400 times slower than getting the distance for flat set containers.
  prefs: []
  type: TYPE_NORMAL
- en: Back to *step 3*. Without reserving memory, insertion of elements may become
    at times slower and less memory efficient. The `std::vector` class allocates the
    required chunk of memory and then in-place construct elements on that chunk. When
    we insert some element without reserving the memory, there is a chance that there
    is no free space remaining on the preallocated chunk of memory, so `std::vector`
    allocates a bigger chunk of memory . After that, `std::vector` copies or moves
    elements from the first chunk to the second, deletes elements of the first chunk,
    and deallocates the first chunk. Only after that, insertion occurs. Such copying
    and deallocation may occur multiple times during insertions, dramatically reducing
    the speed.
  prefs: []
  type: TYPE_NORMAL
- en: If you know the count of elements that `std::vector` or any flat container must
    store, reserve the space for those elements before insertion. This speeds up the
    program in most cases!
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 4* is simple, we are inserting elements here. Note that we are inserting
    ordered elements. This is not required, but recommended to speed up insertion.
    Inserting elements at the end of `std::vector` is much more cheaper than in the
    middle or at the beginning.'
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, `5.2` and `5.3` do not differ much, except in their execution speed.
    Rules for erasing elements are pretty much the same as for inserting them. See
    the preceding paragraph for explanations.
  prefs: []
  type: TYPE_NORMAL
- en: May be I'm telling you simple things about containers, but I saw some very popular
    products that use features of C++11, have insane amount of optimizations and lame
    usage of standard library containers, especially `std::vector`.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, `5.4` shows you that the `std::lower_bound` function works faster
    with `boost::container::flat_set` than with `std::set`, because of random access
    iterators.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, `5.5` also shows you the benefit of random access iterators.
  prefs: []
  type: TYPE_NORMAL
- en: We did not use the `std::find` function here. This is because that function
    takes liner time O(N), while the member `find` functions take logarithmic time
    O(log(N)).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When should we use flat containers, and when should we use usual ones? Well,
    it''s up to you, but here is a list of differences from the official documentation
    of `Boost.Container` that will help you to decide:'
  prefs: []
  type: TYPE_NORMAL
- en: A faster lookup than standard associative containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Much faster iteration than standard associative containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less memory consumption for small objects (and for big objects if `shrink_to_fit`
    is used)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved cache performance (data is stored in contiguous memory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nonstable iterators (iterators are invalidated when inserting and erasing elements)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-copyable and non-movable value types can't be stored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weaker exception safety than standard associative containers (copy/move constructors
    can throw an exception when shifting values in erasures and insertions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slower insertion and erasure than standard associative containers (specially
    for non-movable types)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++17 unfortunately has no flat containers. Flat containers from Boost are fast,
    have a lot of optimizations, and do not use virtual functions. Classes from `Boost.Containers`
    have support of rvalue reference emulation via `Boost.Move`, so you are free to
    use them even on C++03 compilers.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Getting benefits of single linked list and memory pool* recipe
    for more information about `Boost.Container`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recipe *Using C++11 move emulation* in [Chapter 1](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Starting to Write Your Application*, will give you the basics of emulation rvalue
    references on C++03 compatible compilers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: "The official documentation of `Boost.Container` contains a lot of useful information\
    \ about `Boost.Container` and full reference of each class. Read about it at [http://boost.org/libs/container.\uFEFF\
    ](http://boost.org/libs/container)"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
