- en: Chapter 1. Tasting Functional Style in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming is a style of constructing the elements and structure
    of computer program which treats computations like evaluations in mathematical
    functions. Although there are some specifically designed languages for creating
    functional programming, such as Haskell or Scala, we can also use C# to accomplish
    designing functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first chapter of this book, we are going to explore the functional programming
    by testing it. We will use the power of C# to construct some functional code.
    We will also deal with the features in C# that are mostly used in developing functional
    programs. By the end of this chapter, we will have an idea of what the functional
    approach in C# will be like. Here are the topics we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to functional programming concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison between the functional and imperative approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concepts of functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the mathematical approach to understand functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring imperative code to functional code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantages and disadvantages of functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In functional programming, we write functions without side effects the way we
    write in Mathematics. The variable in the code function represents the value of
    the function parameter, and it similar to the mathematical function. The idea
    is that a programmer defines the functions that contain the expression, definition,
    and the parameters that can be expressed by a variable in order to solve problems.
  prefs: []
  type: TYPE_NORMAL
- en: After a programmer builds the function and sends the function to the computer,
    it's the computer's turn to do its job. In general, the role of the computer is
    to evaluate the expression in the function and return the result. We can imagine
    that the computer acts like a calculator since it will analyze the expression
    from the function and yield the result to the user in a printed format. The calculator
    will evaluate a function which are composed of variables passed as parameters
    and expressions which form the body of the function. Variables are substituted
    by their values in the expression. We can give simple expression and compound
    expressions using algebraic operators. Since expressions without assignments never
    alter the value, sub expressions needs to be evaluated only once.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have the expression `3 + 5` inside a function. The computer will
    definitely return `8` as the result right after it completely evaluates it. However,
    this is just a simple example of how the computer acts in evaluating an expression.
    In fact, a programmer can increase the ability of the computer by creating a complex
    definition and expression inside the function. Not only can the computer evaluate
    the simple expression, but it can also evaluate the complex calculation and expression.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding definitions, scripts, and sessions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we discussed earlier about a calculator that will analyze the expression
    from the function, let''s imagine we have a calculator that has a console panel
    like a computer does. The difference between that and a conventional calculator
    is that we have to press ***Enter*** instead of ***=*** (equal to) in order to
    run the evaluation process of the expression. Here, we can type the expression
    and then press ***Enter*** . Now, imagine that we type the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately after pressing ***Enter*** , the computer will print `27` in the
    console, and that''s what we are expecting. The computer has done a great job
    of evaluating the expression we gave. Now, let''s move to analyzing the following
    definitions. Imagine that we type them on our functional calculator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have defined the two definitions, `square` and `max` . We can call the list
    of definitions script. By calling the `square` function followed by any number
    representing variable `a` , we will be given the square of that number. Also,
    in the `max` definition, we serve two numbers to represent variables `a` and `b`
    , and then the computer will evaluate this expression to find out the biggest
    number between the variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'By defining these two definitions, we can use them as a function, which we
    can call session, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The computer will definitely print `9` after evaluating the preceding function.
    The computer will also be able to evaluate the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It will return `2` as the result based on the definition we defined earlier.
    This is also possible if we provide the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Then, `25` will be displayed in our calculator console panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also modify a definition using the previous definition. Suppose we want
    to quadruple an integer number and take advantage of the definition of the `square`
    function; here is what we can send to our calculator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first line of the preceding expression is a definition of the `quad` function.
    In the second line, we call that function, and we will be provided with `10000`
    as the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script can define the variable value; for instance, take a look at the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we should expect the computer to be able to evaluate the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using substitution and simplification to evaluate the expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using a mathematical method called **reduction** , we can evaluate expressions
    by substitution variables or expressions to simplify the expressions until no
    more substitution on reduction is possible. Let''s take our preceding expression,
    `square (1 + 2)` , and look at the following reduction process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, we have the symbol `->` to indicate the reduction. From the sequence,
    we can discover the reduction process-in other words, the evaluation process.
    In the first line, the computer will run the `1 + 2` expression and substitute
    it with `3` in order to reduce the expression. Then, it will reduce the expression
    in the second line by simplifying `square 3` to `3 x 3` expressions. Lastly, it
    will simplify `3 x 3` and substitute it with `9` , which is the result of that
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, an expression can have more than one possibility in the reduction.
    The preceding reduction process is one of the possibilities of a reduction process.
    We can also create other possibilities, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding sequence, firstly, we can see that the rule for a square is
    applied. The computer then substitutes `1 + 2` in line 2 and line 3\. Lastly,
    it multiplies the number in the expression.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding two examples, we can conclude that the expression can be
    evaluated using simple substitution and simplification, the basic rule of mathematics.
    We can also see that the expression is a representation of the value, not the
    value itself. However, the expression will be in the normal form if it can't be
    reduced anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the functions used for functional programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functional programming uses a technique of emphasizing functions and their
    application instead of commands and their execution. Most values in functional
    programming are function values. Let''s take a look at the following mathematical
    notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding notation, we can say that function `f` is a relation of each
    element stated there, which is `A` and `B` . We call `A` , the source type, and
    `B` , the target type. In other words, the notation of `A -> B` states that `A`
    is an argument where we have to input the value, and `B` is a return value or
    the output of the function evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider that `x` denotes an element of `A` and `x + 2` denotes an element
    of `B` , so we can create the mathematical notation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In mathematics, we use `f(x)` to denote a functional application. In functional
    programming, the function will be passed as an argument and will return the result
    after the evaluation of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can construct many definitions for one and the same function. The following
    two definitions are similar and will triple the input passed as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, `triple` and `triple'` have different expressions. However, they
    are the same functions, so we can say that `triple` = `triple'` . Although we
    have many definitions to express one function, we will find that there is only
    one definition that will prove to be the most efficient in the procedure of evaluation
    in the sense of the reducing the expression we discussed previously. Unfortunately,
    we cannot determine which one is the most efficient from our preceding two definitions
    since that depends on the characteristic of the evaluation mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Forming the definition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s go back to our discussion on definitions at the beginning of this
    chapter. We have the following definition in order to retrieve the value from
    the case analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two expressions in this definition, distinguished by a Boolean-value
    expression. This distinguisher is called guards, and we use them to evaluate the
    value of `True` or `False` . The first line is one of the alternative result values
    for this function. It states that the return value will be `a` if the expression
    `a >= b` is `True` . In contrast, the function will return value `b` if the expression
    `b >= a` is `True` . Using these two cases, `a >= b` and `b >= a` , the `max`
    value depends on the value of `a` and `b` . The order of the cases doesn''t matter.
    We can also define the `max` function using the special word `otherwise` . This
    word ensures that the otherwise case will be executed if no expression results
    in a True value. Here, we will refactor our max function using the word `otherwise`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding function definition, we can see that if the first expression
    is `False` , the function will return `b` immediately without performing any evaluation.
    In other words, the otherwise case will always return `True` if all previous guards
    return `False` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Another special word usually used in mathematical notations is `where` . This
    word is used to set the local definition for the expression of the function. Let''s
    take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have a function `f` with variable `z` , whose
    value is determined by `x` and `y` . There, we introduce a local `z` definition
    to the function. This local definition can also be used along with the case analysis
    we have discussed earlier. Here is an example of the conjunction local definition
    with the case analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding function, there is a local `z` definition, which qualifies
    for both `x + z` and `x - z` expressions. As we discussed earlier, although the
    function has two equal to (`=` ) signs, only one expression will return the value.
  prefs: []
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Currying is a simple technique of changing structure arguments by sequence.
    It will transform a n-ary function into n unary function. It is a technique which
    was created to circumvent limitations of Lambda functions which are unary functions.
    Let''s go back to our max function again and get the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that there is no bracket in the `max a b` function name. Also, there
    is no comma-separated `a` and `b` in the function name. We can add a bracket and
    a comma to the function definition, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'At first glance, we find the two functions to be the same since they have the
    same expression. However, they are different because of their different types.
    The `max''` function has a single argument, which consists of a pair of numbers.
    The type of `max''` function can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the `max` function has two arguments. The type of this function
    can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The max function will take a number and then return a function from single number
    to many numbers. From the preceding max function, we pass the variable `a` to
    the `max` function, which returns a value. Then, that value is compared to variable
    `b` in order to find the maximum number.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison between functional and imperative programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main difference between functional and imperative programming is that imperative
    programming produces side effects while functional programming doesn't. In imperative
    programming, the expressions are evaluated and its resulting value is assigned
    to variables. So, when we group series of expressions into a function, the resulting
    value depends upon the state of variables at that point in time. This is called
    side effects. Because of the continuous changes in state, the order of evaluation
    matters. In functional programming world, destructive assignment is forbidden
    and each time an assignment happens a new variable is induced.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the C# compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the rest of the discussion in this chapter, we are going to create some
    code in C#. In order we have the same environment, let's define what we will use
    in configuration settings. We will use Visual Studio 2015 Community Edition and
    .NET Framework 4.6.2 in all of the source code we discuss in this book. We will
    also choose the console application project in order to ease the development of
    our code since it doesn't need many changes to the settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the screenshot of the setting in creating Visual Studio projects we
    will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the C# compiler](img/Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we are discussing a source code that has a `csproj` filename-for instance,
    `FuncObject.csproj` -we can find it in one of solution files provided in the sample
    code. It will be in the `Program.cs` file. The following is a screenshot of the
    structure of the project in Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the C# compiler](img/Image00002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, sometimes, we have more than one `.cs` file inside the project file.
    In this case, we can find the code we are discussing in one of the `.cs` files
    inside the project file. For instance, we have a project file named `FunctionalCode.csproj`
    . So, when we discuss any source code related to this project file, we can find
    it from the `.cs` files inside the project file. The structure of a project file
    consisting of more than one `.cs` files is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the C# compiler](img/Image00003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, inside the `FunctionalCode.csproj` file, not only do we have
    the `Program.cs` file, but also `Disposable.cs` , `FunctionalExtension.cs` , `StringBuilderExtension.cs`
    , and `Utility.cs` .
  prefs: []
  type: TYPE_NORMAL
- en: We will also find the `partial` keyword to the classes name in most of our code
    even though we write the classes in the same file. The purpose is to make the
    code snippet in this book easy to find in the sample code. By knowing the class
    name, it will be easier to find the source code in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We also need to install Visual Studio Community 2017 RC since we will use a
    new feature of C# 7 in [Chapter 9](text00057.html#ch09 "Chapter 9. Working with
    Pattern") , *Working with Pattern* .
  prefs: []
  type: TYPE_NORMAL
- en: Concepts of functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can also distinguish functional programming from imperative programming by
    the concepts. The core ideas of functional programming are encapsulated in the
    constructs such as first class functions, higher order functions, purity, recursion
    over loops, and partial functions. We will discuss the concepts in this topic.
  prefs: []
  type: TYPE_NORMAL
- en: First-class and higher-order functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In imperative programming, the given data is more important and are passed through
    series of functions (with side effects). Functions are special constructs with
    their own semantics. In effect, functions do not have the same place as variables
    and constants. Since a function cannot be passed as a parameter or returned as
    a result, they are regarded as second class citizens of the programming world.
    In the functional programming world, we can pass a function as a parameter and
    return function as a result. They obey the same semantics as variables and their
    values. Thus, they are first class citizens. We can also create function of functions
    called second order function through composition. There is no limit imposed on
    the composability of functions and they are called higher order functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the C# language supports these two concepts since it has a feature
    called function object, which has types and values. To discuss more details about
    the function object, let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can find the code in `FuncObject.csproj` , and if we run it, it will display
    the following output on the console screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First-class and higher-order functions](img/Image00004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Why do we display it? Let's continue the discussion on function types and function
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hit ***Ctrl*** + ***F5*** instead of ***F5*** in order to run the code in debug
    mode but without the debugger. It's useful to stop the console from closing on
    the exit.
  prefs: []
  type: TYPE_NORMAL
- en: Function types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with other objects in C#, function objects have a type as well. We can initialize
    the types in the function declaration. Here is the syntax to declare function
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have `T1` until `T16` , which are the types that correspond to
    input parameters, and `TResult` is a type that corresponds to the return type.
    If we need to convert our previous mathematical function, `f(x) = x + 2` , we
    can write it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We now have a function `f` , which has one argument-typed integer and the integer
    return type as well. Here, we use a lambda expression to define a delegate to
    be assigned to the object named `f` with the `Func` type. Don't worry if you are
    not familiar with delegate and lambda expressions yet. We will discuss them further
    in our next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Function values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To assign a value to function variable, there are the following possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A function variable can be assigned to an existing method inside a class by
    its name using a reference. We can use delegate as reference. Let''s take a look
    at the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code, we assign `da` variable to existing `Double()`
    method using `delegate` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A function variable can be assigned to an anonymous function using a lambda
    expression. Let''s look at the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `da` variable is assigned using lambda expression and we
    can use the `da` variable like we use in previous code snippet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we have a function variable and can assign a variable-integer-typed variable,
    for instance, to this function variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the preceding code, the value of variable `i` will be `3` since
    we pass `1` as the argument, and it will return `1 + 2` . We can also assign the
    function variable with another function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We assign a new function, `2 * x + 1` , to variable `f` , so we will retrieve
    `3` if we run the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the functional programming, most of the functions do not have side effects.
    In other words, the function doesn''t change any variables outside the function
    itself. Also, it is consistent, which means that it always returns the same value
    for the same input data. The following are example actions that will generate
    side effects in programming:'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying a global variable or static variable since it will make a function
    interact with the outside world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying the argument in a function. This usually happens if we pass a parameter
    as a reference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raising an exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking input and output outside-for instance, get a keystroke from the keyboard
    or write data to the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although it does not satisfy the rule of a pure function, we will use many `Console.WriteLine()`
    methods in our program in order to ease our understanding in the code sample.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the sample non-pure function that we can find in `NonPureFunction1.csproj`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding code, as expected, the following result will be displayed
    on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pure functions](img/Image00005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this code, we modify the `strValue` global variable inside the `AddSpace`
    function. Since it modifies the variable outside, it's not considered a pure function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at another non-pure function example in `NonPureFunction2.csproj`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We see the `AddSpace` function again but this time with the addition of an argument-typed
    `StringBuilder` argument. In the function, we modify the `sb` argument with `hyphen`
    and `str` . Since we pass the `sb` variable by reference, it also modifies the
    `sb1` variable in the `Main` function. Note that it will display the same output
    as `NonPureFunction2.csproj` .
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert the preceding two examples of non-pure function code into pure function
    code, we can refactor the code to be the following. This code can be found at
    `PureFunction.csproj` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Running `PureFunction.csproj` , we will get the same output compared to the
    two previous non-pure function code. However, in this pure function code, we have
    three variables in the `Main` function. This is because in functional programming,
    we cannot modify the variable we have initialized earlier. In the `AddSpace` function,
    instead of modifying the global variable or argument, it now returns a string
    value to satisfy the the functional rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the advantages we will have if we implement the pure function
    in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: Our code will be easy to be read and maintain because the function does not
    depend on external state and variables. It is also designed to perform specific
    tasks that increase maintainability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The design will be easier to be changed since it is easier to refactor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing and debugging will be easier since it's quite easy to isolate the pure
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursive functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an imperative programming world, we have got destructive assignments to mutate
    the state if a variable. By using loops, one can change multiple variables to
    achieve the computational objective. In the functional programming world, since
    variables cannot be destructively assigned, we need a recursive function call
    to achieve the objective of looping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a factorial function. In mathematical terms, the factorial of
    the nonnegative integer `N` is the multiplication of all positive integers less
    than or equal to `N` . This is usually denoted by `N!` . We can denote the factorial
    of `7` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look deeper at the preceding formula, we will discover that the pattern
    of the formula is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*N! = N * (N-1) * (N-2) * (N-3) * (N-4) * (N-5) ...*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the following factorial function in C#. It''s an
    imperative approach and can be found in the `RecursiveImperative.csproj` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we invoke the `GetFactorial()` function from the `GetFactorial()`
    function itself. This is what we call a recursive function. We can use this function
    by creating a `Main()` method containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We invoke the `GetFactorial()` method and pass our desired number to the argument.
    The method will then multiply our number with what's returned by the `GetFactorial()`
    method, in which the argument has been subtracted by 1\. The iteration will last
    until `intNumber - 1` is equal to 0, which will return 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s compare the preceding recursive function in the imperative approach
    with one in the functional approach. We will use the power of the `Aggregate`
    operator in the LINQ feature to achieve this goal. We can find the code in the
    `RecursiveFunctional.csproj` file. The code will look like what is shown in the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We initialize the `ints` variable, which contains a value from 1 to our desired
    integer number in the preceding code, and then we iterate `ints` using the `Aggregate`
    operator. The output of `RecursiveFunctional.csproj` will be completely the same
    compared to the output of `RecursiveImperative.csproj` . However, we use the functional
    approach in the code in `RecursiveFunctional.csproj` .
  prefs: []
  type: TYPE_NORMAL
- en: Feeling functional in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will discuss about functional programming in C#. We will be discussing
    both the conceptual aspects of functional programming and write code in C#, as
    well. We will be kick-starting the discussion by discussing about currying, pipelining,
    and method chaining.
  prefs: []
  type: TYPE_NORMAL
- en: Using mathematical concept to understand functional approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In functional programming, functions behave the way a mathematical function
    behaves by returning the same value for a given argument regardless of the context
    in which it is invoked. This is called **Referential Transparency** . To understand
    this in more detail, consider that we have the following mathematical function
    notation, and we want to turn it into functional programming in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '*f(x) = 4x² -14x-8*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The functional programming in C# is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding function, which we can find in the `FunctionF.csproj` file,
    if `x` is 5, we will obtain `f` of 5, which is 22\. The notation will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*f(5) = 22*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also invoke the `f` function in C#, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Every time we run the function with 5 as the argument, which means that `x`
    is equal to 5, we always receive 22 as the return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, compare this with the imperative approach. Let''s take a look at the following
    code, which will be stored in the `ImperativeApproach.csproj` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We describe the following code in the `Main()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run `ImperativeApproach.csproj` , the console screen should be like what
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using mathematical concept to understand functional approach](img/Image00006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding imperative approach code, we will get the different `i` output
    in every invocation of `increment` or `set` although we pass the identical argument.
    Here, we find the so-called side effect problem of the imperative approach. The
    `increment` or `set` functions are said to have a side effect since they modify
    the state of `i` and interact with the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: 'That was about side effects, and now, we have the following code in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is statement style code, and we can find it in the `StatementStyle.csproj`
    file. It is an imperative programming technique that defines actions rather than
    producing results. We tell the computer what to do. We ask the computer to compare
    the value of the `value` variable with zero and then assign the `posOrNeg` variable
    to the associated value. We can try the preceding function by adding the following
    code to the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output in the console will be as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using mathematical concept to understand functional approach](img/Image00007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And it agrees with our preceding discussion.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can turn it into a functional approach by modifying it to expression style
    code. In C#, we can use the conditional operator to achieve this goal. The following
    is the code we have refactored from the `StatementStyle.csproj` code, and we can
    find it in the `ExpressionStyle.csproj` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now we have compact code that has the same behavior as our preceding many lines
    of code. However, as we discussed previously, the preceding code has no side-effect
    since it only returns the string value with no need to prepare the variable first.
    While in the statement style approach, we have to assign the `posOrNeg` variable
    twice. In other words, we can say that the functional approach will produce a
    side-effect-free function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast to imperative programming, in functional programming, we describe
    what we want as the result rather than specifying how to receive the result. Suppose
    we have a list of data and want to create a new list containing the *Nth* element
    from the source list. The imperative approach to achieve this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be found in the `NthElementImperative.csproj` file.
    As we can see, to retrieve the Nth element from the list in C#, we have to initialize
    the first element so that we define `i` as `0` . We then iterate through the list
    element and decide whether the current element is the Nth element. If so, we add
    `newList` the new data from the source list. Here, we find that the preceding
    source code is not a functional approach because the `newList` variable is assigned
    more than once when adding the new data. It also contains the loop process, which
    the functional approach doesn''t have. However, we can turn the code into a functional
    approach as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we have compact code in the functional approach since we are using the
    power of the LINQ feature. If we want to try the preceding two functions, we can
    inset the following code to the `Main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `PrintIntList()` method, the implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Although we run the two functions with different approaches, we are still given
    the same output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using mathematical concept to understand functional approach](img/Image00008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Applying tuple for functional C#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In .NET Framework 4, Tuples is introduced as a new set of generic classes to
    store a set of different typed elements. Tuples is immutable so it can be applied
    to functional programming. It is used to represent a data structure when we need
    the different data type in an object. Here is the available syntax to declare
    tuple objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding syntaxes, we can create a tuple with a maximum
    eight item type (`T1` , `T2` , and so on). `Tuple` has read-only properties that’s
    why it’s immutable. Let’s look at the following code snippet we can find in `Tuple.csproj`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To create Tuple, we have two different ways based on the preceding code. The
    former, we instantiate a new Tuple to a variable. The latter, we use `Tuple.Create()`
    . To consume the Tuple data, we can use its Item like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run `ConsumeTuple()` method above, we will get the following on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying tuple for functional C#](img/Image00009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also return a tuple data type like we do in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, `GetSize()` method will return Tuple data type. We can add the
    following `ReturnTuple()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: And if we run `ReturnTuple()` method above, we will be displayed exactly same
    output as `ConsumeTuple()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, in C# 7, we can return Tuple data type without having to state
    the Tuple like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we want to name all items in the Tuple, we can now do it in C# 7 by
    using the technique like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'And now it will be clearer when we access the Tuple items like the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We no longer call the `Item1` and `Item2` , instead we call the x and y name.
  prefs: []
  type: TYPE_NORMAL
- en: In order to gain all new feature of Tuple in C# 7, we have to download `System.ValueTuple`
     NuGet package from [https://www.nuget.org/packages/System.ValueTuple](https://www.nuget.org/packages/System.ValueTuple)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Currying in C#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have theoretically discussed currying at the beginning of this chapter.
    We apply currying when we split a function that takes multiple arguments into
    a sequence of functions that occupy part of the argument. In other words, when
    we pass fewer arguments into a function, it will expect that we get back another
    function to complete the original function using the sequence of functions. Let''s
    take a look at the following code from the `NonCurriedMethod.csproj` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function will add the `a` and `b` arguments and then return the
    result. The usage of this function is commonly used in our daily programming;
    for instance, take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s move on to the curried method. The code will be found in the `CurriedMethod.csproj`
    file, and the function declaration will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `Func<>` delegate to create the `CurriedAdd()` method. We can invoke
    the preceding method in two ways, and the first is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding invocation of the `CurriedAdd()` method, we pass the argument
    with two brackets, which it might not be familiar with. In fact, we can also curry
    our `CurriedAdd()` method by passing one argument only. The code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we supply one argument to the `CurriedAdd()` method
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it waits for the other `addition` expression, which we provide in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The result of the preceding code will be completely the same as the `NonCurried()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Pipelining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pipelining is a technique used to pass the output of one function as an input
    to the next function. The data in the operation will flow like the flow of water
    in a pipe. We usually find this technique in command-line interfaces. Let''s take
    a look at the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command line will pass the output of the `dir` command to the
    input of the `more` command. Now, let''s take a look at the following C# code
    that we can find in the `NestedMethodCalls.csproj` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, we used the nested method calls technique to write `pipelining`
    in console screen. If we want to refactor it to the pipelining approach, we can
    take a look at the following code that we can find in the `Pipelining.csproj`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: If run the preceding code, we will get exactly the same pipelining output, but
    this time, it will be in the pipelining style.
  prefs: []
  type: TYPE_NORMAL
- en: Method chaining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Method chaining is process of chaining multiple methods in one code line. The
    return from one method will be the input of the next method, and so on. Using
    method chaining, we don''t need to declare many variables to store every method
    return. Instead, the return of the method will be passed to the next method argument.
    The following is the traditional method, which doesn''t apply method chaining,
    and we can find the code at `TraditionalMethod.csproj` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'There are five methods of `StringBuilder` invoked inside the `Main` function
    and two variables: `sb` is used to initialize `StringBuilder` and `str` is used
    to store `StringBuilder` in the string format. Unfortunately, the five methods
    we invoked there modify the `sb` variable. We can refactor the code to apply method
    chaining in order to make it functional. The following is the functional code,
    and we can find it at `ChainingMethod.csproj` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The same output will be displayed if we run both types of code. However, we
    now have functional code by chaining all the invoking methods.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming imperative code to functional code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will transform imperative code to functional code by leveraging
    method chaining. Suppose we want to create an HTML-ordered list containing the
    list of the planets in our solar system; the HTML will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The imperative code approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to list the name of planets, including the Sun. We will also mark
    the order of the planets with the value attribute in each `li` element. The preceding
    HTML code will be displayed in the console. We will create the list in `ImperativeCode.csproj`
    ; here you go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Main()` method, we create a byte array, buffer, containing the planet
    stream we generate in other classes. The code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that there is a class named `Utility` , containing the `GeneratePlanetStream()`
    method. This method is used to generate the list of planets in the solar system
    in a stream format. Let''s take a look at the following code in order to find
    what is inside the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, it creates a variable named `planets` , containing eight planets named
    separately on a new line. We get the bytes of the ASCII using the `GetBytes` method,
    and then it is converted into a stream. This stream will be returned to the caller
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main` function, we also have variable options, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This will create a dictionary-typed variable, which contains the name of the
    planet and its order in the solar system. We use LINQ here, but we will discuss
    it deeper in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we invoke the `GenerateOrderedList()` method inside the `Utility` class.
    This method is used to generate an HTML-ordered list containing the order of the
    planets in the solar system. The code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'If we take a look at the `GenerateOrderedList()` method, we will find the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'First, in this method, we create a `StringBuilder` function named `html` and
    add an opening `ol` tag, which means an *ordered list* . The code snippet is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have Boolean variable, `includeSun` , to define whether we need to
    include Sun in the list. We get the value of this variable from the argument of
    the method. After that, we iterate the content of the dictionary we get from argument.
    This dictionary is generated by LINQ in the `Main()` method. We list the content
    by adding the `li` tag. The `foreach` keyword is used to achieve this goal. Here
    is the code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: We can see that `AppendFormat` in the `StringBuilder` class is similar to `String.Format`
    , and we can pass `Key` and `Value` from dictionary. Do not forget to insert a
    new line for each `li` tag using the `AppendLine` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we close the `ol` tag with the `</ol>` tag, which we define in the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Then, we invoke the `ToString()` method to get a bunch of strings from `StringBuilder`
    . Now if we run the code, we will get the output on the console screen, as we
    discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The functional code approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already developed imperative code in order to construct an HTML-ordered
    list of planet names, as discussed earlier. Now, from this imperative code, we
    are going to refactor it to functional code using method chaining. The functional
    code we build will be at `FunctionalCode.csproj` .
  prefs: []
  type: TYPE_NORMAL
- en: The GenerateOrderedList() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We start with the `GenerateOrderedList()` method since we will modify its first
    three lines. It looks like the following in `ImperativeCode.csproj` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We can refactor the preceding code to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The code becomes more natural now since it applies method chaining. However,
    we are still able to join the `AppendFormat()` method with the `AppendLine()`
    method in order to make it simple. To achieve this goal, we need help from method
    extension. We can create a method extension for `StringBuilder` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, because we have the `AppendFormattedLine()` method in the `StringBuilder`
    class, we can refactor our previous code snippet to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The code snippet becomes much simpler than earlier. We also have the invocation
    of `AppendFormat()` following `AppendLine()` inside the `foreach` loop, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, we can also refactor the preceding code snippet using the `AppendFormattedLine()`
    function we added inside the `StringBuilder` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have `AppendLine()` inside the conditional keyword `if` . We also
    need to refactor it to apply method chaining using the extension method. We can
    create the extension method for `StringBuilder` named `AppendLineWhen()` . The
    use of this method is to compare the condition we provide, and then it should
    decide whether or not it needs to be written. The extension method will be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we now have the `AppendLineWhen()` method, we can chain it to the previous
    code snippet, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, we are now confident about removing the following code from the `GenerateOrderedList()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also able to make the `AppendLineWhen()` method more general so that
    it not only accepts a string, but also takes a function as an argument. Let''s
    modify the `AppendLineWhen()` method to the `AppendWhen()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the function now takes `Func<StringBuilder, StringBuilder> fn`
    as an argument to replace the string value. So, it now uses the function to decide
    the conditional with `fn(@this)` . We can refactor `var html` again with our new
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We have chained two methods so far; they are `AppendFormattedLine()` and `AppendWhen()`
    methods. The remaining function we have is `foreach` loop that we need to chain
    to the `StringBuilder` object named `html` . For this purpose, we create an extension
    method to a `StringBuilder` named `AppendSequence()` again, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: We use the `IEnumerable` interface to make this function iterate over the sequence.
    It also invokes the `Aggregate` method in `IEnumerable` as an accumulator that
    counts the increasing sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, using `AppendSequence()` , we can refactor the `foreach` loop and chain
    the methods to `var html` , as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AppendSequence()` method we add takes the options variable as the dictionary
    input and function of `sb` and `opt` . This method will iterate the dictionary
    content and then append the formatted string into `StringBuilder sb` . Now, the
    following `foreach` loop can be removed from the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is the `html.AppendLine("</ol>")`  function invocation we want to chain
    to the `var html`  variable. This is quite simple because we just need to chain
    it without making many changes. Now let''s take a look at a change in the `var
    html` assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code, we refactor the `AppendLine()` method,
    so it is now chained to the `StringBuilder` declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `GenerateOrderedList()` method, we have the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also refactor the line so that it will be chained to the `StringBuilder`
    declaration in `var html` . If we chain it, we will have the following `var html`
    initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, if we compile the code now, it will yield the *CS0161* error
    with the following explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The error occurs because the method doesn''t return any value when it''s expected
    to return a string value. However, since it is functional programming, we can
    refactor this method in an expression member. The complete `GenerateOrderedList()`
    method will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: We have removed the `return` keyword from the preceding code. We have also removed
    the `html` variable. We now have a function that has bodies as lambda-like expressions
    instead of statement blocks. This feature was announced in .NET Framework 4.6.
  prefs: []
  type: TYPE_NORMAL
- en: The Main() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Main()` method in `FunctionalCode.csproj` is a typical method we usually
    face when programming in C#. The method flow is as follows: it reads data from
    the stream into the byte array and then converts those bytes into strings. After
    that, it performs a transformation to modify that string before passing it to
    the `GenerateOrderedList()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the starting code lines, we get the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to refactor the preceding code to be able to be chained. For this purpose,
    we create a new class named `Disposable` , containing the `Using()` method. The
    `Using()` method inside the `Disposable` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding `Using()` method, we take two arguments: `factory` and `fn`
    . The function to which the `IDisposable` interface applies is `factory` , and
    `fn` is the function that will be executed after declaring the `factory` function.
    Now we can refactor the starting lines in the `Main()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Compared to imperative code, we have now refactored the code that reads the
    stream and stores it in a byte array with the help of the `Dispose.Using()` method.
    We ask the lambda stream function to return the buff content. Now, we have a buffer
    variable to be passed to the next phase, which is the `UTF8.GetString(buffer)`
    method. What we actually do in the `GetString(buffer)` method is transforming
    and then mapping the buffer to a string. In order to chain this method, we need
    to create the `Map` method extension. The method will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we need to make it a general method, we use a generic type in the arguments
    of the method. We also use a generic type in the returning value so that it won''t
    return only the string value. Using the generic types, this `Map` extension method
    will be able to transform any static type value into another static type value.
    We need to use an expression body member for this method, so we use the lambda
    expression here. Now we can use this `Map` method for the `UTF8.GetString()` method.
    The `var buffer` initialization will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'By applying the `Map` method like the preceding code snippet, we don''t need
    the following code anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the problem occurs since the next code needs variable options as arguments
    to the `GenerateOrderedList()` method, which we can see in following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'To solve this problem, we can use the `Map` methods as well to chain the `GenerateOrderedList()`
    method to the buffer variable initialization so that we can remove the `orderedList`
    variable. Now, the code will be look like what is shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the last line of code is the `Console.WriteLine()` method, which takes
    the `orderedList` variable as an argument, we can modify the buffer variable to
    `orderedList` . The change will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line in the `GenerateOrderedList()` method is the `Console.WriteLine()`
    method. We will also chain this method to the `orderedList` variable. For this
    purpose, we need to extend a method called `Tee` , containing the pipelining technique
    we discussed earlier. Let''s take a look at the following `Tee` method extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we can see that the output of `Tee` will be passed
    to the input of the `Action` function. Then, we can chain the last line using
    `Tee` , as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '`Tee` can return the HTML generated by the `GenerateOrderedList()` method so
    that we can remove the `orderedList` variable from the code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also implement the `Tee` method to the lambda expression in the preceding
    code. We will refactor the following code snippet using `Tee` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand what the preceding code snippet is actually doing. First,
    we initialize the byte array variable `buff` to store as many bytes as the length
    of the stream. It then populates this byte array using the `stream.Read` method
    before returning the byte array. We can also ask the `Tee` method to do this job.
    The code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a new `Main()` method, applying method chaining to approach functional
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages and disadvantages of functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have had to deal with functional programming by creating code using
    functional approach. Now, we can look at the advantages of the functional approach,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The order of execution doesn't matter since it is handled by the system to compute
    the value we have given rather than the one defined by programmer. In other words,
    the declarative of the expressions will become unique. Because functional programs
    have an approach toward mathematical concepts, the system will be designed with
    the notation as close as possible to the mathematical way of concept.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables can be replaced by their value since the evaluation of expression
    can be done any time. The functional code is then more mathematically traceable
    because the program is allowed to be manipulated or transformed by substituting
    equals with equals. This feature is called referential transparency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutability makes the functional code free of side effects. A shared variable,
    which is an example of a side effect, is a serious obstacle for creating parallel
    code and result in non-deterministic execution. By removing the side effect, we
    can have a good coding approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The power of lazy evaluation will make the program run faster because it only
    provides what we really required for the queries result. Suppose we have a large
    amount of data and want to filter it by a specific condition, such as showing
    only the data that contains the word Name. In imperative programming, we will
    have to evaluate each operation of all the data. The problem is that when the
    operation takes a long time, the program will need more time to run as well. Fortunately,
    the functional programming that applies LINQ will perform the filtering operation
    only when it is needed. That's why functional programming will save much of our
    time using lazy evaluation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a solution for complex problems using composability. It is a rule principle
    that manages a problem by dividing it, and it gives pieces of the problem to several
    functions. The concept is similar to a situation when we organize an event and
    ask different people to take up a particular responsibility. By doing this, we
    can ensure that everything will done properly by each person.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Beside the advantages of functional programming, there are several disadvantages
    as well. Here are some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: Since there's no state and no update of variables is allowed, loss of performance
    will take place. The problem occurs when we deal with a large data structure and
    it needs to perform a duplication of any data even though it only changes a small
    part of the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compared to imperative programming, much garbage will be generated in functional
    programming due to the concept of immutability, which needs more variables to
    handle specific assignments. Because we cannot control the garbage collection,
    the performance will decrease as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been acquainted with the functional approach by discussing the
    introduction of functional programming. We also have compared the functional approach
    to the mathematical concept when we create functional program. It's now clear
    that the functional approach uses the mathematical approach to compose a functional
    program.
  prefs: []
  type: TYPE_NORMAL
- en: There are three important points in constructing the function; they are definition,
    script, and session. The definition is the equation between particular expressions
    that describe the mathematical function. Script is a collection of definitions
    that are supplied by the programmer. Session is a situation where the program
    submits the expressions that can contain references to the function defined in
    the script to the computer for evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: The comparison between functional and imperative programming also led us to
    the important point of distinguishing the two. It's now clear that in functional
    programming, the programmer focuses on the kind of desired information and the
    kind of required transformation, while in the imperative approach, the programmer
    focuses on the way of performing the task and tracking changes in the state.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also explored several concepts of functional programming, such as first-class
    and higher-order functions, pure functions, and recursive functions. The first-class
    and higher-order functions concept treats the functions as values so that we can
    assign it to a variable and pass it to the argument of the function. The pure
    functions concept makes the function have no side-effect. Recursive functions
    help us iterate the function itself with the power of aggregate in LINQ. Also,
    functions in functional programming have several characteristics that we need
    to know, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It always returns the same value every time it is given the same set of inputs.
  prefs: []
  type: TYPE_NORMAL
- en: It never references a variable defined outside the function.
  prefs: []
  type: TYPE_NORMAL
- en: It cannot change the value of the variable since it applies the immutable concept.
  prefs: []
  type: TYPE_NORMAL
- en: It doesn't contain any I/O, such as a fancy output or a keyboard stroke, since
    no side-effect occurrence is allowed.
  prefs: []
  type: TYPE_NORMAL
- en: When we test functional program in C#, we take the mathematical approach to
    find out how to compose a function in C# from a mathematical function. We learn
    how to curry the curried function to pass the second argument after we assign
    the first argument alone. Also, we now know how to make the program functional
    using pipelining and the method chaining technique.
  prefs: []
  type: TYPE_NORMAL
- en: After finishing with learning the techniques for creating functional programming,
    we translate the imperative approach code into the functional approach code. Here,
    we compose the imperative code from scratch and then refactor it into functional
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, after we become more familiar with functional programming, we can grasp
    the advantages and disadvantages of functional programming itself. This will be
    the reason why we need to learn functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about delegate data type to encapsulates a
    method that has particular parameters and return type. It is useful when we need
    create a cleaner and an easier function pointer.
  prefs: []
  type: TYPE_NORMAL
