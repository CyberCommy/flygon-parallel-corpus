- en: Writing and Running Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed why testing is so important and looked
    at a brief overview of the `unittest` module. We also took a cursory look at pytest's
    features, but barely got a taste of them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start our journey with pytest. We will be pragmatic,
    so this means that we will not take an exhaustive look at all of the things it's
    possible to do with pytest, but instead provide you with a quick overview of the
    basics to make you productive quickly. We will take a look at how to write tests,
    how to organize them into files and directories, and how to use pytest's command
    line effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what is covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing pytest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and running tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing files and packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Useful command-line options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configuration: `pytest.ini` file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the chapter, there are a lot of examples typed into the command line. They
    are marked by the λ character. To avoid clutter and to focus on the important
    parts, the pytest header (which normally displays the pytest version, the Python
    version, installed plugins, and so on) will be suppressed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's jump right into how to install pytest.
  prefs: []
  type: TYPE_NORMAL
- en: Installing pytest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing pytest is really simple, but first, let's take a moment to review
    good practices for Python development.
  prefs: []
  type: TYPE_NORMAL
- en: All of the examples are for Python 3\. They should be easy to adapt to Python
    2 if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: pip and virtualenv
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recommended practice for installing dependencies is to create a `virtualenv`.
    A `virtualenv` ([https://packaging.python.org/guides/installing-using-pip-and-virtualenv/](https://packaging.python.org/guides/installing-using-pip-and-virtualenv/))
    acts like a complete separate Python installation from the one that comes with
    your operating system, making it safe to install the packages required by your
    application without risk of breaking your system Python or tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will learn how to create a virtual environment and install pytest using
    pip. If you are already familiar with `virtualenv` and pip, you can skip this
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type this in your Command Prompt to create a `virtualenv`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will create a `.env` folder in the current directory, containing
    a full-blown Python installation. Before proceeding, you should `activate` the
    `virtualenv`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Or on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will put the `virtualenv` Python in front of the `$PATH` environment variable,
    so Python, pip, and other tools will be executed from the `virtualenv`, not from
    your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to install pytest, type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify that everything went well by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are all set up and can begin!
  prefs: []
  type: TYPE_NORMAL
- en: Writing and running tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using pytest, all you need to do to start writing tests is to create a new
    file named `test_*.py` and write test functions that start with `test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute this test, simply execute `pytest`, passing the name of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you don't pass anything, pytest will look for all of the test files from
    the current directory recursively and execute them automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might encounter examples on the internet that use `py.test` in the command
    line instead of `pytest`. The reason for that is historical: pytest used to be
    part of the `py` package, which provided several general purpose utilities, including
    tools that followed the convention of starting with `py.<TAB>` for tab completion,
    but since then, it has been moved into its own project. The old `py.test` command
    is still available and is an alias to `pytest`, but the latter is the recommended
    modern usage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there''s no need to create classes; just simple functions and plain
    `assert` statements are enough, but if you want to use classes to group tests
    you can do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Grouping tests can be useful when you want to put a number of tests under the
    same scope: you can execute tests based on the class they are in, apply markers
    to all of the tests in a class ([Chapter 3](6a37176b-78d0-4e6c-8185-460d48869d23.xhtml),
    *Markers and Parametrization*), and create fixtures bound to a class ([Chapter
    4](bf8b3438-83e6-4ce5-9df4-4da086636ef7.xhtml), *Fixtures*).'
  prefs: []
  type: TYPE_NORMAL
- en: Running tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pytest can run your tests in a number of ways. Let's quickly get into the basics
    now and, later on in the chapter, we will move on to more advanced options.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start by just simply executing the `pytest` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will find all of the `test_*.py` and `*_test.py` modules in the current
    directory and below recursively, and will run all of the tests found in those
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can reduce the search to specific directories:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also mix any number of files and directories:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can execute specific tests by using the syntax `<test-file>::<test-function-name>`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can execute all of the `test` methods of a `test` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can execute a specific `test` method of a `test` class using the syntax `<test-file>::<test-class>::<test-method-name>`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The syntax used above is created internally by pytest, is unique to each test
    collected, and is called a `node id` or `item id`*. *It basically consists of
    the filename of the testing module, class, and functions joined together by the `::` characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pytest will show a more verbose output, which includes node IDs, with the `-v`
    flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To see which tests there are without running them, use the `--collect-only` 
    flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`--collect-only` is especially useful if you want to execute a specific test
    but can''t remember its exact name.'
  prefs: []
  type: TYPE_NORMAL
- en: Powerful asserts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you've probably already noticed, pytest makes use of the built-in `assert`
    statement to check assumptions during testing. Contrary to other frameworks, you
    don't need to remember various `self.assert*` or `self.expect*` functions. While this
    may not seem like a big deal at first, after spending some time using plain asserts,
    you will realize how much that makes writing tests more enjoyable and natural.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, here''s an example of a failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Pytest shows the line of the failure, as well as the variables and expressions
    involved in the failure. By itself, this would be pretty cool already, but pytest
    goes a step further and provides specialized explanations of failures involving
    other data types.
  prefs: []
  type: TYPE_NORMAL
- en: Text differences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When showing the explanation for short strings, pytest uses a simple difference
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Longer strings show a smarter delta, using `difflib.ndiff` to quickly spot
    the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiline strings are also treated specially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assertion failures for lists also show only differing items by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that pytest shows which index differs, and also that the `-v` flag can
    be used to show the complete difference between the lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If the difference is too big, pytest is smart enough to show only a portion
    to avoid showing too much output, displaying a message like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Dictionaries and sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dictionaries are probably one of the most used data structures in Python, so,
    unsurprisingly, pytest has specialized representation for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Sets also have similar output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As with lists, there are also `-v` and `-vv` options for displaying more detailed
    output.
  prefs: []
  type: TYPE_NORMAL
- en: How does pytest do it?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Python's assert statement does not provide any details when it fails,
    but as we just saw, pytest shows a lot of information about the variables and
    expressions involved in a failed assertion. So how does pytest do it?
  prefs: []
  type: TYPE_NORMAL
- en: Pytest is able to provide useful exceptions because it implements a mechanism
    called *assertion rewriting*.
  prefs: []
  type: TYPE_NORMAL
- en: Assertion rewriting works by installing a custom import hook that intercepts
    the standard Python import mechanism. When pytest detects that a test file (or
    plugin) is about to be imported, instead of loading the module, it first compiles
    the source code into an **abstract syntax tree** (**AST**) using the built-in
    `ast` module. Then, it searches for any `assert` statements and *rewrites* them
    so that the variables used in the expression are kept so that they can be used
    to show more helpful messages if the assertion fails. Finally, it saves the rewritten
    `pyc` file to disk for caching.
  prefs: []
  type: TYPE_NORMAL
- en: This all might seem very magical, but the process is actually simple, deterministic,
    and, best of all, completely transparent.
  prefs: []
  type: TYPE_NORMAL
- en: If you want more details, refer to [http://pybites.blogspot.com.br/2011/07/behind-scenes-of-pytests-new-assertion.html](http://pybites.blogspot.com.br/2011/07/behind-scenes-of-pytests-new-assertion.html),
    written by the original developer of this feature, Benjamin Peterson. The `pytest-ast-back-to-python`
    plugin shows exactly what the AST of your test files looks like after the rewriting
    process. Refer to: [https://github.com/tomviner/pytest-ast-back-to-python](https://github.com/tomviner/pytest-ast-back-to-python).
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking exceptions: pytest.raises'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good API documentation will clearly explain what the purpose of each function
    is, its parameters, and return values. Great API documentation also clearly explains
    which exceptions are raised and when.
  prefs: []
  type: TYPE_NORMAL
- en: For that reason, testing that exceptions are raised in the appropriate circumstances is
    just as important as testing the main functionality of APIs. It is also important
    to make sure that exceptions contain an appropriate and clear message to help
    users understand the issue.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we are writing an API for a game. This API allows programmers to write
    `mods`, which are a plugin of sorts that can change several aspects of a game,
    from new textures to complete new story lines and types of characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'This API has a function that allows mod writers to create a new character,
    and it can raise exceptions in some situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Pytest makes it easy to check that your code is raising the proper exceptions
    with the `raises` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`pytest.raises` is a with-statement that ensures the exception class passed
    to it will be **raised** inside its execution **block**. For more details ([https://docs.python.org/3/reference/compound_stmts.html#the-with-statement](https://docs.python.org/3/reference/compound_stmts.html#the-with-statement)).
    Let''s see how `create_character` implements those checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you are paying close attention, you probably noticed that the copy-paste
    error in the preceding code should actually raise an  `InvalidClassNameError` for
    the class name check.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`test_empty_name` passed as expected. `test_invalid_class_name` raised `InvalidClassNameError`,
    so the exception was not captured by `pytest.raises`, which failed the test (as
    any other exception would).'
  prefs: []
  type: TYPE_NORMAL
- en: Checking exception messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated at the start of this section, APIs should provide clear messages in
    the exceptions they raise. In the previous examples, we only verified that the
    code was raising the appropriate exception type, but not the actual message.
  prefs: []
  type: TYPE_NORMAL
- en: '`pytest.raises` can receive an optional `match` argument, which is a regular
    expression string that will be matched against the exception message, as well
    as checking the exception type. For more details, go to: [https://docs.python.org/3/howto/regex.html](https://docs.python.org/3/howto/regex.html).
    We can use that to improve our tests even further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Simple!
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking warnings: pytest.warns'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: APIs also evolve. New and better alternatives to old functions are provided,
    arguments are removed, old ways of using a certain functionality evolve into better
    ways, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: API writers have to strike a balance between keeping old code working to avoid
    breaking clients and providing better ways of doing things, while all the while
    keeping their own API code maintainable. For this reason, a solution often adopted
    is to start to issue `warnings` when API clients use the old behavior, in the
    hope that they update their code to the new constructs. Warning messages are shown
    in situations where the current usage is not wrong to warrant an exception, it
    just happens that there are new and better ways of doing it. Often, warning messages
    are shown during a grace period for this update to take place, and afterward the
    old way is no longer supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python provides the standard warnings module exactly for this purpose, making
    it easy to warn developers about forthcoming changes in APIs. For more details,
    go to: [https://docs.python.org/3/library/warnings.html](https://docs.python.org/3/library/warnings.html).
    It lets you choose from a number of warning classes, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UserWarning`: user warnings (`user` here means developers, not software users)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeprecationWarning`: features that will be removed in the future'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ResourcesWarning`: related to resource usage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (This list is not exhaustive. Consult the warnings documentation for the full
    listing. For more details, go to: [https://docs.python.org/3/library/warnings.html](https://docs.python.org/3/library/warnings.html)[).](https://docs.python.org/3/library/warnings.html)
  prefs: []
  type: TYPE_NORMAL
- en: Warning classes help users control which warnings should be shown and which
    ones should be suppressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose an API for a computer game provides this handy function
    to obtain the starting hit points of player characters given their class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Time moves forward and the developers decide to use an `enum` instead of class
    names in the next release. For more details, go to: [https://docs.python.org/3/library/enum.html](https://docs.python.org/3/library/enum.html),
    which is more adequate to represent a limited set of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'But changing this suddenly would break all clients, so they wisely decide to
    support both forms for the next release: `str` and the `PlayerClass` `enum`. They
    don''t want to keep supporting this forever, so they start showing a warning whenever
    a class is passed as a `str`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same vein as `pytest.raises` from the previous section, the `pytest.warns`
    function lets you test whether your API code is producing the warnings you expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As with `pytest.raises`, `pytest.warns` can receive an optional `match` argument,
    which is a regular expression string. For more details, go to: [https://docs.python.org/3/howto/regex.html](https://docs.python.org/3/howto/regex.html), which
    will be matched against the exception message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Comparing floating point numbers: pytest.approx'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Comparing floating point numbers can be tricky. For more details, go to: [https://docs.python.org/3/tutorial/floatingpoint.html](https://docs.python.org/3/tutorial/floatingpoint.html).
    Numbers that we consider equal in the real world are not so when represented by
    computer hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When writing tests, it is very common to compare the results produced by our
    code against what we expect as floating point values. As shown above, a simple
    `==` comparison often won''t be sufficient. A common approach is to use a known
    tolerance instead and use `abs` to correctly deal with negative numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: But besides being ugly and hard to understand, it is sometimes difficult to
    come up with a tolerance that works in most situations. The chosen tolerance of
    `0.0001` might work for the numbers above, but not for very large numbers or very
    small ones. Depending on the computation performed, you would need to find a suitable
    tolerance for every set of input numbers, which is tedious and error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: '`pytest.approx` solves this problem by automatically choosing a tolerance appropriate
    for the values involved in the expression, providing a very nice syntax to boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You can read the above as `assert that 0.1 + 0.2 equals approximately to 0.3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the  `approx` function does not stop there; it can be used to compare:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sequences of numbers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Dictionary `values` (not keys):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`numpy` arrays:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When a test fails, `approx` provides a nice error message displaying the values
    that failed and the tolerance used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Organizing files and packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pytest needs to import your code and test modules, and it is up to you how to
    organize them. Pytest supports two common test layouts, which we will discuss
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Tests that accompany your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can place your test modules together with the code they are testing by
    creating a `tests` folder next to the modules themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'By putting the tests near the code they test, you gain the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It is easier to add new tests and test modules in this hierarchy and keep them
    in sync
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your tests are now part of your package, so they can be deployed and run in
    other environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main disadvantage with this approach is that some folks don't like the added
    package size of the extra modules, which are now packaged together with the rest
    of the code, but this is usually minimal and of little concern.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an additional benefit, you can use the `--pyargs` option to specify tests
    using their module import path. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This will execute all test modules found under `mylib.tests`.
  prefs: []
  type: TYPE_NORMAL
- en: You might consider using `_tests` for the test module names instead of `_test`.
    This makes the directory easier to find because the leading underscore usually
    makes them appear at the top of the folder hierarchy. Of course, feel free to
    use `tests` or any other name that you prefer; pytest doesn't care as long as
    the test modules themselves are named `test_*.py` or `*_test.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Tests separate from your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An alternative to the method above is to organize your tests in a separate
    directory from the main package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Some people prefer this layout because:'
  prefs: []
  type: TYPE_NORMAL
- en: It keeps library code and testing code separate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The testing code is not included in the source package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One disadvantage of the above method is that, once you have a more complex
    hierarchy, you will probably want to keep the same hierarchy inside your tests
    directory, and that''s a little harder to maintain and keep in sync:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: So, which layout is the best? Both layouts have advantages and disadvantages.
    Pytest itself works perfectly well with either of them, so feel free to choose
    a layout that you are more comfortable with.
  prefs: []
  type: TYPE_NORMAL
- en: Useful command-line options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will take a look at command-line options that will make you more productive
    in your daily work. As stated at the beginning of the chapter, this is not a complete
    list of all of the command-line features; just the ones that you will use (and
    love) the most.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keyword expressions: -k'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, you don't exactly remember the full path or name of a test that you want
    to execute. At other times, many tests in your suite follow a similar pattern
    and you want to execute all of them because you just refactored a sensitive area
    of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the `-k <EXPRESSION>` flag (from *keyword expression*), you can run
    tests whose `item id` loosely matches the given expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This will execute all tests that contain the string `parse` in their item IDs.
    You can also write simple Python expressions using Boolean operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This will execute all tests that contain `parse` but not `num` in their item
    IDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop soon: -x, --maxfail'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When doing large-scale refactorings, you might not know beforehand how or which
    tests are going to be affected. In those situations, you might try to guess which
    modules will be affected and start running tests for those. But, often, you end
    up breaking more tests than you initially estimated and quickly try to stop the
    test session by hitting `CTRL+C` when everything starts to fail unexpectedly.
  prefs: []
  type: TYPE_NORMAL
- en: In those situations, you might try using the `--maxfail=N` command-line flag,
    which stops the test session automatically after `N` failures or errors, or the
    shortcut `-x`, which equals `--maxfail=1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This allows you to quickly see the first failing test and deal with the failure.
    After fixing the reason for the failure, you can continue running with `-x` to
    deal with the next problem.
  prefs: []
  type: TYPE_NORMAL
- en: If you find this brilliant, you don't want to skip the next section!
  prefs: []
  type: TYPE_NORMAL
- en: 'Last failed, failed first: --lf, --ff'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pytest always remembers tests that failed in previous sessions, and can reuse
    that information to skip right to the tests that have failed previously. This
    is excellent news if you are incrementally fixing a test suite after a large refactoring,
    as mentioned in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: You can run the tests that failed before by passing the `--lf` flag (meaning last
    failed*):*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'When used together with `-x` (`--maxfail=1`) these two flags are refactoring
    heaven:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This lets you start executing the full suite and then pytest stops at the first
    test that fails. You fix the code, and execute the same command line again. Pytest
    starts right at the failed test, and goes on if it passes (or stops again if you
    haven't yet managed to fix the code yet). It will then stop at the next failure.
    Rinse and repeat until all tests pass again.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that it doesn't matter if you execute another subset of tests in
    the middle of your refactoring; pytest always remembers which tests failed, regardless
    of the command-line executed.
  prefs: []
  type: TYPE_NORMAL
- en: If you have ever done a large refactoring and had to keep track of which tests
    were failing so that you didn't waste your time running the test suite over and
    over again, you will definitely appreciate this boost in your productivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `--ff` flag is similar to `--lf`, but it will reorder your tests
    so the previous failures are run **first**, followed by the tests that passed
    or that were not run yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Output capturing: -s and --capture'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, developers leave `print` statements laying around by mistake, or
    even on purpose, to be used later for debugging. Some applications also may write
    to `stdout`  or `stderr` as part of their normal operation or logging.
  prefs: []
  type: TYPE_NORMAL
- en: All that output would make understanding the test suite display much harder.
    For this reason, by default, pytest captures all output written to `stdout` and
    `stderr` automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this function to compute a hash of some text given to it that has
    some debugging code left on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a very simple test for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'When executing this test, by default, you won''t see the output of the `print`
    calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: That's nice and clean.
  prefs: []
  type: TYPE_NORMAL
- en: But those print statements are there to help you understand and debug the code,
    which is why pytest will show the captured output if the test **fails**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the contents of the hashed text but not the hash itself. Now,
    pytest will show the captured output in a separate section after the error traceback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Showing the captured output on failing tests is very handy when running tests
    locally, and even more so when running tests on CI.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling capturing with -s
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While running your tests locally, you might want to disable output capturing
    to see what messages are being printed in real-time, or whether the capturing
    is interfering with other capturing your code might be doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In those cases, just pass `-s` to pytest to completely disable capturing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Capture methods with --capture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pytest has two methods to capture output. Which method is used can be chosen
    with the `--capture` command-line flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--capture=fd`: captures output at the **file-descriptor level**, which means
    that all output written to the file descriptors, 1 (stdout) and 2 (stderr), is
    captured. This will capture output even from C extensions and is the default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--capture=sys`: captures output written directly to `sys.stdout` and `sys.stderr`
    at the Python level, without trying to capture system-level file descriptors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually, you don't need to change this, but in a few corner cases, depending
    on what your code is doing, changing the capture method might be useful.
  prefs: []
  type: TYPE_NORMAL
- en: For completeness, there's also `--capture=no`, which is the same as `-s`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback modes and locals: --tb, --showlocals'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pytest will show a complete traceback of a failing test, as expected from a
    testing framework. However, by default, it doesn''t show the standard traceback
    that most Python programmers are used to; it shows a different traceback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This traceback shows only a single line of code and file location for all frames
    in the traceback stack, except for the first and last one, where a portion of
    the code is shown as well (in bold).
  prefs: []
  type: TYPE_NORMAL
- en: While some might find it strange at first, once you get used to it you realize
    that it makes spotting the cause of the error much simpler. By looking at the
    surrounding code of the start and end of the traceback, you can usually understand
    the error better. I suggest that you try to get used to the default traceback
    provided by pytest for a few weeks; I'm sure you will love it and never look back.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't like pytest's default traceback, however, there are other traceback
    modes, which are controlled by the `--tb` flag. The default is `--tb=auto` and
    was shown previously. Let's have a look at an overview of the other modes in the
    next sections.
  prefs: []
  type: TYPE_NORMAL
- en: --tb=long
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This mode will show a **portion of the code for** **all** **frames** of failure
    tracebacks, making it quite verbose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: --tb=short
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This mode will show a single line of code from all the frames of the failure
    traceback, providing short and concise output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: --tb=native
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This mode will output the exact same traceback normally used by Python to report
    exceptions and is loved by purists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: --tb=line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This mode will output a single line per failing test, showing only the exception
    message and the file location of the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This mode might be useful if you are doing a massive refactoring and except
    a ton of failures anyway, planning to enter **refactoring-heaven mode** with the `--lf
    -x` flags afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: --tb=no
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This does not show any traceback or failure message at all, making it also
    useful to run the suite first to get a glimpse of how many failures there are,
    so that you can start using `--lf -x` flags to fix tests step-wise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: --showlocals (-l)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, while this is not a traceback mode flag specifically, `--showlocals`
    (or `-l` as shortcut) augments the traceback modes by showing a list of the **local
    variables and their values** when using `--tb=auto`, `--tb=long`, and `--tb=short`
    modes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here''s the output of `--tb=auto` and `--showlocals`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how this makes it much easier to see where the bad data is coming from:
    the `''3rd Grid,24,null''` string that is being read from a file at the start
    of the test.'
  prefs: []
  type: TYPE_NORMAL
- en: '`--showlocals` is extremely useful both when running your tests locally and
    in CI, being a firm favorite. Be careful, though, as this might be a security
    risk: local variables might expose passwords and other sensitive information,
    so make sure to transfer tracebacks using secure connections and be careful to
    make them public.'
  prefs: []
  type: TYPE_NORMAL
- en: Slow tests with --durations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the start of a project,  your test suite is usually blazingly fast, running
    in a few seconds, and life is good. But as projects grow in size, so do their
    test suites, both in the number of tests and the time it takes for them to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a slow test suite affects productivity, especially if you follow TDD
    and run tests all the time. For this reason, it is healthy to periodically take
    a look at your longest running tests and perhaps analyze whether they can be made
    faster: perhaps you are using a large dataset in a place where a much smaller
    (and faster) dataset would do, or you might be executing redundant steps that
    are not important for the actual test being done.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When that happens, you will love the `--durations=N` flag. This flag provides
    a summary of the `N` longest running tests, or uses zero to see a summary of all
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This output provides invaluable information when you start hunting for tests
    to speed up.
  prefs: []
  type: TYPE_NORMAL
- en: Although this flag is not something that you will use daily, because it seems
    that many people don't know about it, it is worth mentioning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extra test summary: -ra'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pytest shows rich traceback information on failing tests. The extra information
    is great, but the actual footer is not very helpful in identifying which tests
    have actually failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-ra` flag can be passed to produce a nice summary with the full name of
    all failing tests at the end of the session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This flag is particularly useful when running the suite from the command line
    directly, because scrolling the terminal to find out which tests failed can be
    annoying.
  prefs: []
  type: TYPE_NORMAL
- en: 'The flag is actually `-r`, which accepts a number of single-character arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`f` (failed): `assert` failed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`e` (error): raised an unexpected exception'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s` (skipped): skipped (we will get to this in the next chapter)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x` (xfailed): expected to fail, did fail (we will get to this in the next
    chapter)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X` (xpassed): expected to fail, but passed (!) (we will get to this in the
    next chapter)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`p` (passed): test passed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`P` (passed with output): displays captured output even for passing tests (careful –
    this usually produces a lot of output)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a`: shows all the above, except for `P`; this is the **default** and is usually
    the most useful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The flag can receive any combination of the above. So, for example, if you are
    interested in failures and errors only, you can pass `-rfe` to pytest.
  prefs: []
  type: TYPE_NORMAL
- en: In general, I recommend sticking with `-ra`, without thinking too much about
    it and you will obtain the most benefits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuration: pytest.ini'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users can customize some pytest behavior using a configuration file called `pytest.ini`.
    This file is usually placed at the root of the repository and contains a number
    of configuration values that are applied to all test runs for that project. It
    is meant to be kept under version control and committed with the rest of the code.
  prefs: []
  type: TYPE_NORMAL
- en: The format follows a simple ini-style format with all pytest-related options
    under a `[pytest]` section. For more details, go to:[https://docs.python.org/3/library/configparser.html](https://docs.python.org/3/library/configparser.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The location of this file also defines what pytest calls the **root directory**
    (`rootdir`): if present, the directory that contains the configuration file is
    considered the root directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The root directory is used for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: To create the tests node IDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a stable location to store information about the project (by pytest plugins
    and features)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without the configuration file, the root directory will depend on which directory
    you execute pytest from and which arguments are passed (the description of the
    algorithm can be found here: [https://docs.pytest.org/en/latest/customize.html#finding-the-rootdir](https://docs.pytest.org/en/latest/customize.html#finding-the-rootdir)).
    For this reason, it is always recommended to have a `pytest.ini` file in all but
    the simplest projects, even if empty.
  prefs: []
  type: TYPE_NORMAL
- en: Always define a `pytest.ini` file, even if empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using `tox`, you can put a `[pytest]` section in the traditional
    `tox.ini` file and it will work just as well. For more details, go to: [https://tox.readthedocs.io/en/latest/](https://tox.readthedocs.io/en/latest/):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This is useful to avoid cluttering your repository root with too many files,
    but it is really a matter of preference.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will take a look at more common configuration options. More options
    will be introduced in the coming chapters as we cover new features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional command-line: addopts'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned some very useful command-line options. Some of them might become
    personal favorites, but having to type them all the time would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `addopts` configuration option can be used instead to always add a set
    of options to the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'With that configuration, typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Is the same as typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Note that, despite its name, `addopts` actually inserts the options **before**
    other options typed in the command line. This makes it possible to override most
    options in `addopts` when passing them in explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code will now display **auto **tracebacks, instead
    of native ones, as configured in `pytest.ini`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Customizing a collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, pytest collects tests using this heuristic:'
  prefs: []
  type: TYPE_NORMAL
- en: Files that match `test_*.py` and `*_test.py`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside test modules, functions that match `test*` and classes that match `Test*`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside test classes, methods that match `test*`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This convention is simple to understand and works for most projects, but they
    can be overwritten by these configuration options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`python_files`: a list of patterns to use to collect test modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`python_functions`: a list of patterns to use to collect test functions and
    test methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`python_classes`: a list of patterns to use to collect test classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example of a configuration file changing the defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The recommendation is to only use these configuration options for legacy projects
    that follow a different convention, and stick with the defaults for new projects.
    Using the defaults is less work and avoids confusing other collaborators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cache directory: cache_dir'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `--lf` and `--ff` options shown previously are provided by an internal plugin
    named `cacheprovider`, which saves data on a directory on disk so it can be accessed
    in future sessions. This directory by default is located in the **root directory** under
    the name `.pytest_cache`. This directory should never be committed to version
    control.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to change the location of that directory, you can use the
    `cache_dir` option. This option also expands environment variables automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Avoid recursing into directories: norecursedirs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'pytest by default will recurse over all subdirectories of the arguments given
    on the command line. This might make test collection take more time than desired
    when recursing into directories that never contain any tests, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: virtualenvs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build artifacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version control directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pytest by default tries to be smart and will not recurse inside folders with
    the patterns `.*`, `build`, `dist`, `CVS`, `_darcs`, `{arch}`, `*.egg`, `venv`.
    It also tries to detect virtualenvs automatically by looking at known locations
    for activation scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `norecursedirs` option can be used to override the default list of pattern
    names that pytest should never recurse into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the `--collect-in-virtualenv` flag to skip the `virtualenv`
    detection.
  prefs: []
  type: TYPE_NORMAL
- en: In general, users have little need to override the defaults, but if you find
    yourself adding the same directory over and over again in your projects, consider
    opening an issue. For more details ([https://github.com/pytest-dev/pytest/issues/new](https://github.com/pytest-dev/pytest/issues/new)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Pick the right place by default: testpaths'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed previously, a common directory structure is *out-of-source layout*,
    with tests separated from the application/library code in a `tests` or similarly
    named directory. In that layout it is useful to use the `testpaths` configuration
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This will tell pytest where to look for tests when no files, directories, or
    node ids are given in the command line, which might speed up test collection.
    Note that you can configure more than one directory, separated by spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Override options with -o/--override
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, a little known feature is that you can override any configuration
    option directly in the command-line using the `-o` /`--override` flags. This flag
    can be passed multiple times to override more than one option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to use `virtualenv` and `pip` to install pytest.
    After that, we jumped into how to write tests, and the different ways to run them
    so that we can execute just the tests we are interested in. We had an overview
    of how pytest can provide rich output information for failing tests for different
    built-in data types. We learned how to use `pytest.raises` and `pytest.warns`
    to check exceptions and warnings, and `pytest.approx` to avoid common pitfalls
    when comparing floating point numbers. Then, we briefly discussed how to organize
    test files and modules in your projects. We also took a look at some of the more
    useful command-line options so that we can get productive right away. Finally,
    we covered how `pytest.ini` files are used for persistent command-line options
    and other configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to use marks to help us skip tests on
    certain platforms, how to let our test suite know when a bug is fixed in our code
    or in external libraries, and how to group sets of tests so that we can execute
    them selectively in the command line. After that, we will learn how to apply the
    same checks to different sets of data to avoid copying and pasting testing code.
  prefs: []
  type: TYPE_NORMAL
