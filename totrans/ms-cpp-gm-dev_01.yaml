- en: C++ for Game Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ever since I was young, I was told, whether it was the pursuit of perfection
    in a sport, learning a musical instrument, or even a new technical skill, strong
    understanding of the fundamentals and practice is what makes the difference. Game
    development with C++ is no different. Before you can master the process, you have
    to perfect the fundamentals. That is what the first chapter of this book is all
    about, covering the foundational concepts that will be used throughout the book.
    The chapter is broken down into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of advanced C++ concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with types and containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game programming patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The conventions used in the book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the book, you will encounter code snippets and examples. To keep
    the code readable and uniform, I will follow a few basic coding conventions. While
    the topic of coding standards is a complicated and lengthy discussion, I do think
    it is important to lay out some guidelines for any advanced project. Having an
    accessible guide to what is the expected notation and the naming conventions,
    at the very least, should be considered necessary before any work can begin. If
    you are interested in knowing more about common code standards used in C++, a
    great place to start is the coding standards frequently asked question section
    on the ISO C++ site at [https://isocpp.org/wiki/faq/coding-standards](https://isocpp.org/wiki/faq/coding-standards).
    There, you will find a wealth of commonly used standards for various situations
    and a pile of suggested reading links to expand your knowledge even further.
  prefs: []
  type: TYPE_NORMAL
- en: The standards and conventions used in this book are based on some of the core
    C++ guidelines, industry best practices, and my own personal experience. We will
    be using the latest ISO C++ standard, C++14 throughout the book. However, at times,
    we may make use of some of the functionality in the latest proposed revision,
    C++17, also known as C++1y. When this occurs, a note will be made explaining why.
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes and function names will follow the *MixedCase* style, while variables
    will follow a *camelCase* style. Some examples would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Another important convention used in this book that you should be aware of
    is the use of scope prefixes. Scope prefixes are a quick way of improving readability
    for other developers, and yourself when you enviably forget what scope a variable
    belongs to. The following is a list of the prefixes used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`m_`: This is used for class member variables. These are `private` and by using
    the prefix, tells anyone using the variable that it is available plainly in the
    class or through getters or setters if external, for example, `m_numberOfPlayers`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s_`: This is used for static class members. This tells anyone using this variable
    that only one copy exists across all instances of the class and that it is static,
    for example, `s_objDesc`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g_`: This is used for global variables. This tells anyone using this variable
    that it is available everywhere. We will not see many of these in the book, for
    example, `g_playerInfo`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of advanced C++ concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we jump into building our tools, libraries, and other game components,
    it is probably a good idea to run over some of the more common concepts that will
    show up often as we continue throughout the book. In this section, we will take
    a quick look at some of the advanced topics. This is not meant to be a complete
    list, and the goal is not to be a comprehensive overview of each subject instead
    the object is more of a review and explanation of the concepts when it comes to
    game development.
  prefs: []
  type: TYPE_NORMAL
- en: We will take a look at some simple examples and highlight some of the issues
    that could arise when working with these concepts. Some of the more seasoned C++
    developers might be able to skip this section, but since these topics will play
    an influential role in the rest of the book, it is important to have a firm understanding
    of each of them. If you are looking for a broader review or a deeper explanation
    of the topics, check out some of the suggested reading in the *Summary* section
    at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Working with namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Namespaces might not seem like a very advanced topic when compared to, say,
    smart pointers, but as you advance in your C++ game development adventure, namespaces
    will become an important part of your development toolkit. For a quick review,
    a namespace is a declaration that provides scope for all the variables, types,
    and functions inside of its encapsulation. This is important because it gives
    us a way of organizing our code into logical groups. By breaking our code up into
    these groups, we not only make it easier to read but also prevent what is known
    as **name collisions**. Name collisions occur when you have more than one class,
    function, or type with the same name. This becomes a big problem when you start
    to work with multiple libraries. Using namespaces prevents this through its use
    of scope. For example, say we had an implementation for a specialized string class
    for a certain platform. To keep this specialized version from interfering and
    colliding with the standard library implementation, we can wrap our type in a
    namespace like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can call our particular string implementation like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, if we did not want to keep typing the `ConsoleHelper` part over
    and over again, we could add a `using` statement that will tell the compiler to
    use a particular namespace to find the functions, types, and variables we are
    using. You can do that for our namespace with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The only problem with this is that it will include all of the `ConsoleHelper`
    libraries. If we only wanted to include a specific member of the namespace, we
    can do that with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This would include just the string member and not the whole namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance and polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance and polymorphism are topics that could easily fill their own chapters.
    They are complex and very powerful components of C++. My goal in this section
    is not to cover the entire ins and outs of inheritance and polymorphism. Instead,
    I want to take a quick look at how these concepts can be used to help you build
    your code structure. We will cover the highlights, but I am going to assume that
    you have a basic understanding of object-oriented development concepts and are
    familiar with topics such as access modifiers and friendship.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, we will focus on inheritance. The concept of inheritance is
    an important part of modern object-oriented design and development. While the
    ability of inheritance to save keystrokes is a huge plus, inheritance really shows
    its power when allowing a programmer to develop complex hierarchies of derived
    classes. Let''s take a look at the use of inheritance through a simple example.
    In this example, we have created a simple `Enemy` class. This class will handle
    things like the entity''s health, weapons, damage to deal, AI scripts, and so
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As we start to implement more enemies to the game, we will probably start adding
    some different conditional statements to allow for some more variation in our
    enemies. Adding more and more `if` statements, maybe even a couple cases in a
    switch inserted here and there. This quickly becomes a tangled, hard-to-read,
    mess of code. What happens if we decide to add a slightly different enemy-one
    that has its own possible conditionals, for our example, a boss enemy type. This
    new boss enemy type has a similar structure as the original `Enemy` class and
    shares many of the same types and functions. We could just copy the overlapping
    code into our new `Boss` class. This would work, but it is not the ideal solution.
    We would have a lot of code duplication, and with this needless duplication comes
    more chances for bugs. Then if you do have to fix a bug, you now have to make
    the fix in multiple places. This is an unnecessary maintenance headache. Instead,
    we can use inheritance. If our new boss enemy type inherits from the original
    enemy type, this means we can use the types and functions that the original class
    has available to us. What makes inheritance even more powerful is the fact that
    we not only can adopt the functions of the inherited class, we can override them
    with our own implementations. The new `Boss` class can then be written something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This type of structure is commonly referred to as a **parent** and **child**
    hierarchy where the `Boss` class is a child of the `Enemy` class. This means that
    `Boss` will now have all the required structure from the `Enemy` class. I should
    point out that we only inherited the functions and variables that are declared
    `public`. That is because when using inheritance, the `public` methods and variables
    of the class are exposed to everyone using the class. The `protected` methods
    and variables are only available to the class itself and any classes derived.
    The `private` methods and variables are only available to that class, no one else
    has access, even derived clas
  prefs: []
  type: TYPE_NORMAL
- en: 've overwritten the implementation of the `Update()` function with a special
    version for the new `Boss` class. Now, in our code, we could write something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When this code is run, it will call each of the separate implementations of
    the `Update()` function for the object. On the flip side of this, consider that
    we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here we have not overwritten the `RunAIScripts()` function, as it does not inherit
    the original class's implementation of the function. While this is a very basic
    example, it does demonstrate the abilities of single inheritance, which brings
    me to my next topic-multiple inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we continue with the previous example, and we decide we want to add
    a new enemy type, a boss that can fly. We have a `Boss` class, an `Enemy` class,
    and even a `FlyingEnemy` class that inherits from the `Enemy` class, which looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The problem is we want the functionality of `FlyingEnemy`, but we also want
    some of the functionalities of `Boss`. Again, we could just copy the code chunks
    we want into a new class, but C++ provides us with an even better solution, **multiple
    inheritance**. As the name suggests, multiple inheritance allows us to derive
    our class from multiple sources. We can then build classes that have two or more
    parent classes leading to complex hierarchies, but as we will see, this can also
    lead to some problematic situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To continue with our example, our new `FlyingBoss` class would look something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'At first glance, this looks like the perfect class, we have inherited the functions
    and variables we needed from both of the parent classes. However, there are a
    few issues that can start to come into play when working with multiple inheritance.
    First is the issue of ambiguity. Ambiguity happens when two or more of the classes
    that are being inherited from have functions or variables with the same name.
    For instance, in our example, if we did not override the `Update()` function,
    and we called `Update()` on the object, the compiler would look at the classes
    we inherited from for the implementation. Since they both have an implementation
    of the same name, the compiler throws a compiler time error complaining of ambiguity
    in the call. To solve this problem, we have to use a prefix on the function call
    to identify the class with the implementation we want to use. To do this, we use
    the scope operator (`::`) in our code to call the implementation from the `FlyingEnemy`
    class, which would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The second issue might be a little less obvious; it has to deal with the way
    the class inheritance tree is structured in our example. On the surface, everything
    looks good; the `FlyingBoss` class inherits from the `Boss` class and the `FlyingEnemy`
    class. The problem lies one step up the inheritance tree, both the `Boss` and
    `FlyingEnemy` classes inherit from the `Enemy` class. This creates the dreaded
    diamond of death pattern in the class hierarchy. This might not seem like a big
    deal, but having this pattern causes some unfortunate issues. First is again the
    issue of ambiguity. Every time you try and access any member variable or function
    of the `Enemy` class from the `FlyingBoss` class, it is ambiguous. This is because
    there are multiple paths to each variable and function. To solve this, we can
    specify which path we want to follow by again using the scope operator (`::`).
    Another issue that the diamond of death pattern causes is the problem of duplication.
    When we create a `FlyingBoss` object, it will have two copies of everything it
    inherits from the `Boss` class. This is because both `FlyingEnemy` and `Boss`
    classes have copies from the `Enemy` class that they have inherited. As you can
    see, this is messy and can lead to all kinds of headaches. Fortunately, C++ provides
    us with a solution, the concept of **virtual inheritance**. With virtual inheritance,
    we can make sure that a parent class only appears in any children classes once.
    To implement virtual inheritance, we simply use the `virtual` keyword when declaring
    the class we want to inherit from. In our example, the class declaration would
    then look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now the `FlyingBoss` class only has one instance of anything gained through
    inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: While this does solve the issue of the diamond of death and other possible hierarchy
    issues, these issues are usually a sign of the underlying design issues. I would
    suggest researching all other options before automatically jumping to virtual
    inheritance as a solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I want to quickly mention two important topics that work hand in hand
    to make inheritance the incredible tool it is, polymorphism and virtual functions.
    Boiling it down to the basics, polymorphism is the ability to use an object of
    a class as if it was part of another class. To make this simple, let''s examine
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This line of code creates a pointer to a new `FlyingBoss` object, nothing new
    here. However, we can also create a new pointer like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This works thanks to inheritance and polymorphism. We are able to refer to
    the `FlyBoss` object as if it was a `Boss` class object. It might seem simple
    now, but as you progress in your understanding of C++, you will start to see just
    how powerful this concept can be. It also leads us to the last topic I want to
    touch on with inheritance, virtual functions. Since we can create pointers to
    objects like this, what happens if we call the `Update()` function on `Boss*`
    of the `FlyingBoss` object? This is where virtual functions come in. If a function
    is marked with the `virtual` keyword like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This tells the compiler to use the type of object calling the function to determine
    which implementation should be used in that situation. So in our example if we
    were to use a virtual function in the `FlyingBoss` implementation, it would use
    that implementation when called from the `Boss*` of the `FlyingBoss` object.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers and referencing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most misunderstood and feared concepts in C++ is the concepts of
    pointers and references. It is often the reason new developers shy away from continuing
    their study of C++. There have been many books and tutorials written, trying to
    demystify the topic and to be quite honest I could easily write a chapter or even
    a separate book on the ins and outs of pointers and referencing. By now I am hoping
    you have come to peace with the topic of pointers and references in the classical
    sense and have built a healthy appreciation for their power and flexibility. So,
    in this section, we are not going to cover the core principles, but instead, look
    at the more important uses of, the older, or classical pointers and references
    and briefly cover the new pointers designed to help remove some of the mysticism
    and memory management concerns.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start out with the classical pointers and references. While you will
    quickly see the benefits of using the newer pointers, I still believe, as do a
    lot of C++ game developers, that the older versions still have their place. One
    of these places is when dealing with the passing of data to functions. When calling
    a function, it is often quite tempting to write something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'While this code is totally legal, if the object is more than a negligible size,
    it can pose a serious performance concern. When passing an object like this, the
    compiler automatically creates a copy of the object in memory. In most cases,
    this is not what we want. To prevent the compiler from creating a copy in memory,
    we can pass the object using a classic pointer or reference. The previous code
    would then look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the object is not copied into memory and allows us to operate on the actual
    object through dereferencing. This is one of the more common, continued uses of
    the classical pointers and references. Another common use of the classical pointers
    and references is when working with string literals and when moving objects. This
    type of application is still seen in many game development libraries. As such
    you should be comfortable with seeing code like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With the move to modern C++ and the C++11 standards, came a new set of managed
    pointers to help simplify the understanding and use of pointers. These new pointers
    are much like the classic pointers except for one crucial difference; they are
    managed. What this really boils down to is that these new pointers will handle
    their own memory allocation and deletion. Since one of the major issues with the
    classic pointer was the necessary manual memory and the problem of ownership,
    as in who is going to delete it and when this makes the use of pointers a little
    more welcoming and a lot more flexible. These managed pointers (`unique_ptr` and
    `shared_ptr`) are commonly used in the more modern game development libraries.
  prefs: []
  type: TYPE_NORMAL
- en: unique_ptr and shared_ptr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `unique_ptr` or unique pointer, is considered a smart pointer. The reason
    it is called unique is because this type of object holds sole ownership of its
    pointer. This means that no two `unique_ptr` pointers can manage the same object,
    it is unique. One of the biggest advantages of `unique_ptr` is that it manages
    its own lifetime. What this means is that when the pointer goes out of scope,
    it automatically destroys itself and deallocates its memory. This solves the dreaded
    dangling pointer issues and avoids memory leaks. This also removes the issue of
    ownership since now it is explicit who deletes the pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the C++14 standard, we can now use a handy little function to create
    a unique pointer, `make_unique`. The `make_unique` function creates an object
    of type `T` and then wraps it in a unique pointer. The syntax for creating the `unique_ptr` pointer
    with `make_unique` would look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once created, you can use the pointer much like a classic pointer. The dereference
    operators, `*` and `->`, work just like they normally would. Again the big difference
    here is that the pointer is automatically destroyed when it goes out of scope,
    freeing us from having to track every exit point manually to avoid any memory
    leak issues.
  prefs: []
  type: TYPE_NORMAL
- en: The `shared_ptr` or shared pointer is a lot like the unique pointer. It is considered
    a smart pointer, it handles deletion and deallocation of memory automatically.
    The difference is that the shared pointer *shares* ownership of the object. This
    means that, unlike the unique pointer, a shared pointer can be one of many shared
    pointers, pointing to a single object. This means that if a shared pointer goes
    out of scope or is pointed to another object, through `reset()` or the `=` operator,
    the object still remains. It is only destroyed and its memory deallocated when
    all the `shared_ptr` objects owning the object are either destroyed, go out of
    scope, or are reassigned to another pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, like the unique pointer, the shared pointer also has a handy function
    for creation. The `make_shared` function creates an object of type `T` and then
    wraps it in a shared pointer. The syntax for creating the `shared_ptr` function
    using the `make_shared` function would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Also, like the unique pointer, the shared pointer has the typical dereference
    operators, `*` and `->`.
  prefs: []
  type: TYPE_NORMAL
- en: const correctness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The topic of `const` correctness can be a contentious one in the C++ community.
    The instructor of my first C++ course went as far as to say that the `const` keyword
    was one of the most important keywords in the language. Of course, I have also
    heard the other side, with developers telling me how they never use `const` and
    it is a complete waste of keystrokes. I like to think I fall somewhere in the
    middle on `const`; I believe that it has important uses, but it can be overused
    just like any other feature. In this section, I want to show some of the better
    uses for `const`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick review, the `const` keyword is used as a type qualifier to let the
    compiler know that this value or object cannot change, it is constant. When first
    starting out with C++ game development, your first exposure to `const` will probably
    come early on. Most commonly, the introduction to using *const-ness* has been
    in the defining of important values that we want to have easy access to, say something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This then gives us a named value that we can easily use many times in other
    parts of our code. The big advantage of doing this is that if we then decided
    to change the value, in this case, the maximum amount of bullets, we can just
    change this constant value instead of having to change numerous amounts of hardcoded
    values scattered throughout the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: As you get deeper into C++ development, the `const` keyword will become a more
    familiar site. It is used heavily in libraries and engine code in a variety of
    ways. It is also utilized in the definition of parameters for functions or used
    as a modifier for a function definition. Let's briefly take a look at these.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, when used in the definition of parameters, it becomes an insurance that
    the function we are giving the value to is not going to modify it in any way.
    Take the following code, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, this is a very simple example, but if you did call a function like this,
    unaware of the fact that it could modify the object, you would end up with results
    you might not have been expecting. There are two ways that the `const` keyword
    helps solve this possible issue. One is by using the `const` keyword when passing
    the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This now makes it impossible to modify the value passed in anywhere in the function,
    keeping it constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way is by creating functions that are `const` safe. When you define
    a function as being a `const` function, it then allows `const` objects to call
    it. By default, `const` objects cannot call non `const` functions. However, non
    `const` objects can still call `const` functions. To define a function as being
    a `const` function, we can add the `const` keyword to modify the function definition
    itself. You simply add `const` to the end of the function signature, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is my preferred method of writing any function that is not going to modify
    any objects or values. It allows some flexibility in ensuring that it can be called
    from `const` objects in the future, and it also allows other developers using
    the function in their code to easily identify that the function will not modify
    any object or value used in combination with it.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of **memory management** in C++ is often the topic of nightmares for
    beginners. I have commonly heard developers make statements like *I don't use
    C++ because of its manual memory management*. The truth is manual memory management
    is very rare in the vast majority of projects. These days with modern concepts
    like managed smart pointers, hand built memory management systems is of little
    importance for day-to-day development. It is only when you get to high-performance
    computing, such as game development, does the idea of controlling memory allocation
    and deallocation become a concern. When it comes to game development, the overall
    memory availability and speed on consoles continue to be a concern for developers,
    which is also true for most mobile devices, despite the rapid growth of affordable
    high memory devices. Over this next section, we will take a refresher look at
    the stack and heap, and the differences in how to handle memory allocation. This
    will lay the groundwork for the next chapter where we will see an example of a
    custom memory manager system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the stack, the appropriately named, **memory construct**,
    which you can think of much like a stack of plates or dishes. When you create
    an object or variable on the stack, it is placed on the top of the pile. When
    the object or variable goes out of scope, this is analogous to the plate or dish
    being removed from the stack. An allocation on the stack would look something
    like this in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates an integer value, and assigns it the value of `10`. The
    memory needed to store the integer is allocated on the stack. The second line
    has exactly the same idea, just for a `Player` object instead.
  prefs: []
  type: TYPE_NORMAL
- en: A good thing about using the stack is that any memory we allocate will be cleaned
    up for us when the object or variable goes out of scope. This can, however, be
    a double-edged sword; a lot of newer developers run into issues where they look
    for or make calls to objects after they have gone out of scope because they used
    the stack to store them. The other issue with the stack is that it is limited
    in size, which depends on the platform and compiler settings. This can become
    an issue if you have a lot of objects being created and held for an extended period
    of time. Trying to allocate more memory than available on the stack will throw
    a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The alternative is the heap, which you can think of as being a large blob or
    container of memory. Unlike the stack, this heap of memory is unordered and can
    easily become fragmented. The good news is modern memory, and operating system
    implementations offer a low-level mechanism for dealing with this fragmentation,
    commonly known as **memory virtualization**. Another bonus of this virtualization
    is that it provides access to more heap storage than the physical memory provides,
    by swapping memory out to the hard drive when needed. To allocate and destroy
    memory on the heap, you use the keywords `new` and `delete`, and `new[]` and `delete[]`
    for containers of objects. The code will look something like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines create a `Player` object and a character array on the heap.
    The next two lines delete these objects, respectively. It is important to remember
    for every chunk of memory you create on the heap, you must call delete to destroy
    or release that chunk of memory. Failure to do so can cause memory leaks, where
    your application continues to consume more and more memory until the device runs
    out and crashes. This is a common issue and can be hard to track out and debug.
    Memory leaks are one of the reasons new developers tend to think C++ memory management
    is hard.
  prefs: []
  type: TYPE_NORMAL
- en: So what should you use, the stack or the heap? Well, it really depends on the
    implementation and the object or value being stored. A good rule of thumb I recommend
    is that if you can get away with using the stack for your allocation, that should
    be your default. If you do find yourself needing to use the heap, try and use
    a manager system to handle the creation and deletion. This will cut down on the
    chances of memory leaks and other issues that arise from handling your own memory
    management. We will look at how to build your own memory manager as part of your
    core libraries in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I wish I could say that every line of code I write works flawlessly the first
    time. The reality is that I am human and prone to making errors. Dealing with
    these mistakes and tracking down the bugs can be where most development time is
    spent. Having a good way to catch and deal with these any other issues that occur
    during the running time of your game is crucial. This section covers some of the
    C++ techniques used for finding and handling errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'One technique that you can use when you hit an issue is to gracefully let the
    program crash. Meaning that instead of having the computer crash on its own, we
    tell the computer to stop the execution of our code and exit immediately. To do
    this in C++, we can use the `assert()` method. An example would look something
    like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When the computer hits the line of code `assert(number != NULL);` it checks
    to see whether the integer number is `NULL`, whether this evaluates to true, in
    this case, it will cause an assertion failure that immediately stops execution
    and exits the program. This allows us, at least, some control. We can use the
    opportunity provided by the `assert()` function to capture more information to
    create a crash report. We can print out the file, line, and even a description
    of the error as a custom message. While this does work, it leaves a lot to be
    desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another technique that handles errors which can provide a little more flexibility
    is exceptions. Exceptions work like this; when the program runs into an issue,
    it can throw an exception that halts the execution. The program then looks for
    the nearest exception handling block. If it is unable to find that block in the
    function that threw the exception, it then looks to the parent function for a
    handling block. This process unwinds the stack, meaning that all objects created
    on the stack will be destroyed in the order they were passed in. This process
    will continue until the program finds a handling block or hits the top of the
    stack at which point the default exception handler will be called, and the program
    will quit. The overall the syntax used to handle exceptions in C++ is pretty straightforward.
    To throw an exception, you use the keyword `throw`. This will trigger the program
    to look for a handling block, denoted with the keyword `Catch`. A `Catch` block
    must be located right after a `Try` block, which encapsulates the code that might
    throw the exception. A simple example of this would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also catch and handle specific errors by passing the exception type
    as an argument to the Catch block, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The advantage of using exceptions is that we have the flexibility to handle
    the error any way we want. We could, if the situation allows, correct this issue
    that caused the error and continue on, or we could simply dump some information
    to a log file and exit the program. The choice is ours.
  prefs: []
  type: TYPE_NORMAL
- en: Which solution you implement to handle errors is completely up to you and the
    project you are working on. Some developers do, in fact, choose just to ignore
    handling errors all together. I, however, highly recommend using some sort of
    error handling system. In the example code used for the demos throughout the book,
    I implement an exception handling system. I recommend looking at that implementation
    as a starting reference. The suggested reading section at the end of this chapter
    also contains some great references on handling errors.
  prefs: []
  type: TYPE_NORMAL
- en: Working with types and containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ is a strongly-typed unsafe language. It provides an incredible amount of
    control, but it ultimately expects the programmer to know what they are doing.
    Understanding how to work with types at an advanced level is paramount to mastering
    game library and core system programming. Game development relies heavily on the
    flexibility of types in C++, it also relies on the advanced libraries available
    like the **Standard Template Library** (**STL**). Over the next few sections,
    we will look at some of the more common containers used in game development and
    their STL implementations. We will also cover how to create generic code through
    use templating. Finally, we will wrap up the topic of types and containers with
    a look at type inference and its more often seen use cases.
  prefs: []
  type: TYPE_NORMAL
- en: STL generic containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ STL is a collection of container classes that allow storage of data
    in different structures, with iterators that provide access to elements of the
    container, and algorithms that can perform operations on the containers and the
    elements they hold. These structures, iterators, and algorithms are extremely
    optimized and in most cases use the latest implementations of the C++ language
    standard. The STL makes extensive use of the templating feature in C++ to allow
    easy adaptation for use with our own types. We will take a look at templating
    in the next section. The STL is a huge topic, with many books written on the concepts
    and implementation. If you have had little experience with the STL, I highly recommend
    reading some of the amazing books that have been written on the subject. I have
    listed a few in the *Summary* section at the end of this chapter. This section
    will concentrate on highlighting some of the STL containers that are more commonly
    used in game development. I am going to assume that you have a basic understanding
    of containers and that you have had some experience using iterators to traverse
    elements in a container.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with two sequence containers, vector and list. The reason they are
    referred to as **sequence containers** is because they store their elements in
    a specific order. This allows elements to be added or removed anywhere in that
    order, or sequence. Vector and list are some of the most popular STL sequence
    containers you will come across. Knowing some key facts will help you decide which
    one is the best for a particular task. I have included a few suggestions to help
    guide you.
  prefs: []
  type: TYPE_NORMAL
- en: Vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Vector** is one of the most basic containers offered in the STL. While it
    is comparatively simple, it is highly flexible and is one of the most widely used
    containers in game development. The place you are most likely to see it is in
    replacement of a C array. One of the bigger drawbacks that comes with using arrays
    is that you have to define the size of the array at declaration. This means, in
    most cases, you will need to know the maximum amount of elements needed, or you
    need to allocate more than you will ever need. Luckily for us vectors do not have
    this, predefined size, drawback; a vector will grow to accommodate new elements
    that are added. To create a vector of integers, we can use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You probably noticed `std::` before `vector`, that is because the `vector` class
    is part of the `std` namespace, so we need to identify that we wish to use that
    implementation. See the *Working with namespaces* section earlier in the chapter
    for a review. We can avoid having to type this by adding a `using namespace std;`
    statement at the beginning of the code file. I prefer to add `std::` to my standard
    library calls, or any other specific namespace call. Since game development uses
    so many libraries having a lot of `using` statements can become messy and error
    prone. Although it takes a few extra keystrokes, it can save a pile of headaches.
  prefs: []
  type: TYPE_NORMAL
- en: I personally use vectors in place of arrays in most cases, and would suggest
    you do too. Before you go changing all of your arrays to vectors, though, it is
    important to note one aspect of vectors that could potentially cause issues. When
    you create a vector, one contiguous block of memory is allocated for it. The amount
    of memory depends on the amount of elements in the vector. There will always be
    room for all the elements currently in the vector plus a little extra to allow
    for the addition of new elements. This is the trick of a vector, as you add more
    elements, and ultimately start to run out of space, the vector will grab more
    memory so that it always has room for new elements. It does this by first creating
    a new block of memory, copying all the contents of the first block of memory and
    then deleting it. This is where the issues can creep in. To prevent constant allocation,
    copy, and deletion, when a vector allocates new memory, it generally doubles the
    previous size. Since a vector can never shrink, if we have used a vector in a
    way that creates large additions and subtractions of elements, this can easily
    become a memory issue, especially for lower memory devices. Knowing this should
    not prevent you from using vectors, when implemented in the right situations this
    should rarely become a problem and can be easily mitigated through refactoring
    if it does arise.
  prefs: []
  type: TYPE_NORMAL
- en: Some perfect examples of when to use a vector would be in cases like; a list
    of players, character animation lists, player weapons, really any list that you
    might add to and remove from infrequently. This will avoid the possible memory
    issues while giving you access to vector's iterators, algorithms, and other benefits.
  prefs: []
  type: TYPE_NORMAL
- en: List
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **list** is another type of sequence container you are likely to see when
    developing games with C++. To create a list container of integer values the syntax
    would look something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The list container is quite different from the vector in its implementation
    and general usage in development. The key difference is that unlike a vector,
    the list container does not store all its elements in one large contiguous block
    of memory. Instead, it stores its elements as nodes in a doubly linked list. Where
    each of these nodes holds a pointer to the next and previous nodes. This, of course,
    makes the extra memory allocation issues of the vector disappear since only the
    memory for each element in the list is allocated beforehand. When a new element
    is added only memory for the new node is created, saving the wasted memory you
    might see in a vector implementation. This also allows elements to be added anywhere
    in the list with far better performance compared to a vector container. There
    are some drawbacks, though. Due to this setup of individual nodes in memory, each
    operation on the list will more than likely end up causing a memory allocation.
    With each node possibly scattered around memory in no guaranteed ordered, this
    constant memory allocation might be a potential issue on systems with slower dynamic
    memory. This also means that a list is slower to traverse through its elements
    than a vector is. Again this is not meant to discourage you from using lists in
    your projects. I would give the advice to use a list wherever you have a group
    of objects or elements that you plan on adding to or deleting from frequently.
    A good example would be of a list game objects or meshes to render in each frame.
    A list should not be thought of as a replacement for a vector. Each has its own
    advantages and disadvantages, finding the best choice for a solution is often
    the hardest part.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last container we will take a look at is a commonly used **associative
    container**. Unlike sequence containers, associative containers do not preserve
    the relative positions of the elements in them. Instead associative containers
    are built for speed, more specifically element lookup speed. Without getting into
    **Big O notation**, these associative containers, and their corresponding algorithms
    far outperformed vector and list when it comes to looking up specific elements.
    The reason they are referred to as associative containers is that they usually
    provide a key/data pair that facilitates this faster lookup. It should be noted
    that sometimes the key in the container is the data itself. The one we will be
    focusing on here is the map container.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maps are very handy containers for a multiple of uses in game development. What
    makes maps unique compared to vectors or list, is that each map is made up of
    two pieces of data. The first piece of data is a key and the second is the actual
    element stored. This is what makes maps so performant at looking up elements.
    An easy way of thinking of this is that maps are like arrays, but instead of using
    integer values to index elements, maps use keys, that can be of any type, to index
    its elements. Maps even have a specialized `[]` operator that allows you to access
    elements using the familiar array syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a map with an integer as the key and strings as the element type
    or value, our code would look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When it comes to memory usage, maps are different from both the list and vector
    containers. Maps do not store their data in contiguous blocks like vectors, instead
    they hold their elements in nodes, much like a list. The difference in how the
    list and map handle their allocation is in the way the nodes are structured. The
    nodes in a map have pointers to the next node and previous node, like the list,
    but these nodes are arranged in a tree pattern. This tree pattern autobalances
    itself with the addition and deletion of nodes. The good news is that this balancing
    act does not add any new allocations. The performance of a map is very similar
    to a list, since the memory management is similar, the only time you might see
    a difference is in the very slight overhead of the automatic balancing of the
    node tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way maps are often used is in the form of a dictionary. They provide very
    fast lookup of unique values through their key; because of this, some good example
    maps in game development are: a list of game elements with unique IDs, a list
    of multiplayer clients with unique IDs for keys, and for almost any situation
    in which you have a group of elements that you want to store with some sort of
    key-value pair.'
  prefs: []
  type: TYPE_NORMAL
- en: Templating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Templates are a newer concept in the C++ language. Templates help solve the
    all too common issue of having to rewrite the same code when different datatypes
    or classes are being used. This allows us to write what is referred to as generic
    code. We can then use this generic code in other parts of our project. As of the
    C++14 standard, there are now three types of templates that can be used: **class
    templates**, **function templates**, and **variable templates**. Let''s take a
    closer look at each of them in the upcoming sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Class templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using class templates, we can create abstract classes that can be defined without
    specifying what datatype will be handled by the functions of the class. This becomes
    very useful when building libraries and containers. In fact, the C++ Standard
    library makes extensive use of class templates, including the `vector` class we
    saw earlier in the chapter. Let's take a look at a simple implementation of a
    `Rectangle` class. This could be a useful class for finding screen coordinates,
    buttons and other GUI pieces, and even simple 2D collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic implementation without using class templates will look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This works fine in most cases, but if we want to use this rectangle in a different
    coordinate system that uses values of say 0.0 to 1.0, we will have to make some
    changes. We could just copy the code and change the integer datatypes to float,
    that would work just fine, but using class templates we can avoid this code duplication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using templates, the new `Rectangle` class will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The first change you will notice is the inclusion of `template<class T>` right
    before our class definition. This tells the compiler that this class is a template.
    The `T` is a placeholder for a datatype. The second change is that all the integer
    datatypes have been replaced with this placeholder. So now we can create a rectangle
    using the `int` datatype like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When the compiler comes across this line of code, it goes through the template
    class and replaces all the instances of the placeholder with `int`, and then compiles
    the new class on-the-fly. To create a rectangle using float values, we could then
    use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We can do this for any datatype we like; the only restriction is that the types
    must be supported in the operations of the class. If they are not, a runtime error
    will be thrown. An example of this would be a class template that has the multiplication
    function and is trying to use that template with a string.
  prefs: []
  type: TYPE_NORMAL
- en: Function templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept of function templates is very similar to class templates; the big
    difference is that function templates do not need to be explicitly instantiated.
    They are created automatically based on the datatypes passed in. The following
    will swap two values, but it is not specific to any class type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then pass integer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In fact, you can use this function with any type that supports assignment operators
    and a copy constructor. The restriction here is that both datatypes must be of
    the same type. This is true even if the datatype has an implicit conversion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Variable templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last type of template I want to mention quickly is the variable template,
    not to be confused with **variadic templates**. Introduced in C++14, the variable
    template allows the wrapping of a variable within a templated struct or class.
    The conical example often used is for the mathematic construct of pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This then means you can refer to `pi` as a `float`, `int`, or `double` variable
    and use it in generic functions, for example, to compute the area of a circle
    with a given radius:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: And again this templated function can be used with various datatypes, so you
    can return an area as an integer, a floating point value, or any other supported
    datatype. You may not see variable templates used that often, yet. They are still
    considered a new idea in C++, but it is important to be aware of their existence.
    They do have some unique cases and may one day help you solve a difficult problem.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, templates do have their benefits, and I encourage you to use
    them where it makes sense. However, it is important to note some of the possible
    drawbacks when implementing templates. The first potential drawback is that all
    templates must have their entire implementation in the same file, usually the
    header. The `export` keyword corrects this, but not all commercial compilers support
    it. Another drawback of templates is that they are notorious for being hard to
    debug. Compilers tend to give cryptic errors when the issue resides inside of
    the templated code. My biggest advice is to use them with caution, just like every
    other feature. Just because a feature is advanced does not mean it's a good fit.
    Finally, check your compiler for exact details on implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference and when to use it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the C++11 standard came some very useful **type interference** capabilities.
    These new capabilities give programmers, even more, tools to create generic, flexible
    code. In this section, we will look at these new capabilities in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin with a new, powerful keyword. The `auto` keyword allows you to
    have the compiler infer the variable type, if possible, at the time of declaration.
    This means that instead of defining a variable like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now just use `auto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: However, this is not the best use of the `auto` keyword, in fact, this is a
    perfect example of what you should not do. As tempting as it might be to use `auto`
    when declaring any variable, this not only adds completely unnecessary overhead
    to compiles, it makes your code harder to read and follow. That's what you should
    not do with `auto`, so what should you do with `auto`? Well, where `auto` really
    shows its helpfulness, is when it is used in concert with templates. When coupled
    with the `auto` keyword, templates can become extremely flexible and powerful.
    Let's take a look at a quick example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we have a simple templated function that creates some game
    objects for us, something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To call this code, we will use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This code works fine, but it could be a little more flexible and easier to
    read with the use of the `auto` keyword. Our code will now look something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And then our code to call this function will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: While this is an oversimplification, it should allow you to see the possibilities
    that `auto` can provide. By not defining what type the object factory will return,
    we allow the factory more freedom in its implementation, which in return allows
    for greater uses of the factory in our code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the places you will tend to see the `auto` keyword in action, outside
    of templates, is in the declaration of iterators in for loops. This has become
    the common practice in a lot of the more modern libraries. You will often see
    for loops written like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `auto` keyword has a helper keyword, `decltype`, which extracts the type
    from a variable. So where `auto` is used to let the compiler infer what the variable
    type is, the `decltype` is utilized to determine what a variable''s type is. This
    becomes very useful when you add in the last part of the `auto` keywords functionality,
    as a `return` value. Before C++11 and the `auto` keyword, `return` values had
    to be declared before the function name, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the `CreateObject` function must return a `TreeObject` type,
    but as mentioned earlier, letting the compiler infer what `objFactory.MakeObject();`
    returns allows greater flexibility. In order to infer the type of object returned
    from a function, we can use the concept of `auto`, `decltype`, and the new `return`
    syntax. Our new function will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Also note that `auto` and `decltype` do add some overhead to our compile time.
    In most cases this will be insignificant, but in certain circumstances it could
    become an issue, so be conscious of this when incorporating these new keywords
    in your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: As you continue to build more libraries and toolsets, having the ability to
    build more generic, flexible code will become crucial. Tricks like using `auto`,
    `decltype`, and the new `return` syntax are just some of the ways to accomplish
    this. In the next sections and chapters, we will see more of these useful concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Game programming patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A programming pattern or development pattern, simply put, is a solution to a
    commonly faced or reoccurring problem. It is a description or template that provides
    a solution that can be used in many different situations. These patterns are formalized
    best practices, often developed through years of iterations. By using patterns
    in your project, you can make your code more performant, stronger, and more adaptable.
    They allow you to build structured code that is decoupled by nature. Having this
    decoupling is what makes your code more generic and easier to work with. You no
    longer have to cram the entire program into your mind to understand what a particular
    section of code is trying to accomplish. Instead, you can focus on smaller chunks
    that function independently. This is the true power of object-oriented design.
    This decoupling will also make it easier to track down bugs during testing by
    isolating the issue or issues to a certain segment of code.
  prefs: []
  type: TYPE_NORMAL
- en: Having a solid understanding of, at the least, the most fundamental patterns
    will be critical as you start to build your own libraries and engine structure.
    In the next few sections, we will look at some of these basic patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Working with loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arguably, one of the most important concepts in game development is the concept
    of loops. If you have ever built a game before, I can almost guarantee that you
    have used some sort of loop. Even though loops are common, the particular implementation
    of a loop is often not. Patterns give developers guidelines and structure to build
    performant, flexible loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common loop patterns is the **game loop pattern**. The intent
    of the game loop pattern is to provide a mechanism to decouple the passage of
    game time from the user input and other events, regardless of the processor''s
    clock speed. An easy way to explain it is: a game loop runs continuously during
    the operation of the game, or during a specific state, see state machines in a
    later section. During this continuous looping, each tick or turn of the loop,
    we have a chance to update parts of the game. This usually includes updating the
    current game state, checking and updating any user input, without blocking, and
    a call to draw or render any game objects. Many platforms and almost all engines
    have their own implementation. It is important to note whether the platform or
    engine you are using does have their own game loop. If it does, you will then
    have to hook your code and loop structure into the provided mechanism.'
  prefs: []
  type: TYPE_NORMAL
- en: As an example, the Unity game engine abstracts the looping process, they expose
    connectivity to the internal game loop through the `Update()` function inherited
    by all game objects. This Unity structure is an excellent example of how the game
    loop pattern can be combined with other patterns like the update pattern to build
    a cascading loop system that allows the main game loop to drive the internal looping
    mechanism of each object. We won't build a complete example right now, but as
    we continue through the book, we will see more of how structures like this are
    built. The next few sections will continue this idea of combining patterns to
    build a complete game system flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help picture how a game loop is constructed, let''s take a look at a typical,
    slightly simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of code, `double lastTime = getSystemTime();`, stores the time
    before the first run of the loop. Next we have a simple `while` loop, in this
    situation, the loop will continue to run while the variable `gameOver` is not
    true. Inside the `while` loop, first we get the current time. Next we create a
    `deltaTime` variable, which is the amount of time that has passed since the last
    step of the loop. We then make calls to run the other components of the game:
    `Input`, `Update`, and `Draw`. This is the key to the game loop pattern; we use
    this standard running loop to drive the game forward. You might notice that we
    pass `deltaTime` through to the `Update` method. This is another important component
    of the loop, without getting too deep into the update pattern, by passing along
    the time that has elapsed between loops we are able to modify things like the
    game object physics using proper time slices, which is important to keep everything
    in sink and looking smooth. This style of the game loop pattern implementation
    is called a **variable time step** pattern since the loop steps are based on the
    amount of time the update takes. The longer the update code takes, the longer
    the time between the steps will be. This means each step of the loop will determine
    how much real time has passed. Using this method means that the game will run
    at a consistent rate on different hardware, it also means users with powerful
    machines will be rewarded with smoother gameplay. This implementation is far from
    perfect though. It doesn''t optimize the rendering or deal with lag that can occur
    between steps, but it''s a good start. Understanding what is happening under the
    hood is a significant step. In the next section, we will look at a pattern that
    allows us to create code paths based on events, this coupled with loops is the
    natural evolution of the game system flow.'
  prefs: []
  type: TYPE_NORMAL
- en: State machines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next pattern we will examine is the **state pattern**; more specifically,
    we will look at finite state machines. State machines are an extremely powerful
    engineering concept. While not a common pattern in most programming disciplines,
    except maybe AI development, finite state machines play a significant role in
    building branching code. It might be surprising to know that many mechanical logic
    circuits found in our day-to-day life are constructed from forms of finite state
    machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'A real-world example would be a set of traffic lights, which changes state
    based on cars waiting (maybe not fast enough sometimes). A finite state machine
    can be boiled down to an abstract system where the machine can be in one, and
    only one, of a limited number of states. The machine will stay in this state,
    referred to as the current state, until an event or triggered condition causes
    a transition. Let''s look at an example that demonstrates this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: To begin with, we have an `enum` structure that houses our game states. Next,
    we create a `GameState` variable type to hold the current game state that the
    machine is in. Then in an `Update` loop, we implement a `switch case` construct
    that controls the flow of transitions from state to state. The key to this implementation
    is that each state of the machine has a transition state to the next. This keeps
    the machine running and allows us to perform different actions depending on the
    current state the machine is in. While this is probably one of the most basic
    forms of a game state machine, it does demonstrate the usefulness of the finite
    state pattern. As you move on to the creation of libraries and other components,
    you will start to see more and more uses for these incredible tools. There are
    many other, more complicated implementations and, even more, patterns to help
    describe them. Some of these will be seen in the later chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Event listeners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Very often in the game development process, you will find cases where you have
    a need for certain code to execute based on some user input, or from a condition
    fired from another chunk of code. Maybe you just need a solid way for game object
    communicate. This is where the idea of using an event or message passing system
    comes in. Numerous patterns have been created to help solve this problem, including
    **Overseer**, **Model View Controller**, and others. Each of these patterns implements
    a different mechanic for handling events; many actually build off of each other.
    However, before we jump into using one of these patterns, I believe it is important
    to understand the foundation of what is happening under the hood to power all
    these solutions. By building our own solution, we will gain a better understanding
    of the problem, and more appreciation for the patterns that solve it. In our example,
    we will use the concepts we have learned throughout the chapter to build a simple,
    but reusable event systems that could be used in your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first approach we could take uses the simple version of the state machine
    we just looked at. In this approach, we use a `switch case` construct to branch
    the code based on the type of event passed in. To save space and time, some basic
    structure code has been omitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This is a quick and dirty implementation, and will work in some very basic situations.
    If we use a struct or union for our event type, we could add some simple message
    capability which would make it even more useful. Unfortunately, this approach
    ultimately has too many significant issues. First is the fact that we need to
    have a single source of event types. We then have to edit this source every time
    we want to add a new event type. Second is the `switch case` construct, again
    every time we wish to add a new event type we have to append and modify this section.
    All this is very tedious, prone to errors, and is bad design in an OOP-enabled
    language.
  prefs: []
  type: TYPE_NORMAL
- en: A second approach we can take relies on the capabilities of **Run-time type
    information** (**RTTI**), which is the concept of determining the type of a variable
    at runtime. Using RTTI gives us the ability to use `dynamic_cast` to determine
    the event type in our solution. I should point out that not all RTTI implementations
    are the same, and may not be turned on by default in all compilers. Check your
    compiler's documentation for exact information.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start off with, we create a simple base class for all of the specific events
    we will create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it is simply a matter of using `dynamic_cast` to determine the type of
    event and passing along the message info to the object''s own handling function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a more elegant solution than the first one we saw. It provides more
    flexibility and is easier to maintain. However, we can refactor this code to make
    it even simpler. Using the concept of templates we learned earlier, and good old
    fashion overloading, our new code can be structured like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Like the other examples in this chapter, this example is meant to be basic.
    While it is true that this new approach is cleaner and more adaptable than the
    first, it does have some drawbacks of its own. This includes the overhead of `dynamic_cast`,
    which is entirely dependent on the structure of the class hierarchy. The problem
    of maintenance and error-prone code still exists with the `if...else` chain. Plus,
    we also have the bigger, much more important issue of improper type detection.
    For example, with this approach, if we have a type that is inherited from another,
    say a `LargeExplosion` class from the `Explosion` class. If the queries to the
    object's type are out of order, the event pointer is cast to the `Explosion` class
    first, when in actuality it is pointing to the `LargeExplosion` class, the compiler
    will improperly detect the type and call the wrong version of the function. A
    somewhat more ideal solution would be to have an `EventHandler` class that would
    handle the registration, storage, and polymorphic functions for all events. You
    could then have member function handlers that would implement specific event types,
    which could, in turn, inherit from a handler function base class. This would solve
    many of the issues we have seen with the other two approaches while giving us
    a more generic, reusable implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We'll stop our implementation here, though. Since event handling systems play
    such a strong role in many different parts of game systems, from the toolchain
    to user input and networking, we will see a lot more of these patterns and techniques
    used throughout the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot in this chapter. We discussed some of the more advanced C++
    topics used in modern game development. We looked at inheritance and polymorphism,
    pointers, referencing and the common STL generic containers. The concept of templating
    and building generic code with class, function, and variable templates. Type inference
    and the new language keywords `auto` and `decltype` and their uses in combination
    with the new `return` value syntax. Finally, we closed out the chapter looking
    at some core game patterns used today.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how we can use these key concepts to create
    core libraries that can be used and reused in our game development projects.
  prefs: []
  type: TYPE_NORMAL
