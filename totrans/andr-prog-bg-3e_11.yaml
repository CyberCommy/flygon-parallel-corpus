- en: '*Chapter 11*: More Object-Oriented Programming'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：更多面向对象编程'
- en: This chapter is the second part of our whirlwind tour (theoretical and practical)
    into OOP. We have already briefly discussed the concepts of encapsulation, inheritance,
    and polymorphism, but in this chapter, we will get to see them more in action
    in some demo apps. While the working examples will show these concepts in their
    simplest forms, it will still be a significant stepping stone towards taking control
    of our layouts via our Java code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是我们对面向对象编程的风潮之旅（理论和实践）的第二部分。我们已经简要讨论了封装、继承和多态性的概念，但在本章中，我们将看到它们在一些演示应用程序中更加实际的运用。虽然工作示例将展示这些概念以其最简单的形式，但这仍然是朝着通过我们的Java代码控制布局的重要一步。
- en: 'In this chapter, we will explore the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下内容：
- en: Encapsulation in depth and how it helps us
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解封装及其帮助我们的方式
- en: Inheritance in depth and how to take full advantage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解继承及如何充分利用
- en: Polymorphism explained in greater detail
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更详细地解释多态性
- en: Static classes and how we have been using them already
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态类及我们已经在使用的方式
- en: Abstract classes and interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类和接口
- en: First, we will handle encapsulation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将处理封装。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2011](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2011).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中的代码文件[https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2011](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2011)。
- en: Remember that encapsulation thing?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还记得封装吗？
- en: So far, what we have really seen is what amounts to a kind of code-organizing
    convention where we write classes, full of variables and methods. We did discuss
    the wider goals of all this OOP stuff but now we will take things further and
    begin to see how we actually manage to achieve encapsulation with OOP.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们真正看到的是一种代码组织约定，我们编写类，充满了变量和方法。我们确实讨论了所有这些面向对象编程的更广泛目标，但现在我们将进一步探讨，并开始看到我们如何实际通过面向对象编程实现封装。
- en: Definition of encapsulation
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 封装的定义
- en: Encapsulation describes the ability of an object to hide its data and methods
    from the rest of the world, allowing only the variables and methods you choose
    to be accessed. This means your code can always be updated, extended, or improved
    without affecting the programs that use it – provided the exposed parts are still
    made accessible in the same way. It also allows the code that uses your encapsulated
    code to be much simpler and easier to maintain because much of the complexity
    of the task is encapsulated within your code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 封装描述了对象隐藏其数据和方法不让外界访问的能力，只允许访问您选择的变量和方法。这意味着您的代码始终可以更新、扩展或改进，而不会影响使用它的程序——只要暴露的部分仍然以相同的方式可访问。它还允许使用您封装的代码的代码变得更简单、更易于维护，因为任务的大部分复杂性都封装在您的代码中。
- en: 'But didn''t you say we don''t have to know what is going on inside? So you
    might question what we have seen so far like this: If we are constantly setting
    the instance variables like this `rambo.health` `= 100;`, isn''t it possible that,
    eventually, things could start to go wrong, perhaps like this?'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你不是说我们不需要知道内部发生了什么吗？所以你可能会像这样质疑我们迄今为止所看到的东西：如果我们不断地设置实例变量，比如`rambo.health
    = 100;`，难道不可能最终出现问题，比如这样吗？
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Encapsulation protects the objects of your class from being used in a way that
    they weren't meant to be. By controlling the way that your classes' code is used,
    it can only ever do what you want it to do and with value ranges that you can
    control.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 封装保护了您的类的对象，使其无法以其不应有的方式使用。通过控制类代码的使用方式，它只能做您想要做的事情，并且具有您可以控制的值范围。
- en: 'It can''t be forced into errors or crashes. Also, you are then free to make
    changes to the way your code works internally, without breaking the rest of your
    program or any programs that are using an older version of the code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它不会被强制出现错误或崩溃。此外，您可以自由地更改代码的内部工作方式，而不会破坏程序的其余部分或使用旧版本代码的任何程序：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Encapsulation is not just vital for writing code that other people will use
    (such as the Android API that we use), it is also essential when writing code
    we will reuse ourselves as it will save us from our own mistakes. Furthermore,
    a team of programmers will use encapsulation extensively so that different members
    of the team can work on the same program without all members of the team knowing
    how the other team members' code works. We can encapsulate our classes for this
    same advantage and here is how.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 封装不仅对于编写其他人将使用的代码（例如我们使用的Android API）至关重要，而且在编写自己将重复使用的代码时也是必不可少的，因为它将使我们免受自己的错误。此外，程序员团队将广泛使用封装，以便团队的不同成员可以在同一程序上工作，而不需要所有团队成员都知道其他团队成员的代码如何工作。我们可以为了获得同样的优势而封装我们的类，以下是如何做到的。
- en: Controlling class use with access modifiers
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用访问修饰符控制类的使用
- en: 'The designer of the class controls what can be seen and manipulated by any
    program that uses their class. We can add an `class` keyword like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 类的设计者控制着任何使用其类的程序所能看到和操作的内容。我们可以像这样添加一个`class`关键字：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Class access modifiers
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类访问修饰符
- en: 'There are two main access modifiers for classes in the context we have discussed
    so far. Let''s briefly look at each in turn:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了上下文中类的两个主要访问修饰符。让我们依次简要地看一下每一个：
- en: '`public`: This is straightforward. A class declared as public can be seen by
    all other classes.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`：这很简单。声明为public的类可以被所有其他类看到。'
- en: '`default`: A class has default access when no access modifier is specified.
    This will make it public but only to classes in the same package and inaccessible
    to all others.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`：当未指定访问修饰符时，类具有默认访问权限。这将使其对同一包中的类公开，但对所有其他类不可访问。'
- en: So now we can make a start on this encapsulation thing. But even at a glance,
    the access modifiers described are not very fine-grained. We seem to be limited
    to complete lockdown to anything outside the package or a complete free-for-all.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始封装这个东西了。但是，即使乍一看，所描述的访问修饰符也不是非常精细。我们似乎只能完全封锁包外的任何东西，或者完全自由。
- en: Actually, the benefits here are easily taken advantage of. The idea would be
    to design a package of classes that fulfills a set of tasks. Then, all the complex
    inner workings of the package, the stuff that shouldn't be messed with by anybody
    but our package, should be default access (only accessible to classes within the
    package). We can then make available a careful choice of public classes that can
    be used by others (or other distinct parts of our program).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这里的好处很容易被利用。想法是设计一个包含一组任务的类包。然后，包的所有复杂内部工作，那些不应该被任何人干扰的东西，应该是默认访问权限（只能被包内的类访问）。然后我们可以提供一些精心选择的公共类，供其他人（或程序的其他不同部分）使用。
- en: Important note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: For the size and complexity of the apps in this book, creating multiple packages
    is overkill. We will of course be using other people's packages and classes (the
    public parts), so this stuff is worth knowing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中应用程序的大小和复杂性来说，创建多个包是过度的。当然，我们将使用其他人的包和类（公共部分），所以了解这些内容是值得的。
- en: Class access in summary
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类访问权限总结
- en: A well-designed app will probably consist of one or more packages, each containing
    only default or default and public classes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的应用程序可能由一个或多个包组成，每个包只包含默认或默认和公共类。
- en: In addition to class-level privacy controls, Java gives us programmers very
    fine-grained controls, but to use these controls, we have to look into variables
    with a little more detail.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类级别的隐私控制之外，Java还为我们程序员提供了非常精细的控制，但要使用这些控制，我们必须更详细地研究变量。
- en: Controlling variable use with access modifiers
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用访问修饰符控制变量的使用
- en: 'To build on the class visibility controls, we have variable access modifiers.
    Here is a variable with the `private` access modifier being declared:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加强类的可见性控制，我们有变量访问修饰符。这是一个声明了`private`访问修饰符的变量：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note also that all of our discussion of variable access modifiers applies to
    object variables too. For example, here is an instance of our `Soldier` class
    being declared, created, and assigned. As you can see, the access specified in
    this case is public:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们对变量访问修饰符的所有讨论也适用于对象变量。例如，这里声明、创建和分配了我们的`Soldier`类的一个实例。如你所见，这种情况下指定的访问权限是公共的：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Before you apply a modifier to a variable, you must first consider the class
    visibility. If class *a* is not visible to class *b*, say because class *a* has
    default access and class *b* is in another package, then it doesn't make any difference
    what access modifiers you use on the variables in class *a* – class *b* can't
    see any of them anyway.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在将修饰符应用于变量之前，必须首先考虑类的可见性。如果类*a*对类*b*不可见，比如因为类*a*具有默认访问权限，而类*b*在另一个包中，那么在类*a*的变量上使用任何访问修饰符都没有任何影响
    - 类*b*无法看到其中任何一个。
- en: So, it makes sense to show a class to another class when necessary but only
    to expose the variables that are directly needed – not everything.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有必要在必要时向另一个类显示一个类，但只公开直接需要的变量 - 而不是所有的变量。
- en: Here is an explanation of the different variable access modifiers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是不同变量访问修饰符的解释。
- en: Variable access modifiers
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量访问修饰符
- en: 'Variable access modifiers are more numerous and finely grained than class access
    modifiers. The depth and complexity of access modification are not so much in
    the range of modifiers but rather in the smart ways we can combine them to achieve
    the worthy goals of encapsulation. Here are the variable access modifiers:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 变量访问修饰符比类访问修饰符更多，也更精细。访问修改的深度和复杂性不在于修饰符的范围，而在于我们可以如何巧妙地组合它们以实现封装的可贵目标。以下是变量访问修饰符：
- en: '`public`: You guessed it, any class or method from any package can see this
    variable. Use `public` only when you are sure this is what you want.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`：你猜对了，任何包中的任何类或方法都可以看到这个变量。只有当你确定这就是你想要的时候才使用`public`。'
- en: '`protected`: This is the next least restrictive after `public`. `protected`
    variables can be seen by any class and any method as long as they are in the same
    package.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected`：这是继`public`之后的下一个最不限制的。只要它们在同一个包中，`protected`变量可以被任何类和任何方法看到。'
- en: '`default`: `default` doesn''t sound as restrictive as `protected` but it is
    more so. A variable has `default` access when no access is specified. The fact
    that `default` is restrictive perhaps implies we should be thinking of hiding
    our variables more than we should be exposing them. At this point, we need to
    introduce a new concept. Do you remember we briefly discussed inheritance and
    how we can quickly take on the attributes of a class and yet refine it by using
    the `extends` keyword? Just for the record, default access variables are not visible
    to subclasses; that is, when we extend a class as we did with an Activity, we
    cannot see its default variables. We will look at inheritance in more detail later
    in the chapter.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`：`default`听起来不像`protected`那么限制，但实际上更加限制。当没有指定访问权限时，变量具有`default`访问权限。`default`限制的事实或许意味着我们应该考虑隐藏我们的变量，而不是暴露它们。在这一点上，我们需要介绍一个新概念。你还记得我们曾简要讨论过继承以及如何可以快速地继承一个类的属性，然后使用`extends`关键字对其进行改进吗？只是为了记录，`default`访问权限的变量对子类是不可见的；也就是说，当我们像对Activity一样扩展一个类时，我们无法看到它的默认变量。我们将在本章后面更详细地讨论继承。'
- en: '`private`: `private` variables can only be seen within the class they are declared.
    This means, like default access, they cannot be seen by subclasses (classes that
    inherit from the class in question).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`：`private`变量只能在声明它们的类内部可见。这意味着，与默认访问权限一样，它们对子类（从所讨论的类继承的类）也是不可见的。'
- en: Variable access summary
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量访问权限总结
- en: A well-designed app will probably consist of one or more packages, each containing
    only `default` or `default` and `public` classes. Within these classes, variables
    will have carefully chosen and varied access modifiers, chosen with a view to
    achieving our goal of encapsulation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的应用程序可能由一个或多个包组成，每个包只包含`default`或`default`和`public`类。在这些类中，变量将具有精心选择和不同的访问修饰符，以实现我们封装目标的目标。
- en: One more twist in all this access modification stuff before we get practical
    with it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实际操作之前，让我们再谈一下所有这些访问修改的东西中的一个小技巧。
- en: Methods can have access modifiers too
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法也可以有访问修饰符
- en: We already briefly mentioned in [*Chapter 9*](B16773_09_ePub_RK.xhtml#_idTextAnchor169)*,
    Learning Java Methods*, that methods can have access modifiers. It makes sense
    because methods are the things that our classes can *do*. We will want to control
    what users of our classes can and can't do.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第9章*](B16773_09_ePub_RK.xhtml#_idTextAnchor169)*，学习Java方法*中简要提到，方法可以有访问修饰符。这是有道理的，因为方法是我们的类可以*做*的事情。我们将想要控制我们的类的用户可以做什么和不能做什么。
- en: The general idea here is that some methods will do things internally only and
    are therefore not needed by users of the class and some methods will be fundamental
    to how users of the class use the class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一般想法是，一些方法将只在内部执行操作，因此不需要类的用户，而一些方法将是类的用户使用类的基础。
- en: Method access modifiers
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法访问修饰符
- en: The access modifiers for methods are the same as for the class variables. This
    makes things easy to remember but suggests, again, that successful encapsulation
    is a matter of design rather than of following any specific set of rules.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的访问修饰符与类变量的访问修饰符相同。这使得事情容易记住，但再次表明，成功的封装是一种设计问题，而不是遵循任何特定规则的问题。
- en: 'As an example, this method, provided it is in a public class, could be used
    by any other class:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，只要它在一个公共类中，这种方法可以被任何其他类使用：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Whereas this method could only be used internally by the class that it is part
    of:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 而这个方法只能被它所属的类内部使用：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And this next method with no access specified has default visibility. It can
    be used only by other classes in the same package. If we extend the class holding
    this `default` access method, the child class will not have access to this parent
    class''s method:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个没有指定访问权限的方法具有默认可见性。它只能被同一包中的其他类使用。如果我们扩展持有此“默认”访问方法的类，子类将无法访问此父类的方法：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As the last example before we move on, here is a `protected` method, only visible
    to the package, but usable by our classes that extend it – just like `onCreate`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前的最后一个例子中，这是一个`protected`方法，只对包可见，但可以被我们扩展它的类使用-就像`onCreate`一样：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's have a quick recap of method encapsulation, but remember that you don't
    need to memorize everything.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下方法封装，但请记住，你不需要记住所有的东西。
- en: Method access summary
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法访问总结
- en: Method access should be chosen to best enforce the principles we have already
    discussed. It should provide the users of your class with just the access they
    need and preferably nothing more. Thereby we achieve our encapsulation goals,
    such as keeping the internal workings of your code safe from interference from
    the programs that use it, for all the reasons we have discussed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 方法访问应该被选择为最好地执行我们已经讨论过的原则。它应该为你的类的用户提供他们所需要的访问权限，最好是没有更多。通过这样做，我们实现了我们的封装目标，比如保护代码的内部工作免受使用它的程序的干扰，出于我们已经讨论过的所有原因。
- en: Accessing private variables with getters and setters
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用getter和setter访问私有变量
- en: Now, if it is best practice to hide our variables away as private, we need to
    consider how we allow access to them without spoiling our encapsulation. What
    if an object of the `Hospital` class wanted access to the `health` member variable
    from an object of type `Soldier`, so it could increase it? The `health` variable
    should be private because we don't want just any piece of code changing it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果将变量隐藏为私有是最佳实践，我们需要考虑如何允许访问它们，而不破坏我们的封装。如果`Hospital`类的对象想要访问`Soldier`类型的对象的`health`成员变量，以便增加它，`health`变量应该是私有的，因为我们不希望任何代码片段都可以更改它。
- en: To be able to make as many member variables as possible private and yet still
    allow some kind of limited access to some of them, we use **getters** and **setters**.
    Getters and setters are just methods that get and set variable values.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够尽可能多地将成员变量设置为私有，同时仍然允许对其中一些进行有限访问，我们使用**getter**和**setter**。Getter和setter只是获取和设置变量值的方法。
- en: This is not some special new Java thing we have to learn. It is just a convention
    for using what we already know. Let's have a look at getters and setters using
    our `Soldier` class and `Hospital` class examples.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我们必须学习的一些特殊的新的Java东西。这只是一个使用我们已经知道的东西的惯例。让我们看一下使用我们的`Soldier`类和`Hospital`类示例的getter和setter。
- en: 'In this example, each of our two classes is created in its own file but the
    same package. First of all, here is our hypothetical `Hospital` class:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的两个类分别在自己的文件中创建，但在同一个包中。首先，这是我们假设的`Hospital`类：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our implementation of the `Hospital` class has just one method, `healSoldier`.
    It receives a reference to a `Soldier` object as a parameter. So, this method
    will work on whichever `Soldier` object is passed in: `vassily`, `wellington`,
    `rambo`, or whoever.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Hospital`类的实现只有一个方法，`healSoldier`。它接收一个`Soldier`对象的引用作为参数。因此，这个方法将在传入的任何`Soldier`对象上工作：`vassily`，`wellington`，`rambo`，或其他人。
- en: It also has a local `health` variable, which it uses to temporarily hold and
    increase the soldier's health. In the same line, it initializes the `health` variable
    to the `Soldier` object's current health. The `Soldier` object's health is private
    so the public `getHealth` getter method is used instead.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它还有一个本地的`health`变量，它用来临时保存并增加士兵的健康。在同一行中，它将`health`变量初始化为`Soldier`对象的当前健康状况。`Soldier`对象的健康状况是私有的，因此使用公共的`getHealth`
    getter方法。
- en: Then `health` is increased by 10 and the `setHealth` setter method loads up
    the new revived health value, back to the `Soldier` object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The key here is that although a `Hospital` object can change a `Soldier` object's
    health, it only does so within the bounds of the getter and setter methods. The
    getter and setter methods can be written to control and check for potentially
    mistaken, or even harmful, values.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, look at our hypothetical `Soldier` class we have just been using with
    the simplest implementation possible of its getter and setter methods:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have one instance variable called `health` and it is private. Private means
    it can only be changed by methods of the `Soldier` class. We then have a public
    `getHealth` method that returns the value held in the private `health` int variable.
    As this method is public, any code with access to an object of type `Soldier`
    can use it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `setHealth` method is implemented. Again, it is public but this time
    it takes an `int` as a parameter and assigns whatever is passed in to the private
    `health` variable. In a more life-like example, we would write some more code
    here to make sure the value passed in is within the bounds we expect.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we declare, create, and assign to make an object of each of our two new
    classes and see how our getters and setters work:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We see that we can call our public `setHealth` and `getHealth` methods directly
    on our object of type `Soldier`. Not only that, we can call the `healSoldier`
    method of the `Hospital` object, passing in a reference to the `Soldier` object,
    which too can use the public getters and setters to manipulate the private `health`
    variable.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: We see that the private `health` variable is simply accessible, yet totally
    within the control of the designer of the `Soldier` class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: If you want to play around with this example, there is the code for a working
    app in the code bundle in the [*Chapter 11*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)
    folder called `GettersAndSetters`. I have added a few lines of code to print to
    the console.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Getters and setters are sometimes referred to by their more correct names, **Accessors**
    and **Mutators**. We will stick to getters and setters. I just thought you might
    like to know the jargon.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Yet again, our example and the explanation are probably raising more questions.
    That's good.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: By using encapsulation features (such as access control), it is like signing
    a really important deal about how to use and access a class, its methods, and
    variables. The contract is not just an agreement about now, but an implied guarantee
    for the future. We will see that as we go ahead through this chapter, there are
    more ways in which we'll refine and strengthen this contract.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Use encapsulation where it is needed or, of course, if you are being paid to
    use it by an employer. Often encapsulation is overkill on small learning projects,
    such as some of the examples in this book. Except, of course, when the topic you
    are learning is encapsulation itself.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: We are learning this Java OOP stuff under the assumption that you will one day
    want to write much more complex apps, whether on Android or some other platform
    that uses OOP. In addition, we will be using classes from the Android API that
    use it extensively and it will help us understand what is happening then as well.
    Typically, throughout this book, we will use encapsulation when implementing full
    projects and often overlook it when showing small code samples to demonstrate
    a single idea or topic.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our objects with constructors
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With all these private variables and their getters and setters, does it mean
    that we need a getter and a setter for every private variable? What about a class
    with lots of variables that need initializing at the start. Think about the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Some of these variables might need getters and setters, but what if we just
    want to set things up when the object is first created, to make the object function
    correctly?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Surely, we don't need two methods (a getter and a setter) for each?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们肯定不需要为每个变量都有两个方法（一个getter和一个setter）吧？
- en: Fortunately, this is unnecessary. To solve this potential problem there is a
    special method called a **constructor**. We briefly mentioned the existence of
    a constructor when we discussed instantiating an object of a class in [*Chapter
    10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*, Object-Oriented Programming*.
    Let's look again at constructors.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这是不必要的。为了解决这个潜在的问题，有一个特殊的方法叫做**构造函数**。我们在[*第10章*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*面向对象编程*中讨论实例化一个类的对象时，简要提到了构造函数的存在。让我们再看看构造函数。
- en: 'Here, we create an object of type `Soldier` and assign it to an object called
    `mySoldier`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个类型为`Soldier`的对象，并将其赋给一个名为`mySoldier`的对象：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Nothing new here but look at the last part of that line of code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新的，但是看一下代码行的最后部分：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This looks suspiciously like a method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可疑地像一个方法。
- en: All along, we have been calling a special method called a constructor that has
    been created behind the scenes, automatically, by the compiler.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一直以来，我们一直在调用一个特殊的方法，称为构造函数，这个方法是由编译器在幕后自动创建的。
- en: 'However, and this is getting to the point now, like a method, we can *override*
    the constructor, which means we can do useful things to set up our new object
    *before* it is used. This next code shows how we could do this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在到了重点，就像一个方法一样，我们可以*覆盖*构造函数，这意味着我们可以在使用新对象之前对其进行有用的设置。下面的代码展示了我们如何做到这一点：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The constructor has a lot of syntactical similarities to a method. It can, however,
    only be called with the use of the `new` keyword, and it is created for us automatically
    by the compiler – unless we create our own like in the previous code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数在语法上与方法有很多相似之处。但是，它只能在使用`new`关键字的情况下调用，并且它是由编译器自动为我们创建的 - 除非我们像在先前的代码中那样创建自己的构造函数。
- en: 'Constructors have the following features:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数具有以下特点：
- en: They have no return type
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们没有返回类型
- en: They have the exact same name as the class
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们与类具有完全相同的名称
- en: They can have parameters
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以有参数
- en: They can be overloaded
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以被重载
- en: One more piece of Java syntax that it is useful to introduce at this point is
    the Java `this` keyword.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，还有一些Java语法是有用的，那就是Java的`this`关键字。
- en: 'The `this` keyword is used when we want to be explicit about exactly which
    variables we are referring to. Look at this example constructor, again for a hypothetical
    variation of the `Soldier` class:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要明确指出我们正在引用哪些变量时，就会使用`this`关键字。再看看这个例子构造函数，再看一个假设的`Soldier`类的变体：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This time, the constructor has a parameter for each of the variables we want
    to initialize. By using the `this` keyword, it is clear when we mean the member
    variable or the parameter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，构造函数为每个我们想要初始化的变量都有一个参数。通过使用`this`关键字，当我们指的是成员变量或参数时就很清楚。
- en: There are more twists and turns to be learned about variables and `this` and
    they make much more sense when applied to a practical project. In the next app,
    we will explore all we have learned so far in this chapter and some more new ideas
    too.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关于变量和`this`还有更多的技巧和转折，当应用到一个实际项目时，它们会更有意义。在下一个应用程序中，我们将探索本章迄今为止学到的所有内容，还有一些新的想法。
- en: First, a bit more OOP.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，再多一点面向对象编程。
- en: Static methods
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态方法
- en: 'We know quite a lot about classes already. For example, we know how to turn
    them into objects and use their methods and variables. But something isn''t quite
    right. Since the very start of the book, we have been using two classes more than
    any other. We have repeatedly used `Log` and `Toast` to output to logcat or the
    user''s screen but have not instantiated them once! How can this be? We never
    did this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对类有相当多的了解。例如，我们知道如何将它们转换为对象并使用它们的方法和变量。但是有些地方不太对。自从书的开头，我们一直在使用两个类，比其他类更频繁地使用`Log`和`Toast`来输出到logcat或用户的屏幕，但我们从未实例化过它们！这怎么可能呢？我们从未这样做过：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We just went ahead and used the classes directly, like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接使用了这些类，就像这样：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The **static** methods of classes can be used *without* first instantiating
    an object of the class. We can think of this as a static method belonging to the
    class and all other methods belonging to an object/instance of a class.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 类的**静态**方法可以在没有首先实例化类的对象的情况下使用。我们可以将其视为属于类的静态方法，而所有其他方法都属于类的对象/实例。
- en: 'And as you have probably realized by now, `Log` and `Toast` both contain static
    methods. To be clear: `Log` and `Toast` *contain* static methods; they themselves
    are still classes.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 而且你现在可能已经意识到，`Log`和`Toast`都包含静态方法。要清楚：`Log`和`Toast`*包含*静态方法；它们本身仍然是类。
- en: Classes can have both static and regular methods as well, but the regular methods
    would need to be used in a regular way, via an instance/object of the class.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 类既可以有静态方法，也可以有常规方法，但是常规方法需要以常规方式使用，通过类的实例/对象。
- en: 'Take another look at `Log.i` in action:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 再看一下`Log.i`的使用：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, `i` is the method being statically accessed and the method takes two parameters,
    both of type String.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`i`是静态访问的方法，该方法接受两个参数，都是String类型。
- en: 'Next, we see the static method `makeText` of the `Toast` class in use:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到了`Toast`类的静态方法`makeText`的使用：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `makeText` method of the `Toast` class takes three arguments.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Toast`类的`makeText`方法接受三个参数。'
- en: The first is `this`, which is a reference to the current class. We saw when
    talking about constructors that to explicitly refer to the member variables of
    the current instance of an object, we can use `this.health`, `this.regiment`,
    and so on.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是`this`，它是对当前类的引用。我们在谈论构造函数时看到，为了明确地引用对象的当前实例的成员变量，我们可以使用`this.health`，`this.regiment`等等。
- en: When we use `this` as we do in the previous line of code, we are referring to
    the instance of the class itself; not the `Toast` class but the `this` in the
    previous line of code is a reference to the class the method is being used *from*.
    In our case, we have used it from the `MainActivity` class.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Many things in Android require a reference to an instance of `Activity` to do
    their job. We will fairly regularly throughout this book pass in `this` (a reference
    to `Activity`) in order to enable a class/object from the Android API to do its
    work. We will also write classes that need `this` as an argument in one or more
    of its methods. So, we will see how to handle `this` when it is passed in as well.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The second argument of the `makeText` method is of course a `String`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'The third argument is accessing a `final` variable, `LENGTH_SHORT`, again via
    the class name not an instance of the class. If we declare a variable like this
    next line of code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the variable was declared in a class called `MyClass`, we could access the
    variable like this: `MyClass.LENGTH_SHORT` and use it like any other variable,
    but the `final` keyword makes sure that the value of the variable can never be
    changed. This type of variable is called a **constant**.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The `static` keyword also has another consequence for a variable, especially
    when it is not a constant (can be changed) and we will see this in action in our
    next app.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Now if you look carefully at the very end of the line of code that shows a `Toast`
    message to the user, you will see something else new, `.show()`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: This is called `Toast` class but using just one line of code. It is the `show`
    method that actually triggers the message.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: We will look at chaining more closely as we proceed through the book, such as
    in [*Chapter 14*](B16773_14_ePub_RK.xhtml#_idTextAnchor249), *Android Dialog Windows*,
    when we make a pop-up dialog.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to read about the `Toast` class and some of its other methods in
    detail, you can do so here: [http://developer.android.com/reference/android/widget/Toast.html](http://developer.android.com/reference/android/widget/Toast.html).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Static methods are often provided in classes that have uses that are so generic
    it doesn't make sense to create an object of the class. Another really useful
    class with static methods is `Math`. This class is actually a part of the Java
    API, not the Android API.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Want to write a calculator app? It''s easier than you think with the static
    methods of the `Math` class. You can look at them here: [http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html](http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: If you try this out, you will need to import the `Math` class the same way you
    imported all the other classes we have used. Next, we can try out a practical
    mini app to understand encapsulation and static methods.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation and static methods mini-app
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have looked at the intricate way that access to variables and their scope
    is controlled and it would serve us well to look at an example of them in action.
    These will not so much be practical real-world examples of variable use, more
    a demonstration to help understand access modifiers for classes, methods, and
    variables alongside the different types of variables such as reference or primitive
    and local or instance, along with the new concepts of static and final variables
    and the `this` keyword.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The completed code is in the [*Chapter 11*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)
    folder of the download bundle. It is called `Access Scope This And Static`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Empty Activity project and call it `Access Scope This And Static`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class by right-clicking on the existing `MainActivity` class in
    the project explorer and clicking `AlienShip`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will declare our new class and some member variables. Note that `numShips`
    is `private` and `static`. We will see how this variable is the same across all
    instances of the class soon. The `shieldStrength` variable is `private` and `shipName`
    is public:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next is the constructor. We can see that the constructor is public, has no
    return type, and has the same name as the class – as per the rules. In it, we
    increment the private static `numShips` variable. Remember this will happen each
    time we create a new object of type `AlienShip`. Also, the constructor sets a
    value for the private variable `shieldStrength` using the private `setShieldStrength`
    method:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is the public static getter method so classes outside of `AlienShip` can
    find out how many `AlienShip` objects there are. We will also see the way in which
    we use static methods:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And this is our private `setShieldStrength` method. We could have just set
    `shieldStrength` directly from within the class, but the code below shows how
    we distinguish between the `shieldStrength` local variable/parameter and the `shieldStrength`
    member variable by using the `this` keyword:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This next method is the getter so other classes can read but not alter the
    shield strength of each `AlienShip` object:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we have a public method that can be called every time an `AlienShip` object
    is hit. It just prints to the console and then detects whether that object''s
    `shieldStrength` is zero. If it is, it calls the `destroyShip` method, which we''ll
    look at next:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And lastly for our `AlienShip` class, we will code the `destroyShip` method.
    We print a message that indicates which ship has been destroyed based on its `shipName`
    as well as decrementing the `numShips` static variable so we can keep track of
    how many objects of type `AlienShip` we have:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we switch over to our `MainActivity` class and write some code that uses
    our new `AlienShip` class. All the code goes in the `onCreate` method after the
    call to `setContentView`. First, we create two new `AlienShip` objects called
    `girlShip` and `boyShip`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the next code, look at how we get the value in `numShips`. We use the `getNumShips`
    method as we might expect. However, look closely at the syntax. We are using the
    class name and not an object. We can also access static variables with methods
    that are not static. We did it this way to see a static method in action:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we assign names to our public `shipName` String variables:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In this next code, we try to assign a value directly to a private variable.
    It won''t work. Then we use the public getter method `getShieldStrength` to print
    out the `shieldStrength`, which was assigned in the constructor:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we get to blow some stuff up by playing with the `hitDetected` method
    and occasionally checking the `shieldStrength` of our two objects:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When we think we have destroyed a ship, we again use our static `getNumShips`
    method to see if our static variable `numShips` was changed by the `destroyShip`
    method:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run the demo and look at the console output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the previous example, we saw that we can distinguish between local and member
    variables of the same name by using the `this` keyword. We can also use the `this`
    keyword to write code that refers to whatever the current object being acted upon
    is.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: We saw that a static variable – in this case, `numShips` – is consistent across
    all instances; moreover, by incrementing it in the constructor and decrementing
    it in our `destroyShip` method, we can keep track of the number of `AlienShip`
    objects we currently have.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: We also saw that we can use static methods by using the class name with the
    dot operator instead of an actual object.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Yes, I know it is like living in the blueprint of a house – but it's quite useful
    too.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we proved how we could hide and expose certain methods and variables
    using an access specifier.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at the topic of inheritance.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: OOP and inheritance
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how we can use other people's code by instantiating/creating objects
    from the classes of an API like Android. But this whole OOP thing goes even further
    than that.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们可以通过实例化/创建来自Android等API的类的对象来使用其他人的代码。但是这整个OOP的东西甚至比那更深入。
- en: What if there is a class that has loads of useful functionality in it but not
    exactly what we want? We can inherit from the class and then further refine or
    add to how it works and what it does.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个类有很多有用的功能，但不完全符合我们的要求，我们可以从该类继承，然后进一步完善或添加其工作方式和功能。
- en: 'You might be surprised to hear that we have done this already. In fact, we
    have done this with every single app we have created. When we use the `extends`
    keyword, we are inheriting. Remember this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶地听到我们已经这样做了。实际上，我们已经为我们创建的每个应用程序都这样做了。当我们使用`extends`关键字时，我们正在继承。记住这一点：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we are inheriting the `AppCompatActivity` class along with all its functionality
    – or more specifically, all the functionality that the class designers want us
    to have access to. Here are some of the things we can do to classes we have extended.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们继承了`AppCompatActivity`类以及它的所有功能-更具体地说，类设计者希望我们能够访问的所有功能。以下是我们可以对我们扩展的类做的一些事情。
- en: 'We can even override a method *and* still rely in part on the overridden method
    in the class we inherit from. For example, we overrode the `onCreate` method every
    time we extended the `AppCompatActivity` class. But we also called on the default
    implementation provided by the class designers when we did this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以重写一个方法*并且*仍然部分依赖于我们继承的类中的重写方法。例如，我们每次扩展`AppCompatActivity`类时都重写了`onCreate`方法。但是当我们这样做时，我们也调用了类设计者提供的默认实现：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: And in [*Chapter 6*](B16773_06_ePub_RK.xhtml#_idTextAnchor119), *The Android
    Lifecycle*, we overrode just about all of the Activity class lifecycle methods.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B16773_06_ePub_RK.xhtml#_idTextAnchor119)，*Android生命周期*中，我们重写了几乎所有Activity类的生命周期方法。
- en: We discuss inheritance mainly so that we understand what is going on around
    us and as the first step towards being able to eventually design useful classes
    that we or others can extend.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要讨论继承，以便我们了解周围发生的事情，并作为最终能够设计有用的类的第一步，我们或其他人可以扩展。
- en: With this in mind, let's look at some example classes and see how we can extend
    them, just to see the syntax and as a first step, and also to be able to say we
    have done it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们看一些示例类，并看看我们如何扩展它们，只是为了看看语法并作为第一步，也为了能够说我们已经这样做了。
- en: When we look at the final major topic of this chapter, polymorphism, we will
    also dig a little deeper into inheritance at the same time. Here is some code
    using inheritance.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看这一章的最后一个主要主题，多态性时，我们也将同时深入研究继承。这里有一些使用继承的代码。
- en: 'This code would go in a file named `Animal.java`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将放在一个名为`Animal.java`的文件中：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then in a separate file named `Elephant.java`, we could do this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在一个名为`Elephant.java`的单独文件中，我们可以这样做：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can see in the previous code that we have implemented a class called `Animal`
    and it has four member variables: `age`, `weight`, `type`, and `hungerLevel`.
    It also has two methods, `eat` and `walk`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在前面的代码中，我们实现了一个名为`Animal`的类，它有四个成员变量：`age`，`weight`，`type`和`hungerLevel`。它还有两个方法，`eat`和`walk`。
- en: We then extended `Animal` with `Elephant`. `Elephant` can now do anything an
    `Animal` can and it also has all its variables.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们用`Elephant`扩展了`Animal`。`Elephant`现在可以做任何`Animal`可以做的事情，它也有所有的变量。
- en: We initialized the variables from `Animal` that `Elephant` has in the `Elephant`
    constructor. Two variables (`age` and `weight`) are passed into the constructor
    when an `Elephant` object is created and two variables (`type` and `hungerLevel`)
    are assigned the same for all `Elephant` objects.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Elephant`构造函数中初始化了`Animal`的变量，`Elephant`在创建对象时将两个变量（`age`和`weight`）传递给构造函数，并且为所有`Elephant`对象分配了两个变量（`type`和`hungerLevel`）。
- en: We could go ahead and write a bunch of other classes that extend `Animal`, perhaps
    `Lion`, `Tiger`, and `ThreeToedSloth`. Each would have an `age`, `weight`, `type`,
    and `hungerLevel` and each would be able to `walk` and `eat`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续编写一堆其他扩展`Animal`的类，也许是`Lion`，`Tiger`和`ThreeToedSloth`。每个类都会有`age`，`weight`，`type`和`hungerLevel`，并且每个类都能`walk`和`eat`。
- en: As if OOP were not useful enough already, we can now model real-world objects.
    We have also seen that we can make OOP even more useful by subclassing/extending/inheriting
    from other classes. The terminology we might like to learn here is that the class
    that is extended from is the **super class** and the class that inherits from
    the super class is the **subclass**. We can also say the parent and child class.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 好像OOP已经不够有用了，我们现在可以模拟现实世界的对象。我们还看到，通过子类化/扩展/继承其他类，我们可以使OOP变得更加有用。我们可能想要学习的术语是被扩展的类是**超类**，继承超类的类是**子类**。我们也可以说父类和子类。
- en: Tip
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'As usual, we might find ourselves asking this question about inheritance. Why?
    The reason is something like this: we can write common code once, in the parent
    class; we can update that common code and all classes that inherit from it are
    also updated. Furthermore, a subclass only gets to use public/protected instance
    variables and methods. So, designed properly, this also further enhances the goals
    of encapsulation.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们可能会问关于继承的这个问题。为什么？原因是这样的：我们可以在父类中编写一次通用代码；我们可以更新该通用代码，所有继承自它的类也会更新。此外，子类只能使用公共/受保护的实例变量和方法。因此，如果设计得当，这也进一步增强了封装的目标。
- en: Let's build another small app to play about with inheritance.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建另一个小应用程序来玩一下继承。
- en: Inheritance example app
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承示例应用程序
- en: We have looked at the way we can create hierarchies of classes to model a system
    that fits our app. So, let's try out some simple code that uses inheritance. The
    completed code is in the [*Chapter 11*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)
    folder of the code download. It is called `Inheritance Example`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project called `Inheritance Example` using the `AlienShip`, another
    `Fighter`, and the last one `Bomber`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Here is the code for the `AlienShip` class. It is very similar to our previous
    class demo, `AlienShip`. The differences are that the constructor now takes an
    `int` parameter, which it uses to set the shield strength.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: The constructor also outputs a message to the logcat window, so we can see when
    it is being used. The `AlienShip` class also has a new method, `fireWeapon`, that
    is declared as `abstract`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a class as abstract guarantees that any class that subclasses `AlienShip`
    must implement its own version of `fireWeapon`. Notice the class has the `abstract`
    keyword as part of its declaration. We have to do this because one of its methods
    also uses the `abstract` keyword. We will explain the `abstract` method when discussing
    this demo and the `abstract` class when we talk about polymorphism in the next
    section.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `AlienShip` class:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we will implement the `Bomber` class. Notice the call to `super(100)`.
    This calls the constructor of the super class with the value for `shieldStrength`.
    We could do further specific `Bomber` initialization in this constructor, but
    for now, we just print out the location so we can see when the `Bomber` constructor
    is being executed. We also, because we must, implement a `Bomber` specific version
    of the abstract `fireWeapon` method. Add the following code to the `Bomber` class:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we will implement the `Fighter` class. Notice the call to `super(400)`.
    This calls the constructor of the super class with the value for `shieldStrength`.
    We could do further specific `Fighter` initialization in this constructor but
    for now, we just print out the location so we can see when the `Fighter` constructor
    is being executed. We also must implement a `Fighter` specific version of the
    abstract `fireWeapon` method. Add the following code to the `Fighter` class:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we will code the `onCreate` method of `MainActivity`. As usual, enter
    this code after the call to the `setContentView` method. This is the code that
    uses our three new classes. The code looks quite ordinary – nothing new. It is
    the output that is interesting:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Run the app and you will get the following output in the logcat window:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We can see how the constructor of the subclass calls the constructor of the
    super class. We can also clearly see that the individual implementations of the
    `fireWeapon` method work exactly as expected.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a closer look at the final major OOP concept, polymorphism. Then
    we will be able to do some more practical things with the Android API.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know that polymorphism means *different forms*. But what does it
    mean to us?
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Boiled down to its simplest:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Any subclass can be used as part of the code that uses the super class.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: This means we can write code that is simpler and easier to understand, and easier
    to change.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Also, we can write code for the super class and rely on the fact that no matter
    how many times it is sub-classed, within certain parameters, the code will still
    work. Let's discuss an example.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to use polymorphism to help to write a zoo management app. We
    will probably want to have a method such as `feed`. We will probably want to pass
    a reference to the animal to be fed into the `feed` method. This might seem like
    we need to write a `feed` method for each and every type of `Animal`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can write polymorphic methods with polymorphic return types and
    arguments:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding method has `Animal` as a parameter, which means that any object
    that is built from a class that extends `Animal` can be passed into it. And as
    you can see in the preceding code, the method also returns `Animal`, which has
    exactly the same benefits.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: There is a small gotcha with polymorphic return types and that is that we need
    to be aware of what is being returned and make it explicit in the code that calls
    the method.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could handle `Elephant` being passed into the `feed` method
    like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Notice the highlighted `(Elephant)` in the previous code. This makes it plain
    that we want `Elephant` from the returned `Animal`. This is called **casting**.
    We will use casting occasionally throughout the rest of the book.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: So, you can even write code *today* and make another subclass in a week, month,
    or year, and the very same methods and data structures will still work.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Also, we can enforce upon our subclasses a set of rules as to what they can
    and cannot do, as well as how they do it. So, clever design in one stage can influence
    it at other stages.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: But will we ever really want to instantiate an actual `Animal`?
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We played with an abstract class in the inheritance example app but let's dig
    a little deeper. An abstract class is a class that cannot be instantiated; it
    cannot be made into an object. So, it's a blueprint that will never be used then?
    But that's like paying an architect to design your home and then never building
    it? You might be saying to yourself, "I kind of got the idea of an abstract method
    but abstract classes are just silly."
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: If we or the designer of a class wants to force us to inherit *before* we use
    their class, they can declare a class **abstract**. Then, we cannot make an object
    from it; therefore, we must extend it first and make an object from the subclass.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: We can also declare a method `abstract` and then that method must be overridden
    in any class that extends the class with the abstract method.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example – it will help. We make a class `abstract` by declaring
    it with the `abstract` keyword like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Yes, but why?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes we want a class that can be used as a polymorphic type, but we need
    to guarantee it can never be used as an object. For example, "animal" doesn't
    really make sense on its own.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: We don't talk about animals; we talk about *types* of animals. We don't say,
    "Ooh, look at that lovely fluffy, white animal." Or, "Yesterday we went to the
    pet shop and got an animal and an animal bed." It's just too, well, *abstract*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: So, an abstract class is kind of like a template to be used by any class that
    `extends` it (inherits from it).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: We might want a `Worker` class and extend it to make `Miner`, `Steelworker`,
    `OfficeWorker`, and of course `Programmer`. But what exactly does a plain `Worker`
    do? Why would we ever want to instantiate one?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: The answer is we probably wouldn't want to instantiate one; but we might want
    to use it as a polymorphic type, so we can pass multiple worker subclasses between
    methods and have data structures that can hold all types of `Worker`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: We call this type of class an abstract class and when a class has even one abstract
    method, it must be declared abstract itself. And all abstract methods must be
    overridden by any class that extends it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: This means that the abstract class can give some of the common functionality
    that would be available in all its subclasses. For example, the `Worker` class
    might have the `height`, `weight`, and `age` member variables.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: It might also have the `getPayCheck` method, which is not abstract and is the
    same in all the subclasses, but a `doWork` method is abstract and must be overridden,
    because all the different types of worker `doWork` differently.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: This leads us neatly to another area of polymorphism that is going to make life
    easier for us throughout this book.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An interface is like a class. Phew! Nothing complicated here then. But it's
    like a class that is always abstract and has only abstract methods.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: We can think of an interface as an entirely abstract class with all its methods
    abstract and no member variables either.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: OK, so you can just about wrap your head around an abstract class because at
    least it can pass on some functionality in its methods that are not abstract and
    serve as a polymorphic type. But seriously, this interface seems a bit pointless.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the simplest possible generic example of an interface, then we
    can discuss it further.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'To define an interface, we type the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The methods of an interface have no body because they are abstract, but they
    can still have return types and parameters, or not.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'To use an interface, we use the `implements` keyword after the class declaration:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This enables us to use polymorphism with multiple different objects that are
    from completely unrelated inheritance hierarchies. If a class implements an interface,
    the whole thing can be passed along or used as if it is that thing – because it
    is that thing. It is polymorphic (many things).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: We can even have a class implement multiple different interfaces at the same
    time. Just add a comma between each interface and list them after the `implements`
    keyword. Just be sure to implement all the necessary methods.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will use the interfaces of the Android API more often than
    we write our own. In [*Chapter 13*](B16773_13_ePub_RK.xhtml#_idTextAnchor228)*,
    Anonymous Classes - Bringing Android Widgets to Life*, one such interface we will
    use in the Java Meet UI app is the `OnClickListener` interface.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Many things might like to know when they are being clicked. Perhaps a `Button`
    or a `TextView` widget, and so on. So, using an interface we don't need different
    methods for every type of UI element we might like to click.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Frequently asked questions
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is wrong with this class declaration?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There are no private classes. Classes can be public or default. Public classes
    are public; default classes are private within their own package.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: What is encapsulation?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encapsulation is how we contain our variables, code, and methods in a manner
    that exposes just the parts and functionality we want to other code.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered more theory than in any other chapter. If you haven't
    memorized everything or some of the code seemed a bit too in-depth, then you have
    still succeeded completely.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: If you just understand that OOP is about writing reusable, extendable, and efficient
    code through encapsulation, inheritance, and polymorphism, then you have the potential
    to be a Java master.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, OOP enables us to use other peoples' code even when those other
    people were not aware of exactly what we would be doing at the time they wrote
    the code.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: All you must do is keep practicing because we will constantly be using these
    same concepts over and over again throughout the book, so you do not need to have
    even begun to have mastered them at this point.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be revisiting some concepts from this chapter as
    well as looking at some new aspects of OOP and how it enables our Java code to
    interact with our XML layouts.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: But first, there is an important incoming news flash!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: All the UI elements – `TextView`, `ConstraintLayout`, `CalenderView`, and `Button`
    – are classes too. Their attributes are member variables and they have loads of
    methods that we can use to do all sorts of things with the UI. This could prove
    useful.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: There will much more on this revelation in the next two chapters, but first,
    we will see how Android handles trash.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
