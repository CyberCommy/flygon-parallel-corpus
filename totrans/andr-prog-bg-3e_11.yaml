- en: '*Chapter 11*: More Object-Oriented Programming'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is the second part of our whirlwind tour (theoretical and practical)
    into OOP. We have already briefly discussed the concepts of encapsulation, inheritance,
    and polymorphism, but in this chapter, we will get to see them more in action
    in some demo apps. While the working examples will show these concepts in their
    simplest forms, it will still be a significant stepping stone towards taking control
    of our layouts via our Java code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation in depth and how it helps us
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance in depth and how to take full advantage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism explained in greater detail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static classes and how we have been using them already
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract classes and interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, we will handle encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2011](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2011).
  prefs: []
  type: TYPE_NORMAL
- en: Remember that encapsulation thing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, what we have really seen is what amounts to a kind of code-organizing
    convention where we write classes, full of variables and methods. We did discuss
    the wider goals of all this OOP stuff but now we will take things further and
    begin to see how we actually manage to achieve encapsulation with OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Definition of encapsulation
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation describes the ability of an object to hide its data and methods
    from the rest of the world, allowing only the variables and methods you choose
    to be accessed. This means your code can always be updated, extended, or improved
    without affecting the programs that use it – provided the exposed parts are still
    made accessible in the same way. It also allows the code that uses your encapsulated
    code to be much simpler and easier to maintain because much of the complexity
    of the task is encapsulated within your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'But didn''t you say we don''t have to know what is going on inside? So you
    might question what we have seen so far like this: If we are constantly setting
    the instance variables like this `rambo.health` `= 100;`, isn''t it possible that,
    eventually, things could start to go wrong, perhaps like this?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Encapsulation protects the objects of your class from being used in a way that
    they weren't meant to be. By controlling the way that your classes' code is used,
    it can only ever do what you want it to do and with value ranges that you can
    control.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can''t be forced into errors or crashes. Also, you are then free to make
    changes to the way your code works internally, without breaking the rest of your
    program or any programs that are using an older version of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Encapsulation is not just vital for writing code that other people will use
    (such as the Android API that we use), it is also essential when writing code
    we will reuse ourselves as it will save us from our own mistakes. Furthermore,
    a team of programmers will use encapsulation extensively so that different members
    of the team can work on the same program without all members of the team knowing
    how the other team members' code works. We can encapsulate our classes for this
    same advantage and here is how.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling class use with access modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The designer of the class controls what can be seen and manipulated by any
    program that uses their class. We can add an `class` keyword like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Class access modifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two main access modifiers for classes in the context we have discussed
    so far. Let''s briefly look at each in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public`: This is straightforward. A class declared as public can be seen by
    all other classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default`: A class has default access when no access modifier is specified.
    This will make it public but only to classes in the same package and inaccessible
    to all others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So now we can make a start on this encapsulation thing. But even at a glance,
    the access modifiers described are not very fine-grained. We seem to be limited
    to complete lockdown to anything outside the package or a complete free-for-all.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, the benefits here are easily taken advantage of. The idea would be
    to design a package of classes that fulfills a set of tasks. Then, all the complex
    inner workings of the package, the stuff that shouldn't be messed with by anybody
    but our package, should be default access (only accessible to classes within the
    package). We can then make available a careful choice of public classes that can
    be used by others (or other distinct parts of our program).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For the size and complexity of the apps in this book, creating multiple packages
    is overkill. We will of course be using other people's packages and classes (the
    public parts), so this stuff is worth knowing.
  prefs: []
  type: TYPE_NORMAL
- en: Class access in summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A well-designed app will probably consist of one or more packages, each containing
    only default or default and public classes.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to class-level privacy controls, Java gives us programmers very
    fine-grained controls, but to use these controls, we have to look into variables
    with a little more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling variable use with access modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build on the class visibility controls, we have variable access modifiers.
    Here is a variable with the `private` access modifier being declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Note also that all of our discussion of variable access modifiers applies to
    object variables too. For example, here is an instance of our `Soldier` class
    being declared, created, and assigned. As you can see, the access specified in
    this case is public:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Before you apply a modifier to a variable, you must first consider the class
    visibility. If class *a* is not visible to class *b*, say because class *a* has
    default access and class *b* is in another package, then it doesn't make any difference
    what access modifiers you use on the variables in class *a* – class *b* can't
    see any of them anyway.
  prefs: []
  type: TYPE_NORMAL
- en: So, it makes sense to show a class to another class when necessary but only
    to expose the variables that are directly needed – not everything.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an explanation of the different variable access modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Variable access modifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Variable access modifiers are more numerous and finely grained than class access
    modifiers. The depth and complexity of access modification are not so much in
    the range of modifiers but rather in the smart ways we can combine them to achieve
    the worthy goals of encapsulation. Here are the variable access modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public`: You guessed it, any class or method from any package can see this
    variable. Use `public` only when you are sure this is what you want.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected`: This is the next least restrictive after `public`. `protected`
    variables can be seen by any class and any method as long as they are in the same
    package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default`: `default` doesn''t sound as restrictive as `protected` but it is
    more so. A variable has `default` access when no access is specified. The fact
    that `default` is restrictive perhaps implies we should be thinking of hiding
    our variables more than we should be exposing them. At this point, we need to
    introduce a new concept. Do you remember we briefly discussed inheritance and
    how we can quickly take on the attributes of a class and yet refine it by using
    the `extends` keyword? Just for the record, default access variables are not visible
    to subclasses; that is, when we extend a class as we did with an Activity, we
    cannot see its default variables. We will look at inheritance in more detail later
    in the chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private`: `private` variables can only be seen within the class they are declared.
    This means, like default access, they cannot be seen by subclasses (classes that
    inherit from the class in question).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable access summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A well-designed app will probably consist of one or more packages, each containing
    only `default` or `default` and `public` classes. Within these classes, variables
    will have carefully chosen and varied access modifiers, chosen with a view to
    achieving our goal of encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: One more twist in all this access modification stuff before we get practical
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: Methods can have access modifiers too
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already briefly mentioned in [*Chapter 9*](B16773_09_ePub_RK.xhtml#_idTextAnchor169)*,
    Learning Java Methods*, that methods can have access modifiers. It makes sense
    because methods are the things that our classes can *do*. We will want to control
    what users of our classes can and can't do.
  prefs: []
  type: TYPE_NORMAL
- en: The general idea here is that some methods will do things internally only and
    are therefore not needed by users of the class and some methods will be fundamental
    to how users of the class use the class.
  prefs: []
  type: TYPE_NORMAL
- en: Method access modifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The access modifiers for methods are the same as for the class variables. This
    makes things easy to remember but suggests, again, that successful encapsulation
    is a matter of design rather than of following any specific set of rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, this method, provided it is in a public class, could be used
    by any other class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas this method could only be used internally by the class that it is part
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And this next method with no access specified has default visibility. It can
    be used only by other classes in the same package. If we extend the class holding
    this `default` access method, the child class will not have access to this parent
    class''s method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As the last example before we move on, here is a `protected` method, only visible
    to the package, but usable by our classes that extend it – just like `onCreate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let's have a quick recap of method encapsulation, but remember that you don't
    need to memorize everything.
  prefs: []
  type: TYPE_NORMAL
- en: Method access summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Method access should be chosen to best enforce the principles we have already
    discussed. It should provide the users of your class with just the access they
    need and preferably nothing more. Thereby we achieve our encapsulation goals,
    such as keeping the internal workings of your code safe from interference from
    the programs that use it, for all the reasons we have discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing private variables with getters and setters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, if it is best practice to hide our variables away as private, we need to
    consider how we allow access to them without spoiling our encapsulation. What
    if an object of the `Hospital` class wanted access to the `health` member variable
    from an object of type `Soldier`, so it could increase it? The `health` variable
    should be private because we don't want just any piece of code changing it.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to make as many member variables as possible private and yet still
    allow some kind of limited access to some of them, we use **getters** and **setters**.
    Getters and setters are just methods that get and set variable values.
  prefs: []
  type: TYPE_NORMAL
- en: This is not some special new Java thing we have to learn. It is just a convention
    for using what we already know. Let's have a look at getters and setters using
    our `Soldier` class and `Hospital` class examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, each of our two classes is created in its own file but the
    same package. First of all, here is our hypothetical `Hospital` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Our implementation of the `Hospital` class has just one method, `healSoldier`.
    It receives a reference to a `Soldier` object as a parameter. So, this method
    will work on whichever `Soldier` object is passed in: `vassily`, `wellington`,
    `rambo`, or whoever.'
  prefs: []
  type: TYPE_NORMAL
- en: It also has a local `health` variable, which it uses to temporarily hold and
    increase the soldier's health. In the same line, it initializes the `health` variable
    to the `Soldier` object's current health. The `Soldier` object's health is private
    so the public `getHealth` getter method is used instead.
  prefs: []
  type: TYPE_NORMAL
- en: Then `health` is increased by 10 and the `setHealth` setter method loads up
    the new revived health value, back to the `Soldier` object.
  prefs: []
  type: TYPE_NORMAL
- en: The key here is that although a `Hospital` object can change a `Soldier` object's
    health, it only does so within the bounds of the getter and setter methods. The
    getter and setter methods can be written to control and check for potentially
    mistaken, or even harmful, values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, look at our hypothetical `Soldier` class we have just been using with
    the simplest implementation possible of its getter and setter methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We have one instance variable called `health` and it is private. Private means
    it can only be changed by methods of the `Soldier` class. We then have a public
    `getHealth` method that returns the value held in the private `health` int variable.
    As this method is public, any code with access to an object of type `Soldier`
    can use it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `setHealth` method is implemented. Again, it is public but this time
    it takes an `int` as a parameter and assigns whatever is passed in to the private
    `health` variable. In a more life-like example, we would write some more code
    here to make sure the value passed in is within the bounds we expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we declare, create, and assign to make an object of each of our two new
    classes and see how our getters and setters work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We see that we can call our public `setHealth` and `getHealth` methods directly
    on our object of type `Soldier`. Not only that, we can call the `healSoldier`
    method of the `Hospital` object, passing in a reference to the `Soldier` object,
    which too can use the public getters and setters to manipulate the private `health`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: We see that the private `health` variable is simply accessible, yet totally
    within the control of the designer of the `Soldier` class.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to play around with this example, there is the code for a working
    app in the code bundle in the [*Chapter 11*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)
    folder called `GettersAndSetters`. I have added a few lines of code to print to
    the console.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Getters and setters are sometimes referred to by their more correct names, **Accessors**
    and **Mutators**. We will stick to getters and setters. I just thought you might
    like to know the jargon.
  prefs: []
  type: TYPE_NORMAL
- en: Yet again, our example and the explanation are probably raising more questions.
    That's good.
  prefs: []
  type: TYPE_NORMAL
- en: By using encapsulation features (such as access control), it is like signing
    a really important deal about how to use and access a class, its methods, and
    variables. The contract is not just an agreement about now, but an implied guarantee
    for the future. We will see that as we go ahead through this chapter, there are
    more ways in which we'll refine and strengthen this contract.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Use encapsulation where it is needed or, of course, if you are being paid to
    use it by an employer. Often encapsulation is overkill on small learning projects,
    such as some of the examples in this book. Except, of course, when the topic you
    are learning is encapsulation itself.
  prefs: []
  type: TYPE_NORMAL
- en: We are learning this Java OOP stuff under the assumption that you will one day
    want to write much more complex apps, whether on Android or some other platform
    that uses OOP. In addition, we will be using classes from the Android API that
    use it extensively and it will help us understand what is happening then as well.
    Typically, throughout this book, we will use encapsulation when implementing full
    projects and often overlook it when showing small code samples to demonstrate
    a single idea or topic.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our objects with constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With all these private variables and their getters and setters, does it mean
    that we need a getter and a setter for every private variable? What about a class
    with lots of variables that need initializing at the start. Think about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Some of these variables might need getters and setters, but what if we just
    want to set things up when the object is first created, to make the object function
    correctly?
  prefs: []
  type: TYPE_NORMAL
- en: Surely, we don't need two methods (a getter and a setter) for each?
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, this is unnecessary. To solve this potential problem there is a
    special method called a **constructor**. We briefly mentioned the existence of
    a constructor when we discussed instantiating an object of a class in [*Chapter
    10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*, Object-Oriented Programming*.
    Let's look again at constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we create an object of type `Soldier` and assign it to an object called
    `mySoldier`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing new here but look at the last part of that line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This looks suspiciously like a method.
  prefs: []
  type: TYPE_NORMAL
- en: All along, we have been calling a special method called a constructor that has
    been created behind the scenes, automatically, by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, and this is getting to the point now, like a method, we can *override*
    the constructor, which means we can do useful things to set up our new object
    *before* it is used. This next code shows how we could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The constructor has a lot of syntactical similarities to a method. It can, however,
    only be called with the use of the `new` keyword, and it is created for us automatically
    by the compiler – unless we create our own like in the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructors have the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: They have no return type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have the exact same name as the class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can have parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be overloaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One more piece of Java syntax that it is useful to introduce at this point is
    the Java `this` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `this` keyword is used when we want to be explicit about exactly which
    variables we are referring to. Look at this example constructor, again for a hypothetical
    variation of the `Soldier` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This time, the constructor has a parameter for each of the variables we want
    to initialize. By using the `this` keyword, it is clear when we mean the member
    variable or the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: There are more twists and turns to be learned about variables and `this` and
    they make much more sense when applied to a practical project. In the next app,
    we will explore all we have learned so far in this chapter and some more new ideas
    too.
  prefs: []
  type: TYPE_NORMAL
- en: First, a bit more OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Static methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We know quite a lot about classes already. For example, we know how to turn
    them into objects and use their methods and variables. But something isn''t quite
    right. Since the very start of the book, we have been using two classes more than
    any other. We have repeatedly used `Log` and `Toast` to output to logcat or the
    user''s screen but have not instantiated them once! How can this be? We never
    did this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We just went ahead and used the classes directly, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The **static** methods of classes can be used *without* first instantiating
    an object of the class. We can think of this as a static method belonging to the
    class and all other methods belonging to an object/instance of a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'And as you have probably realized by now, `Log` and `Toast` both contain static
    methods. To be clear: `Log` and `Toast` *contain* static methods; they themselves
    are still classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Classes can have both static and regular methods as well, but the regular methods
    would need to be used in a regular way, via an instance/object of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take another look at `Log.i` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, `i` is the method being statically accessed and the method takes two parameters,
    both of type String.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we see the static method `makeText` of the `Toast` class in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `makeText` method of the `Toast` class takes three arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The first is `this`, which is a reference to the current class. We saw when
    talking about constructors that to explicitly refer to the member variables of
    the current instance of an object, we can use `this.health`, `this.regiment`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: When we use `this` as we do in the previous line of code, we are referring to
    the instance of the class itself; not the `Toast` class but the `this` in the
    previous line of code is a reference to the class the method is being used *from*.
    In our case, we have used it from the `MainActivity` class.
  prefs: []
  type: TYPE_NORMAL
- en: Many things in Android require a reference to an instance of `Activity` to do
    their job. We will fairly regularly throughout this book pass in `this` (a reference
    to `Activity`) in order to enable a class/object from the Android API to do its
    work. We will also write classes that need `this` as an argument in one or more
    of its methods. So, we will see how to handle `this` when it is passed in as well.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument of the `makeText` method is of course a `String`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third argument is accessing a `final` variable, `LENGTH_SHORT`, again via
    the class name not an instance of the class. If we declare a variable like this
    next line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If the variable was declared in a class called `MyClass`, we could access the
    variable like this: `MyClass.LENGTH_SHORT` and use it like any other variable,
    but the `final` keyword makes sure that the value of the variable can never be
    changed. This type of variable is called a **constant**.'
  prefs: []
  type: TYPE_NORMAL
- en: The `static` keyword also has another consequence for a variable, especially
    when it is not a constant (can be changed) and we will see this in action in our
    next app.
  prefs: []
  type: TYPE_NORMAL
- en: Now if you look carefully at the very end of the line of code that shows a `Toast`
    message to the user, you will see something else new, `.show()`.
  prefs: []
  type: TYPE_NORMAL
- en: This is called `Toast` class but using just one line of code. It is the `show`
    method that actually triggers the message.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at chaining more closely as we proceed through the book, such as
    in [*Chapter 14*](B16773_14_ePub_RK.xhtml#_idTextAnchor249), *Android Dialog Windows*,
    when we make a pop-up dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to read about the `Toast` class and some of its other methods in
    detail, you can do so here: [http://developer.android.com/reference/android/widget/Toast.html](http://developer.android.com/reference/android/widget/Toast.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Static methods are often provided in classes that have uses that are so generic
    it doesn't make sense to create an object of the class. Another really useful
    class with static methods is `Math`. This class is actually a part of the Java
    API, not the Android API.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Want to write a calculator app? It''s easier than you think with the static
    methods of the `Math` class. You can look at them here: [http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html](http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html).'
  prefs: []
  type: TYPE_NORMAL
- en: If you try this out, you will need to import the `Math` class the same way you
    imported all the other classes we have used. Next, we can try out a practical
    mini app to understand encapsulation and static methods.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation and static methods mini-app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have looked at the intricate way that access to variables and their scope
    is controlled and it would serve us well to look at an example of them in action.
    These will not so much be practical real-world examples of variable use, more
    a demonstration to help understand access modifiers for classes, methods, and
    variables alongside the different types of variables such as reference or primitive
    and local or instance, along with the new concepts of static and final variables
    and the `this` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The completed code is in the [*Chapter 11*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)
    folder of the download bundle. It is called `Access Scope This And Static`.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Empty Activity project and call it `Access Scope This And Static`.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class by right-clicking on the existing `MainActivity` class in
    the project explorer and clicking `AlienShip`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will declare our new class and some member variables. Note that `numShips`
    is `private` and `static`. We will see how this variable is the same across all
    instances of the class soon. The `shieldStrength` variable is `private` and `shipName`
    is public:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is the constructor. We can see that the constructor is public, has no
    return type, and has the same name as the class – as per the rules. In it, we
    increment the private static `numShips` variable. Remember this will happen each
    time we create a new object of type `AlienShip`. Also, the constructor sets a
    value for the private variable `shieldStrength` using the private `setShieldStrength`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the public static getter method so classes outside of `AlienShip` can
    find out how many `AlienShip` objects there are. We will also see the way in which
    we use static methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is our private `setShieldStrength` method. We could have just set
    `shieldStrength` directly from within the class, but the code below shows how
    we distinguish between the `shieldStrength` local variable/parameter and the `shieldStrength`
    member variable by using the `this` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This next method is the getter so other classes can read but not alter the
    shield strength of each `AlienShip` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a public method that can be called every time an `AlienShip` object
    is hit. It just prints to the console and then detects whether that object''s
    `shieldStrength` is zero. If it is, it calls the `destroyShip` method, which we''ll
    look at next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And lastly for our `AlienShip` class, we will code the `destroyShip` method.
    We print a message that indicates which ship has been destroyed based on its `shipName`
    as well as decrementing the `numShips` static variable so we can keep track of
    how many objects of type `AlienShip` we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we switch over to our `MainActivity` class and write some code that uses
    our new `AlienShip` class. All the code goes in the `onCreate` method after the
    call to `setContentView`. First, we create two new `AlienShip` objects called
    `girlShip` and `boyShip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next code, look at how we get the value in `numShips`. We use the `getNumShips`
    method as we might expect. However, look closely at the syntax. We are using the
    class name and not an object. We can also access static variables with methods
    that are not static. We did it this way to see a static method in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we assign names to our public `shipName` String variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In this next code, we try to assign a value directly to a private variable.
    It won''t work. Then we use the public getter method `getShieldStrength` to print
    out the `shieldStrength`, which was assigned in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we get to blow some stuff up by playing with the `hitDetected` method
    and occasionally checking the `shieldStrength` of our two objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When we think we have destroyed a ship, we again use our static `getNumShips`
    method to see if our static variable `numShips` was changed by the `destroyShip`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the demo and look at the console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we saw that we can distinguish between local and member
    variables of the same name by using the `this` keyword. We can also use the `this`
    keyword to write code that refers to whatever the current object being acted upon
    is.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that a static variable – in this case, `numShips` – is consistent across
    all instances; moreover, by incrementing it in the constructor and decrementing
    it in our `destroyShip` method, we can keep track of the number of `AlienShip`
    objects we currently have.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw that we can use static methods by using the class name with the
    dot operator instead of an actual object.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Yes, I know it is like living in the blueprint of a house – but it's quite useful
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we proved how we could hide and expose certain methods and variables
    using an access specifier.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at the topic of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: OOP and inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how we can use other people's code by instantiating/creating objects
    from the classes of an API like Android. But this whole OOP thing goes even further
    than that.
  prefs: []
  type: TYPE_NORMAL
- en: What if there is a class that has loads of useful functionality in it but not
    exactly what we want? We can inherit from the class and then further refine or
    add to how it works and what it does.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be surprised to hear that we have done this already. In fact, we
    have done this with every single app we have created. When we use the `extends`
    keyword, we are inheriting. Remember this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are inheriting the `AppCompatActivity` class along with all its functionality
    – or more specifically, all the functionality that the class designers want us
    to have access to. Here are some of the things we can do to classes we have extended.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even override a method *and* still rely in part on the overridden method
    in the class we inherit from. For example, we overrode the `onCreate` method every
    time we extended the `AppCompatActivity` class. But we also called on the default
    implementation provided by the class designers when we did this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: And in [*Chapter 6*](B16773_06_ePub_RK.xhtml#_idTextAnchor119), *The Android
    Lifecycle*, we overrode just about all of the Activity class lifecycle methods.
  prefs: []
  type: TYPE_NORMAL
- en: We discuss inheritance mainly so that we understand what is going on around
    us and as the first step towards being able to eventually design useful classes
    that we or others can extend.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, let's look at some example classes and see how we can extend
    them, just to see the syntax and as a first step, and also to be able to say we
    have done it.
  prefs: []
  type: TYPE_NORMAL
- en: When we look at the final major topic of this chapter, polymorphism, we will
    also dig a little deeper into inheritance at the same time. Here is some code
    using inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code would go in a file named `Animal.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in a separate file named `Elephant.java`, we could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see in the previous code that we have implemented a class called `Animal`
    and it has four member variables: `age`, `weight`, `type`, and `hungerLevel`.
    It also has two methods, `eat` and `walk`.'
  prefs: []
  type: TYPE_NORMAL
- en: We then extended `Animal` with `Elephant`. `Elephant` can now do anything an
    `Animal` can and it also has all its variables.
  prefs: []
  type: TYPE_NORMAL
- en: We initialized the variables from `Animal` that `Elephant` has in the `Elephant`
    constructor. Two variables (`age` and `weight`) are passed into the constructor
    when an `Elephant` object is created and two variables (`type` and `hungerLevel`)
    are assigned the same for all `Elephant` objects.
  prefs: []
  type: TYPE_NORMAL
- en: We could go ahead and write a bunch of other classes that extend `Animal`, perhaps
    `Lion`, `Tiger`, and `ThreeToedSloth`. Each would have an `age`, `weight`, `type`,
    and `hungerLevel` and each would be able to `walk` and `eat`.
  prefs: []
  type: TYPE_NORMAL
- en: As if OOP were not useful enough already, we can now model real-world objects.
    We have also seen that we can make OOP even more useful by subclassing/extending/inheriting
    from other classes. The terminology we might like to learn here is that the class
    that is extended from is the **super class** and the class that inherits from
    the super class is the **subclass**. We can also say the parent and child class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, we might find ourselves asking this question about inheritance. Why?
    The reason is something like this: we can write common code once, in the parent
    class; we can update that common code and all classes that inherit from it are
    also updated. Furthermore, a subclass only gets to use public/protected instance
    variables and methods. So, designed properly, this also further enhances the goals
    of encapsulation.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's build another small app to play about with inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance example app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have looked at the way we can create hierarchies of classes to model a system
    that fits our app. So, let's try out some simple code that uses inheritance. The
    completed code is in the [*Chapter 11*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)
    folder of the code download. It is called `Inheritance Example`.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project called `Inheritance Example` using the `AlienShip`, another
    `Fighter`, and the last one `Bomber`.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the code for the `AlienShip` class. It is very similar to our previous
    class demo, `AlienShip`. The differences are that the constructor now takes an
    `int` parameter, which it uses to set the shield strength.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor also outputs a message to the logcat window, so we can see when
    it is being used. The `AlienShip` class also has a new method, `fireWeapon`, that
    is declared as `abstract`.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a class as abstract guarantees that any class that subclasses `AlienShip`
    must implement its own version of `fireWeapon`. Notice the class has the `abstract`
    keyword as part of its declaration. We have to do this because one of its methods
    also uses the `abstract` keyword. We will explain the `abstract` method when discussing
    this demo and the `abstract` class when we talk about polymorphism in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `AlienShip` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will implement the `Bomber` class. Notice the call to `super(100)`.
    This calls the constructor of the super class with the value for `shieldStrength`.
    We could do further specific `Bomber` initialization in this constructor, but
    for now, we just print out the location so we can see when the `Bomber` constructor
    is being executed. We also, because we must, implement a `Bomber` specific version
    of the abstract `fireWeapon` method. Add the following code to the `Bomber` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will implement the `Fighter` class. Notice the call to `super(400)`.
    This calls the constructor of the super class with the value for `shieldStrength`.
    We could do further specific `Fighter` initialization in this constructor but
    for now, we just print out the location so we can see when the `Fighter` constructor
    is being executed. We also must implement a `Fighter` specific version of the
    abstract `fireWeapon` method. Add the following code to the `Fighter` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will code the `onCreate` method of `MainActivity`. As usual, enter
    this code after the call to the `setContentView` method. This is the code that
    uses our three new classes. The code looks quite ordinary – nothing new. It is
    the output that is interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the app and you will get the following output in the logcat window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We can see how the constructor of the subclass calls the constructor of the
    super class. We can also clearly see that the individual implementations of the
    `fireWeapon` method work exactly as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a closer look at the final major OOP concept, polymorphism. Then
    we will be able to do some more practical things with the Android API.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know that polymorphism means *different forms*. But what does it
    mean to us?
  prefs: []
  type: TYPE_NORMAL
- en: 'Boiled down to its simplest:'
  prefs: []
  type: TYPE_NORMAL
- en: Any subclass can be used as part of the code that uses the super class.
  prefs: []
  type: TYPE_NORMAL
- en: This means we can write code that is simpler and easier to understand, and easier
    to change.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we can write code for the super class and rely on the fact that no matter
    how many times it is sub-classed, within certain parameters, the code will still
    work. Let's discuss an example.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to use polymorphism to help to write a zoo management app. We
    will probably want to have a method such as `feed`. We will probably want to pass
    a reference to the animal to be fed into the `feed` method. This might seem like
    we need to write a `feed` method for each and every type of `Animal`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can write polymorphic methods with polymorphic return types and
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method has `Animal` as a parameter, which means that any object
    that is built from a class that extends `Animal` can be passed into it. And as
    you can see in the preceding code, the method also returns `Animal`, which has
    exactly the same benefits.
  prefs: []
  type: TYPE_NORMAL
- en: There is a small gotcha with polymorphic return types and that is that we need
    to be aware of what is being returned and make it explicit in the code that calls
    the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could handle `Elephant` being passed into the `feed` method
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Notice the highlighted `(Elephant)` in the previous code. This makes it plain
    that we want `Elephant` from the returned `Animal`. This is called **casting**.
    We will use casting occasionally throughout the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: So, you can even write code *today* and make another subclass in a week, month,
    or year, and the very same methods and data structures will still work.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we can enforce upon our subclasses a set of rules as to what they can
    and cannot do, as well as how they do it. So, clever design in one stage can influence
    it at other stages.
  prefs: []
  type: TYPE_NORMAL
- en: But will we ever really want to instantiate an actual `Animal`?
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We played with an abstract class in the inheritance example app but let's dig
    a little deeper. An abstract class is a class that cannot be instantiated; it
    cannot be made into an object. So, it's a blueprint that will never be used then?
    But that's like paying an architect to design your home and then never building
    it? You might be saying to yourself, "I kind of got the idea of an abstract method
    but abstract classes are just silly."
  prefs: []
  type: TYPE_NORMAL
- en: If we or the designer of a class wants to force us to inherit *before* we use
    their class, they can declare a class **abstract**. Then, we cannot make an object
    from it; therefore, we must extend it first and make an object from the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: We can also declare a method `abstract` and then that method must be overridden
    in any class that extends the class with the abstract method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example – it will help. We make a class `abstract` by declaring
    it with the `abstract` keyword like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Yes, but why?
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes we want a class that can be used as a polymorphic type, but we need
    to guarantee it can never be used as an object. For example, "animal" doesn't
    really make sense on its own.
  prefs: []
  type: TYPE_NORMAL
- en: We don't talk about animals; we talk about *types* of animals. We don't say,
    "Ooh, look at that lovely fluffy, white animal." Or, "Yesterday we went to the
    pet shop and got an animal and an animal bed." It's just too, well, *abstract*.
  prefs: []
  type: TYPE_NORMAL
- en: So, an abstract class is kind of like a template to be used by any class that
    `extends` it (inherits from it).
  prefs: []
  type: TYPE_NORMAL
- en: We might want a `Worker` class and extend it to make `Miner`, `Steelworker`,
    `OfficeWorker`, and of course `Programmer`. But what exactly does a plain `Worker`
    do? Why would we ever want to instantiate one?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is we probably wouldn't want to instantiate one; but we might want
    to use it as a polymorphic type, so we can pass multiple worker subclasses between
    methods and have data structures that can hold all types of `Worker`.
  prefs: []
  type: TYPE_NORMAL
- en: We call this type of class an abstract class and when a class has even one abstract
    method, it must be declared abstract itself. And all abstract methods must be
    overridden by any class that extends it.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the abstract class can give some of the common functionality
    that would be available in all its subclasses. For example, the `Worker` class
    might have the `height`, `weight`, and `age` member variables.
  prefs: []
  type: TYPE_NORMAL
- en: It might also have the `getPayCheck` method, which is not abstract and is the
    same in all the subclasses, but a `doWork` method is abstract and must be overridden,
    because all the different types of worker `doWork` differently.
  prefs: []
  type: TYPE_NORMAL
- en: This leads us neatly to another area of polymorphism that is going to make life
    easier for us throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An interface is like a class. Phew! Nothing complicated here then. But it's
    like a class that is always abstract and has only abstract methods.
  prefs: []
  type: TYPE_NORMAL
- en: We can think of an interface as an entirely abstract class with all its methods
    abstract and no member variables either.
  prefs: []
  type: TYPE_NORMAL
- en: OK, so you can just about wrap your head around an abstract class because at
    least it can pass on some functionality in its methods that are not abstract and
    serve as a polymorphic type. But seriously, this interface seems a bit pointless.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the simplest possible generic example of an interface, then we
    can discuss it further.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define an interface, we type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The methods of an interface have no body because they are abstract, but they
    can still have return types and parameters, or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use an interface, we use the `implements` keyword after the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This enables us to use polymorphism with multiple different objects that are
    from completely unrelated inheritance hierarchies. If a class implements an interface,
    the whole thing can be passed along or used as if it is that thing – because it
    is that thing. It is polymorphic (many things).
  prefs: []
  type: TYPE_NORMAL
- en: We can even have a class implement multiple different interfaces at the same
    time. Just add a comma between each interface and list them after the `implements`
    keyword. Just be sure to implement all the necessary methods.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will use the interfaces of the Android API more often than
    we write our own. In [*Chapter 13*](B16773_13_ePub_RK.xhtml#_idTextAnchor228)*,
    Anonymous Classes - Bringing Android Widgets to Life*, one such interface we will
    use in the Java Meet UI app is the `OnClickListener` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Many things might like to know when they are being clicked. Perhaps a `Button`
    or a `TextView` widget, and so on. So, using an interface we don't need different
    methods for every type of UI element we might like to click.
  prefs: []
  type: TYPE_NORMAL
- en: Frequently asked questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is wrong with this class declaration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: There are no private classes. Classes can be public or default. Public classes
    are public; default classes are private within their own package.
  prefs: []
  type: TYPE_NORMAL
- en: What is encapsulation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encapsulation is how we contain our variables, code, and methods in a manner
    that exposes just the parts and functionality we want to other code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered more theory than in any other chapter. If you haven't
    memorized everything or some of the code seemed a bit too in-depth, then you have
    still succeeded completely.
  prefs: []
  type: TYPE_NORMAL
- en: If you just understand that OOP is about writing reusable, extendable, and efficient
    code through encapsulation, inheritance, and polymorphism, then you have the potential
    to be a Java master.
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, OOP enables us to use other peoples' code even when those other
    people were not aware of exactly what we would be doing at the time they wrote
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: All you must do is keep practicing because we will constantly be using these
    same concepts over and over again throughout the book, so you do not need to have
    even begun to have mastered them at this point.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be revisiting some concepts from this chapter as
    well as looking at some new aspects of OOP and how it enables our Java code to
    interact with our XML layouts.
  prefs: []
  type: TYPE_NORMAL
- en: But first, there is an important incoming news flash!
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: All the UI elements – `TextView`, `ConstraintLayout`, `CalenderView`, and `Button`
    – are classes too. Their attributes are member variables and they have loads of
    methods that we can use to do all sorts of things with the UI. This could prove
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: There will much more on this revelation in the next two chapters, but first,
    we will see how Android handles trash.
  prefs: []
  type: TYPE_NORMAL
