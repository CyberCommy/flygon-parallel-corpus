- en: '*Chapter 7*: Model View Programming'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：模型视图编程'
- en: '**Model/View programming** is used to separate data from Views in Qt to handle
    datasets. The **Model/View (M/V)** architecture differentiates the functionalities
    that give freedom to the developers to modify and present the information on the
    **User Interface** (**UI**) in multiple ways. We will discuss each component of
    the architecture,the related convenience classes offered by Qt, and how to use
    them with practical examples. Throughout this chapter, we will be discussing the
    Model View pattern and understand the underlying core concepts.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模型/视图编程用于在Qt中处理数据集时将数据与视图分离。**模型/视图（M/V）**架构区分了功能，使开发人员可以以多种方式修改和呈现**用户界面（UI）**上的信息。我们将讨论架构的每个组件，Qt提供的相关便利类，以及如何使用实际示例。在本章中，我们将讨论模型视图模式并了解基本核心概念。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Fundamentals of the M/V architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M/V架构的基本原理
- en: Using Models and Views
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型和视图
- en: Creating custom Models and delegates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义模型和委托
- en: Displaying information using M/V in Qt Widgets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Qt小部件中使用M/V显示信息
- en: Displaying information using M/V in QML
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在QML中使用M/V显示信息
- en: Using C++ Models with QML
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C++模型与QML
- en: By the end of this chapter, you will be able to create a data model and display
    information on a customized UI. You will be able to write your custom models and
    delegates. You will also learn to represent the information in a UI through Qt
    Widgets and QML.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够创建数据模型并在自定义UI上显示信息。您将能够编写自定义模型和委托。您还将学会通过Qt小部件和QML在UI中表示信息。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The technical requirements for this chapter include the minimum versions of
    Qt 6.0.0 and Qt Creator 4.14.0 installed on one of the latest desktop platforms,
    such as Windows 10, Ubuntu 20.04, or macOS 10.14.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求包括在最新的桌面平台之一（如Windows 10、Ubuntu 20.04或macOS 10.14）上安装Qt 6.0.0和Qt Creator
    4.14.0的最低版本。
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter07](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter07).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有代码都可以从以下GitHub链接下载：[https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter07](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter07)。
- en: Important note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The screenshots used in this chapter are taken on the Windows platform. You
    will see similar screens based on the underlying platform on your machine.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的屏幕截图是在Windows平台上获取的。您将在您的机器上基于底层平台看到类似的屏幕。
- en: Understanding the M/V architecture
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解M/V架构
- en: 'Traditionally, the **Model-View-Controller** (**MVC**) design pattern is often
    used when building UIs. As the name suggests, it consists of three terms: Model,
    View, and Controller. The **Model** is an independent component with a dynamic
    data structure and logic, the **View** is the visual element, and the **Controller**
    decides how the UI responds to the user inputs. Before MVC came into existence,
    developers used to put these components together. It is not always possible to
    decouple the Controller from other components although developers want to keep
    them as distinct from each other as possible. MVC design decouples the components
    to increase flexibility and reuse. The following figure illustrates the components
    of a traditional MVC pattern:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，在构建UI时经常使用**模型-视图-控制器（MVC）**设计模式。顾名思义，它由三个术语组成：模型、视图和控制器。**模型**是具有动态数据结构和逻辑的独立组件，**视图**是视觉元素，**控制器**决定UI如何响应用户输入。在MVC出现之前，开发人员通常将这些组件放在一起。虽然开发人员希望将控制器与其他组件分离，但并不总是可能。MVC设计将组件解耦以增加灵活性和重用。以下图示了传统MVC模式的组件：
- en: '![Figure 7.1 – Traditional MVC design pattern'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 – 传统MVC设计模式'
- en: '](img/Figure_7.1_B16231.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.1_B16231.jpg)'
- en: Figure 7.1 – Traditional MVC design pattern
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 传统MVC设计模式
- en: 'In the MVC pattern, a user sees the View and interacts with a Controller. The
    Controller sends data to the Model and the Model updates the View. If the View
    and the Controller components are combined, then it results in the M/V architecture.
    It provides a more versatile architecture. It is based on the same principle but
    makes the implementation much simpler. The modified architecture allows us to
    display the same data in several different Views. The developer can implement
    new types of Views without changing the underlying data structures. To bring this
    flexibility to our handling of the user inputs, Qt introduced the concept of **delegate**.
    Instead of having a Controller, the View receives the data that is updated via
    a delegate. It has two primary purposes:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVC模式中，用户看到视图并与控制器交互。控制器将数据发送到模型，模型更新视图。如果视图和控制器组件合并，则会得到M/V架构。它提供了更灵活的架构。它基于相同的原则，但使实现变得更简单。修改后的架构允许我们在多个不同的视图中显示相同的数据。开发人员可以实现新类型的视图而不更改底层数据结构。为了将这种灵活性带入我们对用户输入的处理中，Qt引入了**委托**的概念。视图接收通过委托更新的数据，而不是通过控制器。它有两个主要目的：
- en: To help the View render each value
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了帮助视图呈现每个值
- en: To help the View when the user wants to make some changes
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了帮助视图在用户想要进行一些更改时
- en: So, in a certain way, the Controller has combined with the View and the View
    also performs some of the Controller's work through the delegate. The benefit
    of having a delegate is that it provides the means by which data elements are
    rendered and modified.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在某种程度上，控制器已与视图合并，并且视图还通过委托执行了一些控制器的工作。拥有委托的好处在于它提供了渲染和修改数据元素的手段。
- en: 'Let''s understand the M/V implementation and its components with a diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过图表了解M/V的实现和其组件：
- en: '![Figure 7.2 – The Qt Model-View-Delegate Framework'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 – Qt模型-视图-委托框架'
- en: '](img/Figure_7.2_B16231.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.2_B16231.jpg)'
- en: Figure 7.2 – The Qt Model-View-Delegate Framework
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: As illustrated in *Figure 7.2*, the M/V components are separated into the three
    sections of **Model**, **View**, and **Delegate**. The **Model** interacts with
    a database and works as an interface for the architecture's other components.
    The purpose of the communication is determined by the data source and the model's
    implementation. The **View** attains the references to items of data known as
    a **model index**. The View can retrieve the individual item data from the data
    model by using this model index. In standard Views, a delegate renders the items
    of data. When an item is modified, the **Delegate** notifies the Model by using
    the model index.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7.3* illustrates how a Model delivers data to the View, which is displayed
    on the individual delegates:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Model-View-Delegate implementation illustration'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.3_B16231.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – Model-View-Delegate implementation illustration
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The Qt framework provides a set of standard classes that implement the M/V architecture
    to manage the relationship between data and how the user sees it. By decoupling
    the functionalities, the architecture provides flexibility to customize the presentation
    of data and allows the combining of an extensive range of data sources with the
    Views.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The Model, View, and Delegate use a **signal and slot mechanism** to communicate
    with each other. The Model emits a signal to notify about the data change that
    occurred in the data source. When a user interacts with the View, then a signal
    from the View is emitted to notify about the user action. The Delegate emits a
    signal to notify the Model and View about the edited state.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have learned the fundamentals of the M/V architecture. The following
    sections explain how to use the M/V pattern in Qt. We will start with the standard
    classes provided by the Qt framework and then we will discuss the use of M/V in
    Qt Widgets. You will learn how to create new components as per the M/V architecture.
    Let's go ahead!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Model
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: M/V removes the data consistency challenges that may happen with the standard
    widgets. It makes it easier to use more than one View for the same data, as one
    Model can be passed to multiple Views. Qt provides several abstract classes for
    M/V implementation with common interfaces and certain feature implementations.
    You can subclass the abstract classes and add the intended functionalities expected
    by other components.In the M/V implementation, the model provides a standard interface
    used by the View and delegate to access the data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt offers some ready-made Model classes such as `QStandardItemModel`, `QFileSystemModel`,
    and `QSqlTableModel`. `QAbstractItemModel` is the standard interface defined by
    Qt. The subclasses of `QAbstractItemModel` represent the data in a hierarchical
    structure. *Figure 7.4* illustrates the hierarchy of Model classes:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – The hierarchy of Model classes in the Qt'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.4_B16231.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – The hierarchy of Model classes in the Qt
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Views use this approach to access individual data items in the Model, but they
    are not restricted in the way that they present this information to the user.
    The data passed through a Model can be held in a data structure or a database,
    or some other application component. All item Models are based on the `QAbstractItemModel`
    class.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7.5* shows how data is arranged in different types of Models:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Different types of models and arrangements of data'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.5_B16231.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – Different types of models and arrangements of data
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: The data is represented through Models either in a tabular representation in
    the form of rows and columns, or using a hierarchical representation of the data.
    In the M/V pattern, widgets do not store data behind the individual cells. They
    directly use the data. You may have to create a wrapper to make your data compatible
    with the `QAbstractItemModel` interface. Views use this interface to read and
    write the data. Any class that is derived from `QAbstractItemModel` is known as
    a Model. It provides an interface to handle Views that represent data in the forms
    of lists, tables, and trees. To implement a custom Model for a list or a table-like
    data structure, you can derive from `QAbstractListModel` and `QAbstractTableModel`
    to use the available features. The subclasses provide Models that are suitable
    for specialized lists and tables.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'The Qt framework provides two standard types of Models. They are as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '`QStandardItemModel`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QFileSystemModel`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `QStandardItemModel` is a multi-purpose Model where custom data can be stored.
    Each element refers to an item. It can be used to display a variety of data structures
    needed by lists, tables, and tree Views. It provides a traditional item-based
    approach to dealing with the Model. `QStandardItem` provides the items used in
    a `QStandardItemModel`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '`QFileSystemModel` is a Model that keeps information about the contents of
    a directory. It simply represents files and directories on the local filing system
    and doesn''t hold any items of data. It provides a ready-to-use Model to create
    a sample application and you can manipulate the data using Model indexes. Now,
    let''s discuss what a delegate is.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Delegate
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Delegates provide control over the presentation of items displayed in the View.
    The M/V pattern, unlike the MVC pattern, does not have an entirely different component
    for handling user interaction. The View is primarily in charge of displaying the
    Model data to the user and allowing them to interact with it. To add some flexibility
    to how the user action is obtained, the delegates handle the interactions. It
    empowers certain widgets to be used as editors for editable items in the Model.
    Delegates are used to provide interaction capabilities and rendering individual
    fields in the Views. The `QAbstractItemDelegate` class defines the basic interface
    for managing delegates. There are a few ready-made delegate classes provided by
    Qt to use with built-in widgets to modify a particular data type.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand it better, we will have a look at the hierarchy of delegate classes
    in the Qt framework (see *Figure 7.6*):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – The hierarchy of delegate classes in the Qt framework'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.6_B16231.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – The hierarchy of delegate classes in the Qt framework
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the preceding diagram, `QAbstractItemDelegate` is the abstract
    base class for delegates. The default delegate implementation is provided by `QStyledItemDelegate`.
    Qt's standard Views use it as the default delegate. Other options for painting
    and creating editors for items in Views are `QStyledItemDelegate` and `QItemDelegate`.
    You can use `QItemDelegate` to customize display features and editor widgets for
    an item. The difference between these two classes is that, unlike `QItemDelegate`,
    `QStyledItemDelegate` uses the current style to paint its items. `QStyledItemDelegate`
    can handle the most common data types such as `int` and `QString`. It is recommended
    to subclass `QStyledItemDelegate` while creating new delegates or while working
    with Qt Style Sheets. By writing a custom delegate, you can use a custom data
    type or customize the rendering.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed the different types of Models and delegates. Let's
    discuss the View classes provided by Qt Widgets.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Views in Qt Widgets
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several convenience classes are derived from the standard View classes to implement
    the M/V pattern. Examples of such convenience classes are `QListWidget`, `QTableWidget`,
    and `QTreeWidget`. As per the Qt documentation, these classes are less adaptable
    than View classes, and they can't be used for random Models. Based on your project
    requirements, you have to choose suitable widget classes for implementing the
    M/V pattern.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个便利类是从标准View类派生出来实现M/V模式的。这些便利类的示例包括`QListWidget`、`QTableWidget`和`QTreeWidget`。根据Qt文档，这些类比View类更不灵活，不能用于随机模型。根据项目要求，您必须选择适合实现M/V模式的小部件类。
- en: 'If you want to use an item-based interface and take advantage of the M/V pattern,
    then it is recommended to use the following View classes with `QStandardItemModel`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用基于项目的界面并利用M/V模式，建议使用以下View类与`QStandardItemModel`一起使用：
- en: '`QListView` displays a list of items.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QListView`显示项目列表。'
- en: '`QTableView` displays data from a Model in a table.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QTableView`在表格中显示模型数据。'
- en: '`QTreeView` shows Model items of data in a hierarchical list.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QTreeView`以分层列表显示模型数据项。'
- en: 'The hierarchy of View classes in the Qt framework is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Qt框架中View类的层次结构如下：
- en: '![Figure 7.7 – The hierarchy of View classes in the Qt framework'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7 - Qt框架中View类的层次结构'
- en: '](img/Figure_7.7_B16231.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.7_B16231.jpg)'
- en: Figure 7.7 – The hierarchy of View classes in the Qt framework
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 - Qt框架中View类的层次结构
- en: '`QAbstractItemView` is the abstract base class of the aforementioned classes.
    These classes can be derived to have specialized Views, even though they provide
    ready-to-use implementations. The most appropriate Views to use for `QFileSystemModel`
    are `QListView` and `QTreeView`. Each of these Views has its unique way of representing
    the data items. For example, `QTreeView` displays a tree hierarchy as a horizontal
    series of lists. All these Views must have a Model associated with them. There
    are several predefined Models provided by Qt. You can add your own customized
    Model if the ready-made Models don''t meet your criteria.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`QAbstractItemView`是上述类的抽象基类。尽管这些类提供了可直接使用的实现，但这些类可以派生为具有专门视图，最适合用于`QFileSystemModel`的视图是`QListView`和`QTreeView`。每个视图都必须与模型相关联。Qt提供了几个预定义的模型。如果现成的模型不符合您的标准，您可以添加自定义模型。'
- en: Unlike the View classes (for which the class name ends with `View`), the convenience
    widgets (for which the class name ends with `Widget`) do not need to be backed
    by a Model and can be used directly. The main advantage of using convenience widgets
    is that they require the least amount of effort to work with them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与View类不同（类名以`View`结尾），便利小部件（类名以`Widget`结尾）不需要由模型支持，可以直接使用。使用便利小部件的主要优势是，它们需要的工作量最少。
- en: 'Let''s look at the different View classes in the Qt Widgets module and which
    readymade Models can be used with them:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Qt Widgets模块中的不同View类以及可以与它们一起使用的现成模型：
- en: '![Figure 7.8 – Different types of Qt widgets used as the View in the M/V pattern'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8 - 在M/V模式中用作View的不同类型的Qt小部件'
- en: '](img/Figure_7.8_B16231.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.8_B16231.jpg)'
- en: Figure 7.8 – Different types of Qt widgets used as the View in the M/V pattern
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 - 在M/V模式中用作View的不同类型的Qt小部件
- en: The delegate is used to display individual field data in `QListView`, `QTableView`,
    or `QTreeView`. When a user starts interacting with an item, the delegate provides
    an editor widget for editing to take place.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 委托用于在`QListView`、`QTableView`或`QTreeView`中显示单个字段数据。当用户开始与项目交互时，委托提供一个编辑器小部件进行编辑。
- en: 'You can find a comparative overview of the aforementioned classes and learn
    about the uses of the corresponding widgets at the following link:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到上述类的比较概述，并了解相应小部件的用途：
- en: '[https://doc.qt.io/qt-6/modelview.html](https://doc.qt.io/qt-6/modelview.html)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/modelview.html](https://doc.qt.io/qt-6/modelview.html)'
- en: In this section, you learned about the M/V architecture and got familiar with
    the terms used. Let's implement M/V with a simple GUI application using Qt Widgets.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您了解了M/V架构并熟悉了所使用的术语。让我们使用Qt Widgets创建一个简单的GUI应用程序来实现M/V。
- en: Creating a simple Qt Widgets application using the M/V pattern
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用M/V模式创建一个简单的Qt Widgets应用程序
- en: It is time for us to create a simple example using *Qt Widgets*. The example
    in this section illustrates how a predefined `QFileSystemModel` is used in association
    with the built-in `QListView` and `QTreeView` widgets. Delegation is automatically
    taken care of when the Views are double-clicked.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使用*Qt Widgets*创建一个简单的示例了。本节中的示例演示了如何将预定义的`QFileSystemModel`与内置的`QListView`和`QTreeView`小部件关联使用。当双击视图时，委托会自动处理。
- en: 'Follow these steps to create a simple application that implements the M/V pattern:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个实现M/V模式的简单应用程序：
- en: Create a new project using Qt Creator, selecting the **Qt Widgets** template
    from the project creation wizard. It will generate a project with a predefined
    project skeleton.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Qt Creator创建一个新项目，从项目创建向导中选择**Qt Widgets**模板。它将生成一个带有预定义项目骨架的项目。
- en: Once the application skeleton is created, open the `.ui` form and add `QListView`
    and `QTreeView` to the form. You may add two labels to distinguish the Views as
    shown here:![](img/Figure_7.9_B16231.jpg)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建应用程序骨架后，打开`.ui`表单并将`QListView`和`QTreeView`添加到表单中。您可以添加两个标签以区分视图，如下所示：![](img/Figure_7.9_B16231.jpg)
- en: Figure 7.9 – Create a UI with QListView and QTreeView using Qt Designer
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 - 使用Qt Designer创建一个带有QListView和QTreeView的UI
- en: 'Open the `mainwindow.cpp` file and add the following contents:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`mainwindow.cpp`文件并添加以下内容：
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding C++ implementation, we have used a predefined `QFileSystemModel`
    as the Model for the Views.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的C++实现中，我们使用了预定义的`QFileSystemModel`作为View的模型。
- en: Next, hit the **Run** button in the left pane. You will see a window as shown
    in *Figure 7.10* once you hit the **Run** button:![Figure 7.10 – Output of the
    sample application showing QListView and QTreeView
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.10_B16231.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.10 – Output of the sample application showing QListView and QTreeView
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the existing application to use a custom Model derived from `QAbstractItemModel`.
    In the following example, we have created a simple `ContactListModel` custom class
    derived from `QAbstractItemModel`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, modify the UI form to implement a `QTableView` and set the contact list
    Model to it as shown in the following snippet:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can add `QStringListModel` to the `QListView` to use a simple list Model:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, hit the **Run** button in the left pane. You will see a window as shown
    in *Figure 7.11*:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Output of the application using custom models in QListView
    and QTableView'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.11_B16231.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.11 – Output of the application using custom models in QListView and
    QTableView
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have learned how to use M/V for your Qt widgets project.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: For more implementations of convenience classes such as `QTableWidget` or `QtTreeWidget`,
    explore the relevant examples on the Qt Creator welcome screen and this chapter's
    source code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create your own custom delegate class. To create a custom delegate,
    you need to subclass `QAbstractItemDelegate` or any of the convenience classes
    such as `QStyledItemDelegate` or `QItemDelegate`. A custom delegate class may
    look like the following code snippet:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You have to override the virtual methods and add respective logic as per your
    project needs. You can learn more about the custom delegates and examples at the
    following link:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doc.qt.io/qt-6/model-View-programming.html](https://doc.qt.io/qt-6/model-View-programming.html)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to create a GUI application that uses the M/V
    pattern. In the next section, we will discuss how it is implemented in QML.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Models and Views in QML
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like Qt Widgets, Qt Quick also implements Models, Views, and delegates
    to display data. The implementation modularizes the visualization of data to empower
    developers to manage that data. You can change one View with another with minimal
    changes to the data.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: To visualize data, bind the View's `model` property to a Model and the `delegate`
    property to a component or another compatible type.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss the QML types available for implementing the M/V pattern in a
    Qt Quick application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Views in Qt Quick
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Views are containers that display data and are used for collections of items.
    These containers are feature-rich and can be customized to meet specific style
    or behavior requirements.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a set of standard Views provided in the basic set of Qt Quick graphical
    types:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '`ListView`: Lays out items in a horizontal or vertical list'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GridView`: Lays out items in a grid manner'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TableView`: Lays out items in a tabular form'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PathView`: Lays out items on a path'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListView`, `GridView`, and `TableView` inherit from the `Flickable` QML type.
    `PathView` inherits `Item`. The `TreeView` QML type is obsolete. Let''s have a
    look at the inheritance of these QML types:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – The hierarchy of View classes in Qt Quick'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.12_B16231.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.12 – The hierarchy of View classes in Qt Quick
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The properties and behaviors are different for each QML type. They are used
    based on the GUI requirement. If you would like to know more about QML types,
    you can refer to their respective documentation. Let's explore Models in Qt Quick
    in the next section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Models in Qt Quick
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qt provides several convenience QML types to implement the M/V pattern. The
    modules provide very simple Models without requiring the creation of custom Model
    classes in C++. Examples of such convenience classes are `ListModel`, `TableModel`,
    and `XmlListModel`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'The `QtQml.Models` module provides the following QML types for defining data
    Models:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '`ListModel` defines a free-form list data source.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListElement` defines a data item in a `ListModel`.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DelegateModel` encapsulates a Model and delegate.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DelegateModelGroup` encapsulates a filtered set of visual data items.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ItemSelectionModel` inherits `QItemSelectionModel` and it keeps track of a
    View''s selected items.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ObjectModel` defines a set of items to be used as a Model.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Instantiator` dynamically instantiates objects.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Package` describes a collection of named items.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use the aforementioned QML types in your Qt Quick application, import the
    module with the following line:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '`import QtQml.Models`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss the readymade Models available in Qt Quick. `ListModel` is a
    simple container of `ListElement` definitions that contain data roles. It is used
    with `ListView`. `Qt.labs.qmlmodels` provides experimental QML types for models.
    These Models can be used for quick prototyping and displaying very simple data.
    The `TableModel` type stores JavaScript/JSON objects as data for a table Model
    and uses it with `TableView`. You can use these experimental types by importing
    the module as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '`import Qt.labs.qmlmodels`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to create a Model from XML data, then you can use `XmlListModel`.
    It can be used as a Model with Views such as `ListView`, `PathView`, and `GridView`.
    To use this Model, you have to import the module as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '`import QtQuick.XmlListModel`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: You can use `ListModel` and `XmlListModel` with `TableView` to create one column
    in `TableView`. To handle multiple rows and columns, you can use `TableModel`
    or you can create a custom C++ Model by subclassing `QAbstractItemModel`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use `Repeater` with Models. An integer can be used as a Model
    that defines the number of items. In that case, the Model does not have any data
    roles. Let''s create a simple example that uses `ListView` and a `Text` item as
    delegate components:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding example, we have used an `Text` as a delegate without using
    a component.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's explore how to use `ListModel` with `ListView`. `ListModel` is a
    simple hierarchy of types specified in QML. The available roles are specified
    by the `ListElement` properties. Let's create a simple application using `ListModel`
    with `ListView`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you want to create a simple address book application. You may need
    a few fields for a contact. In the following code snippet, we have used a `ListModel`
    that contains the names, phone numbers, and email addresses of some contacts:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have now created the Model. Next, we have to display it using a delegate.
    So, let''s modify the delegate component we created earlier with three `Text`
    elements. Based on your need you can create complex delegate types with icons,
    texts, or custom types. You can add a highlighted item and update the background
    based on focus. You need to provide a delegate to a View to visually represent
    an item in a list:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, we used `ListElement` with `ListModel`. The View displays
    each item as per the template defined by the delegate. Items in a Model can be
    accessed through the `index` property or through the item's properties.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about different types of Models and how to manipulate Model
    data at the following link:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doc.qt.io/qt-6/qtquick-modelviewsdata-modelview.html](https://doc.qt.io/qt-6/qtquick-modelviewsdata-modelview.html)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about M/V in QML. You can experiment with the custom
    Models and delegates and create a personalized View. Have a look at your phone
    book or recent call list on your cellphone and try to implement it. In the next
    section, you will learn how to integrate the QML frontend with a C++ Model.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Using C++ Models with QML
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have discussed how to use Models and Views in Qt Widgets and QML.
    But in most modern applications, you will require Models written in C++ and a
    frontend written in QML. Qt allows us to define Models in C++ and then access
    them inside QML. This is convenient for exposing existing C++ data Models or otherwise
    complex datasets to QML. Native C++ is always the right choice for complex logical
    operations. It can outperform logic written in QML with JavaScript.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了如何在Qt Widgets和QML中使用模型和视图。但在大多数现代应用程序中，您将需要在C++中编写模型，并在QML中编写前端。Qt允许我们在C++中定义模型，然后在QML中访问它们。这对于将现有的C++数据模型或其他复杂数据集暴露给QML非常方便。对于复杂的逻辑操作，原生C++始终是正确的选择。它可以优于使用JavaScript编写的QML中的逻辑。
- en: There are many reasons why you should create a C++ Model. C++ is type-safe and
    compiled into object code. It increases the stability of your application and
    reduces the number of bugs. It is flexible and can offer more features than the
    QML types. You can integrate with your existing code or with a third-party library
    that is written in C++.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多原因您应该创建一个C++模型。C++是类型安全的，并且编译为对象代码。它增加了应用程序的稳定性并减少了错误的数量。它灵活，并且可以提供比QML类型更多的功能。您可以与现有代码或使用C++编写的第三方库集成。
- en: 'You can define a C++ Model using the following classes:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下类定义C++模型：
- en: '`QStringList`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QStringList`'
- en: '`QVariantList`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QVariantList`'
- en: '`QObjectList`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QObjectList`'
- en: '`QAbstractItemModel`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QAbstractItemModel`'
- en: The first three classes are beneficial for exposing simpler datasets. `QAbstractItemModel`
    offers a more flexible solution to create complex Models. `QStringList` contains
    a list of `QString` instances and provides the contents of the list via the `modelData`
    role. Similarly, `QVariantList` contains a list of `QVariant` types and provides
    the contents of the list via the `modelData` role. If a `QVariantList` changes,
    then you must reset the Model. `QObjectList` embeds a list of `QObject*` that
    provides the properties of the objects in the list as roles. The `QObject*` is
    accessible as the `modelData` property. For convenience, the properties of the
    object can be accessed directly in the delegate's context.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个类有助于暴露更简单的数据集。`QAbstractItemModel`提供了一个更灵活的解决方案来创建复杂的模型。`QStringList`包含`QString`实例的列表，并通过`modelData`角色提供列表的内容。类似地，`QVariantList`包含`QVariant`类型的列表，并通过`modelData`角色提供列表的内容。如果`QVariantList`发生变化，则必须重置模型。`QObjectList`嵌入了一个`QObject*`列表，该列表提供了列表中对象的属性作为角色。`QObject*`可以作为`modelData`属性访问。为了方便起见，可以直接在委托的上下文中访问对象的属性。
- en: Qt also provides C++ classes to handle SQL data Model such as `QSqlQueryModel`,
    `QSqlTableModel`, and `QSqlRelationalTableModel`. `QSqlQueryModel` offers a read-only
    Model based on an SQL query. These classes reduce the need to run SQL queries
    for basic SQL operations such as insert, create, or update. These classes are
    derived from `QAbstractTableModel` and make it easy to present data from a database
    in a View class.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Qt还提供了处理SQL数据模型的C++类，例如`QSqlQueryModel`、`QSqlTableModel`和`QSqlRelationalTableModel`。`QSqlQueryModel`提供了基于SQL查询的只读模型。这些类减少了运行SQL查询以进行基本的SQL操作（如插入、创建或更新）的需要。这些类是从`QAbstractTableModel`派生的，使得在View类中轻松呈现来自数据库的数据变得容易。
- en: 'You can learn more about different types of C++ Models by visiting the following
    link:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问以下链接了解有关不同类型的C++模型的更多信息：
- en: '[https://doc.qt.io/qt-6/qtquick-modelviewsdata-cppmodels.html](https://doc.qt.io/qt-6/qtquick-modelviewsdata-cppmodels.html)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/qtquick-modelviewsdata-cppmodels.html](https://doc.qt.io/qt-6/qtquick-modelviewsdata-cppmodels.html)'
- en: In this section, we discussed C++ Models and why to use them. Now, you can fetch
    data from a C++ backend and present it in a UI developed in QML. In the next section,
    we will create a simple Qt Quick application using the aforementioned concept
    and explain how to use them inside QML.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了C++模型以及为什么要使用它们。现在，您可以从C++后端获取数据，并在QML中开发的UI中呈现它。在下一节中，我们将使用上述概念创建一个简单的Qt
    Quick应用程序，并解释如何在QML中使用它们。
- en: Creating a simple M/V application with Qt Quick
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Qt Quick创建一个简单的M/V应用程序
- en: In earlier sections, we discussed Qt's Model-View-Delegate framework. You learned
    how to create a custom Model and delegate and how to use a C++ Model. But you
    must be wondering how to integrate with our QML frontend. In this section, we
    will create a C++ Model and expose it to the QML engine. We will also discuss
    how to register a custom Model as a QML type.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们讨论了Qt的模型-视图-委托框架。您学会了如何创建自定义模型和委托，以及如何使用C++模型。但您一定想知道如何与我们的QML前端集成。在本节中，我们将创建一个C++模型并将其暴露给QML引擎。我们还将讨论如何将自定义模型注册为QML类型。
- en: 'Let''s create an application that fetches a Model from the C++ code and displays
    it in a Qt Quick-based application:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个应用程序，从C++代码中获取模型并在基于Qt Quick的应用程序中显示它：
- en: '[PRE8]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code snippet, we have created a simple Model based on `QStringList`.
    The string list contains four different strings. We have exposed the Model to
    the QML engine using `setContextProperty()`. Now, let''s use the Model inside
    our QML file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们创建了一个基于`QStringList`的简单模型。字符串列表包含四个不同的字符串。我们使用`setContextProperty()`将模型暴露给QML引擎。现在，让我们在QML文件中使用该模型：
- en: '[PRE9]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding example uses `QQmlContext::setContextProperty()` to set Model
    values directly in a QML component. An alternative to this is to register the
    C++ Model class as a QML type as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例使用`QQmlContext::setContextProperty()`在QML组件中直接设置模型值。另一种方法是将C++模型类注册为QML类型，如下所示：
- en: '`qmlRegisterType<MyModel>("MyModel",1,0,"MyModel");`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`qmlRegisterType<MyModel>("MyModel",1,0,"MyModel");`'
- en: 'The preceding line will allow the Model classes to be created directly as QML
    types within QML files. The first field is the C++ class name, then comes the
    desired package name, then the version number, and the last parameter is the type
    name in QML. You can import it into your QML file with the following line:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 上述行将允许直接在QML文件中将模型类创建为QML类型。第一个字段是C++类名，然后是所需的包名称，然后是版本号，最后一个参数是QML中的类型名称。您可以使用以下行将其导入到QML文件中：
- en: '`Import MyModel 1.0`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Import MyModel 1.0`'
- en: 'Let''s create an instance of `MyModel` inside our QML file as shown here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的QML文件中创建一个`MyModel`的实例，如下所示：
- en: '[PRE10]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can also use Models with `QQuickView` using `setInitialProperties()` as
    shown in the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`setInitialProperties()`在`QQuickView`中使用模型，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code snippet, we used `QQuickView` to create a UI and passed
    a custom C++ Model to the QML environment.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用了`QQuickView`来创建一个UI，并将自定义的C++模型传递给了QML环境。
- en: In this section, we learned how to integrate a simple C++ Model with QML. You
    can add signals and properties to extend the functionalities of your custom classes.
    Next, let's summarize our learnings in this chapter.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何将简单的C++模型与QML集成。您可以添加信号和属性来扩展自定义类的功能。接下来，让我们总结一下本章的学习成果。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a look at the core concepts of the Model-View-Delegate
    pattern in Qt. We explained how it is different from the traditional MVC pattern.
    We discussed different ways of using M/V and the convenience classes available
    in Qt. We learned how to apply the M/V concept in Qt Widgets as well as in Qt
    Quick. We discussed how to integrate a C++ Model with QML Views. We also created
    a few examples and implemented the concepts in our Qt application. You can now
    create your own Model, delegate, and Views. I hope you have understood the importance
    of the framework and the solid reasons for using it to meet your requirements.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入了解了Qt中的Model-View-Delegate模式的核心概念。我们解释了它与传统MVC模式的不同之处。我们讨论了在Qt中使用M/V的不同方式以及Qt中提供的便利类。我们学习了如何在Qt
    Widgets和Qt Quick中应用M/V概念。我们讨论了如何将C++模型集成到QML视图中。我们还创建了一些示例，并在我们的Qt应用程序中实现了这些概念。您现在可以创建自己的模型、委托和视图。我希望您已经理解了这个框架的重要性，以及使用它满足您需求的充分理由。
- en: In [*Chapter 8*](B16231_08_Final_ASB_ePub.xhtml#_idTextAnchor176), *Graphics
    and Animations*, we will learn about the graphics framework and how to add animations
    to your Qt Quick project.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B16231_08_Final_ASB_ePub.xhtml#_idTextAnchor176)，*图形和动画*中，我们将学习关于图形框架以及如何将动画添加到您的Qt
    Quick项目。
