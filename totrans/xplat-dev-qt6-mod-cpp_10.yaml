- en: '*Chapter 7*: Model View Programming'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Model/View programming** is used to separate data from Views in Qt to handle
    datasets. The **Model/View (M/V)** architecture differentiates the functionalities
    that give freedom to the developers to modify and present the information on the
    **User Interface** (**UI**) in multiple ways. We will discuss each component of
    the architecture,the related convenience classes offered by Qt, and how to use
    them with practical examples. Throughout this chapter, we will be discussing the
    Model View pattern and understand the underlying core concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentals of the M/V architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Models and Views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom Models and delegates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying information using M/V in Qt Widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying information using M/V in QML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using C++ Models with QML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to create a data model and display
    information on a customized UI. You will be able to write your custom models and
    delegates. You will also learn to represent the information in a UI through Qt
    Widgets and QML.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The technical requirements for this chapter include the minimum versions of
    Qt 6.0.0 and Qt Creator 4.14.0 installed on one of the latest desktop platforms,
    such as Windows 10, Ubuntu 20.04, or macOS 10.14.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter07](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter07).'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The screenshots used in this chapter are taken on the Windows platform. You
    will see similar screens based on the underlying platform on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the M/V architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Traditionally, the **Model-View-Controller** (**MVC**) design pattern is often
    used when building UIs. As the name suggests, it consists of three terms: Model,
    View, and Controller. The **Model** is an independent component with a dynamic
    data structure and logic, the **View** is the visual element, and the **Controller**
    decides how the UI responds to the user inputs. Before MVC came into existence,
    developers used to put these components together. It is not always possible to
    decouple the Controller from other components although developers want to keep
    them as distinct from each other as possible. MVC design decouples the components
    to increase flexibility and reuse. The following figure illustrates the components
    of a traditional MVC pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Traditional MVC design pattern'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.1_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Traditional MVC design pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'In the MVC pattern, a user sees the View and interacts with a Controller. The
    Controller sends data to the Model and the Model updates the View. If the View
    and the Controller components are combined, then it results in the M/V architecture.
    It provides a more versatile architecture. It is based on the same principle but
    makes the implementation much simpler. The modified architecture allows us to
    display the same data in several different Views. The developer can implement
    new types of Views without changing the underlying data structures. To bring this
    flexibility to our handling of the user inputs, Qt introduced the concept of **delegate**.
    Instead of having a Controller, the View receives the data that is updated via
    a delegate. It has two primary purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: To help the View render each value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To help the View when the user wants to make some changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, in a certain way, the Controller has combined with the View and the View
    also performs some of the Controller's work through the delegate. The benefit
    of having a delegate is that it provides the means by which data elements are
    rendered and modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the M/V implementation and its components with a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – The Qt Model-View-Delegate Framework'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.2_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – The Qt Model-View-Delegate Framework
  prefs: []
  type: TYPE_NORMAL
- en: As illustrated in *Figure 7.2*, the M/V components are separated into the three
    sections of **Model**, **View**, and **Delegate**. The **Model** interacts with
    a database and works as an interface for the architecture's other components.
    The purpose of the communication is determined by the data source and the model's
    implementation. The **View** attains the references to items of data known as
    a **model index**. The View can retrieve the individual item data from the data
    model by using this model index. In standard Views, a delegate renders the items
    of data. When an item is modified, the **Delegate** notifies the Model by using
    the model index.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7.3* illustrates how a Model delivers data to the View, which is displayed
    on the individual delegates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Model-View-Delegate implementation illustration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.3_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – Model-View-Delegate implementation illustration
  prefs: []
  type: TYPE_NORMAL
- en: The Qt framework provides a set of standard classes that implement the M/V architecture
    to manage the relationship between data and how the user sees it. By decoupling
    the functionalities, the architecture provides flexibility to customize the presentation
    of data and allows the combining of an extensive range of data sources with the
    Views.
  prefs: []
  type: TYPE_NORMAL
- en: The Model, View, and Delegate use a **signal and slot mechanism** to communicate
    with each other. The Model emits a signal to notify about the data change that
    occurred in the data source. When a user interacts with the View, then a signal
    from the View is emitted to notify about the user action. The Delegate emits a
    signal to notify the Model and View about the edited state.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have learned the fundamentals of the M/V architecture. The following
    sections explain how to use the M/V pattern in Qt. We will start with the standard
    classes provided by the Qt framework and then we will discuss the use of M/V in
    Qt Widgets. You will learn how to create new components as per the M/V architecture.
    Let's go ahead!
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: M/V removes the data consistency challenges that may happen with the standard
    widgets. It makes it easier to use more than one View for the same data, as one
    Model can be passed to multiple Views. Qt provides several abstract classes for
    M/V implementation with common interfaces and certain feature implementations.
    You can subclass the abstract classes and add the intended functionalities expected
    by other components.In the M/V implementation, the model provides a standard interface
    used by the View and delegate to access the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt offers some ready-made Model classes such as `QStandardItemModel`, `QFileSystemModel`,
    and `QSqlTableModel`. `QAbstractItemModel` is the standard interface defined by
    Qt. The subclasses of `QAbstractItemModel` represent the data in a hierarchical
    structure. *Figure 7.4* illustrates the hierarchy of Model classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – The hierarchy of Model classes in the Qt'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.4_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – The hierarchy of Model classes in the Qt
  prefs: []
  type: TYPE_NORMAL
- en: Views use this approach to access individual data items in the Model, but they
    are not restricted in the way that they present this information to the user.
    The data passed through a Model can be held in a data structure or a database,
    or some other application component. All item Models are based on the `QAbstractItemModel`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7.5* shows how data is arranged in different types of Models:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Different types of models and arrangements of data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.5_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – Different types of models and arrangements of data
  prefs: []
  type: TYPE_NORMAL
- en: The data is represented through Models either in a tabular representation in
    the form of rows and columns, or using a hierarchical representation of the data.
    In the M/V pattern, widgets do not store data behind the individual cells. They
    directly use the data. You may have to create a wrapper to make your data compatible
    with the `QAbstractItemModel` interface. Views use this interface to read and
    write the data. Any class that is derived from `QAbstractItemModel` is known as
    a Model. It provides an interface to handle Views that represent data in the forms
    of lists, tables, and trees. To implement a custom Model for a list or a table-like
    data structure, you can derive from `QAbstractListModel` and `QAbstractTableModel`
    to use the available features. The subclasses provide Models that are suitable
    for specialized lists and tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Qt framework provides two standard types of Models. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QStandardItemModel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QFileSystemModel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `QStandardItemModel` is a multi-purpose Model where custom data can be stored.
    Each element refers to an item. It can be used to display a variety of data structures
    needed by lists, tables, and tree Views. It provides a traditional item-based
    approach to dealing with the Model. `QStandardItem` provides the items used in
    a `QStandardItemModel`.
  prefs: []
  type: TYPE_NORMAL
- en: '`QFileSystemModel` is a Model that keeps information about the contents of
    a directory. It simply represents files and directories on the local filing system
    and doesn''t hold any items of data. It provides a ready-to-use Model to create
    a sample application and you can manipulate the data using Model indexes. Now,
    let''s discuss what a delegate is.'
  prefs: []
  type: TYPE_NORMAL
- en: Delegate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Delegates provide control over the presentation of items displayed in the View.
    The M/V pattern, unlike the MVC pattern, does not have an entirely different component
    for handling user interaction. The View is primarily in charge of displaying the
    Model data to the user and allowing them to interact with it. To add some flexibility
    to how the user action is obtained, the delegates handle the interactions. It
    empowers certain widgets to be used as editors for editable items in the Model.
    Delegates are used to provide interaction capabilities and rendering individual
    fields in the Views. The `QAbstractItemDelegate` class defines the basic interface
    for managing delegates. There are a few ready-made delegate classes provided by
    Qt to use with built-in widgets to modify a particular data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand it better, we will have a look at the hierarchy of delegate classes
    in the Qt framework (see *Figure 7.6*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – The hierarchy of delegate classes in the Qt framework'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.6_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – The hierarchy of delegate classes in the Qt framework
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the preceding diagram, `QAbstractItemDelegate` is the abstract
    base class for delegates. The default delegate implementation is provided by `QStyledItemDelegate`.
    Qt's standard Views use it as the default delegate. Other options for painting
    and creating editors for items in Views are `QStyledItemDelegate` and `QItemDelegate`.
    You can use `QItemDelegate` to customize display features and editor widgets for
    an item. The difference between these two classes is that, unlike `QItemDelegate`,
    `QStyledItemDelegate` uses the current style to paint its items. `QStyledItemDelegate`
    can handle the most common data types such as `int` and `QString`. It is recommended
    to subclass `QStyledItemDelegate` while creating new delegates or while working
    with Qt Style Sheets. By writing a custom delegate, you can use a custom data
    type or customize the rendering.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed the different types of Models and delegates. Let's
    discuss the View classes provided by Qt Widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Views in Qt Widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several convenience classes are derived from the standard View classes to implement
    the M/V pattern. Examples of such convenience classes are `QListWidget`, `QTableWidget`,
    and `QTreeWidget`. As per the Qt documentation, these classes are less adaptable
    than View classes, and they can't be used for random Models. Based on your project
    requirements, you have to choose suitable widget classes for implementing the
    M/V pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use an item-based interface and take advantage of the M/V pattern,
    then it is recommended to use the following View classes with `QStandardItemModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QListView` displays a list of items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QTableView` displays data from a Model in a table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QTreeView` shows Model items of data in a hierarchical list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The hierarchy of View classes in the Qt framework is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – The hierarchy of View classes in the Qt framework'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.7_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – The hierarchy of View classes in the Qt framework
  prefs: []
  type: TYPE_NORMAL
- en: '`QAbstractItemView` is the abstract base class of the aforementioned classes.
    These classes can be derived to have specialized Views, even though they provide
    ready-to-use implementations. The most appropriate Views to use for `QFileSystemModel`
    are `QListView` and `QTreeView`. Each of these Views has its unique way of representing
    the data items. For example, `QTreeView` displays a tree hierarchy as a horizontal
    series of lists. All these Views must have a Model associated with them. There
    are several predefined Models provided by Qt. You can add your own customized
    Model if the ready-made Models don''t meet your criteria.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the View classes (for which the class name ends with `View`), the convenience
    widgets (for which the class name ends with `Widget`) do not need to be backed
    by a Model and can be used directly. The main advantage of using convenience widgets
    is that they require the least amount of effort to work with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the different View classes in the Qt Widgets module and which
    readymade Models can be used with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Different types of Qt widgets used as the View in the M/V pattern'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.8_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8 – Different types of Qt widgets used as the View in the M/V pattern
  prefs: []
  type: TYPE_NORMAL
- en: The delegate is used to display individual field data in `QListView`, `QTableView`,
    or `QTreeView`. When a user starts interacting with an item, the delegate provides
    an editor widget for editing to take place.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a comparative overview of the aforementioned classes and learn
    about the uses of the corresponding widgets at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doc.qt.io/qt-6/modelview.html](https://doc.qt.io/qt-6/modelview.html)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about the M/V architecture and got familiar with
    the terms used. Let's implement M/V with a simple GUI application using Qt Widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple Qt Widgets application using the M/V pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is time for us to create a simple example using *Qt Widgets*. The example
    in this section illustrates how a predefined `QFileSystemModel` is used in association
    with the built-in `QListView` and `QTreeView` widgets. Delegation is automatically
    taken care of when the Views are double-clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create a simple application that implements the M/V pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project using Qt Creator, selecting the **Qt Widgets** template
    from the project creation wizard. It will generate a project with a predefined
    project skeleton.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the application skeleton is created, open the `.ui` form and add `QListView`
    and `QTreeView` to the form. You may add two labels to distinguish the Views as
    shown here:![](img/Figure_7.9_B16231.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 7.9 – Create a UI with QListView and QTreeView using Qt Designer
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `mainwindow.cpp` file and add the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding C++ implementation, we have used a predefined `QFileSystemModel`
    as the Model for the Views.
  prefs: []
  type: TYPE_NORMAL
- en: Next, hit the **Run** button in the left pane. You will see a window as shown
    in *Figure 7.10* once you hit the **Run** button:![Figure 7.10 – Output of the
    sample application showing QListView and QTreeView
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.10_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.10 – Output of the sample application showing QListView and QTreeView
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the existing application to use a custom Model derived from `QAbstractItemModel`.
    In the following example, we have created a simple `ContactListModel` custom class
    derived from `QAbstractItemModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, modify the UI form to implement a `QTableView` and set the contact list
    Model to it as shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add `QStringListModel` to the `QListView` to use a simple list Model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, hit the **Run** button in the left pane. You will see a window as shown
    in *Figure 7.11*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Output of the application using custom models in QListView
    and QTableView'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.11_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.11 – Output of the application using custom models in QListView and
    QTableView
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have learned how to use M/V for your Qt widgets project.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For more implementations of convenience classes such as `QTableWidget` or `QtTreeWidget`,
    explore the relevant examples on the Qt Creator welcome screen and this chapter's
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create your own custom delegate class. To create a custom delegate,
    you need to subclass `QAbstractItemDelegate` or any of the convenience classes
    such as `QStyledItemDelegate` or `QItemDelegate`. A custom delegate class may
    look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You have to override the virtual methods and add respective logic as per your
    project needs. You can learn more about the custom delegates and examples at the
    following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doc.qt.io/qt-6/model-View-programming.html](https://doc.qt.io/qt-6/model-View-programming.html)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to create a GUI application that uses the M/V
    pattern. In the next section, we will discuss how it is implemented in QML.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Models and Views in QML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like Qt Widgets, Qt Quick also implements Models, Views, and delegates
    to display data. The implementation modularizes the visualization of data to empower
    developers to manage that data. You can change one View with another with minimal
    changes to the data.
  prefs: []
  type: TYPE_NORMAL
- en: To visualize data, bind the View's `model` property to a Model and the `delegate`
    property to a component or another compatible type.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss the QML types available for implementing the M/V pattern in a
    Qt Quick application.
  prefs: []
  type: TYPE_NORMAL
- en: Views in Qt Quick
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Views are containers that display data and are used for collections of items.
    These containers are feature-rich and can be customized to meet specific style
    or behavior requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a set of standard Views provided in the basic set of Qt Quick graphical
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ListView`: Lays out items in a horizontal or vertical list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GridView`: Lays out items in a grid manner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TableView`: Lays out items in a tabular form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PathView`: Lays out items on a path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListView`, `GridView`, and `TableView` inherit from the `Flickable` QML type.
    `PathView` inherits `Item`. The `TreeView` QML type is obsolete. Let''s have a
    look at the inheritance of these QML types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – The hierarchy of View classes in Qt Quick'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.12_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.12 – The hierarchy of View classes in Qt Quick
  prefs: []
  type: TYPE_NORMAL
- en: The properties and behaviors are different for each QML type. They are used
    based on the GUI requirement. If you would like to know more about QML types,
    you can refer to their respective documentation. Let's explore Models in Qt Quick
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Models in Qt Quick
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qt provides several convenience QML types to implement the M/V pattern. The
    modules provide very simple Models without requiring the creation of custom Model
    classes in C++. Examples of such convenience classes are `ListModel`, `TableModel`,
    and `XmlListModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `QtQml.Models` module provides the following QML types for defining data
    Models:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ListModel` defines a free-form list data source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListElement` defines a data item in a `ListModel`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DelegateModel` encapsulates a Model and delegate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DelegateModelGroup` encapsulates a filtered set of visual data items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ItemSelectionModel` inherits `QItemSelectionModel` and it keeps track of a
    View''s selected items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ObjectModel` defines a set of items to be used as a Model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Instantiator` dynamically instantiates objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Package` describes a collection of named items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use the aforementioned QML types in your Qt Quick application, import the
    module with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import QtQml.Models`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss the readymade Models available in Qt Quick. `ListModel` is a
    simple container of `ListElement` definitions that contain data roles. It is used
    with `ListView`. `Qt.labs.qmlmodels` provides experimental QML types for models.
    These Models can be used for quick prototyping and displaying very simple data.
    The `TableModel` type stores JavaScript/JSON objects as data for a table Model
    and uses it with `TableView`. You can use these experimental types by importing
    the module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import Qt.labs.qmlmodels`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to create a Model from XML data, then you can use `XmlListModel`.
    It can be used as a Model with Views such as `ListView`, `PathView`, and `GridView`.
    To use this Model, you have to import the module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import QtQuick.XmlListModel`'
  prefs: []
  type: TYPE_NORMAL
- en: You can use `ListModel` and `XmlListModel` with `TableView` to create one column
    in `TableView`. To handle multiple rows and columns, you can use `TableModel`
    or you can create a custom C++ Model by subclassing `QAbstractItemModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use `Repeater` with Models. An integer can be used as a Model
    that defines the number of items. In that case, the Model does not have any data
    roles. Let''s create a simple example that uses `ListView` and a `Text` item as
    delegate components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have used an `Text` as a delegate without using
    a component.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's explore how to use `ListModel` with `ListView`. `ListModel` is a
    simple hierarchy of types specified in QML. The available roles are specified
    by the `ListElement` properties. Let's create a simple application using `ListModel`
    with `ListView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you want to create a simple address book application. You may need
    a few fields for a contact. In the following code snippet, we have used a `ListModel`
    that contains the names, phone numbers, and email addresses of some contacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now created the Model. Next, we have to display it using a delegate.
    So, let''s modify the delegate component we created earlier with three `Text`
    elements. Based on your need you can create complex delegate types with icons,
    texts, or custom types. You can add a highlighted item and update the background
    based on focus. You need to provide a delegate to a View to visually represent
    an item in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we used `ListElement` with `ListModel`. The View displays
    each item as per the template defined by the delegate. Items in a Model can be
    accessed through the `index` property or through the item's properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about different types of Models and how to manipulate Model
    data at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doc.qt.io/qt-6/qtquick-modelviewsdata-modelview.html](https://doc.qt.io/qt-6/qtquick-modelviewsdata-modelview.html)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about M/V in QML. You can experiment with the custom
    Models and delegates and create a personalized View. Have a look at your phone
    book or recent call list on your cellphone and try to implement it. In the next
    section, you will learn how to integrate the QML frontend with a C++ Model.
  prefs: []
  type: TYPE_NORMAL
- en: Using C++ Models with QML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have discussed how to use Models and Views in Qt Widgets and QML.
    But in most modern applications, you will require Models written in C++ and a
    frontend written in QML. Qt allows us to define Models in C++ and then access
    them inside QML. This is convenient for exposing existing C++ data Models or otherwise
    complex datasets to QML. Native C++ is always the right choice for complex logical
    operations. It can outperform logic written in QML with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: There are many reasons why you should create a C++ Model. C++ is type-safe and
    compiled into object code. It increases the stability of your application and
    reduces the number of bugs. It is flexible and can offer more features than the
    QML types. You can integrate with your existing code or with a third-party library
    that is written in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define a C++ Model using the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QStringList`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QVariantList`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QObjectList`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QAbstractItemModel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first three classes are beneficial for exposing simpler datasets. `QAbstractItemModel`
    offers a more flexible solution to create complex Models. `QStringList` contains
    a list of `QString` instances and provides the contents of the list via the `modelData`
    role. Similarly, `QVariantList` contains a list of `QVariant` types and provides
    the contents of the list via the `modelData` role. If a `QVariantList` changes,
    then you must reset the Model. `QObjectList` embeds a list of `QObject*` that
    provides the properties of the objects in the list as roles. The `QObject*` is
    accessible as the `modelData` property. For convenience, the properties of the
    object can be accessed directly in the delegate's context.
  prefs: []
  type: TYPE_NORMAL
- en: Qt also provides C++ classes to handle SQL data Model such as `QSqlQueryModel`,
    `QSqlTableModel`, and `QSqlRelationalTableModel`. `QSqlQueryModel` offers a read-only
    Model based on an SQL query. These classes reduce the need to run SQL queries
    for basic SQL operations such as insert, create, or update. These classes are
    derived from `QAbstractTableModel` and make it easy to present data from a database
    in a View class.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about different types of C++ Models by visiting the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doc.qt.io/qt-6/qtquick-modelviewsdata-cppmodels.html](https://doc.qt.io/qt-6/qtquick-modelviewsdata-cppmodels.html)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed C++ Models and why to use them. Now, you can fetch
    data from a C++ backend and present it in a UI developed in QML. In the next section,
    we will create a simple Qt Quick application using the aforementioned concept
    and explain how to use them inside QML.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple M/V application with Qt Quick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In earlier sections, we discussed Qt's Model-View-Delegate framework. You learned
    how to create a custom Model and delegate and how to use a C++ Model. But you
    must be wondering how to integrate with our QML frontend. In this section, we
    will create a C++ Model and expose it to the QML engine. We will also discuss
    how to register a custom Model as a QML type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an application that fetches a Model from the C++ code and displays
    it in a Qt Quick-based application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we have created a simple Model based on `QStringList`.
    The string list contains four different strings. We have exposed the Model to
    the QML engine using `setContextProperty()`. Now, let''s use the Model inside
    our QML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example uses `QQmlContext::setContextProperty()` to set Model
    values directly in a QML component. An alternative to this is to register the
    C++ Model class as a QML type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`qmlRegisterType<MyModel>("MyModel",1,0,"MyModel");`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding line will allow the Model classes to be created directly as QML
    types within QML files. The first field is the C++ class name, then comes the
    desired package name, then the version number, and the last parameter is the type
    name in QML. You can import it into your QML file with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Import MyModel 1.0`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an instance of `MyModel` inside our QML file as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use Models with `QQuickView` using `setInitialProperties()` as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we used `QQuickView` to create a UI and passed
    a custom C++ Model to the QML environment.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to integrate a simple C++ Model with QML. You
    can add signals and properties to extend the functionalities of your custom classes.
    Next, let's summarize our learnings in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a look at the core concepts of the Model-View-Delegate
    pattern in Qt. We explained how it is different from the traditional MVC pattern.
    We discussed different ways of using M/V and the convenience classes available
    in Qt. We learned how to apply the M/V concept in Qt Widgets as well as in Qt
    Quick. We discussed how to integrate a C++ Model with QML Views. We also created
    a few examples and implemented the concepts in our Qt application. You can now
    create your own Model, delegate, and Views. I hope you have understood the importance
    of the framework and the solid reasons for using it to meet your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B16231_08_Final_ASB_ePub.xhtml#_idTextAnchor176), *Graphics
    and Animations*, we will learn about the graphics framework and how to add animations
    to your Qt Quick project.
  prefs: []
  type: TYPE_NORMAL
