- en: Chapter 4. Modeling the Actors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now ready to dive head first into development, and we have a solid structure
    in place to help us deal with the arising changes that will come no matter what.
    It is time to think more about what the different components of our system are
    and how they interact.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Interaction in systems happens on multiple levels. The operating system interacts
    with the language runtime, the runtime interacts with our code, and then inside
    our code we create objects calling back out and calling other processes and so
    on. We have already seen how our domain objects can interact with the underlying
    framework and we can imagine how the code calls different libraries. When structuring
    interactions, it is important to know about the seams that exist and to create
    new ones where necessary. When calling other code, it is pretty clear where our
    code ends and where the library code starts. When we are creating code, it is
    easy to muddle responsibilities, but the better we can separate them, the better
    we can evolve our code in the future.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'Almost all aspects of computer science deal with interactions between different
    components in some way or other, and so multiple techniques exist to make sure
    those interactions work well. In this chapter, we are focusing on the actors of
    the system and their interactions, and will go into the details of:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Using object-oriented programming techniques to model domain actors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing domain objects in isolation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying and naming roles in the domain
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shoulders of giants
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the best known models of how interactions can be modeled and worked
    on is the **OSI**/**ISO** model that describes the interaction of layers in the
    networking stack. It comprises seven layers, each with a well-defined interface
    to be communicated with by the layer above, and to communicate with the layer
    below. Furthermore, each layer defines a protocol that allows it to communicate
    with a layer of the same level. With this in place, there is a very clear API
    to communicate with the layer and it is also clear how the layer can call back
    out to the system, therefore making it easy to replace parts of the system. The
    following diagram shows this how it is described in the OSI/ISO model. Each layer
    is defined by a protocol that allows instances on each side to communicate at
    their layer, as we move up the stack protocols are wrapped and unwrapped by the
    given instances:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '![The shoulders of giants](graphics/B03704_04_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
- en: This model has not been adopted across the board of course, with TCP/IP focusing
    on five layers, and it has even been stated that too much layering can be considered
    harmful. But even those who are not in favor of the OSI/ISO model consider the
    basic idea valuable, and isolating communication is one of the basics of making
    the Internet work, so to speak. Each layer is replaceable, be it completely or
    just for a specific case, which is a powerful thing to have in any system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Bringing this over to the world of modeling applications means that our objects
    should communicate at their layer in the business domain. In terms of domain-driven
    design, it is okay for an aggregate to interact with other aggregates to fulfill
    its purpose, but it is not okay for a service to reach into a entity without considering
    the aggregate. Reaching into different parts of an application without considering
    the appropriate APIs causes coupling two models together. In our dungeon, having
    a dungeon master of a foreign dungeon communicate directly with a prisoner is
    also a bad idea, marking the prisoner as a spy and getting him killed immediately,
    most likely. This not only causes problems due to tight coupling, but also opens
    the application up to security problems. There have been many instances of, for
    example, SQL injection attacks because a model accessing the database reached
    directly for the data passed in an HTTP request without a layer to mitigate the
    access.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Communication like this, where one object communicates with another part of
    the object graph, ignoring the gating interfaces, is a well understood problem
    and is solidified as the *Law of Demeter*, which states:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的通信，其中一个对象与对象图的另一部分进行通信，忽略了门控接口，这是一个众所周知的问题，并被确定为*迪米特法则*，该法则规定：
- en: '|   | *Each unit should have only limited knowledge about other units: only
    units "closely" related to the current unit.* |   |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|   | *每个单元应该只对其他单元有限的了解：只有与当前单元“密切”相关的单元。* |   |'
- en: '|   | --*Law of Demeter* |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|   | --*迪米特法则* |'
- en: 'Often this is paraphrased in object-oriented language to say that a method
    should only have one dot. Having a method like the following on the orc master
    for example, violates this. The following code shows implementing an accessor
    for the available weapons in a dungeon, by reaching far into the objects controlled
    by the dungeon and its descendants:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常这在面向对象的语言中被改述为一个方法只应该有一个点。例如，像兽人大师上的以下方法违反了这一点。以下代码显示了通过深入到地牢及其后代控制的对象中实现了一个获取地牢中可用武器的访问器：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this case, the orc master reaches each orc via its dungeon and asks it directly
    for the type of his weapon. This binds the orc master not only to the inner implementation
    of the dungeon, but also the orc and even the weapon itself; if any of those elements
    change, the method has to change as well. This not only makes the object itself
    harder to change, but the system overall is more rigid now and not as malleable
    under refactoring.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，兽人大师通过其地牢直接接触每个兽人，并直接询问他的武器类型。这不仅将兽人大师绑定到地牢的内部实现，还绑定到兽人甚至武器本身；如果这些元素中的任何一个发生变化，方法也必须发生变化。这不仅使对象本身更难以改变，而且整个系统现在更加僵化，在重构下不太灵活。
- en: 'Code like the preceding is imperative in its operation on the data structures,
    where object-oriented code focuses on a more declarative style to reduce the amount
    of coupling. Declarative means the code tells objects what needs to be done and
    lets them handle the operations needed to achieve the goal:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 像前面的代码一样，它在操作数据结构时是命令式的，而面向对象的代码则专注于更声明式的风格，以减少耦合的数量。声明式意味着代码告诉对象需要做什么，并让它们处理实现目标所需的操作：
- en: '|   | *Procedural code gets information then makes decisions. Object-oriented
    code tells objects to do things.* |   |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|   | *过程式代码获取信息然后做决定。面向对象的代码告诉对象要做事情。* |   |'
- en: '|   | --*Alec Sharp* |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|   | --*Alec Sharp* |'
- en: Communication should not cross boundaries randomly, but in a well-defined and
    reasonable way to keep software malleable. This also means that when developing
    software, we need to be aware of the components and interfaces, identifying them
    as we have done already, and be aware as new ones arise from the code we are writing.
    The same is true for commands and events that represent messages being sent in
    our domain.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通信不应该随意跨越边界，而应该以明确定义和合理的方式保持软件的可塑性。这也意味着在开发软件时，我们需要意识到组件和接口，像我们已经做过的那样识别它们，并意识到新的组件和接口从我们正在编写的代码中出现。对于在我们的领域中发送的命令和事件代表的消息也是如此。
- en: Even when thinking about the software under development very intensively beforehand
    and drawing diagrams like we have done, it is almost inevitable you'll miss certain
    abstractions that become clear when development has started. The code and the
    test we write should make the interfaces clear, and to take advantage of this
    fact a common way is to exercise the code under development as early as possible,
    and let it "tell" you about its dependents.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在非常集中地思考正在开发的软件并绘制像我们已经做过的那样的图表时，几乎不可避免地会错过某些在开发开始时变得清晰的抽象。我们编写的代码和测试应该使接口清晰，并利用这一事实的一种常见方式是尽早执行正在开发的代码，并让它“告诉”你关于它的依赖项。
- en: The Different approaches to development
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发的不同方法
- en: 'Now that we are writing the code to solve problems in our domain, we can approach
    problems in different ways: one way is to start at the topmost level we have so
    far discovered and let this guide us down to our lower level objects and abstractions,
    or we can start with the components we identified, flush them out and build up
    the system. Both approaches are valid and are commonly referred to as "outside-in"
    or "inside-out" development. The advantage of inside-out is that we always have
    a running working system because we build the dependents first and build up the
    system. The disadvantage being that it is easier to lose sight of the bigger picture
    and get lost in the details.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在编写代码来解决领域中的问题，我们可以以不同的方式来解决问题：一种方式是从我们迄今为止发现的最高级别开始，让这指导我们下到我们的较低级别对象和抽象，或者我们可以从我们识别的组件开始，完善它们并建立系统。这两种方法都是有效的，通常被称为“自外向内”或“自内向外”开发。自内向外的优势在于我们始终有一个运行的工作系统，因为我们首先构建依赖项并建立系统。缺点是很容易失去对整体情况的视野，并在细节中迷失方向。
- en: What is common to the approaches is that they follow a style based on test-driven
    development. We are building the tests to let us guide the design and show us
    when we are done. We start using our code first to get a feel for how it would
    behave later, and implement what we think the behavior should be. This can be
    done by first focusing on the small, easier to grasp components to gain confidence
    in them, as it is done in the *inside-out* approach. Another way to approach it
    is to ask the big questions at the start, drilling down into more detail as we
    move along, as in the *outside-in* approach.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的共同之处在于它们遵循基于测试驱动开发的风格。我们正在构建测试来指导设计，并在完成时向我们展示。我们首先使用我们的代码来感受它以后的行为，并实现我们认为行为应该是什么。这可以通过首先专注于小而容易理解的组件来获得对它们的信心，就像*自内向外*方法中所做的那样。另一种方法是在开始时提出重要问题，随着我们的深入，逐渐进入更多细节，就像*自外向内*方法中所做的那样。
- en: For this project, it feels more appropriate to start on the outside because
    we explored and got a feel for what the stakeholders want, but are not so clear
    about the exact components and their behavior; after all we are in a world we
    are not entirely familiar with. Especially in an unfamiliar world, we are very
    prone to start building pieces we never needed. Right now we don't know a lot
    about the messaging system between dungeons for example. We could start trying
    to build an abstraction here and allow us to control as much as possible, but,
    on the other hand, it might turn out that we only send one message a week and
    having this pop up on the dungeon master's screen to have him do it by hand is
    perfectly reasonable. In these kinds of evaluations, we have to keep in mind that
    our overarching goal should always be to deliver value and save money, and that
    can mean *not* building things. So how can we go about creating software without
    the underlying structure being in place?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Introducing mocks
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When trying to model a system from the outside in, there is a need have objects
    stand in for what is eventually going to be the lower level implementation. This
    happens on every level and the concept of modeling the API first trickles down
    to the lower layers. We previously started building the prisoner transfer service,
    with dependency being on the prisoner and a dungeon; those again will have dependents
    that, when flushing out the objects, will need to be designed in similar ways.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The objects that enable this are called **mocks**; they are objects that provide
    a static implementation of a certain concept and can assert that they are called
    correctly. Mocks implement the protocol a certain object should follow. In a dynamic
    language, such as JavaScript, this is both easy and hard. Different JavaScript
    testing frameworks approach this differently; some use mock objects as described,
    while some provide spies that call through to the real object but monitor those
    calls for correctness. Both approaches work well and there are advantages to each.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on spies can be found at [http://derickbailey.com/2014/04/23/mock-objects-in-nodejs-tests-with-jasmine-spies/](http://derickbailey.com/2014/04/23/mock-objects-in-nodejs-tests-with-jasmine-spies/).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a mock can be a simple as:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Even though this is not a very advanced mock, it contains what we need. This
    object can now stand in for anything that requires the specific API of providing
    a function called `aFunction`. It is also possible to check whether a function
    has been called by checking the called variable after the test has been run. These
    checks can be done with the `assert` library provided directly by the runtime
    without the need for additional testing frameworks. In the following code, we
    use our very simple mock we created above to assert that a function is indeed
    called at a given time:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, we use the `Object.create` method to create a new instance of
    our `myMock` object, exercise it, and verify it worked correctly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'How to create mock objects is quite specific to the circumstances when they
    are needed and multiple libraries implement their creation. One library that is
    quite commonly used is **Sinon.JS,** and it provides many different ways to verify
    functionality, implement stubs, mocks, and spies. Combined with Mocha as our testing
    framework, we can create a mock test by creating the object we want to mock and
    letting Sinon.JS mock due the heavy lifting of verification for us. We can now
    describe the behavior of the API in very readable terms, using the combined features
    of Mocha to provide the behavioral descriptions and Sinon.JS to provide advanced
    mocking and verification. Here''s an example of this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The concept of a mock on the surface is quite simple, but its usage can be difficult
    as it can be hard to discover where the right place for a mock actually is.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on mocks, visit [http://www.mockobjects.com/2009/09/brief-history-of-mock-objects.html](http://www.mockobjects.com/2009/09/brief-history-of-mock-objects.html).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Why and why not to mock
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|   | *Our initial description had focused too much on implementation, the
    critical idea was that the technique emphasizes the roles that objects play for
    each other.* |   |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '|   | --*A Brief History of Mock Objects – Steve Freeman* |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: Mock objects stand in for other objects in a system during testing, and sometimes
    even during development. There are multiple reasons to do this, for example, the
    underlying structure is not implemented yet, or the call would be really expensive
    both in a cost of time during development or even in money calling to an API that
    charges by the amount of calls. For developers it can be very convenient to be
    able to run the tests offline as well, and there are more reasons why somebody
    would want to not call the real system but something in its place.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: This kind of practice is normally referred to as **stubbing out** an external
    dependency. When combined with making assertions about this dependency, this stub
    becomes a mock, which is often helpful during development to ensure that some
    code is called correctly, at the right time and, of course, when testing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: It is very easy to fall into the trap of creating very specific mock objects,
    mocking inner dependencies of other objects, and so forth. The important thing
    to keep in mind is that a mock should always represent a role in the system. Various
    other objects in the real world can play this role, but they can be represented
    in one mock. In classical object-oriented terms, this would mean that we are mocking
    interfaces not classes. In JavaScript, there are no interfaces so we need to select
    the right objects to mock. The object, or part of the object that is our mock,
    needs to only represent what is essential to the test, and nothing more. This
    comes naturally when we drive our design through tests, but we need to keep an
    eye on this as the software evolves and changes, as changes might result in our
    tests overspecifying an object through a mock.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Who is involved in the prisoner transfer?
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous sections, we did a lot of exploring in the domain to get a
    view of what has to be done to make actions in the system happen. With this knowledge,
    we can now get a clear-cut concept of how a prisoner transfer should happen. The
    tests we created earlier specify some behavior and collaborators we are aware
    of in the domain. We represent them as basic JavaScript objects that contain the
    properties necessary to satisfy the tests; we, for example, know that a dungeon
    needs a message inbox to be notified, but we don''t know any properties for the
    prisoner yet. The following code provides some simple functions to let us describe
    the type of object we are using, as the code grows and our knowledge of what makes
    a prisoner or a dungeon gets solidified we can fill those out to continue to be
    stand-ins for the respective objects during our tests:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So far, the prisoner as well as the dungeon are specific JavaScript objects
    created just to represent what we need at this moment. Looking further into the
    details, other actors are involved as well, namely the orc guarding the prisoner
    along the way, as well as the transfer carriage. Of course, those again have dependencies:
    the carriage consists of the driver, the wooden carriage working as a mobile cell
    for the prisoner, as well as the horses that pull it. All those pieces are potentially
    scarce resources that we need to acquire. Here is where domain modeling comes
    in again; in the context of our application we can stay away from looking at them
    as separate things because if either is missing the whole object won''t be able
    to function. We can focus on which roles the different objects play and acquire
    them as aggregates where it fits our model.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Different objects and their roles
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The carriage is one of those described roles; we do not care at this moment
    what the carriage consists of but treat it as one thing that fulfills some purpose
    in our system. The carriage as a whole is an aggregate we only want to inspect
    from the outside for now and don't care much about its internals. Right there,
    the carriages public API shows a seam that that we need to account for when we
    model. We might care about horses being a separate thing later, for example, to
    model a messenger where we want to allocate horses for both carriages as well
    as messengers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: An aggregate is not a way to limit the share ability of resources but a concept
    to make dealing with the comprised object less complex. It does not change the
    fact that a carriage without horses is useless, and that something else also might
    need to acquire horses as a resource. The carriage is a role in our system. It
    provides a public API and takes care of its own internal data and dependencies.
    It is an aggregate in itself on a smaller scale.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The idea to discover such seams is a fundamental idea when it comes to building
    systems using mocks and stubs. By mocking out roles in the system, we can interact
    with the role before it really exists and explore its functionality without being
    hampered by the internal implementation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Naming objects according to the domain
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *There are only two hard things in Computer Science: cache invalidation
    and naming things.* |   |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '|   | --*Phil Karlton* |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: When exploring roles in a domain, the most complicated thing is most often the
    fact that we need to name the role that we try to establish in the system. When
    we are able to name a thing, we can naturally associate it with the role it plays
    in a system. When building a software system and being able to point out the roles
    by giving them concrete names, we make it easy for every developer working on
    the system to know where to put functionality related to the part they need to
    work on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we introduced the concept of a carriage, comprising the cart itself,
    horses to tow it, and a driver. This is one example of naming a concept according
    to the domain. In the world of the orc dungeons, the concept of a carriage is
    very clear, and what is needed to run it is very clear. By using the language
    of the stakeholders in the system, we are increasing the teams' language and enabling
    all the stakeholders to participate. We saw this before when identifying the parts
    of the domain; we now make sure we continue to increase the language while creating
    abstractions. This allows us to hide certain details behind a common role.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The traps of common names like *Manager
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The carriage we introduced a concept, well known in the domain, is a good abstraction
    to have; as software developers, however, we are prone to keep reusing elements
    we have seen before in other applications. When naming roles, it is very easy
    to fall into a pattern of naming. Very often, we see `Manager` objects that really
    only exist for the lack of a better name about the role they fulfill:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Even though this object fulfills the same responsibility as the object we named
    `carriage` before, finding out what it does is no longer obvious by the name.
    Even though it is clear to the developers on the team what this object is meant
    to do, the other stakeholders will be confused. This drives a separation in the
    team and will not foster involvement in the development process by non-developers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Naming an object as a manager often means naming it after what it does at this
    moment instead of the role it fulfills in the system in general. Naming an object
    this way makes it hard to abstract away the details within it. To know what a
    `Manager` object does always means knowing what it is managing and how its internal
    details work to make sense of it. The abstraction leaks to other parts of the
    system, and everybody using the manager will look into the parts it is managing
    and the details.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: The pain of manager objects often becomes very clear in the context of writing
    tests. When we want to test a manager and we don't see a clear abstraction, we
    need to care about the internal dependencies and therefore need to hold on to
    them in our tests. This makes tests look complicated and the setup starts to trump
    the actual assertion part. With objects named after generic roles, we get objects
    serving the purpose of very generic roles and therefore move away from domain-specific
    objects. This can cause pain as those generic objects are only made specific by
    their internal implementation, and therefore are bad representatives of the role
    they are supposed to play.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 管理对象的痛苦在编写测试的情境中往往变得非常明显。当我们想要测试一个管理器，而我们看不到一个清晰的抽象时，我们需要关心内部依赖关系，因此需要在我们的测试中保持它们。这使得测试看起来复杂，设置开始超过实际的断言部分。通过以通用角色命名的对象，我们得到了为非常通用的角色提供服务的对象，因此远离了特定于领域的对象。这可能会带来痛苦，因为这些通用对象只能通过其内部实现来具体化，因此它们是应该扮演的角色的不良代表。
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When you have trouble coming up with a name for an object, try naming it something
    obviously silly first and let the exploration of the domain guide you to a more
    specific and meaningful name.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在为一个对象想不出名字时，试着先给它取一个明显愚蠢的名字，然后让对领域的探索引导你找到一个更具体和有意义的名字。
- en: Readability of method names
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法名的可读性
- en: 'In **Object-oriented Programming** (**OOP**), an object holds data and is responsible
    for the actions most closely related to the data it holds. Functions operating
    on the data, such as computing new data from the internal state of the object,
    are called queries. Examples for such a function are ones that compute compound
    data, like the full name of an orc from its set first name and last name:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在**面向对象编程**（**OOP**）中，对象保存数据，并负责与其保存的数据最密切相关的操作。操作数据的函数，如从对象的内部状态计算新数据的函数，称为查询。这样的函数的例子是计算复合数据的函数，例如根据其设置的名和姓计算兽人的全名：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On the other hand, if an object is not immutable, there need to be functions
    to modify its internal state. Functions that change the internal state of an object
    are called commands; they allow external objects to send commands to the object
    to change its behavior. The following is an example of this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果对象不是不可变的，就需要有函数来修改其内部状态。改变对象内部状态的函数称为命令；它们允许外部对象向对象发送命令以改变其行为。以下是一个例子：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As commands change their internal state, it needs to be very clear what is happening
    and the object should have as much control as possible over what to actually do
    in the case of the command, so the command tells the object what to do and does
    not ask it for its state to modify it. Making this happen means we want to instruct
    the object to accomplish a task, without inspecting its properties. The opposite
    is checking object properties and based on those, making a decision in place of
    the object responsible for the properties. The *Tell, Don't Ask* principle is
    an important principle of OOP. The preceding example follows this concept, by
    not creating a setter to *attack* the property, we make sure the `Orc` object
    is in control of its internal state. Making domain-specific commands read like
    what they do, instead of creating an extensive amount of setter/getter methods,
    helps readability as well as making sure that the state is well managed. In object
    orientation, we want the object to be responsible for its state and the methods
    that operate on that state.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 随着命令改变其内部状态，需要非常清楚地知道发生了什么，并且对象应尽可能多地控制在命令的情况下实际要做什么，因此命令告诉对象要做什么，而不是询问它的状态以修改它。实现这一点意味着我们希望指示对象完成任务，而不是检查其属性。相反的是检查对象属性，并基于这些属性做出决定，代替负责属性的对象。*告诉，不要问*原则是面向对象编程的重要原则。前面的例子遵循了这个概念，通过不创建一个setter来*attack*属性，我们确保`Orc`对象控制其内部状态。使特定于域的命令读起来像它们所做的那样，而不是创建大量的setter/getter方法，有助于可读性，同时确保状态得到良好管理。在面向对象的方法中，我们希望对象负责其状态和操作该状态的方法。
- en: Not only are the objects part of a consistent naming scheme that allows us to
    model the domain. When we are modeling functionality and we want it to read clearly,
    we need to make the method names readable as well. In the previous example, the
    `TransportManager` only method is `initializeTransport` and it more or less repeats
    the name of the object. This pattern is very common when objects are `Managers`
    or `Executors`, or alike, but it does not help readability. This is the same trap
    as creating setters that are called outside the context of setting a value to
    initialize the object. The method needs to tell what the command does.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对象不仅是一致命名方案的一部分，允许我们对领域进行建模。当我们在建模功能时，希望它读起来清晰，我们还需要使方法名可读。在前面的例子中，`TransportManager`的唯一方法是`initializeTransport`，它或多或少地重复了对象的名称。当对象是`Managers`或`Executors`等时，这种模式非常常见，但它并不有助于可读性。这与创建在设置对象的上下文之外调用的setter方法一样。方法需要告诉命令做什么。
- en: An object named after a role in the system allows much better readability of
    methods. The domain name `Carriage` makes the method name `transport` much more
    understandable because it comes naturally with the concept of a carriage in the
    domain.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个以系统中的角色命名的对象可以更好地提高方法的可读性。域名`Carriage`使方法名`transport`更容易理解，因为它自然地与领域中的马车概念联系在一起。
- en: With all this, it now comes the point where we need to think about how we model
    the objects to ease testing as well as development.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一切，现在到了我们需要考虑如何对对象进行建模以便于测试和开发的时候了。
- en: Objects first
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首先是对象
- en: When building the dungeon manager, we set out to create a maintainable and evolvable
    piece of software. The core principles of OOP are there to help us out when dealing
    with objects, but JavaScript is special when it comes to object orientation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建地牢管理器时，我们致力于创建一个易于维护和可扩展的软件。面向对象编程的核心原则在处理对象时有助于我们，但是当涉及到面向对象编程时，JavaScript是特殊的。
- en: As many JavaScript programmers will most certainly have heard, JavaScript uses
    prototypical inheritance and, more importantly, has not really got a concept of
    classes, only instances.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though the next version of JavaScript, **ECMAScript 6**, introduces the
    class `keyword`, the core language design does not change. Classes are really
    just syntactic sugar over the prototypical inheritance present in JavaScript right
    now. If you want to know more about ES6, follow the blog [http://www.2ality.com/](http://www.2ality.com/)
    by Alex Rauschmayer, who describes and follows the evolving JavaScript language
    closely.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this does not make JavaScript the worst language to perform the task
    we are trying to achieve because this lack does not limit the power of the language
    in any way, but really makes it a superset of classical object-oriented languages.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Let's first do a quick recap of how object orientation works in JavaScript and
    how we can use the power of the language to help us out in modeling the system
    that we have been drafting out so far.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: The basics of objects in JavaScript
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Object-oriented languages such as Ruby or even Java, objects are based on
    classes. Even though it might be possible to create a plain object, it is not
    the norm. Taking Ruby as an example to create an object with a method like our
    carriage, you would write something like:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In JavaScript, for very simple objects and also, very importantly, for the
    tests, we don''t need to have a class first to have an object like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code will do the same thing without the necessity of creating
    a class along with the object first. This can be very powerful especially when
    modeling a new API, because it allows very lightweight usage and generation during
    this phase of development.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the availability of plain objects that are constructed via `{}`, JavaScript
    allows functions to be used as objects. Using functions as object constructors
    means very much the same flexibility as classes in classical object orientation
    would. Functions in JavaScript are objects that encapsulate their internal state
    and the state of any variables they reference at the time of their creation from
    the outside world. Due to those properties, functions in JavaScript are the basic
    building blocks to be used to create objects, and special support via the keyword
    `new` is part of the language:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This looks a lot like the Ruby code and behaves very similarly to it. Constructors
    are a special beast in JavaScript and much has been written about their usage
    or non-usage. In a lot of cases, the idea of a class of objects being related
    by common functionality is a good idiom to use, and modern JavaScript engines
    were built with this is mind. So don't fear constructors, but be aware of their
    special use of the keyword `new` and the confusion they might cause around new
    developers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A lot has been written about the problems with `new` in JavaScript. For more
    information and the best information about the internals of JavaScript as a language,
    read *JavaScript: The Good Parts*, *Douglas Crockford*, *O''Reilly*.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance and why you won't need it
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, just the construction of classes and their usage is only a part of
    being an OO (object-oriented) language. Especially in Java, it is very common
    to build quite complex inheritance hierarchies that allow common functionality
    to be shared across objects.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The basic concept of inheritance is that all the methods of the parent are also
    available on the child.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Modeling patterns beyond inheritance
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|   | *Favor ''object composition'' over ''class inheritance''.* |   |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '|   | --*Gang of Four 1995:20* |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: Even though inheritance is possible in JavaScript, it is not necessarily the
    best route to go down for designing when an application like it is stated in the
    *Gang of Four*. Inheritance creates a very strong bond between the parent class
    and its children; this in itself means a leak of knowledge in parts of the system
    that it should not. Inheritance is the strongest possible form of coupling between
    two objects, and coupling itself should always be a very deliberate choice. Deep
    inheritance trees quickly make a piece of software very resistant to change as
    the changes tend to ripple through the whole system. There is a bigger problem
    so as well—as JavaScript does not do compile time checking of the interface and
    relationships, it is easier for those parts to get out of sync, and cause bugs
    in the system, than in more static languages.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: For those reasons, and also due to the fact that classical inheritance is rarely
    needed in a dynamic language like JavaScript, inheritance is almost never used.
    There are other patterns that have been hinted at already to counter the need
    for inheritance.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The object composition
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What can we do when we don''t want to share functionality via inheritance?
    The easiest way to go is to pass the object that already implements the functionality
    we need and use it directly, for example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A notification is a very simple object that manages the notifications for a
    part of the system; it does not concern itself greatly with how notifications
    are saved for later processing but simply delegates this to a store object that
    by default is implemented as an array.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Delegating to native types is normally done a lot, but this for all other objects
    that are created by the programmer. Composition like this has the big advantage
    that it eases testing especially when the dependencies are passed in, like in
    the example just given, we can simply replace the store object in our tests with
    something that ensures the right calls have been made.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism without inheritance
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '|   | *When I see a bird that walks like a duck and swims like a duck and quacks
    like a duck, I call that bird a duck.* |   |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '|   | --*Michael Heim* |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: 'Another reason for inheritance in languages such as Java is the need for polymorphism.
    The idea is that a method should be implemented differently in different objects.
    In classical inheritance combined with type checking, this means that the objects
    on which the method is called need to have a common ancestor or interface because
    the type checker will complain otherwise:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we can pass both a `SwordMaster` class or an `AxeMaster` class to somebody
    in need in order for an orc to guard them:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This kind of overhead is not needed in a language that supports duck typing.
    In JavaScript, we can just write this without the need for an interface, both
    orcs can just be plain JavaScript objects, as shown in the following example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `Master` object being guarded can now just call the method needed on each
    guard without the need for a matching type:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Duck typing means that an object is defined by what it can do rather than what
    it is. We already saw this behavior when building our own very simple mocks. As
    long as the method is defined on the object, it doesn't matter what its type is
    when we call it, so there is really no need to have a common ancestor.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Due to the very dynamic nature of JavaScript and the availability of duck typing,
    the need for inheritance is very much obviated.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Applying object design to the domain
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With an understanding of conceptual object design, we need to apply all the
    concepts to our domain. We continue modeling the prisoner transfer we started.
    So far, we have an entry point to the application module that will ultimately
    handle this. From the tests, we know that the prisoner transfer relies on a prisoner
    and a dungeon object.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Building a system on simple objects
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So let's walk through what the prisoner transfer needs to do and what its collaborators
    are. Previously, we identified that the prisoner transfer will need a prisoner,
    obviously, and a target dungeon to transfer to, and the prisoner transfer should
    manage everything else. It is important to think about what the minimal input
    is from a user perspective to limit the API surface.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Of course the prisoner transfer, which is a service in DDD speak, needs more
    collaborators to really fulfill its purpose. First is a reference to the local
    dungeon to acquire resources such as orcs to act as keepers, carriages to move
    the prisoner, and possibly more. A goal of a managed transfer is also to notify
    the other dungeon, so we also need the means to notify them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'As we found out in the previous chapters, the concept of notifications is not
    well understood yet, so for now we can assume that there will be a service that
    allows us to send a message to a target, for a specific reason. We can program
    against the abstraction of a messaging service, allowing us to further specify
    what we are going to need out of the system. Bringing all this together and flushing
    it out brings us to the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'All calls are just simple calls to objects that can have a stand-in of a simple
    plain JavaScript object during the tests:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Returning plain objects with the functionality needed, which we will ultimately
    make their own modules based on the design being mocked up now, is all there is
    to creating the roles of the collaborators:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This top-level design really brings us along the way to create the underlying
    functionality. We can already see very clearly what we need from a notification
    system, and flushing out the transfer itself to perform its duties will tell us
    a lot more about the other collaborators as well.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you have a solid foundation on how we can model
    the prisoner transfer inside the system. We used a very simple design with the
    least amount of tooling overhead possible. Our system leverages the dynamic nature
    of JavaScript to create simple stubs for objects we haven't created, yet, and
    we were able to validate the first understanding we discussed in our previous
    research.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to further explore the other roles in the
    system. We focus on classifying them in domain-driven design terms so we can reuse
    the patterns explored by others in the space. We are also going to focus more
    on the language to foster further communication and how it can work with those
    patterns to allow very clear communication in the domain.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
