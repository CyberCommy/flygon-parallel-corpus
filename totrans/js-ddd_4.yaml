- en: Chapter 4. Modeling the Actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now ready to dive head first into development, and we have a solid structure
    in place to help us deal with the arising changes that will come no matter what.
    It is time to think more about what the different components of our system are
    and how they interact.
  prefs: []
  type: TYPE_NORMAL
- en: Interaction in systems happens on multiple levels. The operating system interacts
    with the language runtime, the runtime interacts with our code, and then inside
    our code we create objects calling back out and calling other processes and so
    on. We have already seen how our domain objects can interact with the underlying
    framework and we can imagine how the code calls different libraries. When structuring
    interactions, it is important to know about the seams that exist and to create
    new ones where necessary. When calling other code, it is pretty clear where our
    code ends and where the library code starts. When we are creating code, it is
    easy to muddle responsibilities, but the better we can separate them, the better
    we can evolve our code in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Almost all aspects of computer science deal with interactions between different
    components in some way or other, and so multiple techniques exist to make sure
    those interactions work well. In this chapter, we are focusing on the actors of
    the system and their interactions, and will go into the details of:'
  prefs: []
  type: TYPE_NORMAL
- en: Using object-oriented programming techniques to model domain actors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing domain objects in isolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying and naming roles in the domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shoulders of giants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the best known models of how interactions can be modeled and worked
    on is the **OSI**/**ISO** model that describes the interaction of layers in the
    networking stack. It comprises seven layers, each with a well-defined interface
    to be communicated with by the layer above, and to communicate with the layer
    below. Furthermore, each layer defines a protocol that allows it to communicate
    with a layer of the same level. With this in place, there is a very clear API
    to communicate with the layer and it is also clear how the layer can call back
    out to the system, therefore making it easy to replace parts of the system. The
    following diagram shows this how it is described in the OSI/ISO model. Each layer
    is defined by a protocol that allows instances on each side to communicate at
    their layer, as we move up the stack protocols are wrapped and unwrapped by the
    given instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The shoulders of giants](graphics/B03704_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This model has not been adopted across the board of course, with TCP/IP focusing
    on five layers, and it has even been stated that too much layering can be considered
    harmful. But even those who are not in favor of the OSI/ISO model consider the
    basic idea valuable, and isolating communication is one of the basics of making
    the Internet work, so to speak. Each layer is replaceable, be it completely or
    just for a specific case, which is a powerful thing to have in any system.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing this over to the world of modeling applications means that our objects
    should communicate at their layer in the business domain. In terms of domain-driven
    design, it is okay for an aggregate to interact with other aggregates to fulfill
    its purpose, but it is not okay for a service to reach into a entity without considering
    the aggregate. Reaching into different parts of an application without considering
    the appropriate APIs causes coupling two models together. In our dungeon, having
    a dungeon master of a foreign dungeon communicate directly with a prisoner is
    also a bad idea, marking the prisoner as a spy and getting him killed immediately,
    most likely. This not only causes problems due to tight coupling, but also opens
    the application up to security problems. There have been many instances of, for
    example, SQL injection attacks because a model accessing the database reached
    directly for the data passed in an HTTP request without a layer to mitigate the
    access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Communication like this, where one object communicates with another part of
    the object graph, ignoring the gating interfaces, is a well understood problem
    and is solidified as the *Law of Demeter*, which states:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *Each unit should have only limited knowledge about other units: only
    units "closely" related to the current unit.* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Law of Demeter* |'
  prefs: []
  type: TYPE_TB
- en: 'Often this is paraphrased in object-oriented language to say that a method
    should only have one dot. Having a method like the following on the orc master
    for example, violates this. The following code shows implementing an accessor
    for the available weapons in a dungeon, by reaching far into the objects controlled
    by the dungeon and its descendants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the orc master reaches each orc via its dungeon and asks it directly
    for the type of his weapon. This binds the orc master not only to the inner implementation
    of the dungeon, but also the orc and even the weapon itself; if any of those elements
    change, the method has to change as well. This not only makes the object itself
    harder to change, but the system overall is more rigid now and not as malleable
    under refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code like the preceding is imperative in its operation on the data structures,
    where object-oriented code focuses on a more declarative style to reduce the amount
    of coupling. Declarative means the code tells objects what needs to be done and
    lets them handle the operations needed to achieve the goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *Procedural code gets information then makes decisions. Object-oriented
    code tells objects to do things.* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Alec Sharp* |'
  prefs: []
  type: TYPE_TB
- en: Communication should not cross boundaries randomly, but in a well-defined and
    reasonable way to keep software malleable. This also means that when developing
    software, we need to be aware of the components and interfaces, identifying them
    as we have done already, and be aware as new ones arise from the code we are writing.
    The same is true for commands and events that represent messages being sent in
    our domain.
  prefs: []
  type: TYPE_NORMAL
- en: Even when thinking about the software under development very intensively beforehand
    and drawing diagrams like we have done, it is almost inevitable you'll miss certain
    abstractions that become clear when development has started. The code and the
    test we write should make the interfaces clear, and to take advantage of this
    fact a common way is to exercise the code under development as early as possible,
    and let it "tell" you about its dependents.
  prefs: []
  type: TYPE_NORMAL
- en: The Different approaches to development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are writing the code to solve problems in our domain, we can approach
    problems in different ways: one way is to start at the topmost level we have so
    far discovered and let this guide us down to our lower level objects and abstractions,
    or we can start with the components we identified, flush them out and build up
    the system. Both approaches are valid and are commonly referred to as "outside-in"
    or "inside-out" development. The advantage of inside-out is that we always have
    a running working system because we build the dependents first and build up the
    system. The disadvantage being that it is easier to lose sight of the bigger picture
    and get lost in the details.'
  prefs: []
  type: TYPE_NORMAL
- en: What is common to the approaches is that they follow a style based on test-driven
    development. We are building the tests to let us guide the design and show us
    when we are done. We start using our code first to get a feel for how it would
    behave later, and implement what we think the behavior should be. This can be
    done by first focusing on the small, easier to grasp components to gain confidence
    in them, as it is done in the *inside-out* approach. Another way to approach it
    is to ask the big questions at the start, drilling down into more detail as we
    move along, as in the *outside-in* approach.
  prefs: []
  type: TYPE_NORMAL
- en: For this project, it feels more appropriate to start on the outside because
    we explored and got a feel for what the stakeholders want, but are not so clear
    about the exact components and their behavior; after all we are in a world we
    are not entirely familiar with. Especially in an unfamiliar world, we are very
    prone to start building pieces we never needed. Right now we don't know a lot
    about the messaging system between dungeons for example. We could start trying
    to build an abstraction here and allow us to control as much as possible, but,
    on the other hand, it might turn out that we only send one message a week and
    having this pop up on the dungeon master's screen to have him do it by hand is
    perfectly reasonable. In these kinds of evaluations, we have to keep in mind that
    our overarching goal should always be to deliver value and save money, and that
    can mean *not* building things. So how can we go about creating software without
    the underlying structure being in place?
  prefs: []
  type: TYPE_NORMAL
- en: Introducing mocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When trying to model a system from the outside in, there is a need have objects
    stand in for what is eventually going to be the lower level implementation. This
    happens on every level and the concept of modeling the API first trickles down
    to the lower layers. We previously started building the prisoner transfer service,
    with dependency being on the prisoner and a dungeon; those again will have dependents
    that, when flushing out the objects, will need to be designed in similar ways.
  prefs: []
  type: TYPE_NORMAL
- en: The objects that enable this are called **mocks**; they are objects that provide
    a static implementation of a certain concept and can assert that they are called
    correctly. Mocks implement the protocol a certain object should follow. In a dynamic
    language, such as JavaScript, this is both easy and hard. Different JavaScript
    testing frameworks approach this differently; some use mock objects as described,
    while some provide spies that call through to the real object but monitor those
    calls for correctness. Both approaches work well and there are advantages to each.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on spies can be found at [http://derickbailey.com/2014/04/23/mock-objects-in-nodejs-tests-with-jasmine-spies/](http://derickbailey.com/2014/04/23/mock-objects-in-nodejs-tests-with-jasmine-spies/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a mock can be a simple as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though this is not a very advanced mock, it contains what we need. This
    object can now stand in for anything that requires the specific API of providing
    a function called `aFunction`. It is also possible to check whether a function
    has been called by checking the called variable after the test has been run. These
    checks can be done with the `assert` library provided directly by the runtime
    without the need for additional testing frameworks. In the following code, we
    use our very simple mock we created above to assert that a function is indeed
    called at a given time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we use the `Object.create` method to create a new instance of
    our `myMock` object, exercise it, and verify it worked correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'How to create mock objects is quite specific to the circumstances when they
    are needed and multiple libraries implement their creation. One library that is
    quite commonly used is **Sinon.JS,** and it provides many different ways to verify
    functionality, implement stubs, mocks, and spies. Combined with Mocha as our testing
    framework, we can create a mock test by creating the object we want to mock and
    letting Sinon.JS mock due the heavy lifting of verification for us. We can now
    describe the behavior of the API in very readable terms, using the combined features
    of Mocha to provide the behavioral descriptions and Sinon.JS to provide advanced
    mocking and verification. Here''s an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The concept of a mock on the surface is quite simple, but its usage can be difficult
    as it can be hard to discover where the right place for a mock actually is.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on mocks, visit [http://www.mockobjects.com/2009/09/brief-history-of-mock-objects.html](http://www.mockobjects.com/2009/09/brief-history-of-mock-objects.html).
  prefs: []
  type: TYPE_NORMAL
- en: Why and why not to mock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|   | *Our initial description had focused too much on implementation, the
    critical idea was that the technique emphasizes the roles that objects play for
    each other.* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*A Brief History of Mock Objects – Steve Freeman* |'
  prefs: []
  type: TYPE_TB
- en: Mock objects stand in for other objects in a system during testing, and sometimes
    even during development. There are multiple reasons to do this, for example, the
    underlying structure is not implemented yet, or the call would be really expensive
    both in a cost of time during development or even in money calling to an API that
    charges by the amount of calls. For developers it can be very convenient to be
    able to run the tests offline as well, and there are more reasons why somebody
    would want to not call the real system but something in its place.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of practice is normally referred to as **stubbing out** an external
    dependency. When combined with making assertions about this dependency, this stub
    becomes a mock, which is often helpful during development to ensure that some
    code is called correctly, at the right time and, of course, when testing.
  prefs: []
  type: TYPE_NORMAL
- en: It is very easy to fall into the trap of creating very specific mock objects,
    mocking inner dependencies of other objects, and so forth. The important thing
    to keep in mind is that a mock should always represent a role in the system. Various
    other objects in the real world can play this role, but they can be represented
    in one mock. In classical object-oriented terms, this would mean that we are mocking
    interfaces not classes. In JavaScript, there are no interfaces so we need to select
    the right objects to mock. The object, or part of the object that is our mock,
    needs to only represent what is essential to the test, and nothing more. This
    comes naturally when we drive our design through tests, but we need to keep an
    eye on this as the software evolves and changes, as changes might result in our
    tests overspecifying an object through a mock.
  prefs: []
  type: TYPE_NORMAL
- en: Who is involved in the prisoner transfer?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous sections, we did a lot of exploring in the domain to get a
    view of what has to be done to make actions in the system happen. With this knowledge,
    we can now get a clear-cut concept of how a prisoner transfer should happen. The
    tests we created earlier specify some behavior and collaborators we are aware
    of in the domain. We represent them as basic JavaScript objects that contain the
    properties necessary to satisfy the tests; we, for example, know that a dungeon
    needs a message inbox to be notified, but we don''t know any properties for the
    prisoner yet. The following code provides some simple functions to let us describe
    the type of object we are using, as the code grows and our knowledge of what makes
    a prisoner or a dungeon gets solidified we can fill those out to continue to be
    stand-ins for the respective objects during our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, the prisoner as well as the dungeon are specific JavaScript objects
    created just to represent what we need at this moment. Looking further into the
    details, other actors are involved as well, namely the orc guarding the prisoner
    along the way, as well as the transfer carriage. Of course, those again have dependencies:
    the carriage consists of the driver, the wooden carriage working as a mobile cell
    for the prisoner, as well as the horses that pull it. All those pieces are potentially
    scarce resources that we need to acquire. Here is where domain modeling comes
    in again; in the context of our application we can stay away from looking at them
    as separate things because if either is missing the whole object won''t be able
    to function. We can focus on which roles the different objects play and acquire
    them as aggregates where it fits our model.'
  prefs: []
  type: TYPE_NORMAL
- en: Different objects and their roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The carriage is one of those described roles; we do not care at this moment
    what the carriage consists of but treat it as one thing that fulfills some purpose
    in our system. The carriage as a whole is an aggregate we only want to inspect
    from the outside for now and don't care much about its internals. Right there,
    the carriages public API shows a seam that that we need to account for when we
    model. We might care about horses being a separate thing later, for example, to
    model a messenger where we want to allocate horses for both carriages as well
    as messengers.
  prefs: []
  type: TYPE_NORMAL
- en: An aggregate is not a way to limit the share ability of resources but a concept
    to make dealing with the comprised object less complex. It does not change the
    fact that a carriage without horses is useless, and that something else also might
    need to acquire horses as a resource. The carriage is a role in our system. It
    provides a public API and takes care of its own internal data and dependencies.
    It is an aggregate in itself on a smaller scale.
  prefs: []
  type: TYPE_NORMAL
- en: The idea to discover such seams is a fundamental idea when it comes to building
    systems using mocks and stubs. By mocking out roles in the system, we can interact
    with the role before it really exists and explore its functionality without being
    hampered by the internal implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Naming objects according to the domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *There are only two hard things in Computer Science: cache invalidation
    and naming things.* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Phil Karlton* |'
  prefs: []
  type: TYPE_TB
- en: When exploring roles in a domain, the most complicated thing is most often the
    fact that we need to name the role that we try to establish in the system. When
    we are able to name a thing, we can naturally associate it with the role it plays
    in a system. When building a software system and being able to point out the roles
    by giving them concrete names, we make it easy for every developer working on
    the system to know where to put functionality related to the part they need to
    work on.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we introduced the concept of a carriage, comprising the cart itself,
    horses to tow it, and a driver. This is one example of naming a concept according
    to the domain. In the world of the orc dungeons, the concept of a carriage is
    very clear, and what is needed to run it is very clear. By using the language
    of the stakeholders in the system, we are increasing the teams' language and enabling
    all the stakeholders to participate. We saw this before when identifying the parts
    of the domain; we now make sure we continue to increase the language while creating
    abstractions. This allows us to hide certain details behind a common role.
  prefs: []
  type: TYPE_NORMAL
- en: The traps of common names like *Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The carriage we introduced a concept, well known in the domain, is a good abstraction
    to have; as software developers, however, we are prone to keep reusing elements
    we have seen before in other applications. When naming roles, it is very easy
    to fall into a pattern of naming. Very often, we see `Manager` objects that really
    only exist for the lack of a better name about the role they fulfill:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Even though this object fulfills the same responsibility as the object we named
    `carriage` before, finding out what it does is no longer obvious by the name.
    Even though it is clear to the developers on the team what this object is meant
    to do, the other stakeholders will be confused. This drives a separation in the
    team and will not foster involvement in the development process by non-developers.
  prefs: []
  type: TYPE_NORMAL
- en: Naming an object as a manager often means naming it after what it does at this
    moment instead of the role it fulfills in the system in general. Naming an object
    this way makes it hard to abstract away the details within it. To know what a
    `Manager` object does always means knowing what it is managing and how its internal
    details work to make sense of it. The abstraction leaks to other parts of the
    system, and everybody using the manager will look into the parts it is managing
    and the details.
  prefs: []
  type: TYPE_NORMAL
- en: The pain of manager objects often becomes very clear in the context of writing
    tests. When we want to test a manager and we don't see a clear abstraction, we
    need to care about the internal dependencies and therefore need to hold on to
    them in our tests. This makes tests look complicated and the setup starts to trump
    the actual assertion part. With objects named after generic roles, we get objects
    serving the purpose of very generic roles and therefore move away from domain-specific
    objects. This can cause pain as those generic objects are only made specific by
    their internal implementation, and therefore are bad representatives of the role
    they are supposed to play.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you have trouble coming up with a name for an object, try naming it something
    obviously silly first and let the exploration of the domain guide you to a more
    specific and meaningful name.
  prefs: []
  type: TYPE_NORMAL
- en: Readability of method names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In **Object-oriented Programming** (**OOP**), an object holds data and is responsible
    for the actions most closely related to the data it holds. Functions operating
    on the data, such as computing new data from the internal state of the object,
    are called queries. Examples for such a function are ones that compute compound
    data, like the full name of an orc from its set first name and last name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if an object is not immutable, there need to be functions
    to modify its internal state. Functions that change the internal state of an object
    are called commands; they allow external objects to send commands to the object
    to change its behavior. The following is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As commands change their internal state, it needs to be very clear what is happening
    and the object should have as much control as possible over what to actually do
    in the case of the command, so the command tells the object what to do and does
    not ask it for its state to modify it. Making this happen means we want to instruct
    the object to accomplish a task, without inspecting its properties. The opposite
    is checking object properties and based on those, making a decision in place of
    the object responsible for the properties. The *Tell, Don't Ask* principle is
    an important principle of OOP. The preceding example follows this concept, by
    not creating a setter to *attack* the property, we make sure the `Orc` object
    is in control of its internal state. Making domain-specific commands read like
    what they do, instead of creating an extensive amount of setter/getter methods,
    helps readability as well as making sure that the state is well managed. In object
    orientation, we want the object to be responsible for its state and the methods
    that operate on that state.
  prefs: []
  type: TYPE_NORMAL
- en: Not only are the objects part of a consistent naming scheme that allows us to
    model the domain. When we are modeling functionality and we want it to read clearly,
    we need to make the method names readable as well. In the previous example, the
    `TransportManager` only method is `initializeTransport` and it more or less repeats
    the name of the object. This pattern is very common when objects are `Managers`
    or `Executors`, or alike, but it does not help readability. This is the same trap
    as creating setters that are called outside the context of setting a value to
    initialize the object. The method needs to tell what the command does.
  prefs: []
  type: TYPE_NORMAL
- en: An object named after a role in the system allows much better readability of
    methods. The domain name `Carriage` makes the method name `transport` much more
    understandable because it comes naturally with the concept of a carriage in the
    domain.
  prefs: []
  type: TYPE_NORMAL
- en: With all this, it now comes the point where we need to think about how we model
    the objects to ease testing as well as development.
  prefs: []
  type: TYPE_NORMAL
- en: Objects first
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building the dungeon manager, we set out to create a maintainable and evolvable
    piece of software. The core principles of OOP are there to help us out when dealing
    with objects, but JavaScript is special when it comes to object orientation.
  prefs: []
  type: TYPE_NORMAL
- en: As many JavaScript programmers will most certainly have heard, JavaScript uses
    prototypical inheritance and, more importantly, has not really got a concept of
    classes, only instances.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though the next version of JavaScript, **ECMAScript 6**, introduces the
    class `keyword`, the core language design does not change. Classes are really
    just syntactic sugar over the prototypical inheritance present in JavaScript right
    now. If you want to know more about ES6, follow the blog [http://www.2ality.com/](http://www.2ality.com/)
    by Alex Rauschmayer, who describes and follows the evolving JavaScript language
    closely.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this does not make JavaScript the worst language to perform the task
    we are trying to achieve because this lack does not limit the power of the language
    in any way, but really makes it a superset of classical object-oriented languages.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first do a quick recap of how object orientation works in JavaScript and
    how we can use the power of the language to help us out in modeling the system
    that we have been drafting out so far.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of objects in JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Object-oriented languages such as Ruby or even Java, objects are based on
    classes. Even though it might be possible to create a plain object, it is not
    the norm. Taking Ruby as an example to create an object with a method like our
    carriage, you would write something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In JavaScript, for very simple objects and also, very importantly, for the
    tests, we don''t need to have a class first to have an object like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will do the same thing without the necessity of creating
    a class along with the object first. This can be very powerful especially when
    modeling a new API, because it allows very lightweight usage and generation during
    this phase of development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the availability of plain objects that are constructed via `{}`, JavaScript
    allows functions to be used as objects. Using functions as object constructors
    means very much the same flexibility as classes in classical object orientation
    would. Functions in JavaScript are objects that encapsulate their internal state
    and the state of any variables they reference at the time of their creation from
    the outside world. Due to those properties, functions in JavaScript are the basic
    building blocks to be used to create objects, and special support via the keyword
    `new` is part of the language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This looks a lot like the Ruby code and behaves very similarly to it. Constructors
    are a special beast in JavaScript and much has been written about their usage
    or non-usage. In a lot of cases, the idea of a class of objects being related
    by common functionality is a good idiom to use, and modern JavaScript engines
    were built with this is mind. So don't fear constructors, but be aware of their
    special use of the keyword `new` and the confusion they might cause around new
    developers.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A lot has been written about the problems with `new` in JavaScript. For more
    information and the best information about the internals of JavaScript as a language,
    read *JavaScript: The Good Parts*, *Douglas Crockford*, *O''Reilly*.'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance and why you won't need it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, just the construction of classes and their usage is only a part of
    being an OO (object-oriented) language. Especially in Java, it is very common
    to build quite complex inheritance hierarchies that allow common functionality
    to be shared across objects.
  prefs: []
  type: TYPE_NORMAL
- en: The basic concept of inheritance is that all the methods of the parent are also
    available on the child.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling patterns beyond inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|   | *Favor ''object composition'' over ''class inheritance''.* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Gang of Four 1995:20* |'
  prefs: []
  type: TYPE_TB
- en: Even though inheritance is possible in JavaScript, it is not necessarily the
    best route to go down for designing when an application like it is stated in the
    *Gang of Four*. Inheritance creates a very strong bond between the parent class
    and its children; this in itself means a leak of knowledge in parts of the system
    that it should not. Inheritance is the strongest possible form of coupling between
    two objects, and coupling itself should always be a very deliberate choice. Deep
    inheritance trees quickly make a piece of software very resistant to change as
    the changes tend to ripple through the whole system. There is a bigger problem
    so as well—as JavaScript does not do compile time checking of the interface and
    relationships, it is easier for those parts to get out of sync, and cause bugs
    in the system, than in more static languages.
  prefs: []
  type: TYPE_NORMAL
- en: For those reasons, and also due to the fact that classical inheritance is rarely
    needed in a dynamic language like JavaScript, inheritance is almost never used.
    There are other patterns that have been hinted at already to counter the need
    for inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: The object composition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What can we do when we don''t want to share functionality via inheritance?
    The easiest way to go is to pass the object that already implements the functionality
    we need and use it directly, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A notification is a very simple object that manages the notifications for a
    part of the system; it does not concern itself greatly with how notifications
    are saved for later processing but simply delegates this to a store object that
    by default is implemented as an array.
  prefs: []
  type: TYPE_NORMAL
- en: Delegating to native types is normally done a lot, but this for all other objects
    that are created by the programmer. Composition like this has the big advantage
    that it eases testing especially when the dependencies are passed in, like in
    the example just given, we can simply replace the store object in our tests with
    something that ensures the right calls have been made.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism without inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '|   | *When I see a bird that walks like a duck and swims like a duck and quacks
    like a duck, I call that bird a duck.* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Michael Heim* |'
  prefs: []
  type: TYPE_TB
- en: 'Another reason for inheritance in languages such as Java is the need for polymorphism.
    The idea is that a method should be implemented differently in different objects.
    In classical inheritance combined with type checking, this means that the objects
    on which the method is called need to have a common ancestor or interface because
    the type checker will complain otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can pass both a `SwordMaster` class or an `AxeMaster` class to somebody
    in need in order for an orc to guard them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This kind of overhead is not needed in a language that supports duck typing.
    In JavaScript, we can just write this without the need for an interface, both
    orcs can just be plain JavaScript objects, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Master` object being guarded can now just call the method needed on each
    guard without the need for a matching type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Duck typing means that an object is defined by what it can do rather than what
    it is. We already saw this behavior when building our own very simple mocks. As
    long as the method is defined on the object, it doesn't matter what its type is
    when we call it, so there is really no need to have a common ancestor.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the very dynamic nature of JavaScript and the availability of duck typing,
    the need for inheritance is very much obviated.
  prefs: []
  type: TYPE_NORMAL
- en: Applying object design to the domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With an understanding of conceptual object design, we need to apply all the
    concepts to our domain. We continue modeling the prisoner transfer we started.
    So far, we have an entry point to the application module that will ultimately
    handle this. From the tests, we know that the prisoner transfer relies on a prisoner
    and a dungeon object.
  prefs: []
  type: TYPE_NORMAL
- en: Building a system on simple objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So let's walk through what the prisoner transfer needs to do and what its collaborators
    are. Previously, we identified that the prisoner transfer will need a prisoner,
    obviously, and a target dungeon to transfer to, and the prisoner transfer should
    manage everything else. It is important to think about what the minimal input
    is from a user perspective to limit the API surface.
  prefs: []
  type: TYPE_NORMAL
- en: Of course the prisoner transfer, which is a service in DDD speak, needs more
    collaborators to really fulfill its purpose. First is a reference to the local
    dungeon to acquire resources such as orcs to act as keepers, carriages to move
    the prisoner, and possibly more. A goal of a managed transfer is also to notify
    the other dungeon, so we also need the means to notify them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we found out in the previous chapters, the concept of notifications is not
    well understood yet, so for now we can assume that there will be a service that
    allows us to send a message to a target, for a specific reason. We can program
    against the abstraction of a messaging service, allowing us to further specify
    what we are going to need out of the system. Bringing all this together and flushing
    it out brings us to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'All calls are just simple calls to objects that can have a stand-in of a simple
    plain JavaScript object during the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Returning plain objects with the functionality needed, which we will ultimately
    make their own modules based on the design being mocked up now, is all there is
    to creating the roles of the collaborators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This top-level design really brings us along the way to create the underlying
    functionality. We can already see very clearly what we need from a notification
    system, and flushing out the transfer itself to perform its duties will tell us
    a lot more about the other collaborators as well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you have a solid foundation on how we can model
    the prisoner transfer inside the system. We used a very simple design with the
    least amount of tooling overhead possible. Our system leverages the dynamic nature
    of JavaScript to create simple stubs for objects we haven't created, yet, and
    we were able to validate the first understanding we discussed in our previous
    research.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to further explore the other roles in the
    system. We focus on classifying them in domain-driven design terms so we can reuse
    the patterns explored by others in the space. We are also going to focus more
    on the language to foster further communication and how it can work with those
    patterns to allow very clear communication in the domain.
  prefs: []
  type: TYPE_NORMAL
