- en: Numerical Methods for Pricing Options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A derivative is a contract whose payoff depends on the value of some underlying
    asset. In cases where closed-form derivative pricing may be complex or even impossible,
    numerical procedures excel. A numerical procedure is the use of iterative computational
    methods in attempting to converge to a solution. One such basic implementation
    is a binomial tree. In a binomial tree, a node represents the state of an asset
    at a certain point of time associated with a price. Each node leads to two other
    nodes in the next time step. Similarly, in a trinomial tree, each node leads to
    three other nodes in the next time step. However, as the number of nodes or the
    time steps of trees increase, so do the computational resources that are consumed.
    Lattice pricing attempts to solve this problem by storing only the new information
    at each time step, while reusing values where possible.
  prefs: []
  type: TYPE_NORMAL
- en: In finite difference pricing, the nodes of the tree can also be represented
    as a grid. The terminal values on the grid consist of terminal conditions, while
    the edges of the grid represent boundary conditions in asset pricing. We will
    discuss the explicit method, implicit method, and the Crank-Nicolson method of
    the finite difference schemes to determine the price of an asset.
  prefs: []
  type: TYPE_NORMAL
- en: Although vanilla options and certain exotics such as European barrier options
    and lookback options can be found to have a closed-form solution, other exotic
    products such as Asian options do not contain a closed-form solution. In these
    cases, the pricing of options can be used with numerical procedures.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Pricing European and American options using a binomial tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a Cox-Ross-Rubinstein binomial tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pricing options using a Leisen-Reimer tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pricing options using a trinomial tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deriving Greeks from a tree for free
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pricing options using a binomial and trinomial lattice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finite differences with the explicit, implicit, and Crank-Nicolson method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implied volatility modeling using an LR tree and the bisection method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **option** is a derivative of an asset that gives an owner the right but
    not the obligation to transact the underlying asset at a certain date for a certain
    price, known as the maturity date and strike price, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: A **call option** gives the buyer the right to buy an asset by a certain date
    for a certain price. A seller or writer of a call option is obligated to sell
    the underlying security to the buyer at the agreed price, should the buyer exercise
    his/her rights on the agreed date.
  prefs: []
  type: TYPE_NORMAL
- en: A **put option** gives the buyer the right to sell the underlying asset by a
    certain date for a certain price. A seller or writer of a put option is obligated
    to buy the underlying security from the buyer at the agreed price, should the
    buyer exercise his/her rights on the agreed date.
  prefs: []
  type: TYPE_NORMAL
- en: The most common options that are available are the European options and American
    options. Other exotic options include Bermudan options and Asian options. This
    chapter will deal mainly with European and American options. A European option
    can only be exercised on the maturity date. An American option, on the other hand,
    may be exercised at any time throughout the lifetime of the option.
  prefs: []
  type: TYPE_NORMAL
- en: Binomial trees in option pricing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the binomial option pricing model, the underlying security at one time period,
    represented as a node with a given price, is assumed to traverse to two other
    nodes in the next time step, representing an up state and a down state. Since
    options are derivatives of the underlying asset, the binomial pricing model tracks
    the underlying conditions on a discrete-time basis. Binomial option pricing can
    be used to value European options, American options, as well as Bermudan options.
  prefs: []
  type: TYPE_NORMAL
- en: The initial value of the root node is the spot price *S[0]* of the underlying
    security with a risk-neutral probability of increase *q*, and a risk-neutral probability
    of loss *1-q*, at the next time step. Based on these probabilities, the expected
    values of the security are calculated for each state of price increase or decrease
    for every time step. The terminal nodes represent every value of the expected
    security prices for every combination of up states and down states. We can then
    calculate the value of the option at every node, traverse the tree by risk-neutral
    expectations, and after discounting from the forward interest rates, we can derive
    the value of the call or put option.
  prefs: []
  type: TYPE_NORMAL
- en: Pricing European options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider a two-step binomial tree. A non-dividend paying stock price starts
    at $50, and, in each of the two time steps, the stock may go up by 20 percent
    or go down by 20 percent. Suppose that the risk-free rate is five percent per
    annum and that the time to maturity, *T*, is two years. We would like to find
    the value of a European put option with a strike price *K* of $52\. The following
    diagram shows the pricing of the stock and the payoffs at the terminal nodes using
    a binomial tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ebfbaecf-a7a2-4763-bb3d-cf9673e98c4d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, the nodes are calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/56cb6902-2c50-4589-8d03-71981ff9cd15.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/6c899404-b04e-4695-be22-8f1f4a46fac0.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/70e15ac6-f601-410d-9371-32cfb0dbe24e.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/6eda97f5-8781-4acf-9a3a-a88c41375fd5.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/a959a1cf-4af3-4fba-904a-3e316030ad56.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/98ee5ef1-3fa8-47fd-afd2-5fecdbe22756.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/c7579cd4-bc65-439b-9657-25691097682c.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/82886492-9cb6-4ebe-b4fc-40d5b97d7da3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At the terminal nodes, the payoff from exercising a European call option is
    given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/401d00a1-d6b5-4980-9cad-d589da05a7cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the case of a European put option, the payoff is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/91b879ad-9ac4-4540-b9a2-a9a9dbf3b42d.png)'
  prefs: []
  type: TYPE_IMG
- en: European call and put options are usually denoted by lowercase letters, *c*
    and *p*, while American call and put options are usually denoted by uppercase
    letters, *C* and *P*.
  prefs: []
  type: TYPE_NORMAL
- en: From the option payoff values, we can then traverse the binomial tree backward
    to the current time, and after discounting from the risk-free rate we will obtain
    our present value of the option. Traversing the tree backward takes into account
    the risk-neutral probabilities of the option's up states and down states.
  prefs: []
  type: TYPE_NORMAL
- en: 'We may assume that investors are indifferent to risk and that expected returns
    on all assets are equal. In the case of investing in stocks by risk-neutral probability,
    the payoff from holding the stock and taking into account the up and down state
    possibilities would be equal to the continuously compounded risk-free rate expected
    in the next time step, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/59bc58a4-3aa6-47d1-b491-e305786a3925.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The risk-neutral probability *q* of investing in the stock can be rewritten
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8996391c-6994-421f-99a1-116ac1e83498.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Are these formulas relevant to stocks? What about futures?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike investing in stocks, investors do not have to make an upfront payment
    to take a position in a futures contract. In a risk-neutral sense, the expected
    growth rate from holding a futures contract is zero, and the risk-neutral probability
    *q* of investing in futures can be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/83f95aed-08c9-447c-aa1d-e5f5a372d01b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s calculate the risk-neutral probability *q* of the stock given in the
    preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The payoffs of exercising the European put option at the terminal nodes are
    $0, $4, and $20 at the respective states. The present value of the put option
    can be priced as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/748f9fd6-e9de-4b9b-946a-1719ace53d65.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This gives us the put option price as $4.19\. The two-step binomial tree to
    value a European put option with payoffs at each node is illustrated in the following
    graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/66ef05f5-a024-498b-9228-720be29e4ef9.png)'
  prefs: []
  type: TYPE_IMG
- en: Writing the StockOption base class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before going any further and implementing the various pricing models that we
    are about to discuss, let''s create a `StockOption` class to store and calculate
    the common attributes of the stock option that will be reused throughout this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The current underlying price, strike price, risk-free rate, time to maturity,
    and number of time steps are compulsory common attributes for pricing options.
    The delta of the time step `dt` and the discount factor `df` are computed as properties
    of the class and may be overwritten by implementing classes if needed.
  prefs: []
  type: TYPE_NORMAL
- en: A class for European options using a binomial tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Python implementation of the binomial option pricing model of a European
    option is given as the `BinomialEuropeanOption` class, inheriting the common attributes
    of the option from the `StockOption` class. The implementations of the methods
    in this class are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `price()` method of the `BinomialEuropeanOption` class is the entry point
    for all the instances of this class
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It invokes the `setup_parameters()` method to set up the required model parameters,
    and then calls the `init_stock_price_tree()` method to simulate the expected values
    of the stock prices for the period up until *T*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the `begin_tree_traversal()` method is called to initialize the payoff
    array and store the discounted payoff values, as it traverses the binomial tree
    back to the present time
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The payoff tree nodes are returned as a NumPy array object, where the present
    value of the European option is found at the initial node
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The class implementation of `BinomialEuropeanOption` is given in the following
    Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take the values from the two-step binomial tree example we discussed
    earlier to price the European put option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using the binomial option pricing model gives us a present value of $4.19 for
    the European put option.
  prefs: []
  type: TYPE_NORMAL
- en: A class for American options using a binomial tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike European options, which can only be exercised at maturity, American options
    can be exercised at any time during their lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: To implement the pricing of American options in Python, in the same way we did
    with the `BinomialEuropeanOption` class, create a class named `BinomialTreeOption`
    that inherits the `Stockoption` class. The parameters that are used in the `setup_parameters()`
    method remain the same, except for the removal of an unused `M` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods that are used in American options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`init_stock_price_tree`: Uses a two-dimensional NumPy array to store the expected
    returns of the stock prices for all time steps. This information is used to calculate
    the payoff values from exercising the option at each period. This method is written
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`init_payoffs_tree`: Creates the payoff tree as a two-dimensional NumPy array,
    starting with the intrinsic values of the option at maturity. This method is written
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`check_early_exercise`: Returns the maximum payoff values between exercising
    the American option early and not exercising the option at all. This method is
    written as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`traverse_tree`: This also includes the invocation of the `check_early_exercise()`
    method to check whether it is optimal to exercise an American option early at
    every time step. This method is written as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of the `begin_tree_traversal()` and the `price()` methods
    remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: The `BinomialTreeOption` class can price both European and American options
    when the `is_put` keyword argument is set to `False` or `True` during instantiation
    of the class, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is for pricing the American option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The American put option is priced at $5.0896\. Since American options can be
    exercised at any time and European options can only be exercised at maturity,
    this added flexibility of American options increases their value over European
    options in certain circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: For American call options on an underlying asset that does not pay dividends,
    there might not be an extra value over its European call option counterpart. Because
    of the time value of money, it costs more to exercise the American call option
    today before the expiration at the strike price than at a future time with the
    same strike price. For an in-the-money American call option, exercising the option
    early loses the benefit of protection against adverse price movement below the
    strike price, as well as its intrinsic time value. With no entitlement of dividend
    payments, there are no incentives to exercise American call options early.
  prefs: []
  type: TYPE_NORMAL
- en: The Cox–Ross–Rubinstein model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding examples, we assumed that the underlying stock price would
    increase by 20 percent and decrease by 20 percent in the respective *u* up state
    and *d* down state. The **Cox-Ross-Rubinstein** (**CRR)** model proposes that,
    over a short period of time in the risk-neutral world, the binomial model matches
    the mean and variance of the underlying stock. The volatility of the underlying
    stock, or the standard deviation of returns of the stock, is taken into account
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8a91adde-554a-429b-96bb-180e991f1ce2.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/55fa99b2-ac5a-40bf-8adb-d09102cf749c.png)'
  prefs: []
  type: TYPE_IMG
- en: A class for the CRR binomial tree option pricing model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implementation of the binomial CRR model remains the same as the binomial
    tree we discussed earlier, with the exception of the `u` and `d` model parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, let's create a class named `BinomialCRROption` and simply inherit
    the `BinomialTreeOption` class. Then, all that we need to do is override the `setup_parameters()`
    method with values from the CRR model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instances of the `BinomialCRROption` object will invoke the `price()` method,
    which invokes all other methods of the parent `BinomialTreeOption` class, except
    the overwritten `setup_parameters()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, consider the two-step binomial tree. The non-dividend paying stock has
    a current price of $50 and a volatility of 30 percent. Suppose that the risk-free
    rate is five percent per annum and the time to maturity *T* is two years. We would
    like to find the value of a European put option with a strike price *K* of $52
    by the CRR model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: By using the CRR two-step binomial tree model, the price of the European put
    option and the American put option are $6.2457 and $7.4284, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Leisen-Reimer tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the binomial models we discussed earlier, we made several assumptions about
    the probability of up and down states, as well as the resulting risk-neutral probabilities.
    Besides the binomial model with CRR parameters that we discussed, other forms
    of parameterization that are discussed widely in mathematical finance include
    the Jarrow-Rudd parameterization, Tian parameterization, and Leisen-Reimer parameterization.
    Let's take a look at the Leisen-Reimer model in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Dr. Dietmar Leisen and Matthias Reimer proposed a binomial tree model with the
    purpose of approximating to the Black-Scholes solution as the number of step increases.
    It is known as the **Leisen-Reimer** (**LR**) tree, and the nodes do not recombine
    at every alternate step. It uses an inversion formula to achieve better accuracy
    during tree traversal.
  prefs: []
  type: TYPE_NORMAL
- en: 'A detailed explanation of the formula is given in the paper *Binomial Models
    For Option Valuation - Examining And Improving Convergence*, March 1995, which
    is available at [http://papers.ssrn.com/sol3/papers.cfm?abstract_id=5976](http://papers.ssrn.com/sol3/papers.cfm?abstract_id=5976).
    We will be using method two of the Peizer and Pratt inversion function *f* with
    the following characteristic parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9de89a37-6682-434b-b36a-c2397fa9ed49.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/ec38b5a2-90e5-4563-b006-bb1b848c4512.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/b8910449-3784-4f4e-a9d1-3ae2d5cc8834.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/b38b80b9-8653-42e5-8463-ff6f3922b8eb.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/07c34467-3bfb-468c-aab2-edc83990fdba.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/648c1914-ac35-48f2-aec2-14d91b432121.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/7e22357f-3cfd-4a3b-a57c-5bfad34f8b60.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/2cf66a09-cded-4bac-88dc-c66e4a75b10e.png)'
  prefs: []
  type: TYPE_IMG
- en: The *S[0]* parameter is the current stock price, *K* is the strike price of
    the option, σ is the annualized volatility of the underlying stock, *T* is the
    time to maturity of the option, *r* is the annualized risk-free rate, *y* is the
    dividend yield, and *Δt* is the time interval between each tree step.
  prefs: []
  type: TYPE_NORMAL
- en: A class for the LR binomial tree option pricing model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Python implementation of the LR tree is given in the following `BinomialLROption`
    class. Similar to the `BinomialCRROption` class, we simply inherit the `BinomialTreeOption`
    class and override the variables in the `setup_parameters` method with those of
    the LR tree model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the same examples that we used previously, we can price the options using
    an LR tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: By using the LR binomial tree model with four time steps, the price of the European
    put option and the American put option are $5.87865 and $6.7636, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The Greeks for free
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the binomial tree pricing models that we have covered so far, we traversed
    up and down the tree at each point in time to determine the node values. From
    the information at each node, we can reuse these computed values easily. One such
    use is the computation of Greeks.
  prefs: []
  type: TYPE_NORMAL
- en: The Greeks measure the sensitivities of the price of derivatives, such as options
    with respect to changes in the parameters of the underlying asset, often represented
    by Greek letters. In mathematical finance, the common names associated with Greeks
    include alpha, beta, delta, gamma, vega, theta, and rho.
  prefs: []
  type: TYPE_NORMAL
- en: Two particularly useful Greeks for options are delta and gamma. Delta measures
    the sensitivity of the option price with respect to the underlying asset price.
    Gamma measures the rate of change in delta with respect to the underlying price.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following diagram, an additional layer of nodes is added around
    our original two-step tree to make it a four-step tree, which extends two steps
    backward in time. Even with additional terminal payoff nodes, all nodes will contain
    the same information as our original two-step tree. Our option value of interest
    is now located in the middle of the tree at **t=0**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f93d5207-b1b0-4c63-b4be-ecc0bd5e3324.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that at **t=0** there exists two additional nodes'' worth of information
    that we can use to compute the delta formula, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/da8a6f89-51c5-4052-8f68-cc0eb611150a.png)'
  prefs: []
  type: TYPE_IMG
- en: The delta formula states that the difference in the option prices in the up
    and down state is represented as a unit of the difference between the respective
    stock prices at time **t=0**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, the gamma formula can be computed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6838f01f-47b1-4485-b121-1a222efddc4a.png)'
  prefs: []
  type: TYPE_IMG
- en: The gamma formula states that the difference of deltas between the option prices
    in the up node and the down node against the initial node value are computed as
    a unit of the differences in price of the stock at the respective states.
  prefs: []
  type: TYPE_NORMAL
- en: A class for Greeks with the LR binomial tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To illustrate the computation of Greeks with the LR tree, let's create a new
    class named `BinomialLRWithGreeks` that inherits the `BinomialLROption` class
    with our own implementation of the `price` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the `price` method, we will start by calling the `setup_parameters()` method
    of the parent class to initialize all variables required by the LR tree. However,
    this time, we will also call the `new_stock_price_tree()` method, which is a new
    method that's used to create an extra layer of nodes around the original tree.
  prefs: []
  type: TYPE_NORMAL
- en: The `begin_tree_traversal()` method is called to perform the usual LR tree implementation
    in the parent class. The returned NumPy array object now contains information
    on the three nodes at **t=0**, where the middle node is the option price. The
    payoffs in the up and down states at **t=0** are in the first and last index of
    the array, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this information, the `price()` method computes and returns the option
    price, the delta, and the gamma values together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the same example from the LR tree, we can compute the option values and
    Greeks for a European call and put option with 300 time steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the `price()` method and results, we managed to obtain additional
    information on Greeks from the modified binomial tree without any extra overhead
    in computational complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Trinomial trees in option pricing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the binomial tree, each node leads to two other nodes in the next time step.
    Similarly, in a trinomial tree, each node leads to three other nodes in the next
    time step. Besides having up and down states, the middle node of the trinomial
    tree indicates no change in state. When extended over more than two time steps,
    the trinomial tree can be thought of as a recombining tree, where the middle nodes
    always retain the same values as the previous time step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the Boyle trinomial tree, where the tree is calibrated so that
    the probability of up, down, and flat movements, *u*, *d*, and *m* with risk-neutral
    probabilities *q[u]*, *q[d]*, and *q[m]* are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6bccf093-15d1-474a-aa19-2bbb3b5b4669.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/548f26bc-063d-49c1-b5a5-c5b88cf07150.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/b6f6844b-4f98-41ca-bc2d-277b5d155c6b.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/5f592c17-82bd-4348-be54-2fe893501558.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/3331afe8-85f2-4160-9e74-aadfe9e7253f.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/d6514bfb-2bfa-457a-8a95-eac1f6ec2e1a.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that ![](Images/368560b2-b79d-4f65-adb1-50cf118f29dc.png) recombines
    to *m =1*. With calibration, the no state movement *m* grows at a flat rate of
    1 instead of at the risk-free rate. The variable *v* is the annualized dividend
    yield, and *σ* is the annualized volatility of the underlying stock.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, with an increased number of nodes to process, a trinomial tree
    gives better accuracy than the binomial tree when fewer time steps are modeled,
    saving on computation speed and resources. The following diagram illustrates the
    stock price movements of a trinomial tree with two time steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ebfc055a-39ea-418c-a865-425c697b4255.png)'
  prefs: []
  type: TYPE_IMG
- en: A class for the trinomial tree option pricing model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a `TrinomialTreeOption` class, inheriting from the `BinomialTreeOption`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods for the `TrinomialTreeOption` are provided as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setup_parameters()` method implements the model parameters of the trinomial
    tree. This method is written as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `init_stock_price_tree()` method sets up the trinomial tree to include
    the flat movement of stock prices. This method is written as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `traverse_tree()` method takes into account the middle node after discounting
    the payoff:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the same example of the binomial tree, we get the following result:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: By the trinomial tree model, we obtain prices of $6.57 and $7.16 for the European
    and American put options, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Lattices in option pricing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In binomial trees, each node recombines at every alternative node. In trinomial
    trees, each node recombines at every other node. This property of recombining
    trees can also be represented as lattices to save memory without recomputing and
    storing recombined nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Using a binomial lattice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a binomial lattice from the binomial CRR tree since at every
    alternate up and down nodes, the prices recombine to the same probability of *ud=1*.
    In the following diagram, **S[u]** and **S[d]** recombine with **S[du]** = **S[ud]**
    = **S*[0]***. The tree can now be represented as a single list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1d131a2a-96bb-4663-9199-e84c4a8cbe84.png)'
  prefs: []
  type: TYPE_IMG
- en: For a *N*-step binomial tree, a list of size *2N +1* is required to contain
    the information on the underlying stock prices. For European option pricing, the
    odd nodes of payoffs from the list represent the option value upon maturity. The
    tree traverses backward to obtain the option value. For American option pricing,
    as the tree traverses backward, both ends of the list shrink, and the odd nodes
    represent the associated stock prices for any time step. Payoffs from the earlier
    exercise can then be taken into account.
  prefs: []
  type: TYPE_NORMAL
- en: A class for the CRR binomial lattice option pricing model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s convert the binomial tree pricing into a lattice by CRR. We can inherit
    from the `BinomialCRROption` class (which in turn inherits the `BinomialTreeOption`
    class) and create a new class named `BinomialCRRLattice`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following methods are overwritten with the implementation of the lattice
    while retaining the behavior of all the other pricing functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setup_parameters`: Overrides the parent method to initialize the CRR parameters
    of the parent class, as well as declaring the new variable `M` as the list size'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init_stock_price_tree`: Overrides the parent method to set up a one-dimensional
    NumPy array as the lattice with the `M` size'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init_payoffs_tree` and `check_early_exercise`: Overrides the parent methods
    to take into account the payoffs at odd nodes only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the same stock information from our binomial CRR model example, we can
    price a European and American put option using the binomial lattice pricing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: By using the CRR binomial tree lattice pricing model, we obtain prices of $6.2457
    and $7.428 for the European and American put options, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Using the trinomial lattice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The trinomial lattice works in very much the same way as the binomial lattice.
    Since each node recombines at every other node instead of alternate nodes, extracting
    odd nodes from the list is not necessary. Since the size of the list is the same
    as the one in the binomial lattice, there are no extra storage requirements in
    trinomial lattice pricing, as explained in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ac536179-2cd2-4ee1-ba53-e3debaa9e4e6.png)'
  prefs: []
  type: TYPE_IMG
- en: A class for the trinomial lattice option pricing model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, let's create a class named `TrinomialLattice` for the trinomial lattice
    implementation that inherits from the `TrinomialTreeOption` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as we did for the `BinomialCRRLattice` class, the `setup_parameters`,
    `init_stock_price_tree`, `init_payoffs_tree`, and `check_early_exercise` methods
    are overwritten, without having to take into account the payoffs at odd nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the same examples as before, we can price the European and American options
    using the trinomial lattice model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The output agrees with the results that were obtained from the trinomial tree
    option pricing model.
  prefs: []
  type: TYPE_NORMAL
- en: Finite differences in option pricing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finite difference schemes are very much similar to trinomial tree option pricing,
    where each node is dependent on three other nodes with an up movement, a down
    movement, and a flat movement. The motivation behind the finite differencing is
    the application of the Black-Scholes **Partial Differential Equation** (**PDE**)
    framework (involving functions and their partial derivatives), where price *S(t)*
    is a function of *f(S,t)*, with *r* as the risk-free rate, *t* as the time to
    maturity, and *σ* as the volatility of the underlying security:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/95125917-f109-4f59-82dd-44ff66ff99dc.png)'
  prefs: []
  type: TYPE_IMG
- en: The finite difference technique tends to converge faster than lattices and approximates
    complex exotic options very well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve a PDE by finite differences working backward in time, a discrete-time
    grid of size *M* by *N* is set up to reflect asset prices over a course of time,
    so that *S* and *t* take on the following values at each point on the grid:'
  prefs: []
  type: TYPE_NORMAL
- en: It follows that by grid notation, *f[i,j]=f( idS, j dt)*. *S[max]* is a suitably
    large asset price that cannot be reached by the maturity time, *T*. Thus *dS*
    and *dt* are intervals between each node in the grid, incremented by price and
    time, respectively. The terminal condition at expiration time *T* for every value
    of *S* is *max(S − K, 0)* for a call option with strike *K* and *max(K − S, 0)*
    for a put option. The grid traverses backward from the terminal conditions, complying
    with the PDE while adhering to the boundary conditions of the grid, such as the
    payoff from an earlier exercise.
  prefs: []
  type: TYPE_NORMAL
- en: The boundary conditions are defined values at the extreme ends of the nodes,
    where *i=0* and *i=N* for every time at *t*. Values at the boundaries are used
    to calculate the values of all other lattice nodes iteratively using the PDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'A visual representation of the grid is given in the following diagram. As *i*
    and *j* increase from the top-left corner of the grid, the price *S* tends toward
    *S[max]* (the maximum price possible) at the bottom-right corner of the grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d8d7bd1b-8af0-4d25-bcdc-5ea644964aa5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A number of ways to approximate the PDE are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Forward difference:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](Images/967661cb-b539-45f5-8a7f-999297c8d67d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Backward difference:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](Images/1208b133-921f-4777-992a-5dbfa9349a1a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Central or symmetric difference:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](Images/63ff2ce0-6167-479e-a73b-92aadde910b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The second derivative:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](Images/5886183c-bf2c-4320-8bbe-0ffbcc29da77.png)'
  prefs: []
  type: TYPE_IMG
- en: Once we have the boundary conditions set up, we can now apply an iterative approach
    using the explicit, implicit, or Crank-Nicolson method.
  prefs: []
  type: TYPE_NORMAL
- en: The explicit method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The explicit method for approximating *f[i,j]* is given by the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/cd4d03e8-dab2-4445-bfbe-4f353e2b5985.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we can see that the first difference is the backward difference with
    respect to *t*, the second difference is the central difference with respect to
    *S*, and the third difference is the second-order difference with respect to *S*.
    When we rearrange the terms, we get the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1c511137-07bc-420c-a905-b4084a60e3e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2f7a5ad4-5e48-42af-9366-c1d7818baf68.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/c5f4f25e-9d7a-484f-b8e5-336f01d49559.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0db97616-b3a6-44c4-92c8-9f97fb0af73b.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/496c44aa-5985-4a78-8cec-0e4111dbfcf2.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/e3caf1b2-b486-4785-a6d9-40e6531a77ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The iterative approach of the explicit method can be visually represented by
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2b4772e0-cba3-4545-b93f-c264c4f564a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Writing the finite difference base class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we will be writing the explicit, implicit, and Crank-Nicolson methods
    of finite differences in Python, let's write a base class that inherits the common
    properties and functions of all three methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a class called `FiniteDifferences` that accepts and assigns
    all the required parameters in the `__init__` constructor method. The `price()`
    method is the entry point for invoking the specific finite difference scheme implementation,
    and will invoke these methods in the following order: `setup_boundary_conditions()`,
    `setup_coefficients()`, `traverse_grid()`, and `interpolate()`. These methods
    are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setup_boundary_conditions`: Sets up the boundary conditions of the grid structure
    as a NumPy two-dimensional array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setup_coefficients`: Sets up the necessary coefficients that are used for
    traversing the grid structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`traverse_grid`: Iterates the grid structure backward in time, storing the
    calculated values toward the first column of the grid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`interpolate`: Using the final calculated values on the first column of the
    grid, this method will interpolate these values to find the option price that
    closely infers the initial stock price, `S0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these methods are abstract methods that can be implemented by the derived
    classes. An exception type of `NotImplementedError` will be thrown should we forget
    to implement these methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The base class with the mandatory methods should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**Abstract base classes** (**ABCs**) provide a way to define interfaces for
    a class. The `@abstractmethod()` decorator declares abstract methods that child
    classes should implement. Unlike Java''s abstract methods, these methods may have
    an implementation and may be called via the `super()` mechanism from the class
    that overrides it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these methods, we would need to define `dS` and `dt`, the change
    in `S` per unit time, and the change in `T` per iteration, respectively. We can
    write these as class properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the `price()` method as the entry point that shows the steps in
    calling our discussed abstract methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A class for pricing European options using the explicit method of finite differences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Python implementation of finite differences by using the explicit method
    is given in the following `FDExplicitEu` class, which inherits from the `FiniteDifferences`
    class and overrides the required implementation methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: On completion of traversing the grid structure, the first column contains the
    present value of the initial asset prices at **t=0**. The `interp` function of
    NumPy is used to perform a linear interpolation to approximate the option value.
  prefs: []
  type: TYPE_NORMAL
- en: Besides using linear interpolation as the most common choice for the interpolation
    method, the other methods such as the spline or cubic may be used to approximate
    the option value.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the example of a European put option. The underlying stock price is
    $50 with a volatility of 40 percent. The strike price of the put option is $50
    with an expiration time of five months. The risk-free rate is 10 percent.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can price this option using the explicit method with a `Smax` value of `100`,
    an `M` value of `100`, and an `N` value of `1000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: What happens when other values of `M` and `N` are chosen improperly?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It appears that the explicit method of the finite difference scheme suffers
    from instability problems.
  prefs: []
  type: TYPE_NORMAL
- en: The implicit method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The instability problem of the explicit method can be overcome using the forward
    difference with respect to time. The implicit method for approximating *f[i,j]*
    is given by the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2b6e9a19-c56e-4d89-9da4-4fec358a90b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, it can be seen that the only difference between the implicit and explicit
    approximating scheme lies in the first difference, where the forward difference
    with respect to *t* is used in the implicit scheme. When we rearrange the terms,
    we get the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2d290bf9-5f31-463a-819c-8efaed57c26b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1cd1639f-1740-4616-b9f7-9e45fb885cda.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/7d83d409-627f-4267-b857-f714a158fad8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/193c6822-3155-41e6-b4b8-110a15e4354d.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/3a7cd64e-4488-47fb-a3eb-588da2b9c77f.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/42dc58ea-64de-49be-947b-5b397c2ada52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The iterative approach of the implicit scheme can be visually represented with
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b760a196-4c5e-48a6-a6d3-67799d0a657b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding diagram, we can note that values of *j+1* need to be computed
    before they can be used in the next iterative step, as the grid traverses backward.
    In the implicit scheme, the grid can be thought of as representing a system of
    linear equations at each iteration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8978c0d4-f8ef-421c-89e0-713504b1dcd4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By rearranging the terms, we get the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f23e2337-d4f1-458d-8409-1f55a40b9b69.png)'
  prefs: []
  type: TYPE_IMG
- en: The linear system of equations can be represented in the form of *Ax = B*, where
    we want to solve values of *x* in each iteration. Since the matrix *A* is tri-diagonal,
    we can use the LU factorization, where *A=LU*, for faster computation. Remember
    that we solved the linear system of equations using LU decomposition in [Chapter
    2](7b247a98-9fcc-4ec8-8d5d-3c5b77353f38.xhtml)*, The Importance of Linearity in
    Finance*.
  prefs: []
  type: TYPE_NORMAL
- en: A class for pricing European options using the implicit method of finite differences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Python implementation of the implicit scheme is given in the following
    `FDImplicitEu` class. We can inherit the implementation of the explicit method
    from the `FDExplicitEu` class we discussed earlier and override the necessary
    methods of interest, namely, the `setup_coefficients` and `traverse_grid` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the same example as the explicit scheme, we can price the European put
    options using the implicit scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Given the current parameters and input data, we can see that there are no stability
    issues with the implicit scheme.
  prefs: []
  type: TYPE_NORMAL
- en: The Crank-Nicolson method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way of avoiding the instability issue, as seen in the explicit method,
    is to use the Crank-Nicolson method. The Crank-Nicolson method converges much
    more quickly using a combination of the explicit and implicit methods, taking
    the average of both. This leads us to the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a8840a9a-b4a3-408f-a0ba-a82b85b3767e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This equation can also be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f847380f-ae9d-46f6-bfa1-2b17617b7e49.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/58d5e72d-41d6-4dad-bd00-d0cee25e8b34.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The iterative approach of the implicit scheme can be visually represented with
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/25895799-5f87-4158-970c-988563cc595c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can treat the equations as a system of linear equations in a matrix form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/08f3b87b-e8dc-4d42-8a72-87b0e990a26f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0955b807-c75c-47ac-8abd-2256d570b329.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/d26eccb2-880e-41b4-9ddd-302affc103b1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/a92e8ca5-5361-478b-9cbf-85edad31fa45.png)'
  prefs: []
  type: TYPE_IMG
- en: We can solve for the matrix *M* on every iterative procedure.
  prefs: []
  type: TYPE_NORMAL
- en: A class for pricing European options using the Crank-Nicolson method of finite
    differences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Python implementation of the Crank-Nicolson method is given in the following
    `FDCnEu` class, which inherits from the `FDExplicitEu` class and overrides only
    the `setup_coefficients` and `traverse_grid` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the same examples that we used with the explicit and implicit methods,
    we can price a European put option using the Crank-Nicolson method for different
    time point intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: From the observed values, the Crank-Nicolson method not only avoids the instability
    issue we saw in the explicit scheme, but also converges faster than both the explicit
    and implicit methods. The implicit method requires more iterations, or bigger
    values of *N*, to produce values close to those of the Crank-Nicolson method.
  prefs: []
  type: TYPE_NORMAL
- en: Pricing exotic barrier options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finite differences are especially useful in pricing exotic options. The nature
    of the option will dictate the specifications of the boundary conditions.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will take a look at an example of pricing a down-and-out
    barrier option with the Crank-Nicolson method of finite differences. Due to its
    relative complexity, other analytical methods, such as Monte Carlo methods, are
    usually employed in favor of finite difference schemes.
  prefs: []
  type: TYPE_NORMAL
- en: A down-and-out option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of a down-and-out option. At any time during
    the life of the option, should the underlying asset price fall below an *S[barrier]*
    barrier price, the option is considered worthless. Since, in the grid, the finite
    difference scheme represents all the possible price points, we only need to consider
    nodes with the following price range:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7aa99c36-a86a-45d1-b1d4-0b6f30bd9371.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can then set up the boundary conditions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/843cd7f2-7cec-4c82-b4bd-dc3debce8798.png)'
  prefs: []
  type: TYPE_IMG
- en: A class for pricing down-and-out-options using the Crank-Nicolson method of
    finite differences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a class named `FDCnDo` that inherits from the `FDCnEu` class
    we discussed earlier. We will take into account the barrier price in the constructor
    method, while leaving the rest of the Crank-Nicolson implementation in the `FDCnEu`
    class unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Let's consider an example of a down-and-out option. The underlying stock price
    is $50 with a volatility of 40 percent. The strike price of the option is $50
    with an expiration time of five months. The risk-free rate is 10 percent. The
    barrier price is $40.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can price a call option and a put down-and-out option with `Smax` as `100`,
    `M` as `120`, and `N` as `500`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The prices of the down-and-out call and put options are $5.4916 and $0.5414,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Pricing American options with finite differences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have priced European options and exotic options. Due to the probability
    of an early exercise nature in American options, pricing such options is less
    straightforward. An iterative procedure is required in the implicit Crank-Nicolson
    method, where the payoffs from earlier exercises in the current period take into
    account the payoffs of an earlier exercise in the prior period. The Gauss-Siedel
    iterative method is proposed in the pricing of American options in the Crank-
    Nicolson method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that in [Chapter 2](7b247a98-9fcc-4ec8-8d5d-3c5b77353f38.xhtml)*, The
    Importance of Linearity in Finance*, we covered the Gauss-Siedel method of solving
    systems of linear equations in the form of *Ax=B*. Here, the matrix *A* is decomposed
    into *A=L+U*, where *L* is a lower triangular matrix and *U* is an upper triangular
    matrix. Let''s take a look at an example of a 4 x 4 matrix, *A*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6437c715-0e2b-426c-b17f-cbefd8a42c2b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The solution is then obtained iteratively, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c141f535-da24-4178-a6a0-8500d7d7bd5a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can adapt the Gauss-Siedel method to our Crank-Nicolson implementation as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/11cd3627-b98b-407a-b244-cc620283ca3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This equation satisfies the early exercise privilege equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/596908ed-7de4-4a12-ba73-f3b28424570a.png)'
  prefs: []
  type: TYPE_IMG
- en: A class for pricing American options using the Crank-Nicolson method of finite
    differences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a class named `FDCnAm` that inherits from the `FDCnEu` class, which
    is the Crank-Nicolson method's counterpart for pricing European options. The `setup_coefficients`
    method may be reused, while overriding all other methods for the inclusion of
    payoffs from an earlier exercise, if any.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor `__init__()` and the `setup_boundary_conditions()` methods
    are given in the `FDCnAm` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, implement the `traverse_grid()` method in the same class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In each iterative procedure of the `while` loop, the payoffs are calculated
    while taking into account the start and end boundaries. Furthermore, `new_values`
    are constantly replaced with new payoff calculations based on existing and previous
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the start boundaries where the index is 0,the payoffs are calculated with
    the alpha values omitted. Implement the `calculate_payoff_start_boundary()` method
    inside the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end boundary where the last index is, the payoffs are calculated with
    the gamma values omitted. Implement the `calculate_payoff_end_boundary()` method
    inside the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'For payoffs that are not at the boundaries, the payoffs are calculated by taking
    into account the alpha and gamma values. Implement the `calculate_payoff()` method
    inside the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the new variable, `values`, contains our terminal payoff values as a
    one-dimensional array, override the parent `interpolate` method to account for
    this change with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The tolerance parameter is used in the Gauss-Siedel method as the convergence
    criterion. The `omega` variable is the over-relaxation parameter. Higher `omega`
    values provide faster convergence, but this also comes with higher possibilities
    of the algorithm not converging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s price an American call-and-put option with an underlying asset price
    of 50 and volatility of 40 percent, a strike price of 50, a risk-free rate of
    10 percent, and an expiration date of five months. We choose a `Smax` value of
    `100`, `M` as `100`, `N` as `42`, an `omega` parameter value of `1.2`, and a tolerance
    value of `0.001`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The prices of the call and put American stock options by using the Crank-Nicolson
    method are $6.109 and $4.2778, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together – implied volatility modeling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the option pricing methods we have learned so far, a number of parameters
    are assumed to be constant: interest rates, strike prices, dividends, and volatility.
    Here, the parameter of interest is volatility. In quantitative research, the volatility
    ratio is used to forecast price trends.'
  prefs: []
  type: TYPE_NORMAL
- en: To derive implied volatilities, we need to refer to [Chapter 3](ae0a23e9-876c-43b3-9f48-d1d810f1fb97.xhtml)*,
    Nonlinearity in Finance*, where we discussed the root-finding methods of nonlinear
    functions. We will use the bisection method of numerical procedures in our next
    example to create an implied volatility curve.
  prefs: []
  type: TYPE_NORMAL
- en: Implied volatilities of the AAPL American put option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s consider the option data of the stock **Apple** (**AAPL**), which was
    gathered at the end of the day on October 3, 2014\. These details are provided
    in the following table. The option expires on December 20, 2014\. The prices listed
    are the mid-points of the bid and ask prices:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Strike price** | **Call price** | **Put price** |'
  prefs: []
  type: TYPE_TB
- en: '| 75 | 30 | 0.16 |'
  prefs: []
  type: TYPE_TB
- en: '| 80 | 24.55 | 0.32 |'
  prefs: []
  type: TYPE_TB
- en: '| 85 | 20.1 | 0.6 |'
  prefs: []
  type: TYPE_TB
- en: '| 90 | 15.37 | 1.22 |'
  prefs: []
  type: TYPE_TB
- en: '| 92.5 | 10.7 | 1.77 |'
  prefs: []
  type: TYPE_TB
- en: '| 95 | 8.9 | 2.54 |'
  prefs: []
  type: TYPE_TB
- en: '| 97.5 | 6.95 | 3.55 |'
  prefs: []
  type: TYPE_TB
- en: '| 100 | 5.4 | 4.8 |'
  prefs: []
  type: TYPE_TB
- en: '| 105 | 4.1 | 7.75 |'
  prefs: []
  type: TYPE_TB
- en: '| 110 | 2.18 | 11.8 |'
  prefs: []
  type: TYPE_TB
- en: '| 115 | 1.05 | 15.96 |'
  prefs: []
  type: TYPE_TB
- en: '| 120 | 0.5 | 20.75 |'
  prefs: []
  type: TYPE_TB
- en: '| 125 | 0.26 | 25.8 |'
  prefs: []
  type: TYPE_TB
- en: The last traded price of AAPL was 99.62, with an interest rate of 2.48 percent
    and a dividend yield of 1.82 percent. The American options expire in 78 days.
  prefs: []
  type: TYPE_NORMAL
- en: Using this information, let's create a new class named `ImpliedVolatilityModel`
    that accepts the stock option's parameters in the constructor. If required, import
    the `BinomialLROption` class that we created for the LR binomial tree we covered
    in the earlier section of this chapter, *A class for the LR binomial tree option
    pricing model*. The `bisection` function we covered in [Chapter 3](ae0a23e9-876c-43b3-9f48-d1d810f1fb97.xhtml)*,
    Nonlinearity in Finance*, is also required.
  prefs: []
  type: TYPE_NORMAL
- en: The `option_valuation()` method accepts the `K` strike price and the `sigma`
    volatility value to compute the value of the option. In this example, we are using
    the `BinomialLROption` pricing method.
  prefs: []
  type: TYPE_NORMAL
- en: The `get_implied_volatilities()` method accepts a list of strike and option
    prices to compute the implied volatilities by the `bisection` method for every
    price available. Therefore, the length of the two lists must be the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code for the `ImpliedVolatilityModel` class is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the `bisection` function we discussed in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this model, let''s find out the implied volatilities of the American
    put options using this particular set of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The implied volatility values are now stored in the `impvols_put` variable
    as a `list` object. Let''s plot these values against the strike prices to obtain
    an implied volatility curve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This would give us the volatility smile, as shown in the following diagram.
    Here, we have modeled an LR tree with 77 steps, with each step representing one
    day:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f5e906bf-b5cc-4c74-bc7a-1881acfd58e2.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, pricing an option daily may not be ideal since markets change by
    fractions of a millisecond. We used the bisection method to solve the implied
    volatility as implied by the binomial tree, as opposed to the realized volatility
    values directly observed from market prices.
  prefs: []
  type: TYPE_NORMAL
- en: Should we fit this curve against a polynomial curve to identify potential arbitrage
    opportunities? Or extrapolate the curve to derive further insights on potential
    opportunities from implied volatilities of far out-of-the-money and in-the-money
    options? Well, these questions are for option traders like yourself to find out!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at a number of numerical procedures in derivative
    pricing, the most common being options. One such procedure is the use of trees,
    with binomial trees being the simplest structure to model asset information, where
    one node extends to two other nodes in each time step, representing an up state
    and a down state, respectively. In trinomial trees, each node extends to three
    other nodes in each time step, representing an up state, a down state, and a state
    with no movement, respectively. As the tree traverses upwards, the underlying
    asset is computed and represented at each node. The option then takes on the structure
    of this tree and, starting from the terminal payoffs, the tree traverses backward
    and toward the root, which converges to the current discounted option price. Besides
    binomial and trinomial trees, trees can take on the form of the CRR, Jarrow-Rudd,
    Tian, or LR parameters.
  prefs: []
  type: TYPE_NORMAL
- en: By adding another layer of nodes around our tree, we introduced additional information
    from which we can derive the Greeks, such as the delta and gamma, without incurring
    additional computational costs.
  prefs: []
  type: TYPE_NORMAL
- en: Lattices were introduced as a way of saving storage costs over binomial and
    trinomial trees. In lattice pricing, nodes with new information are saved only
    once and reused later on nodes that require no change in the information.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed the finite difference schemes in option pricing, consisting
    of terminal and boundary conditions. From the terminal conditions, the grid traverses
    backward in time using the explicit method, implicit method, and the Crank- Nicolson
    method. Besides pricing European and American options, finite difference pricing
    schemes can be used to price exotic options, where we looked at an example of
    pricing a down-and-out barrier option.
  prefs: []
  type: TYPE_NORMAL
- en: By importing the bisection root-finding method learned about in [Chapter 3](ae0a23e9-876c-43b3-9f48-d1d810f1fb97.xhtml)*,
    Nonlinearity in Finance*, and the binomial LR tree model in this chapter, we used
    market prices of an American option to create an implied volatility curve for
    further studies.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at modeling interest rates and derivatives.
  prefs: []
  type: TYPE_NORMAL
