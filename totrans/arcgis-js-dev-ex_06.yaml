- en: Chapter 6. Working with Real-Time Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data that are updated constantly presents us with a significant challenge in
    retrieving and rendering them. In this chapter, we will deal with two basic methods
    to work with real-time data by developing an application that is meant to track
    hurricanes. You will learn about the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand about the nature of real-time data such as hurricane data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the in-built options given by ArcGIS to visualize the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods to get the latest data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods to set the refresh interval for a layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background about the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to deal with hurricane data provided by the National Hurricane
    Center (NHC). The NHC provides a map service that describes the path and forecast
    of tropical hurricane activity. The live feeds provided as a map service by the
    NHC can be found at [http://livefeeds.arcgis.com/arcgis/rest/services/LiveFeeds/Hurricane_Active/MapServer](http://livefeeds.arcgis.com/arcgis/rest/services/LiveFeeds/Hurricane_Active/MapServer).
  prefs: []
  type: TYPE_NORMAL
- en: 'The map service provides data about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Forecast Position**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observed Position**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forecast Track**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observed Track**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Cone of Uncertainty**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Watches and Warnings**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tropical Storm Force**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The forecast and observed positions represent the center of the cyclone, whereas
    the track represents forecast and observed positions connected to give a sense
    of the movement of the hurricane.
  prefs: []
  type: TYPE_NORMAL
- en: '![Background about the application](graphics/B04959_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the **Service Catalog** heading, click **ArcGIS.com Map** to get a holistic
    perspective of the data in the map service.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing map data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ArcGIS Online is an effective medium to visualize and play with data hosted
    on ArcGIS Server. When opening a map service in ArcGIS Online, the default symbology
    is displayed and we can get a sense of the extent of the data we would be using
    in our application.
  prefs: []
  type: TYPE_NORMAL
- en: In the following screenshot, we can see the **Forecast Position** feature layer
    and its default symbology. The symbology being used is PictureMarkerSymbol and
    it gives a sense of what is the intensity of the hurricane over the past three
    days (72 hours).
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing map data](graphics/B04959_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot gives a holistic picture of the entire data in the
    map service including forecast locations and track, as well as observed locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing map data](graphics/B04959_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Turn off all the layers in the Table of Contents (TOC) and turn on just the
    **Observed Position** layer. The **Observed Position** layer is just rendered
    by just a simple Renderer. The symbology doesn't vary in size according to any
    field value. It just shows the locations where storm activity was measured in
    the past 72 hours.
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing map data](graphics/B04959_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now ArcGIS Online gives us options to set its symbology in various ways. When
    we click the layer''s name in the TOC, the following screen opens up. It shows
    various styles based on which symbology can be changed. In the following screenshot,
    **INTENSITY** of the storm is chosen as the field of display, and the size of
    the symbol is based on the quantity of the **INTENSITY** value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing map data](graphics/B04959_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The data can be classified into groups according to various classification techniques
    such as **Equal Breaks**, **Quantile**, **Natural Breaks**, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing map data](graphics/B04959_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, the **Observed Track** actually shows the track taken by the hurricane
    over the past 72 hours and uses a unique value renderer to render the data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing map data](graphics/B04959_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building a hurricane tracking app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have gained an understanding of our data using the ArcGIS Online
    service, we can use the map service URL to build a web mapping application of
    our own. In our application, we intend to incorporate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add layers to the map that displays the past and present hurricane locations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add global wind data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a gauge widget to display the wind speed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a current weather widget, which displays the current weather information
    at the user's browser location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a **Current Hurricane List** widget, which shows the updated list of current
    hurricanes and the details of each hurricane when selected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbolizing active hurricane layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have more than one feature layer to deal with. Let''s try to build a layer
    dictionary. In the following code snippet, we will try to create an array of objects
    where each object has properties such as a URL and title. The URL refers to the
    URL of a feature layer and the title property refers to the title by which we
    would like to refer to the feature layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This helps us retrieve the feature layer using the layer name or title property.
    Let''s use the `array.map()` method provided by the `dojo/_base/array` module
    to add the corresponding feature layer for each object into the `layerDict` array.
    The `array.map()` method, if you can recollect from [Chapter 1](ch01.html "Chapter 1. Foundation
    for the API"), *Foundation for the API*, actually iterates through the elements
    in the array and will return an array. Then, each item being iterated can be modified.
    In our case we are trying to do the following for each item:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a feature layer from the URL in each item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the feature layer to the map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an additional layer property to each item object in the `layerDict` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code snippet explains the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now each object in the `layerDict` array will have an additional layer property,
    which holds the feature layer referred by the URL.
  prefs: []
  type: TYPE_NORMAL
- en: To retrieve a feature layer, we can use the layer name in the `array.filter()`
    method provided by the `dojo/_base/array` module. The filter `method()` iterates
    through each object item and returns a filtered array based on our predicate condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line of code returns the feature layer with the title `"Forecast
    Error Cone"` and saves it in the variable named `foreCastErrorConeFeatureLayer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We are trying to symbolize the features in some of the feature layers. We will
    start off with the past positions. The past positions feature a layer, which by
    default is represented by a circle with a dot in the center. We will try to use
    a red flag to symbolize it. The following approach shall be taken to symbolize
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `esri/symbols/PictureMarkerSymbol` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the URL for a PNG representing a red flag and use it to create a `PictureMarkerSymbol`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `esri/renderers/SimpleRenderer` module and create a `SimpleRenderer`
    assigning the symbol for the renderer with the `PictureMarkerSymbol` we just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the renderer for the feature layer with the simple renderer we just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following lines of code explain this process clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can try and render the forecast error cones layer. Forecast error cones
    are polygon feature layers that represent the uncertainty in the forecast predictions.
    Two polygon features are present for each hurricane type. One of the polygon represents
    a 72-hour forecast error polygon and the other represents a 120-hour forecast
    error polygon. This information is available in the `FCSTPRD` field in the feature
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a unique value renderer and symbolize each of these types of
    polygon differently based on the value of the `FCSTPRD` field name. To create
    a unique value renderer, we need to take the following approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `esri/renderers/UniqueValueRenderer`, `esri/symbols/SimpleLineSymbol`
    and `esri/symbols/SimpleFillSymbol` modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a default symbol for the renderer. Since we know that with all our `Forecast
    Error` polygons the `FCSTPRD` field value will be either `72` or `120`, we will
    create a `SimpleFillSymbol` with empty symbology and also set its outline as null
    line symbol.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `UniqueValueRenderer` object from the `esri/renderers/UniqueValueRenderer`
    module. Assign it the default symbology we just created as well as the `FCSTPRD`
    as the fieldname upon which the rendering is based.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add values to the renderer using the `addValue()` method. The `addValue()` method
    accepts the unique value (`72` /`120`) and the corresponding symbol for each unique
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the renderer to the `Forecast Error Cone Feature layer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We have tried symbolizing a feature layer with `PictureMarkerSymbol` and render
    it using `SimpleRenderer`. For another feature layer, we used a unique value renderer
    to render features having different values for a particular field differently.
    Now let's try a special kind of symbology known as `CartographicLineSymbol`.
  prefs: []
  type: TYPE_NORMAL
- en: The `CartographicLineSymbol` provides additional properties such as cap and
    join, which defines how the end cap of the lines and the edge joins are rendered.
    To know more about these two properties, visit the API page at [https://developers.arcgis.com/javascript/jsapi/cartographiclinesymbol-amd.html](https://developers.arcgis.com/javascript/jsapi/cartographiclinesymbol-amd.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like to use the `CartographicLineSymbol` to symbolize the forecast
    track feature layer. The following shows us how to use the symbol and to render
    the particular feature layer:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `esri/symbols/CartographicLineSymbol` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `STYLE_DASHDOT` for the style parameter, yellow for the color parameter,
    `5` as the width in pixels, `CAP_ROUND` as the cap type, and `JOIN_MITER` as the
    join type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the symbol for a `SimpleRenderer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the renderer to the forecast track feature layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following snippet codifies the previous approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our map looks like the following when the previous renderers are applied to
    the past positions layer, **Forecast Track**, and the **Forecast Error Cone**
    layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Symbolizing active hurricane layers](graphics/B04959_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding a global wind data gauge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Global wind data is also a map service provided by the ArcGIS livefeeds, providing
    global-level wind data at various locations. Our objective is to incorporate a
    gauge widget that changes its gauge reading based on the wind location being hovered
    upon. The wind data has been appropriately symbolized by default.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows a gauge widget based on our global wind data.
    The arrows in the map are wind feature locations, the direction of the arrow represents
    the direction of the wind, and the color and size of the arrow represents the
    speed of the wind. The gauge reading in the two instances represents the feature
    being hovered upon (which is highlighted by a thick yellow circle).
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a global wind data gauge](graphics/B04959_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The URL for the wind data has been provided in one of our earlier snippets
    and has been added to the `layerDict` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this URL has been added to the `layerDict` array already, we can go ahead
    and create a feature layer representing the wind data from its title `"Wind Data"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's now add a gauge widget that can harness the data from this layer. The
    gauge is provided by an Esri `dijit` (dojo widget) named `esri/dijit/Gauge`. The
    gauge constructor is very simple. It accepts a `GaugeParameter` object and the
    container dom ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GaugeParameter` object needs to be constructed by us. Keep the following
    in mind before creating the `GaugeParameter` object:'
  prefs: []
  type: TYPE_NORMAL
- en: The `layer` property accepts the reference to the feature layer it represents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `dataField` property indicates which field shall be used to get the gauge
    reading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `dataFormat` property accepts two values—`value` or `percent`. When percent
    is chosen, the maximum value of the gauge is automatically calculated and the
    gauge reading is shown as a percentage of the maximum value. When the `dataFormat`
    value is chosen as `value`, the actual value of the feature being hovered upon
    is shown as the gauge reading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `dataLabelField` property can be used to represent the station name or any
    other ancillary property about the feature being hovered upon, which can identify
    the feature. This shall be clubbed with the `title` property, which represents
    what the `dataLabelField` property represents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `color` property lets us set the color of the gauge reading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `value` is chosen as the `dataFormat` value, we need to provide a value for
    the `maxDataValue` property as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code is the one we used to create the wind gauge widget you saw
    in the previous screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tracking the latest active hurricanes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a widget to track the latest active hurricanes. We already have
    all the layers representing the active hurricanes positions. Our objective is
    to get all the latest positions of active hurricanes and display it in a widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how our widget would look after development:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tracking the latest active hurricanes](graphics/B04959_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The dropdown in the widget lists the names of all the prevalent active hurricanes.
    The following grid displays the details of the selected hurricane.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following thought process has been incorporated into the development of
    this widget:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a cache-bust query to get the unique list of storm names and fill the dropdown
    with this list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On selection change of the dropdown, get the latest feature for the selected
    storm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populate the details of the selected storm in the widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the updated details for every 30 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting a unique list of storms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get the unique values in our data, the Query object has a property known
    as `returnDistinctValues`, the value for which should be a Boolean `true`. The
    following snippet explains the usage of the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Also the outfield property of the Query object should only list those fields
    for which the unique values are required. In our case, the fieldname is `STORMNAME`.
    Refer to the following snippet to understand this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To get updated results every time, we need to avoid cached query results. So
    instead of using a truthy expression such as `1=1`, we may need to use a pattern
    that reads something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will help us get non-cached query results. Non-cached query results ensure
    that we are viewing the latest data within a set time period. Let''s write a function
    that can create such a query string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use this function every time we need to assign a value for the `where`
    property of the Query object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When using the `returnDistinctValues` property in the Query object, we need
    to set the `returnGeometry` property to a Boolean `false`. The following line
    of code explains how to form the Query task and Query object, and how to use the
    result from the query to populate the drop-down box. At the end of the code we
    would call a .`_update_hutticane_details()` method. This method fetches the latest
    details about the selected `StormName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the previous lines of code, observe the last three lines. We are using a
    `timer` function that calls the `_update_hutticane_details()` every 30 seconds.
    This is the function that fetches the latest details about the hurricane.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching the latest data and displaying on the grid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we tried to construct the Query object in the previous snippet, we used
    the `returnDistinctValues` property to get the distinct values based on field
    names. Now we will use the `orderByFields` property of the Query object to order
    the features based on a field name. To get the latest features first, the fieldname
    should represent a time field. In our case the field name is `DTG`. To ensure
    that we get the latest time as the first feature of our query result, we can use
    the following line of code while constructing the query object. The `orderByField`
    accepts a string array, each item mentioning the field name to be ordered upon
    and whether the ordering should be ascending (`ASC`) or descending (`DESC`). The
    default order is ascending:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines of code demonstrate how the required Query object is constructed
    and how the result is used to populate information about the latest storm in the
    widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `where` clause in the previous chunk of code. We are selecting only
    the details of `StormName` that we have selected from the drop-down box, as well
    as using the cache-busting function to get the latest data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Refreshing feature layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The feature layer displaying time data may need to refresh at various intervals.
    We can use feature layers to refresh an interval property to set this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is in addition to the cache-busting techniques we dealt with earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a weather widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will try to create a weather widget in our application, which displays the
    current weather conditions at the user''s location. The user''s location actually
    means the browser''s location as recognized by the Geolocation API in modern browsers.
    When the browser is unable to find the user''s location, we will try to find the
    weather data for the center of the map. Creating a weather widget presents us
    with the following opportunities as well as challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: Weather data is continuously updated in real time and is a spatio-temporal phenomenon,
    meaning something that changes with place and time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It presents us with an opportunity to use an external weather API, which is
    a non-ArcGIS based data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It presents us with an opportunity to explore the client-side geometric operations
    such as buffer and converting between Geographic and Web Mercator coordinates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The open weather API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to find a data source to fetch the latest weather data. Fortunately,
    the open weather API is a simple and free option to fetch weather data in different
    formats. Paid plans provide greater usage levels. For our purposes the free version
    works splendidly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API provides REST endpoints, which provides access to the following kinds
    of data:'
  prefs: []
  type: TYPE_NORMAL
- en: Current weather data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5-day/3-hour forecast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5-day/3-hour forecast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Historical data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UV Index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weather map layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weather stations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be using the current weather data endpoint to fetch the weather details
    for a given location.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the API you need to sign up for an API key. The following URL explains
    how to get an `appid` and use it in the REST queries: [http://openweathermap.org/appid#get](http://openweathermap.org/appid#get).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The base URL we would be using would be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be providing the latitude and longitude values to issue the request
    to the open weather API. We have tried to make the HTTP `GET` request using the
    `esriRequest` object for which the `esri/request` module needs to be imported.
    The following snippet explains how the `esriRequest` object was constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you observe the URL being constructed, it required three parameters, namely
    `lat`, `lon,` and `appid`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `appid` parameter accepts the application key that we generated earlier.
    There are two methods we are going to follow to get the latitude and longitude
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: If the Geolocation API is supported by the browser, get the latitude and longitude
    values from the browser's location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the Geolocation API is not supported by the browser, the map extent's centroid
    shall be projected to geographic coordinates and used to fetch the weather data
    for that location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the Geolocation API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the Geolocation API is as simple as a call to the navigator object''s
    `geolocation.getCurrentPosition()` method. The method returns a callback object,
    which contains the location of the browser. The following lines of code show how
    to call the `geolocation` API to get the current position of the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, the call object is a function by the name of `showPosition()`.
    The `showPosition()` function gets the position as the callback object. The coordinates
    of the position can be accessed by using the property `coords`.
  prefs: []
  type: TYPE_NORMAL
- en: Using geometry engine on input data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `coords` object gives three properties, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '`latitude`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`longitude`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`accuracy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We clearly understand what the latitude and longitude are, but what is accuracy?
    Accuracy is the numeric quantity representing a possible error in meters with
    the coordinates being provided by the API. Or, in other words, the location is
    accurate within a circle of error. When we mention that it''s a circle of error,
    wouldn''t it be nice to visualize it on our map, so that we know the approximate
    location of our browser and maybe corroborate the results. We tried it; it seems
    pretty accurate. To create a circle of error, we took the following approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the latitude and longitude values to create a point geometry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `webMercatorUtils` provided by the API to convert the point from geographic
    coordinates to the Web Mercator coordinates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `geometryEngine` module provided by the API, create a buffer around
    the projected point with the buffer radius equal to the accuracy of the location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Symbolize the buffer geometry using a `SimpleFillSymbol`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following lines of code explain the previous process clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We would be using the latitude and longitude obtained from the `showPosition()`
    method to fetch the weather data for that location.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the weather data in the widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We earlier visited how we used the `esriRequest` module to issue an HTTP GET
    request to the weather API and request for the current weather data at the latitude
    and longitude provided by the browser. The request is a promise and we will use
    a `then` method upon the promise to resolve it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following chunk of code demonstrates how the `esriRequest` promise is resolved
    and how it is used to display the current weather data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, the temperature is always returned in kelvin. So to convert
    it to centigrade, we need to subtract it by `270`. The time conversions are being
    applied using the function named `_processDate()`. The time issued by the open
    weather API is Unix base time in UTC.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `_processDate()` function we wrote looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `dateLocale` object used in the previous function is a dojo module (`dojo/date/locale`),
    which provides localized time versions of the `date` object being dealt with.
    The widget looks like the following screenshot shown. The red circle is the circle
    of error we were talking about. We were also able to create a small weather icon,
    which summarizes the weather condition.
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying the weather data in the widget](graphics/B04959_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you''re curious what the HTML template for the previous widget would look
    like, we have one thing to say—have we disappointed you? Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The innocuous HTML template was all we needed to develop the weather widget,
    which we used to display the current weather data at our location.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered in detail what constitutes real-time data and
    how to visualize and get the latest features. We will be dealing with how to deal
    with time-aware layers and how to visualize spatio-temporal layers in later chapters.
    Thus, we will be able to build effective web applications that are refreshed continuously.
    In the following chapters, we will be dealing with advanced visualization techniques
    using the statistical capabilities of the feature layer, and learning about charting
    libraries.
  prefs: []
  type: TYPE_NORMAL
