- en: Nonlinearity in Finance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent years, there has been a growing interest in research on nonlinear
    phenomena in economic and financial theory. With nonlinear serial dependence playing
    a significant role in the returns of many financial time series, this makes security
    valuation and pricing very important, leading to an increase in studies on the
    nonlinear modeling of financial products.
  prefs: []
  type: TYPE_NORMAL
- en: Practitioners in the financial industry use nonlinear models to forecast volatility,
    price derivatives, and compute **Value at Risk** (**VAR**). Unlike linear models,
    where linear algebra is used to find a solution, nonlinear models do not necessarily
    infer a global optimal solution. Numerical root-finding methods are usually employed
    to converge toward the nearest local optimal solution, which is a root.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Nonlinearity modeling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of nonlinear models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Root-finding algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SciPy implementations in root-finding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nonlinearity modeling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While linear relationships aim to explain observed phenomena in the simplest
    way possible, many complex physical phenomena cannot be explained using such models.
    A nonlinear relationship is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4155a161-47cc-4585-b881-1544650269c4.png)'
  prefs: []
  type: TYPE_IMG
- en: Even though nonlinear relationships may be complex, to fully understand and
    model them, we will take a look at the examples that are applied in the context
    of finance and in time-series models.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of nonlinear models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many nonlinear models have been proposed for academic and applied research
    to explain certain aspects of economic and financial data that are left unexplained
    by linear models. The literature on nonlinearity in finance is simply too broad
    and deep to be adequately explained in this book. In this section, we will briefly
    discuss some examples of nonlinear models that we may come across for practical
    uses: the implied volatility model, Markov switching model, threshold model, and
    smooth transition model.'
  prefs: []
  type: TYPE_NORMAL
- en: The implied volatility model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps one of the most widely-studied option-pricing models is the Black-Scholes-Merton
    model, or simply the Black-Scholes model. A call option is a right, but not an
    obligation, to buy the underlying security at a particular price and time. A put
    option is a right, but not an obligation, to sell the underlying security at a
    particular price and time. The Black-Scholes model helps determine the fair price
    of an option with the assumption that the returns of the underlying security are
    normally distributed (N(.)) or that asset prices are log-normally distributed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The formula takes on the following assumed variables—the strike price (*K*),
    the time to expiry (*T*), the risk-free rate (*r*), the volatility of the underlying
    returns (σ), the current price of the underlying asset (*S*), and its yield (*q*).
    The mathematical formula for a call option, *C*(*S,t*), is represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/af298b08-2488-4b90-aa40-4455d4c604a0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/223c14fe-493f-4a93-98df-66b36a3d97fd.png)'
  prefs: []
  type: TYPE_IMG
- en: By way of market forces, the price of an option may deviate from the price that's
    been derived from the Black-Scholes formula. In particular, the realized volatility
    (that is, the observed volatility of the underlying returns from historical market
    prices) could differ from the volatility value as implied by the Black-Scholes
    model, which is indicated by σ.
  prefs: []
  type: TYPE_NORMAL
- en: Think back to the **Capital Asset Pricing Model **(**CAPM**) discussed in [Chapter
    2](7b247a98-9fcc-4ec8-8d5d-3c5b77353f38.xhtml)*, The Importance of Linearity in
    Finance*. In general, securities that have higher returns exhibit higher risk,
    as indicated by the volatility or standard deviation of returns.
  prefs: []
  type: TYPE_NORMAL
- en: With volatility being such an important factor in security pricing, many volatility
    models have been proposed for studies. One such model is the implied volatility
    modeling of option prices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we plot the implied volatility values of an equity option given by
    the Black-Scholes formula with a particular maturity for every strike price available.
    In general, we get a curve commonly known as the **volatility smile** due to its
    shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4db85299-43b0-4706-8202-7f67684526a4.png)'
  prefs: []
  type: TYPE_IMG
- en: The **Implied volatility** typically is at its highest for deep in-the-money and
    out-of-the-money options driven by heavy speculation and at its lowest for at-the-money
    options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The characteristics of options are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**In-the-money options** (**ITM**): A call option is considered ITM when its
    strike price is below the market price of the underlying asset. A put option is
    considered ITM when its strike price is above the market price of the underlying
    asset. ITM options have an intrinsic value when exercised.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Out-of-the-money options** (**OTM**): A call option is considered OTM when
    its strike price is above the market price of the underlying asset. A put option
    is considered OTM when its strike price is below the market price of the underlying
    asset. OTM options have no intrinsic value when exercised, but may still have
    time value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**At-the-money options** (**ATM**): An option is considered ATM when its strike
    price is the same as the market price of the underlying asset. ATM options have
    no intrinsic value, but may still have time value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the preceding volatility curve, one of the objectives in implied volatility
    modeling is to seek the lowest implied volatility value possible or, in other
    words, to *find the root*. When found, the theoretical price of an ATM option
    for a particular maturity can be deduced and compared against the market prices
    for potential opportunities, such as for studying near ATM options or far OTM
    options. However, since the curve is nonlinear, linear algebra cannot adequately
    solve the root. We will take a look at a number of root-finding methods in the
    next section, *Root-finding algorithms*.
  prefs: []
  type: TYPE_NORMAL
- en: The Markov regime-switching model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To model nonlinear behavior in economic and financial time series, Markov switching
    models can be used to characterize time series in different states of the world
    or regimes. Examples of such states could be a *volatile* state, as seen in the
    2008 global economic downturn, or the *growth* state of a steadily recovering
    economy. The ability to transition between these structures lets the model capture
    complex dynamic patterns.
  prefs: []
  type: TYPE_NORMAL
- en: The Markov property of stock prices implies that only the present values are
    relevant for predicting the future. Past stock-price movements are irrelevant
    to the way the present has emerged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example of a Markov regime-switching model with *m=2* regimes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1c381167-4141-4ef1-a642-e548fb4c7a63.png)'
  prefs: []
  type: TYPE_IMG
- en: 'ϵ[t] is an **independent and identically-distributed** (**i**.**i**.**d**)
    white noise. White noise is a normally-distributed random process with a mean
    of zero. The same model can be represented with dummy variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/469acdb8-a49c-4eb9-ada9-60b87503044b.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/c1bda288-73f1-4b27-82f9-0ad7cf0102ef.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/3b35aee2-f2f3-48ad-b857-0dc351aa1af2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The application of Markov switching models includes representing the real GDP
    growth rate and inflation rate dynamics. These models in turn drive the valuation
    models of interest-rate derivatives. The probability of switching from the previous
    state, *i*, to the current state, *j*, can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9c728e76-fddf-4295-9ca0-cf169522a08d.png)'
  prefs: []
  type: TYPE_IMG
- en: The threshold autoregressive model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One popular class of nonlinear time series models is the **threshold autoregressive**
    (**TAR**) model, which looks very similar to the Markov switching models. Using
    regression methods, simple AR models are arguably the most popular models to explain
    nonlinear behavior. Regimes in the threshold model are determined by past, *d*,
    values of its own time series, relative to a threshold value, *c*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a **self-exciting TAR** (**SETAR**) model. The
    SETAR model is self-exciting because switching between different regimes depends
    on the past values of its own time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/19032cd6-d384-436e-9753-fc1c5ef40731.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using dummy variables, the SETAR model can also be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/02286653-b81d-4261-bbda-9d813b845e68.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/826e2e31-0e85-4aa7-97d8-6d4747cff9c4.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/dba92602-e4e1-4eda-9594-3a5d40877cd0.png)'
  prefs: []
  type: TYPE_IMG
- en: The use of the TAR model may result in sharp transitions between the states
    as controlled by the threshold variable, *c*.
  prefs: []
  type: TYPE_NORMAL
- en: Smooth transition models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Abrupt regime changes in the threshold models appear to be unrealistic against
    real-world dynamics. This problem can be overcome by introducing a smoothly-changing
    continuous function from one regime to another. The SETAR model becomes a **logistic
    smooth transition threshold autoregressive** (**LSTAR**) model with the logistic
    function of *G(y[t−1];γ,c)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/98085bf4-eeb1-4eda-aeac-d2c76e2c4d43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The SETAR model now becomes an LSTAR model, as shown in the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/bfc7c90a-2e13-4be8-a8b2-85775744c094.png)'
  prefs: []
  type: TYPE_IMG
- en: The γ parameter controls the smooth transition from one regime to another. For
    large values of γ, the transition is the fastest, as *y[t−d]* approaches the threshold
    variable, *c*. When γ=0, the LSTAR model is equivalent to a simple *AR(1)* one-regime
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Root-finding algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, we discussed some nonlinear models commonly used for
    studying economics and financial time series. From the model data given in continuous
    time, the intention is therefore to search for the extrema that could possibly
    infer valuable information. The use of numerical methods, such as root-finding
    algorithms, can help us find the roots of a continuous function, *f*, such that
    *f(x)=0*, which can either be the maxima or the minima of the function. In general,
    an equation may either contain a number of roots or none at all.
  prefs: []
  type: TYPE_NORMAL
- en: One example of the use of root-finding methods on nonlinear models is the Black-Scholes
    implied volatility modeling discussed earlier, in *The implied volatility model*
    section. An option trader would be interested in deriving implied prices based
    on the Black-Scholes model and comparing them with market prices. In the next
    chapter, [Numerical Methods for Pricing Options](bd8dfd19-c025-4223-8d5e-b7c7893874c3.xhtml),
    we will see how we can combine a root-finding method with a numerical-option pricing
    procedure to create an implied volatility model based on the market prices of
    a particular option.
  prefs: []
  type: TYPE_NORMAL
- en: Root-finding methods use an iterative routine that requires a start point or
    the estimation of the root. The estimation of the root can either converge toward
    a solution, converge to a root that is not sought, or may not even find a solution
    at all. Thus, it is crucial to find a good approximation to the root.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not every nonlinear function can be solved using root-finding methods. The
    following figure shows an example of a continuous function, ![](Images/92660661-9bf5-4f04-853c-19418fd6f079.png),
    where root-finding methods may fail to arrive at a solution. There are discontinuities
    at *x=0* and *x=2* for the *y* values in the range of -20 to 20:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7068c1c2-39af-41ff-9aa9-ac25775958eb.png)'
  prefs: []
  type: TYPE_IMG
- en: There is no fixed rule as to how a good approximation can be defined. It is
    recommended that you bracket or define the lower and upper search bounds before
    starting the root-finding iterative procedure. We certainly do not want to keep
    searching endlessly in the wrong direction for our root.
  prefs: []
  type: TYPE_NORMAL
- en: Incremental search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A crude method of solving a nonlinear function is by doing an incremental search.
    Using an arbitrary starting point, *a*, we can obtain values of *f(a)* for every
    increment of *dx*. We assume that the values of *f*(*a+dx*), *f*(*a+2dx*), *f*(*a+3dx*)…
    are going in the same direction as indicated by their sign. Once the sign changes,
    a solution is deemed as found. Otherwise, the iterative search terminates when
    it crosses the boundary point, *b*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A pictorial example of the root-finder method for iteration is given in the
    following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/49efa5b2-fb95-44f7-a82b-9634de40256a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An example can be seen from the following Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: At every iterative procedure, `a` will be replaced by `c`, and `c` will be incremented
    by `dx` before the next comparison. Should a root be found, it is plausible that
    it lies between `a` and `c`, both inclusive. In the event that the solution does
    not rest at either point, we will simply return the average of the two points
    as the best estimation. The *n* variable keeps track of the number of iterations
    that underwent the process of finding our root.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the equation that has an analytic solution of ![](Images/64e18993-4c00-4174-9dcd-0bfdf3a7583e.png)
    to demonstrate and measure our root-finder, where *x* is bounded between -5 and
    5\. A small *dx* value of 0.001 is given, which also acts as a precision tool.
    Smaller values of *dx* produce better precision but also require more search iterations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The incremental search root-finder method is a basic demonstration of the fundamental
    behavior of a root-finding algorithm. The accuracy is at its best when defined
    by *dx*, and consumes an extremely long computational time in the worst possible
    scenario. The higher the accuracy demanded, the longer it takes for the solution
    to converge. For practical reasons, this method is the least preferred of all
    root-finding algorithms, and we will take a look at alternative methods to find
    the roots of our equation that can give us better performance.
  prefs: []
  type: TYPE_NORMAL
- en: The bisection method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bisection method is considered the simplest one-dimensional root-finding
    algorithm. The general interest is to find the value, *x*, of a continuous function, *f*,
    such that *f(x)=0*.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we know the two points of an interval, *a* and *b*, where *a* < *b*,
    and that *f(a)<0* and *f(b)>0* lie along the continuous function, taking the midpoint
    of this interval as *c*, where ![](Images/12ba4631-1b1e-4281-9d52-2204938de47d.png); the
    bisection method then evaluates this value as *f(c)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s illustrate the setup of points along a nonlinear function with the following
    graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6ecf4f90-5e2b-4d10-a867-cdc235884bf3.png)'
  prefs: []
  type: TYPE_IMG
- en: Since the value of *f(a)* is negative and *f(b)* is positive, the bisection
    method assumes that the root, *x*, lies somewhere between *a* and *b* and gives
    *f(x)=0*.
  prefs: []
  type: TYPE_NORMAL
- en: If *f(c)=0* or is very close to zero by some predetermined error-tolerance value,
    a root is declared as found. If *f(c)<0*, we may conclude that a root exists along
    the *c* and *b* interval, or the *a* and *c* interval otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: In the next evaluation, *c* is replaced as either *a* or *b* accordingly. With
    the new interval shortened, the bisection method repeats with the same evaluation
    to determine the next value of *c*. This process continues, shrinking the width
    of the *ab* interval until the root is considered found.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest advantage of using the bisection method is its guarantee to converge
    to an approximation of the root, given a predetermined error-tolerance level and
    the maximum number of iterations allowed. It should be noted that the bisection
    method does not require knowledge of the derivative of the unknown function. In
    certain continuous functions, the derivative could be complex or even impossible
    to calculate. This makes the bisection method extremely valuable for working on
    functions that are not smooth.
  prefs: []
  type: TYPE_NORMAL
- en: Because the bisection method does not require derivative information from the
    continuous function, its major drawback is that it takes up more computational
    time in the iterative evaluation than other root-finder methods. Also, since the
    search boundary of the bisection method lies in the *a* and *b* intervals, it
    would require a good approximation to ensure that the root falls within this range.
    Otherwise, an incorrect solution may be obtained, or even none at all. Using large
    values of *a* and *b* might consume more computational time.
  prefs: []
  type: TYPE_NORMAL
- en: The bisection is considered to be stable without the use of an initial guess
    value for convergence to happen. Often, it is used in combination with other methods,
    such as the faster Newton's method, to converge quickly with precision.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code for the bisection method is given as follows. Save this as
    `bisection.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Again, we bounded the anonymous `lambda` function to the `y` variable with an
    input parameter, `x`, and attempted to solve the ![](Images/8f4c7e93-c309-4a2d-93ff-ad18aab35ca9.png) equation
    as before, in the interval between -5 to 5 to an accuracy of 0.00001 with a maximum
    iteration of 100.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the result from the bisection method gives us better precision
    in far fewer iterations over the incremental search method.
  prefs: []
  type: TYPE_NORMAL
- en: Newton's method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Newton''s method**, also known as the **Newton-Raphson method**, uses an
    iterative procedure to solve for a root using information about the derivative
    of a function. The derivative is treated as a linear problem to be solved. The
    first-order derivation, *f′*, of the function, *f*, represents the tangent line.
    The approximation to the next value of *x*, given as *x[1]*, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/83f6a2db-d36c-4456-9e65-b66aa64f69c7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, the tangent line intersects the *x* axis at *x[1]*, which produces *y=0*.
    This also represents the first-order Taylor expansion about *x[1]*, such that
    that the new point, *![](Images/098dae2a-368f-42ca-8d70-e3a5d30631cf.png)*, solves
    the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3ad672d5-727a-4a6f-b135-19d2ce53e032.png)'
  prefs: []
  type: TYPE_IMG
- en: This process is repeated with *x* taking the value of *x[1]* until the maximum
    number of iterations is reached, or the absolute difference between *x[1]* and
    *x* is within an acceptable accuracy level.
  prefs: []
  type: TYPE_NORMAL
- en: An initial guess value is required to compute the values of *f(x)* and *f'(x)*.
    The rate of convergence is quadratic, which is considered to be extremely fast
    at obtaining the solution with high levels of accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: The drawback to Newton's method is that it does not guarantee global convergence
    to the solution. Such a situation arises when the function contains more than
    one root, or when the algorithm arrives at a local extremum and is unable to compute
    the next step. As this method requires knowledge of the derivative of its input
    function, it is required that the input function be differentiable. However, in
    certain circumstances, it is impossible for the derivative of a function to be
    known, or otherwise be mathematically easy to compute.
  prefs: []
  type: TYPE_NORMAL
- en: 'A graphical representation of Newton''s method is shown in the following screenshot.
    *x[0]* is the initial *x* value. The derivative of *f(x[0])* is evaluated, which
    is a tangent line crossing the *x* axis at *x[1]*. The iteration is repeated,
    evaluating the derivative at points *x[1]*, *x[2]*, *x[3]*, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/44c5361f-e2b4-4a9b-a6bd-c8a6c45dc95b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The implementation of Newton''s method in Python is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the same function used in the bisection example and take a look
    at the results from Newton''s method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Beware of division by zero exceptions! In Python 2, using values such as 5.0,
    instead of 5, lets Python recognize the variable as a float, avoids the problem
    of treating variables as integers in calculations, and gives us better precision.
  prefs: []
  type: TYPE_NORMAL
- en: With Newton's method, we obtained a really close solution with less iteration
    over the bisection method.
  prefs: []
  type: TYPE_NORMAL
- en: The secant method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The secant method uses secant lines to find the root. A secant line is a straight
    line that intersects two points of a curve. In the secant method, a line is drawn
    between two points on the continuous function, such that it extends and intersects
    the *x* axis. This method can be thought of as a Quasi-Newton method. By successively
    drawing such secant lines, the root of the function can be approximated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The secant method is graphically represented in the following screenshot. An
    initial guess of the two *x* axis values, *a* and *b*, is required to find *f(a)*
    and *f(b)*. A secant line, *y*, is drawn from *f(b)* to *f(a)* and intersects
    at the *c* point on the *x* axis, such that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/204bd4e1-084d-49a8-a8d9-f1042d68d554.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The solution to *c* is therefore as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4f09d442-9dc2-4ce9-9422-09b1e5fdcaa6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the next iteration, *a* and *b* will take on the values of *b* and *c*,
    respectively. The method repeats itself, drawing secant lines for the *x* axis
    values of *a* and *b*, *b* and *c*, *c* and *d*, and so on. The solution terminates
    when the maximum number of iterations has been reached, or the difference between
    *b* and *c* has reached a pre-specified tolerance level, as shown in the following
    graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e525602d-220b-457d-b4db-8f44ace834f8.png)'
  prefs: []
  type: TYPE_IMG
- en: The rate of convergence of the secant method is considered to be superlinear.
    Its secant method converges much faster than the bisection method and slower than
    Newton's method. In Newton's method, the number of floating-point operations takes
    up twice as much time as the secant method in the computation of both its function
    and its derivative on every iteration. Since the secant method requires only the
    computation of its function at every step, it can be considered faster in absolute
    time.
  prefs: []
  type: TYPE_NORMAL
- en: The initial guess values of the secant method must be close to the root, otherwise
    it has no guarantee of converging to the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code for the secant method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we will reuse the same nonlinear function and return the results from
    the secant method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Though all of the preceding root-finding methods gave very close solutions,
    the secant method performs with fewer iterations compared to the bisection method,
    but with more than Newton's method.
  prefs: []
  type: TYPE_NORMAL
- en: Combing root-finding methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is perfectly possible to write your own root-finding algorithms using a
    combination of the previously-mentioned root-finding methods. For example, you
    may use the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the faster secant method to converge the problem to a pre-specified error-tolerance
    value or a maximum number of iterations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once a pre-specified tolerance level is reached, switch to using the bisection
    method to converge to the root by halving the search interval with each iteration
    until the root is found
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Brent''s method** or the **Wijngaarden-Dekker-Brent** **method** combines
    the bisection root-finding method, secant method, and inverse quadratic interpolation.
    The algorithm attempts to use either the secant method or inverse quadratic interpolation
    whenever possible, and uses the bisection method where necessary. Brent''s method
    can also be found in the `scipy.optimize.brentq` function of SciPy.'
  prefs: []
  type: TYPE_NORMAL
- en: SciPy implementations in root-finding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before starting to write your root-finding algorithm to solve nonlinear or even
    linear problems, take a look at the documentation of the `scipy.optimize` methods.
    SciPy contains a collection of scientific computing functions as an extension
    of Python. Chances are that these open source algorithms might fit into your applications
    off the shelf.
  prefs: []
  type: TYPE_NORMAL
- en: Root-finding scalar functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some root-finding functions that can be found in the `scipy.optimize` modules
    include `bisect`, `newton`, `brentq`, and `ridder`. Let''s set up the examples
    that we have discussed in the *Incremental search s*ection using the implementations
    by SciPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the preceding code, the following output is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the SciPy implementation gives us very similar answers to our
    derived ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be noted that SciPy has a set of well-defined conditions for every
    implementation. For example, the function call of the bisection routine in the
    documentation is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The function will strictly evaluate the function, *f*, to return a zero of the
    function. *f(a)* and *f(b)* cannot have the same signs. In certain scenarios,
    it is difficult to fulfill these constraints. For example, in solving for nonlinear
    implied volatility models, volatility values cannot be negative. In active markets,
    finding a root or a zero of the volatility function is almost impossible without
    modifying the underlying implementation. In such cases, implementing our own root-finding
    methods might perhaps give us more authority over how our application should behave.
  prefs: []
  type: TYPE_NORMAL
- en: General nonlinear solvers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `scipy.optimize` module also contains multidimensional general solvers
    that we can use to our advantage. The `root` and `fsolve` functions are some examples
    with the following function properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`root(fun, x0[, args, method, jac, tol, ...])`: This finds a root of a vector
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fsolve(func, x0[, args, fprime, ...])`: This finds the roots of a function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The outputs are returned as dictionary objects. Using our example as input
    to these functions, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Using an initial guess value of `5`, our solution converged to the root at
    `1.24189656`, which is pretty close to the answers we''ve had so far. What happens
    when we choose a value on the other side of the graph? Let''s use an initial guess
    value of `-5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the display output, the algorithms did not converge and
    returned a root that is a little bit different from our previous answers. If we
    take a look at the equation on a graph, there are a number of points along the
    curve that lie very close to the root. A root-finder would be needed to obtain
    the desired level of accuracy, while solvers attempt to solve for the nearest
    answer in the fastest time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we briefly discussed the persistence of nonlinearity in economics
    and finance. We looked at some nonlinear models that are commonly used in finance
    to explain certain aspects of data left unexplained by linear models: the Black-Scholes
    implied volatility model, Markov switching model, threshold model, and smooth
    transition models.'
  prefs: []
  type: TYPE_NORMAL
- en: In Black-Scholes implied-volatility modeling, we discussed the volatility smile,
    which was made up of implied volatilities derived via the Black-Scholes model
    from the market prices of call or put options for a particular maturity. You may
    be interested enough to seek the lowest implied-volatility value possible, which
    can be useful for inferring theoretical prices and comparing against market prices
    for potential opportunities. However, since the curve is nonlinear, linear algebra
    cannot adequately solve for the optimal point. To do so, we will require the use
    of root-finding methods.
  prefs: []
  type: TYPE_NORMAL
- en: Root-finding methods attempt to find the root of a function or its zero. We
    discussed common root-finding methods, such as the bisection method, Newton's
    method, and the secant method. Using a combination of root-finding algorithms
    may help us to find roots of complex functions faster. One such example is Brent's
    method.
  prefs: []
  type: TYPE_NORMAL
- en: We explored functionalities in the `scipy.optimize` module that contains these
    root-finding methods, albeit with constraints. One of these constraints requires
    that the two boundary input values be evaluated with a pair of a negative value
    and a positive value for the solution to converge successfully. In implied volatility
    modeling, this evaluation is almost impossible, since volatilities do not have
    negative values. Implementing our own root-finding methods might perhaps give
    us more authority over how our application should perform.
  prefs: []
  type: TYPE_NORMAL
- en: Using general solvers is another way to find roots. They may also converge to
    our solution more quickly, but such convergence is not guaranteed by the initial
    given values.
  prefs: []
  type: TYPE_NORMAL
- en: Nonlinear modeling and optimization are inherently a complex task, and there
    is no universal solution or sure way to reach a conclusion. This chapter serves
    to introduce nonlinearity studies for finance in general.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at numerical methods commonly used
    for options pricing. By pairing a numerical procedure with a root-finding algorithm,
    we will learn how to build an implied volatility model with the market prices
    of an equity option.
  prefs: []
  type: TYPE_NORMAL
