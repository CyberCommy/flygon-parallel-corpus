- en: Client-Server Architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client-server architecture is one of the most common architectural styles
    applied today, and it has been used in many different ways.
  prefs: []
  type: TYPE_NORMAL
- en: When we hear the term client-server architecture, we often think of old applications
    that provide a UI for editing complex databases in which the major part of the
    business logic resides. However, the truth is that this architectural style offers
    underlying support for almost every single modern architectural style, including
    microservices, event-driven architectures, or any distributed computing system.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will review how the client-server architecture works, as
    well as how it can be implemented. We will use the Spring Framework to build the
    server side, and then we'll code clients interacting with the server using Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding client-server architectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where to apply client-server architectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implementing client-server architectures:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a server with Spring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Spring actuator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring the health of an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing clients with Java FX and Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the implemented code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding client-server architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In client-server architectures, each running process is either a server or
    a client. They interact with each other using requests that are sent through a
    defined communication channel, in a network that connects them together. We have all used
    an email service, and we understand how such a service works; that is the quintessential
    example of a client-server architecture, illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5421274-ee5a-4aaf-9e8d-827353a7a226.png)'
  prefs: []
  type: TYPE_IMG
- en: Email service components
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now provide a brief overview of each component in the preceding diagram,
    in order to explain how it fits within the client-server architectural style.
    The precedingdiagram is comprised of the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The server (**1**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The request payload (2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The clients accessing the server resources (**3**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The server is in charge of processing the received requests (which should comply
    with a predefined format), and then producing results.
  prefs: []
  type: TYPE_NORMAL
- en: Once the data is retrieved, a whole process begins, checking the requests before
    processing them. This process begins by authenticating and authorizing checks
    that verify the client’s identity. A validation process then starts, to review
    the input provided by clients, and the provided body request is tested to verify
    its structure. After that, checks to validate that the data complies with the
    business logic constraints are executed. To finish, the requests are processed
    by the server.
  prefs: []
  type: TYPE_NORMAL
- en: These steps make it possible to achieve a certain level of reliability within
    the application, since ill-intentioned or corrupt requests that would eventually
    destroy the data or convert the system into an inconsistent state are not processed
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: The responses offered by the server are often services or resources that will
    be consumed by the clients later. When the requests are not processed successfully,
    a response, including reasonable information, is remitted to the client.
  prefs: []
  type: TYPE_NORMAL
- en: A high-performance server is used to support the required processing. The servers
    are located in an on-premise or cloud-based infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the server is in production, it's a good idea to monitor its resource consumption
    and business metrics associated with the application. If we identify any anomalies
    or high traffic, we should consider scaling the server to offer a better user
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: Since a client can be any device that is able to connect to the server, including separate
    computers, we might suddenly have millions of clients accessing the server. When
    the application ran on one machine, the balance of resource consumption between
    the client and server parts of the application was fixed. However, as soon as
    clients and servers could be scaled independently, it became easy for clients
    to scale way out of proportion to the server's capacity. Today, clients only need
    to interact with one user. Because of this, it is easy for them to have adequate
    resources. However, servers may be asked to support numbers of clients across
    a wide, dynamic range. It’s in this situation that scaling becomes an important
    technical requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two options for scaling a server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Vertical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Horizontal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can think about vertical scaling for services that cannot be deployed on
    more than one node, because of its own nature. A node can be represented by a
    computer or process running the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this scaling option, we can only scale a service by adding more resources,
    such as RAM, CPU, hard-disk, and so on, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99beb40a-bd5a-490a-bac7-8258f95e3d53.png)'
  prefs: []
  type: TYPE_IMG
- en: Vertical scaling
  prefs: []
  type: TYPE_NORMAL
- en: An explicit limitation that we have is that we can only increase the power of
    the unique process that is running the service.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you have a stateless service, like a REST API, it can
    be deployed on more than one node, making it possible to scale the service horizontally.
    This approach allows us to scale applications in a better way, but a load balancer
    should be in front of them, in order to route the request appropriately, using
    an algorithm for it. A typical algorithm to use is round-robin, which distributes
    the requests equally among all of the available nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows servers arranged behind a load balancer, using
    a horizontal scaling approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c8e0523-718c-400c-95ae-c40d00a2f5bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Horizontal scaling
  prefs: []
  type: TYPE_NORMAL
- en: Request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A request is a piece of information that is sent to the server by a client.
    The client and the server have to agree on the protocol that they use to communicate,
    in order to allow them to interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: In order to facilitate the exchange of data, it is recommended that an SDK (or
    some sort of library) be provided by the product vendors. For example, if you're
    interested in interacting with a database from a Java application, there are drivers
    coded in the form of libraries that can be used for that. Furthermore, the database
    vendors also provide drivers for different programming languages, desktop applications,
    or UIs, to interact with servers such as pgAdmin or MySQL Workbench.
  prefs: []
  type: TYPE_NORMAL
- en: Providing an SDK is not a must; even when an SDK is provided, an easy to understand
    document will avoid introducing a conformist relationship between the server and
    clients.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conformist relationship** is a term coined by domain driven design. It suggests
    that a service has a complex and large model that forces the downstream dependencies
    to be modified when the server introduces new changes or releases new features.
    The modification should happen, because the effort required to write their own
    model adaptations or mechanisms to interact with the server is extremely high
    and is difficult to achieve.'
  prefs: []
  type: TYPE_NORMAL
- en: Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a plenty of options that can be used for application clients. For
    the email example, it''s well known that there are native applications included
    as part of the computers'' operating systems, and also in mobile devices like
    smartphones, iPads, or tablets, that can be configured to interact with existing
    email servers. There are two types of clients, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Fat clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thin clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fat clients have implemented logic that is in charge of performing some validations,
    formatting data, and fulfilling other related duties. They are designed to make
    the interaction between the end users and the server easier.
  prefs: []
  type: TYPE_NORMAL
- en: Think about a Windows PC running Outlook. This represents a classic example
    of a fat client. In contrast, a web browser talking to a webmail site is a good
    example of a thin client.
  prefs: []
  type: TYPE_NORMAL
- en: We can also compare fat clients with regards to the native applications running
    on our mobile phones that can partially work when they are unable to establish
    communication with the server; meanwhile, a thin client, like a web browser, is
    absolutely useless.
  prefs: []
  type: TYPE_NORMAL
- en: Within the fat client category, we also have middleware, which often consumes
    more than one service and orchestrates the requests to accomplish a business goal.
    The most common examples are the **enterprise service buses** (**ESB**) commonly
    used as part of SOA architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Thin clients are quite simple, and they count with a simple mechanism that makes
    it possible to interact with the server. A common example of this is `curl` commands,
    used to interact with Rest-APIs through the HTTP(S) protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A network is a medium that supports communications between servers and clients,
    following the request-response messaging pattern in which a client sends a request
    to the server and the server responds to the request by using this medium. A typical
    example of a network is the internet, which enables us to communicate with all
    devices connected to it. Today, there are tons of devices that can be connected
    to the internet, including computers, tablets, smartphones, Arduino, Raspberry
    PI, and others. The use of these devices has enabled the growth of the **Internet
    of Things** (**IoT**), giving us the chance to innovate and create a new era of
    applications. There are also other sorts of networks, such as Bluetooth, LiFi,
    LAN, and so on, that can be used to allow interaction between clients and servers,
    depending on business needs.
  prefs: []
  type: TYPE_NORMAL
- en: Where to apply client-server architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a bunch of situations where the client-server architectural style
    can be used. Let's review some typical examples, in order to better understand
    this approach.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, databases commonly fit this architectural style. Currently,
    we have many database vendors available in the market, and the majority of them
    only offer the chance to scale vertically. Two classic examples of this approach
    are SQL Server and PostgreSQL. However, there are options to scale horizontally,
    as well. The most well-known database following this model is Cassandra, which
    is a database created by Facebook that was later adopted as an Apache project.
    This database uses a ring model to connect different nodes, where the data is
    stored. In this manner, you can add as many nodes as you need to, in order to
    support high-availability.
  prefs: []
  type: TYPE_NORMAL
- en: Chat services, like Slack, are a classic example of client-server architectures
    that use the cloud. This chat has clients for almost any computer operating system,
    and for mobile platforms, as well; you can even use it directly on the browser,
    if you don't want to install a native application on your device.
  prefs: []
  type: TYPE_NORMAL
- en: Agents are also an interesting application of this architectural style. An agent
    is a piece of software in charge of sending information from the clients to the
    server, without needing human interaction attached to it. For example, New Relic
    ([https://newrelic.com/](https://newrelic.com/)) is an **Application Performance
    Monitoring and Management** (**APM**) used to monitor the health of servers and
    applications using agents.
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose that you want to monitor your existing Java application. To achieve
    this goal, you only need to add the New Relic agent when the application is started,
    using the `javaagent` option. In this way, the agent will continually be sending
    information to New Relic, which will give us information related to the memory
    and CPU consumption, response time, and so on. In this case, the server that processes
    the data sent by the agents is also in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: The IoT also relies heavily on the use of client-server architectures, where
    small devices with sensors (or some other mechanisms) used to gather data are
    constantly sending information to servers in charge of analyzing that data, in
    order to execute operations, depending on what is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing client-server architectures with Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have a better comprehension of client-server architectures, we
    will code an example that follows this diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d08bec7-ac5c-4d42-9a00-240da83e5b5f.png)'
  prefs: []
  type: TYPE_IMG
- en: Example of client-server architecture
  prefs: []
  type: TYPE_NORMAL
- en: The functionality of our application will be simple. The server will expose
    an endpoint with the customer's bank statement, and then we will code a few clients
    to consume that information.
  prefs: []
  type: TYPE_NORMAL
- en: The server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a bunch of options to build the server side using the Spring Framework,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: SOAP web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RESTful Web Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Common Object Request Broker Architecture** (**CORBA**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AMQP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOAP web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SOAP web services were widely implemented by developers before the REST style
    appeared, and they are heavily based on the use of XML. There are also a bunch
    of libraries available to deal with them, including Apache CXF, and JAX-WS. The
    following screenshot represents a request payload for a simple addition operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acbef2f4-beac-4927-bc6f-626025f79fb7.png)'
  prefs: []
  type: TYPE_IMG
- en: Request payload
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the response looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ad9822f-9121-4cb8-a9c1-c527959c0607.png)'
  prefs: []
  type: TYPE_IMG
- en: Response payload
  prefs: []
  type: TYPE_NORMAL
- en: The preceding examples were taken from [http://www.dneonline.com/calculator.asmx?op=Add](http://www.dneonline.com/calculator.asmx?op=Add).
  prefs: []
  type: TYPE_NORMAL
- en: These XML files are following the **Web Services Description Language** (**WSDL**)
    format used by SOAP web services.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The RESTful style, on the other hand, is currently preferred, and there are
    a bunch of public APIs that use it. Common examples are companies such as GitHub
    and Yahoo. This style bases its functionality on the use of HTTP verbs, making
    it easy to understand how they work. For example, the following HTTP request makes
    it possible to query the repositories from GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This style appeared in 2000, with Roy Fielding''s doctoral dissertation that
    explains the REST principles and dictates how well-designed web applications should
    behave. The use of HTTP verbs is described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP Method/Verb** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Lists all of the resources available under the specified URI |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Creates a new resource in the specified URI |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | Replaces the existing resource under the specified URI with another
    one |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Deletes the resource specified in the URI |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Partially updates a resource that resides in the specified URI
    |'
  prefs: []
  type: TYPE_TB
- en: CORBA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CORBA is a really old standard, designed to allow applications written in
    different programming languages to interact with each other. It is hard to use
    this standard because of all of the required plumbing code to achieve the goal.
    CORBA is not popular nowadays, but some legacy applications still use it to interact
    with old code, written mainly in Cobol, which was one of the preferred programming
    languages to write banking cores.
  prefs: []
  type: TYPE_NORMAL
- en: Sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sockets are a common protocol that became even more popular with the emergence
    of WebSockets, which establishes a full-duplex communication channel among the
    server and clients. A typical scenario wherein this protocol is used includes
    messenger applications, such as Slack.
  prefs: []
  type: TYPE_NORMAL
- en: AMQP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications using the AMQP, or any similar messaging protocol, are designed
    to allow for interoperability among heterogeneous applications, with an asynchronous
    approach. There are a bunch of commercial and open source implementations, such
    as AWS-SQS/SNS and RabbitMQ, among others, that can be used to implement applications
    using this model. We are going to review how this works in detail in [Chapter
    6](47f3823d-e7cd-4384-b392-71c7daf27b2d.xhtml), *Event-Driven Architectures*.
    The basic concept of this approach is to use a messaging broker in charge of receiving
    messages, and then distribute them to their subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: For our example, we are going to choose RESTful web services, which is a popular
    choice nowadays. In order to accomplish our goal, we will use Spring Boot (to
    bootstrap our application) together with Spring Data (to persist the information
    using H2, which is an in-memory database). Our app will be secured using the JSON
    Web Tokens RFC ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)).
  prefs: []
  type: TYPE_NORMAL
- en: 'JWT is an open standard, intended to allow for authenticating clients with
    servers. Another use case is to validate the integrity of the messages. In order
    to use JWT as an authentication mechanism, the clients should send their credentials
    to the server, and it will respond to them with a token in the form of a string.
    This token should be used for the subsequent requests. When they are executed,
    if the provided token is invalid or expired, we will receive a 401 UNAUTHORIZED
    status code from the server. Otherwise, the request will be successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f58c13ed-3bf8-4c93-b45b-bce3456ce155.png)'
  prefs: []
  type: TYPE_IMG
- en: JWT authentication flow
  prefs: []
  type: TYPE_NORMAL
- en: Since the functionality of this application doesn't require a considerable amount
    of computing or real-time processing, we used Groovy as the programming language.
    Groovy has a pretty similar syntax to Java, but with tons of built-in functionalities
    that allow us to avoid writing verbose code. In conjunction with Groovy, we will
    use Spock as a testing framework. This will enable us to write highly expressive
    tests using a **Behavior Driven Development** (**BDD**) approach, with the `given`,
    `when`, and `then` syntax. The main idea behind BDD is to reduce the uncertainty
    about what a test method is testing, using expressive test names that are helpful
    for understanding what goes wrong when a test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'The BDD approach is based on the structure of user stories, and the idea is
    to write tests that make it clear what they are testing. A classic example, used
    to explain this concept, is provided by Dan North (the BDD creator) and starts
    with the following user story related to how an ATM works:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Title – Customer withdraws cash** | **Scenario 1 – Account is on credit**
    | **Scenario 2 – Account is overdrawn past the overdraft limit** |'
  prefs: []
  type: TYPE_TB
- en: '| As a customer, I want to withdraw cash from an ATM so that I don’t have to
    wait in line at the bank. | Given that the account is in credit, the card is valid
    and the dispenser contains cash, when the customer requests cash, then ensure
    that the account is debited, cash is dispensed, and the card is returned. | Given
    that the account is overdrawn and the card is valid, when the customer requests
    cash, then ensure a rejection message is displayed. Ensure that cash is not dispensed
    and the card is returned. |'
  prefs: []
  type: TYPE_TB
- en: 'The preceding validation can be easily expressed with code by using Spock.
    Let''s check one of our implemented tests to understand how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the test explains itself well, using the `given`, `when`, and `then`
    syntax provided by Spock.
  prefs: []
  type: TYPE_NORMAL
- en: Spock also allows for using mocks, without needing additional libraries such
    as Mockito, because this feature is built in. If you are interested in knowing
    more about Spock, I encourage you to visit [http://spockframework.org/](http://spockframework.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s implement the server project for our example. We are going to organize
    its functionalities in modules, in order to make it easy to evolve and understand.
    For the sake of simplicity, we are going to add a simple functionality that will
    later be consumed by different application clients. The server example will have
    three modules, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Banking-domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Banking-api
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Banking-client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Banking-domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module contains all of the domain objects required to build our application;
    it''s a good idea to keep them separated, as another module. By doing this, you
    can later include the module as a dependency of other modules, which will help
    to avoid writing the same code twice. The following diagram shows the contents
    of this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0b438f3-9599-42c5-988e-cb187a8d2d48.png)'
  prefs: []
  type: TYPE_IMG
- en: The banking-domain module
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this module contains only two classes. The `Credentials`class
    is used as the payload, to authenticate a user and retrieve the JSON web token,
    and the `BalanceInformation`class contains the payload resultant of querying the
    customer account balance.
  prefs: []
  type: TYPE_NORMAL
- en: Banking-api
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The banking-api module contains the functionality exposed by the server that
    will later be consumed by different application clients; the functionality will
    be made available for RESTful web services. Let''s review the project structure
    for this API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4edbb43b-ff0a-41eb-a670-605e57bd0fb7.png)'
  prefs: []
  type: TYPE_IMG
- en: The banking-api module
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, this module is implemented entirely using Groovy, and
    that's why all of the files have a `.groovy` extension. The project structure
    is more important here, as the project is separated into `balance`, `config`,
    and `security` packages, which makes it fairly simple to understand their purposes. It's
    always worth organizing the code in this way, in order to make it easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'We mentioned previously that not only should an SDK be provided, but proper
    documentation is also highly recommended. The tedious part of writing documentation
    is that you need to keep it in sync with the new features added to the project.
    To achieve this goal, we have integrated Swagger into our application. This is
    a helpful tool that generates a website with examples to consume the endpoints
    of an application. Furthermore, it also creates payload demos for each one of
    them when it''s required, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef6bcad6-a52b-4cd4-86dc-7072982edd28.png)'
  prefs: []
  type: TYPE_IMG
- en: Autogenerated Swagger UI
  prefs: []
  type: TYPE_NORMAL
- en: This portal is available at `http://localhost:8080/swagger-ui.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's briefly review the packages listed in the screenshot for each module.
  prefs: []
  type: TYPE_NORMAL
- en: Boundaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `boundaries` package contains the functionality exposed by the application
    that will be used to allow for the interaction with the clients. In this case,
    we are placing the endpoints of our service here.
  prefs: []
  type: TYPE_NORMAL
- en: Domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The domainpackage has the domain objects that are required only by this module.
    The classes placed here won't be used in any other place, and that's why it doesn't
    make sense to place them in the banking-domain module, which is intended to be
    shared.
  prefs: []
  type: TYPE_NORMAL
- en: Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, we are going to write the required code to persist information in
    this package. Since the persistence storage of our application is a database,
    and we defined that we are going to use Spring-data for it, we have our Spring-data
    repositories here.
  prefs: []
  type: TYPE_NORMAL
- en: Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have put the required business logic for our service into this package. This
    is where the interaction with many classes happens, in order to achieve the business
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We mentioned earlier that monitoring is quite important to understanding how
    an application performs in the wild. Fortunately, Spring has `actuator`, which
    is a library that can be easily attached to an existing Spring Boot application
    by adding the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Spring Boot Actuator provides a bunch of endpoints that are ready to be consumed
    and provide useful information about the application. Let''s review some of them
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Endpoint** | **Brief Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `/health` | This provides brief information about the application status
    and its main dependencies, such as databases or messaging systems. |'
  prefs: []
  type: TYPE_TB
- en: '| `/autoconfig` | This provides information about the auto-configuration provided
    for the app by the Spring Framework. Remember that Spring prefers convention over
    configuration, so you''ll find tons of default values here. |'
  prefs: []
  type: TYPE_TB
- en: '| `/beans` | This shows the list of Spring beans configured as a part of the
    application context. |'
  prefs: []
  type: TYPE_TB
- en: '| `/dump` | This performs a thread dump at the exact moment that the endpoint
    is requested. |'
  prefs: []
  type: TYPE_TB
- en: '| `/env` | This lists all of the variables configured in the server. Values
    provided as a part of `.properties`/`.yml` files and arguments provided to run
    the application are listed, as well. |'
  prefs: []
  type: TYPE_TB
- en: '| `/metrics` | This shows some metrics around the available endpoints exposed
    in the app. |'
  prefs: []
  type: TYPE_TB
- en: '| `/trace` | This gives information regarding the last 100 (by default) requests,
    including details about the requests and responses. |'
  prefs: []
  type: TYPE_TB
- en: If you are interested in a complete list of the endpoints available by default,
    I encourage you to visit [https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html](https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the preceding endpoints can mainly be configured with three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: This is the endpoint identification'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sensitive`: This indicates whether or not Spring Actuator should enforce security'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enabled`: This indicates whether or not the Spring Actuator endpoints are
    available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to configure the endpoints, you have to use the following entries
    as a part of your configuration (`.properties`/`.yml`) file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following bullet points expand upon this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '`endpoints`: This is a constant value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`endpoint_name`: This should be replaced with the desired endpoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`property`: This can be `id`, `sensitive`, or `enabled`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, let''s suppose that you want to enable the `health` endpoint,
    rename it to `status`, and not enforce `security`. To achieve this requirement,
    the configuration should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: All of the endpoints are enabled by default, except for `/shutdown`, which is
    intended to stop the application gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, Spring actuator can be configured to generate business metrics,
    as well. This is an excellent feature that can be integrated with other tools,
    which makes it possible to visualize the collected metrics using graphical interfaces.
    We will review this feature in detail in [Chapter 12](f58465fa-861d-4800-a2a3-fe19c06e8789.xhtml),
    *Monitoring*.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have introduced unit tests to validate that the code is working
    as expected. However, we would like to add even more tests. After all, the more
    tests we include in our system, the more confidence we will gain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are writing a rest API, we will create a simple script that will exercise
    our endpoints from time to time, giving us the confidence that the app is always
    working. To achieve this goal, our tests will follow a simple process:'
  prefs: []
  type: TYPE_NORMAL
- en: Authenticate the user using the endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validate the status code from the response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the token from the response body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit the balance endpoint using the token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validate the status code from the response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The easiest way to achieve this goal is by using Postman ( [https://www.getpostman.com/](https://www.getpostman.com/)).
    This is a handy tool that allows for trying RESTful web services, and creating
    tests for them, as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss the test generated for the endpoint to authenticate a user,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3dfe152-f51d-4715-a024-d59d408cfbfd.png)'
  prefs: []
  type: TYPE_IMG
- en: Test for the authentication endpoint in Postman
  prefs: []
  type: TYPE_NORMAL
- en: The first three lines of the preceding code check the retrieved status code,
    and line 5 stores the retrieved body response as a variable named `jwt-token`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the preceding code, we can later inject the value of this variable into
    the subsequent requests and perform whatever validations we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all of the tests have been created, we can generate a link referring to
    the collection that contains them, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cb40230-86c1-406f-9529-fe601617ea9f.png)'
  prefs: []
  type: TYPE_IMG
- en: Postman collection link
  prefs: []
  type: TYPE_NORMAL
- en: 'With this link, the collection of tests can be executed over and over again,
    using a command-line integration runner named Newman ([https://www.npmjs.com/package/newman](https://www.npmjs.com/package/newman))
    and the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results of the Newman command''s execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa4ee1ac-45f4-4e45-9374-c5f735614c6b.png)'
  prefs: []
  type: TYPE_IMG
- en: The results of the Newman command execution
  prefs: []
  type: TYPE_NORMAL
- en: This tool can be integrated with any CI server, such as Jenkins, to schedule
    jobs in charge of verifying the health of the application regularly, which will
    give us the confidence that our app is always working.
  prefs: []
  type: TYPE_NORMAL
- en: Banking-client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since our server is implemented using RESTful web services, there are a bunch
    of options for writing clients and consuming them with libraries, such as Netflix
    Feign, OkHttp, Spring Rest Template, and Retrofit.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, the clients can have their own implemented mechanisms to consume
    the services. This approach is not bad at all; actually, we should keep it open,
    and the decision of writing our own tool to interact with the server should be
    a client choice, in order to avoid the conformist relationship described earlier.
    However, it's always a good idea to provide a built-in SDK or library to interact
    with the server and reduce the amount of effort required for it, and that's the
    reason we have the banking-client module.
  prefs: []
  type: TYPE_NORMAL
- en: It's quite common to find SDKs provided by product vendors. For example, AWS
    provides SDKs with support for a bunch of programming languages, in conjunction
    with a developer guide document that explains how to use them. This is helpful
    for accelerating and encouraging the adoption of products to build applications
    by other developers. Another example is Google Firebase, which is a real-time
    database that provides SDKs that are ready to use in different platforms; it has
    a website with excellent demos that make it possible for developers to understand
    how it works and how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This banking-client module is implemented using a library named Retrofit ([http://square.github.io/retrofit/](http://square.github.io/retrofit/)),
    which makes it possible to write type-safe HTTP clients that can be used for almost
    any kind of Java application. This also offers many benefits, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Support for mobile apps, like Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code that is easy to read and explains itself well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for synchronous and asynchronous resource consumption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smooth integration with converters, such as GSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at the implemented clients, in order to consume the endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication endpoint client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to consume a RESTful web service, we only have to create an interface
    with a few annotations to provide some metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It's fairly simple to understand that the authentication endpoint uses the `POST`
    HTTP verb. This is available in the URI `/api/public/auth`, and it needs a `Credentials`
    object as the request body.
  prefs: []
  type: TYPE_NORMAL
- en: Account balance endpoint client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this case, we will consume an endpoint, available in the URI `/api/secure/balance`**, **that
    uses the `GET` HTTP verb and requires that the token be used as a header in the
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you have probably noticed, this module uses the `BalanceInformation` and
    `Credentials` classes, so we don't need to write them again; we only need to add
    the banking-domain module as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''re probably wondering where you have to specify the IP address and port
    for the server, and that is done in the `Retrofit` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the client's implementation, we will review how to use this `Retrofit` object
    in conjunction with the interfaces, in order to make the requests.
  prefs: []
  type: TYPE_NORMAL
- en: The clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have implemented the server, we are going to build three clients,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thin client, using CURL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These clients will use the HTTP protocol to send the requests and retrieve the
    responses. Since we have written a client module, the interaction with the server
    will be fairly simple.
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This client is a simple JavaFX application that has a dependency on the banking-client
    module to interact with the server. We can say that this client is a sort of fat
    client, since it has some code written to simplify the interaction with the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the project structure in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/911f12ec-265c-44ad-b576-bdbac2a574bf.png)'
  prefs: []
  type: TYPE_IMG
- en: JavaFX client project structure
  prefs: []
  type: TYPE_NORMAL
- en: This project is fairly simple, and it has only two screens, which allow the
    users to enter their credentials and then query their account balance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrofit offers the availability to make synchronous and asynchronous requests.
    In this client, we will use synchronous requests, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `execute`method allows for making synchronous requests. The `Retrofit` object
    contains the base URI that will be used in conjunction with the partial URIs provided
    in the client interfaces, in order to form the full URI to hit the endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of this client application is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae4ab25f-74d1-4c79-9ff1-9c5383960b86.png)'
  prefs: []
  type: TYPE_IMG
- en: JavaFX client application
  prefs: []
  type: TYPE_NORMAL
- en: Android client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android client also uses the provided banking-client module to interact
    with the server, but in this case, it's necessary to use the asynchronous method
    to make requests (this requirement comes from the nature of how Android works).
    We can also say that this is a fat client, by looking at the definition provided earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the structure of this project in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59d157df-8691-43a8-93e7-084f2591f2b1.png)'
  prefs: []
  type: TYPE_IMG
- en: Android client project structure
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Activity` classes have the code to make the asynchronous requests, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `enqueue`method allows for hitting the endpoint asynchronously, and it registers
    two callbacks that will be executed, depending on whether the response fails or
    succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The execution flow for this client application is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed9cfd5b-76e5-4719-8576-3915e754d2de.png)'
  prefs: []
  type: TYPE_IMG
- en: Android client application
  prefs: []
  type: TYPE_NORMAL
- en: Thin client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned previously, there are also thin clients, which don't include a
    lot of code to interact with the server; one good example of a thin RESTful web
    service client is `curl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to interact with the endpoints provided by the server example, we
    can use two `curl` commands, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code provides for retrieving the authentication JWT token:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code provides for using the JWT token to query the user''s account
    balance:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For these kinds of clients, we don't have to write our own code; the interaction
    with the server doesn't have a fancy frontend, which can be good (in cases where
    the API is used for other middleware, for example).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our client-server architecture implementation is simple, but
    it uses all of the necessary pieces to make it work. In this case, we have used
    the HTTP protocol as the communication channel. However, depending on what kind
    of server you are implementing, it may be different, and it can also affect the
    authentication mechanism. For example, when you're using a message broker such
    as RabbitMQ to allow for the interaction between servers and clients, the protocol
    to establish the communication is AMQP, which is a different protocol (in comparison
    to HTTP).
  prefs: []
  type: TYPE_NORMAL
- en: The kinds of clients that your application will have also affects the way in
    which you will build the solution. Let's suppose that you're using agents as clients;
    a more secure authentication mechanism would be based on the use of certificates
    instead of tokens, as seen in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed what client-server architectures are and how to
    implement them using the Spring Framework. One important aspect to remember is
    that when we are building applications following this architectural style, it's
    always worth providing an SDK to make the server resources easy to consume.
  prefs: []
  type: TYPE_NORMAL
- en: Providing proper documentation can help clients to write their own code to interact
    with the server, if necessary. In this case, we will avoid introducing a conformist
    relationship among the server and clients. We also explored spring actuator, a
    library that can be used to add endpoints that provide information about the application.
    Furthermore, we reviewed how to use Postman to create tests that can regularly assess
    the application's health.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we created a couple of clients using a library implemented with
    Retrofit, which drastically reduced the effort required to consume the resources
    exposed by the server.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will review MVC architectures and how to write them
    using Spring.
  prefs: []
  type: TYPE_NORMAL
