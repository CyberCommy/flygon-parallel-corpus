- en: Chapter 5. Platform Fun
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a good grounding in the basics of building a game, we are ready
    to create more complex and more efficient projects. In this chapter we are going
    to develop a classic platforming game with an epic boss battle. We will focus
    on building systems and utilizing reusable scripts to simplify our code and save
    time. This will also reduce the total size of the game, making it faster to download.
  prefs: []
  type: TYPE_NORMAL
- en: The gameplay itself will consist of a player character that can run around the
    world, jump onto platforms, and shoot in several directions. The player will need
    to defeat a giant machine Boss that will have three distinct stages. In the first
    stage the player will need to blow up three powerful Cannons that are exposed
    for a short period of time. The second stage requires the destruction of a large
    Laser Cannon that will move up and down firing its massive Laser Beam intermittently.
    The final stage will have Shields that protect the Boss Core, occasionally opening
    to allow the player to eradicate the heart of the boss. All of this will happen
    while the player tries to avoid being hit by an indestructible turret.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring systems-based code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When making a game, it is common to build each component all on its own and
    not to think about how it will affect the game as a whole. The developer will
    build a basic framework and then add features as they come along, often resorting
    to special conditional statements to make the code work without breaking the game.
    This methodology eventually will start creating bugs in the software requiring
    more time and effort to fix each one. The bigger the game, the more likely problems
    will be to arise. It can be an incredibly frustrating experience.
  prefs: []
  type: TYPE_NORMAL
- en: This is where breaking the code into individual systems can really save time
    and effort. Rather than rewriting elements of code over and over again for each
    object, we can write self-contained processes into scripts that can be shared.
    For this game we are going to separate out some of the more basic components,
    such as gravity and animation, into their own systems.
  prefs: []
  type: TYPE_NORMAL
- en: Creating gravity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first system we are going to build is one for dealing with gravity. While
    GameMaker: Studio does have a gravity property, it adds a level of complexity
    not needed in a platformer game. Gravity is a force that is applied to an object''s
    speed cumulatively, which means that the longer an object is falling, that faster
    it will move. The issue we have is that setting gravity to zero just means it
    will not move faster. We need the object to come to a full stop. Therefore, we
    we will create our own gravity system that not only makes objects fall, but will
    deal with landing on the ground as well. Instead we will create our own gravity
    system that not only makes objects fall, but will deal with landing on the ground
    as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to start by introducing **constants** . Constants allow us to
    use names to represent values that will never change. This has the double benefit
    of making it easier for us to read the code and help improve performance as compared
    to variables:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started by creating a **New Project** called `Chapter_03`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Resources** | **Define Constants** editor. In the **Name** column
    write `MAXGRAVITY` with a **Value** of `16`. At this speed we can be sure that
    a falling object will not move so fast that it will miss the bounding box of another
    object in the game. From now on, whenever we see `MAXGRAVITY` the computer will
    see `16`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is convention to write all constants in all capital letters, though it won't
    break if the convention isn't followed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we can create a new Script , `scr_Gravity`, and write the following code
    to create gravity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: First we check to see whether the area below the instance is clear of any collidable
    objects at the speed the instance is currently travelling. If it is clear, then
    we know that we are in the air and that gravity should be applied. We do this
    by increasing the vertical speed each step by a small amount. If there is a collidable
    object, then we are about to hit the ground, so we move the instance to the surface
    of the object in the direction the instance is travelling up to our `MAXGRAVITY`,
    16 pixels. At that point, the instance is on the ground so we set the vertical
    speed to zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have gravity working, but it will pick up too much speed if we don''t
    limit how fast an instance can fall. Add this code to the bottom of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here we are setting the `vspeed` value to the lower value between the current
    `vspeed` and `MAXGRAVITY`. If the instance is moving too fast, this code will
    slow it down to the maximum allowed speed. We now have a simple gravity system
    that all objects in the game could utilize.
  prefs: []
  type: TYPE_NORMAL
- en: Building an animation system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next system we will create is for animation and it will be implemented as
    a state machine. A state machine breaks down all the conditions of an object into
    distinct states. An object can only be in one stage at any one time, so the code
    related to it can be contained and managed more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: To understand this concept better, think about a door. A door has several unique
    states of being. The two states that probably spring to mind are that the door
    can be open or it can be closed. There are also two other states, opening and
    closing, as can be seen in the following image. If the door is opening, it is
    neither open nor is it closed, but rather it is in a unique state of action. This
    makes state machines perfect for animation. Almost every interactive object in
    a game is likely to have some animation or utilize several different images.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building an animation system](img/4100_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since the player character is generally the most robust object in terms of
    different animations, we will start by breaking down its unique states. Our player
    can be either in the air or on the ground, so we will want to make sure to separate
    those controls. We also want the player to be able to shoot in multiple directions
    and take damage. All together we will have a total of eight different states:'
  prefs: []
  type: TYPE_NORMAL
- en: Idle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Idle aiming up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Idle aiming down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run aiming up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run aiming down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: InAir
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Damage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start by defining these states as constants:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Resources** | **Define Constants** editor and in the **Name** column
    write `IDLE` with a **Value** of `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Add** or just press *Enter* to add a new row and write `IDLEUP` with
    a value of `1`. Repeat this process for all the states with increasing numbers
    as can be seen in the following screenshot. Then click on **OK**.![Building an
    animation system](img/4100_05_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new Script and name it `scr_Animation_Control`. We will start by using
    a `switch` statement to control the various states. We also want this script to
    be reusable, so we will want to use some generic variables to make the code more
    universal. Let''s start by adding in the idle state with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here we are going to use a variable called `action` to switch states. If the
    action happens to be `IDLE`, we then change the sprite; in this case we are using
    another variable, `myIdle`, that we will define in each object which will allow
    us to reuse this script. We also set the animation rate which will allow us to
    have different playback speeds for different actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to insert all the cases into this script with a similar setup
    of changing the sprite and setting the image playback speed. Here is the rest
    of the code for the states:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We have all the states we need, but what about dealing with the direction that
    the player is facing. It''s a platformer so they will need to go right and left.
    For this we will just flip the image by scaling it inversely with the following
    code after the switch statement closing brace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once again we are utilizing a variable, `facing`, to make the script more universal.
    We are now done with this script and the animation system is ready to be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a collision forecasting system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next system we are going to build is for dealing with world collision.
    We want to move away from using GameMaker: Studio''s collision system as it requires
    two instances to intersect with each other. This works great for a bullet colliding
    with a player, but it is less effective if the player needs to sink into the ground
    in order to know when to stop. Instead, we want to forecast whether a collision
    will happen before an instance moves:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with forecasting wall collision to the left and right of the
    instance. Create a new Script, `scr_Collision_Forecasting` and write the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We start by checking to see if the area to the left of the instance is free
    of collidable objects. The distance away that we are looking is determined by
    a variable, `mySpeed`, which will allow this check to be adjustable to whatever
    speed the instance may be travelling at. If the area is clear we set the `canGoLeft`
    variable to `true`, otherwise the area is blocked and we stop the horizontal speed
    of the instance. We then repeat this check for collision to the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we need to check for the ground collision. After the previous code we
    need to add:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here we are checking if there is a collidable object directly beneath the instance.
    If there is collision, we set the variable `isOnGround` to `true`, to stop the
    vertical speed and then change the state of the instance to `IDLE`. Changing the
    state like this will guarantee that the instance escapes from an `INAIR` state.
  prefs: []
  type: TYPE_NORMAL
- en: At this point we have the majority of our collision detection built, but we
    haven't covered all the edge cases. We are currently only checking to the left,
    right, and below the instance, but not on diagonals. The issue here is that it
    is possible for all conditions to prove true, but when the instance is moved on
    an angle it can result in the instance becoming stuck within a collidable object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than building conditional checks for all angles, we will instead allow
    the collision to happen and then pop it back into the proper position. Add this
    next code at the end of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are checking to see if the instance is currently intersecting with
    a collidable object. If so we set the X and Y coordinates to their position on
    the previous step, then snap it to the surface in the direction of the movement
    and set the vertical speed to zero. This will clean up the edge case scenario
    in a realistic manner. The whole script should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Checking the keyboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we are breaking systems down into more usable scripts we might as well put
    all the keyboard controls into a single script. This will simplify the code that
    we will be creating in the future and also allow us to easily change the controls
    or offer alternative controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Script, `scr_Keyboard_Input` and write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Our code will be much easier to read with variables such as `keyJump` and `keyShoot`
    to represent the controls than actual key names. In order to use the letter keys
    on a keyboard we need the associated ASCII number. Rather than having to look
    up each key number we can use the `ord` function, which will convert a letter
    into the proper number.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using the `ord` function, always use capital letters or it may give the
    wrong number!
  prefs: []
  type: TYPE_NORMAL
- en: We now have all our universal systems that we will need for this game. Next
    we will implement them.
  prefs: []
  type: TYPE_NORMAL
- en: Building the player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The player character we are building is the most complex object we have created
    yet. Not only will the player run and jump, the controls themselves will be slightly
    different depending on whether the player is on the ground or in the air. The
    player will need to know what direction they are facing, what animation to be
    playing, whether they can shoot their weapon, and at what angle. Let''s construct
    this, starting with importing all the sprites:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Sprite, `spr_Player_Idle`, and load `Chapter 5/Sprites/Player_Idle.gif`
    with **Remove Background** checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Origin** to **X**: `32` **Y**: `63` so that it rests in the center
    horizontally and rests on the bottom of the sprite vertically.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on **Modify Mask** to open the **Mask Properties** editor and select
    **Bounding Box** | **Manual**. Set the values to **Left**: `16`, **Right**: `48`,
    **Top**: `8`, and **Bottom**: `63`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat this process, including the same **Origin** and **Mask Properties**
    for the following sprites:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`spr_Player_IdleUp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spr_Player_IdleDown`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spr_Player_Run`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spr_Player_RunUp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spr_Player_RunDown`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spr_Player_InAir`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spr_Player_Damage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an Object, `obj_Player`, and assign `spr_Player_Idle` as the **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First we need to initialize all the variables the player character will need,
    starting with the ones necessary for animation. Create a new Script, `scr_Player_Create`,
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here we are establishing what sprites are to be used for the various states
    of animation. The variables we are using here must be the same as the ones we
    declared in `scr_Animation_Control` in order to use the animation system we created.
  prefs: []
  type: TYPE_NORMAL
- en: Next we will add the variables for the collision system, but before we do that,
    we should add two more constants for the facing direction. Open the **Resources**
    | **Define Constants** and add `RIGHT` with a value of `1` and `LEFT` with a value
    of `-1`. These numbers will represent the scale of the drawn image, with the negative
    value inverting the sprite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the end of `scr_Player_Create` add the rest of the variables we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here we have variables for the speed of the player, the direction the player
    is aiming, the direction they are facing, and the state they are in. We have also
    added variables for whether the player can take damage or is invulnerable, and
    whether they are able to shoot or not. We now have all our variables initialized.
  prefs: []
  type: TYPE_NORMAL
- en: In `obj_Player`, add a **Create** event and apply the `scr_Player_Create` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have a collision forecasting system ready to go, we just need to use it
    appropriately. Create a new Script, `scr_Player_BeginStep`, and use it to call
    the forecasting script and the keyboard checks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Every script you create is actually an executable function. As seen here you
    just need to write the name of the script and place parentheses at the end to
    have that code run. We will be using this method often.
  prefs: []
  type: TYPE_NORMAL
- en: In `obj_Player` add a **Step** | **Begin Step** event and apply `scr_Player_BeginStep`.
    The **Begin Step** event is the very first event in every step to be executed.
    The **Step** event follows it and **End Step** is the last event before the instance
    is drawn on screen. This allows us more control over when the code is run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next we need to create the controls. As we mentioned earlier, there are actually
    two separate control systems, one for on the ground and one for in the air. We
    will start with the latter as it is the simplest. Create a new Script, name it
    `scr_Player_AirControls` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The first thing you should notice is that we are no longer using operators such
    as `==` in our code. These variables are all Booleans, so they can only be true
    or false. Writing `keyLeft` is the same as writing `keyLeft == true`, but is more
    efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Now, since the player is in the air, the first thing we do is apply gravity.
    Next we have the controls for horizontal movement. We check to see if the appropriate
    key is pressed and if the player is able to move in said direction. If these are
    true, we check the horizontal speed against the maximum speed. If the player is
    able to increase speed, we increment it slightly. This prevents the player from
    changing directions too quickly while in the air. We follow this up by setting
    the facing and aiming directions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now move on to the much more complicated ground controls. Create a new
    Script and name it `scr_Player_GroundControls`. We will start by writing the idle
    state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We start by checking whether neither the left nor right keys are being pressed.
    If the keys aren't pressed and the player is moving, we check to see which way
    they are moving and then reduce the speed accordingly. What this really means
    is that the player will slide to a halt.
  prefs: []
  type: TYPE_NORMAL
- en: 'The player has come to a stop, but it is not yet idling. To do this we need
    to determine if the player is using the up or down keys as that will affect which
    direction the player is aiming. Insert this next code immediately after the last
    line of code, but inside the last brace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We start by checking if the up key is pressed, and if it is, we change the action
    to `IDLEUP` and set the aim to 45 degrees so that the player will shoot upwards.
    If that isn't true, we check the down key and change the action and aim if appropriate.
    Finally, if neither of those keys is pressed, we go into the standard `IDLE`.
    For the aim, however, we need to see which way the player is facing first. The
    player will properly idle from now on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we can add the left and right controls. After the very last brace, write
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We check to see if the left key has been pressed and that the player is able
    to move left. If so, we set the horizontal speed and set the facing direction
    to go left. Once again, we check to see if the up or down keys are currently pressed
    or not and then set the action and aim to their proper values.
  prefs: []
  type: TYPE_NORMAL
- en: Repeat the last step for the right key with the values accordingly. The player
    will now be able to move left and right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All we need now is to add in the jump. Immediately after the previous code
    add:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We check to see if the jump key has been pressed and if the player is on the
    ground or not. If this is true, we set the vertical speed upwards to the maximum
    gravity and set the action to `INAIR`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ground controls are now complete; here is what `scr_Player_GroundControls`
    should look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let's move onto the player attack. First we need to build the Bullet, so create
    a new Sprite, `spr_Bullet`, and load `Chapter 5/Sprites/Bullet.gif` with **Remove
    Background** checked. Center the **Origin** and then click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Bullet`, and apply `spr_Bullet` as the **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will want the Bullet to always be in front of everything, so set the **Depth**
    to `-2000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are now done with the Bullet and can now write the attack code. Create a
    new Script, `scr_Player_Attack`, and write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We start by checking to see if the attack key is pressed and whether the player
    is allowed to shoot. If so, we create an instance of the Bullet from the tip of
    the gun and capture the unique ID into a variable. The horizontal position of
    this Bullet uses the facing variable to offset it to the left or right. We set
    the speed of the Bullet and then set the direction and image rotation to where
    the player is aiming. We then set an alarm which will be used to reset the `canFire`
    variable, which we are changing to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point we have several scripts for movement, attacking, and animation,
    but none of them have been applied. To do this we need one more script, `scr_Player_Step`,
    calling the other scripts as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First we determine what controls we need to use by seeing if the player is on
    the ground or not. We then run the appropriate control script, followed by the
    attack script and finally the animation controls.
  prefs: []
  type: TYPE_NORMAL
- en: In `obj_Player`, add a **Step** | **Step** event and apply `scr_Player_Step`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we test this out, we still need to reset that alarm. Create a new Script,
    `scr_Player_Alarm0`, and set `canFire` to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Add an **Alarm** | **Alarm 0** event and apply this script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The player is ready to be tested. To ensure that you have the player set up
    properly, it should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the player](img/4100_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting up the room
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have the player, now we need a world to place it in. Since we are making
    a platformer, we are going to use two types of building block: a ground object
    and a platform object. The ground will be impassable to the player and will be
    used for the outer perimeter. The platform object will allow the player to jump
    through and then land upon it:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Sprite, `spr_Ground`, and load `Chapter 5/Sprites/Ground.gif` with
    **Remove Background** not checked. Click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Ground`, and assign `spr_Ground` as the **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the box for **Solid**. This is necessary as our collision code is looking
    for solid objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's test this out. Create a new Room, and under the **Settings** tab, change
    the name to `BossArena` and change the **Width** to `800`. We will want a good
    size room to fight in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add instances of `obj_Ground` around the border of the room. Also add a single
    instance of `obj_Player` near the floor of the room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. At this point the player should be able to run and jump around
    the room, but not be able to pass through the walls or floor. You should also
    be able to shoot your weapon in a variety of directions. Also notice that the
    animation system is working as intended, with sprites changing based on the player's
    actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now to build the platforms. Create a new Sprite, `spr_Platform`, and load `Chapter
    5/Sprites/Platform.gif` with **Remove Background** not checked. Click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Platform`, and assign `spr_Platform` as the **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We want the platform to be solid only when the player is above it. For this
    we will need to create a new Script, `scr_Platform_EndStep`, with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here we compare the player's Y coordinate with the Y coordinate of the instance.
    If the player is above it, then the platform should be solid. Otherwise it is
    not solid and the player can jump through it.
  prefs: []
  type: TYPE_NORMAL
- en: In `obj_Platform`, add a **Step** | **End Step** event and apply this script.
    We run this code at the end of the step because we want to change only after the
    player has actually moved, but before it does another forecast.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back into the `BossArena` and add some platforms for the player to jump onto.
    The player can only jump around 128 pixels, so make sure the platforms are placed
    appropriately, such as can be seen below.![Setting up the room](img/4100_05_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. The player should be able to jump through the platforms and land
    on top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have successfully developed a series of systems for a platforming game. It
    required us to separate common elements such as the animation system and controls
    into unique scripts. If we were to stop here, it may feel like we did a lot of
    extra work for nothing. However, as we start building our boss battle, we will
    start reaping the rewards for this effort.
  prefs: []
  type: TYPE_NORMAL
- en: Building a boss battle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boss battles are one of the most enjoyable experiences in games. Building a
    good boss battle is always a challenge, but the theory behind it is quite simple.
    The first rule to follow is that a boss should consist of three unique stages
    of increasing difficulty. The second rule is that the boss should emphasize the
    latest skills that the user has acquired. The third and final rule is that the
    player should always have something to do.
  prefs: []
  type: TYPE_NORMAL
- en: Our boss battle will not be against another character, but against a fortress.
    The first stage will consist of three retractable Cannons that will shoot Cannonballs
    across the room. All three Cannons must be destroyed to move onto the second stage.
    Stage two will have a powerful LaserCannon that will move up and down and shoot
    a room wide Laser Beam that the player will need to avoid. The final stage will
    be to destroy the Boss Core that is protected by two Shields. The Shields will
    only be open for a short period of time. During the entire boss fight, there will
    be an indestructible Gun that will shoot bullets at the player wherever they are
    in the room. Each progressing stage, this Gun will fire more rapidly, making the
    game more challenging. Let's start building the boss!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the indestructible Gun
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start with the indestructible Gun since it will be the primary boss
    attack through the battle. The Gun will need to rotate so that it always points
    towards the player. When it shoots a Gun Bullet, the instance of the Gun Bullet
    will come from the tip of the Gun and move in the direction that the Gun is pointing:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by building the Gun Bullet. Create a new Sprite, `spr_Gun_Bullet`,
    and load `Chapter 5/Sprites/Gun_Bullet.gif` with **Remove Background** checked.
    Center the **Origin** and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Gun_Bullet`, and assign `spr_Gun_Bullet` as the **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want the bullets to always appear on top of the ground and platforms. Set
    the **Depth** to -`2000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Gun Bullet is going to damage the player on contact, as will all the other
    projectiles. Once again, let''s build a single system that all weapons can use.
    Create a new Script, `scr_Damage`, with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This script is specifically for the enemy weapons. We start by checking to see
    if the player is not already damaged so that the player isn't punished repetitively.
    Then we reduce the global health by the value indicated by the variable `myDamage`.
    By using a variable like this, we can have different weapons apply differing amounts
    of damage. We then affect the player directly through a `with` statement. We want
    to launch the player into the air, but first we need to raise the player off the
    ground by one pixel first to ensure the ground collision code doesn't snap it
    back down. Next we apply a vertical velocity and a horizontal velocity in the
    opposite direction that they are facing for a push back effect. We set the player's
    action to the `DAMAGE` state and indicate that damage has happened.
  prefs: []
  type: TYPE_NORMAL
- en: Create another new Script, `scr_Gun_Bullet_Create`, and initialize the `myDamage`
    variable. Then apply it to a **Create** event in `obj_Gun_Bullet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let''s create a collision script, `scr_Gun_Bullet_Collision`, which calls
    the damage script and removes the Bullet. We did not put the destruction of the
    instance into `scr_Damage` so that we have the option for weapons that can''t
    be destroyed, use this script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can now add a **Collision** | **obj_Player** event to `obj_Gun_Bullet` with
    this script attached. The Gun Bullet is now complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can now move onto the Gun itself. Start by creating two new Sprites, `spr_Gun_Idle`
    and `spr_Gun_Run`. Load `Chapter 5/Sprites/Gun_Idle.gif` and `Chapter 5/Sprites/Gun_Run.gif`
    to their associated sprite with **Remove Background** checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Gun sprite has the barrel facing to the right so we need to set the origin
    on the left side so that it pivots properly. Set the **Origin** to **X**: `0`
    and **Y**: `16` on both sprites and click on **OK**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Gun`, and assign `spr_Gun_Idle` as the **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will want to make sure that the Gun remains visually on top of the Boss at
    all times so set the **Depth** to `-1000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to initialize some variables in a new Script, `scr_Gun_Create`, which
    will be added to `obj_Gun` as a **Create** event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We will be using the animation system here, so we need to set values for the
    action and facing variables which are required. The following four variables relate
    to the shooting of the Gun. First is `tipOfGun` for where the end of the barrel
    is located, `canFire` is the trigger, `delay` is how long to pause between shots,
    and the alarm will shoot the Gun Bullet. Finally, we have two states of animation
    that we need to apply. We do not need to add all the other variables such as `myDamage`
    unless the object utilizes that state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we will have the Gun track the player and determine when to shoot. Create
    a new Script, `scr_Gun_Step`, which will be placed in a **Step** | **Step** event.
    Here''s the code we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We start by running the animation script. We want the Gun to play the firing
    animation only once, so we check the currently displayed image against the last
    image of the sprite. Using `image_number` gives us the number of frames, but we
    need to subtract by one as frames of animation start at zero. If it is the last
    frame, then the Gun goes into the `IDLE` state. Next we check to see if the Gun
    is to shoot. If it is, we change states to play the shooting animation, set a
    second alarm for 5 frames, and then turn off `canFire`. Finally we track the player
    by rotating the sprite based on the angle between the Gun and the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using two alarms on this object. The first alarm starts the firing animation
    and the second creates the Gun Bullet. Let''s start with the first alarm by creating
    a new Script, `scr_Gun_Alarm0`, for an **Alarm** | **Alarm 0** event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The second alarm has the code for firing the Gun Bullet. Create a new Script,
    `scr_Gun_Alarm1`, that will be added as an **Alarm** | **Alarm 1** event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Since we need the bullet to leave the end of the barrel of the gun we are going
    to need some trigonometry. We could use sine and cosine to calculate the X and
    Y values from the origin of the circle and radial distance, but there is a much
    easier way. Here we are using `lengthdir_x` and `lengthdir_y` to do the math for
    us. All that it needs is the radial distance and the angle which we can then add
    to the local coordinates of the Gun. Once we have those variables, we can create
    the bullet in the proper position, set its speed, and direction. Finally we reset
    the first alarm so that the Gun will fire again.
  prefs: []
  type: TYPE_NORMAL
- en: We are ready to test the Gun. Open BossArena and place an instance of the Gun
    on the far right side of the room. Once we are done testing we will be removing
    the gun from the room, so exact placement doesn't matter at this time.![Creating
    the indestructible Gun](img/4100_05_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Game. The Gun should follow the player wherever they are in the room
    and fire Gun Bullets every three seconds. If the player is hit by a Gun Bullet,
    they will be launched into the air and pushed back with the damage animation playing
    as seen in the previous screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There is one issue, however, with the player''s damage state; the player can
    still move and shoot. This isn''t much of a deterrent to being shot, so let''s
    fix this. Create a new Script, `scr_Player_Damage`, with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We check to see if the player is on the ground or not as that will deactivate
    the damage state. If the player is in the air, we apply gravity and that is it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to call this script. Reopen `scr_Player_Step` and add a conditional
    statement for whether the player is damaged or not. Here is the entire script
    with the new code in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We check to see if the player is in damage mode, and if it is, we run the damage
    script. Otherwise, we function as normal with all the control systems in the `else`
    statement. The animation script is always called regardless of damage.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game. Now when the player is hit, the impact is really noticeable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Constructing the first phase: The Cannons'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first stage weapon is a Cannon that hides itself for protection and only
    exposes itself to shoot. We will have three Cannons stacked on top of each other
    to make the player have to jump onto platforms. To destroy the Cannons the player
    will need to shoot each Cannon while it is exposed:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the Cannonball, create a new Sprite, `spr_Cannonball`, and load
    `Chapter 5/Sprites/Cannonball.gif` with **Remove Background** checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Origin** to **X**: `12`, **Y**: `32` and click on **OK**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Cannonball`, and assign `spr_Cannonball` as the **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Depth** to `-900` so that it will appear in front of most objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To use the damage system, we need to set the proper variables in the **Create**
    event with a new script, `scr_Cannonball_Create`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This weapon is powerful and will cause 10 points of damage. We also set the
    horizontal velocity so that it quickly moves across the room.
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to destroy the Cannonball if it contacts the player, so all
    we need to do is apply `scr_Damage` to a **Collision** | **obj_Player** event.
    The Cannonball is now ready to be shot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Cannon is going to need five sprites, `spr_Cannon_IdleDown`, `spr_Cannon_IdleUp`,
    `spr_Cannon_RunDown`, `spr_Cannon_RunUp`, and `spr_Cannon_Damage`. Load the associated
    files from the `Chapter 5/Sprites/` folder without checking **Remove Background**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Cannon`, and assign `spr_Cannon_IdleDown` as the **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Depth** to `-1000` so that the Cannon will be in front of the rest
    of the Boss parts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As always, let''s create a new Script, `scr_Cannon_Create`, to initialize all
    the variables in the **Create** event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The Cannon will take several hits before it is destroyed, so we have a `myHealth`
    variable to track the damage. We then set the action state by facing to the right,
    as we are not flipping the sprite, and establish a shooting variable. We then
    have all the animation states we need for the Cannon to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we can create a new Script, `scr_Cannon_Step`, for a **Step** | **Step**
    event with the functionality for switching states and firing the Cannonballs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the Gun, we start with calling the animation system script. We then
    check if the Cannon is on the last frame of the animation. Here we have two different
    idle states depending on whether the Cannon is exposed or not. We check to see
    which state we are in and set the appropriate idle state. Next we check if the
    Cannon should shoot, and if it should, we expose the Cannon and set an alarm to
    create the Cannonball in two seconds. Finally, we do a health check and if the
    Cannon is out of life, it removes itself from the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Script, `scr_Cannon_Alarm0`, and add it to an **Alarm** | **Alarm
    0** event with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here we just create a Cannonball and then set the animation to retract the Cannon.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do with the Cannon is have it take damage. Create
    a new Script, `scr_Cannon_Collision`, and apply it to a **Collision** | **obj_Bullet**
    event with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We start by making sure that damage will only be applied if the Cannon is exposed.
    If it is, then we take 10 points of its health, change to the damage animation,
    and remove the bullet. The Cannon is now complete.
  prefs: []
  type: TYPE_NORMAL
- en: Before we try to test the Cannon out, we are going to start constructing the
    Boss. The Cannon doesn't run on its own, but is controlled by the Boss. Create
    a new Object called `obj_Boss`. There is no sprite to assign as the Boss is comprised
    of other objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new Script, `scr_Boss_Create`, to initialize variables in the **Create**
    event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We start by establishing variables for the three phases and whether the boss
    has been defeated. We then create a variable for the X location of the boss with
    the indestructible Gun located in the upper left corner of the room and a tower
    of Cannons right where the Boss is. We establish variables for each weapon so
    that the Boss can control them.
  prefs: []
  type: TYPE_NORMAL
- en: We want the Cannons to shoot in a sequence rather than all together. To do this
    we are going to use a Time Line. Create a new Time Line and name it `tm_Boss_Phase01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Moment** and set **Indicate the moment** to `180`. This will start six
    seconds into the battle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new Script, `scr_Phase01_180`, and fire the middle Cannon. Apply this
    script to the Time Line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Since the player can destroy the Cannons, we need to check to see if the Cannon
    is still in existence. If it is, we set the Cannon's `canFire` variable to true
    and the Cannon code will handle the rest.
  prefs: []
  type: TYPE_NORMAL
- en: Add another **Moment** at `360`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a Script, `scr_Phase01_360`, and activate the other two Cannons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We need to check both Cannons individually so that if one is destroyed, the
    other will still shoot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reopen `scr_Boss_Create` and start a looping Time Line after the last line
    of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Reopen `BossArena` and make sure you remove the instance of the Gun if it is
    still in the room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place an instance of `obj_Boss` on the right side of the map, though the actual
    location does not matter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'None of the parts of the Boss have the **Solid** attribute, which means the
    player can run through them. To fix that, create a barrier wall in front of the
    Boss with instances of `obj_Ground` as seen in the following screenshot:![Constructing
    the first phase: The Cannons](img/4100_05_06.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the game. At the start we should see three Cannons stacked on top of each
    other and the indestructible Gun. The Gun should aim at the player and shoot a
    Gun Bullet every few seconds. Six seconds into the game we should see the middle
    Cannon power up and shortly afterwards shoot a Cannonball. Six seconds after that,
    the upper and lower Cannons should do the same. If the player is hit by an enemy
    projectile they will be knocked back. The player''s bullets will pass by the Cannons
    unless they have been exposed, in which case the Cannon will go into its damage
    state and the bullet disappears. If any Cannon is hit two separate times it will
    blink out of existence. The first phase is now complete and should look like the
    following screenshot:![Constructing the first phase: The Cannons](img/4100_05_07.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Building the second phase: The giant LaserCannon'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the player destroys all the Cannons, the second phase will begin. Here
    we will have a giant LaserCannon that moves constantly up and down. Every few
    seconds it will fire a large Laser Beam that will stretch across the entire room.
    The player can damage the LaserCannon at all times, though it will have much more
    health:'
  prefs: []
  type: TYPE_NORMAL
- en: First we will create the Laser Beam. Create a new Sprite, `spr_LaserBeam`, and
    load `Chapter 5/Sprites/LaserBeam.gif` without checking **Remove Background**.
    The sprite may appear small, being only eight pixels wide, but we will stretch
    this sprite across the screen so it could work in any room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need the origin to be on the right side so that it lines up with the LaserCannon
    barrel properly. Set the **Origin** to **X**: `8` and **Y**: `32`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_LaserBeam`, apply `spr_LaserBeam` as the **Sprite**
    and set the **Depth** to `-600`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new Script, `scr_LaserBeam_Create`, to initialize variables in a **Create**
    event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The amount of damage from this weapon is much higher than the other weapons,
    which is fitting for the second phase. We also have a `myLaserCannon` variable
    that will be used to keep the Laser Beam aligned with the LaserCannon as it moves.
    The value has been set to zero, though this will become the ID of the LaserCannon
    that spawns it, which we will get to in a moment. Finally, we stretch the sprite
    across the room. The variable `image_xscale` is a multiplier, which is why we
    are dividing the room width by eight, the width of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next we will use a **Step** | **End Step** event with a new Script, `scr_LaserBeam_EndStep`,
    to make the beam move with the LaserCannon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We move the X and Y coordinates with the LaserCannon that creates the Laser
    Beam. We are placing this into the **End Step** event because the LaserCannon
    will move on a **Step** event and this will ensure that it is always in the correct
    position.
  prefs: []
  type: TYPE_NORMAL
- en: All that is left is for `scr_Damage` to be added to a **Collision** | **obj_Player**
    event. The Laser Beam is now complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Moving onto the LaserCannon, we will need to create three sprites: `spr_LaserCannon_Idle`,
    `spr_LaserCannon_Run`, and `spr_LaserCannon_Damage`. Load the associated files
    from the `Chapter 5/Sprites/` folder all of which need to have **Remove Background**
    checked.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Origin** of all three sprites to **X**: `16` and **Y**: `56`. This
    will help place the Laser Beam where we want it to be.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_LaserCannon`, and assign `spr_LaserCannon _Idle` as
    the **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Depth** to `-700` so that the LaserCannon is behind the Cannons and
    Gun, but in front of the Laser Beam.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For initializing variables in the **Create** event, create a new Script, `scr_Laser_Create`,
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We first set all the standard variables for the LaserCannon's health, current
    state, facing direction, and that it isn't shooting. We then set all the animation
    system variables for the three states that the LaserCannon has.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is building the functionality of the laser. Create a new Script, `scr_LaserCannon_Step`,
    and add it to a **Step** | **Step** event with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This should be starting to look quite familiar. We start by running the animation
    system script. We then check to see if the last frame of animation has played,
    and if so, set the LaserCannon to its idle state. Next, if the LaserCannon is
    to shoot, we change states and set a short alarm so that the Laser Beam is created
    after the shooting animation has played. Finally, we do a health check and remove
    the LaserCannon if it is out of health.
  prefs: []
  type: TYPE_NORMAL
- en: We aren't done with this script yet. We still need to add in the movement. When
    the LaserCannon is first created, it will not be moving. We don't want it to start
    moving until the second phase has started. After that point we want the LaserCannon
    to take care of the vertical motion.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the LaserCannon move up and down, all we need to do is send it in the
    opposite direction when it passes an end point. Add this code immediately after
    the last line of code in `scr_LaserCannon_Step`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We are going to have the LaserCannon move the entire height of the room. If
    the Y coordinate is less than 64 pixels from the top, we send it downwards. If
    it is greater than 64 pixels from the bottom of the room, we send it upwards.
    We will start the movement in the Boss script in a while.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s get the LaserCannon shooting a Laser Beam! The Laser Beam will be created
    in an **Alarm** | **Alarm 0** event with a new Script, `scr_LaserCannon_Alarm0`,
    attached with the Laser Beam creation code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We create an instance of the beam right at the tip of the LaserCannon and then
    we set the Laser Beam's `myLaserCannon` variable to be the unique ID of the LaserCannon
    that created it. The benefit of doing this means that we could have more than
    one LaserCannon in the room if we wanted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last element we need to construct is the damage state. Create a new Script,
    `scr_LaserCannon_Collision`, and place it into a **Collision** | **obj_Bullet**
    event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Since we don't want the player to be able to destroy the LaserCannon before
    the second phase, we check what phase the Boss is currently in, to determine if
    damage should be applied or not. If the Boss is in the second phase, we reduce
    the LaserCannon's health, change it to the damage state and remove the Bullet.
    The LaserCannon is now complete and ready to be implemented into the Boss.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is add an instance of the LaserCannon. Reopen
    `scr_Boss_Create` and insert this code before the Time Line is run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Next we will build the functionality of the LaserCannon by creating a new Time
    Line and naming it `tm_Boss_Phase02`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To shoot the Laser Beam, add a **Moment** and set **Indicate the moment** to
    `210`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new Script, `scr_Phase02_210`, and assign it with the code to activate
    the LaserCannon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We want to have full control over the duration of the LaserCannon, so we will
    use the Time Line to remove the Laser Beam. Add a **Moment** at `270`. This will
    give us a Laser Beam that lasts two seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Script, `scr_Phase02_270`, and remove the Laser Beam.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: When the LaserCannon shoots, it creates the `beam` variable which we can now
    use to remove it.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that is left is to have the Boss change from the first phase to the second
    phase. For this we will need to add a **Step** | **Step** event to `obj_Boss`
    with a new Script, `scr_Boss_Step`, assigned with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We start by checking if there are any instances of the Cannon remaining in the
    world and if they have all been destroyed, we check to see if the second phase
    has started. Upon the second phase starting, we set the LaserCannon into motion
    downwards and switch the Time Line to the new phase and reset the Time Line to
    the beginning. We are also going to make the challenge a bit more difficult by
    decreasing the delay between shots from the Gun. We end this code by changing
    `isPhase_02` to true so that this is only executed once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the game. The gameplay starts out the same as before, but after the three
    Cannons have been destroyed, we should see the LaserCannon starts to move up and
    down and fire a Laser Beam every seven seconds. The LaserCannon can be hit at
    any time and will take several hits before being destroyed. The indestructible
    Gun should still function as before, but shoot twice as often. The second phase
    is now complete and should look like the following screenshot:![Building the second
    phase: The giant LaserCannon](img/4100_05_08.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Setting the final stage: The shielded Boss Core'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the final stage we are not going to add another weapon, but instead we
    will create a destructible Boss Core that is protected by two Shields. The Shields
    will open every few seconds to expose the Boss Core. We will also change the Gun
    to shoot in quick bursts:'
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the Boss Core. We need to create two new Sprites, `spr_BossCore_Idle`
    and `spr_BossCore_Damage`. With **Remove Background** checked, load `Chapter 5/Sprites/BossCore_Idle.gif`
    and `Chapter 5/Sprites/BossCore_Damage.gif` to the appropriate sprite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Origin** of both sprites to **X**: `-32` and **Y**: `64` so that
    it will be properly located behind the Shields.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_BossCore`, and assign `spr_BossCore_Idle` as the **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Boss Core is a simple object that only requires some animation states and
    health. Create a new Script, `scr_BossCore_Create`, and initialize the required
    variables as follows. Remember to assign this to a **Create** event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We need a **Step** | **Step** event to control the animation states and deal
    with the health, so create another new Script, `scr_BossCore_Step` with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'All the Boss Core now needs is a **Collision** | **obj_Bullet** event to deal
    with damage. Create a new Script, `scr_BossCore_Collision`, and write the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We first check to see if the Boss is in the final phase and that the Boss Core
    is in its idle state. If it is, we reduce the health and switch over to the damage
    animation. We also make sure that the Bullet is removed. The Boss Core is now
    complete and we can move onto the Shields.
  prefs: []
  type: TYPE_NORMAL
- en: We will have two Shields, one that lifts up and the other that will drop down.
    Let's bring in the two sprites that we will need. Create two new Sprites, `spr_Shield_Upper`
    and `spr_Shield_Lower`. Load `Chapter 5/Sprites/Shield_Upper.gif` and `Chapter
    5/Sprites/Shield_Lower.gif` to the associated sprite. Remember to check **Remove
    Background**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Origin** of `spr_Shield_Upper` to **X**: `0` and **Y**: `269` so
    that the origin is on the bottom of the image. We don''t need to change the **Origin**
    of `spr_Shield_Lower`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two new Objects, `obj_Shield_Upper` and `obj_Shield_Lower`, and assign
    the appropriate sprites.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On both the Shields, set the **Depth** to `-500` so that they are in front of
    the Boss Core but behind all the other parts of the Boss.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will build the upper Shield first and we need to initialize some variables
    in a new Script, `scr_ShieldUpper_Create`, applied to a **Create** event in `obj_Shield_Upper`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The first variable will activate whether the Shield is up or down. The second
    variable sets the value for how high to lift the Shield; in this case it will
    move up 64 pixels. Finally we set a variable for the movement speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lower Shield is almost exactly the same except that it moves in the opposite
    direction. Once again, create a new Script, `scr_ShieldLower_Create`, and apply
    it to the **Create** event of `obj_Shield_Lower`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we will add a **Step** | **Step** event to `obj_Shield_Upper`, with a
    new Script, `scr_ShieldUpper_Step`, attached with the following code to control
    the shield''s movement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We start by checking if the Shield is supposed to be down and whether it is
    all the way down or not. If it isn't all the way down, we move the Shield a bit
    down. The second `if` statement does the opposite, checking to see if the Shield
    is supposed to be up and whether it is all the way up. If not, we lift the Shield
    up a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, the lower Shield is almost exactly the same. Create a new Script,
    `scr_ShieldLower_Step`, attached to a **Step** | **Step** event in `obj_Shield_Lower`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The last element we need to deal with is a **Collision** | **obj_Bullet** event,
    which both the Shields can use. Create a new Script, `scr_Shield_Collision`, with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The Shields will never take damage, but they should only detect collision during
    the final phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that all the objects have been prepared, it is time to implement them into
    the Boss. Reopen `scr_Boss_Create` and insert the following code after the last
    weapon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We create the Boss Core and the Shields all at the same location.
  prefs: []
  type: TYPE_NORMAL
- en: Next we will create a Timeline, `tm_Boss_Phase03`, to deal with the Shields
    and Gun functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a **Moment** at `120`, and then create a new Script, `scr_Phase03_120`,
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Here we are setting the Shields to open and increasing the shooting rate of
    the Gun.
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Moment** at `180` and create a new Script, `scr_Phase03_180`. All we
    are going to do here is turn off the Gun's alarm so that there is a brief respite
    in the shooting. This is achieved by setting the delay to -1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Add another **Moment** at `300`, and create a new Script, `scr_Phase03_300`.
    Now we reactivate the Gun's alarm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally we add a **Moment** at `360` with another new Script, `scr_Phase03_360`,
    where we lower the Shields and return the Gun to a regular shooting rate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to add in the switch from the second phase to the final phase.
    Reopen `scr_Boss_Step` and add the following code at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We check whether the LaserCannon has been destroyed and if we are supposed to
    be in the final phase or not. If we are, all we need to do is switch the `timeline`,
    set it to the beginning, and set it to the final phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need now is a win condition which we will add to the same script. At
    the end of `scr_Boss_Step` write the last conditional statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We check to see if the Boss Core has been destroyed and if the win condition
    has been called. If the Boss has been defeated, we stop the Timeline and declare
    the defeat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the game. It will take some time, but the first two phases should be the
    same as before and once the LaserCannon has been destroyed, the final phase activates.
    The Shields should open and the Gun shoots a burst of bullets. There then should
    be a quiet moment where the player can attack the Boss Core. A few seconds later
    the Gun should start firing and the Shields will close. This will repeat until
    the player defeats the Boss. This phase should look like the following screenshot:![Setting
    the final stage: The shielded Boss Core](img/4100_05_09.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Winding it up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are wrapping up this chapter with some elements still left undone, but you
    already have the ability to do this on your own. There are still all the sounds,
    background art, and front end to build. Not only that, but you may have noticed
    that the player cannot be killed. Making the player invincible made it easier
    for us to test out the boss battle, so try the fight again after you have added
    it in. The boss battle is pretty difficult, but also easily altered. Why not try
    changing up the timing in each phase or try adjusting the values of the damage.
    To take this even further you can build levels and enemies that lead up to the
    battle. Have fun with it and it could look something like the following screenshot
    below!
  prefs: []
  type: TYPE_NORMAL
- en: '![Winding it up](img/4100_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations, you have just built an epic boss battle! We started this chapter
    by delving into systems design and creating some very useful scripts. We built
    an animation system that most objects in the game utilized. We learned how to
    forecast for collision and apply our own custom gravity on the player. We even
    created platforms that the player could jump through and land on. We were introduced
    to constants, which has the benefit of making the code easier to read for us and
    more efficient to the computer. We then went on to build a three-phase boss fight
    utilizing all our previous knowledge along with our new systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter we are going to move onto creating a physics-based game
    utilizing GameMaker: Studio''s Box2D implementation. This will use a completely
    different method of collision detection and physics systems. It will also allow
    us to have objects that react to the world with little or no code!'
  prefs: []
  type: TYPE_NORMAL
