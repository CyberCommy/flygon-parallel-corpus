- en: Understanding GraphQL with a Real Project
  prefs: []
  type: TYPE_NORMAL
- en: '**GraphQL** is a query language for APIs that helps them work with your existing
    data. It provides a complete description of the data in your API, and you can
    only request the exact data you need and nothing more. It also makes it easier
    to improve APIs if they need it and has very powerful developer tools.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to use GraphQL in a real project
    by creating a basic login and user registration system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing PostgreSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating environment variables with a `.env` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Apollo Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining GraphQL queries and mutations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with resolvers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Sequelize models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing JWTs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using GraphQL Playground
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js 12+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PostgreSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Homebrew  ([https://brew.sh](https://brew.sh))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pgAdmin 4 ([https://www.pgadmin.org/download/](https://www.pgadmin.org/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OmniDB ([https://omnidb.org](https://omnidb.org))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter in this book''s GitHub repository: [https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: Installing PostgreSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this example, we will use a PostgreSQL database, so you'll need to install
    PostgreSQL to be able to run this project on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a macOS machine, the easiest way to install PostgreSQL is by doing
    so with Homebrew. You just need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve installed it, you need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can create two new aliases to start and stop your PostgreSQL server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, you should be able to start your PostgreSQL server by using `pg_start`
    or stop it with `pg_stop`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, you need to create your first database, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can connect to PostgreSQL using the `psql` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you get an error stating `role "postgresql" does not exist`, you can fix
    it by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you did everything correctly, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/34a756a4-ec9b-4a38-8d90-6eb502669329.png)If you use Windows, you
    can download PostgreSQL at [https://www.postgresql.org/download/windows/](https://www.postgresql.org/download/windows/)
    and for those that use Linux (Ubuntu), you can download it from [https://www.postgresql.org/download/linux/ubuntu/](https://www.postgresql.org/download/linux/ubuntu/).'
  prefs: []
  type: TYPE_NORMAL
- en: Best tools for PostgreSQL database management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the bests tools for PostgreSQL database management is **pgAdmin 4** ([https://www.pgadmin.org/download/](https://www.pgadmin.org/download/)).
    I like this tool as it can be used to create new servers, users, and databases.
    The other tool I like to use to perform SQL queries and work with data is **OmniDB**
    ([https://omnidb.org](https://omnidb.org)). I highly recommend that you install
    both tools.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to create a database in order to use it in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you may get an error when you start your PostgreSQL server that could
    say something like
  prefs: []
  type: TYPE_NORMAL
- en: '`FATAL: lock file "postmaster.pid" already exists`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you get this error, you can easily fix it by running the `rm /usr/local/var/postgres/postmaster.pid`
    command. Then, you will be able to start your PostgreSQL server.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our .env file and configuration files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, you need to create a backend directory in your GraphQL project (`graphql/backend`),
    after that let''s review the huge list of NPM packages you will need to install
    (the most relevant):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The scripts you should have in your `package.json` file should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we are going to configure our environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring our .env file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `.env` file (also known as `dotenv`) is a configuration file to specify your
    application''s environment variables. Normally your application won''t change
    from development, staging, or production environments but they normally need a
    different configuration: the most common variables to change are the base URL,
    API URL, or even your API keys.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we jump into the actual login code, we need to create a file called
    `.env` (normally, this file is ignored by `.gitignore`), which will allow us to
    use private data, such as the database connection and security secrets. A file
    already exists in the repository called `.env.example`; you just need to rename
    it and put your connection data inside it. This will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Creating a basic config file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this project, we need to create a config file, which should be created
    at `/backend/config/config.json`. Here, we will define some basic configurations,
    such as our server''s port and some security information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to create an `index.ts` file. This will bring in all the database
    connection information we defined in the `.env` file using the `dotenv` package
    and then export three configuration variables called `$db`, `$security`, and `$server`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If your `.env` file is not at the root or does not exist, all your variables
    are going to be `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Apollo Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apollo Server is the most popular open source library that works with GraphQL
    (server and client). It has a lot of documentation and is really easy to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram explains how Apollo Server works in the client and the
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f53621c2-5f75-4fa9-b8fd-a38cee633d22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are going to use Express to set up our Apollo Server and Sequelize ORM to
    handle our PostgreSQL database. So, initially, we need to do some imports. The
    required file can be found at `/backend/src/index.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we need to create our schema using `makeExecutableSchema` by passing
    `typeDefs` and `resolvers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to create an instance of `ApolloServer`, where we need to pass
    the schema and the models in the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to synchronize Sequelize. Here, we are passing some optional
    variables (`alter` and `force`). If `force` is `true` and you change your Sequelize
    models, **this will delete your tables, including their values**, and force you
    to create the tables again, while if `force` is `false` and `alter` is `true`,
    **then you will only update the table fields, without this affecting your values**.
    So, you need to be careful with this option as you can lose all your data by accident.
    Then, after the sync, we must run our Apollo Server, which is listening to port
    `5000` (`$server.port`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will help us synchronize our database with our models so that any time
    we make a change to the models, the tables are going to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Defining our GraphQL types, queries, and mutations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you've created your Apollo Server instance, you need to create your
    GraphQL types. In this case, we will create some types, queries, and mutations
    for users.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to do is define your scalar types at `/backend/src/graphql/types/Scalar.graphql`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create our `User.graphql` file with our initial `User` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are using some scalar types such as `UUID` and `Datetime`
    to define some fields in our `User` type. In this case, when you define a type
    in GraphQL, you need to do so with the `type` keyword, followed by the type's
    name capitalized. Then, you can define your fields inside the curly braces, `{}`.
  prefs: []
  type: TYPE_NORMAL
- en: There are some primitive data types in GraphQL such as `String`, `Boolean`,
    `Float`, and `Int`. You can define custom scalar types as we did with `UUID`,
    `Datetime`, and `JSON`, and you can also define custom types such as the `User`
    type and specify whether we want an array of that type; for example, `[User]`.
  prefs: []
  type: TYPE_NORMAL
- en: The `!` character after the types means the field is **non-nullable**.
  prefs: []
  type: TYPE_NORMAL
- en: Queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GraphQL queries are used to read or fetch values from a data store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to define custom types, let''s define our `Query` type.
    Here, we are going to define `getUsers` and `getUserData`. The first will retrieve
    a list of users, while the second will bring us the data of the specific user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this case, our `getUsers` query is going to return an array of users (`[User!]`),
    while our `getUserData` query, which requires the `at` (**access token**) attribute,
    will return a single `User!`. Remember that with any query you add here, you will
    need to define it under your resolvers later (we will do that in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: Mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mutations are used to write or post values – that is, to modify data in the
    data store – and return a value if you want to do some comparisons with REST,
    such as perform any POST, PUT, or DELETE actions. The `Mutation` type works exactly
    the same as the `Query` type in there you need to define your mutations and specify
    what arguments you will receive and what data you will return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have defined two mutations. The first is `createUser`, to
    register or create a new user in our data store, while the second one is to perform
    a `login`. As you may have noticed, both are receiving the `input` argument with
    some different values (`CreateUserInput` and `LoginInput`), called **input types**,
    which are used as query or mutation parameters. Finally, they will return the
    `User!` type and `AuthPayload!`, respectively. Let''s learn how to define those
    inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The inputs are normally used with mutations, but you can also use them with
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: Merging our type definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've defined all our types, queries, and mutations, we need to merge
    all our GraphQL files to create our GraphQL schema, which is basically one big
    file containing all our GraphQL definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, you need to create a file called `/backend/src/graphql/types/index.ts`
    that contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We are using `@graphql-tools` packages to load our GraphQL files and merging
    them into `typesArray` using the `mergeTypesDefs` method.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our resolvers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A resolver is a function that's responsible for generating data for a field
    in your GraphQL schema. It can normally generate the data in any way you want,
    in that it can fetch data from a database or by using a third-party API.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create our user resolvers, you need to create a file called `/backend/src/graphql/resolvers/user.ts`.
    Let''s create a skeleton of what our resolver should look like. Here, we need
    to specify the functions that are defined under `Query` and `Mutation` in our
    GraphQL schema. So, your resolver should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are returning an object with two main nodes called `Query`
    and `Mutation`, and we are mapping the queries and the mutations we defined in
    our GraphQL schema (the `User.graphql` file). Of course, we need to make some
    changes to receive some parameters and return some data, but I wanted to show
    you the basic skeleton of a resolver file first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to do is add some imports to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We will create the `doLogin` and `getUserBy` functions in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the getUsers query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our first method will be the `getUsers` query. Let''s see how we need to define
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In any query or mutation method, we always receive four parameters: the parent
    (defined as **_**), arguments (defined as `args`), the context (defined as `ctx`),
    and `info` (which is optional).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to simplify the code a little bit, you can destructure the context,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In our next resolver function, we are going to destructure our arguments as
    well. Just as a reminder, the context is being passed in our Apollo Server setup
    (we did this previously):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The context is very important when we need to share something globally in our
    resolvers.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the getUserData query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This function needs to be async because we need to perform some asynchronous
    operations, such as getting the connected user via an `at` (access token) if a
    user already has a valid session. Then, we can validate whether this is a real
    user by looking at our database. This helps stop people from modifying the cookies
    or trying to do some form of injection. If we don''t find a connected user, then
    we return an object of the user that contains empty data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Creating the mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our mutations are very simple – we just need to execute some functions and
    pass all our arguments by spreading the input value (this is coming from our GraphQL
    schema). Let''s see what our `Mutation` node should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You need to pass the email, password, and models to the `doLogin` function.
  prefs: []
  type: TYPE_NORMAL
- en: Merging our resolvers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we did with our types definitions, we need to merge all our resolvers using
    the `@graphql-tools` packages. You need to create the following file at `/backend/src/graphql/resolvers/index.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will combine all your resolvers into an array of resolvers.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Sequelize models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we jump into the authentication functions, we need to create our `User`
    model in Sequelize. For this, we need to create a file at `/backend/src/models/User.ts`.
    Our model will have the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`privilege`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`active`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are defining a Sequelize Hook called `beforeCreate`, which
    helps us encrypt (using `sha1`) the user password right before the data is saved.
    Finally, we return the `User` model.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting Sequelize to a PostgreSQL database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve created the user model, we need to connect Sequelize to our
    PostgreSQL database and put all our models together. You need to add the following
    code to the `/backend/src/models/index.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Authentication functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Step by step, we are putting all the puzzle pieces together. Now, let's look
    at the authentication functions we are using to validate whether a user is connected
    or not and get the user's data. For this, we need to use **JSON Web Tokens** (**JWTs**).
  prefs: []
  type: TYPE_NORMAL
- en: What is JSON Web Token?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JWT** is an open standard – RFC 7519 ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519))
    – which is useful for transmitting information between parties as a JSON object.
    The advantage of JWTs is that they are digitally signed, which is why they can
    be verified and trusted. It uses the HMAC algorithm to sign the token by using
    a secret or a public key pair using RSA or ECDSA.'
  prefs: []
  type: TYPE_NORMAL
- en: JWT functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create some functions that will help verify a JWT and get the user data.
    For this, we need to create the `jwtVerify`, `getUserData`, and `createToken`
    functions. This file should be created at `/backend/src/lib/jwt.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `jwt.sign` is used to create a new JWT, while `jwt.verify` is
    used to validate our JWT.
  prefs: []
  type: TYPE_NORMAL
- en: Creating authentication functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we''ve created the JWT functions, we need to create some functions
    that will help us log in at `/backend/src/lib/auth.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are validating whether the user exists by email, whether the password
    is correct, and whether the account is active in order to create the JWT.
  prefs: []
  type: TYPE_NORMAL
- en: Types and interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we need to define our types and interfaces for all our Sequelize models
    and GraphQL inputs. For this, you need to create a file at `/backend/src/types/types.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create our interfaces at `/backend/src/types/interfaces.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to export both files in `/backend/src/types/index.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When you need to add more models, remember to always add your types and interfaces
    to those files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to create your `tsconfig.json` file at the root directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we are going to run our project and create our tables.
  prefs: []
  type: TYPE_NORMAL
- en: Running our project for the first time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you followed the previous sections correctly and run the `npm run dev` command,
    you should be able to see that the `Users` table is being created and that Apollo
    Server is running on port `5000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5f430c43-93a6-4a50-ba6f-edeeb9be19f8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s say that you want to modify your user model and change the `"username"`
    field to `"username2"`. Let''s see what will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This will execute the following SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s suppose you changed the `force` constant in your `index.ts` file
    to `true`. The following will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8beddecf-b8ea-45e8-a30a-de8695d88145.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, if `force` is `true`, it will execute `DROP TABLE IF EXISTS
    "Users" CASCADE;`. This will completely remove your table and values and then
    recreate your table from scratch. That's why you need to be careful when you use
    the `force` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, if you open `http://localhost:5000`, you should be able to see
    your GraphQL Playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3ff9f5e1-fda9-49ee-8b39-21dcd31a3593.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we are ready to test our queries and mutations.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our GraphQL queries and mutations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Great! At this point, you''re very close to executing your first GraphQL query
    and mutation. The first query we will execute is going to be `getUsers`. The following
    is the correct syntax for running a query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: When you don't have any attribute to pass to the query, you just need to specify
    the name of the query under the `query {...}` block and then specify the fields
    you want to retrieve once you've executed your query. In this case, we want to
    fetch the `id`, `username`, `email`, and `privilege` fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run this query, you will probably get an empty array of data. This is
    because we don''t have any users registered yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ebde4ff2-1a7a-4738-af50-6d465f34a1c7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This means we need to execute our `createUser` mutation in order to register
    our first user. One thing I like about GraphQL Playground is that you have all
    the schema documentation in the DOCS tab on the right-hand side. If you click
    on the DOCS tab, you will see all your queries and mutations listed. Let''s click
    there and select our `createUser` mutation to see what needs to be called and
    what data may be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7cc48a8b-a914-4078-9c57-6b96520abc21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the `createUser` mutation needs an input argument, which is
    `CreateUserInput`. Let''s click on that input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c1ec6778-c671-409b-aad8-d7337661de61.png)'
  prefs: []
  type: TYPE_IMG
- en: Awesome! Now, we know that we need to pass the `username`, `password`, `email`,
    `privilege`, and `active` fields in order to create a new user and that we will
    receive the same fields, plus the generated ID, for the user. Let's do this!
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new tab so that you don''t lose the code of your first query and then
    write the mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, your mutation needs to be written under the `mutation {...}`
    block, and you must pass the input argument as an object. Finally, you must specify
    the fields you want to retrieve once the mutation has been executed correctly.
    If everything is OK, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/06124e63-8eaf-4ba4-b5c6-692ca2f79ef8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you''re curious and wish to take a look at the terminal where you''re running
    your Apollo Server, you will see the SQL query that was performed for this user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `VALUES` variables are handled by Apollo Server, so you won't see the actual
    values in there, but you can find out which operation is being executed in the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Now, go back to your first query (`getUsers`) and run it again!
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1f0832dd-8995-4248-baf9-fb6d4565b703.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Nice – this is your first query and mutation that have been executed correctly
    in GraphQL. If you want to see this data in your database, you can use OmniDB
    to view your `Users` table in your PostgreSQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cdb74ae3-3a5f-4d96-b7f4-2b20fa8890d3.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, our first record has its own `id` field (UUID) and also has
    an encrypted `password` field (do you remember our `beforeCreate` Hook in the
    user model?). By default, Sequelize will create the `createdAt` and `updatedAt`
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: Validations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you may recall, regarding our user model, you will want to make sure all
    the validations we did are working fine, such as whether the user is unique or
    whether their email is valid and unique. You just need to execute the exact same
    mutation again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a9f45ac1-2c20-422e-9aa0-f27175f9dd65.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we will get a `"username must be unique"` error message because
    we''ve already registered the `"admin"` username. Now, let''s try to change the
    username to `"admin2"` but leave the email as is (`admin@js.education`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8d918236-1d29-4074-80c2-bcd31fadbcd8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will also get an `"email must be unique"` error for the email. Now, try
    to change the email to something invalid, such as `admin@myfakedomain`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c4ae35ab-dd85-4b0e-b04b-7e8e727ec89d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we''re getting an `"Invalid email"` error message. This is just amazing,
    don''t you think? Now, let''s stop playing with the validations and add a new
    valid user (`username: admin2`, `email: admin2@js.education`). Once you''ve created
    your second user, run our `getUsers` query once more. However, this time, add
    the `"active"` field to the list of fields we want to return:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e884bf63-a32e-4c8f-b0c6-7adea767f4aa.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have two registered users, and both are inactive accounts (`active =
    false`).
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing I love about GraphQL is that when you''re writing your queries or
    mutations and you don''t remember a certain field, GraphQL will always show you
    the list of available fields for that query or mutation. For example, if you just
    write the letter `p` for the password, you will see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/44ce1fd2-0f38-44ea-8072-0607a3647109.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we are ready to try and log in!
  prefs: []
  type: TYPE_NORMAL
- en: Performing a login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I want to congratulate you for getting to this point in this book – I know we
    have covered a lot, but we are almost there! Now, we are going to try and log
    in with GraphQL (how crazy is that?).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to write our login mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to log our user in by using `"fake@email.com"` as our email and
    `"123456"` as our password. These do not exist in our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2ac6af0e-81ca-4bb4-9c62-74e7c9714aac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Because the email does not exist in our database, an `"Invalid Login"` error
    message will be returned. Now, let''s add the correct email but use a fake password:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d1e1b450-ddbb-4f87-b953-17c830ef667d.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we are receiving the exact same error (`"Invalid Login"`). This
    is because we don't want to provide too much information about what's wrong with
    the login as someone may be trying to hack another user. If we say something such
    as `"Invalid password"` or `"Your email does not exist in our system"`, we are
    giving the attackers extra information that they may find useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to connect with the correct user and password (`admin@js.education
    / 123456`) and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3184a87d-55d9-472d-a074-6694f4d8686e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we are receiving an error stating `"Your account is not activated yet"`.
    This is OK because our user has not been activated yet. Normally, when a user
    is registered in a system, you need to send a link to their email so that they
    can activate their account. We don''t have this feature at the moment, but let''s
    suppose we sent that email and the user has already activated their account. We
    can simulate this by manually changing the value in our database using OnmiDB.
    We can do this by performing an `UPDATE` SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4592d78c-f4e9-4d76-aa46-fc85a1394287.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's try to log in again!
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/111759ec-1952-4aa5-a3c0-0992240a5e26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Nice – we are in baby! **You at this point**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c1670e9c-4548-440a-80a0-9e9baab11647.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '*We are anonymous, we are legion, we do not forgive, we do not forget, expect
    us!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve logged in and retrieved our JWT, let''s copy that huge string
    and use it in our `getUserData` query to see whether we can get the user''s data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything went well, then you should get the user''s data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0b4f0c18-ec40-4914-bca5-119771e37789.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you change or remove any letter from the string (meaning the token is invalid),
    then you should get empty user data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/519b4e1e-6271-4d4d-be9a-71ff7e72fcc7.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that our login system works perfectly in the backend, it is time to implement
    this in the frontend application. We'll do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Building a frontend login system with Apollo Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to build the backend for a login system
    using Apollo Server to create our GraphQL queries and mutations. You are probably
    thinking, *Great, I have the backend working, but how can I use this on the frontend?*
    And you're right – I always like to explain things with full examples and not
    just show basic things, even if this will take longer to do, so let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for the example in this section at [https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter05/graphql/frontend](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter05/graphql/frontend).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Webpack 5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of using a `create-react-app`  project, we will configure a React project
    from scratch using Webpack 5 and Node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is install all the packages we are going to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The buffer,  `crypto-browserify`, and  `stream-browserify`  are polyfills that
    were included by default in Webpack <= 4\. However, in the latest version (Webpack
    5), these are not included anymore, so you will get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b89f72fb-3f13-4d52-919d-20fef237f684.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You need to have those scripts in your `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check our Webpack 5 configuration file (`/frontend/webpack.config.ts`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you need to create the  `index.html`  file, which should be
    at  `/frontend/src/index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will configure our TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring our TypeScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our  `tsconfig.json` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's learn how to configure the Express server.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Express server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our application requires the Express server so that we can perform validations.
    These will help us find out whether the user is connected (using a custom middleware,
    which I''ll explain later) and can also configure our Express sessions. We have
    four main routes on our site:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/`: Our home page  **(handled by React)**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dashboard`: Our dashboard, which is protected. Only connected users with
    god or admin permissions are allowed  **(handled by Express first then by React)**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/login`: Our login page  **(handled by React)**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/logout`: This will delete our existing session  **(handled by Express)**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at our server code. The following file should exist at  `/frontend/src/server.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are protecting our dashboard route with the  `isConnected`  middleware.
    Here, we are validating that we only accept users that are not connected in the
    `login` route.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our frontend configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we need to create our frontend configuration. So, let''s create the  `common.json`  configuration
    at  `/frontend/src/config/common.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create our  `local.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to create our  `production.json` file; for now since we don''t
    have an actual production environment we will use the same localhost URL, but
    once you put this project in a production environment then you will need to change
    it for the actual domain name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve defined our configuration files, we need to create an  `index.ts`  file
    so that we can merge and export our configuration as an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to create a user called `middleware`  and the  `jwt`  functions
    to validate whether the user is connected and has the correct privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A middleware is a function that has access to the request object (req), the
    response object (res), and the next function in the application''s request-response
    cycle. The next function is a function in the Express router that, when invoked,
    executes the middleware succeeding the current middleware. The following diagram
    describes the middleware flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f353071c-3986-4906-ab1d-43ad4fa4c0db.png)'
  prefs: []
  type: TYPE_IMG
- en: In our  case, we will create the  `isConnected`  middleware to validate if a
    user is connected and has the correct privileges. If not, then we will break the
    flow and redirect them to the login page. If the user is valid, we will execute
    the next piece of middleware, which will render our React application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram describes this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/941997a7-1499-45cc-b9a3-45511468fce2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s apply the theoretical part to our code. The required file should exist
    at  `/frontend/src/lib/middlewares/user.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Basically, with this middleware, we can control whether we want to validate
    whether the user is connected (`isLogged = true`). Then, we can validate specific
    privileges (`privileges = ['god', 'admin']`) and redirect the user if they are
    not connected or do not have the correct privileges (`redirectTo = '/'`).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we are using the `getUserData` function from  `jwt`. We'll create
    our  `jwt`  functions in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating JWT functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, when I explained the backend code, I talked about
    JWTs. In the frontend, we need those functions to validate our token and get the
    user''s data. Let''s create a file containing the following code at  `/frontend/src/lib/jwt.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our `getUserData` function will retrieve the user data using
    `accessToken`, which we grabbed from the cookies. It is important that the JWT
    is valid.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our GraphQL queries and mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've already created the required queries and mutations in our backend project.
    At this point, we need to create some files that will execute them in our frontend
    project. For now, we just need to define our  `getUserData`  query and our login
    mutation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our  `getUserData`  query at  `/frontend/src/graphql/user/getUserData.query.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Our login mutation should be at  `/frontend/src/graphql/user/login.mutation.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have defined our query and mutation, let's create the user context
    so that we can use them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our user context to handle the login and the connected user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our user context, we are going to have a login method that will execute our
    mutation and validate whether the email and password are correct. We are also
    going to export the user data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create this context at  `/frontend/src/contexts/user.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are handling the login and got the  `connectedUser`  data
    in our context. Here, we are executing `GET_USER_DATA_QUERY` all the time to verify
    whether the user is connected (validating against the database and not just with
    the cookies).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring our Apollo Client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have created a lot of code, but none of it is going to work if we
    don''t configure our Apollo Client. To configure it, we need to add it to our
    index file at  `/frontend/src/index.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Basically, we are passing `config.apiUrl`, which is where GraphQL Playground
    is running (`http://localhost:5000/graphql`), and then wrapping our  `AppRoutes`  component
    with the  `ApolloProvider`  component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our app routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to use  `react-router-dom`  to create our application routes.
    Let''s create the required code at  `/frontend/src/AppRoutes.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are adding some pages to our routes, such as `HomePage`,  `DashboardPage`  (protected),
    and  `LoginPage`. If the user tries to access a different URL, then we will display
    an  `Error404`  component. We'll create these pages in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The  Home  page should be at  `/frontend/src/pages/home.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The  Dashboard  page should be at  `/frontend/src/pages/dashboard.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The  Login  page should be at  `/frontend/src/pages/login.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to create our  `Error404`  page (`/frontend/src/pages/error404.tsx`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We are almost done. The last piece of this puzzle is to create the  `Login`  and
    `Dashboard`  components. We'll do that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our Login components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I created some basic components for our login and our dashboard. Of course,
    their styles can be improved, but let's see how they work and how our login system
    is going to look.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first file you need to create is called `LoginLayout.tsx`  at `/frontend/src/components/users/LoginLayout.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The layout file is good when we want to add a specific layout to our components.
    It is also good for consuming data from a context and passing the data or functions
    as props.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our  `Login`  component should look like this (`/frontend/src/components/users/Login.tsx`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We'll create the `Dashboard` components in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our Dashboard components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s create our  `Dashboard`  components. The first one should be the  `DashboardLayout.tsx`
    file at `/frontend/src/components/dashboard/DashboardLayout.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we protect our  Dashboard  page to allow only connected users.
    Now, let''s create our  `Dashboard`  component at `/frontend/src/components/dashboard/Dashboard.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: And with that, we're done! We'll test the login system in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our login system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you followed the previous sections correctly, then you should be able to
    run the login system successfully. To do this, we need to open three terminals:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first one, you need to run your backend project (`npm run dev`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second one in your frontend project, you need to build your project (`npm
    run build`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the last one, you need to run the node server in the frontend project (`npm
    run dev`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you open `http://localhost:3000` for the first time, you should be able
    to see the Home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/300b98ca-c7dc-4116-9b17-2417f87a0e27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, if you click on the  Go to Dashboard  (`http://localhost:3000/dashboard`)  link,
    you will be redirected to `http://localhost:3000/login?redirectTo=/dashboard`,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/215eb66b-b6f9-4eaa-9070-f49f202e3b27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is our login form. If you try to log in with some fake credentials, you
    should get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/44a235c3-665c-4d3c-92a5-11de5afec9bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to see the GraphQL request, you can do so on the Chrome Network
    tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/edf13895-ebe2-4975-8585-97dd94bb7752.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, you can see the query you''re executing and the variables you''re sending
    (email and password). You can see the response on the  Preview  tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b9ef4f2e-65f3-47ae-9746-822ac1ac45cf.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we are getting an `"Invalid Login"` error message, and that's
    why we are rendering it in our  `Login`  component. Now, let's try to connect
    with the correct account (`admin@js.education / 123456`).
  prefs: []
  type: TYPE_NORMAL
- en: 'If your login is correct, then you should be redirected to the dashboard, where
    you will see the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a99ef623-b988-4ca3-a9db-4dc8011b4ad7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, you can take a look at the query that is being executed to retrieve the
    user data (`getUserData`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c65ff951-c095-4049-9389-0a603375be0e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, you will see that the payload is being returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fb078044-e451-4e0e-9d62-c0f539471caa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are getting the user information from the access token (`at`). Now, if you
    refresh the page, you should remain connected to the page. This is because we
    saved a cookie containing our token:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c7d2fe96-af44-479f-a81b-5b0587730ea0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s try to modify the cookie by changing any letter of the token. For
    example, let''s change the first two letters (`ey`) to  `XX`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/27a38ecb-0983-426c-82fe-450799d78762.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, you will receive empty data for the user. This is going to invalidate
    the session and redirect you to the login page again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5733fbfd-0098-458b-9861-e814f0eca71b.png)'
  prefs: []
  type: TYPE_IMG
- en: At this point, you have learned how to implement GraphQL in a backend and how
    to consume queries and mutations in the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: This login system is part of a course I'm doing on YouTube where I'm teaching
    viewers how to develop a headless CMS from scratch, so if you're eager to learn
    more, you can check out the course at [https://www.youtube.com/watch?v=4n1AfD6aV4M](https://www.youtube.com/watch?v=4n1AfD6aV4M).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I really hope you enjoyed reading this chapter, which contained a lot of information
    about GraphQL and how to create JWTs, perform a login, and create models with
    Sequelize.
  prefs: []
  type: TYPE_NORMAL
- en: It is now time to talk about data fetching and one-way data flow, which is what
    we will look at in the next chapter.
  prefs: []
  type: TYPE_NORMAL
