- en: Chapter 11. Implementing Software Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an array to object hydrator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an object to array hydrator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a strategy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a mapper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing object-relational mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Pub/Sub design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea of incorporating **software design patterns** into **object-oriented
    programming** (**OOP**) code was first discussed in a seminal work entitled *Design
    Patterns: Elements of Reusable Object-Oriented Software*, authored by the famous
    Gang of Four (E. Gamma, R. Helm, R. Johnson, and J. Vlissides) in 1994\. Defining
    neither standards nor protocols, this work identified common generic software
    designs that have proven useful over the years. The patterns discussed in this
    book are generally thought to fall into three categories: creational, structural,
    and behavioral.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of many of these patterns have already been presented in this book.
    Here is a brief summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Design pattern | Chapter | Recipe |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Singleton | 2 | Defining visibility |'
  prefs: []
  type: TYPE_TB
- en: '| Factory | 6 | Implementing a form factory |'
  prefs: []
  type: TYPE_TB
- en: '| Adapter | 8 | Handling translation without `gettext()` |'
  prefs: []
  type: TYPE_TB
- en: '| Proxy | 7 | Creating a simple REST clientCreating a simple SOAP client |'
  prefs: []
  type: TYPE_TB
- en: '| Iterator | 23 | Recursive directory iteratorUsing iterators |'
  prefs: []
  type: TYPE_TB
- en: In this chapter, we will examine a number of additional design patterns, focusing
    primarily on Concurrency and Architectural patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an array to object hydrator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Hydrator** pattern is a variation of the **Data Transfer Object** design
    pattern. Its design principle is quite simple: moving data from one place to another.
    In this illustration, we will define classes to move data from an array to an
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we define a `Hydrator` class that is able to use getters and setters.
    For this illustration we will use `Application\Generic\Hydrator\GetSet`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a `hydrate()` method, which takes both an array and an object
    as arguments. It then calls the `setXXX()` methods on the object to populate it
    with values from the array. We use `get_class()` to determine the object''s class,
    and then `get_class_methods()` to get a list of all methods. `preg_match()` is
    used to match the method prefix and its suffix, which is subsequently assumed
    to be the array key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate how the array to hydrator object is used, first define the `Application\Generic\Hydrator\GetSet`
    class as described in the *How to do it...* section. Next, define an entity class
    that can be used to test the concept. For the purposes of this illustration, create
    a `Application\Entity\Person` class, with the appropriate properties and methods.
    Be sure to define getters and setters for all properties. Not all such methods
    are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now create a calling program called `chap_11_array_to_object.php`,
    which sets up autoloading, and uses the appropriate classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you can define a test array with values that will be added to a new `Person`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now call `hydrate()` and `extract()` in a static manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building an object to array hydrator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is the converse of the *Creating an array to object hydrator* recipe.
    In this case, we need to pull values from object properties and return an associative
    array where the key will be the column name.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this illustration we will build upon the `Application\Generic\Hydrator\GetSet`
    class defined in the previous recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `hydrate()` method defined in the previous recipe, we define an `extract()`
    method, which takes an object as an argument. The logic is similar to that used
    with `hydrate()`, except this time we''re searching for `getXXX()` methods. Again,
    `preg_match()` is used to match the method prefix and its suffix, which is subsequently
    assumed to be the array key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we have defined `hydrate()` and `extract()` as static methods for
    convenience.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define a calling program called `chap_11_object_to_array.php`, which sets up
    autoloading, and uses the appropriate classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define an instance of `Person`, setting values for its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, call the new `extract()` method in a static manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing a strategy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is often the case that runtime conditions force the developer to define several
    ways of doing the same thing. Traditionally, this involved a massive `if/elseif/else`
    block of commands. You would then either have to define large blocks of logic
    inside the `if` statement, or create a series of functions or methods to enable
    the different approaches. The strategy pattern attempts to formalize this process
    by having the primary class encapsulate a series of sub-classes that represent
    different approaches to solve the same problem.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this illustration, we will use the `GetSet` hydrator class defined previously
    as a strategy. We will define a primary `Application\Generic\Hydrator\Any` class,
    which will then consume strategy classes in the `Application\Generic\Hydrator\Strategy`
    namespace, including `GetSet`, `PublicProps`, and `Extending`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We first define class constants that reflect the built-in strategies that are
    available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define a constructor that adds all built-in strategies to the `$strategies`
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We also add an `addStrategy()` method that allows us to overwrite or add new
    strategies without having to recode the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `hydrate()` and `extract()` methods simply call those of the chosen strategy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The tricky bit is figuring out which hydration strategy to choose. For this
    purpose we define `chooseStrategy()`, which takes an object as an argument. We
    first perform some detective work by way of getting a list of class methods. We
    then scan through the list to see if we have any `getXXX()` or `setXXX()` methods.
    If so, we choose the `GetSet` hydrator as our chosen strategy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Still within our `chooseStrategy()` method, if there are no getters or setters,
    we next use `get_class_vars()` to determine if there are any available properties.
    If so, we choose `PublicProps` as our hydrator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If all else fails, we fall back to the `Extending` hydrator, which returns
    a new class that simply extends the object class, thus making any `public` or
    `protected` properties available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now we turn our attention to the strategies themselves. First, we define a new
    `Application\Generic\Hydrator\Strategy` namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the new namespace, we define an interface that allows us to identify any
    strategies that can be consumed by `Application\Generic\Hydrator\Any`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetSet` hydrator is exactly as defined in the previous two recipes, with
    the only addition being that it will implement the new interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The next hydrator simply reads and writes public properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Finally, `Extending`, the Swiss Army knife of hydrators, extends the object
    class, thus providing direct access to properties. We further define magic getters
    and setters to provide access to properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `hydrate()` method is the most difficult as we are assuming no getters
    or setters are defined, nor are the properties defined with a visibility level
    of `public`. Accordingly, we need to define a class that extends the class of
    the object to be hydrated. We do this by first defining a string that will be
    used as a template to build the new class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuing in the `hydrate()` method, we define a `$values` property, and a
    constructor that assigns the array to be hydrated into the object as an argument.
    We loop through the array of values, assigning values to properties. We also define
    a useful `getArrayCopy()` method, which returns these values if needed, as well
    as a magic `__get()` method to simulate direct property access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For convenience we define a magic `__get()` method, which simulates direct
    variable access as if they were public:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Still in the template for the new class, we define also a magic `__call()`
    method, which simulates getters and setters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, still in the template for the new class, we add a function, in the
    global namespace, that builds and returns the class instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Still in the `hydrate()` method, we execute the completed template using `eval()`.
    We then run the `build()` method defined just at the end of the template. Note
    that as we are unsure of the namespace of the class to be populated, we define
    and call `build()` from the global namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `extract()` method is much easier to define as our choices are extremely
    limited. Extending a class and populating it from an array using magic methods
    is easily accomplished. The reverse is not the case. If we were to extend the
    class, we would lose all the property values, as we are extending the class, not
    the object instance. Accordingly, our only option is to use a combination of getters
    and public properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can begin by defining three test classes with identical properties: `firstName`,
    `lastName`, and so on. The first, `Person`, should have protected properties along
    with getters and setters. The second, `PublicPerson`, will have public properties.
    The third, `ProtectedPerson`, has protected properties but no getters nor setters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now define a calling program called `chap_11_strategy_pattern.php`,
    which sets up autoloading and uses the appropriate classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create an instance of `Person` and run the setters to define values for
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create an instance of the `Any` hydrator, call `extract()`, and use `var_dump()`
    to view the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe, in the following output, that the `GetSet` strategy was chosen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `id` property is not set as its visibility level is `private`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you can define an array with the same values. Call `hydrate()` on the
    `Any` instance, and supply a new `PublicPerson` instance as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result. Note that the `PublicProps` strategy was chosen in this
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, call `hydrate()` again, but this time supply an instance of `ProtectedPerson`
    as the object argument. We then call `getFirstName()` and `getLastName()` to test
    the magic getters. We also access first and last names as direct variable access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the last output, showing that the `Extending` strategy was chosen.
    You''ll also note that the instance is a new `ProtectedPerson_TEMP` class, and
    that the protected properties are fully populated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Defining a mapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **mapper** or **data mapper** works in much the same manner as a hydrator:
    converting data from one model, be it array or object, into another. A critical
    difference is that the hydrator is generic and does not need to have object property
    names pre-programmed, whereas the mapper is the opposite: it needs precise information
    on property names for both models. In this recipe we will demonstrate the use
    of a mapper to convert data from one database table into another.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We first define a `Application\Database\Mapper\FieldConfig` class, which contains
    mapping instructions for individual fields. We also define appropriate class constants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Key properties are defined along with the appropriate class constants. `$key`
    is used to identify the object. `$source` represents the column from the source
    database table. `$destTable` and `$destCol` represent the target database table
    and column. `$default`, if defined, contains a default value or a callback that
    produces the appropriate value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We now turn our attention to the constructor, which assigns default values,
    builds the key, and checks to see that either or both `$source` or `$destTable`
    and `$destCol` are defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we allow source and destination columns to be `NULL`. The reason for
    this is that we might have a source column that has no place in the destination
    table. Likewise, there might be mandatory columns in the destination table that
    are not represented in the source table.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of defaults, we need to check to see if the value is a callback.
    If so, we run the callback; otherwise, we return the direct value. Note that the
    callbacks should be defined so that they accept a database table row as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to wrap up this class, we define getters and setters for each of the
    five properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a `Application\Database\Mapper\Mapping` mapping class, which
    accepts the name of the source and destination tables as well as an array of `FieldConfig`
    objects as an argument. You will see later that we allow the destination table
    property to be an array, as the mapping might be to two or more destination tables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define getters and setters for these properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'For field configuration, we also need to provide the ability to add an individual
    field. There is no need to supply the key as a separate argument as this can be
    obtained from the `FieldConfig` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'It is extremely important to obtain an array of source column names. The problem
    is that the source column name is a property buried in a `FieldConfig` object.
    Accordingly, when this method is called, we loop through the array of `FieldConfig`
    objects and invoke `getSource()` on each one to obtain the source column name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a similar approach for `getDestColumns()`. The big difference compared
    to getting a list of source columns is that we only want the columns for one specific
    destination table, which is critical if there''s more than one such table is defined.
    We do not need to check to see if `$destCol` is set as this is already taken care
    of in the constructor for `FieldConfig`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we define a method that accepts as a first argument an array representing
    one row of data from the source table. The second argument is the name of the
    destination table. The method produces an array of data ready to be inserted into
    the destination table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We had to make a decision as to which would take precedence: the default value
    (which could be provided by a callback), or data from the source table. We decided
    to test for a default value first. If the default comes back `NULL`, data from
    the source is used. Note that if further processing is required, the default should
    be defined as a callback.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that some columns will appear in the destination insert that are not present
    in the source row. In this case, the `$source` property of the `FieldConfig` object
    is left as `NULL`, and a default value is supplied, either as a scalar value or
    as a callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to define two methods that will generate SQL. The first such
    method will generate an SQL statement to read from the source table. The statement
    will include placeholders to be prepared (for example, using `PDO::prepare()`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The other SQL generation method produces a statement to be prepared for a specific
    destination table. Notice that the placeholders are the same as the column names
    preceded by "`:`":'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the code shown in steps 1 to 5 to produce an `Application\Database\Mapper\FieldConfig`
    class. Place the code shown in steps 6 to 14 into a second `Application\Database\Mapper\Mapping`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before defining a calling program that performs mapping, it''s important to
    consider the source and destination database tables. The definition for the source
    table, `prospects_11`, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, you can use two destination tables, `customer_11` and `profile_11`,
    between which there is a 1:1 relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now define a calling program called `chap_11_mapper.php`, which sets
    up autoloading and uses the two classes mentioned previously. You can also use
    the `Connection` class defined in [Chapter 5](ch05.html "Chapter 5. Interacting
    with a Database"), *Interacting with a Database*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'For demonstration purposes, after having made sure the two destination tables
    exist, you can truncate both tables so that any data that appears is clean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You are now ready to build the `Mapping` instance and populate it with `FieldConfig`
    objects. Each `FieldConfig` object represents a mapping between source and destination.
    In the constructor, supply the name of the source table and the two destination
    tables in the form of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You can start simply by mapping fields between `prospects_11` and `customer_11`
    where there are no defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that `addField()` returns the current mapping instance so there is no need
    to keep specifying `$mapper->addField()`. This technique is referred to as the
    **fluent interface**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The name field is tricky, as in the `prospects_11` table it''s represented
    by two columns, but only one column in the `customer_11` table. Accordingly, you
    can add a callback as default for `first_name` to combine the two fields into
    one. You will also need to define an entry for `last_name` but where there is
    no destination mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `customer_11::status` field can use the null coalesce operator (`??`) to
    determine if it''s set or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `customer_11::level` field is not represented in the source table, thus
    you can make a `NULL` entry for the source field, but make sure the destination
    table and column are set. Likewise, `customer_11::password` is not present in
    the source table. In this case, the callback uses the phone number as a temporary
    password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also set mappings from `prospects_11` to `profile_11` as follows. Note
    that as the source photo and date of birth columns are not present in `prospects_11`,
    you can set any appropriate default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to establish the 1:1 relationship between the `profile_11` and `customer_11`
    tables, we set the values of `customer_11::id`, `customer_11::profile_id` and
    `profile_11::id` to the value of `$row[''id'']` using a callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now call the appropriate methods to generate three SQL statements,
    one to read from the source table, and two to insert into the two destination
    tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'These three statements can immediately be prepared for later execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We then execute the `SELECT` statement, which produces rows from the source
    table. In a loop we then generate `INSERT` data for each destination table, and
    execute the appropriate prepared statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the three SQL statements produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can then view the data directly from the database using SQL `JOIN` to ensure
    the relationship has been maintained:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing object-relational mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two primary techniques to achieve a relational mapping between objects.
    The first technique involves pre-loading the related child objects into the parent
    object. The advantage to this approach is that it is easy to implement, and all
    parent-child information is immediately available. The disadvantage is that large
    amounts of memory are potentially consumed, and the performance curve is skewed.
  prefs: []
  type: TYPE_NORMAL
- en: The second technique is to embed a secondary lookup into the parent object.
    In this latter approach, when you need to access the child objects, you would
    run a getter that would perform the secondary lookup. The advantage of this approach
    is that performance demands are spread out throughout the request cycle, and memory
    usage is (or can be) more easily managed. The disadvantage of this approach is
    that there are more queries generated, which means more work for the database
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note, however, that we will show how the use of **prepared statements**
    can be used to greatly offset this disadvantage.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's have a look at two techniques to implement object-relational mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Technique #1 - pre-loading all child information'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we will discuss how to implement object relational mapping by pre-loading
    all child information into the parent class. For this illustration, we will use
    three related database tables, `customer`, `purchases`, and `products`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the existing `Application\Entity\Customer` class (defined in [Chapter
    5](ch05.html "Chapter 5. Interacting with a Database"), *Interacting with a Database*,
    in the *Defining entity classes to match database tables recipe*) as a model to
    develop an `Application\Entity\Purchase` class. As before, we will use the database
    definition as the basis of the entity class definition. Here is the database definition
    for the `purchases` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the customer entity class, here is how `Application\Entity\Purchase`
    might look. Note that not all getters and setters are shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to define `Application\Entity\Product`. Here is the database
    definition for the `products` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the customer entity class, here is how `Application\Entity\Product`
    might look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to implement a way to embed related objects. We will start with
    the `Application\Entity\Customer` parent class. For this section, we will assume
    the following relationships, illustrated in the following diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One customer, many purchases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One purchase, one product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Technique #1 - pre-loading all child information](graphics/B05314_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Accordingly, we define a getter and setter that process purchases in the form
    of an array of objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we turn our attention to `Application\Entity\Purchase`. In this case, there
    is a 1:1 relationship between a purchase and a product, so there''s no need to
    process an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that in both entity classes, we do not alter the `$mapping` array. This
    is because implementing object relational mapping has no bearing on the mapping
    between entity property names and database column names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the core functionality of obtaining basic customer information is still
    needed, all we need to do is to extend the `Application\Database\CustomerService`
    class described in [Chapter 5](ch05.html "Chapter 5. Interacting with a Database"),
    *Interacting with a Database*, in the *Tying entity classes to RDBMS queries*
    recipe. We can create a new `Application\Database\CustomerOrmService_1` class,
    which extends `Application\Database\CustomerService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add a method to the new service class that performs a lookup and embeds
    the results, in the form of `Product` and `Purchase` entities, into the core customer
    entity. This method performs a lookup in the form of a `JOIN`. This is possible
    because there is a 1:1 relationship between purchase and product. Because the
    `id` column has the same name in both tables, we need to add the purchase ID column
    as an alias. We then loop through the results, creating `Product` and `Purchase`
    entities. After overriding the ID, we can then embed the `Product` entity into
    the `Purchase` entity, and then add the `Purchase` entity to the array in the
    `Customer` entity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we provide a wrapper for the original `fetchById()` method. This block
    of code needs to not only get the original `Customer` entity, but needs to look
    up and embed `Product and Purchase` entities. We can call the new `fetchByIdAndEmbedPurchases()`
    method and accept a customer ID as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Technique #2 - embedding secondary lookups'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we will cover embedding secondary lookups into the related entity classes.
    We will continue to use the same illustration as above, using the entity classes
    defined that correspond to three related database tables, `customer`, `purchases`,
    and `products`:'
  prefs: []
  type: TYPE_NORMAL
- en: The mechanics of this approach are quite similar to those described in the preceding
    section. The main difference is that instead of doing the database lookup, and
    producing entity classes right away, we will embed a series of anonymous functions
    that will do the same thing, but called from the view logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to add a new method to the `Application\Entity\Customer` class that
    adds a single entry to the `purchases` property. Instead of an array of `Purchase`
    entities, we will be supplying an anonymous function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will make a copy of the `Application\Database\CustomerOrmService_1`
    class, and call it `Application\Database\CustomerOrmService_2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define a `fetchPurchaseById()` method, which looks up a single purchase
    based on its ID and produces a `Purchase` entity. Because we will ultimately be
    making a series of repetitive requests for single purchases in this approach,
    we can regain database efficiency by working off the same prepared statement,
    in this case, a property called `$purchPreparedStmt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we need a `fetchProductById()` method that looks up a single product
    based on its ID and produces a `Product` entity. Given that a customer may have
    purchased the same product several times, we can introduce an additional level
    of efficiency by storing acquired product entities in a `$products` array. In
    addition, as with purchases, we can perform lookups on the same prepared statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now rework the `fetchPurchasesForCustomer()` method to have it embed
    an anonymous function that makes calls to both `fetchPurchaseById()` and `fetchProductById()`,
    and then assigns the resulting product entity to the newly found purchase entity.
    In this example, we do an initial lookup that just returns the IDs of all purchases
    for this customer. We then embed a sequence of anonymous functions in the `Customer::$purchases`
    property, storing the purchase ID as the array key, and the anonymous function
    as its value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the following classes based on the steps from this recipe as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Technique #1 steps |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Application\Entity\Purchase` | 1 - 2, 7 |'
  prefs: []
  type: TYPE_TB
- en: '| `Application\Entity\Product` | 3 - 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `Application\Entity\Customer` | 6, 16, + described in [Chapter 5](ch05.html
    "Chapter 5. Interacting with a Database"), *Interacting with a Database*. |'
  prefs: []
  type: TYPE_TB
- en: '| `Application\Database\CustomerOrmService_1` | 8 - 10 |'
  prefs: []
  type: TYPE_TB
- en: 'The second approach to this would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Technique #2 steps |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Application\Entity\Customer` | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `Application\Database\CustomerOrmService_2` | 3 - 6 |'
  prefs: []
  type: TYPE_TB
- en: 'In order to implement approach #1, where entities are embedded, define a calling
    program called `chap_11_orm_embedded.php,` which sets up autoloading and uses
    the appropriate classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create an instance of the service, and look up a customer using a random
    ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'In the view logic, you will have acquired a fully populated `Customer` entity
    by way of the `fetchByIdAndEmbedPurchases()` method. Now all you need to do is
    to call the right getters to display information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic needed to display purchase information would then look something
    like the following HTML. Notice that `Customer::getPurchases()` returns an array
    of `Purchase` entities. To get product information from the `Purchase` entity,
    inside the loop, call `Purchase::getProduct()`, which produces a `Product` entity.
    You can then call any of the `Product` getters, in this example, `Product::getTitle()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Turning your attention to the second approach, which uses secondary lookups,
    define a calling program called `chap_11_orm_secondary_lookups.php`, which sets
    up autoloading and uses the appropriate classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create an instance of the service, and look up a customer using a random
    ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now retrieve an `Application\Entity\Customer` instance and call `fetchPurchasesForCustomer()`
    for this customer, which embeds the sequence of anonymous functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The view logic for displaying core customer information remains the same as
    described previously. The logic needed to display purchase information would then
    look something like the following HTML code snippet. Notice that `Customer::getPurchases()`
    returns an array of anonymous functions. Each function call returns one specific
    purchase and related products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_11_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although each iteration of the loop represents two independent database queries
    (one for purchase, one for product), efficiency is retained by the use of *prepared
    statements*. Two statements are prepared in advance: one that looks up a specific
    purchase, and one that looks up a specific product. These prepared statements
    are then executed multiple times. Also, each product retrieval is independently
    stored in an array, resulting in even greater efficiency.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Probably the best example of a library that implements object-relational mapping
    is Doctrine. Doctrine uses an embedded approach that its documentation refers
    to as a proxy. For more information, please refer to [http://www.doctrine-project.org/projects/orm.html](http://www.doctrine-project.org/projects/orm.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'You might also consider reviewing a training video on *Learning Doctrine*,
    available from O''Reilly Media at [http://shop.oreilly.com/product/0636920041382.do](http://shop.oreilly.com/product/0636920041382.do).
    (Disclaimer: this is a shameless plug by the author of both this book and this
    video!)'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Pub/Sub design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Publish/Subscribe** (**Pub/Sub**) design pattern often forms the basis
    of software event-driven programming. This methodology allows **asynchronous**
    communications between different software applications, or different software
    modules within a single application. The purpose of the pattern is to allow a
    method or function to publish a signal when an action of significance has taken
    place. One or more classes would then subscribe and take action if a certain signal
    has been published.
  prefs: []
  type: TYPE_NORMAL
- en: Example of such actions are when the database is modified, or when a user has
    logged in. Another common use for this design pattern is when an application delivers
    news feeds. If an urgent news item has been posted, the application would publish
    this fact, allowing client subscribers to refresh their news listings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we define our publisher class, `Application\PubSub\Publisher`. You''ll
    notice that we are making use of two useful **Standard PHP Library** (**SPL**)
    interfaces, `SplSubject` and `SplObserver`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add properties to represent the publisher name, data to be passed
    to subscribers, and an array of subscribers (also referred to as listeners). You
    will also note that we will use a linked list (described in [Chapter 10](ch10.html
    "Chapter 10. Looking at Advanced Algorithms"), *Looking at Advanced Algorithms*)
    to allow for priority:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor initializes these properties. We also throw in `__toString()`
    in case we need quick access to the name of this publisher:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to associate a subscriber with this publisher, we define `attach()`,
    which is specified in the `SplSubject` interface. We accept an `SplObserver` instance
    as an argument. Note that we need to add entries to both the `$subscribers` and
    `$linked` properties. `$linked` is then sorted by value, represented by the priority,
    using `arsort()`, which sorts in reverse and maintains the key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface also requires us to define `detach()`, which removes the subscriber
    from the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Also required by the interface, we define `notify()`, which calls `update()`
    on all the subscribers. Note that we loop through the linked list to ensure the
    subscribers are called in order of priority:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the appropriate getters and setters. We don''t show them all
    here to conserve space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to provide a means of setting data items by key, which will
    then be available to subscribers when `notify()` is invoked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can have a look at `Application\PubSub\Subscriber`. Typically, we would
    define multiple subscribers for each publisher. In this case, we implement the
    `SplObserver` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Each subscriber needs a unique identifier. In this case, we create the key
    using `md5()` and date/time information, combined with a random number. The constructor
    initializes the properties as follows. The actual logical functionality performed
    by the subscriber is in the form of a callback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The `update()` function is called when `notifiy()` on the publisher is invoked.
    We pass a publisher instance as an argument, and call the callback defined for
    this subscriber:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to define getters and setters for convenience. Not all are shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the purposes of this illustration, define a calling program called `chap_11_pub_sub_simple_example.php`,
    which sets up autoloading and uses the appropriate classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a publisher instance and assign data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can create test subscribers that read data from the publisher and echo
    the results. The first parameter is the name, the second the callback, and the
    last is the priority:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'For test purposes, attach the subscribers out of order, and call `notify()`
    twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define and attach another subscriber that looks at the data for subscriber
    1 and exits if it''s not empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output. Note that the output is in order of priority (where higher
    priority goes first), and that the second block of output is interrupted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_11_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A closely related software design pattern is **Observer**. The mechanism is
    similar but the generally agreed difference is that Observer operates in a synchronous
    manner, where all observer methods are called when a signal (often also referred
    to as message or event) is received. The Pub/Sub pattern, in contrast, operates
    asynchronously, typically using a message queue. Another difference is that in
    the Pub/Sub pattern, publishers do not need to be aware of subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a good discussion on the difference between the Observer and Pub/Sub patterns,
    refer to the article at [http://stackoverflow.com/questions/15594905/difference-between-observer-pub-sub-and-data-binding](http://stackoverflow.com/questions/15594905/difference-between-observer-pub-sub-and-data-binding).
  prefs: []
  type: TYPE_NORMAL
