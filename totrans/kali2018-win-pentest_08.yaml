- en: Windows Privilege Escalation and Maintaining Access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how, once you have exploited a system, you can
    elevate your privileges to system level access. You will also learn how to obtain
    information from a system even when an exploit does go wrong. There aren't any
    total failures; there is always something to learn even when things do go wrong.
    You will learn how to add persistence to your exploit to maintain future access
    to your victim's machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows privilege escalation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MS16-032 Secondary Logon Handle Privilege Escalation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows Escalate Service Permissions Local Privilege Escalation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need, for this chapter, a target Windows machine and a running instance
    of Kali.
  prefs: []
  type: TYPE_NORMAL
- en: Windows privilege escalation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Privilege escalation is gaining a higher level of access than the account being
    used has been given. In hacker terms, this is called **rooting the box**. This
    comes from the UNIX/Linux world, where root is the administrator account. With
    this level of access, you own the box. In Windows systems, the administrator account
    has admin-level access and can do just about anything to the system. Still, in
    Windows, there is an even higher level of access, called system. With this account,
    you have full control over all levels of the system. This is the level of access
    that we want.
  prefs: []
  type: TYPE_NORMAL
- en: Gaining access to a user account is far easier than gaining the domain administrator's
    account in an attack. User accounts are far more numerous than administrator accounts,
    so snagging one of these off the wire (or wirelessly) is easier simply by the
    numbers. User accounts are normally locked down, so you are not given any real
    access to the system level of the machine. Here, we are going to get around that.
    Once actual access to the machine is gained, escalating your rights is easy, as
    we shall see.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have a network with two servers and two workstations protected
    by a firewall to the internet. The network also has a wireless access point. As
    the attacker, we have breached the network through the wireless device and obtained
    user account hashes from the network using an SMB poisoning attack. Using these
    stolen credentials, we will access workstations on the network and work our way
    up the network ladder to get access to the domain controller.
  prefs: []
  type: TYPE_NORMAL
- en: Escalating your privileges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have run our SMB poisoning attack using the Responder tool and captured two
    accounts. One is the user account `fflintstone`, and we got lucky and also captured
    a NTLMv2 hash for the `Administrator` account. As we can see in the following
    screenshot, by running the attack to drop HTTP-NTLM support to basic, we have
    captured a plain-text password for `fflintstone`, so we have an encrypted password
    to work with. NTLMv2 hashes are different for V1 hashes in that V2 hashes are
    salted using the challenge and response given in the communication from server
    to client. So, we can't use the **pass the hash** method to log in by just using
    the hash in place of the actual password, but if hashes were the only thing captured,
    we could use password cracking tools, such as John, Hashcat, or Hydra, to easily
    crack this hash and obtain the actual password. Since we got lucky and obtained
    a clear text password, we will go with this.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65f8d640-7129-4eed-995a-ea88f1ec3db6.png)'
  prefs: []
  type: TYPE_IMG
- en: Once we gain access to the victim's machine, we will need a payload to connect
    back to the attacking machine. So, let's use the MSFvenom tool to build a quick
    payload to upload to our victim.
  prefs: []
  type: TYPE_NORMAL
- en: MSFvenom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MSFvenom is an exploit packing tool that comes with the Metasploit framework.
    MSFvenom has the ability to build everything, from simple exploits to complex
    exploits that contain code to obfuscate the exploit used to bypass anti-virus
    services. Here, we are going to build a simple exploit to run. Normally, I would
    build and run the simple exploit first, and if problems arise from the anti-virus,
    I would then try to build out one to bypass the anti-virus.
  prefs: []
  type: TYPE_NORMAL
- en: 'MSFvenom is a very powerful tool, as we can see from the following `help` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By running the `msfvenom --help-formats` command, we get a list of formats that
    the payload can be compiled as.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executable formats are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`asp`, `aspx`, `aspx-exe`, `axis2`, `dll`, `elf`, `elf-so`, `exe`, `exe-only`,
    `exe-service`, `exe-small`, `hta-psh`, `jar`, `jsp`, `loop-vbs`, `macho`, `msi`,
    `msi-nouac`, `osx-app`, `psh`, `psh-cmd`, `psh-net`, `psh-reflection`, `vba`,
    `vba-exe`, `vba-psh`, `vbs`, and `war`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Transform formats are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bash`, `c`, `csharp`, `dw`, `dword`, `hex`, `java`, `js_be`, `js_le`, `num`,
    `perl`, `pl`, `powershell`, `ps1`, `py`, `python`, `raw`, `rb`, `ruby`, `sh`,
    `vbapplication`, and `vbscript`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c558df9-d1e2-4a6c-b06c-6a9cb55f85d1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have our payload, we need to put it up so we can download it from
    our victim''s machine. All Windows systems come with a built-in FTP client, which
    can be run from the either the command line interface or by using PowerShell.
    PowerShell scripting can also be used to fetch files using FTP or HTTP services.
    Personally, for this use, I like the plain and simple FTP client. Metasploit has
    a built-in FTP server just for this purpose. To start this service from the MSFconsole,
    run the following from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`msfdb start`: This starts the Metasploit database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mfsconsole`: This starts the console'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`workspace <NameOfWorkspace>`: This puts you into your existing workspace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`use auxiliary/server/ftp`: This puts you into the FTP server configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By running the `show options` command, we can see the options for the service
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67a9cd4a-b831-4365-b2be-edac425e7417.png)'
  prefs: []
  type: TYPE_IMG
- en: We see the `FTPROOT` option is set to the `/tmp/ftproot` directory. For one-time
    use, you would need the run the `mkdir /tmp/ftproot` command, which will set up
    the directory for the service and allow you to copy your exploit to this directory.
    This works fine for one-time use, but when the system shuts down, the `/tmp` directory
    is emptied, so the directory and files are deleted. Sometimes, this is the result
    you want. I like to keep my files for later use, so I set up the following directory
    by running the `mkdir /var/ftproot` command. This directory will stay permanently,
    and any files or exploits will remain after a shutdown. We will leave the `FTPUSER`
    and `FTPPASS` fields blank and use an anonymous connection to fetch the file,
    since we are only going to have this service running for a short time. If you
    need to keep the service running for a while, or you are on a hostile network,
    it might be wise to set up these two options. We will need to set up the options
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our attacking machine''s address is `172.16.42.215`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to copy the exploit we built to the `ftproot` directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to use the `run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f68015f-ff6a-4632-be02-8872918b47fa.png)'
  prefs: []
  type: TYPE_IMG
- en: This will start the FTP service. By running the `jobs` command, we can see the
    running service.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a valid login with a payload set up on the FTP service, so we are
    ready for the attack. In our scan of the system, we see that the RDP service is
    running at port `3389`, so we will use the **rdesktop** application to connect
    to the system as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/2fc0e76f-edf0-44a2-9667-81aad699781b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click the Other User button to get to the default login screen, and enter the
    captured domain credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91808fb5-d0c1-4299-bd5b-3774c594b331.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we''re in, pull up either a command-line interface or a PowerShell window
    and download the file as follows. The attacking machine is at `172.16.42.215`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It will ask for a user; enter anonymous and hit the *Enter* key. The service
    will then ask for a password. Again, just hit the *Enter* key, leaving the field
    blank.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will work fine on this setup. Running the `dir` command, we can see our
    exploit; we are going to download it to the Windows `temp` directory by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/9c5d97a8-e4e5-4855-abfd-ab5a1b6765ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The MSFconsole will also report the file download as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74ff9117-3e5d-4517-9c3e-4120af57dff7.png)'
  prefs: []
  type: TYPE_IMG
- en: Before running the exploit, we need to set up the exploit handler on the attacking
    machine. We will set up the Metasploit multi/handler for the exploit to connect
    to. The default payload for the handler is the `reverse_tcp` payload and runs
    on port `4444`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we built our exploit, we set it up to use the `reverse_https` to hide
    our traffic as HTTPS traffic, so we will have to change the defaults. From the
    MSFconsole, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/b70ea545-eef3-4bcd-ab4d-08565de7e39b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Running the `jobs` command, we can see that the handler is now running, and
    also that the FTP service is still running as well. We can now kill the FTP service
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/a3ca6fec-55c4-49a8-b859-82054e93a8e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''re now ready to run our exploit on the victim''s machine. Run the following
    command from either the command-line window or from PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will fire up the exploit and connect to the handler on the attacker''s
    machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51077842-bbc8-4ae1-805b-8bed4f45a92c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the attacker''s system, in Metasploit we can see the exploit connect to
    the handler. Then, by running the `sessions -l` command, we can see the running
    session. Next, by running the `sessions -i 2` command, we can start a Meterpreter
    shell on the machine. Then, by running the `sysinfo` command, we can see that
    we are connected to BO-SRV2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1cd7a229-23ba-4192-b268-11701904142e.png)'
  prefs: []
  type: TYPE_IMG
- en: From our session's information, we can see that we are connected as `LAB1\rred`.
    From earlier footprinting, we know this is a domain user account with no admin
    rights, so we need to elevate the account privileges to get our goodies. Let's
    run the `getsystem` command. This command uses 15 built-in methods to gain sysadmin
    privileges to the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows that it failed to get system access. Oops! Have
    a look at the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6724cab0-64ac-4855-b1d3-e6b8f5be53e2.png)'
  prefs: []
  type: TYPE_IMG
- en: We can check this failure by running the `getuid` command, which then responds
    by showing us that we are still connected as `LAB1\rred`.
  prefs: []
  type: TYPE_NORMAL
- en: Persistence in penetration testing means more than having a continuously running
    exploit. Sometimes, it involves hammering at the system with many post exploits
    in order to elevate your privileges. Some exploits will work on some systems,
    then, at other times, they don't work. Persistence is the key. In exploiting this
    system, the writer had to go though a lot of `post/windows` and `exploit/windows/local`
    modules to eventually escalate his user rights. The `post` tools and exploits
    shown failed on this attack, but could be successful on another system. Once you
    have a Meterpreter shell, you will want to back out of the shell, but still maintain
    the connection by entering background and hitting the *Enter* key.
  prefs: []
  type: TYPE_NORMAL
- en: You can find `post/windows` and `exploit/windows/local` by running the following
    commands. The results will show dates on the modules. You will want to use the
    modules that are older than the age of the target system. There isn't much use
    running an exploit for Windows 2000 on a system running Server 2008\. That exploit
    will have long been patched with a version update.
  prefs: []
  type: TYPE_NORMAL
- en: '`search post/windows`: This will find the post modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search exploit/windows/local`: This will find the exploit that can be run
    on an active session'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MS16-032 Secondary Logon Handle Privilege Escalation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we are going to run the MS16-032 Secondary Logon Handle Privilege Escalation
    module. The module''s information states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'See the following references for more information on MS (MS16-032):'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://cvedetails.com/cve/CVE-2016-0099/](https://cvedetails.com/cve/CVE-2016-0099/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://twitter.com/FuzzySec/status/723254004042612736](https://twitter.com/FuzzySec/status/723254004042612736)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://googleprojectzero.blogspot.co.uk/2016/03/exploiting-leaked-thread-handle.html](https://googleprojectzero.blogspot.co.uk/2016/03/exploiting-leaked-thread-handle.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What this exploit does is create new processes with arbitrary tokens. This tricks
    the service into using privileged access tokens, thus bypassing the security restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this module, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/29702ab4-d1de-4508-b362-c000b3730ea8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By running the `show options` command, we can see that there is only the `SESSION`
    option that must be set. By running the `sessions -l` command, we see our running
    session is `2`. To set this option, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Then run to fire off the exploit. We see that the exploit has failed. The exploit
    ran, but failed to fully execute. Reading the information on this exploit, we
    see that you must have two or more cores for this exploit to work. From other
    information gathered during the footprinting of the system, we can assume this
    system is a VM running on a single core. Failures can still provide more information
    about your target.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Escalate Service Permissions Local Privilege Escalation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next module we will run is Windows Escalate Service Permissions Local Privilege
    Escalation module, which is dated 2012\. This is a local exploit, run through
    the running session. Again, we will use session 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this module, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The description from the module is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the following output, the exploit ran again, but still no
    joy. This may be a failure, but from the output, we now know that there aren''t
    any services running with weak configurations. From the session timing out, we
    now know that any approach attempting to trick services using this method is a
    bust:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8a1ad96-143f-47fd-88fb-ead2c34c83ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Windows Escalate UAC Protection Bypass (ScriptHost Vulnerability)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module attempts to bypass the UAC on Windows, using the VB scripting language,
    by exploiting the `cscript/wscript.exe` executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the module, we can see in the following screenshot that the user
    account we are trying to compromise needs to have administrator''s rights. Well,
    another failure, but again we learned that the account we are using doesn''t have
    many rights in the domain. We did get another account''s credentials; maybe that
    account has more rights:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7ffeb76-5870-4a27-b3ce-3bdd91567466.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By running the `creds` command, we are given a list of the captured credentials.
    Note that there are non-replayable hashes, these aren''t much use, except for
    offline cracking, but we do have another account (`fflintstone`), which was captured
    with a plain-text password. We''ll try this one with our preceding exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b873077-a577-4a8e-a4ed-250aae94d136.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, to get this to run, the multi/handler must have the user account changed,
    so we will need to kill session 2 and then RDP in as `fflintstone` and re-run
    the exploit to gain that user's rights. We will need to get back into the multi/handler
    module.
  prefs: []
  type: TYPE_NORMAL
- en: '`use exploit/multi/handler`: This puts you back into the handler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sessions -k 2`: This kills the running session 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run -j`: This restarts the multi/handler to accept a new connection and runs
    it as a job in the background'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/e9187b0c-0a39-4744-8bab-76fa71c31647.png)'
  prefs: []
  type: TYPE_IMG
- en: Now after logging into an RDP session using the `fflintstone` account, we will
    run the payload again from either the command line or PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/7fdc87d0-45c1-4aa8-b2bf-f44ad013fd0e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following screenshot, we can see that the handler on our Kali box has
    accepted the connection and set up a Meterpreter session on session 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f0ef787-59ec-40b2-9ed7-1e53f6a8393c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, let''s now go back to the Bypass UAC exploit and run it in the new session.
    To do this, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`back`: This backs out of the handler without killing it, or any sessions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`use exploit/windows/local/bypassuac_vbs`: This puts you back into the module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set session 3`: This sets the exploit to use session 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exploit`: This fires it off'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see that we still failed. It seems the
    UAC settings have a higher security setting that can''t be exploited. Again, persistence
    is the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d61ef9a-be1c-45ea-a9db-84105696ce8c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, it seems that BO-SRV2 is pretty locked down from the accounts we have so
    far, so let''s go after another machine. We haven''t tried the domain controller
    so let''s move on to that. We log in as `LAB1\fflintstone` using RDP, and FTP
    our exploit over to the domain controller in the same way as we did on BO-SRV2\.
    In the following screenshot, we change to the `C:\Windows\Temp` directory into
    which we want to dump our exploit, and then connect back to our Kali machine and
    download the exploit as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9241aead-3295-4274-a258-a9c23d45c3d2.png)'
  prefs: []
  type: TYPE_IMG
- en: Again, we are ready to run the exploit and connect back to our Kali box. Be
    sure that you have your multi/handler set up and running! Now, run the executable.
  prefs: []
  type: TYPE_NORMAL
- en: '`svchosts.exe`: This will start the exploit and you will see the session open
    on Kali.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6900f6e-7ed2-497f-b918-c2725400060b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We go back to our VBS bypass exploit and run it against this session. Oh no!
    We have another failure just like the last one on BO-SRV2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4307a3d4-fdf1-4d85-8f70-149ad195fee2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, it seems that all the servers'' security is set to high on all user accounts.
    We need to get this pesky UAC out of the way. This is also most likely the reason
    that our other attempts have failed. When the exploits run automatically, they
    get blocked by the UAC. We need to disable the UAC and get it out of the way.
    Since we have an RDP session and an account with some rights to the machine, we''ll
    use the GUI to disable the UAC, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to Control Panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose User Accounts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Turn User Account Control On or Off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click through the UAC window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, uncheck the checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will then be asked to restart the computer; go ahead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the UAC window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5ae59f16-97fc-4a0a-9ac8-676d4444fc87.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You may wonder why we didn''t do this on BO-SRV2\. Footprinting has shown us
    that BO-SRV2 is a file server on the network. A reboot of this system could alert
    users to our presence. Networks may have only a single file server, so it would
    be noticed if it was rebooted, but domain controllers are another story. We can
    reboot this system and no one will be any the wiser, unless there is a network
    monitoring service on the network that could tell on us. At the very least, the
    chance of getting caught is slimmer when rebooting the domain controller. Oh,
    yes; before rebooting the machine, right-click on the Taskbar, go to the Task
    Manager and check the Users tab to be sure you are the only one on the box. Rebooting
    while the administrator is on the box will mean that you are busted. We can see
    in the following screenshot that we are the only one on the system right now,
    so it safe to reboot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4db6dca3-7c50-415c-878f-a92fa617accd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, after a reboot we start the process over. Be sure and have your multi/handler
    set up properly and running on your Kali machine. Log back into the victim''s
    machine and re-run your payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You will then see the Meterpreter session start on your Kali box, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2716de20-95ce-49fa-bf72-3e9b8878f8fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Well, let''s see what we got this time! Open our Meterpreter session and see
    what happens. To open the session, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sessions -i 2`: The `-i` is to interact with the numbered session'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getuid`: This shows us that we are running as `fflintstone`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is just for giggles, as it didn't work last time we ran it.
  prefs: []
  type: TYPE_NORMAL
- en: '`getsystem`: Bingo! We have a winner! When we re-run `getuid`, we see we are
    now system. Yes, get up and do your happy dance: you now have system-level privileges!
    It''s fully pwned:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/47855e4d-9bf9-4358-a17e-969ec44e82cd.png)'
  prefs: []
  type: TYPE_IMG
- en: So, we have found out that the problem all along was the UAC, and that we didn't
    have the ability to bypass the prompt that normally appears on the screen. Even
    with administrator-level access, the UAC prompt killed our attempts to fully compromise
    the machine.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's loot the system and gather our booty. This, as the domain controller,
    holds the keys to the kingdom. In a penetration test, once this is looted, it's
    game over. In a real world hack, once this is accomplished, your network is toast;
    without a complete rebuild of your entire network structure, you will never be
    absolutely sure that your attacker is completely locked out. To do this, we are
    going to use a `post` module to gather all the user accounts and their hashes.
    To do this, we will use the `post/windows/gather/smart_hashdump` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The information on this module is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Before setting up and running this module, first we want to get out of the Meterpreter
    shell without breaking the connection, then load the post module and run it.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the running Metetpreter shell, run these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`background`: This will background the session and not kill it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`use post/windows/gather/smart_hashdump`: This will load the `smart_hashdump`
    module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show options`: This shows the options needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set SESSION 2`: This sets the session to use our running session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show options`: Run this again to check your settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exploit`: Exploit!!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/0d84fc61-e734-49c4-ae15-d501d97ab5b5.png)'
  prefs: []
  type: TYPE_IMG
- en: Bingo! You are now the proud owner of the `LAB1.boweaver.net` domain. Note that
    all hashes from the domain, including machine accounts, have been looted. These
    hashes are not salted, unlike the hashes captured on the wire using NTLMv2, which
    is salted and non-replayable. These are straight NTLM hashes and can be used in
    **pass the hash** style attacks and logins to other systems. They can also be
    more easily cracked using offline password cracking tools to get the plain-text
    passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that not only have the creds been saved to the Metasploit database,
    they were also outputted to the file at `/root/.msf4/loot/20170709202230_lab1.boweaver.ne_172.16.42.5_windows.hashes_075027.txt`.
    This text file is in a format that can be imported into either John or Hashcat
    for offline cracking.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the results for a test domain for this book,
    so the output isn''t that large. In a large domain, this can be an incredibly
    large dump:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06396ab8-5349-4250-8e14-f81383e4aba2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Hacker''s tip:'
  prefs: []
  type: TYPE_NORMAL
- en: When dumping a large domain, sometimes you can find disabled accounts. It's
    better to enable one of these accounts for attack use, and elevate the privileges
    of this account, than to add a new account for attack use.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have gained access and escalated your level of access, you will want
    to come back. If the system is breached using a vulnerability against an open
    port to the internet, then returning is not a big issue, unless the system gets
    patched. You can always just reuse your exploit and regain access to the internal
    network. If you have exploited the system using a phishing attack or a browser
    exploit, then your connection from the attack will happen only once when the link
    is clicked, or the browser exploit is run from the infected site. When attacking
    a user from a workstation in these ways, in order to return to the workstation
    and bypass the firewall, you will need something to maintain access. With systems
    behind a properly configured firewall, it is almost impossible to gain direct
    access without any ports open to the internet. All systems can, however, call
    out to the internet, so this is our attack vector and our way back in. This is
    why highly secured networks should always be air-gapped, with no physical way
    to call out to the public network. This is where small furry mammals with long
    tails and big ears come into play.
  prefs: []
  type: TYPE_NORMAL
- en: Remote Access Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Remote Access Tools** (**RATs**) are small programs that can be used to call
    out to a server and maintain a connection to that server, sometimes called a **Command
    and Control** server, or CnC. Using that connection from the server, the attacker
    can then access the victim''s internal network from the internal machine, or use
    it as a pivot to exploit the network from the attacker''s remote machine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pivots are my personal favorites. With pivots, there is no need to upload tools
    to another victim''s machine, which can trigger anti-virus software and other
    security monitoring that workstation during the upload. Once the RAT is in place,
    you can now pivot from the first victim''s machine. Also, it just isn''t practical
    to upload a version of something like Metasploit and install it on the victim''s
    machine. With a pivot there is no need to upload tools: you can use the tools
    installed on your system against the internal victim network just as if you were
    plugged into the internal network. The victim''s machine is now acting only as
    a router, and your remote Kali machine is now on the internal network. Metasploit
    has some handy-dandy pivots built right in. Remember, too, that if the network
    can be breached from a wireless access point, then you also have full access to
    the internal network, so there is no need to pivot.'
  prefs: []
  type: TYPE_NORMAL
- en: There are thousands of RATs available these days for any system, not just Windows.
    Android RATs are becoming widely used these days to breach cell phones and tablets
    and maintain access to these devices. We are going to custom-build some RATs using
    Metasploit's MSFvenom tool. I find that these work the best, and other tools,
    such as Mimikats, can be run through the connection.
  prefs: []
  type: TYPE_NORMAL
- en: Metasploit's persistence_exe module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to use our existing session first, to load a persistent executable
    on to the system, which will continue to call back to our multi/handler. Since
    we have this session already, and it has system-level access, loading this will
    be easy. To load the module, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `persistence_exe` module''s information says the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We see the RAT's name is set in the `REXENAME` to `default.exe`. If someone
    is auditing the process list, this will stick out as a malicious process, so let's
    rename it for a little more stealth. Earlier, we built our payload `svchosts.exe`.
    Notice this name is very close to the known running `svchost` executable, which
    will appear many times in the running processes of a normal running server. The
    name being close to the actual service name will give it a bit of stealth. Why
    build a new payload when we have a known working exploit?
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up the module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that it has uploaded the RAT and failed to open the System Manager,
    which has replied that the RPC server is unavailable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed6bdb62-75a9-4988-b91d-c8b5dd19ae0b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the domain controller, we can see that an application has crashed and a
    warning has popped up on the desktop. When attempting to be stealthy, this is
    not a good thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/891006ee-ba1f-4bba-bb82-27ebdbf6255a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The error says the application ApacheBench has crashed. The Apache Web Server
    isn''t loaded on this machine, so the error could be coming from the HTTPS payload
    that we are using. So, let''s build another payload to use as the RAT, using a
    straight TCP connection. To build the payload from the command line, run the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/b64246ba-c993-433b-9952-46cb6cad20ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will need to set up a multi/handler for this payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now go back to the persistence module using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Reset the `REXEPATH` for the new payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/4bba8433-d724-4e24-93c6-9f43af76cb35.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, this time, the payload did successfully run and opened a new
    session. We also see that, again, the RPC server is unavailable, so the RAT didn't
    load as a service. So, the RAT is most likely not running as a service. Running
    as a service is the most optimal, but since it is giving us a problem, let's set
    the `STARTUP` to `USER`. With this configuration, we will have to wait until the
    user logs in again for the exploit to run. When using this setting, it's best
    to use an account that is frequently used. Checking the event logs will give you
    information on which users log in and the frequency of logins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be sure to kill the session that the last run created, and then change the
    `STARTUP` setting as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/32d1dc7c-4825-4f01-84a7-f40d8fe64ce9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Success! On this run, the module loaded the payload and set it to autorun,
    so we should be good to go. Let''s tests the results. When we ran this exploit,
    we didn''t restart our multi/handler to catch the payload, as it ran previously.
    We can see that no session was created, even with everything else showing a successful
    run of the exploit. When we set up and run the handler, we get a connection from
    the payload immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97b782d7-de9d-4836-97f8-9eaae4bc8ac8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s check whether it reconnects on the next login. Kill all the sessions
    in the system and log out of the RDP session. Next, restart the multi/handler
    for the next login:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/0510cba3-bafb-40db-856a-25dc8c5388f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we log back in using an RDP session, we see that a new session has started
    on the running handler. We are able to interact with the session and gain system
    access from the Meterpreter shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbf0a99b-45a3-4bde-89f9-df5488300aa5.png)'
  prefs: []
  type: TYPE_IMG
- en: Windows registry-only persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Windows registry is a great place to hide malicious code. A lot of malware
    and spyware use methods like this to hide and run their payloads. The complexity
    of the registry and the system access level of the registry make it a great attack
    vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will run the following module on the current running session and attempt
    to get the payload to run with system level access. The module''s information
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We will let the module run most of the settings with their defaults. We will
    run with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`set SESSION 4`: Set to the current running session'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set STARTUP SYSTEM`: This will set the persistent payload to run as SYSTEM
    exploit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/159b1ea5-1ef9-462c-972b-78f3dad47c98.png)'
  prefs: []
  type: TYPE_IMG
- en: Well, it appears that our exploit has failed. We got a warning that PowerShell
    is not available. The exploit did write to the registry, but note that a new session
    was not started when the run completed. This tells us that, since PowerShell wasn't
    found, we have a failure on our run. Since PowerShell can't be found, let's try
    an older means by adding persistence from the running session's Meterpreter shell
    and running the exploit from a VB script.
  prefs: []
  type: TYPE_NORMAL
- en: Something to remember is that this type of exploit doesn't require a login,
    so on a production system, this will be an open backdoor if not removed, and can
    be accessed by another attacker if left running on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read the help files for the persistence script by running the following
    commands from the running Meterpreter session. As you can see, the persistence
    script is listed as deprecated, but since the newer post exploits didn''t work,
    it''s best to fallback to an older method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To set this up, we''ll use the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/d72f78a3-71d8-47c7-9ac6-1c48d6211492.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Oh well; the unavailable RPC service got us again, so let''s give it a go with
    an even older method: the `AT` command. The `AT` command is the task scheduler,
    dates back to the days of NT 3.51, and runs only from the command line. This also
    gives it a bit of stealth, since tasks scheduled using `AT` don''t show in the
    GUI version of the task scheduler. They are two separate applications and don''t
    share jobs. The AT service is a lot like Cron on Linux and UNIX. There is an `AT`
    scheduler that runs on these systems also.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to go to the remote shell from the Meterpreter run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'First, move the payload from the `Temp` directory to the `Windows` directory,
    so the payload will run without using the full path to the payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'From the remote shell, run the following to be sure that the scheduler service
    is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/960aafe0-61b8-4baf-844d-68f778c06563.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Remember to start a multi/handler before the set time. When the time rolls
    around, we see that we now have a new running session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ecfea210-5743-459a-b611-c2d156936c64.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to elevate privileges locally and remotely.
    We have shown how even exploits that have gone wrong can be a learning experience
    and can give us valuable information about our target and our target's network.
    We have learned several methods of maintaining persistence in our attacking system,
    and methods to hide these payloads from the user. We have learned how to disable
    UAC and bypass its security.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to build a payload, bring it onto our compromised system,
    and use it to elevate our privileges from a normal user account to system-level
    access on a Windows system. We have also learned how to set this payload to run
    with persistence on our exploited machine, so that we can return later to the
    same compromised machine. We have also learned a valuable lesson on how to gain
    knowledge about a system from failed attempts to compromise it and used that knowledge
    to gain full access to the machine. Failures can be successes.
  prefs: []
  type: TYPE_NORMAL
