- en: Chapter 8. Go Go Gauges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In web application development, gauges can be useful for showing complicated
    or dynamic data in a visual or intuitive way. In this chapter, we''ll learn how
    to create a fully customizable animated gauge that can respond to real-time changes.
    We''ll also discuss techniques to port this type of widget for support in older
    web browsers. We''ll start by learning about a cool SASS enhancement called **Compass**;
    this is another way to deal with CSS3 experimental prefixes. The following is
    the list of the topics we''ll discuss:'
  prefs: []
  type: TYPE_NORMAL
- en: A basic gauge structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Compass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using rem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving the arrow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating the arrow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with older browsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic gauge structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin with a new project; as usual we need to create an `index.html`
    file. This time the markup involved is so small and compact that we can add it
    right now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The gauge widget is identified by the `data-gauge` attribute and defined with
    three other custom data attributes; namely, `data-min`, `data-max`, and `data-percent`,
    which indicate the respective minimum and maximum value of the range and the current
    arrow position expressed in percentage value.
  prefs: []
  type: TYPE_NORMAL
- en: Within the element marked with the `data-gauge` attribute, we have defined a
    `div` tag that will become the arrow of the gauge.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with the styling phase, we first need to equip ourselves with a framework
    that is easy to use and can give us the opportunity to generate CSS code. We decide
    to go for SASS, the same as we used in [Chapter 5](ch05.html "Chapter 5. An Image
    Gallery"), *An Image Gallery*, so we first need to install Ruby ([http://www.ruby-lang.org/en/downloads/](http://www.ruby-lang.org/en/downloads/))
    and then enter the following from a command-line terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You would probably need to execute the following command if you are working
    in Unix/Linux environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Installing Compass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this project we'll also use Compass, a SASS extension able to add some interesting
    features to our SASS stylesheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Compass, we have to just enter `gem install compass` (or `sudo gem
    install compass`) in a terminal window. After the installation procedure is over,
    we have to create a small `config.rb` file in the root folder of our project using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `config.rb` file helps Compass to understand the location of the various
    assets of the project; let''s have a look at these options in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http_path`: This must be set to the HTTP URL related to the project''s root
    folder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`css_dir`: This contains the relative path to the folder where the generated
    CSS files should be saved'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sass_dir`: This contains the relative path to the folder that contains our
    `.scss` files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`images_dir`: This contains the relative path to the folder that holds all
    the images of the project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javascripts_dir`: This is similar to `images_dir`, but for JavaScript files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other options available; we can decide whether the output CSS should
    be compressed or not, or we can ask Compass to use relative paths instead of absolute
    ones. For a complete list of all the options available, see the documentation
    at [http://compass-style.org/help/tutorials/configuration-reference/](http://compass-style.org/help/tutorials/configuration-reference/).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can create the folder structure we just described, providing our project
    with the `css`, `img`, `js`, and `scss` folders. Lastly, we can create an empty
    `scss/application.scss` file and start discovering the beauty of Compass.
  prefs: []
  type: TYPE_NORMAL
- en: CSS reset and vendor prefixes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can ask Compass to regenerate the CSS file after each update to its SCSS
    counterpart. To do so, we need to execute the following command from the root
    of our project using a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Compass provides an alternative to the Yahoo! reset stylesheet we used in our
    previous project. To include this stylesheet, all we have to do is add a SASS
    `include` directive to our `application.scss` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we check `css/application.css`, the following is the result (trimmed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice also how the generated CSS keeps a reference to the original SCSS; this
    comes in handy when it's a matter of debugging some unexpected behaviors in our
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next `@import` directive will take care of the CSS3 experimental vendor
    prefixes. By adding `@import "compass/css3"` on top of the `application.scss`
    file, we ask Compass to provide us with a lot of powerful methods for adding experimental
    prefixes automatically; for example, the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Is compiled into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Equipped with this new knowledge, we can now start deploying the project.
  prefs: []
  type: TYPE_NORMAL
- en: Using rem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this project we want to introduce `rem`, a measurement unit that is almost
    equivalent to `em`, but is always relative to the root element of the page. So,
    basically we can define a font size on the `html` element and then all the sizes
    will be related to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `1rem` corresponds to `20px`; the problem of this measurement is that
    some browsers, such as Internet Explorer version 8 or less, don''t actually support
    it. To find a way around this problem, we can use the following two different
    fallback measurement units:'
  prefs: []
  type: TYPE_NORMAL
- en: '`em`: The good news is that `em`, if perfectly tuned, works exactly as `rem`;
    the bad news is that this measurement unit is relative to the element''s `font-size`
    property and is not relative to `html`. So, if we decide to pursue this method,
    we then have to take extra care every time we deal with `font-size`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`px`: We can use a fixed unit pixel size. The downside of this choice is that
    in older browsers, we''re complicating the ability to dynamically change the proportions
    of our widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this project, we will use pixels as our unit of measurement. The reason we
    have decided this is because one of the `rem` benefits is that we can change the
    size of the gauge easily by changing the font-size property with media queries.
    This is only possible where media queries and `rem` are supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have to find a way to address most of the duplication that would emerge
    from having to insert every statement containing a space measurement unit twice
    (`rem` and `px`). We can easily solve this problem by creating a SASS mixin within
    our `application.scss` file as follows (for more info on SASS mixins, we can refer
    to the specifications page at [http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#mixins](http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#mixins)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'So the next time instead of writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can instead write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to that, we can also save the `multiplier` coefficient between
    `px` and `rem` in a variable and use it in every call to this function and within
    the `html` declaration; let''s also add this to `application.scss`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Of course, there are still some cases in which the `@mixin` directive that we
    just created doesn't work, and in such situations we'll have to handle this duality
    manually.
  prefs: []
  type: TYPE_NORMAL
- en: Basic structure of a gauge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we''re ready to develop at least the basic structure of our gauge, which
    includes the rounded borders and the minimum and maximum range labels. The following
    code is what we need to add to `application.scss`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With `box-shadow` and `border`, we can't use the `px_and_rem` mixin, so we duplicated
    these properties using `px` first and then `rem`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic structure of a gauge](img/3264OT_08_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Gauge tick marks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How to handle tick marks? One method would be by using images, but another
    interesting alternative is to benefit from multiple background support and create
    those tick marks out of gradients. For example, to create a vertical mark, we
    can use the following within the `div[data-gauge]` selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Basically, we define a very small gradient between transparent and another color
    in order to obtain the tick mark. That's the first step, but we're yet to deal
    with the fact that each tick mark must be defined with a different angle. We can
    solve this problem by introducing a SASS function that takes the number of tick
    marks to print and iterates up to that number while also adjusting the angles
    of each mark. Of course, we also have to take care of experimental vendor prefixes,
    but we can count on Compass for that.
  prefs: []
  type: TYPE_NORMAL
- en: The following is the function. We can create a new file called `scss/_gauge.scss`
    for this and other gauge-related functions; the leading underscore is to tell
    SASS to not create a `.css` file out of this `.scss` file, because it will be
    included in a separate file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We start with an empty string adding the result of calling the `linear-gradient`
    Compass function, which handles experimental vendor prefixes, with an angle that
    varies based on the current tick mark index.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this function out, we first need to include `_gauge.scss` in `application.scss`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can insert the function call within the `div[data-gauge]` selector
    in `application.scss`, specifying the number of tick marks required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `background` function is also provided by Compass and it is just another
    mechanism to deal with experimental prefixes. Unfortunately, if we reload the
    projects the results are far from expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Gauge tick marks](img/3264OT_08_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although we can see a total of 11 stripes, they are of the wrong sizes and in
    the wrong position. To resolve this, we will create some functions to set the
    correct values for `background-size` and `background-position`.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with background size and position
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with `background-size`, the easiest. Since we want each of the
    tick marks to be exactly `1rem` in size, we can proceed by creating a function
    that prints **1rem 1rem** as many times as the number of the passed parameter;
    so let''s add the following code to `_gauge.scss`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We already noticed the `append` function; an interesting thing to know about
    it is that the last parameter of this function lets us decide if some letter must
    be used to concatenate the strings being created. One of the available options
    is `comma`, which perfectly suits our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add a call to this function within the `div[data-gauge]` selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dealing with background size and position](img/3264OT_08_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now the tick marks are of the right size, but they are displayed one above
    the other and are repeated all across the element. To avoid this behavior, we
    can simply add `background-repeat: no-repeat` just below the previous instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, to handle the position of the tick marks we need another
    SASS function; this time it''s a little more complex and involves a bit of trigonometry.
    Each gradient must be placed in the function of its angle—x is the cosine of that
    angle and y the sine. The `sin` and `cos` functions are provided by Compass, we
    need just to handle the shift, because they are referred to the center of the
    circle whereas our css property''s origin is in the upper-left corner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can go ahead and add a new line inside the `div[data-gauge]` selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s the much-awaited result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dealing with background size and position](img/3264OT_08_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to create a `@mixin` directive to hold these three functions
    together, so we can add the following to `_gauge.scss`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And replace what we placed inside `div[data-gauge]` in this chapter with a
    single invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve also left three additional parameters to define extra values for `background`,
    `background-size` , and `background-position`, so we can, for example, easily
    add a gradient background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And following is the screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dealing with background size and position](img/3264OT_08_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the arrow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create an arrow we can start by defining the circular element in the center
    of the gauge that holds the arrow. This is easy and doesn''t introduce anything
    really new; here''s the code that needs to be nested within the `div[data-gauge]`
    selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The arrow itself is a more serious business; the basic idea is to use a linear
    gradient that adds a color only to half the element starting from its diagonal.
    Then we can rotate the element in order to move the pointed end at its center.
    The following is the code that needs to be placed within `div[data-arrow]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To better understand the trick behind this implementation, we can temporarily
    add `border: 1px solid red` within the `&:before` selector to the result and zoom
    a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the arrow](img/3264OT_08_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Moving the arrow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we want to position the arrow to the correct angle depending on the `data-percent`
    attribute value. To do so we have to take advantage of the power of SASS. In theory
    the CSS3 specification would allow us to valorize some properties using values
    taken from attributes, but in practice this is only possible while dealing with
    the `content` property, as we saw earlier in this book.
  prefs: []
  type: TYPE_NORMAL
- en: So what we're going to do is create a `@for` loop from `0` to `100` and print
    in each iteration a selector that matches a defined value of the `data-percent`
    attribute. Then we'll set a different `rotate()` property for each of the CSS
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code; this time it must be placed within the `div[data-gauge]`
    selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are too scared about the amount of CSS generated, then you can decide
    to adjust the increment of the gauge, for example, to `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Moving the arrow](img/3264OT_08_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Animating the gauge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now animate the arrow using CSS transitions. Basically, we have to tell
    the browser that the `transform` property needs to be animated; the necessary
    SASS code is a bit longer than expected because Compass is not yet able to prefix
    the `transition` property and its value ([https://github.com/chriseppstein/compass/issues/289](https://github.com/chriseppstein/compass/issues/289)),
    so we have to do it manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: After we have placed these CSS instructions inside the `div[data-arrow]` selector,
    we'll notice that if we change the `data-percentage` property, for example, by
    using Chrome and its development console, the arrow responds with a smooth animation.
  prefs: []
  type: TYPE_NORMAL
- en: Overall indicator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some gauges present a color indicator, usually from green to red, associated
    with the position of the arrow; we can work out a similar result. First of all
    we need to define two new custom data attributes, one that indicates the percentage
    at which the indicator switches from green to orange and the other where the percentage
    switches from orange to red. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to specify a default background color, let''s say `green`, within
    `div[data-gauge]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we redefine the background gradient to leave the first 25 percent of
    the circumference transparent; in this way we can display (and control) the underlying
    color, so let''s rewrite the `gauge-background` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now we can use another Sass loop to change the `background-color` property respecting
    the value defined in the attributes. Since we're going to implement a loop nested
    in the previous loop, we have to be careful not to increase the size of the resulting
    CSS too much.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this let's consider only the 10s of the `data-orange-from` and `data-red-from`
    data attributes. What we need to do is basically write a CSS rule that activates
    the red or orange background color if the `data-percentage` property is greater
    than or equal to `data-orange-from` or `data-red-from`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the complete loop, including the previous loop we used to
    move the arrow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overall indicator](img/3264OT_08_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Reducing the size of the CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can reduce the size of the generated CSS by asking Compass to not add a comment
    before each rule pointing to the corresponding SASS rule. If we want to do that,
    simply add `line_comments = false` to our `config.rb` file and then stop and relaunch
    `compass watch` in the project's root folder.
  prefs: []
  type: TYPE_NORMAL
- en: Adding some trembling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an additional feature we can add an option to let the arrow tremble a bit
    when it nears 100 percent. We can achieve this behavior by adding a small animation
    if an extra `data-trembling` attribute is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, Compass doesn''t provide CSS3 animation mixins out of the box,
    so we have to install a Compass plugin that can help us with that. In this case,
    the plugin is called **compass-animation** ([https://github.com/ericam/compass-animation](https://github.com/ericam/compass-animation)),
    created by Eric Meyer ([http://eric.andmeyer.com/](http://eric.andmeyer.com/)).
    This is how it''s installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Or as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we have to include the plugin both when calling `compass watch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the header of `application.scss`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Well done! Now we''re ready to define a really simple animation that modifies
    the rotating angle of the arrow causing the trembling effect we''re looking for.
    Let''s add a few lines of code at the end of `application.scss`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to add a new rule within `div[data-gauge]` that activates this
    animation if `data-trembling` is present and `data-percentage` starts with `8`
    or `9` or is equal to `100`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, due to some yet-to-be-resolved bugs in WebKit-based browsers
    that prevent animations from being applied to `before` and `after` pseudo-selectors,
    at the time of writing only Firefox correctly implements this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding some trembling](img/3264OT_08_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Displaying the gauge value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we make a small edit to our HTML code, we can easily display the current
    gauge value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And following is the code to add within the `div[data-gauge]` selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying the gauge value](img/3264OT_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Graceful degradation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To keep this widget meaningful also for those browsers that do not support
    background gradients, we have to handle a different representation for the arrow.
    To detect where this feature is missing, we can use Modernizr by creating a custom
    build ([http://modernizr.com/download/](http://modernizr.com/download/)), as we
    saw in the previous chapters that check only for gradient support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can go for a solid background color; the arrow will, of course, become
    a rectangle but we''ll save the meaning of the widget; let''s add this rule at
    the bottom of `application.scss`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'And following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graceful degradation](img/3264OT_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can go a step forward by using Compass'' ability to translate gradients
    into `Base64`-encoded SVG and use them as fallback background images where native
    gradients are not supported. Unfortunately, this doesn''t work with gradients
    that express an angle using numeric values, such as `23deg`, so we will not be
    able to reproduce tick marks. We can however ask Compass to convert the `radial-gradient`
    property we use for background. The following are the properties we need to add
    inside the `.no-cssgradients div[data-gauge]` rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following is the result, much closer to the original gauge:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graceful degradation](img/3264OT_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing the gauge in Internet Explorer 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to support Internet Explorer 8, then we need to address the lack
    of both the `border-radius` and `transform` properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `border-radius` we can use a JavaScript-based polyfill such as CSS3 Pie,
    and we can download this polyfill from its website, [http://css3pie.com/](http://css3pie.com/),
    and then copy `PIE.js` in our project''s `js` folder. Next, we can include this
    JavaScript file from `index.html` along with the latest version of jQuery and
    `js/application.js`, an empty file we are going to use in a while:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Usually CSS3 Pie automatically detects how to enhance a given element by identifying
    the CSS3 properties to emulate. In this case, however, we have used `border-top-left-radius`
    and `border-top-right-radius` whereas CSS3 Pie only supports the general `border-radius`.
    We can find a way around this by adding a special `border-radius` property prefixed
    with `–pie` inside the `div[data-gauge]` rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to activate CSS3 Pie by inserting a few lines of JavaScript code
    inside `js/application.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'And following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the gauge in Internet Explorer 8](img/3264OT_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now if we want to activate the arrow rotation, we need to emulate the `transform`
    property. To achieve this behavior, we can use `jquery.transform.js` ([https://github.com/louisremi/jquery.transform.js](https://github.com/louisremi/jquery.transform.js))
    by Louis-Rémi Babé ([http://twitter.com/louis_remi](http://twitter.com/louis_remi)).
  prefs: []
  type: TYPE_NORMAL
- en: 'After downloading the library, we need to copy `jquery.transform2d.js` into
    the `js` folder of our project. Then we add the necessary `script` element in
    `index.html`. In order to add a different class to the `html` element when the
    browser is Internet Explorer 8, we will use `IE` conditional comments to add a
    different class to the `html` element. The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '`jquery.transform2d.js` adds the ability to trigger the `transform` property
    even on Internet Explorer 8 thereby enhancing the `css` function provided by jQuery;
    the following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we can try to add a few more JavaScript lines of code by calling the preceding
    function; this transforms `js/application.js` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the results are not as good as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the gauge in Internet Explorer 8](img/3264OT_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The problem is that the `div[data-arrow]:before` element is clipped within its
    parent. This can be resolved by drawing a white disk (now a square) under the
    arrow, and resizing `div[data-arrow]` to be as large as the whole widget with
    a transparent background and no borders in order to easily contain the arrow.
  prefs: []
  type: TYPE_NORMAL
- en: To do so we can use the `.ie8` class to add some properties only when the browser
    is Internet Explorer 8\. Let's append a few lines of code to `application.scss`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, following is the working result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the gauge in Internet Explorer 8](img/3264OT_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Compass and Internet Explorer 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The latest version of Compass at the time of writing (0.12.0) doesn''t add
    the `-ms-` experimental prefix to `linear-gradient` and `radial-gradient`. To
    find a way around this problem and make the gauge work smoothly also on IE10,
    we have to apply some modifications to our `.scss` code. In particular, we need
    to change the `gauge-tick-marks` function inside `_gauge.scss` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to change the `gauge-background` mixin, also inside `_gauge.scss`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally we have to add an extra CSS line in `application.scss` inside `:before`
    within `div[data-arrow]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'After making these small modifications, we can also appreciate this widget
    using Internet Explorer 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Compass and Internet Explorer 10](img/3264OT_08_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drawing a gauge can be more difficult than expected; this is more truer if we
    also take care of keeping support for older browsers. In this chapter, we learned
    how to install and work with Compass, create complex CSS using the power of the
    SASS syntax, and deal with graceful degradation and polyfill techniques. In the
    next chapter, we'll create a movie trailer by leveraging the power of CSS animations
    and 3D transforms.
  prefs: []
  type: TYPE_NORMAL
