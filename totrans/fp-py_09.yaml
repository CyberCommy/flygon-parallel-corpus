- en: Chapter 9. More Itertools Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming emphasizes stateless programming. In Python, this leads
    us to work with generator expressions, generator functions, and iterables. In
    this chapter, we'll continue our study of the `itertools` library, with numerous
    functions to help us work with iterable collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we looked at three broad groupings of iterator functions.
    They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions that work with infinite iterators can be applied to any iterable or
    an iterator over any collection; they will consume the entire source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions that work with finite iterators can either accumulate a source multiple
    times, or they produce a reduction of the source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `tee()` iterator function clones an iterator into several copies that can
    each be used independently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at the `itertools` functions that work with permutations
    and combinations. These include several functions and a few recipes built on these
    functions. The functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`product()`: This function forms a Cartesian product equivalent to the nested
    `for` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`permutations()`: This function emits tuples of length *r* from a universe
    *p* in all possible orderings; there are no repeated elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`combinations()`: This function emits tuples of length *r* from a universe
    *p* in sorted order; there are no repeated elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`combinations_with_replacement()`: This function emits tuples of length *r*
    from *p* in a sorted order, with repeated elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These functions embody algorithms that iterate over potentially large result
    sets from small collections of input data. Some kinds of problems have exact solutions
    based on exhaustively enumerating a potentially gigantic universe of permutations.
    The functions make it simple to emit a large number of permutations; in some cases,
    the simplicity isn't actually optimal.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating the Cartesian product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term Cartesian product refers to the idea of enumerating all the possible
    combinations of elements drawn from a number of sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathematically, we might say that the product of two sets, ![Enumerating the
    Cartesian product](graphics/B03652_09_01.jpg), has 52 pairs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can produce the preceding results by executing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The calculation of a product can be extended to any number of iterable collections.
    Using a large number of collections can lead to a very large result set.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing a product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In relational database theory, a join between tables can be thought of as a
    filtered product. A SQL `SELECT` statement that joins tables without a `WHERE`
    clause will produce a Cartesian product of rows in the tables. This can be thought
    of as the worst-case algorithm: a product without any filtering to pick the proper
    results.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `join()` function to join two tables, as shown in the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: All combinations of the two iterables, `t1` and `t2`, are computed. The `filter()`
    function will apply the given `where` function to pass or reject items that didn't
    fit the given condition to match appropriate rows from each iterable. This will
    work when the `where` function returns a simple Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, we don't have a simple Boolean matching function. Instead, we're
    forced to search for a minimum or maximum of some distance between items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that we have a table of `Color` objects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For more information, see [Chapter 6](ch06.html "Chapter 6. Recursions and Reductions"),
    *Recursions and Reductions*, where we showed you how to parse a file of colors
    to create `namedtuple` objects. In this case, we've left the RGB as a triple,
    instead of decomposing each individual field.
  prefs: []
  type: TYPE_NORMAL
- en: 'An image will have a collection of pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As a practical matter, the **Python Imaging Library** (**PIL**) package presents
    the pixels in a number of forms. One of these is the mapping from (*x*, *y*) coordinate
    to RGB triple. For more information, visit [https://pypi.python.org/pypi/Pillow](https://pypi.python.org/pypi/Pillow)
    for the Pillow project documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a `PIL.Image` object, we can iterate over the collection of pixels with
    something like the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We've determined the range of each coordinate based on the image size. The calculation
    of the `product(range(w), range(h))` method creates all the possible combinations
    of coordinates. It is, effectively, two nested `for` loops.
  prefs: []
  type: TYPE_NORMAL
- en: This has the advantage of providing each pixel with its coordinates. We can
    then process the pixels in no particular order and still reconstruct an image.
    This is particularly handy when using multiprocessing or multithreading to spread
    the workload among several cores or processors. The `concurrent.futures` module
    provides an easy way to distribute work among cores or processors.
  prefs: []
  type: TYPE_NORMAL
- en: Computing distances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A number of decision-making problems require that we find a close-enough match.
    We might not be able to use a simple equality test. Instead, we have to use a
    distance metric and locate items with the shortest distance to our target. For
    text, we might use the Levenshtein distance; this shows how many changes are required
    to get from a given block of text to our target.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use a slightly simpler example. This will involve very simple math. However,
    even though it's simple, it doesn't work out well if we approach it naively.
  prefs: []
  type: TYPE_NORMAL
- en: When doing color matching, we won't have a simple equality test. We're rarely
    able to check for the exact equality of pixel colors. We're often forced to define
    a minimal distance function to determine whether two colors are close enough,
    without being the same three values of R, G, and B. There are several common approaches,
    including the Euclidean distance, Manhattan distance, and yet other complex weightings
    based on visual preferences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the Euclidean and Manhattan distance functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Euclidean distance measures the hypotenuse of a right-angled triangle among
    the three points in an RGB space. The Manhattan distance sums the edges of each
    leg of the right-angled triangle among the three points. The Euclidean distance
    offers precision where the Manhattan distance offers calculation speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking forward, we''re aiming for a structure that looks like this. For each
    individual pixel, we can compute the distance from that pixel''s color to the
    available colors in a limited color set. The results of this calculation for a
    single pixel might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve shown an overall tuple that consists of a number of four tuples. Each
    of the four tuples contains the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: The pixel's coordinates, for example, (0,0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pixel's original color, for example, (92, 139, 195)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Color` object from our set of seven colors, for example, Color(rgb=(239,
    222, 205),name='Almond')
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Euclidean distance between the original color and the given `Color` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see that the smallest Euclidean distance is the closest match color.
    This kind of reduction is done easily with the `min()` function. If the overall
    tuple is assigned to a variable name, `choices`, the pixel-level reduction would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We've called each four tuple an xypcd, that is, an xy coordinate, pixel, color,
    and distance. The minimum distance calculation will then pick a single four tuple
    as the optimal match between pixel and color.
  prefs: []
  type: TYPE_NORMAL
- en: Getting all pixels and all colors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How do we get to the structure that contains all pixels and all colors? The
    answer is simple but, as we'll see, less than optimal.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to map pixels to colors is to enumerate all pixels and all colors using
    the `product()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The core of this is the `product(pixel_iter(img), colors)` method that creates
    all pixels combined with all colors. We will do a bit of restructuring of the
    data to flatten it out. We will apply the `euclidean()` function to compute distances
    between pixel colors and `Color` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final selection of colors uses the `groupby()` function and the `min(choices,...)`
    expression, as shown in the following command snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The overall product of pixels and colors is a long, flat iterable. We grouped
    the iterable into smaller collections where the coordinates match. This will break
    the big iterable into smaller iterables of just colors associated with a single
    pixel. We can then pick the minimal color distance for each color.
  prefs: []
  type: TYPE_NORMAL
- en: In a picture that's 3,648×2,736 with 133 Crayola colors, we have an iterable
    with 1,327,463,424 items to be evaluated. Yes. That's a billion combinations created
    by this `distances` expression. The number is not necessarily impractical. It's
    well within the limits of what Python can do. However, it reveals an important
    flaw in the naïve use of the `product()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can''t trivially do this kind of large-scale processing without some analysis
    to see how large it is. Here are some `timeit` numbers for these that do each
    of these calculations only 1,000,000 times:'
  prefs: []
  type: TYPE_NORMAL
- en: Euclidean 2.8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manhattan 1.8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling up from 1 million to 1 billion means 1,800 seconds, that is, about half
    an hour for the Manhattan distance and 46 minutes to calculate the Euclidean distance.
    It appears that the core arithmetic operations of Python are too slow for this
    kind of naïve bulk processing.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, we're doing it wrong. This kind of *width×height×color* processing
    is simply a bad design. In many cases, we can do much better.
  prefs: []
  type: TYPE_NORMAL
- en: Performance analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A key feature of any big data algorithm is locating a way to execute some kind
    of a divide-and-conquer strategy. This is true of functional programming design
    as well as imperative design.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have three options to speed up this processing; they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We can try to use parallelism to do more of the calculations concurrently. On
    a four-core processor, the time can be cut to approximately ¼. This cuts the time
    to 8 minutes for Manhattan distances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can see if caching intermediate results will reduce the amount of redundant
    calculation. The question arises of how many colors are the same and how many
    colors are unique.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can look for a radical change in the algorithm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll combine the last two points by computing all the possible comparisons
    between source colors and target colors. In this case, as in many other contexts,
    we can easily enumerate the entire mapping and avoid redundant calculation when
    done on a pixel-by-pixel basis. We'll also change the algorithm from a series
    of comparisons to a series of simple lookups in a mapping object.
  prefs: []
  type: TYPE_NORMAL
- en: 'When looking at this idea of precomputing all transformations for source color
    to target color, we need some overall statistics for an arbitrary image. The code
    associated with this book includes `IMG_2705.jpg`. Here is a basic algorithm to
    collect some data from the specified image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We collected all pixels of a given color into a list organized by color. From
    this, we''ll learn the first of the following facts:'
  prefs: []
  type: TYPE_NORMAL
- en: The total number of pixels is 9,980,928\. This is not surprising for a 10 megapixel
    image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total number of colors is 210,303\. If we try to compute the Euclidean distance
    between actual colors and the 133 colors, we would merely do 27,970,299 calculations,
    which might take about 76 seconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a 3-bit mask, `0b11100000`, there are 214 colors used out of a possible
    512.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a 4-bit mask, `0b11110000`, there are 1,150 colors used out of 4,096.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a 5-bit mask, `0b11111000`, there are 5,845 colors used out of 32,768.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a 6-bit mask, `0b11111100`, there are 27,726 colors out of 262,144.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This gives us some insight into how we can rearrange the data structure, calculate
    the matching colors quickly, and then rebuild the image without doing a billion
    comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can apply mask values to the RGB bytes with the following piece of command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will pick out the most significant 3 bits of red, green, and blue values.
    If we use this instead of the original color to create a `Counter` object, we'll
    see that we have 214 distinct values.
  prefs: []
  type: TYPE_NORMAL
- en: Rearranging the problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The naïve use of the `product()` function to compare all pixels and all colors
    was a bad idea. There are 10 million pixels, but only 200,000 unique colors. When
    mapping the source colors to target colors, we only have to save 200,000 values
    in a simple map.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll approach it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compute the source to target color mapping. In this case, let''s use 3-bit
    color values as output. Each R, G, and B value comes from the eight values in
    the `range(0, 256, 32)` method. We can use this expression to enumerate all the
    output colors:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can then compute the Euclidean distance to the nearest color in our source
    palette, doing just 68,096 calculations. This takes about 0.14 seconds. It's done
    one time only and computes the 200,000 mappings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In one pass through the image, build a new image using the revised color table.
    In some cases, we can exploit the truncation of integer values. We can use an
    expression such as (`0b11100000&r`, `0b11100000&g`, `0b11100000&b`) to remove
    the least significant bits of an image color. We'll look at this additional reduction
    in computation later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will replace a billion Euclidean distance calculations with 10 million
    dictionary lookups. This will replace 30 minutes of calculation with about 30
    seconds of calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of doing color mapping for all pixels, we'll create a static mapping
    from input to output values. We can build the image building using simple lookup
    mapping from original color to new color.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the palette of all 200,000 colors, we can apply the fast Manhattan
    distance to locate the nearest color in an output, such as the Crayola colors.
    This will use the algorithm for color matching shown earlier to compute the mapping
    instead of a result image. The difference will center on using the `palette.keys()`
    function instead of the `pixel_iter()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll fold in yet another optimization: truncation. This will give us an even
    faster algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: Combining two transformations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When combining multiple transformations, we can build a more complex mapping
    from source through intermediate targets to the result. To illustrate this, we'll
    truncate the colors as well as apply a mapping.
  prefs: []
  type: TYPE_NORMAL
- en: In some problem contexts, truncation can be difficult. In other cases, it's
    often quite simple. For example, truncating US postal ZIP codes from 9 to 5 characters
    is common. Postal codes can be further truncated to three characters to determine
    a regional facility that represents a larger geography.
  prefs: []
  type: TYPE_NORMAL
- en: For colors, we can use the bit-masking shown previously to truncate colors form
    three 8-bit values (24 bits, 16 million colors) to three 3-bit values (9 bits,
    512 colors).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a way to build a color map that combines both distances to a given
    set of colors and truncation of the source colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We created a `range` object, `bit3`, that will iterate through all eight of
    the 3-bit color values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `range` objects aren't like ordinary iterators; they can be used multiple
    times. As a result of this, the `product(bit3, bit3, bit3)` expression will produce
    all 512 color combinations that we'll use as the output colors.
  prefs: []
  type: TYPE_NORMAL
- en: For each truncated RGB color, we created a three tuple that has (0) the distance
    from all crayon colors, (1) the RGB color, and (2) the crayon `Color` object.
    When we ask for the minimum value of this collection, we'll get the closest crayon
    `Color` object to the truncated RGB color.
  prefs: []
  type: TYPE_NORMAL
- en: We built a dictionary that maps from the truncated RGB color to the closest
    crayon. In order to use this mapping, we'll truncate a source color before looking
    up the nearest crayon in the mapping. This use of truncation coupled with the
    precomputed mapping shows how we might need to combine mapping techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the commands for the image replacement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This simply uses a number of PIL features to replace all of the pixels in a
    picture with other pixels.
  prefs: []
  type: TYPE_NORMAL
- en: What we've seen is that the naïve use of some functional programming tools can
    lead to algorithms that are expressive and succinct, but also inefficient. The
    essential tools to compute the complexity of a calculation—sometimes called Big-O
    analysis—is just as important for functional programming as it is for imperative
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is not that the `product()` function is inefficient. The problem
    is that we can use the `product()` function in an inefficient algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Permuting a collection of values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we permute a collection of values, we'll elaborate all the possible orders
    for the items. There are ![Permuting a collection of values](graphics/B03652_09_02.jpg)
    ways to permute ![Permuting a collection of values](graphics/B03652_09_03.jpg)
    items. We can use permutations as a kind of brute-force solution to a variety
    of optimization problems.
  prefs: []
  type: TYPE_NORMAL
- en: By visiting [http://en.wikipedia.org/wiki/Combinatorial_optimization](http://en.wikipedia.org/wiki/Combinatorial_optimization),
    we can see that the exhaustive enumeration of all permutations isn't appropriate
    for larger problems. The use of the `itertools.permutations()` function is a handy
    way to explore very small problems.
  prefs: []
  type: TYPE_NORMAL
- en: One popular example of these combinatorial optimization problems is the assignment
    problem. We have *n* agents and *n* tasks, but the cost of each agent performing
    a given task is not equal. Imagine that some agents have trouble with some details,
    while other agents excel at these details. If we can properly assign tasks to
    agents, we can minimize the costs.
  prefs: []
  type: TYPE_NORMAL
- en: We can create a simple grid that shows how well a given agent is able to perform
    a given task. For a small problem of a half-dozen agents and tasks, there will
    be a grid of 36 costs. Each cell in the grid shows agents 0 to 5 performing tasks
    A to F.
  prefs: []
  type: TYPE_NORMAL
- en: We can easily enumerate all the possible permutations. However, this approach
    doesn't scale well. 10! is 3,628,800\. We can see this sequence of 3 million items
    with the `list(permutations(range(10)))` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would expect to solve a problem of this size in a few seconds. If we double
    the size of the problem to 20!, we would have a bit of a scalability problem:
    there would be 2,432,902,008,176,640,000 permutations. If it takes about 0.56
    seconds to generate 10! permutations, then to generate 20! permutations, it would
    take about 12,000 years.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that we have a cost matrix with 36 values that show the costs of six
    agents and six tasks. We can formulate the problem as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We've created all permutations of tasks for our six agents. We've computed the
    sums of all the costs in our cost matrix for each task assigned to each agent.
    The minimum cost is the optimal solution. In many cases, there might be multiple
    optimal solutions; we'll locate all of them.
  prefs: []
  type: TYPE_NORMAL
- en: For small text-book examples, this is very fast. For larger examples, an approximation
    algorithm is more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Generating all combinations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `itertools` module also supports computing all combinations of a set of
    values. When looking at combinations, the order doesn't matter, so there are far
    fewer combinations than permutations. The number of combinations is often stated
    as ![Generating all combinations](graphics/B03652_09_04.jpg). This is the number
    of ways that we can take combinations of `r` things at a time from a universe
    of `p` items overall.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, there are 2,598,960 5-card poker hands. We can actually enumerate
    all 2 million hands by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'More practically, we have a dataset with a number of variables. A common exploratory
    technique is to determine the correlation among all pairs of variables in a set
    of data. If there are *v* variables, then we will enumerate all variables that
    must be compared by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get some sample data from [http://www.tylervigen.com](http://www.tylervigen.com)
    to show how this will work. We''ll pick three datasets with the same time range:
    numbers 7, 43, and 3890\. We''ll simply laminate the data into a grid, repeating
    the year column.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the first and the remaining rows of the yearly data will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we can use the `combinations()` function to emit all the combinations
    of the nine variables in this dataset, taken two at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: There are 36 possible combinations. We'll have to reject the combinations that
    involve `year` and `year`. These will trivially correlate with a value of 1.00.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a function that picks a column of data out of our dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to use the `corr()` function from [Chapter 4](ch04.html "Chapter 4. Working
    with Collections"), *Working with Collections*, to compare two columns of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we can compute all combinations of correlations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: For each combination of columns, we've extracted the two columns of data from
    our data set and used multiple assignments to separate the header from the remaining
    rows of data. If the headers match, we're comparing a variable to itself. This
    will be `True` for the three combinations of `year` and `year` that stem from
    the redundant year columns.
  prefs: []
  type: TYPE_NORMAL
- en: Given a combination of columns, we will compute the correlation function and
    then print the two headings along with the correlation of the columns. We've intentionally
    chosen some datasets that show spurious correlations with a dataset that doesn't
    follow the same pattern. In spite of this, the correlations are remarkably high.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It's not at all clear what this pattern means. We used a simple expression,
    `combinations(range(9), 2)`, to enumerate all the possible combinations of data.
    This kind of succinct, expressive technique makes it easier to focus on the data
    analysis issues instead of the Combinatoric algorithm considerations.
  prefs: []
  type: TYPE_NORMAL
- en: Recipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The itertools chapter of the Python library documentation is outstanding. The
    basic definitions are followed by a series of recipes that are extremely clear
    and helpful. Since there's no reason to reproduce these, we'll reference them
    here. They are the required reading materials on functional programming in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Section *10.1.2*, *Itertools Recipes*, of *Python Standard Library* is a wonderful
    resource. Visit [https://docs.python.org/3/library/itertools.html#itertools-recipes](https://docs.python.org/3/library/itertools.html#itertools-recipes)
    more details.
  prefs: []
  type: TYPE_NORMAL
- en: These function definitions aren't importable functions in the `itertools` modules.
    These are ideas that need to be read and understood and then, perhaps, copied
    or modified before inclusion in an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes some recipes that show functional programming
    algorithms built from the itertools basics:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function Name | Arguments | Results |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `powerset` | `(iterable)` | This generates all the subsets of the iterable.
    Each subset is actually a `tuple` object, not a set instance. |'
  prefs: []
  type: TYPE_TB
- en: '| `random_product` | `(*args, repeat=1)` | This randomly selects from `itertools.product(*args,
    **kwds)`. |'
  prefs: []
  type: TYPE_TB
- en: '| `random_permutation` | `(iterable, r=None)` | This randomly selects from
    `itertools.permutations(iterable, r)`. |'
  prefs: []
  type: TYPE_TB
- en: '| `random_combination` | `(iterable, r)` | This randomly selects from `itertools.combinations(iterable,
    r)`. |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at a number of functions in the `itertools` module.
    This library module provides a number of functions that help us work with iterators
    in sophisticated ways.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the `product()` function that will compute all the possible combinations
    of the elements chosen from two or more collections. The `permutations()` function
    gives us different ways to reorder a given set of values. The `combinations()`
    function returns all the possible subsets of the original set.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at ways in which the `product()` and `permutations()` functions
    can be used naïvely to create extremely large result sets. This is an important
    cautionary note. A succinct and expressive algorithm can also involve a vast amount
    of computation. We must perform basic complexity analysis to be sure that the
    code will finish in a reasonable amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at the `functools` module. This module includes
    some tools to work with functions as first-class objects. This builds on some
    material shown in [Chapter 2](ch02.html "Chapter 2. Introducing Some Functional
    Features"), *Introducing Some Functional Features*, and [Chapter 5](ch05.html
    "Chapter 5. Higher-order Functions"), *Higher-order Functions*.
  prefs: []
  type: TYPE_NORMAL
