- en: Securing Access to APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护API访问
- en: In this chapter, we will see how we can secure access to the APIs and web pages
    exposed by the edge server introduced in the previous chapter. We will learn to
    use HTTPS to protect against eavesdropping on external access to our APIs and
    also how to use OAuth 2.0 and OpenID Connect to authenticate and authorize users
    and client applications to access our APIs. Finally, we will study the use of
    HTTP basic authentication to secure access to the discovery service, Netflix Eureka.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何保护上一章介绍的边缘服务器暴露的API和网页的访问。我们将学习使用HTTPS来保护对我们的API的外部访问，以防止窃听，以及如何使用OAuth
    2.0和OpenID Connect对用户和客户端应用程序进行身份验证和授权以访问我们的API。最后，我们将研究使用HTTP基本身份验证来保护对发现服务Netflix
    Eureka的访问。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An introduction to the OAuth 2.0 and OpenID Connect standards
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth 2.0和OpenID Connect标准介绍
- en: A general discussion on how to secure the system landscape
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对如何保护系统架构进行了一般讨论
- en: Adding an authorization server to our system landscape
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向我们的系统架构添加授权服务器
- en: Protecting external communication with HTTPS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTPS保护外部通信
- en: Securing access to the discovery service, Netflix Eureka
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护对发现服务Netflix Eureka的访问
- en: Authenticating and authorizing API access using OAuth 2.0 and OpenID Connect
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OAuth 2.0和OpenID Connect对API访问进行身份验证和授权
- en: Testing with the local authorization server
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本地授权服务器进行测试
- en: Testing with an OpenID Connect provider, Auth0
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenID Connect提供者Auth0进行测试
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All commands described in this book are run on a MacBook Pro using macOS Mojave
    but modifying them so they run on another platform such as Linux or Windows should
    be straightforward.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的所有命令都在使用macOS Mojave的MacBook Pro上运行，但修改它们以在其他平台（如Linux或Windows）上运行应该很简单。
- en: No new tools need to be installed in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中不需要安装新工具。
- en: The source code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter11](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter11).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在GitHub上找到[https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter11](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter11)。
- en: 'To be able to run the commands as described in the book, download the source
    code to a folder and set up an environment variable, `$BOOK_HOME`, that points
    to that folder. The following commands can be used to perform these steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够按照书中描述的方式运行命令，请将源代码下载到一个文件夹并设置一个环境变量`$BOOK_HOME`，指向该文件夹。以下命令可用于执行这些步骤：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Java source code is written for Java 8 and tested on Java 12\. This chapter
    uses Spring Cloud 2.1.0, SR1 (also known as the **Greenwich** release), Spring
    Boot 2.1.3, and Spring 5.1.5, that is, the latest available version of the Spring
    components at the time of writing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Java源代码是为Java 8编写的，并在Java 12上进行了测试。本章使用Spring Cloud 2.1.0，SR1（也称为**Greenwich**发布版），Spring
    Boot 2.1.3和Spring 5.1.5，即编写时可用的Spring组件的最新版本。
- en: 'The source code contains the following Gradle projects:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码包含以下Gradle项目：
- en: '`api`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`API`'
- en: '`util`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`工具`'
- en: '`microservices/product-service`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`微服务/产品服务`'
- en: '`microservices/review-service`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`微服务/评论服务`'
- en: '`microservices/recommendation-service`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`微服务/推荐服务`'
- en: '`microservices/product-composite-service`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`微服务/产品组合服务`'
- en: '`spring-cloud/eureka-server`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud/eureka-server`'
- en: '`spring-cloud/gateway`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud/网关`'
- en: '`spring-cloud/authorization-server`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud/授权服务器`'
- en: The code examples in this chapter all come from source code in `$BOOK_HOME/Chapter11`,
    but are, in several cases, edited to remove non-relevant parts of the source code,
    such as comments, imports, and log statements.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例都来自于`$BOOK_HOME/Chapter11`中的源代码，但在几种情况下进行了编辑，以删除源代码中的非相关部分，如注释、导入和日志语句。
- en: If you want to see the changes applied to the source code in [Chapter 11](bcb9bba0-d2fe-4ee8-954b-07a7e38e1115.xhtml), *Secure
    Access to APIs*, that is, to see what it took to secure access to the APIs in
    the microservice landscape, you can compare it with the source code for [Chapter
    10](a3383211-405d-4319-b142-ddb8cf3674fd.xhtml), *Using Spring Cloud Gateway to
    Hide Microservices Behind an Edge Server*. You can use your favorite `diff` tool
    and compare the two folders, `$BOOK_HOME/Chapter10` and `$BOOK_HOME/Chapter11`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看应用于[第11章](bcb9bba0-d2fe-4ee8-954b-07a7e38e1115.xhtml)源代码的更改，即查看在微服务架构中保护API访问所需的内容，您可以将其与[第10章](a3383211-405d-4319-b142-ddb8cf3674fd.xhtml)的源代码进行比较，*使用Spring
    Cloud Gateway隐藏微服务在边缘服务器后面*。您可以使用您喜欢的`diff`工具，比较两个文件夹`$BOOK_HOME/Chapter10`和`$BOOK_HOME/Chapter11`。
- en: Introduction to OAuth 2.0 and OpenID Connect
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth 2.0和OpenID Connect介绍
- en: Before introducing OAuth 2.0 and OpenID Connect, let's clarify what we mean
    with authentication and authorization. **Authentication** means identifying a
    user by validating credentials supplied by the user, such as a username and password.
    **Authorization** is about giving access to various parts of, in our case, an
    API to an authenticated, that is, an identified user. In our case, a user will
    be assigned a set of privileges based on OAuth 2.0 scopes, as explained hereinafter.
    The microservices will be based on these privileges determine whether the user
    is allowed to access an API.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍OAuth 2.0和OpenID Connect之前，让我们澄清一下我们所说的身份验证和授权。**身份验证**是指通过验证用户提供的凭据（如用户名和密码）来识别用户。**授权**是指向已经认证的用户，即已经确定身份的用户，授予对各个部分的访问权限，即在我们的情况下，API的访问权限。在我们的情况下，用户将根据OAuth
    2.0范围被分配一组特权，如下所述。微服务将基于这些特权确定用户是否被允许访问API。
- en: '**OAuth 2.0** is an open standard for authorization, and **OpenID Connect** is
    an add-on to OAuth 2.0 that enables client applications to verify the identity
    of users based on the authentication performed by the authorization server. Let''s
    look briefly at OAuth 2.0 and OpenID Connect separately to get an initial understanding
    of their purposes!'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0是授权的开放标准，OpenID Connect是OAuth 2.0的附加功能，它使客户端应用程序能够根据授权服务器执行的身份验证来验证用户的身份。让我们简要地分别看一下OAuth
    2.0和OpenID Connect，以便初步了解它们的目的！
- en: Introduction to OAuth 2.0
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth 2.0简介
- en: '**OAuth** *2.0* is a widely accepted open standard for authorization that enables
    a user to give consent for a third-party client application to access protected
    resources in the name of the user.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0是一种广泛接受的授权开放标准，使用户能够同意第三方客户端应用程序以用户的名义访问受保护的资源。
- en: So, what does this mean?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这意味着什么呢？
- en: 'Let''s start with sorting out the concepts used:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始整理使用的概念：
- en: '**Resource owner**: The end user.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源所有者：最终用户。
- en: '**Client**: The third-party client application, for example, a web app or a
    native mobile app, that wants to call some protected APIs in the name of the end
    user.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端：第三方客户端应用程序，例如Web应用程序或本机移动应用程序，希望以最终用户的名义调用一些受保护的API。
- en: '**Resource server**: The server that exposes the APIs that we want to protect.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源服务器：暴露我们想要保护的API的服务器。
- en: '**Authorization server:** The authorization server issues tokens to the client
    after the resource owner, that is, the end user, has been authenticated. The management
    of user information and the authentication of users are typically delegated, behind
    the scenes, to an **Identity Provider** (**IdP**).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权服务器：资源所有者（即最终用户）经过身份验证后，授权服务器向客户端发放令牌。用户信息的管理和用户的身份验证通常在幕后委托给身份提供者（IdP）。
- en: A client is registered in the authorization server and is given a **client ID** and
    a **client secret**. The client secret must be protected by the client, like a
    password. A client also gets registered with a set of allowed **redirect-URIs** that
    the authorization server will use after a user has been authenticated to send
    **grant codes** and **tokens** that have been issued back to the client application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在授权服务器中注册，并获得客户端ID和客户端密钥。客户端密钥必须由客户端保护，就像密码一样。客户端还将被注册为一组允许的重定向URI，授权服务器在用户经过身份验证后将使用这些URI发送授予代码和已发放的令牌回到客户端应用程序。
- en: The following is an example by way of illustration. Let's say that a user accesses
    a third-party client application and the client application wants to call a protected
    API to serve the user. To be allowed to access these APIs, the client application
    needs a way to tell the APIs that it is acting in the name of the user. To avoid
    solutions where the user must share their credentials with the client application
    for authentication, an **access token** is issued by an authorization server that
    gives the client application limited access to a selected set of APIs in the name
    of the user.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个举例说明。假设用户访问第三方客户端应用程序，客户端应用程序希望调用受保护的API以服务用户。为了允许访问这些API，客户端应用程序需要一种方式告诉API它是以用户的名义行事。为了避免用户必须与客户端应用程序共享其凭据进行身份验证的解决方案，授权服务器发放了一个访问令牌，该令牌为客户端应用程序提供了有限的访问权限，以代表用户访问一组选定的API。
- en: This means that the user never has to reveal their credentials to the client
    application. The user can also give consent to the client application to access
    specific APIs on behalf of the user. An access token represents a time-constrained
    set of access rights, expressed as a *scope* in OAuth 2.0 terms. A **refresh token**
    can also be issued to a client application by the authorization server. A refresh
    token can be used by the client application to obtain new access tokens without
    having to involve the user.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着用户永远不必向客户端应用程序透露其凭据。用户还可以同意客户端应用程序代表用户访问特定API。访问令牌代表一组有时间限制的访问权限，以OAuth
    2.0术语表示为*scope*。授权服务器还可以向客户端应用程序发放刷新令牌。刷新令牌可供客户端应用程序使用，以获取新的访问令牌，而无需涉及用户。
- en: 'The OAuth 2.0 specification defines four authorization grant flows for issuing
    access tokens, explained as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0规范定义了四种授权授予流程来发放访问令牌，如下所述：
- en: '**Authorization Code grant flow**: This is the safest, but also the most complex,
    grant flow. This grant flow requires that the user interact with the authorization
    server using a web browser for authentication and giving consent to the client
    application, as illustrated by the following diagram:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权码授予流程：这是最安全但也是最复杂的授予流程。这个授予流程要求用户通过网络浏览器与授权服务器进行交互进行身份验证，并同意客户端应用程序的访问权限，如下图所示：
- en: '![](img/186b42c1-4690-4407-99c1-c0f71c1894c4.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186b42c1-4690-4407-99c1-c0f71c1894c4.png)'
- en: 'Explanations for this diagram are as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此图的解释如下：
- en: The client application initiates the grant flow by sending the user to the authorization
    server in the web browser.
  id: totrans-48
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序通过将用户发送到网络浏览器中的授权服务器来启动授予流程。
- en: The authorization server will authenticate the user and ask for the user's consent.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器将对用户进行身份验证并征求用户的同意。
- en: The authorization server will redirect the user back to the client application
    with a grant code. The authorization server will use the redirect-URI specified
    by the client in step 1 to know where to send the grant code. Since the grant
    code is passed back to the client application using the web browser, that is,
    to an insecure environment where malicious JavaScript code potentially can pick
    up the grant code, it is only allowed to be used once and only during a short
    time period.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器将使用授予代码将用户重定向回客户端应用程序。授权服务器将使用客户端在步骤1中指定的重定向URI，以确定将授予代码发送到何处。由于授予代码是通过网络浏览器传递回客户端应用程序的，即通过一个不安全的环境，恶意JavaScript代码可能会获取授予代码，因此授予代码只允许使用一次，并且只能在短时间内使用。
- en: To exchange the grant code for an access token, the client application is expected
    to call the authorization server again, using server-side code. The client application
    must present its client ID and client secret together with the grant code for
    the authorization server.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将授权代码交换为访问令牌，预期客户端应用程序再次调用授权服务器，使用服务器端代码。客户端应用程序必须提供其客户端ID和客户端密钥以及授权服务器的授权代码。
- en: The authorization server issues an access token and sends it back to the client
    application. The authorization server can also, optionally, issue and return a
    refresh token.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器发放访问令牌并将其发送回客户端应用程序。授权服务器还可以选择性地发放和返回刷新令牌。
- en: Using the access token, the client can send a request to the protected API exposed
    by the resource server.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用访问令牌，客户端可以向资源服务器发送请求，该服务器提供受保护的API。
- en: The resource server validates the access token and serves the request in the
    event of a successful validation. Steps 6 and 7 can be repeated as long as the
    access token is valid. When the lifetime of the access token has expired, the
    client can use their refresh token to acquire a new access token.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源服务器验证访问令牌，并在验证成功的情况下提供请求。只要访问令牌有效，步骤6和7可以重复。当访问令牌的生命周期已过期时，客户端可以使用其刷新令牌来获取新的访问令牌。
- en: '**Implicit grant flow**: This flow is also web browser-based, but intended
    for client applications that are not able to keep a client secret protected, for
    example, a single-page web application. It gets an access token back from the
    authorization server instead of a grant code, but cannot request a refresh token,
    since it is using the implicit grant flow that is less secure than the code grant
    flow.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式授权流程：**这个流程也是基于Web浏览器的，但是适用于无法保护客户端密钥的客户端应用程序，例如单页Web应用程序。它从授权服务器获取访问令牌而不是授权代码，但不能请求刷新令牌，因为它使用的隐式授权流程比代码授权流程不够安全。'
- en: '**Resource Owner Password Credentials grant flow**: If a client application
    can''t interact with a web browser, it can fall back on this grant flow. In this
    grant flow, the user must share their credentials with the client application
    and the client application will use these credentials to acquire an access token.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源所有者密码凭据授权流程：**如果客户端应用程序无法与Web浏览器交互，它可以退而使用此授权流程。在此授权流程中，用户必须与客户端应用程序共享其凭据，客户端应用程序将使用这些凭据来获取访问令牌。'
- en: '**Client Credentials grant flow:** In the case where a client application needs
    to call an API unrelated to a specific user, it can use this grant flow to acquire
    an access token using its own client ID and client secret.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端凭据授权流程：**在客户端应用程序需要调用与特定用户无关的API的情况下，它可以使用此授权流程，使用自己的客户端ID和客户端密钥来获取访问令牌。'
- en: When it comes to automating tests against APIs that are protected by OAuth 2.0,
    the **Resource Owner Password Credentials grant flow** is very handy since it
    doesn't require manual interaction using a web browser. We will use this later
    on in this chapter with our test script; see the *Changes in the test script* section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动化测试受OAuth 2.0保护的API时，**资源所有者密码凭据授权流程**非常方便，因为它不需要使用Web浏览器进行手动交互。我们将在本章后面使用这个测试脚本；请参阅*测试脚本中的更改*部分。
- en: 'The full specification can be found here: [https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749).
    There are also a number of additional specifications that detail various aspects
    of OAuth 2.0; for an overview, refer to [https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/](https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的规范可以在这里找到：[https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749)。还有许多其他规范详细介绍了OAuth
    2.0的各个方面；有关概述，请参阅[https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/](https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/)。
- en: One additional specification that is worth some extra attention is *RFC 7636
    – Proof Key for Code Exchange by OAuth Public Clients (PKCE), *[https://tools.ietf.org/html/rfc7636](https://tools.ietf.org/html/rfc7636).
    This specification describes how an otherwise insecure public client, such as
    a mobile native app or desktop application, can utilize the code grant flow by
    adding an extra layer of security.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 值得额外关注的一个附加规范是*RFC 7636 – Proof Key for Code Exchange by OAuth Public Clients
    (PKCE)*，[https://tools.ietf.org/html/rfc7636](https://tools.ietf.org/html/rfc7636)。该规范描述了一个否则不安全的公共客户端（如移动原生应用程序或桌面应用程序）如何通过添加额外的安全层来利用代码授权流程。
- en: Securing access to the discovery service, Netflix Eureka
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护对发现服务Netflix Eureka的访问
- en: Previously, we learned to protect external communication with HTTPS. Now we
    will use HTTP basic authentication to restrict access to the APIs and web pages
    on the discovery server, Netflix Eureka; that is, we will require a user to supply
    a username and password to get access. Changes are required both on the Eureka
    server and in the Eureka clients described as follows.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们学习了如何使用HTTPS保护外部通信。现在我们将使用HTTP基本身份验证来限制对发现服务器Netflix Eureka上的API和网页的访问；也就是说，我们将要求用户提供用户名和密码以获取访问权限。需要在Eureka服务器和以下描述的Eureka客户端上进行更改。
- en: Introducing OpenID Connect
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入OpenID Connect
- en: '**OpenID Connect** (abbreviated to **OIDC**) is, as has already been mentioned,
    an add-on to OAuth 2.0 that enables client applications to verify the identity
    of users. OIDC adds an extra token, an ID token, that the client application gets
    back from the authorization server after a completed grant flow.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenID Connect**（缩写为**OIDC**）是OAuth 2.0的附加功能，允许客户端应用程序验证用户的身份。OIDC在完成授权流程后，授权服务器会向客户端应用程序返回一个额外的令牌，即ID令牌。'
- en: The ID token is encoded as a **JSON Web Token** (**JWT**) and contains a number
    of claims, such as the ID and email address of the user. The ID token is digitally
    signed using JSON web signatures. This makes it possible for a client application
    to trust the information in the ID token by validating the digital signature using
    public keys from the authorization server.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, access tokens can also be encoded and signed in the same way as
    ID tokens, but it is not mandatory according to the specification. Finally, OIDC
    defines a **discovery endpoint**, which is a standardized way to establish URLs
    to important endpoints, such as initiating a grant flow, getting the public keys
    to verify a digitally signed JWT token, and a **user-info endpoint**, which can
    be used to get extra information about an authenticated user given an access token
    for that user.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: For an overview of the available specifications, see [https://openid.net/developers/specs/](https://openid.net/developers/specs/).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our introduction to the OAuth 2.0 and OpenID Connect standards.
    In the next section, we will get a high-level view of how the system landscape
    will be secured.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Securing the system landscape
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To secure the system landscape as described in the introduction to this chapter,
    we will perform the following steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Encrypt external requests and responses to and from our external API using HTTPS
    to protect against eavesdropping
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticate and authorize users and client applications that access our APIs
    using OAuth 2.0 and OpenID Connect
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure access to the discovery service, Netflix Eureka, using HTTP basic authentication
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will only apply HTTPS for external communication to our edge server, using
    plain HTTP for communication inside our system landscape.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: In the chapter on service mesh ([Chapter 18](422649a4-94bc-48ae-b92b-e3894c014962.xhtml),
    *Using a Service Mesh to Improve Observability and Management*) that will appear
    later in this book, we will see how we can get help from a service mesh product
    to automatically provision HTTPS to secure communication inside a system landscape.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: For test purposes, we will add a local OAuth *2.0* authorization server to our
    system landscape. All external communication with the authorization server will
    be routed through the edge server. The edge server and the product-composite service
    will act as OAuth 2.0 resource servers; that is, they will require a valid OAuth
    2.0 access token to allow access.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: To minimize the overhead of validating access tokens, we will assume that they
    are encoded as signed JWT tokens and that the authorization server exposes an
    endpoint that the resource servers can use to access the public keys, also known
    as `jwk-set`, required to validate the signing.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'The system landscape will look like the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c45c1b73-3816-4923-aca4-414cef12a865.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding diagram, we can note that:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS is used for external communication, while plain text HTTP is used inside
    the system landscape.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The local OAuth 2.0 authorization server will be accessed externally through
    the edge server.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both the edge server and the product composite microservice will validate access
    tokens as signed JWT tokens.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The edge server and the product composite microservice will get the authorization
    server's public keys from its `jwk-set` endpoint, and use them to validate the
    signature of the JWT-based access tokens.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that we will focus on securing access to APIs over HTTP, not on covering
    general best practices for securing web applications, for example, managing web
    application security risks pointed out by the *Category:OWASP Top Ten Project*.
    Refer to [https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project](https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project)
    for more information on the OWASP Top Ten.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: With this overview of how the system landscape will be secured, let's start
    by adding a local authorization server to the system landscape.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Adding an authorization server to our system landscape
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向系统架构中添加授权服务器
- en: To be able to run tests locally and fully automated with APIs that are secured
    using OAuth 2.0 and OpenID Connect, we will add an OAuth 2.0-based authorization
    server to our system landscape. Spring Security 5.1 does not, unfortunately, provide
    an authorization server out of the box. But there is a legacy project (currently
    in maintenance mode), Spring Security OAuth, that provides an authorization server that
    we can use.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在本地运行测试并使用OAuth 2.0和OpenID Connect进行完全自动化，我们将向系统架构中添加基于OAuth 2.0的授权服务器。不幸的是，Spring
    Security 5.1没有提供授权服务器。但是有一个遗留项目（目前处于维护模式），Spring Security OAuth，提供了一个我们可以使用的授权服务器。
- en: In fact, in the samples provided by Spring Security 5.1, a project using the
    authorization server from Spring Security OAuth is available. It is configured
    to use JWT-encoded access tokens, and it also exposes an endpoint for a **JSON
    Web Key Set** (**JWKS**) (part of the OpenID Connect Discovery standard), a set
    of keys containing the public keys that can be used by resource servers to verify
    JWT tokens issued by the authorization server.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在Spring Security 5.1提供的示例中，可以使用Spring Security OAuth的授权服务器项目。它配置为使用JWT编码的访问令牌，并公开了一个**JSON
    Web Key Set**（**JWKS**）端点（OpenID Connect Discovery标准的一部分），其中包含可以被资源服务器用来验证授权服务器发放的JWT令牌的公钥集。
- en: So, even if it isn't a full-blown OpenID Connect provider, it is suitable for
    use together with tests that we want to be able to run locally and in a fully
    automated manner.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使它不是一个完整的OpenID Connect提供者，它也适用于我们希望能够在本地和完全自动化方式下运行的测试。
- en: For more details on planned support for OAuth 2.0 in Spring Security, refer
    to [https://spring.io/blog/2018/01/30/next-generation-oauth-2-0-support-with-spring-security](https://spring.io/blog/2018/01/30/next-generation-oauth-2-0-support-with-spring-security).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Spring Security对OAuth 2.0的计划支持的更多详细信息，请参阅[https://spring.io/blog/2018/01/30/next-generation-oauth-2-0-support-with-spring-security](https://spring.io/blog/2018/01/30/next-generation-oauth-2-0-support-with-spring-security)。
- en: The authorization server in the Spring Security sample projects is available
    here: [https://github.com/spring-projects/spring-security/tree/master/samples/boot/oauth2authorizationserver](https://github.com/spring-projects/spring-security/tree/master/samples/boot/oauth2authorizationserver).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security示例项目中的授权服务器在这里可用：[https://github.com/spring-projects/spring-security/tree/master/samples/boot/oauth2authorizationserver](https://github.com/spring-projects/spring-security/tree/master/samples/boot/oauth2authorizationserver)。
- en: The Spring Security sample project configures two OAuth clients, `reader` and
    `writer`, where the `reader` client is granted a read scope, and the `writer`
    client is granted both a read and a write scope. Both clients are configured to
    have the secret set to `secret`; refer to the `configure()` method in the `sample.AuthorizationServerConfiguration` class.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security示例项目配置了两个OAuth客户端，`reader`和`writer`，其中`reader`客户端被授予读取范围，而`writer`客户端被授予读取和写入范围。两个客户端都配置为将密钥设置为`secret`；请参阅`sample.AuthorizationServerConfiguration`类中的`configure()`方法。
- en: 'The following changes have been applied to the sample project:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对示例项目进行了以下更改：
- en: A Eureka client has been added in the same way as for the other microservices.
    See [Chapter 9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml), *Adding Service Discovery
    Using Netflix Eureka and Ribbon;* refer to the *Connecting microservices to a
    Netflix Eureka server* section.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已添加了Eureka客户端，方式与其他微服务相同。参见[第9章](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml)，*使用Netflix
    Eureka和Ribbon添加服务发现*部分。
- en: Spring Boot Actuator has been added to get access to the `health` endpoint.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已添加Spring Boot Actuator以访问`health`端点。
- en: A Dockerfile has been added to be able to run the authorization server as a
    Docker container.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已添加了一个Dockerfile，以便将授权服务器作为Docker容器运行。
- en: The Gradle build file, `spring-security-samples-boot-oauth2authorizationserver.gradle`,
    has been changed to become more like the `build.gradle` files used in the source
    code of this book.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle构建文件`spring-security-samples-boot-oauth2authorizationserver.gradle`已更改，以更像本书源代码中使用的`build.gradle`文件。
- en: 'The configuration in the `sample/AuthorizationServerConfiguration` class has
    been changed as follows:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sample/AuthorizationServerConfiguration`类中的配置已更改如下：'
- en: 'Support has been added for the grant types: `code`, `authorization_code`, and
    `implicit`.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已添加对授权类型`code`、`authorization_code`和`implicit`的支持。
- en: The names of the scopes, `message:read` and `message:write`, have been changed to
    `product:read` and `product:write`.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域的名称`message:read`和`message:write`已更改为`product:read`和`product:write`。
- en: The username of the user registered in the authorization server has been changed
    to `magnus`, with the password `password`; refer to the `userDetailsService()`
    method in the `UserConfig` class (found in the `sample/AuthorizationServerConfiguration.java` file).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在授权服务器中注册的用户的用户名已更改为`magnus`，密码为`password`；请参阅`UserConfig`类中的`userDetailsService()`方法（位于`sample/AuthorizationServerConfiguration.java`文件中）。
- en: The source code for the authorization server is available in `$BOOK_HOME/Chapter11/spring-cloud/authorization-server`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 授权服务器的源代码位于`$BOOK_HOME/Chapter11/spring-cloud/authorization-server`中。
- en: 'To incorporate the authorization server in the system landscape, a number of
    changes have been applied. The authorization server has been added to the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将授权服务器纳入系统架构中，已应用了一些更改。授权服务器已添加到以下位置：
- en: The common build file, `settings.gradle`
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`settings.gradle`是常见的构建文件。'
- en: The three Docker Compose files, `docker-compose*.yml`
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个Docker Compose文件，`docker-compose*.yml`
- en: 'The edge server, `spring-cloud/gateway`:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘服务器`spring-cloud/gateway`：
- en: A health check has been added to `HealthCheckConfiguration`.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已添加健康检查到`HealthCheckConfiguration`。
- en: A route for URIs starting with `/oauth/` has been added.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已添加以`/oauth/`开头的URI的路由。
- en: With an understanding of how a local authorization server is added to the system
    landscape, let's move on and see how we can protect external communication from eavesdropping
    using HTTPS.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了如何将本地授权服务器添加到系统架构中后，让我们继续看看如何使用HTTPS保护外部通信免受窃听。
- en: Protecting external communication with HTTPS
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTTPS保护外部通信
- en: 'In this section, we will learn how to prevent eavesdropping on external communication,
    for example from the internet, via the public APIs exposed by the edge server. We
    will use HTTPS to encrypt communication. To use HTTPS, we need to do the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将学习如何防止通过边缘服务器公开的公共API来自互联网的窃听。我们将使用HTTPS加密通信。要使用HTTPS，我们需要执行以下操作：
- en: '**Create a certificate**: We will create our own self-signed certificate, sufficient
    for development purposes.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建证书**：我们将创建自己的自签名证书，足以用于开发目的。'
- en: '**Configure the edge server**: It has to be configured to accept only HTTPS-based
    external traffic using the certificate.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置边缘服务器**：必须配置为仅接受使用证书的基于HTTPS的外部流量。'
- en: 'The self-signed certificate is created with the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建自签名证书：
- en: '[PRE1]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The source code comes with a sample certificate file, so you don't need to run
    this command to run the following examples.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码附带了一个示例证书文件，因此您无需运行此命令来运行以下示例。
- en: The command will ask for a number of parameters. When asked for a password,
    I entered `password`. For the rest of the parameters, I simply entered an empty
    value to accept the default value. The certificate file created, `edge.p12`, is
    placed in the `gateway` projects folder, `src/main/resources/keystore`. This means
    that the certificate file will be placed in the `.jar` file when it is built and
    will be available on the classpath in runtime at: `keystore/edge.p12`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将要求输入一些参数。当要求输入密码时，我输入了`password`。对于其余的参数，我只是输入了一个空值以接受默认值。创建的证书文件`edge.p12`放置在`gateway`项目文件夹`src/main/resources/keystore`中。这意味着在构建时，证书文件将放置在`.jar`文件中，并且在运行时将在类路径中可用于：`keystore/edge.p12`。
- en: Providing certificates using the classpath is sufficient during development,
    but not applicable to other environments, for example, a production environment.
    The following shows how we can replace this certificate with an external certificate
    at runtime!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，使用类路径提供证书已经足够，但不适用于其他环境，例如生产环境。以下显示了我们如何在运行时用外部证书替换此证书！
- en: 'To configure the edge server to use the certificate and HTTPS, the following
    is added to `application.yml` in the `gateway` project:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置边缘服务器使用证书和HTTPS，需要将以下内容添加到`gateway`项目中的`application.yml`中：
- en: '[PRE2]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following are the explanations for the preceding source code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述源代码的解释：
- en: The path to the certificate is specified in the `server.ssl.key-store` parameter,
    and is set to the `classpath:keystore/edge.p12` value. This means that the certificate
    will be picked up on the classpath from the location, `keystore/edge.p12`.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书的路径在`server.ssl.key-store`参数中指定，并设置为`classpath:keystore/edge.p12`值。这意味着证书将从`keystore/edge.p12`位置的类路径中获取。
- en: The password for the certificate is specified in the `server.ssl.key-store-password` parameter.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书的密码在`server.ssl.key-store-password`参数中指定。
- en: To indicate that the edge server talks HTTPS and not HTTP, we also change the
    port from `8080` to `8443` in the `server.port` parameter.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了指示边缘服务器使用HTTPS而不是HTTP进行通信，我们还将`server.port`参数中的端口从`8080`更改为`8443`。
- en: 'In addition to these changes in the edge server, changes are also required
    in the following files to reflect the changes to the port and HTTP protocol:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了边缘服务器中的这些更改之外，还需要更改以下文件以反映端口和HTTP协议的更改：
- en: The three Docker Compose files, `docker-compose*.yml`
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个Docker Compose文件`docker-compose*.yml`
- en: The test script, `test-em-all.bash`
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试脚本`test-em-all.bash`
- en: Providing certificates using the classpath is as already mentioned previously
    only sufficient during development; let's see how we can replace this certificate
    with an external certificate in runtime!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，使用类路径提供证书已经足够，如前所述；让我们看看如何在运行时用外部证书替换此证书！
- en: Replacing a self-signed certificate in runtime
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时替换自签名证书
- en: Placing a self-signed certificate in the `.jar` file is only useful for development.
    For a working solution in runtime environments, for example, for test or production,
    it must be possible to use certificates signed by authorized **CAs** (short for
    **Certificate Authorities**).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将自签名证书放置在`.jar`文件中仅适用于开发。在运行时环境中，例如测试或生产环境中，必须能够使用由授权的**CA**（证书颁发机构）签名的证书来实现工作解决方案。
- en: It must also be possible to specify the certificates to be used during runtime
    without the need to rebuild the `.jar` files and, when using Docker, the Docker
    image that contains the `.jar` file. When using Docker Compose to manage the Docker
    container, we can map a volume in the Docker container to a certificate that resides
    on the Docker host. We can also set up environment variables for the Docker container
    that points to the new certificate in the Docker volume.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 还必须能够在运行时指定要使用的证书，而无需重新构建`.jar`文件，并且在使用Docker时，包含`.jar`文件的Docker镜像。当使用Docker
    Compose管理Docker容器时，我们可以将Docker容器中的卷映射到驻留在Docker主机上的证书。我们还可以为Docker容器设置环境变量，指向Docker卷中的新证书。
- en: In [Chapter 15](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml), *Introduction to
    Kubernetes*, we will learn about Kubernetes, where we will see more powerful solutions
    for how to handle secrets, such as certificates, that are suitable for running
    Docker containers in a cluster; that is, where containers are scheduled on a group
    of Docker hosts and not on a single Docker host.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第15章](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml)中，*Kubernetes简介*，我们将学习有关Kubernetes的更多强大解决方案，以处理诸如证书之类的秘密，适用于在集群中运行Docker容器的情况；也就是说，容器被调度到一组Docker主机上，而不是单个Docker主机上。
- en: The changes described in this topic have **not** been applied to the source
    code in the book's GitHub repository; that is, you need to make them yourself
    to see them in action!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本主题中描述的更改**尚未**应用于书籍的GitHub存储库中的源代码；也就是说，您需要自己进行更改才能看到它们的效果！
- en: 'To replace the certificate packaged in the `.jar` file, perform the following
    steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换打包在`.jar`文件中的证书，执行以下步骤：
- en: 'Create a second certificate and set the password to `testtest`, when asked
    for it:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Update the Docker Compose file, `docker-compose.yml`, with environment variables
    for the location and password for the new certificate and a volume that maps to
    the folder where the new certificate is placed. The configuration of the edge
    server will look like the following after the change:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If the edge server is up and running, it needs to be restarted with the following
    commands:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `docker-compose restart gateway` command might look like a good candidate
    for restarting the `gateway` service, but it actually does not take changes in
    `docker-compose.yml` into consideration. Hence, it is not a useful command in
    this case.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The new certificate is now in use!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the section on how to protect external communication with HTTPS.
    In the next section we will learn how to secure access to the discovery service,
    Netflix Eureka, using HTTP basic authentication.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Changes in the Eureka server
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To protect the Eureka servers, the following changes have been applied:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'A dependency in `build.gradle` has been added to Spring Security:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Security configuration has been added to the `se.magnus.springcloud.eurekaserver.SecurityConfig` class:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The user is defined as follows:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `username` and `password` are injected into the constructor from the configuration
    file:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'All APIs and web pages are protected using HTTP basic authentication by means
    of the following definition:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Credentials for the user are set up in the configuration file, `application.yml`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, the test class, `se.magnus.springcloud.eurekaserver.EurekaServerApplicationTests`,
    uses the credentials from the configuration file when testing the APIs of the
    Eureka server:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding are the steps required for restricting access to the APIs and
    web pages of the discovery server, Netflix Eureka. It will now use HTTP basic
    authentication and require a user to supply a username and password to get access. In
    the next section, we will learn how to configure Netflix Eureka clients so that
    they pass credentials when accessing the Netflix Eureka server.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Eureka clients
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For Eureka clients, the credentials have to be specified in the connection
    URL for the Eureka server. This is specified in each client''s configuration file,
    `application.yml`, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will see this configuration in use by Netflix Eureka clients when we test
    the secured system landscape in the *Testing with the local authorization server* section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to add credentials when we manually access
    the Netflix Eureka server, either using its API or its Web pages.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Testing the protected Eureka server
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the protected Eureka server is up and running, we have to supply valid
    credentials to be able to access its APIs and web pages.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, asking the Eureka server for registered instances can be done
    by means of the following `curl` command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A sample response is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d901aa7-4296-49ed-ba1d-eae67342dced.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: 'When accessing the web page on `https://localhost:8443/eureka/web`, we first
    have to accept an insecure connection, since our certificate is self-signed, and
    next we have to supply valid credentials, as specified in the preceding configuration
    files:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e043650f-1b2b-479f-a3c6-57ff2aa0d767.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: 'Following a successful login, we will see the familiar web page from the Eureka
    server:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46c6f213-a33d-4599-9fdf-9715968c6537.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: This concludes the section on how to restrict access to the Netflix Eureka server.
    In the next section we will learn how to use OAuth 2.0 and OpenID Connect to authenticate
    and authorize access to APIs.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating and authorizing API access using OAuth 2.0 and OpenID Connect
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the authorization server in place, we can enhance the edge server and
    the `product-composite` service so they become OAuth 2.0 resource servers; that
    is, they require a valid access token to allow access. We will configure the edge
    server to accept any access token it can validate using the signature provided
    by the authorization server. The `product-composite` service will also require
    the access token to contain some OAuth 2.0 scopes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 授权服务器已经就位，我们可以增强边缘服务器和`product-composite`服务，使它们成为OAuth 2.0资源服务器；也就是说，它们需要有效的访问令牌才能允许访问。我们将配置边缘服务器，以接受任何可以使用授权服务器提供的签名验证的访问令牌。`product-composite`服务还将要求访问令牌包含一些OAuth
    2.0范围：
- en: The `product:read` scope will be required for accessing the read-only APIs.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问只读API将需要`product:read`范围。
- en: The `product:write` scope will be required for accessing the create and delete
    APIs.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问创建和删除API将需要`product:write`范围。
- en: We also need to enhance our test script, `test-em-all.bash`, so that it acquires
    access tokens before it runs the tests.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要增强我们的测试脚本`test-em-all.bash`，以便在运行测试之前获取访问令牌。
- en: Changes in both the edge server and the product-composite service
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边缘服务器和`product-composite`服务中的更改
- en: 'The following changes have been applied:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 已经应用了以下更改：
- en: 'Spring Security 5.1 dependencies have been added to `build.gradle` to support
    OAuth 2.0 resource servers:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经添加了Spring Security 5.1依赖项到`build.gradle`，以支持OAuth 2.0资源服务器：
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Security configurations have been added to the `se.magnus.springcloud.gateway.SecurityConfig`
    and `se.magnus.microservices.composite.product.SecurityConfig` classes:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经添加了安全配置到`se.magnus.springcloud.gateway.SecurityConfig`和`se.magnus.microservices.composite.product.SecurityConfig`类中：
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Explanations for the preceding source code are as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前述源代码的解释如下：
- en: '`.pathMatchers("/actuator/**").permitAll()` is used to allow access to URLs
    that should be unprotected, for example, the `actuator` endpoints in this case.
    Refer to the source code for URLs that are treated as unprotected. Be careful
    about which URLs are exposed unprotected. For example, the `actuator` endpoints
    should be protected before going to production:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`.pathMatchers("/actuator/**").permitAll()`来允许访问应该不受保护的URL，例如在这种情况下的`actuator`端点。请参考源代码以了解哪些URL被视为不受保护。要小心哪些URL被暴露为不受保护的。例如，`actuator`端点在投入生产之前应该受到保护：
- en: '`.anyExchange().authenticated()` ensures that the user is authenticated before
    being allowed access to all other URLs.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.anyExchange().authenticated()`确保用户在被允许访问所有其他URL之前已经进行了身份验证。'
- en: '`.oauth2ResourceServer().jwt()` specifies that authentication and authorization
    will be based on a JWT-encoded OAuth 2.0 access token.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.oauth2ResourceServer().jwt()`指定认证和授权将基于JWT编码的OAuth 2.0访问令牌。'
- en: 'The endpoint of the authorization server''s `jwk-set` endpoint has been registered
    in the configuration file, `application.yml`:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权服务器的`jwk-set`端点的端点已在配置文件`application.yml`中注册。
- en: '[PRE16]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With these changes applied to both the edge server and the `product-composite`
    service to make them act as OAuth 2.0 resource servers, we also need to make some
    changes that only apply to the `product-composite` service.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对边缘服务器和`product-composite`服务应用了这些更改，使它们作为OAuth 2.0资源服务器运行，我们还需要进行一些只适用于`product-composite`服务的更改。
- en: Changes in the product-composite service
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`product-composite`服务中的更改'
- en: 'In addition to the common changes applied in the previous section, the following
    changes have also been applied to the `product-composite` service:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前一节中应用的常见更改之外，还对`product-composite`服务应用了以下更改：
- en: 'The security configuration has been refined by requiring OAuth 2.0 scopes in
    the access token in order to allow access:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过要求访问令牌中包含OAuth 2.0范围来完善了安全配置，以允许访问。
- en: '[PRE17]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By convention, OAuth 2.0 scopes should be prefixed with `SCOPE_` when checked
    for authority using Spring Security.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，OAuth 2.0范围在使用Spring Security进行权限检查时应该以`SCOPE_`为前缀。
- en: A method, `logAuthorizationInfo()`, has been added to log relevant parts from
    the JWT-encoded access token upon each call to the API. The access token can be
    acquired using the standard Spring Security, `SecurityContext`, which, in a reactive
    environment, can be acquired using the static helper method, `ReactiveSecurityContextHolder.getContext()`.
    Refer to the `se.magnus.microservices.composite.product.services.ProductCompositeServiceImpl` class for
    details.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经添加了一个方法`logAuthorizationInfo()`，用于在每次调用API时记录JWT编码的访问令牌中的相关部分。可以使用标准的Spring
    Security `SecurityContext`获取访问令牌，在响应式环境中，可以使用静态辅助方法`ReactiveSecurityContextHolder.getContext()`获取。有关详细信息，请参考`se.magnus.microservices.composite.product.services.ProductCompositeServiceImpl`类。
- en: 'The use of OAuth has been disabled when running Spring-based integration tests.
    To prevent the OAuth machinery from kicking in when we are running integration
    tests, we disable it as follows:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行基于Spring的集成测试时，已禁用了OAuth的使用。为了防止在运行集成测试时OAuth机制生效，我们进行了如下禁用：
- en: 'A security configuration, `TestSecurityConfig`, is added to be used during
    tests that permit access to all resources:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一个安全配置`TestSecurityConfig`，用于在测试期间允许访问所有资源：
- en: '[PRE18]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In each Spring integration test class, we configure `TestSecurityConfig` to
    override the existing security configuration with the following:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个Spring集成测试类中，我们配置`TestSecurityConfig`来覆盖现有的安全配置，如下所示：
- en: '[PRE19]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With these changes in place, both the edge server and the `product-composite`
    service can act as OAuth 2.0 resource servers. The last step we need to take to
    introduce the usage of OAuth 2.0 and OpenID Connect is to update the test script
    so it acquires access tokens and uses them when running the tests.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些更改，边缘服务器和`product-composite`服务都可以作为OAuth 2.0资源服务器运行。我们需要采取的最后一步是更新测试脚本，以便在运行测试时获取访问令牌并使用它们。
- en: Changes in the test script
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试脚本中的更改
- en: 'To start with, we need to acquire an access token before we can call any of
    the APIs, except the health API. This is done using the OAuth 2.0 password flow.
    To be able to call the create and delete APIs, we acquire an access token as the
    `writer` client, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To verify that the scope-based authorization works, two tests have been added
    to the test script:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The first test calls an API without supplying an access token. The API is expected
    to return the 401 Unauthorized HTTP status.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other test calls an updating API using the `reader` client, which is only
    granted a read scope. The API is expected to return the 403 Forbidden HTTP status.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the full source code, see `test-em-all.bash`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With the test scripts updated to acquire and use OAuth 2.0 access tokens, we
    are ready to try them out in the next section!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Testing with the local authorization server
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section we will try out the secured system landscape; that is, we will
    test all the security components together. We will use the local authorization
    server to issue access tokens. The following tests will be performed:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: First, we build from source and run the test script to ensure that everything
    fits together.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we learn how to acquire access tokens using OAuth 2.0 grant flows: password,
    implicit, and code grant flows.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we will use access tokens to call APIs. We will also verify that an
    access token issued for a reader client can't be used to call an updating API.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building and running the automated tests
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build and run automated tests, we perform the following steps:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'First, build Docker images with the following commands:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, start the system landscape in Docker and run the usual tests with the
    following command:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note the new negative tests at the end that verify that we get a 401 Unauthorized
    code back when not authenticated, and 403 Forbidden when not authorized.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring access tokens
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we can acquire access tokens using the various grant flows defined by OAuth
    2.0\. We will try out the following grant flows: password, implicit, and code
    grant.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring access tokens using the password grant flow
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get an access token for the `writer` client, that is, with both the `product:read` and `product:write` scopes,
    issue the following command:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The client identifies itself using HTTP basic authentication, passing its `writer`
    client ID, and its secret, `secret`. It sends the credentials of the resource
    owners, that is the end user, using the `username` and `password` parameters.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample response is as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aabd7ac5-4ce6-4f92-ae33-0393200e9116.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: 'Set the value of the `access_token` field in the response as the access token
    in an environment variable:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To get an access token for the `reader` client, that is, with only the `product:read`
    scope, simply replace `writer` with `reader` in the preceding command:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Acquiring access tokens using the implicit grant flow
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To acquire an access token using the implicit grant flow, we need to involve
    a web browser. Open the URL in a web browser that accepts the use of self-signed
    certificates, for example, Chrome. Then perform the following steps:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an access token for the `reader` client open the URL, `https://localhost:8443/oauth/authorize?response_type=token&client_id=reader&redirect_uri=http://my.redirect.uri&scope=product:read&state=48532`.
    When asked to login by the web browser, use the credentials specified in the configuration
    of the authorization server, for example, `magnus` and `password`:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8faa69da-b3b7-4720-90c3-894d5b351ca0.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: 'Next, you will be asked to authorize the `reader` client to call the APIs in
    your name:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/db2552db-ce24-484a-9eae-48e8a08c4e70.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we will get the following response:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fedc6ade-fe6a-4abb-839d-c654eea7bd1f.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
- en: 'This might, at first glance, look a bit disappointing. The URL that the authorization
    server sent back to the web browser is based on the redirect-URI specified by
    the client in the initial request. Copy the URL into a text editor and you will
    find something similar to the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '`http://my.redirect.uri/#access_token=eyJh...C8pw&token_type=bearer&state=48532&expires_in=599999999&jti=8956b38b-36ea-4888-80dc-685b49f20f91`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Great! We can find the access token in the new URL in the `access_token` request
    parameter.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the access token in an environment variable, as shown:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To get an access token for the `writer` client, you can use the following URL:
    `https://localhost:8443/oauth/authorize?response_type=token&client_id=writer&redirect_uri=http://my.redirect.uri&scope=product:read+product:write&state=95372`.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: You are already authenticated, so you do not need to log in again, but you must
    give your consent to the `writer` client.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Note that no client secret is required; that is, the implicit grant flow is
    not very secure.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Any application can claim that it is the `writer` client and can ask for the
    user's consent to use the requested scopes to access APIs in the name of the user,
    so beware!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring access tokens using the code grant flow
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, let's try out the most secure grant flow in OAuth 2.0 – the code grant
    flow!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the code grant flow, things are a bit more complicated in order
    to make the flow more secure. In the first insecure step, we will use the web
    browser to acquire a code that can be used only once, when it is exchanged with
    an access token. The code shall be passed from the web browser to a secure layer,
    for example, server-side code, which can make a new request the authorization
    server again to exchange the code with an access token. In this exchange, the
    server has to supply a client secret to verify its origin.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: To get a code for the `reader` client, use the following URL in the web browser: `https://localhost:8443/oauth/authorize?response_type=code&client_id=reader&redirect_uri=http://my.redirect.uri&scope=product:read&state=35725`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: This time, you will get back a much shorter URL, for example, `http://my.redirect.uri/?code=T2pxvW&state=72489`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract the authorization code from the `code` parameter and define an environment
    variable, `CODE`, with its value:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, pretend you are the backend server that exchanges the authorization code
    with an access token using the following `curl` command:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A sample response is as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b06c2376-bab9-452d-8081-fce44ce0b426.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: 'Finally, save the access token in an environment variable as previously:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To get a code for the `writer` client, use the following URL: `https://localhost:8443/oauth/authorize?response_type=code&client_id=writer&redirect_uri=http://my.redirect.uri&scope=product:read+product:write&state=72489`[.](https://localhost:8443/oauth/authorize?response_type=code&client_id=writer&redirect_uri=http://my.redirect.uri&scope=message:read+message:write&state=72489)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Calling protected APIs using access tokens
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's use the access tokens we have acquired to call the protected APIs!
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'First, call an API to retrieve a composite product without a valid access token:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It should return the following response:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a11b7747-9134-464d-956b-8d9ea3ee632b.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
- en: The error message clearly states that the access token is invalid!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, try using the API to retrieve a composite product using one of the access
    tokens acquired for the `reader` client from the previous section:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we will get the `200 OK` status code and the expected response body will
    be returned:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/35945d10-f681-4265-99d7-8c71e352e889.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
- en: 'If we try to access an updating API, for example, the delete API, with an access
    token acquired for the `reader` client, the call will fail:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It will fail with a response similar to the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41ac8596-5ddd-4a60-a2f4-48f0ec0e69e9.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: If we repeat the call to the delete API, but with an access token acquired for
    the `writer` client, the call will succeed with 200 OK in the response.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: The delete operation should return `200` even if the product with the specified
    product ID does not exist in the underlying database, since the delete operation
    is idempotent, as described in [Chapter 6](6c495e97-f473-4cb1-a404-11fd938f5478.xhtml),
    *Adding Persistence*. Refer to the *Adding new APIs* section.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look into the log output using the `docker-compose logs -f product-composite` command, you
    should be able to find authorization information such as the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa8061ea-8387-4bda-b2bd-ad5bab5f2230.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
- en: This information was extracted by the new method, `logAuthorizationInfo()`,
    in the `product-composite` service from the JWT-encoded access token; that is,
    the `product-composite` service did not need to communicate with the authorization
    server to get this information!
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: With these tests, we have seen how to acquire an access token with the various
    grant flows, that is, password, implicit, and code grant flow. We have also seen
    how scopes can be used to limit what a client can do with a specific access token,
    for example only use is for reading operations.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will replace the local authorization server used in
    this section to an external OpenID Connect provider.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Testing with an OpenID Connect provider – Auth0
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, the OAuth dance works fine with an authorization server we control ourselves.
    But what happens if we replace it with a certified OpenID Connect provider? In
    theory, it should work out of the box. Let's find out, shall we?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'For a list of certified implementations of OpenID Connect, refer to [https://openid.net/developers/certified/](https://openid.net/developers/certified/).
    We will use Auth0, [https://auth0.com/](https://auth0.com/), for our tests with
    an OpenID provider. To be able to use Auth0 instead of our own authorization server,
    we will go through the following topics:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an account with an OAuth client and a user in Auth0
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the changes required to use Auth0 as an OpenID provider and running
    the test script to verify whether it is working
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Acquiring access tokens using the following:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password grant flow
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit grant flow
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization code grant flow
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling protected APIs using the access tokens.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the **user info** endpoint to get more information about a user.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us understand each of them in the following sections.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an account and OAuth 2.0 client in Auth0
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to sign up for a free account in Auth0, configure
    both an OAuth 2.0 client and the `product-composite` API, and finally register
    a user:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Open the URL, [https://auth0.com](https://auth0.com), in your browser.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the SIGN UP button:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sign up with an account of your choice.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a successful sign-up, you will be asked to create a tenant domain.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the name of the tenant of your choice, in my case: `dev-ml.eu.auth0.com`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Fill in information about your account as requested.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Following sign-up, you will be directed to your dashboard. Select the Applications
    tab (on the left) to see the default client application that was created for you
    during the sign-up process.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the Default App to configure it:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the Client ID and Client Secret; you will need them later on.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As Application Type, select Machine to Machine.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As Token Endpoint Authentication Method, select POST.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `http://my.redirect.uri` as the allowed callback URL.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Show Advanced Settings, go to the Grant Types tab, deselect Client
    Credentials, and select the Password box.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on SAVE CHANGES.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now define authorizations for our API:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the APIs tab (on the left) and click on the + CREATE API button.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the API `product-composite`, give it the identifier `https://localhost:8443/product-composite`,
    and click on the CREATE button.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Permissions tab and create two permissions (that is, OAuth scopes)
    for `product:read` and `product:write`.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, create a user:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Users & Roles and -> Users tab (on the left) and then on the +
    CREATE YOUR FIRST USER button.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter an `email` and `password` of your preference and click on the SAVE button.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look for a verification mail from Auth0 in the Inbox for the email address you
    supplied.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, validate your Default Directory setting, used for the password grant
    flow:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on your tenant profile in the upper-right corner and select Settings.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the tab named General, scroll down to the field named Default Directory and
    verify that it contains the `Username-Password-Authentication` value. If not,
    update the field and save the change.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's it! Note that both the default app and the API get a client ID and secret.
    We will use the client ID and secret for the default app; that is, the OAuth client.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With an Auth0 account created and configured we can move on and apply the necessary
    configuration changes in the system landscape.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Applying the necessary changes to use Auth0 as an OpenID provider
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we will learn what configuration changes are required to be
    able to replace the local authorization server with Auth0\. We only need to change
    the configuration for the two services that act as OAuth resource servers, the
    `product-composite`, and the `gateway` services. We also need to change our test
    script a bit, so that it acquires the access tokens from Auth0 instead of from
    our local authorization server. Let's start with the OAuth resource servers, that
    is, the `product-composite` and the `gateway` services.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: The changes described in this topic have **not** been applied to the source
    code in the book's Git repository; that is, you need to make them yourself to
    see them in action!
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Changing the configuration in the OAuth resource servers
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using an OpenID Connect provider, we only have to configure the base URI
    to the standardized discovery endpoint in the OAuth resource servers, that is,
    the `product-composite` and the `gateway` service. Spring Security will use the
    information in the response from the discovery endpoint to configure the resource
    server.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `product-composite` and `gateway` projects, make the following change
    to the `resource/application.yml` file:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'Now find the following property setting:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Replace it with:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Note**: Replace `${TENANT_DOMAIN_NAME}` in the preceding configuration with
    your tenant domain name; in my case, it is `dev-ml.eu.auth0.com`, and do not forget
    the trailing `/`!'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are curious, you can see what''s in the discovery document by running
    the following command:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '`curl https://${TENANT_DOMAIN_NAME}/.well-known/openid-configuration -s | jq`'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'Rebuild the `product-composite` and `gateway` services as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With the `product-composite` and the `gateway` service updated, we can move
    on and also update the test script.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Changing the test script so it acquires access tokens from Auth0
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We also need to update the test script so it acquires access tokens from the
    Auth0 OIDC provider. This is done by performing the following changes in `test-em-all.bash`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following command:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Replace it with this command:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, replace `${TENANT_DOMAIN_NAME}`, `${USER_EMAIL}`, `${USER_PASSWORD}`,
    `${CLIENT_ID}`, and `${CLIENT_SECRET}` in the preceding command with the values
    you collected during the registration process in Auth0, as described previously.
    Then, take the following command:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Replace it with this command:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Apply the preceding changes to the command. Also note that we only require the
    `product:read` scope and not the `product:write` scope. This is to simulate a
    client with read-only access.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Now access tokens are issued by Auth0 instead of our local authorization server,
    and our API implementations can verify that the access tokens (have been correctly
    signed by Auth0 and have not expired), using information from Auth0's discovery
    service flagged in the `application.yml` files. The API implementations can, as
    before, use the scopes in the access tokens to authorize the client to perform
    the call to the API, or not.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Now we have all the required changes in place, let's run some tests to verify
    that we can acquire access tokens from Auth0.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Running the test script with Auth0 as the OpenID Connect provider
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we are ready to give Auth0 a try!
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the usual tests against Auth0 with the following command:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the logs (using the `docker-compose logs -f product-composite` command), you
    will be able to find authorization information from the access tokens issued by
    Auth0:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'From calls using an access token with both the `product:read` and `product:write`
    scopes, we will see that both scopes are listed as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c98cb07-9e00-4611-8c25-0db0aa384d1d.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
- en: 'From calls using an access token with only the `product:read` scope, we will
    see that only that scope is listed as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/568e2fc6-35fa-43e1-8247-1d2b9cad167f.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
- en: As we can see from the log output, we now get information regarding the intended
    audience for this access token. To strengthen security, we could add a test to
    our service that verifies that its URL, `https://localhost:8443/product-composite`
    in this case, is part of the audience list. This would prevent the situation where
    someone tries to use an access token issued for another purpose to get access
    to our API.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: With the automated tests working together with Auth0, we can move on and learn
    how to acquire access tokens using the different types of grant flow. Let's start
    with the password grant flow.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring access tokens using the password grant flow
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we will learn how to acquire an access token from Auth0 using
    the password grant flow.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to acquire an access token from Auth0 yourself, you can do so by
    running the following command:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Following the instruction in the *Calling protected APIs using the access tokens* section, you
    should be able to call the APIs using the acquired access token. The next grant
    flow we'll try out is the implicit grant flow.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring access tokens using the implicit grant flow
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to acquire an access token from Auth0 using
    the implicit grant flow.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to try out the more involved implicit grant flow, you can open
    the following URL in a web browser:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Replace `${TENANT_DOMAIN_NAME}` and `${CLIENT_ID}` in the preceding URL with
    the tenant domain name and client ID you collected during the registration process
    in Auth0 as described previously.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following steps:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'Auth0 should present the following login screen:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/51fa7e05-b536-4ae8-8108-403cb016fa7f.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
- en: 'Following a successful login, Auth0 will ask you to give the client application
    your consent:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/88af32b9-cb29-4cea-afba-1e337b85d14f.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
- en: 'The access token is now in the URL in the browser, just like when we tried
    out the implicit flow in our local authorization server:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2124688f-d39d-431b-982b-6f5f786ac8d7.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
- en: To get an access token that corresponds to the `reader` client, remove the `product:write` scope from
    the preceding URL that we used to initiate the implicit grant flow.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to acquire an access token using the implicit grant flow,
    we can move on to the third and last grant flow that we will try out, the authorization
    code grant flow.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring access tokens using the authorization code grant flow
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we come to the most secure grant flow – the authorization code grant
    flow. We will follow the same procedure as with the local authorization server;
    that is, we first acquire code and then exchange it for an access token. Get the
    code by opening the following URL in a web browser, as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Replace `${TENANT_DOMAIN_NAME}` and `${CLIENT_ID}` in the preceding URL with
    the tenant domain name and client ID you collected during the registration process
    in Auth0 as described previously.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'Expect a redirect attempt in the web browser to a URL as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Extract the code and run the following command to get the access token:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Replace `${TENANT_DOMAIN_NAME}`, `${CLIENT_ID}`, `${CLIENT_SECRET}`, and `${CODE}` in
    the preceding URL with the tenant domain name, client ID, and the client code
    you collected during the registration process in Auth0 as described previously.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to acquire access tokens using all three types
    of grant flows, we are ready to try calling the external API using an access token
    acquired from Auth0 in the next section.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Calling protected APIs using the Auth0 access tokens
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how we can use an access token acquired from Auth0
    to call the external API.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: We can use access tokens issued by Auth0 to call our APIs  just like when we
    used access tokens issued by our local authorization server.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'For a read-only API, execute the following command:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For an updating API, execute the following command:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Since we have requested both scopes, `product:read` and `product:write`, both
    the preceding API calls are expected to return 200 OK.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Getting extra information about the user
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see in the log output, the ID of the subject, that is, the user,
    is a bit cryptic, for example, `auth0|5ca0b73c97f31e11bc85a5e6`.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want your API implementation to know a bit more about the user, it can
    call Auth0''s `userinfo_endpoint` as described in the response to the discovery
    request made previously:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Replace `${TENANT_DOMAIN_NAME}` in the preceding command with the tenant domain
    name you collected during the registration process in Auth0 as described previously.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample response is as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85766cca-2c09-4b6a-9ead-a450d32154af.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
- en: This endpoint can also be used to verify that the user hasn't revoked the access
    token in Auth0.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap up the tests by shutting down the system landscape with the following
    command:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This concludes the section where we have learned how to replace the local OAuth
    2.0 Authorization server, only used for tests, with an external alternative. We
    have also seen how to reconfigure the microservice landscape to validate access
    tokens using an external OIDC provider.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to use Spring Security to protect our APIs.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how easy it is to enable HTTPS to prevent eavesdropping by third
    parties using Spring Security. With Spring Security, we have also learned that
    it is straightforward to restrict access and the discovery server, Netflix Eureka,
    using HTTP basic authentication. Finally, we have seen how we can use Spring Security
    to simplify the use of OAuth 2.0 and OpenID Connect to allow third-party client
    applications to access our APIs in the name of a user, but without requiring that
    the user share credentials with the client application. We have learned both how
    to set up a local OAuth 2.0 authorization server based on Spring Security and
    also how to change the configuration so that an external OpenID Connect provider,
    Auth0, can be used instead.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: One concern, however, is how to manage the configuration required. Many small
    pieces of configuration must be set up for the microservices involved and the
    configuration must be synchronized to match. Added to the scattered configuration
    is the fact that some of the configuration contains sensitive information, such
    as credentials or certificates. It seems like we need a better way to handle the
    configuration for a number of cooperating microservices and also a solution for
    how to handle sensitive parts of the configuration.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the Spring Cloud Configuration server and
    see how it can be used to handle these types of requirement.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the benefits and shortcomings of using self-signed certificates?
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of OAuth 2.0 authorization codes?
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of OAuth 2.0 scopes?
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does it mean when a token is a JWT token?
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we trust the information that is stored in a JWT token?
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it suitable to use the OAuth 2.0 authorization code grant flow with a native
    mobile app?
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does OpenID Connect add to OAuth 2.0?
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
