- en: Day 03 - What&#x27;s New in C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Today, we will learn a very recent and newly released feature with the current
    version of the C# language, that is, C# 7.0 (this is the most recent adaptation
    amid the review of this book). Some of these elements are altogether new and others
    were present in past adaptations and have been upgraded in the current version
    of the language. C# 7.0 will change the game with a lot of new features to the
    table. Some of these elements, such as tuples, are augmentations of officially
    accessible ideas while others are completely new. Here are the fundamental elements
    we will learn about on Day 03:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Tuples and deconstruction
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Literal improvements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Async Main
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default Expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infer Tuple Names
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuples and deconstruction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tuples have not been newly introduced in the current version but were introduced
    with the .NET 4.0 release. In the present release, they have been improved.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tuples are there at whatever point a particular case needs to return multiple
    values from a method. For instance, let's say we have to find odd and even numbers
    from a given number series.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Tuples are an unchanging information esteem that hold related data. Tuples used
    to aggregate together related data, for example, such that a person's name, age,
    gender and whatever you want data as an information.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: To complete this, our method should return or provide us the result with a number
    and saying whether this is an odd number or even number. For a method that will
    return these multiple values, we could use custom datatypes, dynamic return types,
    or out parameters, which sometimes will create confusion for a developer.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'To use tuples, you need to add the NuGet package:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.nuget.org/packages/System.ValueTuple/](https://www.nuget.org/packages/System.ValueTuple/)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: For this problem, we have a tuple object and in C# 7.0 we have two different
    things, tuple types and tuple literals, to return multiple values from a method.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us discuss tuples in detail using a code example. Consider the following
    code snippet:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code snippet, we added more descriptive names to our tuple.
    Now the caller method can directly use these names, as shown in the following
    code snippet:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By adding some descriptive names to the tuple, we can easily identify and use
    items/elements of the tuple in the caller method.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The System.ValueTuple struct
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tuples in C# 7.0 require the NuGet package `System.ValueType`. This is nothing
    but a struct by design. This contains a few static and public methods to work
    undeneath:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '**CompareTo(ValueTuple)**: A public method that compares to the `ValueTuple`
    instance. The method returns 0 if the comparison is successful, else it returns
    1.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here we have two methods that show the power of the `CompareTo` method:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is the calling code snippet to get the results from preceding code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we execute the preceding code, it will provide the output as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00044.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: '**Equals(Object)**: A public method that returns true/false, stating whether
    the `TupleValue` instance is equal to the provided object. It returns true if
    successful.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the implementation:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the calling method code snippet:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, the output is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00045.gif)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: '**Equals(ValueTuple)**: A public method that always returns true and it''s
    by design. It is designed in this way because `ValueTuple` is a zero-element tuple,
    hence when two ValueTuples perform equally having no element will always return
    zero.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GetHashCode()**: A public method that returns the hash code of the object.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GetType()**: A public method that provides the specific type of the current
    instance.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ToString()**: A public method that is a string representation of the `ValueTuple`
    instance. However, as per design, it always returns zero.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Create()**: A static method that creates a new `ValueTuple` (0 tuple). We
    can create a 0 tuple as follows:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Create<T1>(T1) ... Create<T1, T2, T3, T4, T5, T6, T7, T8>(T1, T2, T3, T4, T5, T6, T7, T8)**:
    All are static methods which create Value Tuples with 1-components (singleton)
    to 8-components (octuple).'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See the following code snippet showing singleton and octuple examples:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You will need to update the NuGet package to Microsoft.Net.Compilers to 2.0
    preview if you get compilation warnings. To do so, just select preview and search
    Microsoft.Net.Compilers to 2.0 from NuGet Package Manager [[https://www.nuget.org/packages/Microsoft.Net.Compilers/](https://www.nuget.org/packages/Microsoft.Net.Compilers/)].
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Deconstruction
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, we saw that multiple return values with the use of
    `ValueTuple` are accessible with its items/element. Now think of a scenario where
    we want to directly assign these element values to variables. Here, deconstruction
    helps us. Deconstruction is a way in which we can unpackage the tuple that is
    returned by a method.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'There are mainly two ways to deconstruct a tuple:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicitly typed declaration: We explicitly declare the type of each field.
    Let''s see the following code example:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Implicitly typed declaration: We implicitly declare the type of each field.
    Let''s see the following code example:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can also deconstruct UserDefined/Custom types by implementing deconstruction
    using out parameters; see the following code-example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, the deconstruct method enables assignment from a `UserDefinedModel`
    to one int and one string, which represent the properties `number` and `OddEven`
    respectively.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Tuple – important points to remember
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section, we discussed tuples and noticed how they help us
    in scenarios where we need multiple values and complex data values (besides custom
    types). Here are the important points that we should remember while working with
    tuples:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: To work with tuples, we need the NuGet package `System.ValueTuple`.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ValueTuple` (`System.ValueTuple`) is a struct instead of a class by design.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ValueTuple` implements `IEquatable<ValueTuple>, IStructuralEquatable, IStructuralComparable,
    IComparable, IComparable<ValueTuple>` interfaces.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ValueTuples are mutable.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ValueTuples are flexible data containers and can be either unnamed or named:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unnamed**: When we do not provide any name for a field, these are unnamed
    tuples and accessible using the default fields `Item1`, `Item2`, and so on:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Named**: When we explicitly provide some descriptive name to fields:'
  id: totrans-70
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Assignment: When we assign one tuple to another, only values get assigned and
    not field names:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of the preceding code-snippet would be as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00046.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: In the preceding code-snippet, we can see that the output of an assigned tuple
    is the same with an assigned tuple.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a general way, pattern matching is a way to compare contents in predefined
    formats in an expression. The format is nothing but a combination of different
    matches.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: In C# 7.0, pattern matching is a feature. With the use of this feature, we can
    implement method dispatch on properties other than the type of an object.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching supports various expressions; let's discuss these with code-examples.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Patterns can be constant patterns: Type patterns or Var patterns.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: is expression
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `is` expression enables the inspection of an object and its properties
    and determines whether it satisfies the pattern:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code is not showing any fancy stuff and informs us whether the
    input parameter is a specific type and a vowel or a consonant. You can see here
    we simply use the `is` operator, that tells whether the object is of the same
    type or not.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The `is` operator ([https://goo.gl/79sLW5](https://goo.gl/79sLW5)) checks the
    object, and if the object is of the same type, it returns true; if not, it returns
    false.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, while we are checking object for string, we need to
    explicitly cast object to string and then pass this to our utility method, `IsVowel()`.
    In the preceding code, we are doing two things: the first is checking the type
    of the incoming parameter and if the type is the same then we are casting it to
    the desired type and performing actions as per our case. Sometimes this creates
    confusion when we need to write more complex logic with expressions.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'C# 7.0 resolves this subtly to make our expression simpler. Now we can directly
    declare a variable while checking the type in an expression; see the following
    code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, which is updated where the `is` expression both tests
    the variable and assigns it to a new variable of the desired type. With this change,
    there is no need to explicitly cast the type `((string) character)` as we were
    doing in the previous code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us add one more condition to the preceding code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, we are checking *object* for `int`, which is a *struct*.
    The preceding condition works perfectly fine and produces the expected results.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our complete code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `is` expression works perfectly fine with both value types as well as reference
    types.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code-example, the variables `str` and `number` are only assigned
    when the respective expression matches results as `true`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: switch statement
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already discussed the `switch` statement in Day 02\. The `switch` pattern
    helps a great deal as it uses any datatype for matching additionally `case` provides
    a way so, it matched the condition.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: The `match` expression is the same but in C# 7.0, this feature has been enhanced
    in three different ways. Let us understand them using code examples.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: constant pattern
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In earlier versions of C#, the `switch` statement only supported the *constant*
    pattern, where we evaluate some variable in the `switch` and then make a conditional
    call as per the constant case. See the following code example, where we are trying
    to check whether `inputChar` is of a specific length, which is computed in `switch`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, our main task is to check whether `inputChar` is a vowel
    or consonant, and what we are doing here is we are first evaluating the length
    of the `inputChar` and then performing operations as required, which leads to
    more work/code for more complex conditions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: type pattern
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the introduction of the *type* pattern, we can overcome the problem we
    were facing with the *constant* pattern (in the previous section). Consider the
    following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, now it's easy to perform the operation as per type pattern.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: When clause in case expression
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the introduction of a `when` clause in `case` expressions, you can do
    special things in the expression; see the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, `case` with `when` makes sure that it will perform the
    operation only if `listObjects` has some value.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The `case` statement requires that each `case` ends with a `break`, `return`,
    or `goto`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Local functions
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Local functions can be achievable using function and action using anonymous
    methods in prior versions, but there are still a few limitations:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ref` and `out` parameters'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local functions are featured to declare within the block scope. These functions
    are very powerful and have the same capability as any other normal function but
    with the difference that they are scoped within the block these were declared.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code-example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The method `FindOddEvenBySingleNumber()` in the preceding code is simply returning
    a number as *Odd* or *Even* for numbers greater than 1\. This uses a private method,
    `IsOddNumber()`, as shown here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The method `IsOddNumber()` is a private method and is available within the class
    it declared. Hence, its scope is within a class and not within a code block.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see the following code-example of a local function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, the local function `IsOddNumber()` is performing the
    same action as in the case of the `private` method in the previous section. But
    here, the scope of `IsOddNumber()` is within the method `FindOddEvenBySingleNumberUsingLocalFunction()`.
    Hence, it would not be available outside this code block.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Literal improvements
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to literals, we can think about the declaration of various variables
    constant, which are sometimes the life of a method as these would be very important
    for a method or to take any decision. And it leads to wrong decisions with the
    misreading of a numeric constant. To overcome this confusion, C# 7.0 introduced
    two new features, binary literals and digit separators.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Binary literals
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Binary digits are very important for performing complex operations. A constant
    of a binary digit can be declared as *0b<binaryvalue>*, where 0b tells us that
    this is a binary literal and binary values is the value of your decimal digit.
    Here are a few examples:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Digit separator
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the introduction of digit separators, we can easily read long numeric,
    binary digits. Digit separators can be used with both numeric and binary digits.
    For binary digits, the digit separator, that is, underscore (`_`), applies on
    bit pattern, and for numeric, it can appear anywhere but it is good to make 1,000
    the separator. Take a look at the following examples:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The digit separator can be used with decimal, float, and double types as well.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '<p>Followings are the new features shipped with Visual Studio 2017 update 3
    as a language features of C# 7.1, we will discuss all the features as per: [https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md](https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information new release of Visual Stuio 2017 refer to: [https://www.visualstudio.com/en-us/news/releasenotes/vs2017-relnotes](https://www.visualstudio.com/en-us/news/releasenotes/vs2017-relnotes)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are looking how to set up your existing project or new project that
    is using C# 7.0 – then you need not to worry, Visual Studio 2017 Update 3 is there
    to assist you. Whenever you start using new feature of C# 7.1 – you need to follow
    these steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio will warn about existing version support and suggest to upgrade
    your project if you want to use new feature of C# 7.1.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just click on yellow bulb and select best option fits for your requirement and
    you’re good to go with new C# 7.1.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Following image tells you two-steps to get ready with C# 7.1:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00047.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: 'Let us start discussion on new features of Language C# 7.1:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Async Main
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A new feature of language C# 7.1 that enables entry-point that is, `Main` of
    an application. Async main enables `main` method to be awaitable that mean `Main`
    method is now asynchronous to get `Task` or `Task<int>`. With this feature followings
    are valid entry-points:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Restrictions while using new signatures
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use these new signature entry-points and these marked as valid if no
    overload of previous signature is present that means if you are using an existing
    entry-point.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is not mandatory to mark your entry-point as async that means you can
    still use the existing async entry-point:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There may be more usage of the entry-point that you can incorporate in the
    application – refer to official document of this feature: [https://github.com/dotnet/csharplang/blob/master/proposals/async-main.md](https://github.com/dotnet/csharplang/blob/master/proposals/async-main.md)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Default expressions
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A new expression introduced in C# 7.1 that is default literal. With the introduction
    of this new literal, the expression can be implicitly converted to any type and
    produces result as default value of the type.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: New default literal is different than old `default(T)`. Earlier `default` convert
    the target type of `T` but newer one can convert any type.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code when we are writing `int thisIsANewDefault = default;`
    an expression that is valid in C# 7.1 and it implicitly convert the expression
    to type int and assign a default value that is 0 (zero) to `thisIsANewDefault`.
    The notable point here is that default literal implicitly detect the type of `thisIsANewDefault`
    and set the value. On the other hand, we need to explicitly tell the target type
    to set the default value in expression `var thisIsAnOlderDefault = default(int);`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code generates following output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00048.gif)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: 'There are multiple implementations of new default literal so, you can use the
    same with following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Member variables
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'New `default` expression can be applied to assign default values to variables,
    followings are the various ways:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Constants
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to variables, with the use of default we can declare constants, followings
    are the various ways:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'There are more scenarios where you can use this new default literal viz. optional
    parameter in method that is, For more information, refer to: [https://github.com/dotnet/csharplang/blob/master/meetings/2017/LDM-2017-03-07.md](https://github.com/dotnet/csharplang/blob/master/meetings/2017/LDM-2017-03-07.md)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Infer tuple names
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the introduction of this new feature we you do not require to explicitly
    declare the tuple candidate names. We discussed Tuples in previous section *Tuples
    and Deconstructions*. Infer tuple names feature is an extended to the tuple values
    introduced in C# 7.0.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with this new feature, you require updated NuGet package of `ValueTuple`
    that you’ve installed in previous section *Tuple*. To update the NuGet package,
    go to *NuGet Package manager* and click on Update tab and then click update latest
    version. Following screenshot provides the complete information:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00049.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: 'Following code-snippet shows, various ways to declare the tuple:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding code is self-explanatory, Tuple `noNamed` does not have any member
    name and can be accessed using `item1` and `item2`. Similarly, in Tuple `IgnoredName`
    all defined member names will be ignored as declaration is not defined with a
    member name. Following code-snippet tells the complete story of how we can access
    various tuples:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding code produces the following output:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00050.gif)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: 'There is more variation where you can use this new feature for more info, refer:
    [https://github.com/dotnet/roslyn/blob/master/docs/features/tuples.md](https://github.com/dotnet/roslyn/blob/master/docs/features/tuples.md)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Other features supposed to release
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There would be more features with the final release of programming language
    C# 7.1 in addition to previous, following are the features that encountered a
    bug or partially implemented as on date.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Pattern-matching with generics
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pattern-matching with generic is proposed here: [https://github.com/dotnet/csharplang/blob/master/proposals/generics-pattern-match.md](https://github.com/dotnet/csharplang/blob/master/proposals/generics-pattern-match.md)
    as new feature of C# 7.1 that encountered a bug and can be seen here: [https://github.com/dotnet/roslyn/issues/16195](https://github.com/dotnet/roslyn/issues/16195)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this feature would be based on `as` operator as detailed
    here: [https://github.com/dotnet/csharplang/blob/master/spec/expressions.md#the-as-operator](https://github.com/dotnet/csharplang/blob/master/spec/expressions.md#the-as-operator)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Reference assemblies
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reference assemblies feature is yet to be incorporated within IDE, you can
    refer: [https://github.com/dotnet/roslyn/blob/master/docs/features/refout.md](https://github.com/dotnet/roslyn/blob/master/docs/features/refout.md)
    here for more details.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on exercises
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions, which cover the concepts of today''s learning:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: What are `ValueTuple` types?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ValueTuples are mutable; prove with an example.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `ValueTuple` of 10 elements.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a user-defined class employee as follows and then write a program to
    deconstruct user-defined types:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个如下所示的用户定义类employee，然后编写一个程序来解构用户定义的类型：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Create a class of various constants using digit separators and implement these
    constants to a function `ToDecimal()` and `ToBinary()`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个使用数字分隔符的各种常量的类，并将这些常量实现到函数`ToDecimal()`和`ToBinary()`中。
- en: What are local functions? How are they different from private functions?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地函数是什么？它们与私有函数有什么不同？
- en: Rewrite the `OddEven` program using generic local functions.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用通用本地函数重写`OddEven`程序。
- en: Rewrite the `OddEven` program using the type pattern in `switch` case.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`switch`语句中的类型模式重写`OddEven`程序。
- en: Write a program to find out `OddEven` with the utilization of inferred Tuple
    names feature of language C# 7.1.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，利用C# 7.1语言的推断元组名称特性来找出`OddEven`。
- en: What is default expression (C# 7.1), elaborate with the help of program?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认表达式（C# 7.1）是什么，通过程序详细说明？
- en: Revisiting Day 03
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重温第03天
- en: Today, we have discussed all the new features introduced in C# 7.0 with code
    examples. We also understood the important points and usage of these features.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们讨论了C# 7.0中引入的所有新功能，并提供了代码示例。我们还了解了这些功能的重要点和用法。
- en: We discussed how ValueTuples help us gather the data information and the cases
    where we are expecting multiple outputs from a method. One of the good points
    of `ValueTuple` is that this is a mutable and `ValueType`. There are a few `public`
    and `static` methods provided by `System.ValueTuple` and we can achieve many complex
    scenarios with the use of these.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了ValueTuples如何帮助我们收集数据信息以及我们期望从方法中获得多个输出的情况。`ValueTuple`的一个优点是它是可变的和`ValueType`。`System.ValueTuple`提供了一些`public`和`static`方法，我们可以利用这些方法实现许多复杂的场景。
- en: Then we came to know the advantage and power of pattern matching; this helps
    the coder perform various complex conditional scenarios which were not possible
    in prior versions of the C# language. The type pattern and the `when` clause in
    `case` statements makes this feature superb.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们了解了模式匹配的优势和能力；这有助于编码人员执行各种复杂的条件场景，这在C#语言的先前版本中是不可能的。类型模式和`case`语句中的`when`子句使这个功能非常出色。
- en: Local functions are one of the most important features introduced in C# 7.0\.
    They help a lot in a scenario, where we need to make our code symmetric, so you
    can read code perfectly and when we do not require the method outside, or we do
    not need to reuse this operation which is required within a block scope.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本地函数是C# 7.0中引入的最重要的功能之一。它们在需要使我们的代码对称的场景中非常有帮助，这样你就可以完美地阅读代码，当我们不需要在方法外部使用方法，或者我们不需要重用在块范围内需要的操作时。
- en: With the literal improvements, now we can declare binary numbers as constants
    and use them as we use other variables. The capability of adding the digit separator
    underscore (`_`) made this feature more useful.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 随着字面改进，现在我们可以将二进制数字声明为常量，并像使用其他变量一样使用它们。添加数字分隔符下划线（`_`）的能力使这个功能更加有用。
- en: Finally, we have gone through the new features released for language C# 7.1
    as a part of Visual Studio update 3.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经了解了作为Visual Studio更新3的一部分发布的C# 7.1语言的新功能。
- en: 'Earlier, in plan there were more features which were planned to release but
    the final release came with preceding new features. Next release is in plan and
    there are more robust features which are yet to come. You can watch the plan and
    next release feature list here: [https://github.com/dotnet/csharplang/tree/master/proposals](https://github.com/dotnet/csharplang/tree/master/proposals).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，计划中有更多的功能计划发布，但最终发布的版本却包含了之前的新功能。下一个版本已经计划中，还有更强大的功能尚未推出。您可以在这里查看计划和下一个版本的功能列表：[https://github.com/dotnet/csharplang/tree/master/proposals](https://github.com/dotnet/csharplang/tree/master/proposals)。
