- en: Day 03 - What&#x27;s New in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Today, we will learn a very recent and newly released feature with the current
    version of the C# language, that is, C# 7.0 (this is the most recent adaptation
    amid the review of this book). Some of these elements are altogether new and others
    were present in past adaptations and have been upgraded in the current version
    of the language. C# 7.0 will change the game with a lot of new features to the
    table. Some of these elements, such as tuples, are augmentations of officially
    accessible ideas while others are completely new. Here are the fundamental elements
    we will learn about on Day 03:'
  prefs: []
  type: TYPE_NORMAL
- en: Tuples and deconstruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Literal improvements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Async Main
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default Expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infer Tuple Names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuples and deconstruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tuples have not been newly introduced in the current version but were introduced
    with the .NET 4.0 release. In the present release, they have been improved.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tuples are there at whatever point a particular case needs to return multiple
    values from a method. For instance, let's say we have to find odd and even numbers
    from a given number series.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples are an unchanging information esteem that hold related data. Tuples used
    to aggregate together related data, for example, such that a person's name, age,
    gender and whatever you want data as an information.
  prefs: []
  type: TYPE_NORMAL
- en: To complete this, our method should return or provide us the result with a number
    and saying whether this is an odd number or even number. For a method that will
    return these multiple values, we could use custom datatypes, dynamic return types,
    or out parameters, which sometimes will create confusion for a developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use tuples, you need to add the NuGet package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.nuget.org/packages/System.ValueTuple/](https://www.nuget.org/packages/System.ValueTuple/)'
  prefs: []
  type: TYPE_NORMAL
- en: For this problem, we have a tuple object and in C# 7.0 we have two different
    things, tuple types and tuple literals, to return multiple values from a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us discuss tuples in detail using a code example. Consider the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we added more descriptive names to our tuple.
    Now the caller method can directly use these names, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By adding some descriptive names to the tuple, we can easily identify and use
    items/elements of the tuple in the caller method.
  prefs: []
  type: TYPE_NORMAL
- en: The System.ValueTuple struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tuples in C# 7.0 require the NuGet package `System.ValueType`. This is nothing
    but a struct by design. This contains a few static and public methods to work
    undeneath:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CompareTo(ValueTuple)**: A public method that compares to the `ValueTuple`
    instance. The method returns 0 if the comparison is successful, else it returns
    1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here we have two methods that show the power of the `CompareTo` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the calling code snippet to get the results from preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the preceding code, it will provide the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Equals(Object)**: A public method that returns true/false, stating whether
    the `TupleValue` instance is equal to the provided object. It returns true if
    successful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the implementation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the calling method code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00045.gif)'
  prefs: []
  type: TYPE_IMG
- en: '**Equals(ValueTuple)**: A public method that always returns true and it''s
    by design. It is designed in this way because `ValueTuple` is a zero-element tuple,
    hence when two ValueTuples perform equally having no element will always return
    zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GetHashCode()**: A public method that returns the hash code of the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GetType()**: A public method that provides the specific type of the current
    instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ToString()**: A public method that is a string representation of the `ValueTuple`
    instance. However, as per design, it always returns zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Create()**: A static method that creates a new `ValueTuple` (0 tuple). We
    can create a 0 tuple as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Create<T1>(T1) ... Create<T1, T2, T3, T4, T5, T6, T7, T8>(T1, T2, T3, T4, T5, T6, T7, T8)**:
    All are static methods which create Value Tuples with 1-components (singleton)
    to 8-components (octuple).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See the following code snippet showing singleton and octuple examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You will need to update the NuGet package to Microsoft.Net.Compilers to 2.0
    preview if you get compilation warnings. To do so, just select preview and search
    Microsoft.Net.Compilers to 2.0 from NuGet Package Manager [[https://www.nuget.org/packages/Microsoft.Net.Compilers/](https://www.nuget.org/packages/Microsoft.Net.Compilers/)].
  prefs: []
  type: TYPE_NORMAL
- en: Deconstruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, we saw that multiple return values with the use of
    `ValueTuple` are accessible with its items/element. Now think of a scenario where
    we want to directly assign these element values to variables. Here, deconstruction
    helps us. Deconstruction is a way in which we can unpackage the tuple that is
    returned by a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are mainly two ways to deconstruct a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicitly typed declaration: We explicitly declare the type of each field.
    Let''s see the following code example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Implicitly typed declaration: We implicitly declare the type of each field.
    Let''s see the following code example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also deconstruct UserDefined/Custom types by implementing deconstruction
    using out parameters; see the following code-example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the deconstruct method enables assignment from a `UserDefinedModel`
    to one int and one string, which represent the properties `number` and `OddEven`
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Tuple – important points to remember
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section, we discussed tuples and noticed how they help us
    in scenarios where we need multiple values and complex data values (besides custom
    types). Here are the important points that we should remember while working with
    tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: To work with tuples, we need the NuGet package `System.ValueTuple`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ValueTuple` (`System.ValueTuple`) is a struct instead of a class by design.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ValueTuple` implements `IEquatable<ValueTuple>, IStructuralEquatable, IStructuralComparable,
    IComparable, IComparable<ValueTuple>` interfaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ValueTuples are mutable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ValueTuples are flexible data containers and can be either unnamed or named:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unnamed**: When we do not provide any name for a field, these are unnamed
    tuples and accessible using the default fields `Item1`, `Item2`, and so on:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Named**: When we explicitly provide some descriptive name to fields:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Assignment: When we assign one tuple to another, only values get assigned and
    not field names:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code-snippet would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding code-snippet, we can see that the output of an assigned tuple
    is the same with an assigned tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a general way, pattern matching is a way to compare contents in predefined
    formats in an expression. The format is nothing but a combination of different
    matches.
  prefs: []
  type: TYPE_NORMAL
- en: In C# 7.0, pattern matching is a feature. With the use of this feature, we can
    implement method dispatch on properties other than the type of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching supports various expressions; let's discuss these with code-examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Patterns can be constant patterns: Type patterns or Var patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: is expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `is` expression enables the inspection of an object and its properties
    and determines whether it satisfies the pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is not showing any fancy stuff and informs us whether the
    input parameter is a specific type and a vowel or a consonant. You can see here
    we simply use the `is` operator, that tells whether the object is of the same
    type or not.
  prefs: []
  type: TYPE_NORMAL
- en: The `is` operator ([https://goo.gl/79sLW5](https://goo.gl/79sLW5)) checks the
    object, and if the object is of the same type, it returns true; if not, it returns
    false.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, while we are checking object for string, we need to
    explicitly cast object to string and then pass this to our utility method, `IsVowel()`.
    In the preceding code, we are doing two things: the first is checking the type
    of the incoming parameter and if the type is the same then we are casting it to
    the desired type and performing actions as per our case. Sometimes this creates
    confusion when we need to write more complex logic with expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'C# 7.0 resolves this subtly to make our expression simpler. Now we can directly
    declare a variable while checking the type in an expression; see the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, which is updated where the `is` expression both tests
    the variable and assigns it to a new variable of the desired type. With this change,
    there is no need to explicitly cast the type `((string) character)` as we were
    doing in the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us add one more condition to the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are checking *object* for `int`, which is a *struct*.
    The preceding condition works perfectly fine and produces the expected results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our complete code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `is` expression works perfectly fine with both value types as well as reference
    types.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code-example, the variables `str` and `number` are only assigned
    when the respective expression matches results as `true`.
  prefs: []
  type: TYPE_NORMAL
- en: switch statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already discussed the `switch` statement in Day 02\. The `switch` pattern
    helps a great deal as it uses any datatype for matching additionally `case` provides
    a way so, it matched the condition.
  prefs: []
  type: TYPE_NORMAL
- en: The `match` expression is the same but in C# 7.0, this feature has been enhanced
    in three different ways. Let us understand them using code examples.
  prefs: []
  type: TYPE_NORMAL
- en: constant pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In earlier versions of C#, the `switch` statement only supported the *constant*
    pattern, where we evaluate some variable in the `switch` and then make a conditional
    call as per the constant case. See the following code example, where we are trying
    to check whether `inputChar` is of a specific length, which is computed in `switch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, our main task is to check whether `inputChar` is a vowel
    or consonant, and what we are doing here is we are first evaluating the length
    of the `inputChar` and then performing operations as required, which leads to
    more work/code for more complex conditions.
  prefs: []
  type: TYPE_NORMAL
- en: type pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the introduction of the *type* pattern, we can overcome the problem we
    were facing with the *constant* pattern (in the previous section). Consider the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, now it's easy to perform the operation as per type pattern.
  prefs: []
  type: TYPE_NORMAL
- en: When clause in case expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the introduction of a `when` clause in `case` expressions, you can do
    special things in the expression; see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `case` with `when` makes sure that it will perform the
    operation only if `listObjects` has some value.
  prefs: []
  type: TYPE_NORMAL
- en: The `case` statement requires that each `case` ends with a `break`, `return`,
    or `goto`.
  prefs: []
  type: TYPE_NORMAL
- en: Local functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Local functions can be achievable using function and action using anonymous
    methods in prior versions, but there are still a few limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ref` and `out` parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local functions are featured to declare within the block scope. These functions
    are very powerful and have the same capability as any other normal function but
    with the difference that they are scoped within the block these were declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code-example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The method `FindOddEvenBySingleNumber()` in the preceding code is simply returning
    a number as *Odd* or *Even* for numbers greater than 1\. This uses a private method,
    `IsOddNumber()`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The method `IsOddNumber()` is a private method and is available within the class
    it declared. Hence, its scope is within a class and not within a code block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see the following code-example of a local function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the local function `IsOddNumber()` is performing the
    same action as in the case of the `private` method in the previous section. But
    here, the scope of `IsOddNumber()` is within the method `FindOddEvenBySingleNumberUsingLocalFunction()`.
    Hence, it would not be available outside this code block.
  prefs: []
  type: TYPE_NORMAL
- en: Literal improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to literals, we can think about the declaration of various variables
    constant, which are sometimes the life of a method as these would be very important
    for a method or to take any decision. And it leads to wrong decisions with the
    misreading of a numeric constant. To overcome this confusion, C# 7.0 introduced
    two new features, binary literals and digit separators.
  prefs: []
  type: TYPE_NORMAL
- en: Binary literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Binary digits are very important for performing complex operations. A constant
    of a binary digit can be declared as *0b<binaryvalue>*, where 0b tells us that
    this is a binary literal and binary values is the value of your decimal digit.
    Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Digit separator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the introduction of digit separators, we can easily read long numeric,
    binary digits. Digit separators can be used with both numeric and binary digits.
    For binary digits, the digit separator, that is, underscore (`_`), applies on
    bit pattern, and for numeric, it can appear anywhere but it is good to make 1,000
    the separator. Take a look at the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The digit separator can be used with decimal, float, and double types as well.
  prefs: []
  type: TYPE_NORMAL
- en: '<p>Followings are the new features shipped with Visual Studio 2017 update 3
    as a language features of C# 7.1, we will discuss all the features as per: [https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md](https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information new release of Visual Stuio 2017 refer to: [https://www.visualstudio.com/en-us/news/releasenotes/vs2017-relnotes](https://www.visualstudio.com/en-us/news/releasenotes/vs2017-relnotes)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are looking how to set up your existing project or new project that
    is using C# 7.0 – then you need not to worry, Visual Studio 2017 Update 3 is there
    to assist you. Whenever you start using new feature of C# 7.1 – you need to follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio will warn about existing version support and suggest to upgrade
    your project if you want to use new feature of C# 7.1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just click on yellow bulb and select best option fits for your requirement and
    you’re good to go with new C# 7.1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Following image tells you two-steps to get ready with C# 7.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let us start discussion on new features of Language C# 7.1:'
  prefs: []
  type: TYPE_NORMAL
- en: Async Main
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A new feature of language C# 7.1 that enables entry-point that is, `Main` of
    an application. Async main enables `main` method to be awaitable that mean `Main`
    method is now asynchronous to get `Task` or `Task<int>`. With this feature followings
    are valid entry-points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Restrictions while using new signatures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use these new signature entry-points and these marked as valid if no
    overload of previous signature is present that means if you are using an existing
    entry-point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not mandatory to mark your entry-point as async that means you can
    still use the existing async entry-point:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'There may be more usage of the entry-point that you can incorporate in the
    application – refer to official document of this feature: [https://github.com/dotnet/csharplang/blob/master/proposals/async-main.md](https://github.com/dotnet/csharplang/blob/master/proposals/async-main.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Default expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A new expression introduced in C# 7.1 that is default literal. With the introduction
    of this new literal, the expression can be implicitly converted to any type and
    produces result as default value of the type.
  prefs: []
  type: TYPE_NORMAL
- en: New default literal is different than old `default(T)`. Earlier `default` convert
    the target type of `T` but newer one can convert any type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code when we are writing `int thisIsANewDefault = default;`
    an expression that is valid in C# 7.1 and it implicitly convert the expression
    to type int and assign a default value that is 0 (zero) to `thisIsANewDefault`.
    The notable point here is that default literal implicitly detect the type of `thisIsANewDefault`
    and set the value. On the other hand, we need to explicitly tell the target type
    to set the default value in expression `var thisIsAnOlderDefault = default(int);`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code generates following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00048.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'There are multiple implementations of new default literal so, you can use the
    same with following:'
  prefs: []
  type: TYPE_NORMAL
- en: Member variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'New `default` expression can be applied to assign default values to variables,
    followings are the various ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to variables, with the use of default we can declare constants, followings
    are the various ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'There are more scenarios where you can use this new default literal viz. optional
    parameter in method that is, For more information, refer to: [https://github.com/dotnet/csharplang/blob/master/meetings/2017/LDM-2017-03-07.md](https://github.com/dotnet/csharplang/blob/master/meetings/2017/LDM-2017-03-07.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Infer tuple names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the introduction of this new feature we you do not require to explicitly
    declare the tuple candidate names. We discussed Tuples in previous section *Tuples
    and Deconstructions*. Infer tuple names feature is an extended to the tuple values
    introduced in C# 7.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with this new feature, you require updated NuGet package of `ValueTuple`
    that you’ve installed in previous section *Tuple*. To update the NuGet package,
    go to *NuGet Package manager* and click on Update tab and then click update latest
    version. Following screenshot provides the complete information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Following code-snippet shows, various ways to declare the tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is self-explanatory, Tuple `noNamed` does not have any member
    name and can be accessed using `item1` and `item2`. Similarly, in Tuple `IgnoredName`
    all defined member names will be ignored as declaration is not defined with a
    member name. Following code-snippet tells the complete story of how we can access
    various tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00050.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'There is more variation where you can use this new feature for more info, refer:
    [https://github.com/dotnet/roslyn/blob/master/docs/features/tuples.md](https://github.com/dotnet/roslyn/blob/master/docs/features/tuples.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Other features supposed to release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There would be more features with the final release of programming language
    C# 7.1 in addition to previous, following are the features that encountered a
    bug or partially implemented as on date.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern-matching with generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pattern-matching with generic is proposed here: [https://github.com/dotnet/csharplang/blob/master/proposals/generics-pattern-match.md](https://github.com/dotnet/csharplang/blob/master/proposals/generics-pattern-match.md)
    as new feature of C# 7.1 that encountered a bug and can be seen here: [https://github.com/dotnet/roslyn/issues/16195](https://github.com/dotnet/roslyn/issues/16195)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this feature would be based on `as` operator as detailed
    here: [https://github.com/dotnet/csharplang/blob/master/spec/expressions.md#the-as-operator](https://github.com/dotnet/csharplang/blob/master/spec/expressions.md#the-as-operator)'
  prefs: []
  type: TYPE_NORMAL
- en: Reference assemblies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reference assemblies feature is yet to be incorporated within IDE, you can
    refer: [https://github.com/dotnet/roslyn/blob/master/docs/features/refout.md](https://github.com/dotnet/roslyn/blob/master/docs/features/refout.md)
    here for more details.'
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions, which cover the concepts of today''s learning:'
  prefs: []
  type: TYPE_NORMAL
- en: What are `ValueTuple` types?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ValueTuples are mutable; prove with an example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `ValueTuple` of 10 elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a user-defined class employee as follows and then write a program to
    deconstruct user-defined types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Create a class of various constants using digit separators and implement these
    constants to a function `ToDecimal()` and `ToBinary()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are local functions? How are they different from private functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rewrite the `OddEven` program using generic local functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rewrite the `OddEven` program using the type pattern in `switch` case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program to find out `OddEven` with the utilization of inferred Tuple
    names feature of language C# 7.1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is default expression (C# 7.1), elaborate with the help of program?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Revisiting Day 03
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, we have discussed all the new features introduced in C# 7.0 with code
    examples. We also understood the important points and usage of these features.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed how ValueTuples help us gather the data information and the cases
    where we are expecting multiple outputs from a method. One of the good points
    of `ValueTuple` is that this is a mutable and `ValueType`. There are a few `public`
    and `static` methods provided by `System.ValueTuple` and we can achieve many complex
    scenarios with the use of these.
  prefs: []
  type: TYPE_NORMAL
- en: Then we came to know the advantage and power of pattern matching; this helps
    the coder perform various complex conditional scenarios which were not possible
    in prior versions of the C# language. The type pattern and the `when` clause in
    `case` statements makes this feature superb.
  prefs: []
  type: TYPE_NORMAL
- en: Local functions are one of the most important features introduced in C# 7.0\.
    They help a lot in a scenario, where we need to make our code symmetric, so you
    can read code perfectly and when we do not require the method outside, or we do
    not need to reuse this operation which is required within a block scope.
  prefs: []
  type: TYPE_NORMAL
- en: With the literal improvements, now we can declare binary numbers as constants
    and use them as we use other variables. The capability of adding the digit separator
    underscore (`_`) made this feature more useful.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have gone through the new features released for language C# 7.1
    as a part of Visual Studio update 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, in plan there were more features which were planned to release but
    the final release came with preceding new features. Next release is in plan and
    there are more robust features which are yet to come. You can watch the plan and
    next release feature list here: [https://github.com/dotnet/csharplang/tree/master/proposals](https://github.com/dotnet/csharplang/tree/master/proposals).'
  prefs: []
  type: TYPE_NORMAL
