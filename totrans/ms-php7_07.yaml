- en: Optimizing for High Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the years, PHP has grown into a remarkable language we use to build
    our web applications. An impressive number of language features, alongside countless
    libraries and frameworks, make our job ever so easier. We often write code which
    encompasses several layers of stack without giving it a second thought. This makes
    it easy to overlook one of the most important aspects of every application--performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are several aspects to performance that developers need to pay
    attention to, the end user is only interested in one - the time it takes for their
    web page to be loaded. This is really all that it comes down to. Nowadays, users expect
    their pages to load in less than 2 seconds. Anything more and we face decreased
    conversion, which often translates into serious financial loss when it comes to
    big e-commerce retailers:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A 1 second delay in page response can result in a 7% reduction in conversions."  "If
    an e-commerce site is making $100,000 per day, a 1 second page delay could potentially
    cost you $2.5 million in lost sales every year."'
  prefs: []
  type: TYPE_NORMAL
- en: - kissmetrics.com
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will address some of the areas of PHP that directly or
    indirectly impact the application performance and behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: Max execution time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File uploads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Session handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output buffering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disabling debug messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zend OPcache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Max execution time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **maximum execution time** is one of the most common errors developers come across.
    By default, the maximum execution time of the PHP script executing in the browser
    is 30 seconds, unless we execute the script within the CLI environment, where
    there is no such limitation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could easily test that through a simple example, given through the `index.php`
    and `script.php` files, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Executed from within the browser, this will return the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Executed from within the CLI environment, this will return the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Luckily for us, PHP provides two ways to control the timeout value:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `max_execution_time` configuration directive (`php.ini` file, `ini_set()`
    function)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `set_time_limit()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `set_time_limit()` function use has an interesting implication. Let''s
    take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example will result in the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly enough, the `set_time_limit()` function restarts the timeout counter
    from zero at the point where it was called. What this really means is that using
    the `set_time_limit()` function throughout the code, in a largely complex system,
    we can significantly extend the overall timeout beyond the initially imagined
    boundaries. This is quite dangerous, as PHP timeout is not the only timeout in
    the mix when it comes to delivering the final web page to a user's browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Web servers come with various timeout configurations of their own that might interrupt
    the PHP execution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apache:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimeOut` directive, defaults to 60 seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nginx:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`client_header_timeout` directive, defaults to 60 seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`client_body_timeout` directive, defaults to 60 seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fastcgi_read_timeout` directive, defaults to 60 seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we can certainly control script timeouts within the browser context, the important
    question is *why would we want to do so*? Timeouts are usually a result of resource-intense
    operations, such as various non-optimized loops, data exports, imports, PDF file
    generations, and so on. The CLI environment, or ideally, dedicated services, should
    be our go-to when it comes to all resource-intense jobs. Whereas the browser environment's
    prime focus should be delivering pages to users in the shortest possible amount
    of time.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quite often, PHP developers need to deal with a large amount of data. While large
    is a relative term, memory is not. Certain combinations of functions and language
    constructs, when used irresponsibly, can clog our server memory in a matter of
    seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Probably the most notorious function is `file_get_contents()`. This easy-to-use
    function literally grabs the content of an entire file and puts it into memory.
    To better understand the issue, let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: While this code is perfectly valid and working, it is a potential performance
    bottleneck. The `$content` variable will pull the content of the entire `users.csv`
    file into memory. While this could work for a small file size, of let's say a
    couple of megabytes, the code is not performance optimized. The moment `users.csv`
    starts to grow, we will begin experiencing memory issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'What can we do to mitigate the issue? We can rethink our approach to solving
    a problem. The moment we shift our mind into the *must optimize performance* mode,
    other solutions become clear. Instead of reading the content of an entire file
    into the variable, we can parse the file line by :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using  `file_get_contents()` and `str_getcsv()`, we focus onto using
    another set of functions, `fopen()` and `fgetcsv()`. The end result is absolutely the
    same, with the added benefit of being fully performance friendly. Using functions
    with handles, in this specific case, we have effectively assured that memory limitations
    are not an issue for our script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The irresponsible use of loops is another common cause of memory :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s go ahead and see a modified, memory-friendly example with the same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `fetchAll()` method is slightly faster than `fetch()`, but it requires more
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'When PHP hits the memory limit, it stops the script execution and throws the
    following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Luckily, the `memory_limit` directive enables us to control the amount of memory
    available. The default `memory_limit` value is `128M`, which implies 128 megabytes
    of memory. The directive is `PHP_INI_ALL` changeable, which means that apart from
    setting it via the `php.ini` file, we can set it at runtime using `ini_set('memory_limit',
    '512M');`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from tuning the `memory_limit` directive, PHP provides the following
    two functions that return memory usage information:'
  prefs: []
  type: TYPE_NORMAL
- en: '`memory_get_usage()`: This returns the amount of memory currently allocated
    by our PHP script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`memory_get_peak_usage()`: This returns the peak amount of memory allocated
    by our PHP script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we might be tempted to increase this value, we should think twice about
    doing so. The memory limit is per process, not per server. Web servers themselves
    can spin up several processes. Using large memory limit values can therefore clog
    our server. Aside from that, any script that might actually consume a large amount
    of memory is easily a candidate for performance optimization. Applying simple, thought-through
    techniques to our code can greatly reduce memory use.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to actual memory management, things are pretty automated here.
    Unlike C language, where we get to manage memory ourselves, PHP uses garbage collection
    in combination with a reference counting mechanism. Without going into the ins
    and outs of the mechanism itself, it is suffice to say that variables are automatically
    released when they are not being used any more.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on garbage collection, check out [http://php.net/manual/en/features.gc.php](http://php.net/manual/en/features.gc.php).
  prefs: []
  type: TYPE_NORMAL
- en: File uploads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Uploading files is a common functionality to many PHP applications. So common
    that PHP provides a convenient global `$_FILES` variable we can use to access
    uploaded files, or errors behind the file upload tries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following simple file upload form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In order for PHP to pick up the files, we need to set the `form method` value
    to `post`, and `enctype` to `multipart/form-data`. Once submitted, PHP will pick
    it up and fill in the `$_FILES` variable appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Without going into the details of the actual post-upload file management, it''s
    suffice to say that `$_FILES` contains enough information for us to either pick
    up and further manage files, or indicate a possible error code during upload.
    The following eight error codes can be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UPLOAD_ERR_OK`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPLOAD_ERR_INI_SIZE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPLOAD_ERR_FORM_SIZE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPLOAD_ERR_PARTIAL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPLOAD_ERR_NO_FILE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPLOAD_ERR_NO_TMP_DIR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPLOAD_ERR_CANT_WRITE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPLOAD_ERR_EXTENSION`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While all of the errors should be equally addressed, two of them (`UPLOAD_ERR_FORM_SIZE`
    and `UPLOAD_ERR_PARTIAL`) open up crucial performance questions: *how big a file
    can we upload* and *are there any timeouts in the process*?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer to these two questions can be found in configuration directives,
    some of which are directly related to file upload, while others are related to
    more general PHP options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`session.gc_maxlifetime`: This is the number of seconds after which data will
    be seen as garbage and cleaned up; it defaults to 1,440 seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`session.cookie_lifetime`: This is the lifetime of the cookie in seconds; by
    default, the cookie is valid until the browser is closed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_input_time`: This is the maximum time in seconds a script is allowed to
    parse input data, such as POST; by default, this is turned off'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_execution_time`: This is the maximum time a script is allowed to run before
    it is terminated; it defaults to 30 seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upload_max_filesize`: This is the maximum size of an uploaded file; it defaults
    to 2 megabytes (2M)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_file_uploads`: This is the maximum number of files allowed to be uploaded in
    a single request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post_max_size`: This is the maximum size of the post data allowed; it defaults
    to 8 megabytes (8M)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tweaking these options ensures that we avoid timeouts and planned size limits.
    To ensure that we can avoid the maximum file size limitation early in the process, `MAX_FILE_SIZE`
    can be used as a hidden form field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `MAX_FILE_SIZE` field must precede any other file field a form might have.
    Its value stands for the maximum file size accepted by PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Trying to upload a file larger than defined by the `MAX_FILE_SIZE` hidden field
    would now result in a `$_FILES` variable similar to the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the error has now turned to value `2`, which equals the `UPLOAD_ERR_FORM_SIZE`
    constant.
  prefs: []
  type: TYPE_NORMAL
- en: While normally we would address the limitations of default configuration through
    code optimization, file uploads are specific; in that, we really need to ensure
    that large file uploads are possible if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Session handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sessions are an interesting mechanism in PHP, allowing us to maintain state
    in what is overall a stateless communication. We might visualize them as a *per-user
    serialized array of information* saved to a file. We use them to store user-specific information
    across various pages. By default, sessions rely on cookies, although, they can
    be configured to use the `SID` parameter in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cookie version of the PHP session works roughly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the session token from the cookie.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create or open an existing file on disk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lock the file for writing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the content of the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put the file data into the global `$_SESSION` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set caching headers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the cookie to the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On each page request, repeat steps 1-7.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *SID version* of the PHP session works pretty much the same way, aside from
    the cookie part. The cookie here is replaced by the SID value we push via the
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: The session mechanism can be used for various things, some of which include
    user login mechanisms, storing minor data caches, parts of templates, and so on.
    Depending on the usage, this might bring up the question of *maximum session size*.
  prefs: []
  type: TYPE_NORMAL
- en: By default, when a script executes, sessions are read from files into the memory. Therefore,
    the maximum size of a session file cannot exceed the `memory_limit` directive,
    which defaults to 128 megabytes. We could bypass this *default* session behavior
    by defining the custom session handlers. The `session_set_save_handler()` function
    allows us to register a custom session handler, which must comply to the `SessionHandlerInterface`
    interface. With custom session handlers, we are able to move away from the file
    mechanism to storing session data in the database. The added benefit of this is greater performance
    efficiency, as we are now able to create scalable PHP environments behind a load
    balancer where all application nodes connect to a central session server.
  prefs: []
  type: TYPE_NORMAL
- en: '**Redis** and **memcached** are two data stores that are quite popular among
    PHP developers. The **Magento 2** e-commerce platform supports both Redis and memcached for
    external session storage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While the session storage plays a key role in terms of performance, there are
    a few configuration directives worth keeping an eye on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`session.gc_probability`: This defaults to 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`session.gc_divisor`: This defaults to 100'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gc_maxlifetime`: This defaults to 1,440 seconds (24 minutes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `gc_probability` and `gc_divisor` directives work in conjunction. Their
    ratio (*gc_probability/gc_divisor => 1/100 => 1%*) defines a probability of the
    garbage collector running on each `session_start()` call. Once the garbage collector
    is run, value of the `gc_maxlifetime` directive tells it if something should be
    seen as garbage and should be potentially cleaned up.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to high-performance sites, sessions can easily become a bottleneck.
    Thoughtful tuning and session storage selection can make just the right performance
    difference.
  prefs: []
  type: TYPE_NORMAL
- en: Output buffering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Output buffering is a PHP mechanism that controls the output of a script. Imagine
    we write down `echo 'test';` within our PHP script and do not see anything on
    screen. How is that possible? The answer is **o****utput buffering**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following piece of code is a simple example of output buffering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When executed within the CLI environment, we will first see `Chunk#1` come out
    after a few seconds, then a few seconds after, we will see `Chunk#3` come out,
    and, finally, a few more seconds after, we will see `Chunk#4` come out.  `Chunk#2`
    would never be output. This is quite a concept, given that we are used to having
    the `echo` construct outputting stuff just after it is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several output buffering related functions, of which the following
    five are the most interesting ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ob_start()`: This triggers a new buffer and creates stacked buffers if called
    after another *non-closed* buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ob_end_flush()`: This outputs the topmost buffer and turns this output buffer
    off'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ob_end_clean()`: This cleans the output buffer and turns off output buffering'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ob_get_contents()`: This returns the content of the output buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ob_gzhandler()`: This is the callback function for use with `ob_start()`,
    to GZIP the output buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example demonstrates the stacked buffers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The entire output here is being withheld for roughly 8 seconds, after which
    all four `Chunk#...` strings are being output at once. This is because the `ob_end_flush()`
    function is the only one that sends the output to the console, whereas the `ob_end_flush()` function
    merely closes the buffer, passing it to the parent buffer present in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of the `ob_get_contents()` function can add further dynamic to output
    buffering, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `ob_get_content()` function allows us to grab a string representation of
    content stored in the buffer. It is up to us to choose if we want to modify that
    content further, output it, or pass it on to other constructs.
  prefs: []
  type: TYPE_NORMAL
- en: How does all this apply to web pages? After all, we are interested in the performance
    of our scripts, mostly, in context of web pages. Without output buffering, HTML
    is sent to the browser in chunks as PHP progresses through our script. With output
    buffering, HTML is sent to the browser as one string at the end of our script.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping in mind that the `ob_start()` function accepts a callback function,
    we can use the callback function to further modify the output. This modification
    can be anything, either form of filtering or even compression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates the use of output filtering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Nowadays, however, we are not likely to write these kinds of structures ourselves,
    as the framework abstractions masquerade it for us.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling debug messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Ubuntu Server is a popular, free, and open source Linux distribution that
    we can use to quickly set up a **LAMP** (**Linux, Apache, MySQL, PHP**) stack.
    The ease of installation and long-term support of Ubuntu Server makes it a popular
    choice among PHP developers. With a clean server installation, we can get the
    LAMP stack up and running just by executing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once these are done, visiting our external server IP address, we should see
    an Apache page, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/65d05a45-40ba-469f-b2b8-2e510122490d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The HTML we are seeing in the browser originates from the `/var/www/html/index.html`
    file. After replacing `index.html` with `index.php`, we're good to play with the
    PHP code.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this Ubuntu Server-like introduction is to emphasize certain server defaults. Out
    of all configuration directives, we should never blindly accept defaults for *error
    logging* and *error displaying* directives without truly understanding them. Constant
    switching between development and production environments makes it way too easy
    to expose confidential information within the browser or miss logging the right
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, let''s assume we have the following broken `index.php` file
    on our freshly installed Ubuntu Server LAMP stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'On trying to open this in the browser, Apache will send back `HTTP 500 Internal
    Server Error`, which, depending on the browser, might be visible to the end user,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4fab80d6-e7a8-43a9-b4e6-574dc6d457e6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Ideally, we would have our web server configured with a nicely styled generic
    error page, just to make it more user friendly. While the browser response might
    satisfy the end user, it certainly does not satisfy the developer in this case.
    The information returned does not indicate anything about the nature of the error,
    which makes it difficult to fix it. Luckily, for us, the default LAMP stack configuration
    in this case includes logging the error to a `/var/log/apache2/error.log` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'While this behavior is perfect for production, it is cumbersome for the development
    environment. When developing, we would really like our errors to show up in the
    browser, just to speed things up. PHP allows us to control the error reporting
    and logging behavior through several configuration directives, the following being
    the most important:'
  prefs: []
  type: TYPE_NORMAL
- en: '`error_reporting`: This is the error level we wish to monitor; we can use the
    pipe (`|`) operator to list several error-level constants. Its default value is `E_ALL
    & ~E_NOTICE & ~E_STRICT & ~E_DEPRECATED`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`display_errors`: This specifies if errors should be sent to the browser/CLI
    or be hidden from the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error_log`: This is the file where we want to log PHP errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log_errors`: This tells us if we should log the error to the `error_log` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The available error-level constants are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`E_ERROR (1)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E_WARNING (2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E_PARSE (4)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E_NOTICE (8)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E_CORE_ERROR (16)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E_CORE_WARNING (32)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E_COMPILE_ERROR (64)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E_COMPILE_WARNING (128)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E_USER_ERROR (256)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E_USER_WARNING (512)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E_USER_NOTICE (1024)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E_STRICT (2048)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E_RECOVERABLE_ERROR (4096)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E_DEPRECATED (8192)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E_USER_DEPRECATED (16384)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E_ALL (32767)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the `error_reporting()` and `ini_set()` functions, we can use some of
    these directives to configure logging and displaying during runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: careful using `ini_set()` for `display_errors` as it won't have any effect if
    the script has fatal errors, simply because runtime does not get executed.
  prefs: []
  type: TYPE_NORMAL
- en: Error displaying and error logging are two different mechanisms that work hand
    in hand with each other. While we are likely to benefit more from error displaying
    in development environments, error logging is the way to go for production environments.
  prefs: []
  type: TYPE_NORMAL
- en: Zend OPcache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One major downside of PHP is that it loads and parses the PHP script on every
    request. Written in plain text, the PHP code is first compiled to opcodes, then
    the opcodes are executed. While this performance impact might not be noticeable
    with small applications that have one or few scripts in total, it makes a big
    difference with larger platforms, such as Magento, Drupal, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from PHP 5.5, there is an out-of-the-box solution to this problem.
    The Zend OPcache extension addresses the repetitive compilation issue by storing
    the compiled opcodes in shared memory (RAM). Turning it on or off is simply a
    matter of changing the configuration directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are quite a few configuration directives, a few of which will get us
    started:'
  prefs: []
  type: TYPE_NORMAL
- en: '`opcache.enable`: This defaults to 1 and is changeable via `PHP_INI_ALL`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opcache.enable_cli`: This defaults to 0 and is changeable via `PHP_INI_SYSTEM`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opcache.memory_consumption`: This defaults to 64 and is changeable via `PHP_INI_SYSTEM`,
    which defines the size of shared memory used by OPcache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opcache.max_accelerated_files`: This defaults to 2000 and is changeable via
    `PHP_INI_SYSTEM`, which defines the maximum number of keys/scripts in the OPcache
    hash table. Its maximum value is 1000000.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opcache.max_wasted_percentage`: This defaults to 5 and is changeable via `PHP_INI_SYSTEM`,
    which defines the maximum percentage of wasted memory allowed before scheduling
    a restart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While `opcache.enable` is flagged as `PHP_INI_ALL`, using `ini_set()` to enable
    it at runtime won't work. Only disabling it with `ini_set()` will work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although fully automated, Zend OPcache also provides a few functions for us
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`opcache_compile_file()`: This compiles and caches a script without executing
    it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opcache_get_configuration()`: This fetches the OPcache configuration information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opcache_get_status()`: This fetches the OPcache information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opcache_invalidate()`: This invalidates OPcache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opcache_is_script_cached()`: This tells us if the script is cached via OPcache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opcache_reset()`: This resets the OPcache cache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While it is unlikely we will use these methods on our own, they do come in handy
    for utility tools that deal with OPcache for us.
  prefs: []
  type: TYPE_NORMAL
- en: The opcache-gui tool shows OPcache statistics, settings, and cached files whilst providing
    a real-time update. This tool is available for download at [https://github.com/amnuts/opcache-gui](https://github.com/amnuts/opcache-gui).
  prefs: []
  type: TYPE_NORMAL
- en: One thing to be wary about with OPcache is its potential *cache slam* problem. Using
    the `memory_consumption`, `max_accelerated_files`, and `max_wasted_percentage`
    configuration directives, OPcache determines when it is time to flush the cache.
    When this happens, servers with large amounts of traffic are likely to experience
    a cache slam problem, with lots of requests simultaneously generating the same
    cache entries. Therefore, we should try to avoid frequent cache flushing. To do
    so, we can use the cache monitoring tool and tune the three configuration directives to
    suit our application size.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While concurrency is a topic applicable to multiple layers of stack, there are
    a few configuration directives around web servers that every developer should
    be familiar with. Concurrency refers to handling multiple connections inside a
    web server. The two most popular web servers for PHP, Apache, and Nginx, both
    allow some basic configuration for handling multiple connections.
  prefs: []
  type: TYPE_NORMAL
- en: While there are plenty of debates as to which server is faster, Apache with
    the MPM event module is pretty much on par with the Nginx performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following directives dictate the Apache MPM event concurrency, and are
    therefore worth keeping an eye on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ThreadsPerChild`: This is the number of threads created by each child process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ServerLimit`: This is the limit on the configurable number of processes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MaxRequestWorkers`: This is the maximum number of connections to be processed
    simultaneously'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsyncRequestWorkerFactor`: This is the limit on concurrent connections per
    process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An absolute maximum numbers of possible concurrent connections can be calculated
    using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*max_connections = (AsyncRequestWorkerFactor + 1) * MaxRequestWorkers*'
  prefs: []
  type: TYPE_NORMAL
- en: The formula is quite simple; however, changing `AsyncRequestWorkerFactor` is
    not just a matter of punching in a higher configuration value. We would need to
    have a solid knowledge about the traffic hitting the web server, which implies
    extensive testing and data gathering.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following directives dictate the Nginx concurrency, and are therefore worth
    keeping an eye on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`worker_processes`: This is the number of worker processes; it defaults to
    1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`worker_connections`: This is the maximum number of simultaneous connections
    that can be opened by a worker process; it defaults to 512'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The ideal total number of users Nginx can serve comes down to the following
    formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*max_connections = worker_processes * worker_connections*'
  prefs: []
  type: TYPE_NORMAL
- en: Though we have barely scratched the surface of web server concurrency and the
    overall configuration directives for these two web servers, the preceding information
    should serve us as a starting point. While developers don't usually tune web servers,
    they should know when to flag misconfiguration that might impact their PHP application
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we have addressed some aspects of the PHP performance
    optimization. While these merely scratch the surface of the overall performance
    topic, they outline the most common areas every PHP developer should be deeply
    familiar with. The broad range of configuration directives allows us to tune application
    behavior that often works in tandem with the web server itself. The backbone of
    optimal performance, however, lies in the thoughtful use of resources across the
    stack, as we got to observe through the simple SQL query example.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we will look into serverless architecture, an emerging abstraction
    of the standard development environment.
  prefs: []
  type: TYPE_NORMAL
