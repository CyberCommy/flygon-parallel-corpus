- en: Creating Testable Documentation with doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Documenting the basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catching stack traces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a doctest from the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding a test harness for doctest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering out test noise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing out all your documentation including a status report
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the edges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing corner cases by iteration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting nosy with doctest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the project-level script to run this chapter's doctests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python provides a useful ability to embed comments inside functions that are
    accessible from a Python shell. These are known as **docstrings**.
  prefs: []
  type: TYPE_NORMAL
- en: A docstring provides the ability to embed not only information, but also code
    samples that are runnable.
  prefs: []
  type: TYPE_NORMAL
- en: There is an old adage that says *comments **aren't **code*. This is because
    comments don't undergo syntax checks and are often not maintained. Thus, the information
    they carry can lose its value over time. `doctest` counters this by turning comments
    into code, which can serve many useful purposes.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore different ways to use `doctest` to develop
    testing, documentation, and project support. No special setup is required, as
    `doctest` is part of Python's standard libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting the basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python provides an out-of-the-box capability to put comments in code, known
    as docstrings. Docstrings can be read when looking at the source and also when
    inspecting the code interactively from a Python shell. In this recipe, we will
    demonstrate how these interactive docstrings can be used as runnable tests.
  prefs: []
  type: TYPE_NORMAL
- en: What does this provide? It offers easy-to-read code samples for the users. Not
    only are the code samples readable, they are also runnable, meaning we can ensure
    the documentation stays up-to-date.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the following steps, we will create an application combined with runnable
    docstring comments, and see how to execute these tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `recipe16.py` to put all the code we write for this
    recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a function that converts base-10 numbers to any other base using recursion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a docstring just below the external function, as shown in the highlighted
    section of the following code. This docstring declaration includes several examples
    of using the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a test runner block that invokes Python''s `doctest` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'From an interactive Python shell, import the recipe and view its documentation.
    Take a look at this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the code from the command line. In the following screenshot, notice how
    nothing is printed. This is what happens when all the tests pass. Look at this
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the code from the command line with `-v` to increase verbosity. In the
    following screenshot, we see a piece of the output, showing what was run and what
    was expected. This can be useful when debugging `doctest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `doctest` module looks for blocks of Python inside docstrings and runs it
    like real code. `>>>` is the same prompt we see when we use the interactive Python
    shell. The line following `>>>` shows the expected output. `doctest` runs the
    statements it sees and then compares the actual output with the expected output.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will see how to catch things such as stack traces,
    errors, and also add extra code that equates to a test fixture.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`doctest` is very picky when matching expected output with actual results:'
  prefs: []
  type: TYPE_NORMAL
- en: An extraneous space or tab can cause things to break.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structures such as dictionaries are tricky to test, because Python doesn't guarantee
    the order of items. On each test run, the items could be stored in a different
    order. Simply printing out a dictionary is bound to break.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is strongly advised not to include object references in expected outputs.
    These values also vary every time the test is run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catching stack traces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's a common fallacy that we should write tests only for successful code paths.
    We also need to code against error conditions including the ones that generate
    stack traces. With this recipe, we will explore how stack traces are pattern-matched
    in doc testing, which allows us to confirm expected errors.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the following steps, we will see how to use `doctest` to verify error
    conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `recipe17.py` for all our code in this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a function that converts base-10 numbers to any other base using recursion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a docstring just below the external function declaration that includes
    two examples that are expected to generate stack traces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a test runner block that invokes Python''s `doctest` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code from the command line. In the following screenshot, notice how
    nothing is printed. This is what happens when all the tests pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the code from the command line with `-v` to increase verbosity. In the
    following screenshot, we can see that `0` and `-1` generate math domain errors.
    This is due to using `math.log` to find the starting exponent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `doctest` module looks for blocks of Python inside docstrings and runs it
    like real code. `>>>` is the same prompt we see when we use the interactive Python
    shell. The line following `>>>` shows the expected output. `doctest` runs the
    statements it sees and then compares the actual output with the expected output.
  prefs: []
  type: TYPE_NORMAL
- en: 'With regard to stack traces, there is a lot of detailed information provided
    in the stack trace. Pattern matching the entire trace is ineffective. By using
    the ellipsis, we are able to skip the intermediate parts of the stack trace and
    just match on the distinguishing part: `ValueError: math domain error`.'
  prefs: []
  type: TYPE_NORMAL
- en: This is valuable, because our users will not only see the way it handles good
    values, but will also observe what errors to expect when bad values are provided.
  prefs: []
  type: TYPE_NORMAL
- en: Running a doctest from the command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to develop tests by embedding runnable fragments of code in
    docstrings. But for each of these tests, we had to make the module runnable. What
    if we wanted to run something else other than our `doctest` from the command line?
    We would have to get rid of the `doctest.testmod()` statements!
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that, starting with Python 2.6, there is a command-line option
    to run a specific module using `doctest` without coding a runner.
  prefs: []
  type: TYPE_NORMAL
- en: The `python -m doctest -v example.py` command will import `example.py` and run
    it through `doctest.testmod()`. According to the documentation, this may fail
    if the module is part of a package and imports other sub modules.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following steps, we will create a simple application. We will add some
    doctests and then run them from the command line without writing a special test
    runner:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `recipe18.py` to store the code written for this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a function that converts base-10 numbers to any other base using recursion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a docstring just below the external function declaration that includes
    some of the tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code from the command line using `-m doctest`. As shown in the following
    screenshot, no output indicates that all the tests have passed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the code from the command line with `-v` to increase verbosity. What happens
    if we forget to include `-m doctest`? Using the `-v` option helps us to avoid
    this by giving us a warm fuzzy feeling that our tests are working. Take a look
    at this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we were using the `__main__` block of a module to run
    other test suites. What if we wanted to do the same here? We would have to pick
    whether `__main__` would be for unittest tests, doctests, or both! What if we
    didn't even want to run testing through `__main__`, but instead run our application?
  prefs: []
  type: TYPE_NORMAL
- en: That is why Python added the option of invoking testing right from the command
    line using `-m doctest`.
  prefs: []
  type: TYPE_NORMAL
- en: Don't you want to *know* whether your tests are running or working? Is the test
    suite really doing what it promised? With other tools, we usually have to embed
    print statements, or deliberate failures just to know things are being trapped
    properly. Doesn't it appear that the `-v` option in `doctest` provides a convenient
    quick glance at what's happening?
  prefs: []
  type: TYPE_NORMAL
- en: Coding a test harness for doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tests we have written so far are very simple, because the function we are
    testing is simple. There are two inputs and one output with no side effects. No
    objects have to be created. This isn't the most common use case for us. Often,
    we have objects that interact with other objects.
  prefs: []
  type: TYPE_NORMAL
- en: The `doctest` module supports creating objects, invoking methods, and checking
    results. With this recipe, we will explore this in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: An important aspect of `doctest` is that it finds individual instances of docstrings,
    and runs them in a local context. Variables declared in one docstring cannot be
    used in another docstring.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new file called `recipe19.py` to contain the code from this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a simple shopping cart application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert a docstring at the top of the module, before the `ShoppingCart` class
    declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the recipe using `-m doctest` and `-v` for verbosity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Copy all the code we just wrote from `recipe19.py` into a new file called `recipe19b.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside `recipe19b.py`, add another docstring to `item`, which attempts to reuse
    the `cart` variable defined at the top of the module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this variant of the recipe. Why does it fail? Wasn''t `cart` declared in
    the earlier docstring? Look at this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `doctest` module looks for every docstring. For each docstring it finds,
    it creates a shallow copy of the module's global variables and then runs the code
    and checks results. Apart from that, every variable created is locally scoped
    and then cleaned up when the test is complete. This means that our second docstring
    that was added later cannot see the `cart` that was created in our first docstring.
    That is why the second run failed.
  prefs: []
  type: TYPE_NORMAL
- en: There is no equivalent to a `setUp` method as we used with some of the unittest
    recipes. If there is no `setUp` option with `doctest`, then what value is this
    recipe? It highlights a key limitation of `doctest` that all developers must understand
    before using it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `doctest` module provides an incredibly convenient way to add testability
    to our documentation. But this is not a substitute for a full-fledged testing
    framework, such as unittest. As noted earlier, there is no equivalent to a `setUp`.
    There is also no syntax checking of the Python code embedded in the docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing the right level of a `doctest` with unittest (or any other testing framework
    we may pick) is a matter of judgment.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering out test noise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Various options help `doctest` ignore noise, such as whitespace, in test cases.
    This can be useful, because it allows us to structure the expected outcome in
    a better way, to ease reading for the users.
  prefs: []
  type: TYPE_NORMAL
- en: We can also flag some tests that can be skipped. This can be used where we want
    to document known issues, but haven't yet patched the system.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these situations can easily be construed as noise when we are trying
    to run comprehensive testing but are focused on other parts of the system. In
    this recipe, we will dig in to ease the strict checking done by `doctest`. We
    will also look at how to ignore entire tests, whether it's for temporary or permanent
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the following steps, we will experiment with filtering out test results
    and easing certain restrictions of `doctest`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `recipe20.py` for the code from this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a recursive function that converts base-10 numbers into other bases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a docstring that includes a test to exercise a range of values as well
    as document a future feature that is not yet implemented:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a test runner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test case in verbose mode, as shown in this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Copy the code from `recipe20.py` into a new file called `recipe20b.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit `recipe20b.py` by updating the docstring to include another test exposing
    that our function doesn''t convert `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test case. Notice what is different about this version of the recipe
    and why it fails? Take a look at this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Copy the code from `recipe20b.py` into a new file called `recipe20c.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit `recipe20c.py` and update the docstring, indicating that we will skip
    the test for now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test case. Take a look at this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we revisit the function for converting from base-10 to any base
    numbers. The first test shows it being run over a range. Normally, Python would
    fit this array of results on one line. To make it more readable, we spread the
    output across two lines. We also put some arbitrary spaces between the values
    to make the columns line up better.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is something that `doctest` definitely would *not* support, due to its
    strict pattern matching nature. By using `#doctest: +NORMALIZE_WHITESPACE`, we
    are able to ask `doctest` to ease this restriction. There are still constraints.
    For example, the first value in the expected array cannot have any whitespace
    in front of it (*believe me, I tried for maximum readability!*) But wrapping the
    array to the next line no longer breaks the test.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a test case that is really meant as documentation only. It indicates
    a future requirement that shows how our function would handle negative binary
    values. By adding `#doctest: +SKIP`, we are able to command `doctest` to skip
    this particular instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we see a scenario where we discover that our code doesn''t handle
    `0`. As the algorithm gets the highest exponent by taking a logarithm, there is
    a math problem. We capture this edge case with a test. We then confirm that the
    code fails in classic **test-****driven ****design** (**TDD**) fashion. The final
    step would be to fix the code to handle this edge case. But we decide, in a somewhat
    contrived fashion, that we don''t have enough time in the current sprint to fix
    the code. To avoid breaking our **continuous ****integration** (**CI**) server,
    we mark the test with a `TO-DO` statement and add `#doctest: +SKIP`.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Both situations that we have marked up with `#doctest: +SKIP` are cases where
    eventually we will want to remove the `SKIP` tag and have them run. There may
    be other situations where we will never remove `SKIP`. Demonstrations of code
    that have big fluctuations may not be readily testable without making them unreadable.
    For example, functions that return dictionaries are harder to test because the
    order of results vary. We can bend it to pass a test, but we may lose the value
    of the documentation in order to present it to the reader.'
  prefs: []
  type: TYPE_NORMAL
- en: Printing out all your documentation including a status report
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since this chapter has been about both documentation and testing, let's build
    a script that takes a set of modules and prints out a complete report, showing
    all documentation as well as running any given tests.
  prefs: []
  type: TYPE_NORMAL
- en: This is a valuable recipe, because it shows us how to use Python's APIs to harvest
    a code-driven runnable report. This means the documentation is accurate and up
    to date, reflecting the current state of our code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following steps, we will write an application and some `doctests`. Then
    we will build a script to harvest a useful report:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `recipe21_report.py` to contain the script that harvests
    our report.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start creating a script by importing Python''s `inspect` library as the basis
    for drilling down into a module: `from inspect import*`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a function that focuses on either printing out an item''s `__doc__` string
    or prints out that no documentation was found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a function that prints out the documentation based on a given module. Make
    sure this function looks for classes, methods, and functions, and prints out their
    docs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a runner that parses the command-line string, and iterates over each provided
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Create a new file, `recipe21.py`, to contain an application with tests that
    we will run the earlier script against.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `recipe21.py`, create a shopping cart app and fill it with docstrings and
    `doctests`. This is documentation for the entire recipe. With it, we can demonstrate
    usage of the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the report script against this module using `-v`, and look at the screen''s
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This script is tiny, yet it harvests a lot of useful information.
  prefs: []
  type: TYPE_NORMAL
- en: By using Python's standard `inspect` module, we are able to drill down starting
    at the module level. The reflective way to look up a docstring is by accessing
    the `__doc__` property of an object. This is contained in modules, classes, methods,
    and functions. They exist in other places, but we limited our focus for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'We ran it in verbose mode to show that the tests were actually executed. We
    hand parsed the command-line options, but `doctest` automatically looks for `-v`
    to decide whether or not to turn on verbose output. To prevent our module processor
    from catching this and trying to process it as another module, we added a line
    to skip any `-xyz` style flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could spend more time enhancing this script. For example, we could dump this
    out with an HTML markup, making it viewable in a web browser. We could also find
    third-party libraries to export it in other ways.
  prefs: []
  type: TYPE_NORMAL
- en: We could also work on refining where it looks for docstrings and how it handles
    them. In our case, we just printed them to the screen. A more reusable approach
    would be to return some type of structure containing all the information. Then,
    the caller can decide whether to print to screen, encode it in HTML, or generate
    a PDF document.
  prefs: []
  type: TYPE_NORMAL
- en: This isn't necessary, because this recipe's focus is on seeing how to mix these
    powerful out-of-the-box options Python provides into a quick and useful tool.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the edges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tests need to exercise the boundaries of our code up to and beyond the range
    limits. In this recipe, we will dig into defining and testing edges with `doctest`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the following steps, we will see how to write code that tests the edges
    of our software:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `recipe22.py` and use it to place all of our code for
    this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a function that converts base-10 numbers to anything between base-2
    and base-36:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a docstring just below our function declaration that includes tests showing
    base-2 edges, base-36 edges, and the invalid base-37:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a test runner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the recipe, as shown in this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This version has a limit of handling base-2 through base-36.
  prefs: []
  type: TYPE_NORMAL
- en: For base-36, it uses `a` to `*z*`. This is compared to base-16 that uses `a`
    to `f`. `35` in base-10 is represented as `z` in base-36.
  prefs: []
  type: TYPE_NORMAL
- en: We include several tests, including `1` for base-2 and base-36\. We also test
    the maximum value before rolling over, and the next value, to show the rollover.
    For base-2, this is `1` and `2`. For base-36, this is `35` and `36`.
  prefs: []
  type: TYPE_NORMAL
- en: As we have also included tests for 0 to show that our function doesn't handle
    this for any base, we also test base-37, which is invalid as well.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's important that our software works for valid inputs. It's just as important
    that our software works as expected for invalid inputs. We have documentation
    that can be viewed by our users when using our software that documents these edges.
    And, thanks to Python's `doctest` module, we can test it and make sure that our
    software performs correctly.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Testing **the **edges* section mentioned in [Chapter 1](part0025.html#NQU20-dd965cfd3480473da68e719fadb0727c),
    *Using Unittest to Develop Basic Tests*.
  prefs: []
  type: TYPE_NORMAL
- en: Testing corner cases by iteration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Corner cases will appear as we continue to develop our code. By capturing corner
    cases in an iterable list, there is less code to write for capturing another test
    scenario. This can increase our efficiency at testing new scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new file called `recipe23.py`, and use it to store all our code for
    this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a function that converts base-10 to any other base:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some instances of `doctest` that include an array of input values to generate
    an array of expected outputs. Include one failure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a test runner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous screenshot, the key information is on this line: `AssertionError:
    expected: 11/2 actual: 10/2`. Is this test failure a bit contrived? Sure it is.
    But seeing a test case that shows useful output is not. It''s important to verify
    that our tests give us enough information to fix either the tests or the code.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created an array with each entry containing both the input data as well as
    the expected output. This provides us an easy way to glance at a set of test cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we iterated over each test case, calculated the actual value, and ran
    it through a Python `assert`. An important part that is needed is the custom message
    `''expected: %s actual: %s''`. Without it, we would never get the information
    that tells us which test case failed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What if one test case fails?**'
  prefs: []
  type: TYPE_NORMAL
- en: If one of the tests in the array fails, then that code block exits and skips
    over the rest of the tests. This is the trade-off for having a more succinct set
    of tests.
  prefs: []
  type: TYPE_NORMAL
- en: Does this type of test fit better into doctest or unittest?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some criteria to help you decide whether it''s worth putting these
    tests in `doctest`:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the code easy to comprehend at a glance?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there clear, succinct, useful information when users view the docstrings?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is little value of having this in the documentation, and it clutters
    the code, then that is a strong hint that this test block belongs to a separate
    test module.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Testing **corner **cases **by **iteration* section of [Chapter 1](part0025.html#NQU20-dd965cfd3480473da68e719fadb0727c),
    *Using Unittest to Develop Basic Tests*
  prefs: []
  type: TYPE_NORMAL
- en: Getting nosy with doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have been either appending modules with a test runner,
    or we have typed `python -m doctest <module>` on the command line to exercise
    our tests.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced the powerful `nose` library (refer to [http://somethingaboutorange.com/mrl/projects/nose](http://somethingaboutorange.com/mrl/projects/nose)
    for more details).
  prefs: []
  type: TYPE_NORMAL
- en: 'For a quick recap, nose has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Provides us with the convenient test discovering tool `nosetests`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is pluggable, with a huge ecosystem of plugins available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Includes a built-in plugin targeted at finding doctests and running them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to activate our virtual environment (`virtualenv`) and then install
    nose for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a virtual environment, activate it, and verify the tools are working.
    Take a look at this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using `pip`, install `nose`, as shown in the screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00051.jpeg)This recipe assumes you have built all of the previous
    recipes in this chapter. If you have built only some of them, your results may
    appear different.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Run `nosetests -with-doctest` against all the modules in this folder. You may
    notice that it prints a very short `.....F.F...F`, indicating that three tests
    have failed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run `nosetests -with-doctest -v` to get a more verbose output. In the following
    screenshot, notice how the tests that failed are the same ones that failed for
    the previous recipes in this chapter. It is also valuable to see the `<module>.<method>`
    format with either `ok` or `FAIL`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run `nosetests -with-doctest` against both the `recipe19.py` file as well as
    the `recipe19` module, in different combinations, as shown in the screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`nosetests` is targeted at discovering test cases and then running them. With
    this plugin, when it finds a docstring, it uses the `doctest` library to programmatically
    test it.'
  prefs: []
  type: TYPE_NORMAL
- en: The `doctest` plugin is built around the assumption that doctests are not in
    the same package as other tests, such as unittest. This means it will only run
    doctests found from non-test packages.
  prefs: []
  type: TYPE_NORMAL
- en: There isn't a whole lot of complexity to `nosetests` nor in using them, `nosetests`
    is meant to be an easy-to-use tool that puts testing at your fingertips. In this
    recipe, we have seen how to use `nosetests` to get a hold of all the doctest we
    have built so far in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the project-level script to run this chapter's doctests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will help us explore building a project-level script that allows
    us to run different test suites. We will also focus on how to run it in our `doctest`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the following steps, we will craft a command-line script to allow us to
    manage a project that includes running `doctest`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `recipe25.py` to put all the code for this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add code that parses a set of options using Python''s `getopt` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function that maps to `-test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function that maps to `-doctest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create stub functions that support `package`, `publish`, and `register`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some code that detects if the option list is empty. If so, have it print
    out the help menu and exit the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some code that defines debug levels and then parses options to allow the
    user to override:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some code that scans the command-line options for `-help`, and, if found,
    exits the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Add code that checks if `--doctest` has been picked. If so, have it specifically
    scan `--suite` and run it through the `doctest()` method. Otherwise, run `-suite`
    through the  `test()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finish it by iterating through each of the command-line options, and invoking
    the other functions based on the options that are picked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script with `--help`, as shown in the screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the script with `--doctest`. Notice the first few lines of output in the
    following screenshot. It shows how the tests have passed and failed along with
    detailed output. Take a look at this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00055.jpeg)The output is much longer. It has been trimmed for
    the sake of brevity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the script with `-doctest -suite=recipe16,recipe17.py`, as shown in the
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00056.jpeg)We deliberately used `recipe16.py` and `recipe17.py`
    to demonstrate that it works with both module names and filenames.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This script uses Python's `getopt` library, which is modeled after the `getopt()`
    function (refer to [http://docs.python.org/library/getopt.html](http://docs.python.org/library/getopt.html)
    for more details).
  prefs: []
  type: TYPE_NORMAL
- en: 'We have wired the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Usage`: A function to provide help to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Key`: The key option definitions are included in the following block:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We parse everything in the arguments except the first, it being the executable
    itself.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"h"` defined the short option: `-h`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list defines long options. Those with `"="` accept an argument. Those without
    are flags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an option is received that isn't in the list, an exception is thrown, we
    print out `usage()`, and then exit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doctest`: It runs modules through nose using `-with-doctest`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package`, `pubilsh`, and `register`: These are just like the functions described
    in the previous chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With each of these functions defined, we can now iterate over the options that
    were parsed. For this script, there is a sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether there is a debugging override. We default to `logging.INFO`, but
    we provide the ability to switch to `logging.DEBUG`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether `-h` or `-help` was called. If so, print out the `usage()` information
    and then exit with no more parsing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because `-suite` can be used either by itself to run unittest tests, or as a
    suboption for `-doctest`, we have to parse through things and figure out whether `-doctest`
    was used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, iterate over the options, and call their corresponding functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To exercise things, we first called this script with the `-help` option that
    printed out the command choices we had.
  prefs: []
  type: TYPE_NORMAL
- en: Then we called it with `-doctest` to see how it handled finding all the doctests
    in this folder. In our case, we found all the recipes for this chapter including
    three test failures.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we called the script with `-doctest -suite=recipe16,recipe17.py`. This
    shows how we can pick a subset of tests delineated by the comma. With this example,
    we see that nose can process either by the module name (`recipe16.py`) or by the
    filename (`recipe17.py`).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The features this script provides could easily be handled by commands that are
    already built. We looked at `nosetests` with `doctest` earlier in this chapter
    and saw how it can take arguments to pick tests flexibly.
  prefs: []
  type: TYPE_NORMAL
- en: Using `setup.py` to generate tarballs and register releases is also a commonly
    used feature in the Python community.
  prefs: []
  type: TYPE_NORMAL
- en: So why write this script? Because, we can exploit all these features with a
    single command.
  prefs: []
  type: TYPE_NORMAL
