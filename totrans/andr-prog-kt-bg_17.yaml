- en: Chapter 17. Data Persistence and Sharing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章。数据持久性和共享
- en: In this chapter, we will look at a couple of different ways to save data to
    an Android device's permanent storage. Also, for the first time, we will add a
    second `Activity` instance to our app. It often makes sense when implementing
    a separate "screen", such as a "Settings" screen, in our app to do so in a new
    `Activity` instance. We could go to the trouble of hiding the original UI and
    then showing the new UI in the same `Activity`, as we did in [Chapter 4](ch04.html
    "Chapter 4. Getting Started with Layouts and Material Design"), *Getting Started
    with Layouts and Material Design*, but this would quickly lead to confusing and
    error-prone code. So, we will see how to add another `Activity` instance and navigate
    the user between them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨将数据保存到Android设备的永久存储的几种不同方法。此外，我们还将首次向我们的应用程序添加第二个`Activity`实例。在我们的应用程序中实现一个单独的“屏幕”，比如“设置”屏幕时，这通常是有意义的，可以在一个新的`Activity`实例中这样做。我们可以通过在同一个`Activity`中隐藏原始UI然后显示新UI的方式来做到这一点，就像我们在[第4章](ch04.html
    "第4章。开始使用布局和材料设计")中所做的那样，*开始使用布局和材料设计*，但这很快会导致混乱和容易出错的代码。因此，我们将看到如何添加另一个`Activity`实例并在它们之间导航用户。
- en: 'In this chapter, we will do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将执行以下操作：
- en: Learn about the Android `Intent` class to switch `Activity` instances and pass
    data between them
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Android `Intent`类以在`Activity`实例之间切换并在它们之间传递数据
- en: Create a very simple settings screen in a new `Activity` instance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个新的`Activity`实例中创建一个非常简单的设置屏幕
- en: Persist the settings screen data using the `SharedPreferences` class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SharedPreferences`类持久保存设置屏幕数据
- en: Learn about **JavaScript Object Notation** (**JSON**) for serialization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解**JavaScript对象表示**（**JSON**）进行序列化
- en: Explore `try`-`catch`-`finally`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索`try`-`catch`-`finally`
- en: Implement saving data in our Note to self app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的备忘录应用程序中实现数据保存
- en: The Android Intent class
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android Intent类
- en: The `Intent` class is appropriately named. It is a class that demonstrates the
    intent of an `Activity` instance from our app. It makes intent clear and it also
    facilitates it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intent`类的命名恰如其分。它是一个展示我们应用程序的`Activity`实例意图的类。它使意图清晰并且也促进了它。'
- en: All our apps so far have had just one `Activity` instance but many Android apps
    comprise more than one.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的所有应用程序都只有一个`Activity`实例，但许多Android应用程序包含多个。
- en: In perhaps its most common use, an `Intent` object allows us to switch between
    `Activity` instances. But, of course, `Activity` instances are made from classes.
    So, what happens to the data when we switch between these classes? The `Intent`
    class handles this problem for us as well by allowing us to pass data between
    them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在它可能最常见的用法中，`Intent`对象允许我们在`Activity`实例之间切换。但是，当我们在这些类之间切换时，数据会发生什么？`Intent`类也通过允许我们在它们之间传递数据来解决了这个问题。
- en: '`Intent` classes aren''t just about wiring up the Activities of our app. They
    also make it possible to interact with other apps, too. For example, we could
    provide a link in our app for the user to send an email, make a phone call, interact
    with social media, or open a web page in a browser, and have the email, dialer,
    web browser, or relevant social media app do all the work.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intent`类不仅仅是关于连接我们应用程序的活动。它们还使与其他应用程序进行交互成为可能。例如，我们可以在我们的应用程序中提供一个链接，让用户发送电子邮件，打电话，与社交媒体互动，或在浏览器中打开网页，并让电子邮件、拨号器、网络浏览器或相关的社交媒体应用程序完成所有工作。'
- en: There aren't enough pages to really dig deep into interacting with other apps,
    and so we will mainly focus on switching between Activities and passing data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 没有足够的页面来深入了解与其他应用程序的交互，因此我们主要将专注于在活动之间切换和传递数据。
- en: Switching Activity
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切换Activity
- en: 'Let''s say we have an app with two `Activity`-based classes, and we will soon.
    We can assume that, as usual, we have an `Activity` instance called `MainActivity`,
    which is where the app starts, and a second `Activity` instance called `SettingsActivity`.
    This is how we can swap from `MainActivity` to `SettingsActivity`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个基于两个`Activity`的类的应用程序，很快我们就会有。我们可以假设，像往常一样，我们有一个名为`MainActivity`的`Activity`实例，这是应用程序的起点，以及一个名为`SettingsActivity`的第二个`Activity`实例。这是我们如何从`MainActivity`切换到`SettingsActivity`的方法：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Look carefully at how we initialized the `Intent` object. `Intent` has a constructor
    that takes two arguments. The first is a reference to the current `Activity` instance,
    `this`. The second parameter is the name of the `Activity` instance that we want
    to open, `SettingsActivity::class`. The `class` on the end of `SettingsActivity`
    makes it the full name of the `Activity` instance as declared in the `AndroidManifest.xml`
    file, and we will peek at that when we experiment with `Intent` shortly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看我们如何初始化`Intent`对象。`Intent`有一个构造函数，它接受两个参数。第一个是对当前`Activity`实例`this`的引用。第二个参数是我们要打开的`Activity`实例的名称，`SettingsActivity::class`。`SettingsActivity`末尾的`class`使其成为`AndroidManifest.xml`文件中声明的`Activity`实例的完整名称，我们将在不久的将来尝试`Intent`时窥探一下。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The odd-looking `.java` on the end is because all the Kotlin code is turned
    into Java byte code, and `SettingsActivity::class.java` is its fully qualified
    name.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来奇怪的`.java`是因为所有的Kotlin代码都被转换为Java字节码，`SettingsActivity::class.java`是它的完全限定名称。
- en: The only problem is that `SettingsActivity` doesn't share any of the data of
    `MainActivity`. In a way, this is a good thing, because if you need all the data
    from `MainActivity`, then it is a reasonable indication that switching `Activity`
    instances might not be the best way of proceeding with your app's design. It is,
    however, unreasonable to have encapsulation so thorough that the two `Activity`
    instances know absolutely nothing about each other.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是`SettingsActivity`不共享`MainActivity`的任何数据。在某种程度上，这是一件好事，因为如果您需要从`MainActivity`获取所有数据，那么这合理地表明切换`Activity`实例可能不是处理应用程序设计的最佳方式。然而，让两个`Activity`实例封装得如此彻底，以至于它们彼此完全不知道，这是不合理的。
- en: Passing data between Activities
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Activity之间传递数据
- en: What if we have a sign-in screen for the user, and we want to pass the login
    credentials to each `Activity` instance of our app? We could do so using the `Intent`
    class.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add data to an `Intent` instance like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In `SettingsActivity`, we could then retrieve the `String` value like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the previous two blocks of code, we switched `Activity` instances in the
    same way as we have already seen. But, before we called `startActivity`, we used
    the `putExtra` function to load a `String` value into `myIntent`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: We add data using **key-value pairs**. Each piece of data needs to be accompanied
    by an **identifier** that can be used in the retrieving `Activity` instance to
    identify and then retrieve the data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The identifier name is arbitrary, but useful/memorable values should be used.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the receiving `Activity` instance, we simply create an `Intent` object
    using the default constructor:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can then retrieve the data using the `extras.getString` function and the
    appropriate identifier from the key-value pair.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The `Intent` class can help us send more complex data than this, but the `Intent`
    class has its limits. For example, we wouldn't be able to send a `Note` object.
    Once we want to start sending more than a few values, it is worth considering
    different tactics.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Adding a settings page to Note to self
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we are armed with all this knowledge about the Android `Intent` class,
    we can add another screen (`Activity`) to our Note to self app: a "Settings" screen.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: We will first create a new `Activity` instance for our new screen and see what
    effect that has on the `AndroidManifest.xml` file. We will then create a very
    simple layout for our settings screen and add the Kotlin code to switch from `MainActivity`
    to the new one. We will, however, defer wiring up our settings screen layout with
    Kotlin until we have learned how to save the users preferred settings to disk.
    We will do this later on in this chapter and then come back to the settings screen
    to make its data persist.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: First, let's code that new `Activity` class. We will call it `SettingsActivity`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Creating the SettingsActivity
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SettingsActivity will be a screen where the user can turn on or off the decorative
    divider between each note in the `RecyclerView` widget. This will not be a very
    comprehensive settings screen, but it will be a useful exercise, and we will see
    switching between the two `Activity` instances in action as well as save data
    to disk. Follow these steps to get started:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: In the project explorer window, right-click the folder that contains all your
    `.kt` files and has the same name as your package. From the pop-up context menu,
    select **New | Activity | Empty Activity**.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Activity Name:** field, enter `SettingsActivity`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave all the other options at their defaults and left-click **Finish**.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Android Studio has created a new `Activity` class for us and its associated
    `.kt` file. Let's take a quick peek at some of the work that was done behind the
    scenes for us, because it is useful to know what is going on.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `AndroidManifest.xml` file from within the `manifests` folder in the
    project explorer. Notice the following new line of code near the end of this file:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is how an `Activity` class is **registered** with the operating system.
    If an `Activity` class is not registered, then an attempt to run it will crash
    the app. We could create an `Activity` class simply by creating a class that extends
    `Activity` (or `AppCompatActivity`) in a new `.kt` file. However, we would then
    have had to add the preceding code ourselves. Also, by using the new activity
    wizard, we got a layout XML file (`activity_settings.xml`) automatically generated
    for us.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Designing the settings screen layout
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will quickly build a user interface for our settings screen; the following
    steps and screenshot should make this straightforward:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Open the `activity_settings.xml` file and switch to the **Design** tab, where
    we will quickly lay out our settings screen.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use this next screenshot as a guide while following the rest of the steps:![Designing
    the settings screen layout](img/B12806_17_01.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop a **Switch** widget onto the center-top of the layout. I stretched
    mine by dragging the edges to make it larger and clearer.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `id` attribute of `switch1` (if it isn't already) so that we can interact
    with it using Kotlin.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the constraint handles to fix the position of the switch, or click the **Infer
    Constraints** button to fix it automatically.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have a nice (and very simple) new layout for our settings screen, and
    the `id` property is in place, ready for when we wire it up with our code later
    in the chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the user to switch to the "Settings" screen
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already know how to create and switch to a `SettingsActivity` instance. Also,
    as we won't be passing any data to it or from it, we can get this working with
    just a few lines of Kotlin code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed in the action bar of our app there is the menu icon.
    It is indicated in this next screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling the user to switch to the "Settings" screen](img/B12806_17_02.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: 'If you tap it, there is already a menu option in there for **Settings**, provided
    by default when we first created the app. This is what you will see when you tap
    the menu icon:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling the user to switch to the "Settings" screen](img/B12806_17_03.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: All we need to do is place our code to create and switch to the `SettingsActivity`
    instance within the `onOptionsItemSelected` function in the `MainActivity.kt`
    file. Android Studio even provides a `when` block by default for us to paste our
    code into, on the assumption that we would one day want to add a settings menu.
    How thoughtful.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to `MainActivity.kt` in the editor window and find the following block
    of code in the `onOptionsItemSelected` function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Edit the `when` block shown previously to match the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need to import the `Intent` class using your preferred technique to
    add this line of code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can now run the app and visit the new settings screen by tapping the **Settings**
    menu option. This screenshot shows the settings screen running on the emulator:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling the user to switch to the "Settings" screen](img/B12806_17_04.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: To return from `SettingsActivity` screen to the `MainActivity` screen, you can
    tap the back button on the device.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Persisting data with SharedPreferences
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Android, there are a few ways to make data persist. By persist, I mean that
    if the user quits the app, then when they come back to it their data will still
    be available. Which technique is the correct one to use is dependent upon the
    app and the type of data.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will look at three ways to make data persist. For saving our
    user's settings, we only need a simple method. After all, we just need to know
    whether they want the decorative divider between each of the notes in the `RecyclerView`
    widget.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we can make our apps save and reload variables to the internal
    storage of the device. We need to use the `SharedPreferences` class. `SharedPreferences`
    is a class that provides access to data that can be accessed and edited by all
    the classes of an app. Let''s look at how we can use it:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We initialized the `prefs` object by using the `getSharedPreferences` function
    and passing in a `String` value that will be used to refer to all the data read
    and written using this object. Typically, we could use the name of the app as
    this String value. In the next code, `Mode_Private` means that any class can access
    it, but only from this app.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: We then used our newly initialized `prefs` object to initialize our `editor`
    object by calling the `edit` function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we wanted to save the user''s name, which we have in a `String`
    instance called `username`. We can then write the data to the internal memory
    of the device like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The first argument used in the `putString` function is a label that can be
    used to refer to the data, the second argument is the actual variable that holds
    the data we want to save. The second line in the previous code initiates the saving
    process. So, we could write multiple variables to disk like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: “putString”函数中使用的第一个参数是一个标签，可用于引用数据，第二个参数是保存我们要保存的数据的实际变量。前面代码的第二行启动了保存过程。因此，我们可以像这样将多个变量写入磁盘：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code demonstrates that you can save other variable types and it,
    of course, assumes that the `username`, `age`, and `subscribed` variables have
    previously been declared then initialized with appropriate values.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码演示了您可以保存其他变量类型，并且假设“username”、“age”和“subscribed”变量已经被声明并使用适当的值进行了初始化。
- en: Once `editor.apply()` has executed, the data is stored. We can quit the app,
    even turn off the device, and the data will persist.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦“editor.apply()”执行，数据就被存储了。我们可以退出应用程序，甚至关闭设备，数据仍将持久存在。
- en: Reloading data with SharedPreferences
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SharedPreferences重新加载数据
- en: 'Let''s see how we can reload our data the next time the app is run. This code
    will reload the three values that the previous code saved. We could even declare
    our variables and initialize them with the stored values:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一次应用程序运行时如何重新加载我们的数据。这段代码将重新加载前一段代码保存的三个值。我们甚至可以声明变量并使用存储的值进行初始化：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the previous code, we load the data from disk using the function appropriate
    for the data type and the same label we used to save the data in the first place.
    What is less clear is the second argument to each of the function calls.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了适用于数据类型的函数从磁盘加载数据，并使用了与我们首次保存数据时使用的相同标签。不太清楚的是每个函数调用的第二个参数。
- en: The `getString`, `getInt`, and `getBoolean` functions require a default value
    as the second argument. If there is no data stored with that label, it will then
    return the default value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: “getString”、“getInt”和“getBoolean”函数需要第二个参数作为默认值。如果没有存储带有该标签的数据，它将返回默认值。
- en: 'We could then check for these default values in our code and go about trying
    to obtain the required values or handling an error. For example, see the following
    code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在我们的代码中检查这些默认值，并尝试获取所需的值或处理错误。例如，参见以下代码：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We now know enough to save our user's settings in the Note to self app.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解足够的知识来保存用户的设置在Note to self应用程序中。
- en: Making the Note to self settings persist
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使自我备忘录设置持久化
- en: We have already learned how to save data to the device's memory. As we implement
    saving the user's settings, we will, again, see how we handle the `Switch` widget
    input and where exactly the code we have just seen will go to make our app work
    the way we want it to.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何将数据保存到设备的内存中。当我们实现保存用户的设置时，我们将再次看到我们如何处理“Switch”小部件的输入，以及我们刚刚看到的代码将如何使我们的应用程序按照我们想要的方式工作。
- en: Coding the SettingsActivity class
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写SettingsActivity类
- en: Most of the action will take place in the `SettingsActivity.kt` file. So, click
    on the appropriate tab and we will add the code a bit at a time.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分操作将在“SettingsActivity.kt”文件中进行。因此，点击适当的选项卡，我们将逐步添加代码。
- en: First, we want a property to represent the user's option on the settings screen
    – whether they want decorative dividers or not.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们希望有一个属性来表示用户在设置屏幕上的选项 - 他们是否想要装饰性分隔线。
- en: 'Add the following to `SettingsActivity`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到“SettingsActivity”中：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, in `onCreate`, add the highlighted code to initialize `prefs`, which is
    inferred to be a `SharedPreferences` instance:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在“onCreate”中，添加突出显示的代码以初始化“prefs”，它被推断为“SharedPreferences”实例：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Import the `SharedPreferences` class:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 导入“SharedPreferences”类：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, still in `onCreate`, let''s load up the saved data, which represents
    our user''s previous choice for whether to show the dividers. We will set the
    switch to either on or off, as appropriate:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在“onCreate”中，让我们加载保存的数据，这些数据代表我们的用户以前选择是否显示分隔线。我们将根据需要将开关设置为打开或关闭：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we will create a lambda to handle changes to our `Switch` widget. We
    simply set the value of `showDividers` to be the same as the `isChecked` variable
    of the `Switch` widget. Add the following code to the `onCreate` function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个lambda来处理我们的“Switch”小部件的更改。我们只需将“showDividers”的值设置为“Switch”小部件的“isChecked”变量相同。将以下代码添加到“onCreate”函数中：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You might have noticed that we did not write any values to the device storage
    at any point in any of that code. We could have placed it after we detected a
    change to the switch, but it is much simpler to put it where it is guaranteed
    to be called – but only once.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在任何代码中的任何时候，我们都没有将任何值写入设备存储。我们可以在检测到开关变化后放置它，但是将它放在保证被调用的地方要简单得多 -
    但只有一次。
- en: 'We will use our knowledge of the `Activity` lifecycle and override the `onPause`
    function. When the user leaves the `SettingsActivity` screen, either to go back
    to the `MainActivity` screen or to quit the app, `onPause` will be called and
    the settings will be saved. This way, the user can flip the switch as often as
    they like, and the app will save their final decision. Add this code to override
    the `onPause` function and save the user''s settings. Add the code just before
    the closing curly brace of the `SettingsActivity` class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用我们对“Activity”生命周期的了解，并覆盖“onPause”函数。当用户离开“SettingsActivity”屏幕时，无论是返回“MainActivity”屏幕还是退出应用程序，“onPause”都将被调用，并且设置将被保存。这样，用户可以随意切换开关，应用程序将保存他们的最终决定。添加此代码以覆盖“onPause”函数并保存用户的设置。将此代码添加到“SettingsActivity”类的结束大括号之前：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code declares and initializes a new `SharedPreferences` instance
    in private mode, using the name of the app. It also declares and initializes a
    new `SharedPreferences.Editor` instance. Finally, the value is entered into the
    `editor` object using `putBoolean`, and written to the disk using the `apply`
    function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在私有模式下声明和初始化了一个新的“SharedPreferences”实例，使用了应用程序的名称。它还声明和初始化了一个新的“SharedPreferences.Editor”实例。最后，使用“putBoolean”将值输入到“editor”对象中，并使用“apply”函数写入磁盘。
- en: Now, we can add some code to `MainActivity` to load the settings when the app
    starts, or when the user switches back from the settings screen to the main screen.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Coding the MainActivity class
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add this highlighted code after the `NoteAdapter` declaration:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we have a `Boolean` property to decide whether to show the dividers. We
    will override the `onResume` function and initialize our `Boolean` property. Add
    the overridden `onResume` function, as shown next to the `MainActivity` class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The user is now able to choose their settings. The app will both save and reload
    them as necessary, but we need to make `MainActivity` respond to the user's choice.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Find this code in the `onCreate` function and delete it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The previous code is what set the dividers between each note in the list. Add
    this new code to the `onResume` function, which is the same line of code surrounded
    by an `if` statement, to selectively use dividers only when `showDividers` is
    `true`. Add the code after the previous code in `onResume`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the app and you''ll notice the dividers are gone; go to the settings screen,
    switch on the dividers, return to the main screen (with the back button), and
    behold: there are now separators. This next screenshot shows the list with and
    without separators, photoshopped side by side, to illustrate that the switch works,
    and that the settings persist between the two `Activity` instances:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding the MainActivity class](img/B12806_17_05.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: Be sure to try quitting the app and restarting to verify that the settings are
    saved to disk. You can even turn the emulator off and back on again and the settings
    will persist.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a neat settings screen, and we can permanently save the users choices.
    Of course, the big missing link regarding persistence is that the user's fundamental
    data, their notes, still does not persist.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: More advanced persistence
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's think about what we need to do. We want to save a bunch of notes to the
    internal storage. Being more specific, we want to store a selection of Strings
    and related Boolean values. These Strings and Boolean values represent the user's
    note title, the text, and whether it is a to-do, important, or an idea.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Given what we already know about the `SharedPreferences` class, at first glance,
    this might not seem especially challenging – until we dig a little deeper into
    our requirements. What if the user loves our app and ends up with 100 notes? We
    would need 100 identifiers for key-value pairs. Not impossible, but starting to
    get awkward.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine that we wanted to enhance the app and give the user the ability
    to add dates to them. Android has a `Date` class that is perfect for this. It
    would be reasonably straightforward to then add neat features, such as reminders,
    to our app. But when it comes to saving data, things suddenly start to get complicated.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: How would we store a date using `SharedPreferences`? It wasn't designed for
    this. We could convert it to a String value when we save it, and then could convert
    it back again when we load it, but this is far from simple.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: And, as our app grows in features and our users get more and more notes, the
    whole persistence thing becomes a nightmare. What we need is a way to save and
    load actual Kotlin objects. If we can simply save and load objects, including
    their internal data (Strings, Booleans, dates, or anything else), our apps can
    have any kind of data we need to suit our users.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The process of converting data objects into bits and bytes to store on a disk
    is called **serialization**; the reverse process is called **de-serialization**.
    Serialization on its own is a vast topic and is far from straightforward. Fortunately,
    as we are coming to expect, there is a class to handle most of the complexity
    for us.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: What is JSON?
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JSON** stands for **JavaScript Object Notation**, and it is widely used in
    fields beyond Android programming. It is perhaps more frequently used for sending
    data between web applications and servers.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there are JSON classes available for Android that almost entirely
    hide the complexity of the serialization process. By learning about a few more
    Kotlin concepts, we can quickly begin to use these classes and start writing entire
    Kotlin objects to the device storage, rather than worry ourselves about what primitive
    types make up the objects.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The JSON classes, when compared with other classes we have seen so far, undertake
    operations that have a higher than normal possibility of failure beyond their
    control. To find out why this is so and what can be done about it, let's look
    at **exceptions**.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions – try, catch, and finally
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All this talk of JSON requires us to learn another Kotlin concept: **exceptions**.
    When we write a class that performs operations that have a possibility of failure,
    especially for reasons beyond our control, it is advisable to make this plain
    in our code so that anyone using our class is prepared for the possibility.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading data is one such scenario where failure is possible beyond
    our control. Think about trying to load data when the SD card has been removed
    or has been corrupted. Another instance where code might fail is perhaps when
    we write code that relies on a network connection – what if the user goes offline
    part of the way through a data transfer?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin exceptions are the solution, and the JSON classes use them, so it is
    a good time to learn about them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: When we write a class that uses code with a chance of failure, we can prepare
    the users of our class by using exceptions with `try`, `catch`, and `finally`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write functions in our classes using the @`Throws` annotation before
    the signature; a bit like this, perhaps:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, any code that uses `somePrecariousFunction` will need to **handle** the
    exception. The way that we handle exceptions is by wrapping code in `try` and
    `catch` blocks; perhaps like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Optionally, we can also add a `finally` block if we want to take any further
    action after the `try` and `catch` blocks:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In our Note to self app, we will take the minimum of necessary action to handle
    exceptions, and simply output an error to the logcat window, but you could do
    things such as notify the user, retry the operation, or put into operation some
    clever back-up plan.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Backing up user data in Note to self
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, with our new-found insight into exceptions, let's modify our Note to self
    code, and then we can be introduced to `JSONObject` and `JSONException`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: First, let's make some minor modifications to our `Note` class.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Add some more properties that will act as the key in a key-value pair for each
    aspect of our `Note` class:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, add a constructor and an empty default constructor that receives a `JSONObject`
    reference and throws a `JSONException` error. The body of the first constructor
    initializes each of the members that define the properties of a single `Note`
    object by calling the `getString` or `getBoolean` function of the `JSONObject`
    class, passing in the key as an argument. We also provide an empty constructor,
    which is required so that we can also create a `Note` object with uninitialized
    properties:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need to import the `JSONException` and `JSONObject` classes:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The next code we will see will load the property values of a given `Note` object
    into a `JSONObject` instance. This is where the `Note` object's values are packed
    up ready for when the actual serialization takes place.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do is call `put` with the appropriate key and the matching property.
    This function returns `JSONObject` (we will see where to in a minute) and also
    throws a `JSONObject` exception. Add the code we have just discussed:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, let's make a `JSONSerializer` class, which will perform the actual serialization
    and deserialization. Create a new Kotlin class and call it `JSONSerializer`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Let's split up the coding into a few chunks and talk about what we are doing
    as we code each chunk.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the declaration and a couple of properties: a `String` instance to hold
    the filename where the data will be saved, and a `Context` instance, which is
    necessary in Android for writing data to a file. Edit the `JSONSerializer` class
    code to be the same as the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，声明和一些属性：一个`String`实例来保存数据的文件名，以及一个`Context`实例，在Android中写入数据到文件是必要的。编辑`JSONSerializer`类的代码如下所示：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Tip
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You will need to import the `Context` class:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要导入`Context`类：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now we can start coding the real guts of the class. The `save` function is next.
    It first creates a `JSONArray` object, which is a specialized `ArrayList` class
    for handling JSON objects.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始编写类的真正核心部分。接下来是`save`函数。它首先创建一个`JSONArray`对象，这是一个专门处理JSON对象的`ArrayList`类。
- en: Next, the code uses a `for` loop to go through all the `Note` objects in `notes`
    and convert them to JSON objects using the `convertToJSON` function from the `Note`
    class that we added previously. Then, we load these converted `JSONObjects` into
    `jArray`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码使用`for`循环遍历`notes`中的所有`Note`对象，并使用我们之前添加的`Note`类的`convertToJSON`函数将它们转换为JSON对象。然后，将这些转换后的`JSONObject`加载到`jArray`中。
- en: 'Next, the code uses a `Writer` instance and an `Outputstream` instance combined
    to write the data to an actual file. Notice that the `OutputStream` instance needed
    the `Context` object. Add the code we have just discussed:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码使用`Writer`实例和`Outputstream`实例组合将数据写入实际文件。注意，`OutputStream`实例需要`Context`对象。添加我们刚刚讨论过的代码：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Tip
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You will need to add the following import statements for these new classes:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为这些新类添加以下导入语句：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now for the de-serialization – loading the data. This time, as we might expect,
    the function has no parameters, but instead returns `ArrayList`. An `InputStream`
    instance is created using `context.openFileInput`, and our file containing all
    our data is opened.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进行反序列化 - 加载数据。这次，正如我们所期望的那样，该函数没有参数，而是返回`ArrayList`。使用`context.openFileInput`创建一个`InputStream`实例，并打开包含所有数据的文件。
- en: 'We use a `for` loop to append all the data to a `String` object and use our
    new `Note` constructor, which extracts JSON data to regular properties to unpack
    each `JSONObject` into a `Note` object and add it to `ArrayList`, which is finally
    returned to the calling code. Add the `load` function:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`for`循环将所有数据追加到一个`String`对象中，并使用我们的新`Note`构造函数，将每个`JSONObject`解包为`Note`对象并将其添加到`ArrayList`中，最后将其返回给调用代码。添加`load`函数：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Tip
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You will need to add these imports:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要添加这些导入：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, all we need to do is put our new class to work in the `MainActivity` class.
    Add a new property after the `MainActivity` declaration as shown next. Also, remove
    the initialization of `noteList` to leave just the declaration, as we will now
    initialize it with some new code in the `onCreate` function. I have commented
    out the line you need to delete:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在`MainActivity`类中让我们的新类开始工作。在`MainActivity`声明之后添加一个新属性，如下所示。此外，删除`noteList`的初始化，只留下声明，因为我们现在将在`onCreate`函数中使用一些新代码进行初始化。我已经注释掉了你需要删除的那行：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, in the `onCreate` function, we initialize `mSerializer` by calling the
    `JSONSerializer` constructor with the filename and `getApplicationContext()`,
    which is the `Context` instance of the application and is required. We can then
    use the `JSONSerializer load` function to load any saved data. Add this new highlighted
    code after the code that handles the floating action button. This new code must
    come before the code where we initialize the `RecyclerView` instance:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`onCreate`函数中，我们通过使用文件名和`getApplicationContext()`调用`JSONSerializer`构造函数来初始化`mSerializer`，这是应用程序的`Context`实例，是必需的。然后我们可以使用`JSONSerializer
    load`函数来加载任何保存的数据。在处理浮动操作按钮的代码之后添加这段新的突出代码。这段新代码必须出现在我们初始化`RecyclerView`实例的代码之前：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Tip
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I have shown a great deal of context in the previous code because its correct
    positioning is necessary for it to work. If you are having any problems getting
    this to work, be sure to compare it to the code in the download bundle in the
    `Chapter17/Note to self` folder.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一段代码中，我展示了大量的上下文，因为它的正确位置对其工作是必要的。如果你在使用过程中遇到任何问题，请确保将其与“Chapter17/Note to
    self”文件夹中的下载包中的代码进行比较。
- en: 'Now, add a new function to our `MainActivity` class so that that we can call
    it to save all our user''s data. All that this new function does is call the `save`
    function of the `JSONSerializer` class, passing in the required list of `Note`
    objects:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的`MainActivity`类中添加一个新函数，以便我们可以调用它来保存所有用户的数据。这个新函数所做的就是调用`JSONSerializer`类的`save`函数，传入所需的`Note`对象列表：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we will override the `onPause` function to save our user''s data just
    as we did when saving our user''s settings. Be sure to add this code in the `MainActivity`
    class:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将重写`onPause`函数，以保存我们用户的数据，就像我们保存用户设置时所做的那样。确保在`MainActivity`类中添加这段代码：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: That's it. We can now run the app and add as many notes as we like. The `ArrayList`
    instance will store them all in our running app, our `RecyclerAdapter` will manage
    displaying them in the `RecyclerView` widget, and now JSON will take care of loading
    them from disk and saving them back to disk as well.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在我们可以运行应用程序，并添加尽可能多的笔记。`ArrayList`实例将把它们全部存储在我们的运行应用程序中，我们的`RecyclerAdapter`将管理在`RecyclerView`小部件中显示它们，现在JSON将负责从磁盘加载它们，并将它们保存回磁盘。
- en: Frequently asked questions
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题
- en: Q.1) I didn't understand everything in this chapter, so am I cut out to be a
    programmer?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Q.1)我并没有完全理解本章的所有内容，那我适合成为程序员吗？
- en: A) This chapter introduced many new classes, concepts, and functions. If your
    head is aching a little, that is to be expected. If some of the detail is unclear,
    don't let it hold you back. Proceed with the next couple of chapters (they are
    much more straightforward), then revisit this one, and especially examine the
    completed code files.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: A) 本章介绍了许多新的类、概念和函数。如果你感到有些头痛，这是可以预料的。如果一些细节不清楚，不要让它阻碍你。继续进行下一章（它们要简单得多），然后回顾这一章，特别是检查已完成的代码文件。
- en: Q.2) So, how does serialization work in detail?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Q.2)那么，序列化的详细工作原理是什么？
- en: 'A) Serialization really is a vast topic. It is possible to write apps your
    whole life and never really need to understand it. It is the type of topic that
    would be the subject of a computer science degree. If you are curious to know
    more, have a look at this article: [https://en.wikipedia.org/wiki/Serialization](https://en.wikipedia.org/wiki/Serialization).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: A）序列化确实是一个广阔的话题。你可以一辈子写应用程序，而不真正需要理解它。这是一种可能成为计算机科学学位课程主题的话题。如果你想了解更多，请看看这篇文章：[https://en.wikipedia.org/wiki/Serialization](https://en.wikipedia.org/wiki/Serialization)。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: At this point in our journey through the Android API, it is worth taking stock
    of what we know. We can lay out our own UI designs, and can choose from a wide
    and diverse range of widgets to allow the user to interact. We can create multiple
    screens, as well as pop-up dialogs, and we can capture comprehensive user data.
    Furthermore, we can now make this data persist.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们通过Android API的旅程中，现在值得回顾一下我们所知道的。我们可以制定自己的UI设计，并可以从各种各样的小部件中进行选择，以便让用户进行交互。我们可以创建多个屏幕，以及弹出对话框，并且可以捕获全面的用户数据。此外，我们现在可以使这些数据持久化。
- en: Certainly, there is a lot more to the Android API still to learn, even beyond
    what this book will teach you, but the point is that we know enough now to plan
    and implement a working app. You could get started on your own app right now.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Android API还有很多东西需要学习，甚至超出了这本书会教给你的内容，但关键是我们现在知道足够的知识来规划和实施一个可工作的应用程序。你现在就可以开始自己的应用程序了。
- en: If you have the urge to start your own project right away, then my advice is
    to go ahead and do it. Don't wait until you consider yourself "expert" or more
    ready. Reading this book and, more importantly, implementing the apps will make
    you a better Android programmer, but nothing will teach you faster than designing
    and implementing your own app! It is perfectly possible to read this book and
    work on your own project simultaneously.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有立即开始自己的项目的冲动，那么我的建议是继续前进并去做。不要等到你认为自己是“专家”或更加准备好了。阅读这本书，更重要的是，实施这些应用程序将使你成为更好的Android程序员，但没有什么比设计和实施自己的应用程序更能让你更快地学会。完全可以阅读这本书并同时在自己的项目上工作。
- en: In the next chapter, we will add the finishing touches to this app by making
    it multilingual. This is quite quick and easy.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过使应用程序支持多语言来为这个应用程序添加最后的修饰。这是相当快速和简单的。
