- en: Chapter 17. Data Persistence and Sharing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at a couple of different ways to save data to
    an Android device's permanent storage. Also, for the first time, we will add a
    second `Activity` instance to our app. It often makes sense when implementing
    a separate "screen", such as a "Settings" screen, in our app to do so in a new
    `Activity` instance. We could go to the trouble of hiding the original UI and
    then showing the new UI in the same `Activity`, as we did in [Chapter 4](ch04.html
    "Chapter 4. Getting Started with Layouts and Material Design"), *Getting Started
    with Layouts and Material Design*, but this would quickly lead to confusing and
    error-prone code. So, we will see how to add another `Activity` instance and navigate
    the user between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about the Android `Intent` class to switch `Activity` instances and pass
    data between them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a very simple settings screen in a new `Activity` instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persist the settings screen data using the `SharedPreferences` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about **JavaScript Object Notation** (**JSON**) for serialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore `try`-`catch`-`finally`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement saving data in our Note to self app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Android Intent class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Intent` class is appropriately named. It is a class that demonstrates the
    intent of an `Activity` instance from our app. It makes intent clear and it also
    facilitates it.
  prefs: []
  type: TYPE_NORMAL
- en: All our apps so far have had just one `Activity` instance but many Android apps
    comprise more than one.
  prefs: []
  type: TYPE_NORMAL
- en: In perhaps its most common use, an `Intent` object allows us to switch between
    `Activity` instances. But, of course, `Activity` instances are made from classes.
    So, what happens to the data when we switch between these classes? The `Intent`
    class handles this problem for us as well by allowing us to pass data between
    them.
  prefs: []
  type: TYPE_NORMAL
- en: '`Intent` classes aren''t just about wiring up the Activities of our app. They
    also make it possible to interact with other apps, too. For example, we could
    provide a link in our app for the user to send an email, make a phone call, interact
    with social media, or open a web page in a browser, and have the email, dialer,
    web browser, or relevant social media app do all the work.'
  prefs: []
  type: TYPE_NORMAL
- en: There aren't enough pages to really dig deep into interacting with other apps,
    and so we will mainly focus on switching between Activities and passing data.
  prefs: []
  type: TYPE_NORMAL
- en: Switching Activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say we have an app with two `Activity`-based classes, and we will soon.
    We can assume that, as usual, we have an `Activity` instance called `MainActivity`,
    which is where the app starts, and a second `Activity` instance called `SettingsActivity`.
    This is how we can swap from `MainActivity` to `SettingsActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Look carefully at how we initialized the `Intent` object. `Intent` has a constructor
    that takes two arguments. The first is a reference to the current `Activity` instance,
    `this`. The second parameter is the name of the `Activity` instance that we want
    to open, `SettingsActivity::class`. The `class` on the end of `SettingsActivity`
    makes it the full name of the `Activity` instance as declared in the `AndroidManifest.xml`
    file, and we will peek at that when we experiment with `Intent` shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The odd-looking `.java` on the end is because all the Kotlin code is turned
    into Java byte code, and `SettingsActivity::class.java` is its fully qualified
    name.
  prefs: []
  type: TYPE_NORMAL
- en: The only problem is that `SettingsActivity` doesn't share any of the data of
    `MainActivity`. In a way, this is a good thing, because if you need all the data
    from `MainActivity`, then it is a reasonable indication that switching `Activity`
    instances might not be the best way of proceeding with your app's design. It is,
    however, unreasonable to have encapsulation so thorough that the two `Activity`
    instances know absolutely nothing about each other.
  prefs: []
  type: TYPE_NORMAL
- en: Passing data between Activities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if we have a sign-in screen for the user, and we want to pass the login
    credentials to each `Activity` instance of our app? We could do so using the `Intent`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add data to an `Intent` instance like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In `SettingsActivity`, we could then retrieve the `String` value like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the previous two blocks of code, we switched `Activity` instances in the
    same way as we have already seen. But, before we called `startActivity`, we used
    the `putExtra` function to load a `String` value into `myIntent`.
  prefs: []
  type: TYPE_NORMAL
- en: We add data using **key-value pairs**. Each piece of data needs to be accompanied
    by an **identifier** that can be used in the retrieving `Activity` instance to
    identify and then retrieve the data.
  prefs: []
  type: TYPE_NORMAL
- en: The identifier name is arbitrary, but useful/memorable values should be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the receiving `Activity` instance, we simply create an `Intent` object
    using the default constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can then retrieve the data using the `extras.getString` function and the
    appropriate identifier from the key-value pair.
  prefs: []
  type: TYPE_NORMAL
- en: The `Intent` class can help us send more complex data than this, but the `Intent`
    class has its limits. For example, we wouldn't be able to send a `Note` object.
    Once we want to start sending more than a few values, it is worth considering
    different tactics.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a settings page to Note to self
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we are armed with all this knowledge about the Android `Intent` class,
    we can add another screen (`Activity`) to our Note to self app: a "Settings" screen.'
  prefs: []
  type: TYPE_NORMAL
- en: We will first create a new `Activity` instance for our new screen and see what
    effect that has on the `AndroidManifest.xml` file. We will then create a very
    simple layout for our settings screen and add the Kotlin code to switch from `MainActivity`
    to the new one. We will, however, defer wiring up our settings screen layout with
    Kotlin until we have learned how to save the users preferred settings to disk.
    We will do this later on in this chapter and then come back to the settings screen
    to make its data persist.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's code that new `Activity` class. We will call it `SettingsActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the SettingsActivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SettingsActivity will be a screen where the user can turn on or off the decorative
    divider between each note in the `RecyclerView` widget. This will not be a very
    comprehensive settings screen, but it will be a useful exercise, and we will see
    switching between the two `Activity` instances in action as well as save data
    to disk. Follow these steps to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: In the project explorer window, right-click the folder that contains all your
    `.kt` files and has the same name as your package. From the pop-up context menu,
    select **New | Activity | Empty Activity**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Activity Name:** field, enter `SettingsActivity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave all the other options at their defaults and left-click **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Android Studio has created a new `Activity` class for us and its associated
    `.kt` file. Let's take a quick peek at some of the work that was done behind the
    scenes for us, because it is useful to know what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `AndroidManifest.xml` file from within the `manifests` folder in the
    project explorer. Notice the following new line of code near the end of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is how an `Activity` class is **registered** with the operating system.
    If an `Activity` class is not registered, then an attempt to run it will crash
    the app. We could create an `Activity` class simply by creating a class that extends
    `Activity` (or `AppCompatActivity`) in a new `.kt` file. However, we would then
    have had to add the preceding code ourselves. Also, by using the new activity
    wizard, we got a layout XML file (`activity_settings.xml`) automatically generated
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the settings screen layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will quickly build a user interface for our settings screen; the following
    steps and screenshot should make this straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `activity_settings.xml` file and switch to the **Design** tab, where
    we will quickly lay out our settings screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use this next screenshot as a guide while following the rest of the steps:![Designing
    the settings screen layout](img/B12806_17_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop a **Switch** widget onto the center-top of the layout. I stretched
    mine by dragging the edges to make it larger and clearer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `id` attribute of `switch1` (if it isn't already) so that we can interact
    with it using Kotlin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the constraint handles to fix the position of the switch, or click the **Infer
    Constraints** button to fix it automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have a nice (and very simple) new layout for our settings screen, and
    the `id` property is in place, ready for when we wire it up with our code later
    in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the user to switch to the "Settings" screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already know how to create and switch to a `SettingsActivity` instance. Also,
    as we won't be passing any data to it or from it, we can get this working with
    just a few lines of Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed in the action bar of our app there is the menu icon.
    It is indicated in this next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling the user to switch to the "Settings" screen](img/B12806_17_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you tap it, there is already a menu option in there for **Settings**, provided
    by default when we first created the app. This is what you will see when you tap
    the menu icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling the user to switch to the "Settings" screen](img/B12806_17_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All we need to do is place our code to create and switch to the `SettingsActivity`
    instance within the `onOptionsItemSelected` function in the `MainActivity.kt`
    file. Android Studio even provides a `when` block by default for us to paste our
    code into, on the assumption that we would one day want to add a settings menu.
    How thoughtful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to `MainActivity.kt` in the editor window and find the following block
    of code in the `onOptionsItemSelected` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `when` block shown previously to match the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need to import the `Intent` class using your preferred technique to
    add this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now run the app and visit the new settings screen by tapping the **Settings**
    menu option. This screenshot shows the settings screen running on the emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling the user to switch to the "Settings" screen](img/B12806_17_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To return from `SettingsActivity` screen to the `MainActivity` screen, you can
    tap the back button on the device.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting data with SharedPreferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Android, there are a few ways to make data persist. By persist, I mean that
    if the user quits the app, then when they come back to it their data will still
    be available. Which technique is the correct one to use is dependent upon the
    app and the type of data.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will look at three ways to make data persist. For saving our
    user's settings, we only need a simple method. After all, we just need to know
    whether they want the decorative divider between each of the notes in the `RecyclerView`
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we can make our apps save and reload variables to the internal
    storage of the device. We need to use the `SharedPreferences` class. `SharedPreferences`
    is a class that provides access to data that can be accessed and edited by all
    the classes of an app. Let''s look at how we can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We initialized the `prefs` object by using the `getSharedPreferences` function
    and passing in a `String` value that will be used to refer to all the data read
    and written using this object. Typically, we could use the name of the app as
    this String value. In the next code, `Mode_Private` means that any class can access
    it, but only from this app.
  prefs: []
  type: TYPE_NORMAL
- en: We then used our newly initialized `prefs` object to initialize our `editor`
    object by calling the `edit` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we wanted to save the user''s name, which we have in a `String`
    instance called `username`. We can then write the data to the internal memory
    of the device like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The first argument used in the `putString` function is a label that can be
    used to refer to the data, the second argument is the actual variable that holds
    the data we want to save. The second line in the previous code initiates the saving
    process. So, we could write multiple variables to disk like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code demonstrates that you can save other variable types and it,
    of course, assumes that the `username`, `age`, and `subscribed` variables have
    previously been declared then initialized with appropriate values.
  prefs: []
  type: TYPE_NORMAL
- en: Once `editor.apply()` has executed, the data is stored. We can quit the app,
    even turn off the device, and the data will persist.
  prefs: []
  type: TYPE_NORMAL
- en: Reloading data with SharedPreferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how we can reload our data the next time the app is run. This code
    will reload the three values that the previous code saved. We could even declare
    our variables and initialize them with the stored values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we load the data from disk using the function appropriate
    for the data type and the same label we used to save the data in the first place.
    What is less clear is the second argument to each of the function calls.
  prefs: []
  type: TYPE_NORMAL
- en: The `getString`, `getInt`, and `getBoolean` functions require a default value
    as the second argument. If there is no data stored with that label, it will then
    return the default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could then check for these default values in our code and go about trying
    to obtain the required values or handling an error. For example, see the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We now know enough to save our user's settings in the Note to self app.
  prefs: []
  type: TYPE_NORMAL
- en: Making the Note to self settings persist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already learned how to save data to the device's memory. As we implement
    saving the user's settings, we will, again, see how we handle the `Switch` widget
    input and where exactly the code we have just seen will go to make our app work
    the way we want it to.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the SettingsActivity class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the action will take place in the `SettingsActivity.kt` file. So, click
    on the appropriate tab and we will add the code a bit at a time.
  prefs: []
  type: TYPE_NORMAL
- en: First, we want a property to represent the user's option on the settings screen
    – whether they want decorative dividers or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following to `SettingsActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in `onCreate`, add the highlighted code to initialize `prefs`, which is
    inferred to be a `SharedPreferences` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Import the `SharedPreferences` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, still in `onCreate`, let''s load up the saved data, which represents
    our user''s previous choice for whether to show the dividers. We will set the
    switch to either on or off, as appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a lambda to handle changes to our `Switch` widget. We
    simply set the value of `showDividers` to be the same as the `isChecked` variable
    of the `Switch` widget. Add the following code to the `onCreate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You might have noticed that we did not write any values to the device storage
    at any point in any of that code. We could have placed it after we detected a
    change to the switch, but it is much simpler to put it where it is guaranteed
    to be called – but only once.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use our knowledge of the `Activity` lifecycle and override the `onPause`
    function. When the user leaves the `SettingsActivity` screen, either to go back
    to the `MainActivity` screen or to quit the app, `onPause` will be called and
    the settings will be saved. This way, the user can flip the switch as often as
    they like, and the app will save their final decision. Add this code to override
    the `onPause` function and save the user''s settings. Add the code just before
    the closing curly brace of the `SettingsActivity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code declares and initializes a new `SharedPreferences` instance
    in private mode, using the name of the app. It also declares and initializes a
    new `SharedPreferences.Editor` instance. Finally, the value is entered into the
    `editor` object using `putBoolean`, and written to the disk using the `apply`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can add some code to `MainActivity` to load the settings when the app
    starts, or when the user switches back from the settings screen to the main screen.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the MainActivity class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add this highlighted code after the `NoteAdapter` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a `Boolean` property to decide whether to show the dividers. We
    will override the `onResume` function and initialize our `Boolean` property. Add
    the overridden `onResume` function, as shown next to the `MainActivity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The user is now able to choose their settings. The app will both save and reload
    them as necessary, but we need to make `MainActivity` respond to the user's choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find this code in the `onCreate` function and delete it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code is what set the dividers between each note in the list. Add
    this new code to the `onResume` function, which is the same line of code surrounded
    by an `if` statement, to selectively use dividers only when `showDividers` is
    `true`. Add the code after the previous code in `onResume`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the app and you''ll notice the dividers are gone; go to the settings screen,
    switch on the dividers, return to the main screen (with the back button), and
    behold: there are now separators. This next screenshot shows the list with and
    without separators, photoshopped side by side, to illustrate that the switch works,
    and that the settings persist between the two `Activity` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding the MainActivity class](img/B12806_17_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Be sure to try quitting the app and restarting to verify that the settings are
    saved to disk. You can even turn the emulator off and back on again and the settings
    will persist.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a neat settings screen, and we can permanently save the users choices.
    Of course, the big missing link regarding persistence is that the user's fundamental
    data, their notes, still does not persist.
  prefs: []
  type: TYPE_NORMAL
- en: More advanced persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's think about what we need to do. We want to save a bunch of notes to the
    internal storage. Being more specific, we want to store a selection of Strings
    and related Boolean values. These Strings and Boolean values represent the user's
    note title, the text, and whether it is a to-do, important, or an idea.
  prefs: []
  type: TYPE_NORMAL
- en: Given what we already know about the `SharedPreferences` class, at first glance,
    this might not seem especially challenging – until we dig a little deeper into
    our requirements. What if the user loves our app and ends up with 100 notes? We
    would need 100 identifiers for key-value pairs. Not impossible, but starting to
    get awkward.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine that we wanted to enhance the app and give the user the ability
    to add dates to them. Android has a `Date` class that is perfect for this. It
    would be reasonably straightforward to then add neat features, such as reminders,
    to our app. But when it comes to saving data, things suddenly start to get complicated.
  prefs: []
  type: TYPE_NORMAL
- en: How would we store a date using `SharedPreferences`? It wasn't designed for
    this. We could convert it to a String value when we save it, and then could convert
    it back again when we load it, but this is far from simple.
  prefs: []
  type: TYPE_NORMAL
- en: And, as our app grows in features and our users get more and more notes, the
    whole persistence thing becomes a nightmare. What we need is a way to save and
    load actual Kotlin objects. If we can simply save and load objects, including
    their internal data (Strings, Booleans, dates, or anything else), our apps can
    have any kind of data we need to suit our users.
  prefs: []
  type: TYPE_NORMAL
- en: The process of converting data objects into bits and bytes to store on a disk
    is called **serialization**; the reverse process is called **de-serialization**.
    Serialization on its own is a vast topic and is far from straightforward. Fortunately,
    as we are coming to expect, there is a class to handle most of the complexity
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: What is JSON?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JSON** stands for **JavaScript Object Notation**, and it is widely used in
    fields beyond Android programming. It is perhaps more frequently used for sending
    data between web applications and servers.'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there are JSON classes available for Android that almost entirely
    hide the complexity of the serialization process. By learning about a few more
    Kotlin concepts, we can quickly begin to use these classes and start writing entire
    Kotlin objects to the device storage, rather than worry ourselves about what primitive
    types make up the objects.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON classes, when compared with other classes we have seen so far, undertake
    operations that have a higher than normal possibility of failure beyond their
    control. To find out why this is so and what can be done about it, let's look
    at **exceptions**.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions – try, catch, and finally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All this talk of JSON requires us to learn another Kotlin concept: **exceptions**.
    When we write a class that performs operations that have a possibility of failure,
    especially for reasons beyond our control, it is advisable to make this plain
    in our code so that anyone using our class is prepared for the possibility.'
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading data is one such scenario where failure is possible beyond
    our control. Think about trying to load data when the SD card has been removed
    or has been corrupted. Another instance where code might fail is perhaps when
    we write code that relies on a network connection – what if the user goes offline
    part of the way through a data transfer?
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin exceptions are the solution, and the JSON classes use them, so it is
    a good time to learn about them.
  prefs: []
  type: TYPE_NORMAL
- en: When we write a class that uses code with a chance of failure, we can prepare
    the users of our class by using exceptions with `try`, `catch`, and `finally`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write functions in our classes using the @`Throws` annotation before
    the signature; a bit like this, perhaps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, any code that uses `somePrecariousFunction` will need to **handle** the
    exception. The way that we handle exceptions is by wrapping code in `try` and
    `catch` blocks; perhaps like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, we can also add a `finally` block if we want to take any further
    action after the `try` and `catch` blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In our Note to self app, we will take the minimum of necessary action to handle
    exceptions, and simply output an error to the logcat window, but you could do
    things such as notify the user, retry the operation, or put into operation some
    clever back-up plan.
  prefs: []
  type: TYPE_NORMAL
- en: Backing up user data in Note to self
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, with our new-found insight into exceptions, let's modify our Note to self
    code, and then we can be introduced to `JSONObject` and `JSONException`.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's make some minor modifications to our `Note` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add some more properties that will act as the key in a key-value pair for each
    aspect of our `Note` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add a constructor and an empty default constructor that receives a `JSONObject`
    reference and throws a `JSONException` error. The body of the first constructor
    initializes each of the members that define the properties of a single `Note`
    object by calling the `getString` or `getBoolean` function of the `JSONObject`
    class, passing in the key as an argument. We also provide an empty constructor,
    which is required so that we can also create a `Note` object with uninitialized
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need to import the `JSONException` and `JSONObject` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The next code we will see will load the property values of a given `Note` object
    into a `JSONObject` instance. This is where the `Note` object's values are packed
    up ready for when the actual serialization takes place.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do is call `put` with the appropriate key and the matching property.
    This function returns `JSONObject` (we will see where to in a minute) and also
    throws a `JSONObject` exception. Add the code we have just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's make a `JSONSerializer` class, which will perform the actual serialization
    and deserialization. Create a new Kotlin class and call it `JSONSerializer`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's split up the coding into a few chunks and talk about what we are doing
    as we code each chunk.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the declaration and a couple of properties: a `String` instance to hold
    the filename where the data will be saved, and a `Context` instance, which is
    necessary in Android for writing data to a file. Edit the `JSONSerializer` class
    code to be the same as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need to import the `Context` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now we can start coding the real guts of the class. The `save` function is next.
    It first creates a `JSONArray` object, which is a specialized `ArrayList` class
    for handling JSON objects.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code uses a `for` loop to go through all the `Note` objects in `notes`
    and convert them to JSON objects using the `convertToJSON` function from the `Note`
    class that we added previously. Then, we load these converted `JSONObjects` into
    `jArray`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the code uses a `Writer` instance and an `Outputstream` instance combined
    to write the data to an actual file. Notice that the `OutputStream` instance needed
    the `Context` object. Add the code we have just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need to add the following import statements for these new classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now for the de-serialization – loading the data. This time, as we might expect,
    the function has no parameters, but instead returns `ArrayList`. An `InputStream`
    instance is created using `context.openFileInput`, and our file containing all
    our data is opened.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use a `for` loop to append all the data to a `String` object and use our
    new `Note` constructor, which extracts JSON data to regular properties to unpack
    each `JSONObject` into a `Note` object and add it to `ArrayList`, which is finally
    returned to the calling code. Add the `load` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need to add these imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all we need to do is put our new class to work in the `MainActivity` class.
    Add a new property after the `MainActivity` declaration as shown next. Also, remove
    the initialization of `noteList` to leave just the declaration, as we will now
    initialize it with some new code in the `onCreate` function. I have commented
    out the line you need to delete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `onCreate` function, we initialize `mSerializer` by calling the
    `JSONSerializer` constructor with the filename and `getApplicationContext()`,
    which is the `Context` instance of the application and is required. We can then
    use the `JSONSerializer load` function to load any saved data. Add this new highlighted
    code after the code that handles the floating action button. This new code must
    come before the code where we initialize the `RecyclerView` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I have shown a great deal of context in the previous code because its correct
    positioning is necessary for it to work. If you are having any problems getting
    this to work, be sure to compare it to the code in the download bundle in the
    `Chapter17/Note to self` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add a new function to our `MainActivity` class so that that we can call
    it to save all our user''s data. All that this new function does is call the `save`
    function of the `JSONSerializer` class, passing in the required list of `Note`
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will override the `onPause` function to save our user''s data just
    as we did when saving our user''s settings. Be sure to add this code in the `MainActivity`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: That's it. We can now run the app and add as many notes as we like. The `ArrayList`
    instance will store them all in our running app, our `RecyclerAdapter` will manage
    displaying them in the `RecyclerView` widget, and now JSON will take care of loading
    them from disk and saving them back to disk as well.
  prefs: []
  type: TYPE_NORMAL
- en: Frequently asked questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q.1) I didn't understand everything in this chapter, so am I cut out to be a
    programmer?
  prefs: []
  type: TYPE_NORMAL
- en: A) This chapter introduced many new classes, concepts, and functions. If your
    head is aching a little, that is to be expected. If some of the detail is unclear,
    don't let it hold you back. Proceed with the next couple of chapters (they are
    much more straightforward), then revisit this one, and especially examine the
    completed code files.
  prefs: []
  type: TYPE_NORMAL
- en: Q.2) So, how does serialization work in detail?
  prefs: []
  type: TYPE_NORMAL
- en: 'A) Serialization really is a vast topic. It is possible to write apps your
    whole life and never really need to understand it. It is the type of topic that
    would be the subject of a computer science degree. If you are curious to know
    more, have a look at this article: [https://en.wikipedia.org/wiki/Serialization](https://en.wikipedia.org/wiki/Serialization).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point in our journey through the Android API, it is worth taking stock
    of what we know. We can lay out our own UI designs, and can choose from a wide
    and diverse range of widgets to allow the user to interact. We can create multiple
    screens, as well as pop-up dialogs, and we can capture comprehensive user data.
    Furthermore, we can now make this data persist.
  prefs: []
  type: TYPE_NORMAL
- en: Certainly, there is a lot more to the Android API still to learn, even beyond
    what this book will teach you, but the point is that we know enough now to plan
    and implement a working app. You could get started on your own app right now.
  prefs: []
  type: TYPE_NORMAL
- en: If you have the urge to start your own project right away, then my advice is
    to go ahead and do it. Don't wait until you consider yourself "expert" or more
    ready. Reading this book and, more importantly, implementing the apps will make
    you a better Android programmer, but nothing will teach you faster than designing
    and implementing your own app! It is perfectly possible to read this book and
    work on your own project simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will add the finishing touches to this app by making
    it multilingual. This is quite quick and easy.
  prefs: []
  type: TYPE_NORMAL
