- en: ASP.NET Core on the MVC Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will explore creating an ASP.NET Core application with the MVC
    framework. The previous chapter introduced you to ASP.NET Core, and we started
    with the basics needed for this chapter. If you are not familiar with ASP.NET
    Core, take a look at what [Chapter 10](2eda8a40-ad8c-45c9-b49e-82a7d208fdf0.xhtml),
    *Exploring .NET Core 1.1* has to offer. We will be looking at:'
  prefs: []
  type: TYPE_NORMAL
- en: Including middleware and why it is useful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Controllers and using routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering Views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MVC framework is named according to the MVC design pattern it follows. MVC
    stands for **M**odel-**V**iew-**C**ontroller. An HTTP request is sent to a Controller,
    which is then mapped to a method inside the *Controller* class. Inside that method,
    the Controller decides what to do with the HTTP request. It then constructs a
    *model* that is agnostic to the Controller and request. The model brings all the
    logic together that contains the information the Controller needs. The *view*
    is then used to display the information contained inside the model to build an
    HTML page that gets sent back to the requesting client in the HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: 'What the MVC framework allows us to do is separate the logic by letting each
    component of the framework focus on one specific thing:'
  prefs: []
  type: TYPE_NORMAL
- en: The Controller receives the HTTP request and builds a model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The model contains the data we requested and sends it to the view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The view then creates the HTML page from the data contained in the model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including middleware and why it is useful
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to set up middleware in your ASP.NET Core application.
    Middleware in ASP.NET defines how our application responds to any HTTP requests
    it receives. It is also useful for controlling how our application responds to
    user authentication or errors. It can also perform logging operations regarding
    incoming request.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to modify the code contained inside the `Configure()` method of our
    `Startup` class. It is here that we set up middleware in an ASP.NET Core application.
    In [Chapter 10](2eda8a40-ad8c-45c9-b49e-82a7d208fdf0.xhtml), *Exploring .NET Core
    1.1*, we saw that our `Configure()` method already contained two pieces of middleware.
    The first is a piece of middleware that will display a developer exception page
    when an unhandled exception is caught. The code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will display any error messages which is useful for debugging the application.
    Typically, this page would contain information such as a stack trace. It is only
    installed when the application is in development mode. When you first create an
    ASP.NET Core application, it is in development mode.
  prefs: []
  type: TYPE_NORMAL
- en: The second middleware is the `app.Run()` and will always be present in your
    application. In [Chapter 10](2eda8a40-ad8c-45c9-b49e-82a7d208fdf0.xhtml), *Exploring
    .NET Core 1.1* , it would always respond with the current date. Think of middleware
    as gate keepers. All HTTP requests coming in to your application must pass through
    your middleware.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to know that the order you add your middleware is important.
    In the `app.Run()` middleware, we did a `context.Response.WriteAsync()`. Any middleware
    added after this will not be reached because the processing pipeline terminates
    in `app.Run()`. This will become clearer as we move on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Your current ASP.NET Core application should contain a `Configure()` method
    that looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'From the Debug menu, click on Start Without Debugging or press *Ctrl* + *F5*.
    You will see the date displayed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Go back to your code and tell your application to display the welcome page
    middleware. You can do this by adding `app.UseWelcomePage();` just before the
    `app.Run()`. Your code needs to look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Save your `Startup.cs` file and refresh your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You now no longer see the date displayed on the screen. This is because the
    welcome page is the terminating middleware and any HTTP requests do not pass through
    that. Go ahead and modify the welcome page middleware to look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you save your file and refresh your browser now, you will see the date displayed
    in the browser again. So what happened? Well you just told the welcome page middleware
    to only respond to requests for a `/hello` page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the URL in the browser as follows `http://localhost:25860/hello` and
    press *Enter*. The welcome page is displayed again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `UseDeveloperExceptionPage()` middleware. Modify
    `app.Run()` to look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Save your changes and refresh your browser. You will see that the browser now
    displays a page that a developer will find extremely useful. It displays the stack
    information, the incoming query, any cookies as well as the header info. It even
    tells us on what line the exception happened (line 36 in the `Startup.cs` file).
    The `UseDeveloperExceptionPage()` middleware allows the request to pass through
    it to the lower middleware. If an exception happens, this would then allow the
    `UseDeveloperExceptionPage()` middleware to do its job. As mentioned earlier,
    the placement of middleware is important. If we had this `UseDeveloperExceptionPage()`
    middleware at the end of the page, it wouldn’t catch any unhandled exceptions.
    It is, therefore, a good idea to have this at the top of your `Configure()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take this concept further. When we are in a production environment,
    we would typically not want the user to see the exception page. Assume that they
    need to be directed to a friendly error page. Start off by adding a static HTML
    page to the wwwroot of your application. Right-click on the wwwroot and select
    Add, New Item from the context menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The wwwroot is where you would serve static pages such as JavaScript files,
    CSS files, images, or static HTML pages.
  prefs: []
  type: TYPE_NORMAL
- en: Select an HTML page, call it `friendlyError.html` and click on Add.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Modify the HTML of `friendlyError.html` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: What we need to do next is add a NuGet package to our application so that we
    can serve static files. In the **NuGet Package Manager**, search for Microsoft.AspNetCore.StaticFiles
    and add that to the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we need to modify the code slightly to simulate that it is running in
    a production environment. We do this by setting the`EnvironmaneName` property
    of the `IHostingEnvironment` interface as follows: `env.EnvironmentName = EnvironmentName.Production;`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then need to add an `else` statement to the `if (env.IsDevelopment())` condition
    and write the code to call our custom, static error page. It is here that we will
    add the `friendlyError.html` file to our `DefaultFileNames()` collection and tell
    our application that we want to use this error file on any exceptions in the production
    environment. Lastly, we need to tell our application to use static files by calling
    the `UseStaticFiles()` method. When complete, your code should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Press *Ctrl* + *F5* again to restart IIS Express and launch our application.
    You will see that our custom error page has been displayed inside the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In reality, we will probably use a controller to do this kind of thing. What
    I wanted to illustrate here was the use of adding a custom default page and to
    display that page when an exception happens in the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, middleware in ASP.NET Core is really useful. There is a lot
    of documentation regarding his topic, and I encourage you to do some further reading
    on the topic. Start with the Microsoft documentation at [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware).
  prefs: []
  type: TYPE_NORMAL
- en: Creating Controllers and using routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inside the MVC framework, the Controllers, Models, and Views need to work together
    to form the HTTP request and response cycle. The fundamental starting point, however,
    is calling the correct Controller based on the HTTP request it receives. Without
    that, our application built on the MVC framework can't work. In the MVC framework,
    the process of calling the correct Controller for the HTTP request is known as
    routing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can route HTTP requests to the correct Controllers by looking at what routing
    information is contained in the middleware of our application. The middleware
    then uses this routing information to see if the HTTP request needs to get sent
    to a Controller or not. Middleware will have a look at the incoming URL and match
    that up with the configuration information we provide it with. We can define this
    routing information in the `Startup` class using one of two routing approaches,
    namely:'
  prefs: []
  type: TYPE_NORMAL
- en: Convention-based routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attribute-based routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This recipe will explore these routing approaches. Before we can do that, we
    need to add the ASP.NET MVC NuGet package to our application. You should be rather
    familiar with adding NuGet packages to your application by now. Inside the NuGet
    Package Manager, browse for and install the Microsoft.AspNetCore.Mvc NuGet package.
    This will expose new middleware for our application, one of which is `app.UseMvc();`.
    This is used to map an HTTP request to a method in one of our Controllers. Modify
    the code in your `Configure()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to register our MVC services that the MVC framework requires
    in order to function. Inside `ConfigureServices()` add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After this is complete, we have the basics set up for MVC to function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add another folder to your application called `Controllers`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside the `Controllers` folder, add a new class called `StudentController`.
    Inside the `StudentController`, add a method called `Find()`. When you are done,
    your class will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in the `Startup` class, add a `private void` method called `FindController()` that
    takes a parameter of type `IRouteBuilder`. Make sure that you also add the `using
    Microsoft.AspNetCore.Routing;` namespace to your class. Your method should look
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the `Configure()` method, change the `app.UseMvc();` to `app.UseMvc(FindController);`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now need to tell our application how to look at a URL to determine which
    Controller to call. We will use convention-based routing here which uses a template
    that we define, to determine which Controller to call. Consider the following
    template `{controller}/{action}`. Our application will then use this template
    to split apart a URL and identify which part of a URL is the Controller part and
    which part of the URL is the Action. Using our `StudentController` class, the
    method `Find()` is the Action the template refers to. Therefore, when the application
    receives an incoming HTTP request with a URL `/Student/Find`, it will know to
    look for the `StudentController` class and go to the `Find()` method inside that
    Controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do not need to have the URL explicitly named `/StudentController/Find` because
    the MVC framework will, by convention, automatically take the word `Student` in
    the `{controller}` portion of the template and apply `Controller` to it to identify
    the name of the Controller to find.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the route mapping to the `FindController()` method. This tells the application
    that the template name is default and the template needs to look for a `{controller}/{action}`
    template in the URL. Your code should now look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting it all together, your `Startup` class will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Save your code and enter the following to the end of your URL in your browser: `/student/find`.
    My URL looks as follows, but yours will differ because the port number will most
    likely be different to mine: `http://localhost:25860/student/find`. Entering that
    in your browser will route the incoming HTTP request to the correct Controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What should we do, however, if the URL is not in the correct format or the
    Controller can''t be found. Well, this is where we can add defaults to our template.
    Remove the `/student/find` portion of the URL and hit enter. You should now see
    an error 404 in the browser. This is because the application could not find the
    Controller based on our URL. Add another class to our `Controllers` folder. Call
    this class `ErrorController`. Then, create a method inside this controller called
    `Support()`. Your code should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in the `Startup` class, modify the template in the `FindController()`
    method. It should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: What this does is tell our application that if it does not find a Controller,
    it should default to the `ErrorController` class and execute the `Support()` method
    inside that class. Save your code and refresh your browser to see the application
    default to the `ErrorController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_12_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the routing in ASP.NET MVC is very flexible. The previous steps
    listed discussed what we call convention-based routing. There is another routing
    method called attribute-based routing that uses attributes on our Controllers.
    Go to the `ErrorController` class and add the following `using Microsoft.AspNetCore.Mvc;` namespace
    to the class. Then, add an attribute `[Route("Error")]` to the class name and
    an attribute `[Route("Support")]` to your method. Your code should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the `Startup` class inside the `FindController()` method, comment out the
    line `route.MapRoute("Default", "{controller=Error}/{action=Support}");`. In the
    browser, add the text `/Error/Support` to the end of your URL and enter. You will
    see that the application correctly matches the `ErrorController`, based on the
    attributes defined inside the `ErrorController` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routing inside the MVC framework is a very flexible method of accessing specific
    Controllers, based on HTTP requests. If you need more control over the Controller
    that is accessed, attribute-based routing would probably be a better fit than
    convention-based routing. That said, there are additional things you can do when
    using attribute-based routing. Take a look at what is available to you as a developer
    when using attribute-based routing.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have been using plain C# classes as Controllers, but it is far more
    common have your Controllers inherit from the `Controller` base class which the
    MVC framework provides. This allows developers to return complex objects from
    their Controllers, students in our case. These complex return types are returned
    in a result that implements the `IActionResult` interface. We can, therefore,
    return JSON, XML, and even HTML to return to the client. The usage of this and
    creating Views is what we will be looking at next in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open up the `StudentController` class and modify it to contain attribute-based
    routing. Be sure to add the `using Microsoft.AspNetCore.Mvc;` namespace to the
    `StudentController` class. Also, inherit from the `Controller` base class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add another folder to your project called `Models`. Inside the `Models`
    folder, add a class called `Student` because our application will be returning
    student information. This will be a simple class with properties for the student
    number, first name, and last name. Your `Student` class should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Back in the `StudentController`, we want to instantiate our `Student` model
    and give it some data. We then change the return type of the `Find()` method from
    `string` to `IActionResult`. Also, add the `using AspNetCore.Models;` namespace
    to your `StudentController` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note, if your project is called something other than `AspNetCore`, your namespace
    will change accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '`using [projectname].Models;`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Ultimately, we want to return a view result from our `StudentController`. We
    now have everything set up to do that next.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add a new folder to your project called `Views`. Inside that folder, add another
    folder called `Student`. Inside the `Student` folder, add an new item by right-clicking
    on the `Student` folder and selecting New Item... from the context menu. From
    the Add New Item dialog screen, search for the MVC View Page template and call
    it `Find.cshtml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You should begin to notice that the `Views` folder, sub folders, and views follow
    a very specific naming convention. This is because the MVC framework follows a
    very specific convention, and when you look at the `StudentController`, this convention
    will become clear. The `Views` folder are `Views`, `Student`, `Find`, and the
    `StudentController` contains the word `Student` in the class name and has a method
    called `Find()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also create a `Shared` folder in the `Views` folder. This is where you
    place views that are shared across all Controllers and the Controllers will look
    in the `Shared` folder by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Heading back to the `Find.cshtml` Razor view, delete the code that is currently
    in there and replace it with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the HTML code snippet. Type `html` and press *Tab* twice to
    insert the boilerplate HTML code into the Find view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The deal with Razor views is that you are able to write C# expressions directly
    inside the `Find.cshtml` file. Before we do this, however, we need to set the
    type of the model we will be bringing in to our view. We do this using the following
    directive: `@model AspNetCore.Models.Student`. We can now reference our `Student`
    model directly inside our Razor view with full IntelliSense support. This is done
    using `@Model` with an upper case `M`. Take a look at the changes to the Razor
    view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Save your code and refresh your browser. Your URL should be `http://localhost:[your
    port number]/student/find` for this to work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The HTTP request is routed to the `StudentController` that in turn populates
    and returns the `Student` model containing the data we need and sends it to the
    Find Razor view. This is the essence of what the MVC framework is all about. There
    is a lot more to cover when it comes to the MVC framework and ASP.NET Core, but
    this chapter just deals with the basic introduction to these topics.
  prefs: []
  type: TYPE_NORMAL
- en: We as developers are continually challenged to stay up to date with the latest
    and greatest technologies. There is a drive in us to learn more and become better
    at what we do. The very fact that you are reading this book is a testament to
    that. Regarding this chapter, however, .NET Core and the MVC framework are areas
    that definitely need more learning. It is not possible to cover all there is to
    know in a single chapter. There are various online resources available to developers.
    I find that one of the best (and free) resources for learning new tech is the
    Microsoft Virtual Academy at [https://mva.microsoft.com](https://mva.microsoft.com).
    Free Microsoft training is delivered by experts.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, this is enough to pique your interest and will encourage you to research
    the topics further.
  prefs: []
  type: TYPE_NORMAL
