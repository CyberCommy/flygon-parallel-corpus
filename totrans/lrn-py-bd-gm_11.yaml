- en: Outdo Turtle - Snake Game UI with Pygame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python game development, in one way or another, is related to the `pygame` module.
    We have learned about a variety of topics and techniques regarding Python so far
    because we have to know about them before we progress to the `pygame` module.
    And all of these concepts will be used as apportioned techniques while build a
    game using Pygame. We can now start to use object-oriented principles, vectored
    movements for event handling, rotation techniques to rotate the images or sprites used
    in th     e game, and even use things that we learned about in the turtle module.
    In the turtle module, we learned how to create objects (refer to [Chapter 6](7f11f831-b5e7-4605-a9bd-25bfb5e3098e.xhtml), *Object-Oriented
    Programming*), which can be used to debug different features at the rudimentary
    stages of the game that we may build using Pygame. Thus, whatever we have learned
    so far will be used, along with the additional features of the Pygame module,
    which can help us make more appealing games.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover multiple things, starting with learning
    the basics of Pygame—the installation, building blocks, and different features.
    After that, we are going to learn about different objects of Pygame. They are
    the modules that can be used for several functionalities, such as drawing shapes
    into the screen, handling mouse and keyboard events, loading images into the Pygame
    projects, and many more. At the end of this chapter, we will try to make our snake
    game visually attractive by adding multiple features, such as a custom-made snake
    image, apples as food, and a menu screen for the game. Finally, we will convert
    our snake game into executable files so that you can distribute your game with
    your friends and family and get responses from them. The following topics will
    be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Pygame basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pygame objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing display and handling events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object rendering—making the snake game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Menu for the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting into an executable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game testing and possible modifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following requirements to complete this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Python—3.5 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyCharm IDE—refer to [Chapter 1](0ef9574b-5690-454e-971f-85748021018d.xhtml), *Getting
    to Know Python – Setting Up Python and the Editor*, for the download procedure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The files for this chapter can be found at [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter11](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2o2GngQ](http://bit.ly/2o2GngQ)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding pygame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing games with the `pygame` module requires pygame to be installed on your
    machine. You can download it manually from the official Pygame library by visiting
    the website ([www.pygame.org](http://www.pygame.org).), or install it by using
    the Terminal with the  `pip install pygame` command.
  prefs: []
  type: TYPE_NORMAL
- en: The pygame module is free to download from the aforementioned website, so we
    can download it by following a similar process to what we do for any other Python
    module. However, we can remove the headache of downloading pygame manually by
    using a visually more attractive and effective alternative IDE, **PyCharm**, which
    we  downloaded back in [Chapter 1](0ef9574b-5690-454e-971f-85748021018d.xhtml),
    *Getting to Know Python – Setting Up Python and the Editor*. We are became familiar
    with the techniques that are used to download and install third-party packages
    within PyCharm in that chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have downloaded the pygame package into PyCharm, give it some time
    to load. Now, we can test it by writing the following code. The following two
    lines of code check if the `pygame` module is downloaded or not, and if it is,
    it will print its version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If pygame is successfully installed onto your machine, you will observe the
    following output. The version may vary, but at the time of writing this book,
    it is version 1.9.6 (the latest version of 2019). The contents of this book works
    for any version of `pygame` because of its backward compatibility. Make sure that
    you have a pygame version that is newer than 1.9+:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Pygame is a utopia for many Python game developers; it contains a surfeit amount
    of modules, ranging from making an interface to handling user events. All of these
    modules that are defined within pygame can be used independently, according to
    our needs. Most importantly, you can also make games using pygame, which may or
    may not be platform-specific. Invoking the modules of pygame is similar to invoking
    the methods of the class. You can always access these classes using the pygame
    namespace, followed by the class that you want to use. For instance, `pygame.key`
    will read the key that is pressed on the keyboard. Thus, the `key` class is responsible
    for handling keyboard actions. Similarly, the `pygame.mouse` module is used to
    manage mouse events. These, and many other modules of pygame, can be called independently
    from one another, which makes our code more manageable and readable. You can search
    for the list of modules that are available in the pygame module from its official
    documentation page, but almost 80 percent of the games require only four to six
    modules. If you want to learn more about them, it''s always good to explore its
    official documentation page. Among them, we mostly use two classes in each and
    every game, that is, the display module, in order to access and manipulate the
    game display; and the mouse and key or joystick module, in order to handle input
    events for the game. I won''t say that the others are less important, but these
    modules are the building blocks of games. The following table has been extracted
    from the Python pygame official documentation; it gives us a succinct idea about
    the `pygame` modules and their usages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Module name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.draw` | Draws shapes, lines, and points. |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.event` | Deals with external events. |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.font` | Deals with system fonts. |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.image` | Loads the image into the project. |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.joystick` | Deals with joystick movements/events. |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.key` | Reads key presses from the keyboard. |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.mixer` | Mixing, loading, and playing sound. |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.mouse` | Reads mouse events. |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.movie` | Plays/runs movie files. |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.music` | Plays streaming audio files. |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame` | Bundled as high-level pygame functions/methods. |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.rect` | Deals with rectangular areas and can create a box structure.
    |'
  prefs: []
  type: TYPE_TB
- en: 'There are also a few more, such as surface, time, and transform. We will explore
    each of them in this and the upcoming chapters. All of the preceding modules are
    platform-independent, which means that they can be evoked, regardless of the operating
    system that is used by the machines. But there are some OS-specific errors, and
    errors due to hardware incompatibilities or improper device drivers. If any module
    is not compatible with any machine, the Python parser returns it as `None`, which
    means we can check beforehand to make sure that the game works properly. The following
    line of code will check whether any specified module (`pygame.module_name`) is
    present, and if not, it will return a custom message in the print statement, which
    in this case is, *No such module! Try other one*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To completely grasp the concept of `pygame`, we have to make a habit of observing
    the code that is written by other pygame developers. In doing so, you will learn
    the pattern for building games with `pygame`. If, like me, you only check documentation
    if you are at an impasse, then we can make a simple program to help us understand
    the concept of `pygame` and the ways that we can call its different modules. We
    are going to write a simple code to illustrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Before discussing the preceding code, let''s run it and observe the output.
    You will get a geometrical shape—a green rectangular box that will be rendered
    inside the screen of a certain height and width. Now, it''s time to make a quick
    mental note of the building blocks of the `pygame` module. To make things simpler,
    I have listed them in the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import pygame`: The import statement that we have been with familiar from
    the beginning of this book. This time, we are importing the pygame framework into
    our Python file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pygame.init()`: This method is going to initialize a bundle of modules/classes
    that are embedded inside pygame. This means that we can call pygame''s other modules
    with its namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pygame.display.set_mode((width, height))`: The size passed as a tuple (width,
    height) is the desired screen size. This size represents our games console. The
    returned object will be a window screen, or surface, on which we will perform
    different graphical computations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pygame.event.get()`: This statement is going to handle the event queue. The
    queue, as we discussed in previous chapters, is going to store different events
    of the user. If this statement is not called explicitly, the game will be hindered
    by overwhelming Windows messages, and eventually it will become unresponsive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pygame.draw.rect()`: We will be able to draw into the screen using the draw
    module. Different shapes can be drawn with this module. More on this will be covered
    in the next section—*Pygame objects*. Taking a screen object, color, and position
    as arguments, the `rect()` method draws a rectangle. The first argument represents
    the screen object, which is the returned object of the display class; the second
    is the color code that is passed as a tuple in the form of RGB (red, green, blue)
    code; and the third is the dimensions of a rectangle. In order to manipulate and
    store rectangular areas, pygame uses `Rect`objects. `Rect()` can be created by
    combining four different values—height, width, left, and top.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pygame.QUIT`: This event is invoked whenever you explicitly close the pygame
    screen, which is done by pressing the `close(X)` button at the top-most right
    corner of the games console.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pygame.display.flip()`: This is same as the `update()` function, which makes
    any new updates on the screen visible. While making or blitting shapes or characters,
    this method must be invoked at the end of the game in order to ensure that all
    the objects are rendered properly. This will swap the pygame buffer, as pygame
    is a double-buffered framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The aforementioned code renders the green rectangular shape when executed. As
    we mentioned previously, the `rect()` method is responsible for creating the rectangular
    area, and the color code (0, 128, 0) represents the green color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t get overwhelmed with this jargon; you will learn about it in detail
    in the upcoming chapters. While you read this chapter, make sure that you make
    a habit of making a logical connection between the code: something like a blueprint
    that maps the game from one position to another, that is, the display screen,
    to rendering characters, to handling events.'
  prefs: []
  type: TYPE_NORMAL
- en: If you get into a situation where you are unable to close the pygame Terminal,
    it's surely because you haven't handled the event queue properly. In such cases,
    you can always stop Python from the Terminal by pressing *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: Before hopping over to the next section, I want to discuss the rather simple
    but abyss working of commands—pygame initialization—which is done by the `pygame.init()`
    statement. This is just a single line of command, but it carries out more tasks
    than we can imagine. As the name suggests, it is the initialization of pygame.
    Thus, it must initialize each of the sub-modules of the `pygame` package, that
    is, `display`, `rect`, `key`, and so on. Not only that, but it is also going to
    load all the essential drivers and queries of the hardware components in order
    to communicate.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to load any submodules quicker, you can explicitly initialize the
    specific ones, and avoid all the unnecessary ones. For example, `pygame.music.init()` will
    only initialize the music sub-module from the bucket of submodules that is maintained
    by Pygame. For most of the games that we are going to cover in this book, the
    `pygame` module requires more than three submodules. Thus, we can use the universal
    `pygame.init()` method to perform initialization. After making the preceding call,
    we will be well-equipped to use all of the specified submodules of the `pygame`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the process of initialization, it''s good practice to start creating
    a display screen. The dimension of the display screen depends on the demand of
    the game. Sometimes, you may have to provide full-screen resolution to the games
    in order to make it fully interactive and appealing. The manipulation of the screen
    size can be done via the pygame surface object. The method call of `set_mode`
    on the display class returns the object, which represents the entire window screen.
    You can also set the caption to the display screen if you want; the caption will
    be added to the top navigation bar, which is along with the close button. The
    following code represents a way of adding captions or game names to the game screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's talk about the argument that is passed with the `set_mode` method.
    The first—and an most important–argument is the dimension of the screen's surface.
    The size should be passed as a tuple, that is, in terms of width and height, and
    it is mandatory. The others are optional (in the previous program, we didn't even
    bother using them); they are called flags. We need them because the information
    related to width and height sometimes won't be enough to make an appropriate display.
  prefs: []
  type: TYPE_NORMAL
- en: 'We may want a **fullscreen** or **resizable** display, and in such cases, flags
    can be better suited for display creation. Speaking of flags, it is a feature
    that can be turned on and off, based on the situation, and sometimes working with
    it may be time-saving, relatively speaking. Let''s observe some of the flags in
    the following table, though we are not going to use them any time soon, but covering
    them here obviates the unnecessary introduction in the upcoming sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Flag** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| `FULLSCREEN` | Creation of a display that covers the entire screen. Windowed
    screen recommended for debugging. |'
  prefs: []
  type: TYPE_TB
- en: '| `DOUBLEBUF` | Used in the creation of a *double-buffered* display. It is
    highly recommended for `HWSURFACE` or `OPENGL`, which simulates a 3D display.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `HWSURFACE` | Used in creating a hardware-accelerated display, that is, it
    uses video card memory instead of main memory (must be combined with the `FULLSCREEN`
    flag). |'
  prefs: []
  type: TYPE_TB
- en: '| `RESIZABLE` | Creates a resizable display. |'
  prefs: []
  type: TYPE_TB
- en: '| `NOFRAME` | Display without frame or border, along with no title bar. |'
  prefs: []
  type: TYPE_TB
- en: '| `OPENGL` | Creates an OpenGL renderable display. |'
  prefs: []
  type: TYPE_TB
- en: You can use the bitwise OR operator to combine multiple flags together, which
    facilitates a better experience in terms of the screen surface. In order to create
    a double-buffered OpenGL rendered display, you can set an optional flag parameter
    to `DOUBLEBUF|OPENGL;` here, (`|`) is the bitwise `OR` operator. Even if pygame
    is not able to render the perfect display that we asked for, which may be due
    to the lack of the appropriate graphics card, pygame will make a decision for
    us in terms of choosing a  display that is compatible with our hardware.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important aspects of game development is handling a user event,
    and it is normally done within the game loop. Inside the main game loop, we usually
    have another loop to handle user events—an event loop. An event is a course of
    messages that inform pygame of what to expect outside the periphery of the code.
    Events may vary from the user pressing the key events, to any information transferred
    through a third-party library, for example, the internet.
  prefs: []
  type: TYPE_NORMAL
- en: The events that are created as a chunk are stored in the queue, and remain there
    until we explicitly address them. While there are different functions in event
    modules from pygame that provide a way to capture the events, `get()` is the most
    reliable, and is also easy to use. After getting the gamut of actions, we can
    address them using the pygame event handler—using functions such as `pump` or
    `get`. Remember that if you are only addressing specific actions, the event queue
    may infuse with other superficial events that you might not be interested in.
    Thus, the handling of events must be done explicitly using event attributes, similar
    to what we did in the preceding example using the `QUIT` event attribute. You
    may also get full access to the event object's attributes through the `eventType.__dict__`
    attribute. We will learn about them thoroughly in the upcoming *Event handling*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Before learning how to upgrade our own previously made *snake* game using pygame,
    we have to learn about a few important concepts of pygame—*Pygame objects*, *Drawing
    into the screen*, and *Handling User Events*. We will learn about these concepts
    in detail, one by one. We will start with *Pygame objects*, where we will learn
    about surface objects, creating surfaces, and rectangular objects. We will also
    learn how to draw shapes using pygame.
  prefs: []
  type: TYPE_NORMAL
- en: Pygame objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `pygame` module, which is made by internally using classes, makes code readable
    and reusable by allowing us to create objects and use their properties. As we
    mentioned earlier, there are several classes that are defined in the `pygame`
    module that can be called independently to perform independent tasks. For instance,
    the `draw` class can be used to draw different shapes such as rectangles, polygons,
    circles, and many more; the `event` class can call functions such as get or pump
    in order to handle user events. These invocations can be done using objects, by
    creating them first for each action. In this section, you are going to explore
    the concepts that will help you learn about accessing surface objects, rectangular
    objects, and drawing to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most basic way to create a blank surface of customized dimensions is by
    calling a `Surface` constructor from the pygame namespace. While creating objects
    of the `Surface` class, tuples containing width and height information must be
    passed. The following line of code creates a blank surface of 200 by 200 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can specify a few more optional parameters that can ultimately affect the
    screen visuals. You can set the flag parameter to one or more of the following
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HWSURFACE`: Creates a hardware surface. This is not very important in the
    context of games because it is done internally by pygame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SRCALPHA`: It uses *alpha information* for the conversion of the background,
    which refers to a process that makes the background of the screen transparent.
    It creates a surface with alpha conversion. The alpha information will make a
    part of your surface transparent. If you are using this as an optional flag, you
    have to specify one more mandatory parameters, including depth, and assign its
    value to 32, which is standard for alpha information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Furthermore, if you want to create a surface that contains an image as a background,
    you can call up the `image` class from the `pygame` module. The image class contains
    the `load` method, which can be called with the argument of the background image
    filename that needs to be rendered. The filename that is passed should be the
    full name, with its original extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The load function that is called from the `image` class reads an image file
    from your machine and then returns the surface containing an image. Here, the
    screen dimension will be determined by the image size. The `convert()` member
    function of the `Surface` object will convert the specified image into the format
    that is supported by your display screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's learn how to create multiple surfaces inside a single one, which
    is normally called a subsurface.
  prefs: []
  type: TYPE_NORMAL
- en: Subsurfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name suggests, subsurfaces are a list of nested surfaces inside the
    single main surface. The main surface can be referenced as the parent surface.
    The parent surface can be created with any of the aforementioned methods using
    the `Surface` constructor, `set_mode`, or image. When you draw onto the subsurface,
    it is also going to draw onto the parent one, as subsurfaces are part of the parent,
    too. Creating a subsurface is easy; you just need to call the `subsurface` method
    from the `Surface` object, and the argument that is passed should indicate the
    position of the `parent` class to be covered. Normally, the coordinate that is
    passed should create a small rectangle inside the parent screen. The following
    code shows how a subsurface can be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can store these subsurfaces into data structures such as a dictionary so
    that you can reference them easily. You can observe the position that is passed
    inside the subsurface method—they are heretic from the others. The point (0, 0)
    always means that a subsurface starts from the top-left corner of the parent screen.
  prefs: []
  type: TYPE_NORMAL
- en: There are several methods available with subsurfaces, all of which you can pry
    from its official documentation. One of the most useful methods is `get_parent()`,
    which returns the parent surface of the subsurface. It will return `None` if the
    `get_parent` method is not called with any subsurface.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will learn about the next method regarding surface objects that you
    will frequently use while making any game with pygame, which is `blit`, which
    stands for **bit block transfer**.
  prefs: []
  type: TYPE_NORMAL
- en: Blitting your objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the term *blitting* may not have been defined in the Oxford dictionary,
    it has greater significance while making games with pygame. Often referred to
    as bit-boundary block transfer, or Block Information Transfer, `blit` is a way
    of copying the image from one surface to another, usually by cropping or shifting.
    Let's asume you have `Surfaceb`(your screen), and you would like to draw a shape,
    let's say, a rectangle onto the screen. So, what you have to do is draw a rectangle
    and then transfer a rectangular block of the buffer to the screen buffer. This
    process is called *blitting*. When we cover games using pygame, you will find
    it being used for drawing backgrounds, fonts, characters, and everything that
    you can imagine.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to `blit` the surface, you can call the `blit` method from the resulting
    surface object, which is often the display object. You have to pass your source
    surface, such as characters, animations, and images, along with the coordinate
    to `blit` in as arguments. The invocation of the `blit` method is rather simple,
    compared to what it sounds like, theoretically. The following line of code shows
    how to `blit` the background image in the specified position (0,0), which is the
    top-most corner of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let's say you have a collection of images that needs to be rendered, based on
    different frame rates. We could also do this using the `blit` method. We can change
    the value of the frame number and `blit` in a different area of the resulting
    screen to make an animation of the images. This is normally done in the case of
    static images. For example, we are going to create a clone of the flappy bird
    game, using Pygame, in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that game, we have to `blit` the pipes and the bird (characters for the
    flappy game) on the different position, out of the static image, which we normally
    call sprites. These sprites are nothing but images that can be used directly from
    the internet, or we can make one for ourselves, according to our needs. The following
    code shows a simple way to `blit` images, based on the different frame rates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of the flappy bird game, a list of images contains the images of
    the bird in two positions: flying and falling. Based on the user events, we will
    render each of them using the `blit` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Before jumping into the next section, let's learn about the maybe paltry, but
    must-know topic, of *frame rates*. It is the term that is often used as the benchmark
    for measuring game performance. The frame rate in a video game infers the resultant
    simulation movements, or motions of how many times the images that you observe
    in the screen, are refreshed or fetched. The frame rate is a measurement that
    is done in **frames per second** or **FPS** (do not be confuse this with the term **first
    person shooter**).
  prefs: []
  type: TYPE_NORMAL
- en: There are many factors that go into determining a game's frame rate, but contemporary
    game players want anything but lag, or a sluggish game. Therefore, the higher
    rate is always better. Low frame rates may develop a hapless situation at an inopportune
    time. An example may be in games where users are able to jump or are chopped from
    a certain height; low FPS causes a lag in the system, and often makes the screen
    *Frozen*, which makes the user unable to interact with the game. Many modern games,
    for example, first-person shooter games such as Pubg and Fortnite, are developed
    with the intention of approaching a frame rate of around 60 FPS. But in a simple
    game developed by Pygame, anywhere from 15 to 30 FPS is considered acceptable.
    Some critics argue that anything below 30 FPS will create choppy animation and unrealistic
    motion, but as we know, pygame allows us to create mostly mini games. Therefore,
    anything between 15 to 30 FPS will be sufficient for us.
  prefs: []
  type: TYPE_NORMAL
- en: Let's hop into the next section, in which we will learn how to draw different
    shapes using the `pygame` draw module.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing with the pygame draw module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most used modules is `draw`, which has plenty of methods declared,
    and can be used to draw shapes onto the game screen. The aim of using this module
    is to draw lines, circles, and polygons—in fact, any geometrical shape. You might
    be wondering about the importance of using it—it has a broad range of uses. We
    might have to create shapes so as to perform cropping, or to blit the sprites
    or images onto the screen. Sometimes, you may want to use these shapes as characters
    for your game; games such as Tetris, which is one of the most popular games, is
    a perfect example. Even though you might not find it very useful while creating
    the games, and you would use sprites instead, it may be helpful while testing
    your game animation. You don't have to go anywhere to understand the importance
    of these shapes in game development; you can observe the games that we have created
    so far. Up until now, in the snake game, we have been using simple rectangular
    shapes to denote the snake's body and head. Although it might not be very appealing,
    at the incipient stage of games, we can always make games using such shapes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating such shapes using pygame is easier than with any other module. We
    can call up the draw module, along with the function name. The function name will
    be the name of the shape that you want to draw. For example, for a circle, we
    would use `pygame.draw.circle()`, and for a rectangle, we would use: `pygame.draw.rect()`.
    The first two parameters for the functions in `pygame.draw` are the surface on
    which you want to draw, followed by the color with which you want to draw it.
    The first parameter for drawing the function is the `Surface` object, which represents
    the screen in which you want to draw. The next parameter represents the position
    of the screen on which you want to draw your shapes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These three arguments are mandatory for each of the geometrical shapes, but
    the last one depends on the shapes. The last argument of the method represents
    the mathematical quantity that is used while drawing such shapes, such as the
    radius or diameter of a circle. Normally, the third argument that is passed should
    represent the coordinate position in the form of *x* and *y* coordinates, where
    the point (0, 0) represents the top-most left area of the screen. The following
    table lists the number of methods that are available inside the draw module, which
    can be used to draw any geometric shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `rect` | Draws a rectangle |'
  prefs: []
  type: TYPE_TB
- en: '| `polygon` | Draws a regular polygon (geometrical shape that has three or
    more enclosed sides) |'
  prefs: []
  type: TYPE_TB
- en: '| `line` | Draws a line |'
  prefs: []
  type: TYPE_TB
- en: '| `lines` | Draws several lines |'
  prefs: []
  type: TYPE_TB
- en: '| `circle` | Draws a circle |'
  prefs: []
  type: TYPE_TB
- en: '| `ellipse` | Draws an ellipse |'
  prefs: []
  type: TYPE_TB
- en: 'As an example, let''s use the `circle` method and observe the `pygame` draw
    module in action. We need to know the value of the radius in order to draw a circle.
    The radius is the distance from the center of the circle to the edge of the circle,
    which is the arc of the circle. The arguments that should be passed while calling
    the circle functions are screen, which represents the surface object; the color
    of the circle; the position where the circle should be drawn; and finally, the
    radius of the circle. Since we used the random module to generate random values
    of the radius for the circle, instead of giving specific values, the following
    code creates multiple circles, with random widths in a random position, and blatantly
    with a random color. If you type specific values for each parameter, a shape will
    be drawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code, which will be written from this chapter onward, is in the PyCharm
    Community IDE, which was downloaded in [Chapter 1](0ef9574b-5690-454e-971f-85748021018d.xhtml), *Getting
    to Know Python - Setting Up Python and the Editor*. Make sure that `pygame` is
    installed on the interpreter main directory so that `pygame` can be used universally
    on any newly created Python file.
  prefs: []
  type: TYPE_NORMAL
- en: One of the important features that can be noted while using the PyCharm IDE
    is that it can give us information about all the modules that come with the installation
    of the `pygame` module. To determine which functions reside in the `draw` module,
    select the `circle` or `draw` keyboard from your code and press *Ctrl* + *B* on
    the keyboard, which will, in turn, redirect you to the declaration file of the
    `draw` module.
  prefs: []
  type: TYPE_NORMAL
- en: While talking about the code, it is simple to understand. The main three lines
    of code are highlighted so that you can directly observe the importance of them.
    Mostly, the third line, which calls the `circle` method, is declared within the
    `draw` module, which takes the arguments, screen object, color, position, and
    radius in order to draw a circle. The output of the preceding program will print
    the circle with a random radius and a random color incessantly, until and unless
    the user closes the screen manually, which is due to the event handler, and is
    done by the `pygame.event.get` method.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can draw polygons of many shapes and sizes, which may range from
    a three-sided triangle to a 9999-sided polygon. Just like we have used the `pygame.draw.circle`
    function to create a circle, we can use `pygame.draw.polygon` to draw any kind
    of polygon. A call to the polygon function takes the argument in the form of a
    list of points, and will draw a polygon shape using these points. We can draw
    different geometrical shapes using a specific appellation in a similar fashion.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to learn about the different ways of initializing
    the display screen and handling keyboard and mouse events using the `pygame` module.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the display and handling events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Primarily, the game developer will be focusing on how to make the game more
    interactive by making players feel like they are engaged. The two things that
    must be tied as dovetail in such cases is a visually attractive display and handling
    the events of the player. We don''t want our player to be overwhelmed with a deplorable
    display screen and a game that lags in movement. In this section, we are going
    to address the two primary things that the developer must take into account while
    making games: different ways of initializing the display by accommodating the
    available optional parameters and handling the user action events, such as when
    a keyboard key or a mouse button is pressed. The type of the display that you
    want to create depends on the type of game that you are planning to develop.'
  prefs: []
  type: TYPE_NORMAL
- en: One thing that you have to remember while making games with the `pygame` module
    is that adding more actions to the game will affect the smoothness of the game,
    which means that if you add multiple features into the game, the more the game
    will lag in interactivity. Thus, we will primarily focus on making mini games
    with the `pygame` module. There are more advanced Python modules on the market
    that can be used for making high-feature games, and we will explore them in the
    upcoming chapters. For now, we will see how to initialize the display, which is
    done by selecting a lower resolution, because we don't want our game to lag in
    any way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any games that will be made from now on will have a fixed and low resolution,
    but you can experiment on your own by making the user choose their own customized
    display. The following code is a simple way of creating a pygame window, and we
    have also seen this in the previously written code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter of `set_mode()` will be the dimension of the screen. The
    value in the tuple (640, 480) represents the height and width of the screen. This
    dimension value will create a small window box, which is compatible with most
    desktop screens. We might, however, encounter a situation where a game must have
    a `FULLSCREEN`, instead of a small screen. In such cases, we can use an optional
    parameter, giving the value of `FULLSCREEN`. The code that displays the fullscreen
    looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We might, however, observe the performance difference between using fullscreen
    mode versus a customized display. While opening the game in fullscreen mode will
    run faster, as it doesn''t interact with other background desktop screens, the
    other screen, with a customized display, may become incorporated with other running
    display screens on your machine. Apart from that, debugging games with a small
    display screen is easier than games with a fullscreen because you should address
    alternative ways of closing the game in fullscreen mode as the close button will
    not be visible. To check the different resolutions of display that are supported
    by your PC, you can call the `list_modes()` method, which will return tuples containing
    a list of the resolutions, which appear like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, you may feel that there is slight decrease in the quality of the
    image that is displayed in your screen. This is primarily due to a graphics card
    with fewer features, which doesn't provide the color of the image that you have
    requested . This is compensated for by `pygame`, who converts the image into one
    that is appropriate for your device.
  prefs: []
  type: TYPE_NORMAL
- en: In some games, you might want the user to decide on choosing the size of the
    display screen. The trade-offs are concerned with whether a player chooses either
    high-quality visuals or making the game run smoothly. Our main goal will be to
    handle the event, which can toggle a screen between a resizable screen and a fullscreen.
    The following code illustrates a switch between a windowed screen to a fullscreen,
    and vice versa. When the user presses *F* on the keyboard, it will toggle between
    screens.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you run the program, the toggling process between the windowed screen and
    the fullscreen is not spontaneous. This is because `pygame` takes some time to
    check the features of the graphics card, and handles the quality of images itself
    if the card is not capable enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s learn about the display toggling process, line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You must begin by importing the `pygame` module. The second import statement
    is going to import constants that are used by Pygame. However, its contents are
    automatically placed in the `pygame` module namespace, and we can use `pygame.locals`
    to include only the `pygame` constants. Examples of constants include: KEYDOWN,
    Keyboard `k_constants`, and so on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will set the default display mode at the start of the game. This display
    will be a default display, whenever you run your program for first time; the current
    customized display will be rendered. We have a passed display screen of (640,
    480) by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To toggle the display screen, you have to make a Boolean variable, `Fullscreen`, which
    will be either `True` or `False`, and based on that, we will set the mode for
    the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the main loop, you must handle the event for keyboard key actions. Whenever
    the user presses *F* on the keyboard, we will change the value of the Boolean
    variable, and if the value of the `FULLSCREEN` variable is `True`, we have to
    change the display to fullscreen. The extra flag, `FULLSCREEN`, is added as a
    second argument to the `add_mode()` function with a depth of 32.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the else part, if the value of fullscreen is `False`, you have to display
    the screen in the windowed version. The same key, *F*, is used to toggle the screen
    between the windowed and the fullscreen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have learned how to modify the windowed visuals using the different
    available flags, let's hop into the next section, where we will discuss accepting
    user input and controlling the game, which is often referred as *h**andling user
    events*.
  prefs: []
  type: TYPE_NORMAL
- en: Handling user events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On conventional PC games, we normally see the player playing games using just
    the keyboard. Even today, most games fully rely on keyboard actions. With the
    advancement of the game industry, we can accept user input from several input
    devices, such as the mouse and joysticks. Often, the mouse is used to handle the
    action, which gives a panoramic view of the game visuals. If you have ever played
    counter strike, or any first person shooter game, the mouse allows the player
    to rotate the view in several angles, whereas keyboard actions handle the player
    movements, such as moving left, right, jumping, and so on. The keyboard is normally
    used to trigger actions such as firing and dodging, because its action is pretty
    much like a switch. A switch only has two possibilities: on or off; keyboard keys
    are also either pressed, or not, which generalizes the technique for handling
    the keyboard actions. In typical 19th-century games, we used to spawn the game
    enemy by checking the actions of the keyboard. When a user presses a keyboard
    key relentlessly, we used to generate the enemy in a greater quantity.'
  prefs: []
  type: TYPE_NORMAL
- en: The combination of the two input devices, that is, the mouse and the keyboard,
    works perfectly for these games because the mouse is capable of handling directional
    movements and does it in a smooth manner. For instance, when you play a first-person
    shooter game, you rotate the player using the keyboard and the mouse. Whenever
    any enemy is behind you, you normally use the mouse to rotate quickly to that
    position, rather than using the keyboard to rotate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to detect and listen to (capture) all of the keyboard keys, you have
    to use the `pygame.key` module. This module is capable of detecting whether any
    key is pressed or not, and even supports directional movements. This module is
    also capable of handling any keyboard actions. Basically, there are two ways of
    handling key presses in pygame:'
  prefs: []
  type: TYPE_NORMAL
- en: By handling KEYDOWN events, which are triggered when a key is pressed on the
    keyboard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By handling KEYUP events, which are triggered or issued when a key on the keyboard
    is released.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While these event handlers are a great way to check for the key presses, handling
    the keyboard input for movement is not appropriate with them. We need to know
    beforehand if the keyboard key is being pressed or not in order to draw the next
    frame. Thus, using the `pygame.key` module directly will give us the power to
    handle keyboard keys effectively. The keys of the keyboard (a-z, 0-9, and F1-F12)
    have key constants which are predefined by pygame. These key constants can be
    referred to as keycode, which is used to identify them uniquely. Keycode always
    starts with `K_`. For every possible key, the keycode looks something like (`K_a`
    to `K_z`), (`K_0` to `K_9`), and contains other constants such as `K_SPACE`, `K_LEFT`,
    and `K_RETURN`. Some keyboard keys cannot be handled by pygame due to hardware
    incompatibility. This anomaly is discussed in "Keyboards are Evil," by several
    developers online. You might want to refer to them to understand this in more
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most basic way of handling any keyboard action is by using the `pygame.key
    get_pressed` function. This method is quite powerful as it assigns Boolean values
    to all the keyboard constants; either `True` or `False`. We can check this by
    using `if` conditionals: is the value of the keyboard constant `True` or `False`?
    If it is `True`, it is obvious that a key is being pressed. The `get_pressed`
    method call returns a dictionary of the key constants, where the key of the dictionary
    is the key constants of the keyboard and a value of the dictionary is boolean,
    `dictionary_name[K_a] = True`. Let''s say you are making a program that will use
    an *up* movement as a jump button. You would have to write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s learn about the `pygame.key` module in more detail. Each of the following
    functions are going to handle keyboard keys, but with different approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pygame.key.get_pressed()`: As we saw in the preceding code, this method returns
    a dictionary containing Boolean values for each key of the keyboard. You have
    to check the value of the keys to determine if it has been pressed or not. In
    other words, if any value for the keyboard key is set to `True`, the key for that
    index is said to be pressed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pygame.key.name()`: As the name suggests, this method call will return the
    name of the pressed key. For example, if I get a `KEY_UP` event for a key that
    has a value of 115, you can use `key.name` to print out the name of the key, which
    in this case is a string, *s*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pygame.key.get_mods()`: This will determine which modifier key has been pressed.
    Modifier keys are normal keys combined with *Shift*, *Alt*, and *Ctrl*. In order
    to check if any modifier key is being pressed or not, you have to call the `get_mods`
    method first, followed by `K_MOD`. The method call and constants are separated
    by a bitwise AND operator, for example, `event.key == pygame.K_RIGHT` and `pygame.key.get_mods()
    & pygame`. The  `KMOD_LSHIFT` method can be used to check for the LEFT *Shift*
    key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pygame.key.set_mods()`: You can also automatically set the modifier key temporarily
    to observe the effect of the modifier key being pressed. To set multiple modifier
    keys, we normally combine them using the bitwise OR operator (|). For instance,
    `pygame.key.set_mods(KMOD_SHIFT | KMOD_LSHIFT)` will set the SHIFT and LEFT *Shift*
    modifier keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pygame.key.get_focused()`: To grab every pressed key from the keyboard, the
    display must focus on the keyboard actions. This method call will return a Boolean
    value by checking if the display is receiving keyboard input from the system or
    not. In the case of games where there may be a customized screen, and the game
    screen is not focused because you may be using other application; this will return
    `False`, which means that the display is not active or focused to listen to keyboard
    actions. But in the case of a fullscreen display mode, you will be fully focused
    on the single screen, and in such cases, this method will always return `True`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are couple more pygame key functions, such as `get_repeat` and `set_repeat`,
    they are useful in cases where you want the repeated action to occur when you
    continously hold down any key on the keyboard. For instance, open your notepad
    and press the *s *key, continuously. You will see that the character `s` will
    be printed several times. This feature can be embedded using the `pygame.key set_repeat`
    function. This function will take two arguments: delay and interval in milliseconds.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first delay value is for the initial delay before a key repeats, while
    the next interval value is for the delay between repeated keys. You can disable
    these key-repeating features by using the `calling set_repeat` method with no
    parameter. By default, when pygame is initialized, the key-repeat feature is disabled.
    Thus, you need not have to disable it manually. Go to the following website for
    the pygame official documentation in order to learn more about pygame''s key functions:
    [https://www.pygame.org/docs/ref/key.html](https://www.pygame.org/docs/ref/key.html).'
  prefs: []
  type: TYPE_NORMAL
- en: You can set a movement for a sprite/image/object of the game screen with the
    keyboard by assigning a key of Up, Down, Left, or Right. Up until now, we have
    been doing this using different modules such as Python turtle and curses. However,
    we were unable to handle the movement of static sprites or images. We were only
    handling up, down, left, right, and key events for geometrical objects, but now
    pygame allows us to use more intricate graphics and handle them accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can allocate any keyboard key to perform directional movements, but following
    conventional methods, we can appropriate cursor keys or arrow keys as they are
    perfectly placed on the keyboard, which allows the player to play easily. But
    in some complex multiplayer games, such as first-person shooter games, the *A*,
    *W*, *S*, and *D* keys are allocated for directional movements. Now, you might
    be wondering what you have to do in order to make any arrow key behave in such
    a way that it can be used for directional movements. Just recall the power of
    vectors: the mathematical concept that is useful for game development, irrespective
    of whatever language or module you use. The technique for moving any geometrical
    shapes and images is the same; we need to create a vector that points in the direction
    that we might want to head in. Representing the position of a game character is
    quite simple: you can represent it in 2D using the (*x*, *y*) position, and in
    3D using (*x*, *y*, *z*) position. The directional vector, however, is the unit
    quantity that must be added to the current vectored position in order to change
    to the next frame. For instance, by pressing the down key on the keyboard, we
    have to move downward with no change in the *x* position, but with a unit increment
    in the *y* coordinates. The following table explains the directional movement
    for four directions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Position** | **Directional vector** |'
  prefs: []
  type: TYPE_TB
- en: '| Up | (0, -1) |'
  prefs: []
  type: TYPE_TB
- en: '| Down | (0, 1) |'
  prefs: []
  type: TYPE_TB
- en: '| Left | (-1, 0) |'
  prefs: []
  type: TYPE_TB
- en: '| Right | (1, 0) |'
  prefs: []
  type: TYPE_TB
- en: 'We may also want the player to allow diagonal movements, as shown in the following
    illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8a263cf7-95c9-4277-ad7c-2dfd24d02cd3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding illustration represents a vectored motion for the up and right
    keyboard keys. Suppose, at the beginning of the game, the player is at position
    (0, 0), which means they are at the center. Now, when the user presses the up
    (arrow key) keyboard key, there will be addition of (0, 0) with the up directional
    vectors (0, -1), and the resulting vector will be the player''s new position.
    The diagonal movement (the combination of two keys, in this case, up and right),
    will give an addition of (0.707, -0.707) to the current vectored position of the
    player. We can use this technique of vectored motion in order to provide the directional
    movement to any game objects, either sprites/static images or geometrical shapes.
    The following code represents the vectored movement using pygame event handling
    techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Although it is worth knowing how to make things move in eight directions (four
    basic directions and four diagonal movements), using all eight of these won''t
    make the game smoother. Hypothetically, it is a little artificial to make things
    go in eight directions. However, games nowadays allow game players to observe
    a view with a 360-degree facility. Thus, in order to make games with such features,
    instead of using eight keyboard actions, we can make rotational movements with
    the keys. To calculate the resultant vector from the rotation, we must calculate
    the sine and cosine of the angle using math modules. The sine of the angle is
    responsible for the movement in the *x*-component, while cosine is responsible
    for the movement in the *y*-component. Both of these functions take angles in
    radians; if the rotation angle is in degrees, you have to convert it into radians
    using (`degree*pi/180`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's learn about implementing mouse control and observe how it can be
    used in game development.
  prefs: []
  type: TYPE_NORMAL
- en: Mouse control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having mouse control, along with keyboard control, comes in handy if you want
    to make games more interactive. Sometimes, handling eight directional keys is
    not enough, and in such cases, you also have to handle mouse events. For example,
    in games such as flappy bird, users have to essentially be able to play with a
    mouse, and although it uses screen taps in mobile games, on a PC, you have to
    be able to provide mouse actions. Drawing a mouse cursor into the display screen
    is quite simple; you need to get the coordinates of the mouse from `MOUSEMOTION`
    events. Similar to the keyboard `get_pressed` function, you can call up the `pygame.mouse.get_pos()`
    function in order to obtain the position of the mouse. Mouse movements are extremely
    helpful in the game—if you want to make the game characters rotate, or make a
    screen tap game, or even if you want to look up and down the game screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand the ways of handling mouse events, let''s look at a
    simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'I have highlighted some important parts of the code. The focus is primarily
    on those parts that help us understand the implementation of mouse events. Let''s
    look at the code, line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, you have to define an object—an area that will have the mouse
    event listener set to capture it. In this case, you have to declare the area as
    a rectangle using the `pygame.draw.rect` method call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the main loop, you have to get the position of the mouse, which will
    represent the current cursor coordinates using the `pygame.mouse.get_pos()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, you have to call the `get_pressed()` method from the `pygame.mouse` module.
    A list of Boolean values will be returned. A Boolean `True` value for LEFT, RIGHT,
    or CENTER means that, at a particular instance, a specific mouse button is pressed,
    and the remaining two are not. Here, we captured three Boolean values for three
    mouse buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, to check if the user has pressed in the rectangle or not, you have to call
    the `collidepoint` method and pass a position value to it. The position represents
    the current cursor position. `pressed1` is going to be `True` if the mouse is
    clicked at the current position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When both of these statements are `True`, you can perform any action accordingly.
    Remember that this program is not going to print a message, even if you clicked
    in the window screen, which is not part of the rectangle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Similar to the `pygame.key` module, let''s learn about the `pygame.mouse` module
    in detail. This module contains eight functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pygame.mouse.get_rel()`: It will return the relative mouse movement as a tuple,
    with the *x* and *y* relative movement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pygame.mouse.get_pressed()`: It will return three Boolean values, which represent
    the mouse buttons, and if any one is `True`, the corresponding button is assumed
    as pressed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pygame.mouse.set_cursor()`: It will set the standard cursor image. This is
    rarely needed since better results can be achieved by blitting an image to the
    mouse coordinate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pygame.mouse.get_cursor()`: Two different tasks are performed: firstly, it
    sets the cursor standard image, and secondly, it fetches the deterministic data
    regarding the system cursor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pygame.mouse.set_visible()`: It changes the visibility of the standard mouse
    cursor. If `False`, the cursor will be invisible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pygame.mouse.get_pos()`: It returns a tuple containing the *x* and *y* values
    of the position in the canvas where the mouse is clicked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pygame.mouse.set_pos()`: It will set the mouse position. It takes an argument
    in the form of a tuple containing the coordinates of *x* and *y* in the canvas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pygame.mouse.get_focused()`: This Boolean function result is based on the
    condition of whether the window screen is getting input from mouse or not. It
    is similar to the `key.get_focused` function. When pygame is running in the current
    window screen, the window will get the input from the mouse, but only if the pygame
    window is selected and is running at the front of the display. If another program
    is running in the background and is selected, then the pygame window won''t get
    an input from the mouse, and the output of this method call will be `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might have played games where you fly an airplane or destroy tanks where
    the mouse is used as an aiming device and the keyboard is used for movement and
    firing actions. These games are highly interactive. Therefore, you have to try
    to make a game that can combine both of these events as much as possible. These
    two types of events are very useful and are important for any game development
    I suggest that you take the time to experiment with these events. If possible,
    try to make your own game using only geometrical objects. Now, we are going to
    learn how to make a game using pygame, and our own sprites.
  prefs: []
  type: TYPE_NORMAL
- en: This game will be a modified version of the snake game that was made by the
    turtle module in the previous chapter. All the concepts will be same, but instead
    of dull and bland-looking game characters, we will make visually appealing characters,
    and we will handle events using pygame.
  prefs: []
  type: TYPE_NORMAL
- en: Object rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computers store images in the form of grids of colors. Mostly, RGB (red, green,
    and blue) are enough to provide information for pixels. But apart from RGB values,
    there is another component of an image that is useful when dealing with pygame
    game development, which is alpha information (usually known as attribute components).
    The alpha information represents image transparency. This extra bit of information
    is quite useful; what usually happens in the case of pygame is that we normally
    draw or place one image on top of another with the alpha property activated. By
    doing this, we can see part of the background through it. We normally use third-party
    software such as GIMP in order to make an images' background transparent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from knowing how to make an images'' background transparent, we have
    to know how to import them into our project so that we can use them. Importing
    any static images or sprites into the Python project is easy, and pygame makes
    it even easier. We have an image module, which provides a load method to import
    images. While calling the load method, you have to pass an image with the full
    filename, including the extensions. The following code represents a way of importing
    images into Python projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The image that you want to import into the game project should be in the same
    directory where the game project resides. For example, if the Python file is saved
    in the snake directory, the image that is loaded by the Python file should also
    be saved inside the snake directory.
  prefs: []
  type: TYPE_NORMAL
- en: In the image module, the load function will load a file from your hard drive
    and return a newly generated surface that contains the image that you want to
    load. The first call to `pygame.image.load` will read the image file, and then
    an immediate call to the `convert` method takes place, which will convert the
    image into the same format as our display. Due to the conversion of the image
    and the display screen being in the same depth level, drawing into the screen
    is relatively faster.
  prefs: []
  type: TYPE_NORMAL
- en: The second statement is to load the mouse cursor. Sometimes, you might want
    to load a custom-made mouse cursor into game, and a second line of code is the
    way to do this. In the case of loading `mouse_cursor`, `convert_alpha` is used
    instead of the convert function. This is because the image of the mouse cursor
    contains special information regarding transparency, which is termed as *alpha
    information*, and makes part of the image invisible to detect. By disabling the
    alpha information, our mouse cursor would be besieged by rectangular or square
    shapes, and thus would make the cursor look unprepossessing. Essentially, the
    alpha information is used to denote images that will have a transparent background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have learned how to import images into the Python projects, let''s
    learn how to rotate these images. This is an extremely useful technique because,
    while building games, we may have to rotate images by a certain degree in order
    to make the game appealing. For instance, let''s say that we are making a snake
    game, and we are using an image for the head of the snake. Now, when the user
    presses *up* key on the keyboard, the head of the snake should rotate, and must
    move smoothly upward. This is done by the `pygame.transform` module. The `Rotate`
    method can be called from the transform module in order to facilitate rotation.
    The rotate method takes the image surface, which is loaded from the `image.load()`
    function and specifies the degrees by which the rotation must be done. Usually,
    the operation of transformation would resize, or move part of the pixel, in order
    to make the surface look compatible with the display screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we begin to develop our own visually appealing snake game, you have
    to learn about the Pygame `time` module. Follow this link to learn more about
    it: [https://www.pygame.org/docs/ref/time.html#pygame.time.Clock](https://www.pygame.org/docs/ref/time.html#pygame.time.Clock).
    The `Pygame.time` module is used for monitoring time. The time-clock also provides
    several functions to help control a game''s frame rate. The term frame rate is
    the rate or frequency at which consecutive images appear on a display screen.
    Whenever you call the `Clock()` constructor of the time module, it will create
    an object, which can be used to track time. There are a variety of functions that
    are defined internally by Pygame developers inside the Pygame time module. However,
    we are only going to use the `tick` method, which will update the clock.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Pygame.time.Clock.tick()` should be called once per frame. Between two successive
    calls of the function, the `tick()` method tracks the time between each call in
    milliseconds. By calling `Clock.tick(60)` once per frame, programs are limited
    to running within the boundary of 60 FPS, and cannot exceed it, even if the processing
    power is higher. Thus, it can be used to limit the runtime speed of the game.
    This is important in the case of games that are developed by Pygame because we
    want to run the game smoothly, instead of compensating with CPU resources. The
    value of frames per second (frame rate) can be anywhere from 15 to 40 in the games
    that are developed by Pygame.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have enough information to make our very own game using Pygame, which
    will have sprites and smooth movements for game characters. We will start by initializing
    the display in the next section. We are going to update our snake game using the
    Pygame module.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Initializing the display is pretty basic; you can always start by importing
    the essential modules and providing specific dimensions of the display to the
    `set_mode()` method in order to create a windowed screen. Apart from that, we
    are going to declare a main loop. Refer to the following code to observe the declaration
    of the main loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: After the initialization, you can run your program to check if everything works.
    If you get an error saying `No pygame module`, make sure that you follow the aforementioned
    steps for installing Pygame on your PyCharm IDE. Now, we will learn how to work
    with colors.
  prefs: []
  type: TYPE_NORMAL
- en: Working with colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic principle that works with computer color is *color addition*, which
    is a technique that will add the three primary colors in order to create a new
    one. The three primary colors are red, green, and blue, and often referred to
    as the RGB value. Whenever Pygame requires any color to be added into a game,
    you have to pass it in the tuple of three integers, one for each of the components
    referring to either red, green, or blue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The order in which you pass the integer value to the tuple matters, with a
    small change being made in integer resulting in different colors. The value of
    each of the components of color must range from 0 to 255, where 255 represents
    a color having absolute intensity, and 0 represents that color having no intensity
    at all. For example, (255, 0, 0) represents a red color. The following table indicates
    the color codes for different colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Color name | Hex code#RRGGBB | Decimal code(R,G,B) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Black | #000000 | (0,0,0) |'
  prefs: []
  type: TYPE_TB
- en: '| White | #FFFFFF | (255,255,255) |'
  prefs: []
  type: TYPE_TB
- en: '| Red | #FF0000 | (255,0,0) |'
  prefs: []
  type: TYPE_TB
- en: '| Lime | #00FF00 | (0,255,0) |'
  prefs: []
  type: TYPE_TB
- en: '| Blue | #0000FF | (0,0,255) |'
  prefs: []
  type: TYPE_TB
- en: '| Yellow | #FFFF00 | (255,255,0) |'
  prefs: []
  type: TYPE_TB
- en: '| Cyan/Aqua | #00FFFF | (0,255,255) |'
  prefs: []
  type: TYPE_TB
- en: '| Magenta/Fuchsia | #FF00FF | (255,0,255) |'
  prefs: []
  type: TYPE_TB
- en: 'Now, let''s add some color to our snake game project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, in the next section, we will learn how to create game objects using the
    `pygame` module.
  prefs: []
  type: TYPE_NORMAL
- en: Making game objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to begin the creation of game objects, we won''t use snake sprites
    or images directly. Instead, we will start by using a small rectangular box, and
    later we will replace it with a snake image. This needs to be done in most game
    because we have to test multiple things at the beginning of game development,
    such as frame rate, collisions, rotations, and so on. After we deal with all of
    these, it is easy to add images to the pygame project. Thus, in this section,
    we will make game objects that resemble the rectangular box. We will make the
    head and body of the snake, which will be a small rectangular box. We will initially
    make one box for the head of the snake and another for the food, and then add
    color to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now add movement to the `game` objects. We have been talking about
    these a lot in the previous chapters, such as while handling directional movements
    using vectors::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `change_x` and `change_y` denote the initial position
    for the snake. Whenever start playing our game, the default position for the snake
    will be (`change_x`, `change_y`). By pressing either the left or the right key,
    we change its position.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the game at this moment, you might observe that your game will
    move only one step, and will eventually stop when you press, and then immediately
    release, the keyboard key. This anomaly can be corrected by handling multiple
    movements. In this case, we will create `lead_x_change`, this will change according
    to the main `change_x` variable. Remember that, we are not handling key events
    for up and down; thus, `lead_y_change` is not needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Since, in the new line of code, we added extra information, `lead_x_change`,
    it will be called as a change in the *x* coordinates, and every time the user
    hits the left and right keyboard keys, the snake will move automatically. The
    highlighted part of the code (`change_x += lead_x_change`) is responsible for
    giving the snake continuous movement, even if the user doesn't press any keys
    (the rule of the snake game).
  prefs: []
  type: TYPE_NORMAL
- en: Now, when you press one key, you might see another unusual behavior in the game.
    In my case, I ran my game, and as soon as I started to press the left key, the
    snake began to move quickly, and continuously, from left to right. This is due
    to leniency in the frame rate; we now have to explicitly indicate the frame rate
    for the game so that it limits the runtime speed of the game. We will cover this
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using the frame rate concept
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This topic is not foreign to us; I have tried my best to introduce this topic
    as early as I could. We learned about the concept of frame rate while discussing
    the clock module, too. In this section, we will look at the concept of frame rate
    in action. Up until now, we have made a game that can run, but that has no restraint
    in its movements. It is continuously moving in one direction or another, with
    high speed, and we certainly don''t want that. What we really want is to make
    the snake move continuously, but within a certain frame rate. We will use `pygame.time.Clock`
    to create an object, that will track the time on our game. We will use the `tick`
    function to update the clock. The tick method should be called once per frame.
    By calling `Clock.tick(15)` once per frame, the game will never run at more than
    15 FPS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It is important to understand that FPS is not the same as the speed of a sprite
    in the game. Developers make games in such a way that they can be played on both
    high- and low-end devices. You would see that the game is a little sluggish and
    jerky in a low-featured machine, but sprites or characters in both devices will
    move at an average speed. We are not denying that machines that use time-based
    motion games with slow frame rates will have a less appealing visual experience,
    but it won't slow down the speed of the actions.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, to make a game that is visually appealing, and even compatible in pervasive
    devices, it is usually good practice to offer a frame rate of between 20 to 40
    FPS.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we will handle the remaining directional movements.
    Handling these movements is no different; they can be handled by vectored motion.
  prefs: []
  type: TYPE_NORMAL
- en: Handling directional movements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already handled movements for a change in the *x*-axis. Now, let''s
    add some code that will handle movements in the *y*-axis. To make continuous movements
    of the snake, we have to make `lead_y_change`, which represents the directional
    quantity that is added continuously to the current position, even if the user
    doesn''t press any keyboard keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have handled every possible movement for the snake, let''s define
    the boundary for the snake game. The values of `change_x` and `change_y` represent
    the current position of the head. If the head hits the boundary, the  game will
    be terminated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will learn about another concept of programming, that will make our
    code look cleaner. Until now, we have been using numerical values for many components,
    such as the height, width, FPS, and so on. But what happens if you have to change
    one of these values? There will be a lot of overheads in searching the code and
    debugging it again. Now, instead of using those numerical value directly, we can
    create constant variables, in which we store the values and retrieve them whenever
    they are needed. This process is called the *removal of hardcoding*. Let''s create
    a variable for each of these numeric values with an appropriate name. The code
    should look like something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After removing the hardcoding from the variable initialization steps, we will
    move onto the main game loop. The following code represents the main game loop
    (add it after the initialization step):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have added ways to handle user events inside the main loop, let''s
    refractor the code that represents logic, such as what happens when the snake
    hits boundary of game, or when the snake changes its speed. The following code
    should be added inside the main loop after handling the user events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: All of the preceding code has been described briefly already and what we actually
    did in the preceding three blocks of code is refract the variable to some meaningful
    names so as to remove hardcoding; for instance, adding a variable name to display
    the width, adding a variable name to the color code, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we are going to add a food character to the screen,
    and create some logic to check if the snake has eaten the apple or not.
  prefs: []
  type: TYPE_NORMAL
- en: Adding food to the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding a character to the screen is pretty simple. First of all, create a position
    for the character, and eventually, `blit` the character to that position. In the
    case of the snake game, the food must be rendered in the arbitrary position. Therefore,
    we will use a random module to create the random position. I have created a new
    function, `gameLoop()`, which will use the code from the preceding section. I
    have used `apple` as the food. Later, I will add an apple image to it. The following
    line of code defines the main loop for the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining some initials for the game display and the characters, let''s
    add some logic to add the apples (food) for the snake game (this should be inside
    the `MainLoopForGame` function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The two lines of code will create random positions for *x* and *y*. Make sure
    that you import the random module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we need to define the main game loop inside the `MainLoopForGame`
    function. The code that is added inside the main loop will handle multiple things,
    such as handling user events, drawing game characters, and so on. Let''s start
    by getting the user events from the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will be easy to grasp, as we did this earlier in this chapter.
    We start by filling background screen of the game with a white color, and then
    we get the event using the event class of the `pygame` module. We check if the
    user entered the `q` key, and if they did, then we quit the game. Similarly, now
    that we have an event from the user, let''s handle the events that make the movements
    for snake game—the arrow keys such as the left and right keys. The following code
    must be added after getting the user events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code was already written, so make sure you follow the sequence
    of the program. Refer to the code asset that is provided at the [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter11](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter11).
    Let''s add the remaining code inside the main loop, which handles the logic to
    render the snake''s food. The following code should be added after handling the
    user events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the highlighted part of the code, we will draw a rectangle that is red, and
    render it in the position that is defined by the random modules of the height
    and width of `pixel_size= 10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have added food for the snake, let''s make a function which that
    make the body of the snake. Up until now, we have only been working with the head
    of the snake; now, it''s time to make a function that will increase the snake''s
    body by unit blocks. Remember, this function is only going to be called if the
    snake eats the food:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the main game loop, we have to declare multiple things. To begin with,
    we will declare `snakeArray`, which will contain the body of the snake. The snake
    length''s will be one at the beginning of the game. We will increase it whenever
    the snake eats the food:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The name of the variable tells you everything that you need to know. We have
    done this many times previously, that is, making lists for the snake's head and
    checking if it collides with the snake's body. The snake method call takes `pixel_size`,
    which is the snake dimension, and the snake's list, which contains a list of positions
    that relate to the snake's body. The snake will be `blit`, according to these
    lists, by drawing statements that are defined inside the `snake` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to define the logic to make the snake eat the food. This logic
    has been repeatedly used, and it is no different in the case of pygame. Whenever
    the snake''s head position is the same as the food position, we will increase
    the length of the snake by one and generate food in a new, random position. Make
    sure that you add the following code inside the main game loop, after updating
    the display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Since we are able to add some logic that will check if the snake has eaten the
    food or not, and respond accordingly, it's time to add a sprite or image to the
    characters. As we mentioned earlier, instead of using dull rectangular shapes,
    we are going to add our own snake head. Let's start creating one.
  prefs: []
  type: TYPE_NORMAL
- en: Adding snake sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we can start making our game more appealing—we are going to make the
    snake's head. We don't need any extra knowledge to create images for game characters.
    You can also download images from the internet and use them instead. However,
    here, I will show you how to create one for yourself, and how to use it in our
    snake game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps, line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: Open any *paint* application, or search paint in the search tab, and open the
    application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Press *Ctrl* + *W* to resize and skew the picture that you have selected, or
    simply use the resize button on the upper menu bar. It will open a new resize
    window. Resizing can be done by percentage and pixels. Use percentage resize and
    maintain an aspect ratio of 20 by 20, that is, horizontal: 20 and vertical: 20.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, you will get a draw screen. Choose the color of the snake head
    that you want to make. While making the game, we created a snake body that was
    green; therefore, I will also choose green for the snake''s head. I will use a
    pen and draw something like the following image. You can take your time and create
    an even better one if you wish. After completing it, save the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/38c3a904-cd84-46db-9eb7-458cab37f736.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, you have to make the background of the image transparent. You can use several
    online tools too, but I am going to use GIMP software, which we have talked about
    before. You have to download it from its official website. It is open source,
    and freely available to use. Go to the website and download GIMP: [https://www.gimp.org/downloads/](https://www.gimp.org/downloads/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your previously made snake head with the GIMP software. Go to the Layer
    tab from the upper-most menu, select Transparency, and click on Add alpha channel.
    This will add a channel, which can be used to make the background of our image
    transparent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Color tab from the menu screen. A drop-down menu will appear. Click
    on Color to Alpha to make the background transparent. Export that file in the
    same directory as where your Python file is stored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have a sprite of the snake head, let''s use it and render it using
    the `blit` command in the Python file. As you know, before using any image, you
    have to import it. Since I have saved the snake head image in the same directory
    where the Python file is saved, I can use the `pygame.image.load` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the body of the `drawSnake` method, you have to blit the image; something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you run the game, you will observe one strange thing. As we press
    any one arrow key, the head won''t rotate accordingly. It will remain in its default
    position. Thus, in order to make the sprite rotate, based on the directional movements,
    we have to use the `transform.rotate` function. Observe the snake method, as it
    has a way to `blit` images without rotation. Now, we will add couple of lines
    of code that will make the sprites rotate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, instead of using a rectangular box for the apple, let me download a sample
    of an apple from internet, in the form of a PNG (transparent background), and
    `blit` that, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the game and observe the output. Although the snake head looks bigger,
    we can always resize it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ade1f80d-3bf7-4b01-84e0-f80900e83a5f.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will learn how to add a menu to our game. The menu is
    a screen that is seen whenever you open a game, and it is generally a welcome
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a menu to the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding an introductory screen to any game requires us to have the knowledge
    of working with fonts using the `pygame` module. pygame provides a feature so
    that we can use different types of fonts, including a feature to change the size
    of them. The `pygame.font` module is used to add fonts to games. Fonts are used
    to add text to the game screen. Since the intro or welcome screen requires a player
    to show a screen containing fonts, we have to use this module. The `SysFont` method
    is called to add a font to the screen. The `SysFont` method takes two arguments:
    the first is the name of the font, and the second one is size of the font. The
    following line of code initializes three different sizes of the same font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the `text_object` function first in order to create a surface for
    the small, medium, and large fonts. The text object function will create a rectangular
    surface using the text. The text that is passed to this method is added to the
    box-shaped object and is returned from it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a new function in the Python file, which will add a message to
    the screen using the aforementioned fonts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The message to the `screen` method will create a rectangular surface to `blit`
    the text that is passed as a `msg` to it. The default font size is small, and
    the text is aligned at the center of the rectangular surface. Now, let''s create
    a game intro method for our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This game `intro` method is called before the game `loop` method call. For
    example, look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the output of the welcome menu should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6fb16dc8-2ad6-4d90-bfc6-9ef51d3d3be5.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, our game is ready to be distributed. You might see that our game is
    a Python file with the extension of `.py`, and it cannot be executed in a machine
    that doesn't have Python installed. Thus, in the next section, we will learn how
    to convert a Python file into executables so that we can distribute our game globally
    on Windows machines.
  prefs: []
  type: TYPE_NORMAL
- en: Converting into executables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have got to the point of making your own game with pygame, it's obvious
    that you would like to share it with your friends and family. In the world of
    the internet, sharing a file is pretty easy, but problems arise when a user on
    the other side doesn't have Python preinstalled. It is not possible for everybody
    to install Python for the sole purpose of testing your game. A better idea is
    to make executables that can be executed on many of these machines. We will learn
    how to convert into `.exe` in this section—other versions (Linux and Mac) will
    be covered in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The conversion of Python files into executables is easier if you use the modules
    that are provided by Python. There are a couple of them—`them—py2exe` and `cx_Freeze`.
    We will use the first one in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Using py2exe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To convert Python files into executables, we can use another Python module,
    which is named `py2exe`. The `py2exe` module is not preinstalled in pygame—it''s not
    a standard library—but it can be downloaded by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'After downloading the `py2exe` module, navigate to the folder that contains
    your Python file. Open a Command Prompt or Terminal in that position and run code..
    It will package your Python file into an `.exe` file, or into executables. The
    following command will search for and copy all the files that are used by the
    script to a folder called `dist`. Inside `dist` will be a `snake.exe` file; this
    file will be the output simulation of the Python code, which can be executed without
    Python being installed on the machine. For example, your friend might not have
    installed Python on their machine, but he or she can still run this file. In order
    to distribute the games to any other Windows machine, you can simply send the
    content of the `dist` folder or `snake.exe` file. Just run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This will create your game with the name, *snake* and an extension of `.exe`.
    You can distribute these files across Windows platforms and get a response from
    them. Congratulations! You have finally made it. Now, let's learn about game testing
    using pygame.
  prefs: []
  type: TYPE_NORMAL
- en: Game testing and possible modifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, there may be a case of memory shortage in your machine. If you run
    out of memory and you try to load more images into the game, even with pygame's
    best efforts, this process will be aborted. `pygame.image.load` must be accompanied
    by some memory in order to perform tasks properly. In the case of memory shortages,
    you can predict that you are surely going to trigger some kind of exception. And
    even if there is enough memory, if you try to load an image that is not in your
    hard drive, or say, you made a typo when writing the name of the file, you are
    likely to get an exception. Therefore, it's better to handle them beforehand so
    that we won't have the trouble of debugging them afterward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, let''s check what happens when we provide unusual dimensions of the
    screen to the `set_mode` method. Recall that `set_mode`, is a method that we use
    to create a `Surface` object. For instance, let''s say we forget to add two values
    to `set_mode` and we carried on adding only one. We are going to trigger an error
    in such cases, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say that, instead of forgetting to add proper dimensions for the height
    and width, what happens if we add a height value of 0? This problem does not create
    any exception in the case of PyCharm IDE. Instead, the program will run infinitely,
    causing your machine to break down. However, these programs will normally throw
    an exception of `pygame.error: cannot set 0 sized display`. Now that you know
    the areas where `pygame` could go wrong, you can catch those exceptions and handle
    them accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: So, it's better to choose your display screen sensibly in order to remove any
    unwanted exceptions. But, more likely, you can get the exception of the `pygame`
    error if you try to load an image that is not in your hard drive. Thus, it's good
    practice to handle the exceptions so that the sprites or images for the game are
    loaded properly .
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the `pygame` module and discovered the reasons
    for using it in game development. Most of the games that we are covering from
    the next chapter onwards will be somehow based on the `pygame` module. Thus, make
    sure that you make one simple game using pygame by yourself, before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: We began by learning about how to use pygame objects to make games. We learned
    various things, including handling user key events that involve input devices
    such as the mouse and the keyboard; we made a sprite animation; we learned about
    color properties; and we handled different diagonal and directional movements
    using vectored motion. We have created our own sprites using a simple paint application,
    and added alpha properties using the GIMP application. We tried to make a game
    more interactive by incorporating an interactive game screens, that is, the menu
    screen. Finally, we learned how to convert Python files into executables using
    `py2exe` modules.
  prefs: []
  type: TYPE_NORMAL
- en: The main goal of this chapter was to make you familiar with the usage of sprites
    so that you can build 2D games. You have also learned how to handle user events
    and different movements, including diagonal movements. You also learned how to
    create custom sprites and images using external software, and also the ways of
    using them in the game. Not only that, but you were made familiar with the concepts
    of color and `rect` objects, and learned how to use them to make games more user-interactive,
    by deploying menu and score screens.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to use the concepts that we have learned in
    this chapter to make our own flappy bird clone. In addition to whatever we have
    learned in this chapter, we will learn about game animation, character animation,
    collision principles, random object generation, adding scores, and many more concepts.
  prefs: []
  type: TYPE_NORMAL
