- en: Strong Encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strong encryption conceals data even against determined adversaries, such as
    enemy military agencies, if done correctly. The two main methods of strong encryption
    are AES and RSA, which are both approved by the US government. You do not need
    to have programming experience to learn this, and you don't need any special computer;
    any computer that can run Python can do these projects. Also, you don't need much
    math because we are not going to be inventing new encryption techniques just to
    learn how to use the standard pre-existing ones that don't require anything more
    than very basic algebra.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover  pre-existing:'
  prefs: []
  type: TYPE_NORMAL
- en: Strong encryption with AES
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECB and CBC modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Padding oracle attack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strong encryption with RSA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's next?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strong encryption with AES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a look at the **Advanced Encryption Standard**
    (**AES**), private key encryption, key and block size, how to influence AES, and
    Python and confusion and diffusion.
  prefs: []
  type: TYPE_NORMAL
- en: 'AES is the encryption standard approved by the United States National Institute
    of Standards and is considered very secure. It''s approved even for the storage
    of secret military information. It is private key cryptography, which is the kind
    of cryptography that has been used for thousands of years in which both the sender
    and the receiver use the same key. It''s a block cipher, so the input data has
    to be put in blocks that are 128-bits long, and a block of plaintext is encrypted
    with a key, producing a block of ciphertext:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are three key sizes: 128, 192, and 256-bits. The most common type of
    AES is the 128-bit key size, and that''s what we''ll use in this example. In Python,
    it''s quite easy to use.'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, you need to import the `AES` module from `crypto cipher`, then you
    need a 16-byte key and plaintext, which is some integral multiple of 16 bytes.
    You will then create a new AES object with the key and then calculate it with
    cipher encrypt. This gives you a 16-byte string, which may be unprintable, so
    it's best to encode it as hex to print it out; and, of course, if you decrypt
    it, you get back to your original plaintext. This has many desirable cryptographic
    properties, and one of them is confusion. If you change a bit of the key, it changes
    the entire ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: So, if we change the key to `kex`, you will see that all of the ciphertext changes.
    This is what you want. Two very similar keys produce completely different results,
    so you cannot find any pattern in the results that you could use to deduce information
    about the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, diffusion is a desirable property, where if you encrypt something
    twice with the same key but you change even one bit of the plaintext, again, the
    entire ciphertext changes. See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here we have bytes and we get the same `433` ending in `6a8`. If we change the
    last letter to `t`, you can see that it starts with `90c` and ends with `5d2`;
    that is, it completely changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at that in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Terminal window and start `python`. We will enter the following command,
    as shown in the sceenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We import the `AES` module, where we have a 16-byte key and a 16-byte plaintext.
    We have created an AES object, encrypted it, and then we have printed out the
    hex value over here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we change the key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here we go up to the key line and change that to say `z`, and then do it again,
    creating a new AES object with that key. Performing the encryption and printing
    out the results again, you see everything is different.
  prefs: []
  type: TYPE_NORMAL
- en: It now starts with `b`, ends with `4`, and has completely changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll leave the key where it is and change the plaintext. Let''s change
    `t` to `F`. Now if we encrypt that and print out the result in hexadecimal, once
    again, everything has changed; even though this is the same key as the one above
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, this shows both confusion and diffusion, which are desirable properties.
    In the next section, we'll discuss ECB and CBC modes.
  prefs: []
  type: TYPE_NORMAL
- en: ECB and CBC modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll compare **E****lectronic Codebook** (**ECB**) and **Cipher Block Chaining**
    (**CBC**) and show you how to implement AES CBC in Python.
  prefs: []
  type: TYPE_NORMAL
- en: ECB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the ECB method, each block of plaintext is encrypted with the key separately,
    so if you have two blocks of plaintext that are the same, they will result in
    identical ciphertext:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you have something like an image here with large areas of solid colors such
    as gray and black and then you encrypt it, you''ll just get different colors but
    the pattern won''t change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: That's not good. You can still see that this is a picture of a penguin, and
    that's not what most people expect out of encryption. You expect the encryption
    to conceal the data so attackers looking at the encrypted data can't tell what
    the message is, and here that property is not present.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, CBC is considered the best solution to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: CBC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the key, you add an initialization vector, which is XOR''d with
    the plaintext before encryption. Then for the next block, you take the ciphertext
    produced by encryption and use it as the initialization vector for the second
    block. The output of that is used as the initialization vector for the third block.
    Thus, even if the inputting plaintext is the same in every block, the ciphertext
    will be different in each block:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This results in far more obfuscation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the penguin is now completely invisible and all the bytes are
    just random, so this is preferred from almost every purpose.
  prefs: []
  type: TYPE_NORMAL
- en: To do it in Python, here's how we did the previous AES, which was the EBC mode.
    By default, you don't specify the mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use CBC mode, you put the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: AES mode CBC when you create the cipher object. You also have to provide an
    initialization vector, which can be 16 bytes, just like the key. If you encrypt
    one block of 16 bytes of text, there's no obvious difference in the result because
    of the initialization vector, but it's just a block of hexadecimal. To see the
    effect of this, you need to make the plaintext longer. When you encrypt it, you
    get a blob of hexadecimal. That's the ECB mode, which does not remove all the
    patterns in the data. Here's the CBC mode with the same repeating input. As you
    can see, the output has no pattern, and does not repeat however far you go. So,
    it much more effectively conceals the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at that. We start Python in the Terminal, and then add this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, you can see the 16-byte key and the 16-byte plaintext AES in ECB mode. We
    encrypt it and print the answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to make it longer, we add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can multiply a string object in Python and if you just print it out, you'll
    see it's just the same thing three times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can encrypt that `plain3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we print that out, it''ll have that repeating pattern for 33\. Now, if
    we change the mode, we''ll need an `iv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We just need 16 bytes, so we'll just 16 bytes to `iv`. Next, we create a new
    `AES` object. In the `iv` now, we encryp `plain3` again, and we print out the
    result again.
  prefs: []
  type: TYPE_NORMAL
- en: You see it has `61f`, and you can see that there's no longer any repetition.
    So, this is a much more effective way to encrypt things if you really want to
    obscure the input.
  prefs: []
  type: TYPE_NORMAL
- en: Padding oracle attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will see how padding works in the PKCS # 7 system and then
    show you a system with the `PADDING ERROR` message. Plus, we''ll also deal with
    the padding oracle attack, which makes it possible to craft ciphertext that will
    decode 20 plaintext we want.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the encryption routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We'll have three blocks of data, each 16-bytes long. We'll encrypt the data
    with AES in CBC mode, so in comes the initialization vector and the key. You produce
    three blocks of ciphertext, and each one of the blocks after the first uses the
    output of the previous encryption routine as an initialization vector to XOR with
    the plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how PKCS#7 padding works:'
  prefs: []
  type: TYPE_NORMAL
- en: If one byte of padding is needed, use `01`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If two bytes of padding are needed, use `0202`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If three bytes of padding are needed, use `030303`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And so on...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we have a message here that is only 47-bytes long, then we can''t fill the
    last block, so we have to add a byte of padding. You could use a variety of numbers
    as the padding, but in this system, we use one binary value one, if you have one
    byte of padding needed if you have two, you use two for both bytes and three for
    all three bytes for three bytes of padding and so on. This means that, if we decrypt
    it, we''ll have three blocks of ciphertext. We decrypt it and we''ll get the 47-byte
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The last byte here will always be the padding byte, and that will be `0-1`,
    a binary value of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example of a vulnerable system that you can attack. This is just
    using the same techniques we've made before where we just encrypt things with
    AES and CBC mode, which you can save in `pador.py`, and then you can just import
    it to make it easy to use and more realistic. There have been real systems that
    use this. So, we import, encrypt, and decrypt methods so that we can put in a
    47-pipe message and encrypt it. We'll get a long blob of hexadecimal output.
  prefs: []
  type: TYPE_NORMAL
- en: If we decrypt that, we will get our original input plus one byte of `0`1 at
    the end. x01 is the Python notation for a single byte with the binary value of
    `1`. If you modify the input by keeping the first 47 bytes alone and changing
    the last byte to `A` or `65` and decrypt it, you'll get a padding error. This
    error message may seem harmless, but in fact it makes it possible to completely
    subvert the encryption.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at that:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Terminal and start `python`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will encrypt and decrypt routines. You can see we have the plaintext. When
    we encrypt 47 bytes of plaintext, we get a long binary blob:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When we decrypt that, we get the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00088.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that it in fact added the single byte of padding at the end of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we should do the deformed one. If we set our modified text equal to the
    original plaintext going up to character `47` and then we add `"A"` at the end,
    when we decrypt it, we get `''PADDING ERROR''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00089.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'That is the error message that we can exploit to subvert the system. So, here''s
    how the padding oracle attacked works change:'
  prefs: []
  type: TYPE_NORMAL
- en: Change ciphertext `[16:31]` to any bytes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change ciphertext `[31]` until padding is valid
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Intermediate `[47]` must be `1`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is a diagram of CBC:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00090.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Leave the first 16 bytes of the ciphertext alone. Change this to anything you
    like, such as all-As, and then decrypt that. What will happen is, because you
    changed the bytes in the second block, the second block will turn to random characters,
    and so will the third block. But it'll give you a padding error unless the, very
    last byte  of the very last block is one. So, you brute force it. You change a
    byte to all 256 possible values until the byte becomes `1`, and when that happens,
    you know this value is `1`. You know this value because it's the one that did
    not give you a padding error message, and you can XOR them to determine this intermediate
    value right here. So, proceeding byte by byte to the left, you can determine these
    intermediate values. If you know them, you can put in ciphertext that will make
    anything you like appear in the third block. So, you can defeat the encryption
    even though you don't know the key or the initialization vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code that does it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00091.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00092.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We set the ciphertext equal to the first original 16 bytes of ciphertext and
    then 15 bytes of `A`. Then we vary the next byte through all possible `256` values
    and add the third block of data unchanged. After that, we look to see when we
    no longer get a padding error, and that will be `234`, so the intermediate value
    is `234` XOR one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we want to get the next byte back, we have to arrange two bytes of
    padding, both of which will be `2`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, the final two bytes of ciphertext `46` and `47` will both be two. So, we
    set ciphertext `31` to the value needed to create two there. Now that we know
    the intermediate value, we can calculate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We vary ciphertext `30` until the padding is valid and that will determine
    the next byte of the intermediate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Leave the first block unchanged and add 14 bytes of a vary the next byte. Leave
    the byte at the chosen value of `233` so you know that the final byte of the decrypted
    output will be `2`, and when the padding error message goes away, you can take
    that number, XOR it with `2`, and you get the next value of the intermediate.
    So, now we can make messages. We would have to repeat this more times to get more
    bytes, but for this demonstration, we''ll settle for a message just one letter
    long. We''ll make an `A` followed by a binary value of `1` for valid padding.
    That''s our goal, and in order to do that, all we have to do is set ciphertext
    `30` and `31` to these chosen values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ciphertext[30] = ord("A") ^ 113`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ciphertext[31] = 16 235`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we know the intermediate values are `113` and `235`, we just need to XOR
    these intermediate values with the values we want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will create ciphertext that will decrypt to a message ending in `A` and
    a binary `1`, so let''s see that go. Now, this one is a little complicated, so
    we''ve chosen to save some of the text here in a text editor so we can do it stage
    by stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s our Python:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright, we import the library, which we already had anyway. Here we leave
    the first 16 bytes unchanged and fill in 15 bytes with `A`. Then, we have the
    loop that changes the next byte''s every possible value and leave the third block
    of data unchanged. We run through the loop until we no longer get a padding error.
    This tells us that `234` is the value that gives us correct padding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we take `234` to the `1`, which tells us the intermediate value, all over
    cut the indentation right, so it''s `234` XOR `1`. This tells us that the value
    is `235`. That''s the intermediate value. For the next bit, use a very similar
    process, so now we have 14 bytes of padding. We will vary the next byte, and the
    byte after that is `233`, which is chosen to always give us a `2` at the end.
    So, when we run this loop through, it is correctly padded at `115`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So, `115` XOR `2` is `113`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, `113` is the next byte of intermediate value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know these two numbers, `235` and `113`, we can control the last
    two bytes of plaintext. Now we will keep the first block of input data unchanged.
    We have 14 bytes of padding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We choose to make `A` and a binary one with the two bytes, `235` and `113`.
    When we create the modified ciphertext and decrypt it, we get the following message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first block of data is unmodified. The second block and most of the third
    block have changed to random characters, but we controlled the last two bytes
    and we could make them say anything we wanted. So, we are able to create ciphertext
    that will decrypt at least partly two values we choose, even though we don't know
    the key or the initialization vector.
  prefs: []
  type: TYPE_NORMAL
- en: Strong encryption with RSA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover public key encryption, the RSA algorithm, and
    implementation in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Public key encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In public key encryption, we solve this problem: Google, for example, wants
    to receive confidential data from users, such as passwords and credit card numbers,
    but they don''t have a secure communication channel; what they have is the public
    internet, and any data being sent might be eavesdropped upon by any number of
    attackers. Thus, there''s no way to deliver a shared secret key, and symmetric
    encryption algorithms, such as AES, cannot solve this problem. That''s where public
    key encryption comes in.'
  prefs: []
  type: TYPE_NORMAL
- en: Google creates a key pair. They keep the private key secret and don't tell anyone,
    and they publish public key so anyone can know it. Everyone who wants to send
    secrets to Google can encrypt them with the public key and send them over an insecure
    channel because the only one who can decrypt them is Google, who has the private
    key. Mailboxes work like this. Anybody can go to the mailbox and put mail in the
    top slot, but the bottom door is locked, and only the postal worker with the private
    key can take the mail out. The private key and the public key must be related,
    but they have to be related by a one-way function so that it's easy to calculate
    the public key from the private key, which is what Google has to do when they
    first set up their key pair. But it has to be very difficult to calculate the
    private key from the public key, so it's safe to publish the public key and no
    one's going to find the private key.
  prefs: []
  type: TYPE_NORMAL
- en: RSA algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are various one-way functions that can be used for this purpose, but
    in RSA, the function is factoring a large number:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Private key `d` is made from two large prime numbers: `p` and `q`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public key is the product of `n = p * q`, and and arbitrary value `e`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `p` and `q` are large, factoring `n` into `p` and `q` is very difficult
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you multiply the two prime numbers `p` and `q` together to create their
    product `n`, it is a well-known difficult problem to factor `n` into `p` and `q`.
    And if `p` and `q` are large enough, it becomes essentially impossible. This is
    the one-way function. You can easily multiply `p` and `q` to create the public
    key `n`, but knowledge of the public key cannot be used to determine `p` and `q`
    practically:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public key**: This is two numbers, `(n,e)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`e` can be any prime number, often `65537`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encryption**: `y = x^(e )mod n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decryption**: `x = y^d mod n `'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x` is plaintext, `y` is ciphertext'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, the public key is `n`, which is the product of two prime numbers and another
    arbitrary number, `e`, which is often just this value `65,537`. Anyone who wishes
    to secretly send their plaintext, `x`, raises it to the power of `e`, modulus
    `n`, and sends that scrambled stuff over an insecure channel, such as the internet,
    to the recipient. The recipient has the private key so they can find the decryption
    key, `d`, and they take the ciphertext to `d` modulus `n`, and that turns into
    the decrypted message. The decryption key is calculated this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '`phin = (p-1) * (q-1)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d*e  = 1 mod phin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since Google knows the `p` and `q` secrets, they can calculate this number `phin`
    which is `p - 1`, times `q - 1` and then they choose a decryption key so that
    `d` times `e` is `1` modulus `Phi` of `n`. Nobody else can do this calculation
    because they do not know the values of `p` and `q`. So, in Python, you can import
    the `RSA` module and then generate a key of whatever length you like. In this
    example, we have used `2048` bits, which is the current National Institute of
    Standards recommendation. Then, they have a public key. There's a message to encrypt
    and you encrypt it, and the result is this very long ciphertext, which is as long
    as `2048` bits. ciphertext is long and the calculations are very slow, so you
    do not normally send a long message with this method. What you do in RSA is just
    send a secret key, and then you use AES to encrypt everything after that point
    to make the calculations faster. This chapter covers something called textbook
    RSA, which contains many of the essential ingredients but is not really secure
    enough for real use, because you have to add a padding that is specified in RFC
    8017\. This adds a hash value, a mask, and padding to the message and protects
    the key from some attacks. Let's take a look at this in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is how we can implement what we''ve talked about in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start up `python` and then add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00096.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The last step shown takes around 2 to 4 seconds just to generate the key; that''s
    because it had to find two large prime numbers, and these are very difficult calculations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It has to guess a number and test it, and typically, it has to try more than
    a hundred guesses for each of these large prime numbers, so this process is very
    time-consuming. However, it happens automatically, and now we can encrypt the
    message with the key, producing this very long ciphertext:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we could test this to see whether we change one bit of the message or
    take the plaintext and change that last letter to an `f`. If we encrypt that,
    the results will be similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we print the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00099.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, all `4ac` go to `1dc`, and then it ends at `578` to `633`. This
    is the desirable property of strong encryption. Any change in the input changes
    all of the output clipping approximately half the bits.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge – cracking RSA with similar factors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover topics such as large integers–in Python and the
    `decimal` library. We will also take a look at an example of factoring a large
    number and then two challenges for you to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Large integers in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python can do multiplication and division–and a contented multiplication and
    division of arbitrarily large integers with complete precision:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we have `1001` and then we calculate `1001` squared, we get the right answer,
    of course; and even if we take a number like `10**100 + 1`, it correctly gets
    that number a hundred places with a `1` at each end. Now, if we square that number,
    it again gets it correct, all the way to the one at each end.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for simple integer operations, Python''s precision is unlimited. However,
    if we want to square root, we need to import a `math` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00101.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `math` library does not keep any arbitrary number of places, as you can
    see in the preceding code. If we take `10 **100 + 1` and square it, then take
    the square root, we don't get `10 **100 + 1`. We get `10 ** 100`, which means
    it rounded off to some number of places less than `100`, and that's fine for many
    purposes. However, it's not fine for what we want to do here, which is factor
    large integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do that, you use the `decimal` library, and we will import it as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00102.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have imported the `decimal` library and set value to `a`
    as `10 **100+ 1`. Here `b` equals to a squared, and then instead of calculating
    the square root of `b` with the `math` library, you calculate the decimal value
    of `b` with the `decimal` library. Use the square root method of that and this
    gives you again the wrong answer, because by default, the `decimal` library rounds
    things off. But if you set the precision to be higher, you get exactly the right
    answer, and that's why the `decimal` library is better for our purposes. This
    `getcontext().prec` command lets us set it to keep enough places to be as precise
    as we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'All right, so, you wouldn''t be able to factor a large number in the general
    case, and that''s what makes RSA secure. But, if a mistake is made by using numbers
    and can be predictable in some way, then RSA can be cracked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00103.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here the mistake is using two prime factors that are close together instead
    of choosing independent random numbers for the two prime factors. So, this large
    number is the product of two prime factors, and so you can factor it. So, if we
    put that number in a value called `n`, we set the precision to `50` places and
    calculate the square root. We find that the square root is `1` followed by many
    zeros, and that is ended at `83` +a fraction.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if the number is the product of two prime numbers, and the two prime numbers
    are close together, one number must be less than the square root and the other
    number must be larger than the square root.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we simply start at the square root and try numbers close to the square
    root by jumping back by two every time, we will eventually find the prime factor,
    and we do:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00104.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, we can jump back by twos because even numbers are certainly not prime,
    so we don't need to test the even numbers.
  prefs: []
  type: TYPE_NORMAL
- en: And, as we can see, now we've found a number where the modulus of `n` modulus
    the number is zero, so this is a prime factor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get the other prime factor by just dividing `n` by the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, here's the original number, `n`, which is the product of two primes, and
    we have one of the primes; `q` is `n` over `p` which you can see. To test it,
    if we calculate `p*q`, we get the original number again. So, we have factored
    a large number into `p` and `q`, and that is enough information to crack RSA.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s try that in Python. Go to the Terminal and run `python`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00106.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, we have `n` equal to the large number shown. We import this number to the
    `decimal` library and set the position to `50` places. Now, if we take the square
    root, we get `1` followed by many zeros, and then `83`, and then a fraction. Then,
    we copy the integer part of the square root:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00107.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we set `p` in range of that number followed by the number, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This begins a loop, and all we have to do is print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It will calculate `n` modulus `p`, which will be zero. If that''s an integral
    multiple, pressing *Enter* twice runs the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00108.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, we can see this number is `p`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we copy that number, we can set `p` equal to that and can set `q` equal
    to `n` over `p`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we print, we will get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00109.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can see `n` matches with `p*q`. So, we've now factored that long number
    into its complement primes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the first challenge:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00110.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the second challenge:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00111.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In both cases, you will be able to factor them.
  prefs: []
  type: TYPE_NORMAL
- en: What's next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Internet of Things** (**IoT**) has a promising future and will soon connect
    billions of devices. For IoT, security has always been a major concern. But the
    good news is that cryptography offers various options to secure IOT from hackers;
    hence, it is a key to the coming era of IoT.'
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography within IoT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we talk about using cryptography within IoT, we are talking about using
    cryptography across many layers of the communication stack. If we look at the
    OSI model, we can see that crypto is used at Layer 2 and up with linking operating
    at level 2, networking operating at layer 3, and transporting operating at layer
    4:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00112.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: At the Application Layer, Cryptography is also used to protect communication
    through both authentication and encryption. Before we begin our description about
    specific cryptographic approaches for IOT protocols, let’s first talk about the
    ready availability of exploitation tools for existing wireless protocols. As IOT
    matures, keep in mind that there are many tools available to exploit IOT wireless
    communication protocols and these tools will continue to rapidly keep up with
    new technologies introduced to support the IOT.
  prefs: []
  type: TYPE_NORMAL
- en: For example, looking at Wi-Fi 802.11, which was introduced in 1989, the AirCrack
    tool was introduced in 2004 and to this day is still a popular and well-supported
    tool. There are also many tools available to exploit Bluetooth communication and
    cellular communication.
  prefs: []
  type: TYPE_NORMAL
- en: Besides this, keys that drive crypto must be securely managed both at the device
    (module) level as well as throughout an enterprise. Let’s explore some of them.
  prefs: []
  type: TYPE_NORMAL
- en: ZigBee cryptographic keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ZigBee uses many keys for cryptographic operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Link key**: This is established based on the use of pre-provisioned master
    key from the manufacturer. The link key provides point-to-point secure connection
    between two ZigBee nodes. The link key is also used to establish derived keys,
    including data keys, key-transport keys, and Key-load keys'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key-transport keys**: This key is the outcome of executing the specialized
    keyed hash function under the link key with the 1-octet string 0x00 as the input
    string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complexity of ZigBee key management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, key management is challenging. Let’s take a look at how
    challenging key management can be. Take, for example, the ZigBee protocol. There
    are three primary types of keys that can be employed within the ZigBee network.
    Master keys are often preinstalled by the vendor and protect the exchange between
    two ZigBee nodes as they generate link keys. Link keys support node-to-node communication
    and network keys support broadcast communication.
  prefs: []
  type: TYPE_NORMAL
- en: Key management functions might be built into the media management software of
    utility, for example, and it might be provided as standalone software. However,
    all of these keys need to be sufficiently secured across their entire lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: Bluetooth – LE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Bluetooth low energy protocol employs cryptography for pairing devices for
    future relationships. Bluetooth—LE uses various keys within these cryptographic
    processes, including a **long-term key** (**LTK**), which is used to generate
    a 128-bit key for the link layer encryption and a **connection signature resolving
    key** (**CSRK**), which is used for digitally signing data at the ATT layer.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we come to the end of this book. Cryptography applications should
    be tailored specifically for the threat environments. Cryptography is based on
    strong, well- designed algorithms and associated with all layers of the communication
    stack. It is everywhere and fundamental to the security of IOT systems.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered AES, the strongest private key system in common
    use today, and its two modes, ECB and CBC. We covered the padding oracle attack
    against CBC, which is made possible when an error message gives the attacker more
    information than they should have about the encryption process.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we covered RSA, the primary public key algorithm in use today to send
    secrets over the internet, and we also looked at the challenge where we cracked
    RSA in the case where the two prime numbers are similar instead of being independent
    and randomly chosen. We also looked at the future of cryptography and how it will
    help secure IOT devices.
  prefs: []
  type: TYPE_NORMAL
