- en: Creating Real-Time Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Nothing endures but change."'
  prefs: []
  type: TYPE_NORMAL
- en: – Heraclitus
  prefs: []
  type: TYPE_NORMAL
- en: What is real-time software? A list of friends gets updated the instant one joins
    or exits. Traffic updates automatically stream into the smartphones of drivers
    looking for the best route home. The sports page of an online newspaper immediately
    updates scoreboards and standings as points are scored in an actual game. Users
    of this type of software expect reactions to change to be communicated quickly,
    and this expectation demands a particular focus on reducing network latency from
    the software designer. Data I/O updates must occur along subsecond time frames.
  prefs: []
  type: TYPE_NORMAL
- en: Let's step back and consider the general characteristics of the Node environment
    and community that make it an excellent tool for creating these kinds of responsive
    network applications.
  prefs: []
  type: TYPE_NORMAL
- en: Some validation of Node's design, it may be argued, is found in the enormous
    community of open developers contributing enterprise-grade Node systems. Multicore,
    multiserver enterprise systems are being created using free software mostly written
    in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why are so many companies migrating toward Node when designing or updating
    their products? The following list enumerates the reasons why:'
  prefs: []
  type: TYPE_NORMAL
- en: Node offers the excellent npm package management system, which integrates easily
    with the Git version control system. A shallow learning curve helps even inexperienced
    developers safely store, modify, and distribute new modules, programs, and ideas.
    Developers can develop private modules on private Git repositories and distribute
    these repositories securely within a private network using npm. As a result, the
    community of Node users and developers has rapidly expanded, some members gaining
    great fame. *If you build it, they will come*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Node lifted the system-access barrier for a large group of skilled programmers,
    suddenly releasing pent-up talent into an empty volume, offering the ecosystem
    of opportunity that a popular new project in need of many improvements in infrastructure
    brings. The point is this: Node merged the opportunity of concurrency with native
    JavaScript events; its brilliantly designed API allowed users of a well-known
    programming paradigm to take advantage of high-concurrency I/O. *If you reward
    them, they will come*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node lifted the network-access barrier for a large group of JavaScript developers
    whose work and ambition had begun to outgrow the tiny sandbox available to client
    developers. It should not be forgotten that the period of time extending from
    the introduction of JavaScript in 1995 to the present is now over 20 years. Nearly
    a generation of developers has struggled trying to implement new ideas for network
    applications within an event-driven development environment known for, even defined
    by, its limitations. Overnight, Node removed those limitations. *If you clear
    paths, they will come*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node provides an easy way to build scalable network programs, where network
    I/O is no longer a bottleneck. The real shift is not from another popular system
    to Node—it is away from the idea that expensive and complex resources are needed
    to build and maintain efficient applications demanding burstable concurrency.
    If a resilient and scalable network architecture can be achieved cheaply, freed
    resources can be directed to solving other pressing software challenges, such
    as parallelizing data filtering, scaling massively multiplayer games, building
    real-time trading platforms or collaborative document editors, even implementing
    live code changes in hot systems. Confidence breeds progress. *If you make it
    easy, they will come*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Node arrived at a time when those building dynamic web pages had begun to run
    up against the limitations of servers not equipped to smoothly field many small,
    simultaneous requests. The software architect must now solve some interesting
    problems: what are the rules of *real time*—will the user be satisfied with *soon*,
    or is *now* the only right response? And, what is the best way to design systems
    responsible for satisfying these user desires?'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will investigate three standard techniques available to
    developers to use when constructing real-time network applications: AJAX, WebSockets,
    and server-sent events (SSE). Our goals for this chapter are to learn the benefits
    and drawbacks of each of these techniques, and to implement each technique with
    Node. Remembering that we are aiming to achieve a consistent architecture reflecting
    the evented-streams design of Node, we will also consider how well each technique
    lends itself to representation as a readable, writable, or duplex stream.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will close this chapter with the construction of a collaborative code editor,
    which should demonstrate the opportunities Node provides for those seeking to
    build real-time groupware. As you work your way through the examples, and build
    your own applications, these are some questions that are worth asking yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the volume of messages I expect to transact per second? How many simultaneously
    connected clients are expected at peak times and at off-peak times?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the average size of the messages being transmitted?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can I accept occasional communication breakdowns or dropped messages if this
    concession buys me lower average latency?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do I really need bidirectional communication, or is one side responsible for
    nearly all message volume? Do I need a complicated communication interface at
    all?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What sorts of networks will my application run within? Will there be proxy servers
    between a client and my Node server? Which protocols are supported?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do I need a complex solution or will simple and straightforward, even slightly
    slower, solutions bring other benefits in the long run?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing AJAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2005, Jesse James Garrett published an article in which he tried to condense
    the changes he had been seeing in the way that websites were being designed into
    a pattern. After studying this trend, Garrett proposed that dynamically updating
    pages represented a new wave of software, resembling desktop software, and he
    coined the acronym, *AJAX***,** to describe the technological concept powering
    such rapid movement toward *web applications*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This was the diagram he used to demonstrate the general pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/705a2392-c4f4-4f16-b238-d58c5e77eca4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The original article can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://adaptivepath.org/ideas/ajax-new-approach-web-applications/](http://adaptivepath.org/ideas/ajax-new-approach-web-applications/).'
  prefs: []
  type: TYPE_NORMAL
- en: The "*AJAX engine*" *Garrett's* diagram referred to had in fact existed in most
    common browsers by the year 2000, and even earlier in some. JavaScript implementations
    of the **XMLHttpRequest** (**XHR**) object in these browsers gave web pages the
    ability to request *chunks* of HTML or other data from servers. Partial updates
    could be dynamically applied to a web page, creating the opportunity for new kinds
    of user interfaces. For example, the latest pictures from an event could magically
    appear to a user, without that user actively requesting a page refresh, or clicking
    a Next Picture button.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, Garrett also understood how the synchronous, stateless world
    of the *old* internet was becoming an asynchronous, stateful one. The conversation
    between clients and servers was no longer being derailed by sudden amnesia and
    could continue usefully for longer periods of time, sharing increasingly useful
    information. Garret saw this as a shift to a new generation of network software.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If changes can be introduced into a web application without requiring a complete
    reconstruction of state and state display, updating client information becomes
    cheaper. The client and server can talk more often, regularly exchanging information.
    Servers can recognize, remember, and respond immediately to client desires, aided
    by reactive interfaces gathering user actions and reflecting the impact of those
    actions within a UI in near real time.
  prefs: []
  type: TYPE_NORMAL
- en: 'With AJAX, the construction of a multiuser environment supporting real-time
    updates to each client''s view on the overall application state involves regular
    polling of the server by clients checking for important updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f9a7fcf-e3cd-460c-b6ac-2759125b945a.png)'
  prefs: []
  type: TYPE_IMG
- en: The significant drawback to this method of polling for state is that many of
    these requests will be fruitless. The client has become a broken record, constantly
    asking for status updates regardless of whether those updates are available or
    forthcoming. When an application spends time or energy performing unnecessary
    tasks, there should exist some clear benefit to the user or the provider (or both)
    offsetting this cost. Additionally, each futile call adds to the cost of building
    up then tearing down HTTP connections.
  prefs: []
  type: TYPE_NORMAL
- en: Such a system can only take snapshots of the state at periodic intervals, and
    as that polling interval may increase to several seconds in an effort to reduce
    redundant network chatter, our awareness of state changes can begin to appear
    dull, just a little behind the latest news.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw a better solution in the previous chapter—long polling, the technique
    of letting a server hold on to a client connection until new data is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e75d3f2e-60b1-43ad-90b5-302707dde4c5.png)'
  prefs: []
  type: TYPE_IMG
- en: This improved AJAX technique does not fully escape the cost of building up and
    tearing down network connections, yet a significant reduction in the number of
    such costly operations is achieved. In general, AJAX fails to deliver a smooth,
    stream-like evented interface, requiring a great deal of attending services to
    persist state as connections are regularly broken and then reestablished.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, AJAX remains a real option for some applications, in particular
    simple applications where the ideal polling interval is fairly well known, each
    poll standing a good chance of gathering useful results. Let's use Node to build
    a server able to communicate with a stock reporting service, and build a polling
    client that periodically requests this server to check for changes and report
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a stock ticker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ultimately, we will create an application that allows clients to pick a stock
    and watch for changes in the data points related to that stock, such as its price,
    and to highlight positive or negative changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/daf8e1a5-a9f3-430a-9a96-822e15020901.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To create the client, our work is minimal. We need to simply poll our server
    every few seconds or so, updating our interface to reflect any data changes. Let''s
    use jQuery as our AJAX library provider. To fetch JSON from a server using jQuery,
    you will normally do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A Node server will receive this request for an update, perform some I/O (check
    a database, call an external service), and respond with data, which the client
    can use.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, Node will be used to connect to the IEX Developer Platform ([https://iextrading.com/developer/](https://iextrading.com/developer/)),
    which provides stock quotes for free.
  prefs: []
  type: TYPE_NORMAL
- en: We will construct a Node server that listens for clients requesting an update
    to the data for a given stock symbol, such as "IBM". The Node server will then
    create a YQL query for that stock symbol and execute that query via `http.get`,
    packaging the received data nicely for the calling client and sending it back.
  prefs: []
  type: TYPE_NORMAL
- en: This package will also be assigned a new `callIn` property, indicating the number
    of milliseconds the client should wait before calling again. This is a useful
    technique to remember, as our stock data server will have a much better idea of
    the traffic conditions and the update frequency than the client will. Instead
    of a client blindly checking on a fixed schedule, our server can recalibrate this
    frequency after each call, even demanding that the client stop calling!
  prefs: []
  type: TYPE_NORMAL
- en: 'As this design, particularly the visual design, can be done through any number
    of ways, we will simply look at the core functionality necessary for our client,
    contained within the following `fetch` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Users on this page enter stock symbols into an input box with ID `#symbol`.
    This data is then fetched from our data service. In the preceding code, we see
    the service call being made via the `$.getJSON jQuery` method, the JSON data being
    received, and a `setTimeout` property being set using the `callIn` interval sent
    back by Node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our server is responsible for brokering the preceding client call with the
    data service. Assuming that we have a properly configured server that successfully
    receives stock symbols from clients, we need to open an HTTP connection to the
    service, read any response, and return this data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see a good example of why it is a good idea to let the server, the
    primary observer of state, modulate the frequency with which clients poll. If
    a successful data object is received, we set the poll interval (`callIn`) to about
    five seconds. Should an error occur, we increase that delay to 10 seconds. It
    is easy to see how we might do more, perhaps, throttling connections further if
    repeated errors occur. Given that, there will often be limits on the rate at which
    an application may make requests to an external service (such as limiting the
    number of calls that can be made in one hour); this is also a useful technique
    for ensuring that constant client polling doesn't exceed these rate limits.
  prefs: []
  type: TYPE_NORMAL
- en: 'AJAX is the original technique for creating real-time applications. It remains
    useful in some cases, but has been superseded by more efficient transports. As
    we leave this section, let''s keep in mind some of the advantages and disadvantages
    of polling:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pros** | **Cons** |'
  prefs: []
  type: TYPE_TB
- en: '| The theory and practice of REST is available, allowing more standardized
    communication | Making and breaking connections imposes a cost on network latency,
    especially if done very often |'
  prefs: []
  type: TYPE_TB
- en: '| No need for any special protocol server, with polling easily implemented
    using a standard HTTP server | Clients must request data; servers are unable to
    unilaterally update clients as new data arrives |'
  prefs: []
  type: TYPE_TB
- en: '| HTTP is well-known and consistently implemented | Even long polling doubles
    the network traffic needed to maintain a persistent connection |'
  prefs: []
  type: TYPE_TB
- en: '|  | Data is blindly pushed and pulled, rather than smoothly broadcast and
    listened for on channels |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s move on now into a discussion of some newer protocols, in part designed
    to solve some of the issues we''ve found with AJAX: WebSockets and SSE.'
  prefs: []
  type: TYPE_NORMAL
- en: Bidirectional communication with socket.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're already familiar with what sockets are. In particular, we know how to
    establish and manage TCP socket connections using Node, as well as how to pipe
    data through them bidirectionally or unidirectionally.
  prefs: []
  type: TYPE_NORMAL
- en: The W3C has proposed a socket API that allows browsers to communicate with a
    socket server over a persistent connection. `socket.io` is a library that facilitates
    the establishment of persistent socket connections for those developing with Node,
    providing both a Node-based socket server and an emulation layer for browsers
    that do not support the `WebSocket` API natively.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first take a brief look at how the native WebSocket API is implemented,
    and how to build a socket server supporting this protocol using Node. We will
    then build a collaborative drawing application using `socket.io` with Node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full specification for the `WebSocket` API can be found at: [http://www.w3.org/TR/websockets/. ](http://www.w3.org/TR/websockets/)Documentation
    and installation instructions for `socket.io` can be found at: [https://socket.io/](http://socket.io/)'
  prefs: []
  type: TYPE_NORMAL
- en: Using the WebSocket API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Socket communication is efficient, only occurring when one of the parties has
    something useful to say:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20c55a5c-de5a-4eb0-8151-7e06441bdb44.png)'
  prefs: []
  type: TYPE_IMG
- en: This lightweight model is an excellent choice for applications that require
    high-frequency message passing between a client and a server, such as found in
    multiplayer network games or chat rooms.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the W3C, the WebSocket API is intended *to "enable web applications
    to maintain bidirectional communications with server-side processes."* Assuming
    that we have established a socket server running at `localhost:8080`, we can connect
    to this server from a browser containing the following line of JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`WebSocket` expects two arguments: an URL prefixed by the URI scheme `ws://`,
    and an optional subprotocol list, which can be an array or a single string of
    protocols that a server may implement.'
  prefs: []
  type: TYPE_NORMAL
- en: To establish a secure socket connection, use the `wss://` prefix. As with HTTPS
    servers, you'll need an SSL certificate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a socket request is made, the connection events, open, close, error, and
    message can be handled by a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For this example, we''ll implement a `WebSocket` server in Node using the ws
    module at: [https://github.com/websockets/ws](https://github.com/websockets/ws).
    After installing ws using npm (`npm i ws`), establishing a Node socket server
    is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see how the server simply listens for the `connection` and `message`
    events from clients, responding as necessary. Should there be a need to terminate
    a connection (perhaps, if the client loses authorization), the server can simply
    emit a `close` event, which a client can listen for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The general schematic for an application using the WebSocket API to create
    bidirectional communication therefore looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c6e068c-8269-4d4d-b0da-61edf9fce8fa.png)'
  prefs: []
  type: TYPE_IMG
- en: The native WebSocket browser implementation is used here to communicate with
    our custom Node socket server, which fields requests from the client as well as
    broadcasting new data or information to the client when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: socket.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned previously, `socket.io` aims to provide an emulation layer that
    will use the native `WebSocket` implementation in browsers that support it, reverting
    to other methods (such as long polling) to simulate the native API in legacy browsers
    that don''t. This is an important fact to keep in mind: there are still some old
    browsers out there.'
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, `socket.io` does a very good job of hiding browser differences
    and remains a good choice when the control flow made available by sockets is a
    desirable model of communication for your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `WebSocket` implementation used in the preceding example (`ws`), it
    is clear that the socket server is independent of any specific client file. We
    wrote some JavaScript to establish a `WebSocket` connection on a client, independently
    running a socket server using Node. Unlike this native implementation, `socket.io`
    requires a custom client library to be installed on a server in addition to the
    `socket.io` server module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba61389a-37f6-422b-9be3-5cb98714aa72.png)'
  prefs: []
  type: TYPE_IMG
- en: '`socket.io` can be installed using the `npm` package manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Setting up a client/server socket pairing is straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'On the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can see how both the client and the server are using the same file, `socket.io.js`.
    A server using `socket.io` handles the serving of the `socket.io.js` file to clients
    automatically when requested. It should also jump out how closely the `socket.io`
    API resembles a standard Node `EventEmitter` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing collaboratively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a collaborative drawing application using `socket.io` and Node.
    We want to create a blank canvas that will simultaneously display all the *pen
    work* being done by connected clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fcb18fa-585d-4dce-aef8-cb16bde157b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the server end, there is very little to do. When a client updates coordinates
    by moving their mouse, the server simply broadcasts this change to all connected
    clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`socket.io` automatically generates a unique ID for each socket connection.
    We will pass this ID along whenever new draw events occur, allowing the receiving
    clients to track how many users are connected. Similarly, when a client disconnects,
    all other clients are instructed to remove their references to this client. Later,
    we will see how this ID is used within the application UI to maintain a pointer
    representing all connected clients.'
  prefs: []
  type: TYPE_NORMAL
- en: This is an excellent example of just how simple it is to create multiuser network
    applications using Node and the packages created by the Node community. Let's
    break down what this server is doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we will need to deliver the HTML file that clients will use to draw,
    half of the server setup involves creating a static file server. For convenience,
    we''ll use the node-static package at: [https://github.com/cloudhead/node-static](https://github.com/cloudhead/node-static).
    Our implementation will serve an `index.html` file to any client who connects.'
  prefs: []
  type: TYPE_NORMAL
- en: Our `socket.io` implementation expects to receive `mousemove` events from clients,
    and its only task is to send to all connected clients these new coordinates, which
    it does by emitting a moving event through its `broadcast` method. As one client
    changes the canvas state by drawing a line, all clients will receive the information
    necessary to update their view of the canvas state in real time.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the communication layer built, we now must create client views. As mentioned,
    each client will load an `index.html` file containing the necessary canvas element,
    and the JavaScript necessary to listen for moving events, as well the `socket.io`
    emitter broadcasting client draw events to our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A `pointers` element is created to hold visible representations for the cursors
    of all connected clients, which will update as connected clients move their pointers
    and/or draw something.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `script.js` file, we first set up event listeners on the `canvas`
    element, watching for the combination of `mousedown` and `mousemove` events indicating
    a draw action. Note how we create a time buffer of 50 milliseconds, delaying the
    broadcast of each draw event, slightly reducing the resolution of drawings but
    avoiding an excessive number of network events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever a draw action occurs (a combination of a `mousedown` and a `mousemove`
    event), we draw the requested line on the client''s machine, and then broadcast
    these new coordinates to our `socket.io` server via `socket.emit(''mousemove'',
    …)`, remembering to pass along the `id` value of the drawing client. The server
    in turn will broadcast them via `socket.broadcast.emit(''moving'', data)`, allowing
    client listeners to draw equivalent lines on their `canvas` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Within this listener, a client will establish a new client pointer if the sent
    client ID has not been seen previously, and animate both the drawing of a line
    and the client pointer, creating the effect of multiple cursors drawing distinct
    lines within a single client view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recalling the `clientdisconnect` event we track on our server, we also enable
    clients to listen for these disconnects, removing references to lost clients from
    both the view (visual pointer) and our `clients` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`socket.io` is an excellent tool to consider when building interactive, multiuser
    environments where continuous rapid bidirectional data transfer is necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, take a look at the pros and cons of `socket.io`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pros** | **Cons** |'
  prefs: []
  type: TYPE_TB
- en: '| Rapid bidirectional communication essential to real-time games, collaborative
    editing tools, and other applications | The number of allowed persistent socket
    connections can be limited on the server side or anywhere in between |'
  prefs: []
  type: TYPE_TB
- en: '| Lower overhead than standard HTTP protocol requests, lowering the price of
    sending a package across the network | Many proxies and reverse proxies are known
    to confound socket implementations, leading to lost clients |'
  prefs: []
  type: TYPE_TB
- en: '| The evented, streaming nature of sockets fits conceptually with the Node
    architecture—clients and servers are simply piping data back and forth through
    consistent interfaces | Requires a custom protocol server, and often a custom
    client library |'
  prefs: []
  type: TYPE_TB
- en: 'Another interesting project is SockJS, which implements socket servers in many
    different languages, including Node.js. Check out: [https://github.com/sockjs/sockjs-node](https://github.com/sockjs/sockjs-node).'
  prefs: []
  type: TYPE_NORMAL
- en: Listening for Server Sent Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSE are uncomplicated and specific. They are to be used when the majority of
    data transfer proceeds unidirectionally from a server to clients. A traditional
    and similar concept is the *push* technology. SSE pass text messages with simple
    formatting. Many types of applications passively receive brief status updates
    or data state changes. SSE are an excellent fit for these types of applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `WebSocket`, SSE also eliminate the redundant chatter of AJAX. Unlike
    `WebSocket`, an SSE connection is only concerned with broadcasting data from servers
    to connected clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e993b38-8ad7-41c4-9e68-b340567b01f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A client connects to a server supporting SSE by passing the `EventSource` constructor
    a path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This instance of `EventSource` will now emit subscribable data events whenever
    new data is received from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Using the EventSource API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The way in which `EventSource` instances emit subscribable data events whenever
    new data is received from the server is like the way `Readable` streams emit data
    events in Node, as we can see in this example client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'An `EventSource` instance emits three default events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`open`: When a connection is successfully opened, this event will fire'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message`: The handler assigned to this event will receive an object whose
    `data` property contains the broadcast message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`: This fires whenever a server error occurs, or the server disconnects
    or otherwise severs its connection with this client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Forming part of the standard HTTP protocol, a server responsive to SSE requests
    requires minimal configuration. The following server will accept `EventSource`
    bindings and broadcast the current date to the bound client every second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This server listens for requests and selects those made on the path `/login`,
    which it interprets as a request for an `EventSource` binding. Establishing an
    `EventSource` connection is simply a matter of responding to the request with
    a `Content-Type` header of `text/event-stream`. Additionally, we indicate that
    the client's `Cache-Control` behavior should be set to `no-cache`, as we expect
    a lot of original material on this channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the point of connection, the `response` object of this client will remain
    an open pipe that messages can be sent through using `write`. Let''s look at the
    next two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This first write is adjusting for an XHR implementation feature in some browsers,
    which ultimately requires all SSE streams to be prefixed by a 2-KB padding. This
    write action need happen only once, and has no relevance to subsequent messages.
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of SSE is that clients will automatically try to reconnect
    with the server, should that connection be severed. The number of milliseconds
    before retrying will vary from client to client, and can be controlled using the
    retry field, which we use here to set a two-millisecond retry interval.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we listen for the client''s close event, which fires when a client
    disconnects, and begins broadcasting the time on a one-second interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'A website might bind to this time server and display the current server time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Because the connection is one way, any number of services can be set up as publishers
    very easily, with clients binding individually to these services via new `EventSource`
    instances. Server monitoring, for example, could be achieved easily by modifying
    the preceding server so that it periodically sends the value of `process.memoryUsage()`.
    As an exercise, use SSE to reimplement the stocks service we covered earlier in
    the section on AJAX.
  prefs: []
  type: TYPE_NORMAL
- en: The EventSource stream protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once a server has established a client connection, it may now send new messages
    across this persistent connection at any time. These messages consist of one or
    more lines of text, demarcated by one or several of the following four fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`event`: This is an event type. Messages sent without this field will trigger
    the client''s general `EventSource` event handler for any message. If set to a
    string such as *latestscore*, the client''s `message` handler will not be called,
    with handling being delegated to a handler bound using `EventSource.addEventListener(''latestscore''…)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data`: This is the message being sent. This is always of the `String` type,
    though it can usefully transport objects passed through `JSON.stringify()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id`: If set, this value will appear as the `lastEventID` property of the sent
    message object. This can be useful for ordering, sorting, and other operations
    on the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retry`: The reconnection interval, in milliseconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sending messages involves composing strings containing relevant field names
    and ending with newlines. These are all valid messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We can see that multiple `data` fields can be set as well. An important thing
    to note is the double newline (`"\n\n"`) to be sent after the final data field.
    Previous fields should just use a single newline.
  prefs: []
  type: TYPE_NORMAL
- en: The default `EventSource` client events (`open`, `message`, and `close`) are
    sufficient for modeling most application interfaces. All broadcasts from the server
    are caught within the solitary `message` handler, which takes responsibility for
    routing the message or otherwise updating the client, in the same way that event
    delegation would work when working with events in the DOM using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: This system may not be ideal in cases where many unique message identifiers
    are needed, overwhelming a single handling function. We can use the `event` field
    of SSE messages to create custom event names that can be individually bound by
    a client, neatly separating concerns.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if two special events `actionA` and `actionB` are being broadcast,
    our server would structure them like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Our client would bind to them in the normal way, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In cases where a single message handling function is becoming too long or too
    complex, consider uniquely named messages and handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Asking questions and getting answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What if we wanted to create an interface to interests? Let''s build an application
    enabling any number of people to ask and/or answer questions. Our users will join
    the community server, see a list of open questions and answers to those questions,
    and get real-time updates whenever a new question or answer is added. There are
    two key activities to model:'
  prefs: []
  type: TYPE_NORMAL
- en: Each client must be notified whenever another client asks a question or posts
    an answer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A client can ask questions or supply answers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/1d168c9c-c488-4c1d-b08b-5f7910f26b61.png)'
  prefs: []
  type: TYPE_IMG
- en: Where would the greatest amount of change happen in a large group of simultaneous
    contributors to this community?
  prefs: []
  type: TYPE_NORMAL
- en: Any individual client can potentially ask a few questions or provide a few answers.
    Clients will also select questions and have the answers displayed to them. We
    will need to satisfy merely a handful of client-to-server requests, such as when
    sending a new question or answer to the server. Most of the work will be in satisfying
    client requests with data (a list of answers to a question) and broadcasting application
    state changes to all connected clients (new question added; new answer given).
    The one-to-many relationship existing for clients within such collaborative applications
    implies that a single client broadcast may create a number of server broadcasts
    equal to the number of connected clients—1 to 10,000 or more. SSE are a great
    fit here, so let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three main operations for this application are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Asking a question
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answering a question
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting a question
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Either of these actions will change the application state. As this state must
    be reflected across all clients, we will store the state of our application on
    our server—all questions, answers, and the relationships of clients to these data
    objects. We will also need to uniquely identify each client. Normally, one would
    use a database to persist some of this information, but for our purposes, we will
    simply store this data in our Node server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the `questions` and `answers` storage objects, we will also need
    to store client objects themselves—clients are assigned a unique ID that can be
    used to look up information (such as the client's socket) when broadcasts are
    made.
  prefs: []
  type: TYPE_NORMAL
- en: We only want to broadcast answer data to clients that have expressed an interest
    in the specific question—as client UIs are only displaying answers for a single
    question, we, of course, would not broadcast answers to clients indiscriminately.
    For this reason, we keep a `clientQMap` object, which maps a question to all clients
    listening to that question, by the ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `removeClient` method is straightforward: when a client disconnects, the
    method removes its data from the pool. We''ll see this again later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this setup in place, we next need to build our server to respond the `/login`
    path, which is used by `EventSource` to grab a connection. This service is responsible
    for configuring a proper event-stream for clients, storing this `Response` object
    for later use, and assigning the user a unique identifier, which will be used
    on future client requests to identify the client and fetch that client''s communication
    socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'After establishing request parameters, our servers check the request for a
    `_sse_user_id_` header, which is the unique string that is assigned to a user
    within `/login` on the initial `EventSource` bind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This ID is then sent to the client via an immediate broadcast, an opportunity
    we use to send along the current batch of questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The client is now responsible for passing along this ID whenever it makes a
    call. By listening for the `/login` event and storing the ID that is passed, a
    client can self-identify when making HTTP calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that we have just created a unidirectional event-stream from our server
    to our client. This channel is used to communicate with clients—not `response.end()`
    or similar. The broadcast method, referenced in `/login`, accomplishes this task
    of broadcasting stream events, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Scan this code from the bottom up. Note how the primary purpose of broadcast
    is to take a client ID, look up that client's event stream, and write to it, accepting
    a custom event name if needed. However, as we will regularly broadcast to all
    connected clients, we allow for a special `*` flag to indicate mass broadcast.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything is now set up, requiring only the definition of services for the
    three main operations for this application: adding new questions and answers,
    and remembering the question each client is following.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When questions are asked, we ensure that the question is unique, add it to
    our `question` collection, and tell everyone the new question list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Handling answers is nearly identical, except that here we want to broadcast
    new answers only to clients asking the right questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we store changes to the client''s interests by updating `clientQMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: While we won't go too deeply into the client-side HTML and JavaScript necessary
    to render this interface, we will look at how some of the core events would be
    handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming a UI rendered in HTML, which lists answers on one side and questions
    on the other, containing forms for adding new questions and answers, as well as
    for selecting questions to follow, our client code is very lightweight and easy
    to follow. After negotiating the initial `/login` handshake with our server, this
    client need simply send new data via HTTP when submitted. The handling of server
    responses is neatly encapsulated into three events, making for easy-to-follow
    event stream handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This interface needs only to wait for new question and answer data, and display
    it in lists. Three callbacks are enough to keep this client up to date, regardless
    of how many different clients update the application's state.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pros** | **Cons** |'
  prefs: []
  type: TYPE_TB
- en: '| Lightweight: By using the native HTTP protocol, an SSE server can be created
    with a couple of simple headers | Inconsistent browser support requires a custom
    library for client-to-server communication, where unsupported browsers will normally
    long poll |'
  prefs: []
  type: TYPE_TB
- en: '| Able to send data to a client unilaterally, without requiring matching client
    calls | One way only: Does not bring its advantages to cases where bidirectional
    communication is needed |'
  prefs: []
  type: TYPE_TB
- en: '| Automatic reconnection of dropped connections, making SSE a reliable network
    binding | Server must send a "heartbeat" every 10 seconds or so in order to keep
    the connection alive |'
  prefs: []
  type: TYPE_TB
- en: '| Simple, easily customizable, and an easy-to-understand messaging format |  |'
  prefs: []
  type: TYPE_TB
- en: '`EventSource` is not supported by all browsers (in particular, IE). An excellent
    emulation library for SSE can be found at: [https://github.com/Yaffle/EventSource](https://github.com/Yaffle/EventSource).'
  prefs: []
  type: TYPE_NORMAL
- en: Building a collaborative document editing application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've examined various techniques to consider when building a collaborative
    application, let's put together a collaborative code editor using **Operational
    transformation** (**OT**).
  prefs: []
  type: TYPE_NORMAL
- en: 'For our discussion here, OT will be understood as a technology that allows
    many people to edit the same document concurrently—collaborative document editing.
    Google described their (now defunct) Wave project in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: As [https://svn.apache.org/repos/asf/incubator/wave/whitepapers/operational-transform/operational-transform.html](https://svn.apache.org/repos/asf/incubator/wave/whitepapers/operational-transform/operational-transform.html) says, "Collaborative
    document editing means multiple editors are able to edit a shared document at
    the same time. It is live and concurrent when a user can see the changes another
    person is making, keystroke by keystroke. Google Wave offers live concurrent editing
    of rich text documents.".
  prefs: []
  type: TYPE_NORMAL
- en: One of the engineers involved in the Wave project was Joseph Gentle, and Mr.
    Gentle was kind enough to write a module bringing OT technology to the Node community,
    named **ShareJS**, which later became **ShareDB**, the OT backend for the Derby
    web framework ([http://derbyjs.com/](http://derbyjs.com/)). We are going to use
    this module to create an application that allows anyone to create a new collaboratively
    editable document.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example liberally borrows from the many examples contained in the ShareDB
    GitHub repository. To delve deeper into the possibilities of ShareDB, visit: [https://github.com/share/sharedb](https://github.com/share/sharedb).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, we will need a code editor to bind our OT layer to. For this
    project, we will use the excellent Quill editor, which can be cloned from: [https://github.com/quilljs/quill](https://github.com/quilljs/quill).
    Quill is especially suited to working with ShareDB, as it is designed to represent
    documents as a sequence of changesets represented in JSON ([https://github.com/ottypes/rich-text](https://github.com/ottypes/rich-text)),
    which can be mapped to the OT types that ShareDB understands. While out of scope
    for this section, it might benefit the reader to dig into how OT works, especially
    with these two libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: Being a collaborative, real-time application, we will use the **ws** socket
    server to manage communication between clients and the database, and **Express**
    to manage serving static files, such as `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your code bundle for this chapter, there will be a sharedb folder. To install
    and try it out, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The two main files there will be `client.js` and `server.js`. The `client.js` file
    will be bundled using **Browserify**, generating the JavaScript the client will
    use. Let''s look at the `client.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The header of this file simply instantiates ShareDB, setting its document type
    to `rich-text`, and providing the instance with a communication socket to the
    server. For the purposes of this demonstration, we're going to operate on a single
    collection `examples` and the one file `richtext`. This collection/document pairing
    is how you work with documents in ShareDB, and is reflected in the `server.js`
    file we'll be looking at shortly. In a more advanced implementation, you will
    likely need to create some sort of collection/document management layer, linking
    those collections to certain users, adding user accounts, permissions, and so
    forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve established a subscription to the server, we bind a new Quill instance
    to the `#editor` element, set its contents (`quill.setContents`) to whatever the
    server returns as the current document, declaring that we''d like to use the `snow` theme,
    whose css we''ve included in `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'All that is left to do is create the Node server exposing the functionality
    of OT to the client. To do this, we will need to accept OT changes (deltas) from
    the server and apply those changes to the Quill editor, and report changes to
    the server as a user uses the Quill editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We're now set up to update the document database whenever there is a `text-change`
    in the Quill editor, and to `updateContents` of any connected client editor whenever
    there is a new `op` on the shared document.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server implementation largely reflects the client implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We require all of the libraries, making a note of the websocket-json-stream
    requirement, a library that creates a JSON object stream across the socket, needed
    to represent the JSON changesets we will be working with.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then establish the collection/document setup our client expects, creating
    the document with some dummy text, "Say something!" if the document does not exist.
    The only thing left to do is to bind the ShareDB backend to this bidirectional
    JSON Object stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This server can now be used to share document state across all clients requesting
    identically named documents, facilitating collaborative editing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ve gone over three of the major strategies employed when
    building real-time applications: AJAX, WebSocket, and SSE. We''ve shown that non-trivial
    collaborative applications can be developed with very little code using Node.
    We''ve also seen how some of these strategies enable the modeling of client/server
    communication as an evented data stream interface. We''ve considered the pros
    and cons of these various techniques, and we''ve gone through some clear examples
    of the best places to use each one.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we've shown how client identifiers and state data can be built
    and managed within a Node server, so that state changes can be safely encapsulated
    in a central location and broadcast out to many connected clients safely and predictably.
    Demonstrating the quality of the modules being developed with the Node community,
    we created a collaborative code editing system through the use of operational
    transformation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at how to coordinate the efforts of
    multiple Node processes running simultaneously. Through examples, we will learn
    how to achieve parallel processing with Node, from spawning many child processes
    running Unix programs to creating clusters of load-balancing Node socket servers.
  prefs: []
  type: TYPE_NORMAL
