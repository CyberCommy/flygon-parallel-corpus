- en: Chapter 9. Getting Started with Ext JS 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ext JS 4** is, by far, the most sophisticated JavaScript library available
    and provides an amazing set of widgets for almost all practical design concerns.
    It does everything we could possibly want in order to develop complex, cross-browser
    compatible applications that require a high degree of user interaction. In this
    chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about core Ext JS 4 MVC concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore practical project design and development conventions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the Ext JS 4 development framework and introduce Sencha Cmd
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate an Ext JS 4 application skeleton for the 3T application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ext JS has come a long way since starting out as an extension to the **Yahoo
    User Interface** (**YUI**) library. Each new version has been a significant improvement
    on the previous one and Ext JS 4 is no exception. Those new to Ext JS will appreciate
    the elegant framework design and consistent API, while those transitioning from
    Ext JS 3 will appreciate the improvements in many areas, including the introduction
    of the MVC design pattern. Regardless of your background, this chapter will help
    you be productive with Ext JS 4.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that Ext JS 4 is not the only JavaScript MVC framework available
    today. `Angular.js` and `Backbone.js`, for example, are both very capable development
    frameworks, with MVC features similar to Ext JS 4\. They do not, however, have
    the extensive documentation, build tools, and commercial support that make Ext
    JS 4 so appropriate for enterprise application development.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of application design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Technology aside, a thoughtful and consistent application design is critical
    when developing enterprise applications. The quality of the application''s architecture
    will determine the maintainability, scalability, and overall cost of the application
    during the project lifecycle. The benefits of a well-designed application include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The application will be easier to understand. New team members will quickly
    come up to speed if there is a consistent way of doing things.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application will be easier to maintain. Enhancements and new functionalities
    will be far simpler to implement if you have consistent application design guidelines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code consistency. A well-designed application will have well-documented naming
    conventions, directory structures, and coding standards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application will be multideveloper friendly. On large projects, many people
    will be involved and a consistent design strategy will ensure that everyone is
    on the same page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less-tangible benefits are often overlooked when you start a new project and
    excitedly work on the first prototype for the proof-of-concept presentation. The
    ability to refactor and scale a project from simple beginnings is often a key
    factor in enterprise application development. Regardless of how small the project
    may seem in the initial phases, you can be certain that business users will want
    to change workflows and layouts as soon as they become familiar with the application.
    New functionality will be requested and old functionality will be deprecated.
    Components will be moved and redesigned as the application evolves over time.
    A consistent and well-thought-out application design will make these project lifecycle
    processes less daunting. Thankfully, the Ext JS 4 application architecture itself
    encourages a formal and well-structured application design.
  prefs: []
  type: TYPE_NORMAL
- en: Ext JS 4 MVC concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the MVC design pattern was introduced for the first time in Ext JS 4,
    it completely revolutionized the Ext JS framework. Although MVC was well known
    as a design pattern, this was the first time a sophisticated JavaScript framework
    had implemented the strategy. There are several key benefits as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The MVC design pattern organizes code into logical realms or component types,
    which makes the code easier to understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MVC modularity can simplify component testing and refactoring as each object
    has a well-defined purpose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MVC design pattern architecture encourages cleaner code, clearly separating
    data access, presentation, and business logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These were a huge advantage over the previous Ext JS 3 where the only true MVC
    component was the **V** (**View**). It was left to the Ext JS 3 developer to architect
    the **M** (**Model**) and **C** (**Controller**) as best they could, which often
    led to confusing and inconsistent code. Let's now look at how Ext JS 4 defines
    the MVC design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Ext JS 4 model is a collection of properties that represent a domain entity.
    It may not come as a surprise that our 3T application will require a `Company`,
    `Project`, `Task`, `User`, and `TaskLog` model definition, just like they are
    represented in our Java domain layer. The main difference with our Java domain
    objects is that the Ext JS 4 model equivalent will be persistence aware. Thanks
    to the Ext JS 4 `data` package, each model instance will know how to persist and
    manage its state.
  prefs: []
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Ext JS 4 view represents a logical visual component block and may itself
    include panels, toolbars, grids, forms, trees, and charts. An Ext JS 4 view always
    resides in its own file and should be as *dumb* as possible. This means that there
    should be no JavaScript business logic in the view; its purpose is to present
    data and provide interactive ability for the user.
  prefs: []
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Ext JS 4 controller can be loosely described as the glue that binds together
    your application logic. Controllers are central in handling event processing and
    cross-view interactions and define the application workflows. The vast majority
    of JavaScript business logic code will reside in controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Ext JS 4 flexibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although we have a clear definition of the different MVC components, there is
    considerable implementation flexibility in the Ext JS 4 framework itself. We do
    not need to use controllers or models; in fact, we could easily build a fully
    working Ext JS 4 application using the same strategies followed in Ext JS 3\.
    This would be a mistake, however, and should be avoided at all costs. The benefits
    of leveraging the MVC architecture for enterprise application development are
    significant, including, but not limited to, a simpler and more robust code base.
  prefs: []
  type: TYPE_NORMAL
- en: Ext JS 4 design conventions and concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Sencha Ext JS 4 team has done an enormous amount of work in defining conventions,
    which you should consider following, for building enterprise applications. These
    include a standard directory structure, naming conventions, and detailed design
    best practices. We strongly urge you to browse the many tutorials and guides on
    the *Sencha Ext JS 4 Docs* website at [http://docs.sencha.com/extjs/4.2.2](http://docs.sencha.com/extjs/4.2.2)
    to become familiar with their application design recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: This book will adhere to the common design strategies outlined by the Ext JS
    4 team, with minor differences noted and explained upon being introduced in their
    relevant sections. It is beyond the scope of the book to cover basic Ext JS 4
    concepts and you may need to refer to the *Sencha Ext JS 4 Docs* to fine-tune
    your understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Practical conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A well-structured Ext JS 4 project with consistent naming conventions will be
    a joy to work with. Enterprise applications with hundreds of files should be structured
    in a way that is easy to learn and maintain. It should be a rare occurrence when
    you ask a colleague, "Where is the file that displays the editing toolbar for
    the xyz widget?".
  prefs: []
  type: TYPE_NORMAL
- en: Project structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Ext JS 4 directory structure, comprising a top-level app and subdirectories
    named `controller`, `model`, `store`, and `view`, should always be used. This
    is the default directory structure for any Ext JS 4 application and allows out-of-the-box
    integration with the Sencha Cmd build tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Large projects have many hundreds of JavaScript files, so it is important to
    have a consistent project structure. Practical namespacing, especially in the
    `view` directory, can simplify a project structure and make it easier to find
    components. In [Chapter 10](ch10.html "Chapter 10. Logging On and Maintaining
    Users"), *Logging On and Maintaining Users*, [Chapter 11](ch11.html "Chapter 11. Building
    the Task Log User Interface"), *Building the Task Log User Interface*, and [Chapter
    12](ch12.html "Chapter 12. 3T Administration Made Easy"), *3T Administration Made
    Easy*, for example, we will be creating a `view` structure containing the files
    displayed in the following screenshot (on the left-hand side):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project structure](img/5457_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot displays all views (on its right-hand side) in the
    same directory. Which is the better way? That depends on the nature of the project
    and the number of files. Enterprise projects are usually namespaced at a modular
    level with many subdirectories logically grouping related components. Smaller
    projects can just as easily have a flat structure where all files are found in
    the same directory. Whichever structure you choose, be consistent! It should be
    easy for any new developer to find a component without searching through a large
    number of files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We recommend defining a consistent naming convention that is easy to understand
    and follow. It should be easy to locate files, both on the filesystem and in the
    IDE you are using.
  prefs: []
  type: TYPE_NORMAL
- en: Naming stores and models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each model should be named as the singular of the entity it represents (for
    example, `Company`, `Project`, `Task`, `TaskLog`, and `User`). Each store should
    be named in a similar singular manner. We have seen `Store` added as a postfix
    to store names in Ext JS 3 (for example, `ProjectStore`), but this is not recommended
    for Ext JS 4\. Controllers automatically create a `get` function for each store
    by adding `Store` to the store name. Naming a store `ProjectStore` will result
    in a function named `getProjectStoreStore` in each controller that the store is
    referenced. For this reason, we recommend that you use store names without the
    `Store` postfix.
  prefs: []
  type: TYPE_NORMAL
- en: The store name in its singular form is often replaced with the plural version.
    For example, a Project store is often named `Projects`. Once again, consistency
    is the key. If you decide to use the plural form, use it for each store name.
    In our application, this would result in `Companies`, `Projects`, `Tasks`, `TaskLogs`,
    and `Users` stores. This tends to sometimes cause confusion in spelling; we have
    seen both Companies and Companys used for the plural version of Company. When
    English is not your first language, it may be difficult to know the correct plural
    name for entities, such as territories, countries, companies, currencies, and
    statuses. For this reason, we prefer using the singular version when naming stores.
  prefs: []
  type: TYPE_NORMAL
- en: Naming views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following situation, in which we have been researching panels
    on the Sencha Docs website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Naming views](img/5457_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are four different **Panel** files open (`Ext.grid.Panel`, `Ext.tab.Panel`,
    `Ext.form.Panel`, and `Ext.panel.Panel`). It is frustrating to try and locate
    the `Ext.grid.Panel` file in this situation; in the worst case, you will need
    to click on four different tab items. In a large project, there may be many panel
    containers worthy of the name `Panel`. We recommend giving each file a unique
    name, regardless of how it is namespaced. Unlike models and stores, where the
    same filename is used for the model and store namespaces, we do not recommend
    using the same filename between view classes. For example, the files `app.view.user.List`
    and `app.view.tasklog.List` cannot be easily differentiated in an IDE tab bar
    without examining the file content. It is far easier to make these filenames unique,
    even though they may exist in different namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: The use of postfixing class types is another issue worthy of discussion. Ext
    JS 3 used typed postfixing on class names. This resulted in `GridPanel`, `FormPanel`,
    `TabPanel`, and `Panel` filenames. They were all panels. It was easy to identify
    what the class was by examining the filename. Ext JS 4 took a namespaced approach
    and dropped the descriptive name. The preceding examples became `Ext.grid.Panel`,
    `Ext.tab.Panel`, `Ext.form.Panel`, and `Ext.panel.Panel`. Each file is named `Panel`,
    which is not very helpful without knowledge of the directory it resides in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whatever naming convention you implement, it is important to be consistent.
    We will use the following naming conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: All namespacing folder names will be lowercase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any class that is used to represent a list of items will have the class name
    postfixed with `List`. The implementation of `List` is not important; we do not
    care if the listing is created using a grid, simple template, or data view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any class that is a form will be postfixed with `Form`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any class that is a tree will be postfixed with `Tree`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any class that is a window will be postfixed with `Window`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any component that manages the positioning and layout of a set of related components
    will be prefixed with `Manage`. Such a class will usually contain toolbars, lists,
    forms, and tab panels arranged in an appropriate layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may wish to introduce other conventions appropriate for your development
    environment. This is fine; the important point is to be consistent and ensure
    that everyone understands and adheres to your conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Naming controllers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We recommend that all controller class names be postfixed with `Controller`.
    This makes them easy to identify in any IDE. The controller responsible for user
    maintenance, for example, would hence be named `UserController`.
  prefs: []
  type: TYPE_NORMAL
- en: Naming xtypes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We recommend using the lowercase class name as `xtype` for each class. This
    is another very good reason to ensure that the filename for each view class is
    unique. The `UserList` `xtype` is `userlist`, the `UserForm` xtype is `userform`,
    and the `ManageUsers` xtype is `manageusers`. There can be no confusion.
  prefs: []
  type: TYPE_NORMAL
- en: The Ext JS 4 development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two core components required for Ext JS 4 development as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Sencha Cmd Tool**: This is a cross-platform, Java-based, command-line
    tool that provides many options to help manage the lifecycle of your applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ext JS 4 SDK (Software Development Kit)**: This contains all source files,
    examples, resources, and minified scripts required for application development'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now examine and install each of these components.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Sencha Cmd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Sencha Cmd Tool can be downloaded from [http://www.sencha.com/products/sencha-cmd/download](http://www.sencha.com/products/sencha-cmd/download).
    The file is approximately 46 MB and needs to be unzipped before running the setup
    process.
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing Sencha Cmd](img/5457_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on **Next** to view the **License Agreement** section. You will need
    to accept the agreement before clicking on the **Next** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing Sencha Cmd](img/5457_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The screen shown in the following screenshot prompts for an **Installation
    Directory**. We recommend that you install the Sencha Cmd Tool on a directory
    that is easily accessible (`/Users/Shared/` for Mac users and `C:\` for Windows
    users):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing Sencha Cmd](img/5457_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on **Next** to continue. This will show a prompt indicating that setup
    is now ready to begin installing Sencha Cmd on your computer. Click on **Next**
    again to continue the installation. The final prompt will confirm the installation
    of Sencha Cmd:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing Sencha Cmd](img/5457_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can now view the installed files as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing Sencha Cmd](img/5457_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To confirm the installation, open a command prompt (Windows) or terminal (Mac),
    type `sencha`, and press the *Enter* key. This will confirm that Sencha Cmd has
    been added to your system path and should result in output similar to that shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing Sencha Cmd](img/5457_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that any currently open console/terminal windows will need to be closed
    and reopened to ensure that the installation path changes are reloaded. The final
    step is to check whether or not there are any upgrades available by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This command should display an appropriate message as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing Sencha Cmd](img/5457_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is possible to upgrade versions of Sencha Cmd by omitting the `––check`
    argument. For a full list of Sencha command-line options, refer to [http://docs.sencha.com/extjs/4.2.2/#!/guide/command](http://docs.sencha.com/extjs/4.2.2/#!/guide/command).
    This page also contains many helpful troubleshooting tips and explanations. In
    addition, you may also use the command-line help by executing `sencha help`. Executing
    the `sencha help` command will display detailed help options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing Sencha Cmd](img/5457_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Installing Ext JS 4 SDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The SDK can be downloaded from [http://www.sencha.com/products/extjs](http://www.sencha.com/products/extjs).
    The previous step will have created a Sencha directory in the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: '`C:\Sencha` for Windows users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/Users/Shared/Sencha` for Mac users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After downloading the SDK, you should create an `ext-xxx` directory within
    this Sencha directory where `xxx` represents the version of the Ext JS 4 framework.
    You can then unzip the SDK into this directory resulting in the structure shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing Ext JS 4 SDK](img/5457_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You are now ready to initialize the Ext JS 4 3T application skeleton.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the 3T Ext JS 4 application skeleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The format of the skeleton generation command is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Running this command will copy all required SDK files to the `/path/to/MyApp`
    directory and create a skeleton of the resources ready for development. You must
    use full paths for both the `SDK` and `MyApp` directories.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that the 3T application is a Maven project and that
    the web content root is the `webapp` directory located within the Maven directory
    structure. The project folder that was created in [Chapter 1](ch01.html "Chapter 1. Preparing
    Your Development Environment"), *Preparing Your Development Environment*, and
    the `webapp` directory (on Windows) can be found at `C:\projects\task-time-tracker\src\main\webapp`.
  prefs: []
  type: TYPE_NORMAL
- en: On Mac, it can be found at `/Users/{username}/projects/task-time-tracker/src/main/webapp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 3T application skeleton can now be generated by executing the following
    command (for Windows platforms):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that this command must be on a single line. The `TTT` argument represents
    the application name and will be used to generate the application namespace. We
    could have used `TaskTimeTracker`, but the abbreviated form is easier to write!
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the command from the terminal should produce considerable output,
    ending with some red errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating the 3T Ext JS 4 application skeleton](img/5457_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Don't be too concerned with the **[ERR]** warnings; Sencha Cmd has identified
    the presence of the `index.html` file and replaced it with the Sencha Cmd version.
    The original file was copied to `index.html.$old`. We don't need the backup file
    (it was created during the NetBeans project creation process); it can safely be
    deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Opening the NetBeans IDE will now display many new files and directories within
    the `webapp` directory of the 3T project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating the 3T Ext JS 4 application skeleton](img/5457_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can now run the project to view the output in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating the 3T Ext JS 4 application skeleton](img/5457_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This output is the default Ext JS 4 application content in the `index.html`
    page, created by the `generate app` command when building the project skeleton.
    Let's now look at the key files that have been generated.
  prefs: []
  type: TYPE_NORMAL
- en: The index.html file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `index.html` file consists of the following listings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note the `x-compile` and `x-bootstrap` tags within the page content. These are
    used by the Sencha Cmd Tool and allow the compiler to identify the scripts at
    the root of your application (the default file is always `app.js`). The compiler
    also ignores the bootstrap part of the framework that is used only during development.
    When generating a production application, all of the required files are pulled
    in during the build process. This will be covered in detail in [Chapter 13](ch13.html
    "Chapter 13. Moving Your Application to Production"), *Moving Your Application
    to Production*.
  prefs: []
  type: TYPE_NORMAL
- en: You should note that the `ext-dev.js` file is the only Ext JS 4 framework resource
    required. This file is used for dynamic JavaScript class loading during the development
    phase. The framework will then dynamically retrieve any JavaScript resources required
    by the application.
  prefs: []
  type: TYPE_NORMAL
- en: The app.js and Application.js files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `app.js` file is the entry point of the application. The contents of the
    file, including generated comments, looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Ext.application` extends the `TTT.Application` class, which is defined
    in the `app/Application.js` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is the `Application.js` file that will contain our 3T application-specific
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should note that this is a different setup to that described in earlier
    Ext JS 4 tutorials where the `app.js` file contains application-specific properties
    (views, controllers, stores, and application functions). The approach outlined
    previously keeps all application-specific code within the `app` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first change to the autogenerated `Application.js` file is to add the `launch`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now remove `autoCreateViewport:true` from the `app.js` file as the logic
    for creating the viewport is now in the `launch` function. The `launch` function
    itself will be enhanced in the next chapter to implement the user logon, so there
    is plenty of code to come! The updated `app.js` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The bootstrap.js and bootstrap.css files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `bootstrap.js` and `bootstrap.css` files were generated by Sencha Cmd and
    should not be edited. They are used internally to initialize and configure the
    development environment.
  prefs: []
  type: TYPE_NORMAL
- en: The app/Viewport.js and app/view/Main.js files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An Ext JS 4 viewport is a container that resizes itself to use the entire browser
    window. The `Viewport.js` definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There is only one view added to the `items` array; the `TTT.view.Main`, function,
    which has an `xtype` function called `app-main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding file defines the border layout and textual content of the two
    regions that are displayed in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not confident with Ext JS views, xtypes, viewports, border layouts, or panels?
    We recommend browsing and reviewing the basic Ext JS 4 component concepts at [http://docs.sencha.com/extjs/4.2.2/#!/guide/components](http://docs.sencha.com/extjs/4.2.2/#!/guide/components).
  prefs: []
  type: TYPE_NORMAL
- en: The app/controller/Main.js file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final generated file we will examine is the `Main.js` controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There is no functionality in this class as there is nothing yet to control.
  prefs: []
  type: TYPE_NORMAL
- en: Creating components using Sencha Cmd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to use Sencha Cmd to generate skeleton components. The most useful
    of these commands are those used to generate basic models.
  prefs: []
  type: TYPE_NORMAL
- en: Generating model skeletons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A model skeleton can be generated very easily using the Sencha Cmd Tool. The
    syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This command must be executed in the application root (the directory in which
    the `app.js` file is found). Note that there must not be any spaces in the comma-separated
    field listing. The company model skeleton can be generated by executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The final `string` for the `companyName` field is not strictly required as
    the default property type is `string`, if not specified. The output from this
    command looks as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating model skeletons](img/5457_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The generated `Company.js` file is written into the `app/model` directory and
    has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very simple model and has two fields as expected. We can also generate
    more complex models using different data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will generate the `TaskLog` model with fields of types
    `int`, `string`, `date`, and `float`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The model skeletons for the three remaining entities can be created by executing
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that each of these models matches the JSON structure generated by the
    `addJson` (`JsonObjectBuilder`) method in the equivalent Java domain classes.
    You should now have the files shown in the following screenshot in the `app/model`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating model skeletons](img/5457_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although we have used the Sencha Cmd Tool to generate these model skeletons,
    it would have been just as easy to create the appropriate files and definitions
    in the NetBeans IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Generating views and controllers using Sencha Cmd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is also possible to generate basic view and controller skeletons, but the
    contents of these files are very limited. The following command will create a
    view named `ManageUsers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ManageUsers.js` file will be written to the `app/view` directory and have
    the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar manner, you could create a controller skeleton for `UserController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UserController.js` file would be written to the `app/controller` directory
    and have the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We believe it is simpler to create views and controllers in the NetBeans IDE
    and will not be using Sencha Cmd for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has configured the Ext JS 4 development environment and introduced
    practical design conventions and concepts. We have installed Sencha Cmd and generated
    the 3T application skeleton, examining the core generated files to understand
    the recommended application structure. Our model entities have been generated
    using Sencha Cmd and are ready for enhancement in the following chapters. The
    scene has been set for building our 3T application frontend.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](ch10.html "Chapter 10. Logging On and Maintaining Users"), *Logging
    On and Maintaining Users*, we will develop the Ext JS 4 components required to
    log on to the 3T application and maintain users. Our creative journey through
    **User Interface** (**UI**) design is just starting!
  prefs: []
  type: TYPE_NORMAL
