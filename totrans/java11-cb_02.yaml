- en: Fast Track to OOP - Classes and Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing **Object-Oriented Design** (**OOD**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using inner classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using inheritance and aggregation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding to an interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating interfaces with default and static methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating interfaces with private methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A better way to work with nulls using `Optional`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the utility class `Objects`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recipes in this chapter do not require any prior knowledge of OOD. However,
    some experience of writing code in Java would be beneficial. The code samples
    in this chapter are fully functional and compatible with Java 11\. For better
    understanding, we recommend that you try to run the presented examples.
  prefs: []
  type: TYPE_NORMAL
- en: We also encourage you to adapt the tips and recommendations in this chapter
    to your needs in the context of your team experience. Consider sharing your newfound
    knowledge with your colleagues and discuss how the described principles can be
    applied to your domain and your current project.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter gives you a quick introduction to the concepts of **o****bject-oriented
    programming** (**OOP**) and covers some enhancements that have been introduced
    since Java 8\. We will also try to cover a few good OOD practices wherever applicable
    and demonstrate them using specific code examples.
  prefs: []
  type: TYPE_NORMAL
- en: One can spend many hours reading articles and practical advice on OOD in books
    and on the internet. Doing this can be beneficial for some people. But, in our
    experience, the fastest way to get hold of OOD is to try its principles early
    in your own code. That is exactly the goal of this chapter—to give you a chance
    to see and use the OOD principles so that the formal definition makes sense immediately.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main criteria of well-written code is the clarity of the intent.
    A well-motivated and clear design helps achieve this. The code is run by a computer,
    but it is maintained—read and modified—by humans. Keeping this in mind will assure
    the longevity of your code and perhaps even a few thanks and mentions with appreciation
    from those who have to deal with it later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to use the five basic OOP concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Object/class**: Keeping data and methods together'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encapsulation**: Hiding data and/or methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inheritance**: Extending another class data and/or methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface**: Hiding the implementation and coding for a type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polymorphism**: Using the base class type reference that points to a child
    class object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you search the internet, you may notice that many other concepts and additions
    to them, as well as all OOD principles, can be derived from the five concepts
    listed previously. This means that a solid understanding of them is a prerequisite
    to a successful design of an object-oriented system.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing object-oriented design (OOD)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn the first two OOP concepts—object/class and encapsulation.
    These concepts are at the foundation of OOD.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term *object* usually refers to an entity that couples data and procedures
    that can be applied to this data. Neither data nor procedures are required, but
    one of them is—and, typically, both are—always present. The data is called object
    fields (or properties), while procedures are called methods. Field values describe
    the object's *state*. Methods describe the object's *behavior*. Every object has
    a type, which is defined by its class—the template used for the object's creation.
    An object is also said to be an instance of a class.
  prefs: []
  type: TYPE_NORMAL
- en: A *class* is a collection of definitions of fields and methods that will be
    present in each of its instances—the objects created based on this class.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation is the hiding of those fields and methods that should not be accessible
    by other objects.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation is achieved by using the `public`, `protected`, or `private` Java
    keywords, called *access modifiers, *in the declaration of the fields and methods.
    There is also a default level of encapsulation when no access modifier is specified.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create an `Engine` class with the `horsePower` field. Add the `setHorsePower(int
    horsePower)` method, which sets this field''s value, and the `getSpeedMph(double
    timeSec, int weightPounds)` method, which calculates the speed of a vehicle based
    on the period of time passed since the vehicle began moving, the vehicle weight,
    and the engine power:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `Vehicle` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the application that will use the preceding classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `engine` object was created by invoking the default constructor
    of the `Engine` class without parameters and with the `new` Java keyword that
    allocates memory for the newly created object on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: The second object, `vehicle`, was created with the explicitly defined constructor
    of the `Vehicle` class with two parameters. The second parameter of the constructor
    is the `engine` object, which carries the `horsePower` value set to `246` using
    the `setHorsePower(int horsePower)` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `engine` object contains the `getSpeedMph(double timeSec, int weightPounds)` method,
    which can be called by any object (because it is `public`), as is done in the `getSpeedMph(double timeSec)` method
    of the `Vehicle` class.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding application produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e877a71-e07d-4cdf-a2ba-4d06cf4abe6a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s worth noticing that the `getSpeedMph(double timeSec)` method of the `Vehicle` class
    relies on the presence of a value assigned to the `engine` field. This way, the
    object of the `Vehicle` class *delegates* the speed calculation to the object
    of the `Engine` class. If the latter is not set (`null` passed in the `Vehicle()`
    constructor, for example), `NullPointerException` will be thrown at the runtime
    and, if not handled by the application, will be caught by JVM and force it to
    exit. To avoid this, we can place a check for the presence of the `engine` field
    value in the `Vehicle()` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can place a check in the `getSpeedMph(double timeSec)` method
    of the `Vehicle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This way, we avoid the ambiguity of `NullPointerException` and tell the user
    exactly what the source of the problem was.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have noticed, the `getSpeedMph(double timeSec, int weightPounds)`
    method can be removed from the `Engine` class and can be fully implemented in
    the `Vehicle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To do this, we would need to add the `getHorsePower()` public method to the `Engine`
    class in order to make it available for usage by the `getSpeedMph(double timeSec)`
    method in the `Vehicle` class. For now, we leave the `getSpeedMph(double timeSec,
    int weightPounds)` method in the `Engine` class.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the design decisions you need to make. If you think that an object
    of the `Engine` class is going to be passed around and used by the objects of
    different classes (not only `Vehicle`), you would need to keep the `getSpeedMph(double timeSec,
    int weightPounds)` method in the `Engine` class. Otherwise, if you think that
    only the `Vehicle` class is going to be responsible for the speed calculation
    (which makes sense, since it is the speed of a vehicle, not of an engine), you
    should implement this method inside the `Vehicle` class.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java provides a capability to extend a class and allows the subclass to access
    all non-private fields and methods of the base class. For example, you can decide
    that every object that could be asked about its speed belongs to a subclass that
    is derived from the `Vehicle` class. In such a case, the `Car` class may look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can change our test code by replacing the `Vehicle` class object with
    the object of the `Car` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When the preceding code is executed, it produces the same value as with an
    object of the `Vehicle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2366a79d-188e-42bb-87d8-accfac3a3c97.png)'
  prefs: []
  type: TYPE_IMG
- en: Because of polymorphism, a reference to the object of the `Car` class can be
    assigned to the reference of its base class, `Vehicle`. The `Car` class object
    has two types—its own type, `Car`, and the type of the base class, `Vehicle`.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, a class can also implement multiple interfaces, and the object of such
    a class would have a type of each of the implemented interfaces, too. We will
    talk about this in the subsequent recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Using inner classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn about three types of inner classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner class**: This is a class defined inside another (enclosing) class.
    Its accessibility from outside the enclosing class is regulated by the `public`,
    `protected`, and `private` access modifiers. An inner class can access the private
    members of the enclosing class, and the enclosing class can access the private
    members of its inner class, but a private inner class or private members of a
    non-private inner class cannot be accessed from outside the enclosing class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method-local inner class**: This is a class defined inside a method. Its
    accessibility is restricted to within the method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Anonymous inner class**: This is a class without a declared name that''s
    defined during object instantiation based on the interface only or the extended
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a class is used by one, and only one, other class, the designer might decide
    that there is no need to make such a class public. For example, let's assume that
    the `Engine` class is only used by the `Vehicle` class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the `Engine` class as an inner class of the `Vehicle` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `getSpeedMph(double timeSec)` method of the `Vehicle` class
    can access the `Engine` class, even though it is declared `private`. It can even
    access the `getSpeedMph(double timeSec)` private method of the `Engine` class.
    And the inner class can access all private elements of the enclosing class, too.
    That is why the `getSpeedMph(double timeSec)` method of the `Engine` class can
    access the private `getWeightPounds()` method of the enclosing `Vehicle` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look closer at the usage of the inner `Engine` class. Only the `getSpeedMph(double timeSec)` method
    of the `Engine` class is used. If the designer believes that it is going to be
    the case in the future too, they could reasonably decide to make the `Engine` class
    a method-local inner class, which is the second type of an inner class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, it does not make sense to have an `Engine` class
    at all. The speed-calculation formula can be just used directly, without the mediation
    of the `Engine` class. But there are cases when this might be not so easy to do.
    For example, the method-local inner class may need to extend some other class
    in order to inherit its functionality, or the created `Engine` object may need
    to go through some transformation, so creation is required. Other considerations
    may require a method-local inner class.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, it is a good practice to make all the functionality that is not
    required to be accessed from outside the enclosing class inaccessible. Encapsulation—hiding
    the state and behavior of objects—helps avoid unexpected side effects resulting
    from an accidental change or overriding object behavior. It makes the results
    more predictable. That's why a good design exposes only the functionality that
    must be accessed from the outside. And it is usually the enclosing class functionality
    that motivated the class creation in the first place, not the inner class or other
    implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whether the `Engine` class is implemented as an inner class or a method-local
    inner class, the test code looks the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding program, we get the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23149b17-7ecf-404f-ae5b-77abdb9deb27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s assume that we need to test a different implementation of the `getSpeedMph()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If this speed-calculation formula does not make sense to you, you are correct,
    it does not. We did it to make the result predictable and different from the result
    of the previous implementation.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to introduce this new implementation. We can change the code
    of the `getSpeedMph(double timeSec)` method in the `Engine` class, for example.
    Or, we can change the implementation of the same method in the `Vehicle` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will do this by using the third type of inner class, called the
    anonymous inner class. This approach is especially handy when you want to write
    as little new code as possible, or you want to quickly test the new behavior by
    temporarily overriding the old one. The usage of an anonymous class would then
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this program, this would be the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6f8fa7d-3a9c-416c-a8ff-c78167eaf68e.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the anonymous class implementation has overridden the `Vehicle` class
    implementation. The new anonymous class has only one method in it—the `getSpeedMph()` method
    which returns the hardcoded value. But we could override other methods of the `Vehicle` class
    or add new ones too. We just wanted to keep the example simple for demonstration
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'By definition, an anonymous inner class has to be an expression that is part
    of a statement that ends (as any statement) with a semicolon. Such an expression
    is composed of the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The `new` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the implemented interface or extended class followed by parentheses, `()`,
    that represents the default constructor or a constructor of the extended class
    (the latter is our case, with the extended class being `Vehicle`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class body with methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like any inner class, an anonymous inner class can access any member of the
    enclosing class with a caveat—to be used by an inner anonymous class, the fields
    of the enclosing class have to be either declared `final` or become `final` implicitly,
    which means that their values cannot be changed. A good modern IDE will warn you
    about the violation of this constraint if you try to change such a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these features, we can modify our sample code and provide more input
    data for the newly implemented `getSpeedMph(double timeSec)` method without passing
    them as method parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `timeSec`, `engineHorsePower`, and `vehicleWeightPounds` variables
    are accessible by the `getSpeedMph(double timeSec)` method of the inner class
    and cannot be modified. If we run the preceding code, the result will be the same
    as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b0f5b59-fcd0-4847-8141-cb56a9c81995.png)'
  prefs: []
  type: TYPE_IMG
- en: In the case of an interface with only one abstract method (called the functional
    interface), instead of an anonymous inner class, another construct can be used,
    called a *lambda expression*. It provides a shorter notation. We are going to
    discuss the functional interface and lambda expressions in [Chapter 4](69c0640b-9b2e-4515-bda6-8a481206da19.xhtml),
    *Going Functional*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An inner class is a non-static nested class. Java also allows us to create
    a static nested class that can be used when an inner class does not require access
    to non-static fields and methods of the enclosing class. Here is an example (the `static` keyword
    is added to the `Engine` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Because a static class couldn't access a non-static member, we were forced to
    pass the weight value to the `Engine` class during its construction, and we removed
    the `getWeightPounds()` method as it's no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: Using inheritance and aggregation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn more about two important OOP concepts, inheritance
    and polymorphism, which have been mentioned already and used in the examples of
    the previous recipes. Together with aggregation, these concepts make the design
    more extensible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance is the ability of one class to get ownership of the non-private fields
    and methods of another class.
  prefs: []
  type: TYPE_NORMAL
- en: The extended class is called the base class, superclass, or parent class. The
    new extension of the class is called a subclass or child class.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism is the ability to use the base class type for the reference to
    an object of its subclass.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the power of inheritance and polymorphism, let's create classes
    that represent cars and trucks, each with the weight, engine power, and speed
    it can reach (as a function of time) with the maximum load. In addition, a car,
    in this case, will be characterized by the number of passengers, while a truck's
    important feature will be its payload.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Look at the `Vehicle` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The functionality implemented in the `Vehicle` class is not specific to a car
    or to a truck, so it makes sense to use this class as a base class for the `Car`
    and `Truck` classes, so each of them gets this functionality as its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `Car` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `Truck` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Since the `Vehicle` base class has neither an implicit nor explicit constructor
    without parameters (because we have chosen to use an explicit constructor with
    parameters only), we had to call the base class constructor `super()` as the first
    line of the constructor of every subclass of the `Vehicle` class.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write a test program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `vehicle` reference of the `Vehicle` type points to the object
    of the `Car` subclass and later to the object of the `Truck` subclass. This is
    possible thanks to polymorphism, according to which an object has a type of every
    class in its line of inheritance, including all the interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to invoke a method that exists only in the subclass, you have to
    cast such a reference to the subclass type, as was done in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results of the preceding code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d383484b-d020-48a8-b025-444f48b764a4.png)'
  prefs: []
  type: TYPE_IMG
- en: We should not be surprised to see the same speed calculated for both the car
    and the truck because the same weight and engine power are used to calculate the speed
    of each. But, intuitively, we feel that a heavily loaded truck should not be able
    to reach the same speed as a car in the same period of time. To verify this, we
    need to include the total weight of the car (with the passengers and their luggage)
    and that of the truck (with the payload) in the calculations of the speed. One
    way to do this is to override the `getSpeedMph(double timeSec)` method of the `Vehicle` base
    class in each of the subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add the `getSpeedMph(double timeSec)` method to the `Car` class, which
    will override the method with the same signature in the base class. This method
    will use car-specific weight calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have assumed that a passenger with luggage weighs
    `250` pounds total on average.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can add the `getSpeedMph(double timeSec)` method to the `Truck` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of these modifications (if we run the same test class) will be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2063b24d-ad9e-45ad-9fe8-387b077e2c86.png)'
  prefs: []
  type: TYPE_IMG
- en: The results confirm our intuition—a fully loaded car or truck does not reach
    the same speed as an empty one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new methods in the subclasses override `getSpeedMph(double timeSec)` of
    the `Vehicle` base class, although we access it via the base class reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The overridden method is dynamically bound, which means that the context of
    the method invocation is determined by the type of the actual object being referred
    to. Since, in our example, the reference `vehicle` points to an object of the `Car` subclass,
    the `vehicle.getSpeedMph(double timeSec)` construct invokes the method of the
    subclass, not the method of the base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is obvious code redundancy in the two new methods, which we can refactor
    by creating a method in the `Vehicle` base class and then use it in each of the
    subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Since this method is used by subclasses only, it can be `protected` and thus,
    accessible only to the subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can change the `getSpeedMph(double timeSec)` method in the `Car` class,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, there was no need to use the `super` keyword while calling
    the `getSpeedMph(timeSec, weightPounds)` method because a method with such a signature
    exists only in the `Vehicle` base class, and there is no ambiguity about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar changes can be made in the `getSpeedMph(double timeSec)` method of the `Truck` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to modify the test class by adding casting, otherwise there will
    be a runtime error because the `getSpeedMph(double timeSec)` method does not exist
    in the `Vehicle` base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may have expected, the test class produces the same values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3b6ad65-2ded-4313-9556-3f48a4060cb4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To simplify the test code, we can drop casting and write the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The speed values produced by this code remain the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet, there is an even simpler way to achieve the same effect. We can add the `getMaxWeightPounds()`
    method to the base class and each of the subclasses. The `Car` class will now
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s what the new version of the `Truck` class looks like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add the `getMaxWeightPounds()` method to the base class so
    that it can be used for the speed calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Adding an abstract method, `getMaxWeightPounds()`, to the `Vehicle` class makes
    the class abstract. This has a positive side effect—it enforces the implementation
    of the `getMaxWeightPounds()` method in each subclass. Otherwise, a subclass cannot
    be instantiated and has to be declared abstract too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test class remains the same and produces the same results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5729936-bd5b-478f-80f4-4b0f0737bdb9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But, to be honest, we did it just to demonstrate one possible way of using
    an abstract method and class. In fact, an even simpler solution would be to pass
    the maximum weight as a parameter into the constructor of the `Vehicle` base class.
    The resulting classes will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We added the weight of the passengers to the value we pass to the constructor
    of the superclass; this is the only change in this subclass. Here is a similar
    change in the `Truck` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Vehicle` base class remains the same as the original one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The test class does not change and produces the same results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fda2f8c4-58be-44e1-afd1-02c378f1b7a0.png)'
  prefs: []
  type: TYPE_IMG
- en: This last version—passing the maximum weight to the constructor of the base
    class—will now be the starting point for further code demonstrations.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation makes the design more extensible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding example, the speed model was implemented in the `getSpeedMph(double
    timeSec)` method of the `Vehicle` class. If we need to use a different speed model
    (which includes more input parameters and is more tuned to certain driving conditions,
    for example), we would need to change the `Vehicle` class or create a new subclass
    to override the method. In the case where we need to experiment with dozens or
    even hundreds of different models, this approach becomes untenable.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in real life, modeling based on machine learning and other advanced techniques
    become so involved and specialized, that it is quite common that the modeling
    of car acceleration is done by a different team, not the team that assembles the
    vehicle model.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid the proliferation of subclasses and code-merge conflicts between vehicle
    builders and speed-model developers, we can create a more extensible design using
    aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation is an OOD principle for implementing the necessary functionality
    using the behavior of classes that are not part of the inheritance hierarchy.
    That behavior can exist independent of the aggregated functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can encapsulate the speed calculations inside the `SpeedModel` class in
    the `getSpeedMph(double timeSec)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'An object of this class can be created and then set as the value of the `Vehicle` class
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The test class changes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97d4f021-cc4a-4235-bae2-4388a0c31ba8.png)'
  prefs: []
  type: TYPE_IMG
- en: We isolated the speed-calculating functionality in a separate class and can
    now modify or extend it without changing any class of the `Vehicle` inheritance
    hierarchy. This is how the aggregation design principle allows you to change the behavior
    without changing the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we will show you how the OOP concept of interface unlocks
    more power of aggregation and polymorphism, making the design simpler and even
    more expressive.
  prefs: []
  type: TYPE_NORMAL
- en: Coding to an interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn the last of the OOP concepts, called interface,
    and further practice the usage of aggregation and polymorphism as well as inner
    classes and inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An interface defines the signatures of the methods one can expect to see in
    the class that implements the interface. It is the public face of the functionality
    that's accessible to a client and is thus often called an **Application Program
    Interface** (**API**). It supports polymorphism and aggregation, and facilitates
    a more flexible and extensible design.
  prefs: []
  type: TYPE_NORMAL
- en: An interface is implicitly abstract, which means it cannot be instantiated.
    No object can be created based on an interface only, without implementing it.
    It is used to contain abstract methods (without body) only. But since Java 8,
    it is possible to add default and private methods to an interface, which is the
    capability we are going to discuss in the following recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Each interface can extend multiple other interfaces and, similar to class inheritance,
    inherit all default and abstract methods of the extended interfaces. Static members
    cannot be inherited because they belong to a specific interface.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create interfaces that describe the API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Use factories, which are classes that generate objects that implement certain
    interfaces. A factory hides from the client code the details of the implementation,
    so the client deals with an interface only. It is especially helpful when an instance
    creation requires a complex process and/or significant code duplication. In our
    case, it makes sense to have a `FactoryVehicle` class that creates objects of
    classes that implement the `Vehicle`, `Car`, or `Truck` interface. We will also
    create the `FactorySpeedModel` class, which generates objects of a class that
    implements the `SpeedModel` interface. Such an API allows us to write the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe that the code behavior is the same as in the previous examples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/350a455b-060d-47ea-ac7a-b0b904f5f119.png)'
  prefs: []
  type: TYPE_IMG
- en: However, the design is much more extensible.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen one possible implementation of the `SpeedModel` interface.
    Here is another way to do it by aggregating the object of the `SpeedModel` type
    inside the `FactorySpeedModel` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We put comments as pseudocode, and the `...` symbol instead of the actual code,
    for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the factory class may hide many different private classes, each
    containing a specialized model for particular driving conditions. Each model produces
    a different result.
  prefs: []
  type: TYPE_NORMAL
- en: 'An implementation of the `FactoryVehicle` class may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CarImpl` private nested class may look as follows inside the  `FactoryVehicle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the `TruckImpl` class can be a private nested class of the `FactoryImpl` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can place the `VehicleImpl` class as a private inner class of the `FactoryVehicle`
    class too, so the `CarImpl` and `TruckImpl` classes can access it, but not any
    other class outside of `FactoryVehicle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, an interface describes how to invoke object behavior, while
    factories can generate different implementations for different requests without
    changing the code of the client application.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's try to model a crew cab—a truck with multiple passenger seats that combines
    the properties of a car and a truck. Java does not allow multiple inheritances.
    This is another case where an interface comes to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CrewCab` class may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This class implements both interfaces—`Car` and `Truck`—and passes the combined
    weight of the vehicle, payload, and passengers with their luggage to the base
    class constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add the following method to `FactoryVehicle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The double nature of the `CrewCab` object can be demonstrated in the following
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we can cast the object of the `CrewCub` class to each of the
    interfaces it implements. If we run this program, the results will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5b5257c-8012-4426-9d71-ac9820ccbbf1.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating interfaces with default and static methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn about two new features that were first introduced
    in Java 8—the default and static methods in an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A default method in an interface allows us to add a new method signature without
    changing the classes that have implemented this interface before a new method
    signature was added. The method is called *default* because it provides functionality
    in case this method is not implemented by the class. If, however, the class implements
    it, the interface's default implementation is ignored and overridden by the class
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: A static method in an interface can provide functionality in the same way a
    static method in a class can. Similarly to a class static method, which can be
    called without class instantiation, an interface static method can also be called
    using a dot-operator applied to the interface, `SomeInterface.someStaticMethod()`.
  prefs: []
  type: TYPE_NORMAL
- en: A static method of an interface cannot be overridden by the class that implements
    this interface, and it cannot hide any static method of any class, including the
    class that implements this interface.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's add some functionality to the system we have used already
    in our examples. So far, we have created an amazing piece of software that calculates
    the speed of a vehicle. If the system becomes popular (as it should), we would
    like it to be friendlier to the readers who prefer a metric system of units, instead
    of the miles and pounds we have used in our speed calculations. To address such
    a need after our speed-calculating software has become popular, we have decided
    to add more methods to the `Car` and `Truck` interfaces, but we do not want to break
    the existing implementations.
  prefs: []
  type: TYPE_NORMAL
- en: The default interface method was introduced exactly for such a situation. Using
    it, we can release a new version of the `Car` and `Truck` interfaces without the
    need to coordinate the release with the corresponding modification of the existing
    implementations, that is, the `CarImpl`, `TruckImpl`, and `FactoryVehicle` classes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an example, we will change the `Truck` interface. The `Car` interface can
    be modified in a similar fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enhance the `Truck` interface by adding the `getPayloadKg()` method, which
    returns the truck payload in kilograms. You can do this without forcing a change
    in the `TruckImpl` class that implements the `Truck` interface—by adding a new
    default method to the `Truck` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the new `getPayloadKg()` method uses the existing `getPayloadPounds()` method
    as if the latter is implemented inside the interface too, although, in fact, it
    is implemented in a class that implements the `Truck` interface. The magic happens
    during runtime when this method becomes dynamically bound to the instance of the
    class that implements this interface.
  prefs: []
  type: TYPE_NORMAL
- en: We could not make the `getPayloadKg()` method static because it would not be
    able to access the non-static `getPayloadPounds()` method, and we must use the
    `default` keyword because only the default or static method of an interface can
    have a body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the client code that uses the new method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the preceding program and check out the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b8a5a262-530f-4fda-8c70-f6a7031828ef.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the new method works even without changing the class that implemented
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you decide to improve the implementation of the `TruckImpl` class, you
    can do it by adding the corresponding method, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We have implemented the `getPyloadKg()` method as `return -2` in order to make
    it obvious which implementation is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the same demo program. The results will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ec934ae1-b1ca-46e6-bd7c-c4ddd443e171.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, this time, the method implementation in the `TruckImpl` class
    was used. It has overridden the default implementation in the `Truck` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enhance the `Truck` interface with the ability to enter the payload in kilograms
    without changing the implementation of `FactoryVehicle` and the `Truck` interface.
    Also, we do not want to add a setter method. With all of these limitations, our
    only recourse is to add `convertKgToPounds(int kgs)` to the `Truck` interface,
    and it has to be `static` since we are going to use it before the object that
    implements the `Truck` interface is constructed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Those who prefer the metric system of units can now take advantage of the new
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The results will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b6dd7f4-683a-4c17-9fe9-36f269429277.png)'
  prefs: []
  type: TYPE_IMG
- en: The value of 1,502 is close to the original 1,500, while 3,308 is close to 3,312\.
    The difference is caused by the error of an approximation during the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Creating interfaces with private methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn about a new feature that was introduced in Java
    9, the private interface method, which is of two types—static and non-static.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A private interface method must have an implementation (a body with a code). A
    private interface method not used by other methods of the same interface does
    not make sense. The purpose of a private method is to contain functionality that
    is common between two or more methods with a body in the same interface or to
    isolate a section of code in a separate method for better structure and readability.
    A private interface method cannot be overridden—not by a method of any other interface,
    nor by a method in a class that implements the interface.
  prefs: []
  type: TYPE_NORMAL
- en: A non-static private interface method can only be accessed by non-static methods
    of the same interface. A static private interface method can be accessed by non-static
    and static methods of the same interface.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the `getWeightKg(int pounds)` method implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the redundant code by using the private interface method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code demonstrates the new addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of the test do not change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e275e58-b2e0-4b84-bf31-fd7cba0ce165.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the `getWeightKg(int pounds)` method accepting the input parameter, the
    method name can be misleading because it does not capture the weight unit of the
    input parameter. We could try and name it `getWeightKgFromPounds(int pounds)` but
    it does not make the method function clearer. After realizing it, we decided to make
    the `convertPoundsToKg(int pounds)` method public and to remove the `getWeightKg(int pounds)` method
    at all. Since the `convertPoundsToKg(int pounds)` method does not require access
    to the object fields, it can be static, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Fans of the metric system are still able to convert pounds into kilograms and
    back. Besides, since both converting methods are static, we do not need to create
    an instance of the class that implements the `Truck` interface in order to do
    the conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The results do not change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e402e41-cd4e-42b6-9ed2-5549b764a5ce.png)'
  prefs: []
  type: TYPE_IMG
- en: A better way to work with nulls using Optional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the `java.util.Optional` class for
    representing optional values instead of using `null` references. It was introduced
    in Java 8 and further enhanced in Java 9—where three more methods were added—`or()`,
    `ifPresentOrElse()`, and `stream()`. We will demonstrate all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Optional` class is a wrapper around a value, which can be `null` or a value
    of any type. It was intended to help to avoid the dreaded `NullPointerException`.
    But, so far, the introduction of `Optional` helped to accomplish it only to a
    degree and mostly in the area of streams and functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: The vision that motivated the creation of the `Optional` class was to call the `isPresent()` method
    on an `Optional` object and then apply the `get()` method (to get the contained
    value) only when the `isPresent()` method returns `true`. Unfortunately, when
    one cannot guarantee that the reference to the `Optional` object itself is not
    `null`, one needs to check it in order to avoid `NullPointerException`. If so,
    then the value of using `Optional` diminishes, because with even less amount of
    code writing we could check for `null` the value itself and avoid wrapping inside
    `Optional` whatsoever? Let's write the code that illustrates what we have been
    talking about.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we would like to write a method that checks the lottery
    result and, if the ticket you have bought with your friend wins, calculates your 50%
    share. The traditional way to do it would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'But, to demonstrate how to use `Optional`, we will assume that the result is
    of the `Integer` type. Then, we also need to check for `null`, if we are not sure
    that the passed-in value cannot be `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `Optional` class does not help to avoid the check for `null`. It
    even requires an additional check, `isPresent()`, to be added so that we can avoid
    `NullPointerException` while getting the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Apparently, the preceding usage of `Optional` does not help to improve the code
    or make the coding easier. Using `Optional` in Lambda expressions and stream pipelines
    has more potential because the `Optional` object provides methods that can be
    invoked via the dot-operator and can be plugged into the fluent-style processing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create an `Optional` object using any of the methods that have been demonstrated,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Notice that a `null` value can be wrapped inside an `Optional` object by using
    the `ofNullable()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to compare two `Optional` objects by using the `equals()` method,
    which compares them by value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Please note that an empty `Optional` object is equal to an object that wraps
    the `null` value (the `prize1` and `prize3` objects in the preceding code). The `prize2`
    and `prize4` objects in the preceding code are equal because they wrap the same
    value, although they are different objects and the references do not match (`prize2
    != prize4`). Also, notice that empty objects that wrap different types are equal
    (`prize1.equals(congrats1)`), which means that the `equals()` method of the `Optional` class
    does not compare the value type.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Use the `or(Suppier<Optional<T>> supplier)` method of the `Optional` class
    to reliably return a non-null value from the `Optional` object. If the object
    is empty and contains `null`, it returns another value contained in the `Optional` object
    that was produced by the provided `Supplier` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the `Optional<Integer> lotteryPrize` object can contain a `null`
    value, the following construct will return zero every time the `null` value is
    encountered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `ifPresent(Consumer<T> consumer)` method to ignore the `null` value
    and to process the non-null value using the provided `Consumer<T>` function. For
    example, here is the `processIfPresent(Optional<Integer>)` method, which processes the `Optional<Integer>
    lotteryPrize` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We can simplify the preceding code by creating the `checkResultAndShare(int
    prize)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `processIfPresent()` method looks much simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do not want to ignore the `null` value and process it as well, you can
    use the `ifPresentOrElse(Consumer<T> consumer, Runnable processEmpty)` method
    to apply the `Consumer<T>` function to a non-null value, and use the `Runnable` functional
    interface to process the `null` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have reused the `checkResultAndShare(int prize)` method we
    just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `orElseGet(Supplier<T> supplier)` method allows us to replace an
    empty or `null` value (contained in the  `Optional` object) with the value produced
    by the provided `Supplier<T>` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `orElseThrow()` method if you need to throw an exception in case an `Optional` object
    is empty or contains a `null` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'An overloaded version of the `orElseThrow()` method allows us to specify an
    exception and the message you would like to throw when the value contained in
    the `Optional` object is `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `filter()`, `map()`, and `flatMap()` methods to process `Optional` objects
    in a stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `useFilter()` method processes only those stream
    elements that have non-null values. The `useMap()` method processes all stream
    elements but replaces `Optional` objects without any value or by wrapping the `null`
    value with an `Optional` object that wraps zero. The last method uses `flatMap()`,
    which requires returning a stream from the provided function. Our example is quite
    useless in this respect because the function we pass as a `flatMap()` parameter
    produces a stream of one object, so using `map()` (as in the previous `useMap()` method)
    is a better solution here. We only did this for demonstrating how the `flatMap()`
    method can be plugged into the stream pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code demonstrates the functionality of the described `Optional` class.
    The `useFlatMap()` method accepts a list of `Optional` objects, creates a stream,
    and process each emitted element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Each element of the original list first enters the `flatMap()` method as an
    input into the `tryUntilWin` function. This function first checks if the value
    of the `Optional` object is present. If yes, the `Optional` object is emitted
    as a single element of a stream and is processed by the `checkResultAndShare()` method.
    But if the `tryUntilWin` function determines that there is no value in the `Optional`
    object or the value is `null`, it generates a random double number in the range
    between `-0.8` and `0.2`. If the value is negative, an `Optional` object is added
    to the resulting list with a value of zero and a new random number is generated.
    But if the generated number is positive, it is used for the prize-value calculation,
    which is added to the resulting list that's wrapped inside an `Optional` object.
    The resulting list of `Optional` objects is then returned as a stream, and each
    element of the stream is processed by the `checkResultAndShare()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s run the preceding method for the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The results will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94c3889d-7c68-497b-a360-7604d8c4f8ca.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, when the first list element, `Optional.empty()`, was processed,
    the `tryUntilWin` function succeeded in getting a positive `prize` value from
    the third attempt. The second `Optional.ofNullable(null)` object caused two attempts
    until the `tryUntilWin` function succeeded. The last object successfully went
    through and awarded you and your friend 50,000 each.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An object of the `Optional` class is not serializable and, thus, cannot be used
    as a field of an object. This is another indication that the designer of the `Optional` class
    intended to be used in a stateless process.
  prefs: []
  type: TYPE_NORMAL
- en: It makes the stream processing pipeline more compact and expressive, focusing
    on the actual values instead of checking if there are empty elements in the stream.
  prefs: []
  type: TYPE_NORMAL
- en: Using the utility class Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how the `java.util.Objects` utility class allows
    for the better processing of objects related functionality related to object comparison,
    calculating a hash value, and checking for `null`. It was a long time coming,
    as the programmers wrote the same code for checking an object for `null` again
    and again.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Objects` class has only 17 methods, all of which are static. For a better
    overview, we have organized them into seven groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '`compare()`: One method compares two objects using the provided `Comparator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toString()`: Two methods that convert an `Object` to a `String` value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkIndex()`: Three methods that allow us to check whether the index and
    the length of a collection or an array are compatible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requireNonNull()`: Five methods throw an exception if the provided object
    is `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hash()`, `hashCode():` Two methods that calculate a hash value for a single
    object or an array of objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isNull()`, `nonNull()`: Two methods that wrap the `obj == null` or  `obj !=
    null` expressions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`equals()`, `deepEquals()`: Two methods that compare two objects that can be
    null or arrays'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to write code that uses these methods in the preceding sequence.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `int compare(T a, T b, Comparator<T> c)` method uses the provided comparator
    for comparing the two objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Returns 0 when the objects are equal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a negative number when the first object is smaller than the second one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a positive number otherwise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The non-zero return value of the `int compare(T a, T b, Comparator<T> c)` method
    depends on the implementation. In the case of `String`, smaller and bigger are
    defined according to their ordering position (smaller is placed in front of bigger
    in the ordered list), and the returned value is the difference between the positions
    of the first and the second parameter in the list, ordered according to the provided
    comparator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Integer` values, on the other hand, return just `-1` or `1` when the values
    are not equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Please notice how, in the last line in the preceding code block, the result
    changes when we compare numbers as `String` literals.
  prefs: []
  type: TYPE_NORMAL
- en: 'When both objects are `null`, the `compare()` method considers them equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'But it throws `NullPointerException` when only one of the objects is null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: If you need to compare an object with null, you are better off using `org.apache.commons.lang3.ObjectUtils.compare(T
    o1, T o2)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `toString(Object obj)` method is helpful when an `obj` object reference
    is the `null` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`String toString(Object obj)`: Returns the result of calling `toString()` on
    the first parameter when it is not `null` and `null` when the first parameter
    value is `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String toString(Object obj, String nullDefault)`: Returns the result of calling `toString()` on
    the first parameter when it is not `null` and the second parameter value, `nullDefault`,
    when the first parameter value is `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The usage of the `toString(Object obj)` method is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The `checkIndex()` overloaded method checks whether the index and the length
    of a collection or an array are compatible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`int checkIndex(int index, int length)`: Throws `IndexOutOfBoundsException` if
    the provided `index` is bigger than `length - 1`, for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '`int checkFromIndexSize(int fromIndex, int size, int length)`: Throws `IndexOutOfBoundsException` if
    the provided `index + size` is bigger than `length - 1`, for example:'
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '`int checkFromToIndex(int fromIndex, int toIndex, int length)`: Throws `IndexOutOfBoundsException` if
    the provided `fromIndex` is bigger than `toIndex`, or `toIndex` is bigger than `length
    - 1`, for example:'
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The five methods of the `requireNonNull()` group check the value of the first
    parameter, `obj`. If the value is `null`, they either throw `NullPointerException` or
    return the provided default value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`T requireNonNull(T obj)`: Throws `NullPointerException` without a message
    if the parameter is `null`, for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '`T requireNonNull(T obj, String message)`: Throws `NullPointerException` with
    the provided message if the first parameter is `null`, for example:'
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '`T requireNonNull(T obj, Supplier<String> messageSupplier)`: If the first parameter
    is `null`, returns the message generated the provided function or, if the generated
    message or the function itself is `null`, throws `NullPointerException`, for example:'
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '`T requireNonNullElse(T obj, T defaultObj)`: Returns the first parameter (if
    it is non-null), the second parameter (if it is non-null), throws `NullPointerException` (if
    both parameters is `null`), for example:'
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '`T requireNonNullElseGet(T obj, Supplier<T> supplier)`: Returns the first parameter
    (if it is non-null), the object produced by the provided supplier function (if
    it is non-null and `supplier.get()` is non-null), throws `NullPointerException` (if
    both parameters are `null` or the first parameter and supplier.get() are `null`),
    for example:'
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `hash()` or `hashCode()` method is typically used to override the default `hashCode()` implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`int hashCode(Object value)`: Calculates a hash value for a single object,
    for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '`int hash(Object... values)`: Calculates a hash value for an array of objects,
    for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the `hashCode(Object value)` method returns a different hash
    value (`96354`) than the `Objects.hash(Object... values)` method (`96385`), even
    though they calculate the hash value for the same single object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `isNull()` and `nonNull()` methods are just wrappers around Boolean expressions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`boolean isNull(Object obj)`: Returns the same value as `obj == null`, for
    example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '`boolean nonNull(Object obj)`: Returns the same value as `obj != null`, for
    example:'
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The `equals()` and `deepEquals()` methods allow us to compare two objects by
    their state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`boolean equals(Object a, Object b)`: Compares two objects using the `equals(Object)` method
    and handles the case when one of them or both are `null`, for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `Objects.equals(ints1, ints2)` returns `false` because
    arrays cannot override the `equals()` method of the `Object` class and are compared
    by references, not by value.
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean deepEquals(Object a, Object b)`: Compares two arrays by the value
    of their elements, for example:'
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `deepEquals()` method returns `true` when the corresponding
    values of the arrays are equal. But if the arrays have different values or a different
    order of the same values, the method returns `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The  `Arrays.equals(Object a, Object b)` and  `Arrays.deepEquals(Object a, Object
    b)` methods behave the same way as the `Objects.equals(Object a, Object b)` and `Objects.deepEquals(Object a, Object
    b)` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: In fact, the `Arrays.equals(Object a, Object b)` and  `Arrays.deepEquals(Object a, Object
    b)` methods are used in the implementation of the `Objects.equals(Object a, Object
    b)` and `Objects.deepEquals(Object a, Object b)` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, if you would like to compare two objects, `a` and `b`, by the
    values of their fields, then:'
  prefs: []
  type: TYPE_NORMAL
- en: If they are not arrays and `a` is not `null`, use `a.equals(Object b)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If they are not arrays and each or both objects can be `null`, use `Objects.equals(Object a, Object
    b)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If both can be arrays and each or both can be `null`, use `Objects.deepEquals(Object a, Object
    b)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Objects.deepEquals(Object a, Object b)` method seems to be the safest one,
    but it does not mean that you must always use it. Most of the time, you will know
    whether the compared objects can be `null` or can be arrays, so you can safely
    use other methods, too.
  prefs: []
  type: TYPE_NORMAL
