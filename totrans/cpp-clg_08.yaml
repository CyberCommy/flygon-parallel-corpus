- en: Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 67\. Validating passwords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that validates password strength based on predefined rules,
    which may then be selected in various combinations. At a minimum, every password
    must meet a minimum length requirement. In addition, other rules could be enforced,
    such as the presence of at least one symbol, digit, uppercase and lowercase letter,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 68\. Generating random passwords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that can generate random passwords according to some predefined
    rules. Every password must have a configurable minimum length. In addition, it
    should be possible to include in the generation rules such as the presence of
    at least one digit, symbol, lower or uppercase character, and so on. These additional
    rules must be configurable and composable.
  prefs: []
  type: TYPE_NORMAL
- en: 69\. Generating social security numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a program that can generate social security numbers for two countries,
    Northeria and Southeria, that have different but similar formats for the numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: In Northeria, the numbers have the format `SYYYYMMDDNNNNNC`, where `S` is a
    digit representing the sex, 9 for females and 7 for males, `YYYYMMDD` is the birth
    date, `NNNNN` is a five-digit random number, unique for a day (meaning that the
    same number can appear twice for two different dates, but not the same date),
    and `C` is a digit picked so that the checksum computed as described later is
    a multiple of 11.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Southeria, the numbers have the format `SYYYYMMDDNNNNC`, where `S` is a digit
    representing the sex, 1 for females and 2 for males, `YYYYMMDD` is the birth date,
    `NNNN` is a four-digit random number, unique for a day, and `C` is a digit picked
    so that the checksum computed as described below is a multiple of 10.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The checksum in both cases is a sum of all the digits, each multiplied by its
    weight (the position from the most significant digit to the least). For example,
    the checksum for the Southerian number 12017120134895 is computed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 70\. Approval system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program for a purchasing department of a company that allows employees
    to approve new purchases (or expenses). However, based on their position, each
    employee may only approve expenses up to a predefined limit. For instance, regular
    employees can approve expenses up to 1,000 currency units, team managers up to
    10,000, and the department manager up to 100,000\. Any expense greater than that
    must be explicitly approved by the company president.
  prefs: []
  type: TYPE_NORMAL
- en: 71\. Observable vector container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a class template that behaves like a vector but can notify registered
    parties of internal state changes. The class must provide at least the following
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Various constructors for creating new instances of the class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator=` to assign values to the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`push_back()` to add a new element at the end of the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pop_back()` to remove the last element from the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()` to remove all the elements from the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size()` to return the number of elements from the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`empty()` to indicate whether the container is empty or has elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator=`, `push_back()`, `pop_back()`, and `clear()` must notify others
    of the state changes. The notification should include the type of the change,
    and, when the case, the index of the element that was changed (such as added or
    removed).'
  prefs: []
  type: TYPE_NORMAL
- en: 72\. Computing order price with discounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A retail store sells a variety of goods and can offer various types of discount,
    for selected customers, articles, or per order. The following types of discount
    could be available:'
  prefs: []
  type: TYPE_NORMAL
- en: A fixed discount, such as 5%, regardless of the article or the quantity that
    is purchased.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A volume discount, such as 10%, for each article when buying more than a particular
    quantity of that article.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A price discount per total order of an article, that is, a discount for an article
    when a customer buys a quantity of that article so that the total cost exceeds
    a particular amount. For instance, a 15% discount for an article when the total
    cost of that article exceeds $100\. If the article costs $5, and the customer
    buys 30 units, the total cost is $150; therefore, a 15% discount applies to the
    order of that article.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A price discount per entire order (regardless what articles and in which quantity
    they were ordered).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a program that can calculate the final price of a particular order. It
    is possible to compute the final price in different ways; for instance, all discounts
    could be cumulative, or on the other hand, if an article has a discount, a customer
    or total order discount might not be considered.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 67\. Validating passwords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem described here is a typical case for the *decorator* pattern. This
    design pattern allows adding behavior to an object without affecting other objects
    of the same type. This is achieved by wrapping an object within another object.
    Multiple decorators could be stacked on top of each other, each time adding new
    functionality. In our case, the functionality would be validating that a given
    password meets a particular requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class diagram describes the pattern for validating passwords:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5538133-29a5-4fc2-9211-f899f1f4bae0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The implementation of the pattern, as described in the diagram, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`password_validator` is the base class and has a single virtual method called
    `validate()` with a string argument representing the password. `length_validator`
    is derived from this class and implements the mandatory password requirement for
    a minimum length.'
  prefs: []
  type: TYPE_NORMAL
- en: '`password_validator_decorator` is also derived from `password_validator` and
    contains an inner `password_validator` component. Its `validate()` implementation
    simply resolves to calling `inner->validate()`. The other classes, `digit_password_validator`,
    `symbol_password_validator`, and `case_password_validator`, are derived from it
    and implement the other individual password strength requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are examples of how these classes could be composed to create
    various password validators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 68\. Generating random passwords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This problem could be solved using the *composite* pattern or a variation of
    the pattern. This design pattern composes objects into tree hierarchies and enables
    treating groups (or trees) of objects the same way as individual objects of the
    same type. The following class diagram shows a hierarchy of classes that can be
    used for generating passwords:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1c82b45-1102-4c75-aa44-575a8696909e.png)'
  prefs: []
  type: TYPE_IMG
- en: '`password_generator` is the base class and has several virtual methods: `generate()` returns
    a new random string, `length()` specifies the length of the strings it generates,
    `allowed_chars()` returns a string with all the characters it uses for generating
    passwords, and `add()` adds a new child component to a composite generator. `basic_password_generator`
    is derived from this base class and defines a generator with a minimum length.
    `digit_generator`, `symbol_generator`, `upper_letter_generator`, and `lower_letter_generator`
    are derived from `basic_password_generator` and override `allowed_chars()` to
    define subsets of characters used to generate random texts.'
  prefs: []
  type: TYPE_NORMAL
- en: '`composite_password_generator` is also derived from `password_generator` and
    has a collection of `password_generator` objects that it uses to compose a random
    text. This is done in the overridden `generate()` method, which concatenates all
    the strings generated by the child components and then randomly shuffles them
    to produce a final string representing a password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be used to generate passwords in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You could use the password validator we wrote for the previous problem to make
    sure the passwords generated in this way do indeed meet the expected requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 69\. Generating social security numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The formats for both countries are very similar, although several details are
    different:'
  prefs: []
  type: TYPE_NORMAL
- en: The value of the digit for the sex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The length of the random part, and therefore the length of the entire number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number the checksum must be a multiple of
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This problem can be solved using the *template method* design pattern, which
    defines the skeleton of an algorithm and lets subclasses redefine particular steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ba24167-f7a0-4d1b-9065-75abe6616e95.png)'
  prefs: []
  type: TYPE_IMG
- en: '`social_number_generator` is a base class that has a public method called `generate()`
    that produces a new social security number for a specified sex and birth date.
    This method internally calls several protected virtual methods, `sex_digit()`,
    `next_random()`, and `modulo_value()`. These virtual methods are overridden in
    the two derived classes, `northeria_social_number_generator` and `southeria_social_number_generator`.
    In addition, a factory class holds instances of these social number generators
    and makes them available to the calling clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this code, social security numbers can be generated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 70\. Approval system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The problem described can be expressed in a series of `if … else if … else
    … endif` statements. An object-oriented version of this idiom is the *chain of
    responsibility* design pattern. This pattern defines a chain of receiver objects
    that have the responsibility of either handling a request or passing it to the
    next receiver in the chain if one exists. The following class diagram shows a
    possible implementation of the pattern for this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/676456df-25ff-47e3-8206-7ec6a5ea2f68.png)'
  prefs: []
  type: TYPE_IMG
- en: '`employee` is a class that represents an employee in the company. An employee
    may have a direct manager that is set with a call to the `set_direct_manager()` method.
    Every employee has a name and a role that defines their responsibilities and permissions.
    `role` is an abstract base class for possible roles and has a pure virtual method, `approval_limit()`,
    that derived classes such as `employee_role`, `team_manager_role`, `department_manager_role`,
    and `president_role` override to indicate the limit up to which an employee can
    approve expenses. The `approve()` method from the `employee` class is used to
    let an employee approve an expense. If the role of the employee allows them to
    approve an expense, they do so; otherwise, the request is passed to their direct
    manager, if any is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows how this code can be used to approve expenses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 71\. Observable vector container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The observable vector described in this problem is a typical example of a subject
    in the design pattern called observer. This pattern describes an object, called
    the **subject**, that maintains a list of dependent objects, called **observers**,
    and notifies them of any state changes by calling one of their methods. The class
    diagram shown here describes a possible pattern implementation for the proposed
    problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8b339bd-6ace-409b-aeb9-b95cb3999171.png)'
  prefs: []
  type: TYPE_IMG
- en: '`observable_vector` is a class that wraps an `std::vector` and exposes the
    required operations. It also maintains a list of pointers to `collection_observer`
    objects. This is a base class for objects that want to be informed of any state
    changes in the `observable_vector`. It has a virtual method called `collection_changed()`
    with an argument of type `collection_changed_notification` that contains information
    about the change. When any change in the internal state of `observable_vector`
    occurs, it calls this method on all the registered observers. Observers can be
    added to the vector with the `add_observer()` method, or removed from the vector
    by calling the `remove_observer()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are examples of using the `observable_vector` class and getting
    notifications of the changes in its internal state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can take it as a further exercise to add more functionality to `observable_vector`,
    such as providing access to the elements using iterators.
  prefs: []
  type: TYPE_NORMAL
- en: 72\. Computing order price with discounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The problem proposed here can be solved with the *strategy* pattern. This design
    pattern defines a family of algorithms and makes them interchangeable within the
    family. In this particular problem, both the discounts and the final order price
    calculators could be implemented based on the strategy pattern. The following
    diagram describes the hierarchy of discount types and their interchangeable use
    within the other classes, `customer`, `article`, `order_line`, and `order`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef515e1d-dd0e-4413-9f46-13516bc7a64b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The implementation of the discount types is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The classes that model customers, articles, and orders have only a minimum
    structure, in order to keep the solution simple. They are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For computing the final price of an order, we could use various types of calculator.
    This is yet another instantiation of the strategy pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/717ac2bc-3067-4808-962d-f4af920797a9.png)'
  prefs: []
  type: TYPE_IMG
- en: '`price_calculator` is an abstract base class that has a pure virtual method, `calculate_price()`.
    The classes derived from `price_calculator`, such as `cumulative_price_calculator`,
    provide the actual algorithm implementation by overriding the `calculate_price()`
    method. For simplicity, in this implementation only one concrete strategy for
    price calculation is provided. As a further exercise, you can implement others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are examples of how to compute the final order price using `cumulative_price_calculator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
