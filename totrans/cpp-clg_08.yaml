- en: Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 67\. Validating passwords
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that validates password strength based on predefined rules,
    which may then be selected in various combinations. At a minimum, every password
    must meet a minimum length requirement. In addition, other rules could be enforced,
    such as the presence of at least one symbol, digit, uppercase and lowercase letter,
    and so on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 68\. Generating random passwords
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that can generate random passwords according to some predefined
    rules. Every password must have a configurable minimum length. In addition, it
    should be possible to include in the generation rules such as the presence of
    at least one digit, symbol, lower or uppercase character, and so on. These additional
    rules must be configurable and composable.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 69\. Generating social security numbers
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a program that can generate social security numbers for two countries,
    Northeria and Southeria, that have different but similar formats for the numbers:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: In Northeria, the numbers have the format `SYYYYMMDDNNNNNC`, where `S` is a
    digit representing the sex, 9 for females and 7 for males, `YYYYMMDD` is the birth
    date, `NNNNN` is a five-digit random number, unique for a day (meaning that the
    same number can appear twice for two different dates, but not the same date),
    and `C` is a digit picked so that the checksum computed as described later is
    a multiple of 11.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Southeria, the numbers have the format `SYYYYMMDDNNNNC`, where `S` is a digit
    representing the sex, 1 for females and 2 for males, `YYYYMMDD` is the birth date,
    `NNNN` is a four-digit random number, unique for a day, and `C` is a digit picked
    so that the checksum computed as described below is a multiple of 10.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The checksum in both cases is a sum of all the digits, each multiplied by its
    weight (the position from the most significant digit to the least). For example,
    the checksum for the Southerian number 12017120134895 is computed as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 70\. Approval system
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program for a purchasing department of a company that allows employees
    to approve new purchases (or expenses). However, based on their position, each
    employee may only approve expenses up to a predefined limit. For instance, regular
    employees can approve expenses up to 1,000 currency units, team managers up to
    10,000, and the department manager up to 100,000\. Any expense greater than that
    must be explicitly approved by the company president.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 71\. Observable vector container
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a class template that behaves like a vector but can notify registered
    parties of internal state changes. The class must provide at least the following
    operations:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Various constructors for creating new instances of the class
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator=` to assign values to the container'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`push_back()` to add a new element at the end of the container'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pop_back()` to remove the last element from the container'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()` to remove all the elements from the container'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size()` to return the number of elements from the container'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`empty()` to indicate whether the container is empty or has elements'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator=`, `push_back()`, `pop_back()`, and `clear()` must notify others
    of the state changes. The notification should include the type of the change,
    and, when the case, the index of the element that was changed (such as added or
    removed).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 72\. Computing order price with discounts
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A retail store sells a variety of goods and can offer various types of discount,
    for selected customers, articles, or per order. The following types of discount
    could be available:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: A fixed discount, such as 5%, regardless of the article or the quantity that
    is purchased.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A volume discount, such as 10%, for each article when buying more than a particular
    quantity of that article.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A price discount per total order of an article, that is, a discount for an article
    when a customer buys a quantity of that article so that the total cost exceeds
    a particular amount. For instance, a 15% discount for an article when the total
    cost of that article exceeds $100\. If the article costs $5, and the customer
    buys 30 units, the total cost is $150; therefore, a 15% discount applies to the
    order of that article.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A price discount per entire order (regardless what articles and in which quantity
    they were ordered).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a program that can calculate the final price of a particular order. It
    is possible to compute the final price in different ways; for instance, all discounts
    could be cumulative, or on the other hand, if an article has a discount, a customer
    or total order discount might not be considered.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 67\. Validating passwords
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem described here is a typical case for the *decorator* pattern. This
    design pattern allows adding behavior to an object without affecting other objects
    of the same type. This is achieved by wrapping an object within another object.
    Multiple decorators could be stacked on top of each other, each time adding new
    functionality. In our case, the functionality would be validating that a given
    password meets a particular requirement.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class diagram describes the pattern for validating passwords:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5538133-29a5-4fc2-9211-f899f1f4bae0.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: 'The implementation of the pattern, as described in the diagram, is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`password_validator` is the base class and has a single virtual method called
    `validate()` with a string argument representing the password. `length_validator`
    is derived from this class and implements the mandatory password requirement for
    a minimum length.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '`password_validator_decorator` is also derived from `password_validator` and
    contains an inner `password_validator` component. Its `validate()` implementation
    simply resolves to calling `inner->validate()`. The other classes, `digit_password_validator`,
    `symbol_password_validator`, and `case_password_validator`, are derived from it
    and implement the other individual password strength requirements.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are examples of how these classes could be composed to create
    various password validators:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 68\. Generating random passwords
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This problem could be solved using the *composite* pattern or a variation of
    the pattern. This design pattern composes objects into tree hierarchies and enables
    treating groups (or trees) of objects the same way as individual objects of the
    same type. The following class diagram shows a hierarchy of classes that can be
    used for generating passwords:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1c82b45-1102-4c75-aa44-575a8696909e.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: '`password_generator` is the base class and has several virtual methods: `generate()` returns
    a new random string, `length()` specifies the length of the strings it generates,
    `allowed_chars()` returns a string with all the characters it uses for generating
    passwords, and `add()` adds a new child component to a composite generator. `basic_password_generator`
    is derived from this base class and defines a generator with a minimum length.
    `digit_generator`, `symbol_generator`, `upper_letter_generator`, and `lower_letter_generator`
    are derived from `basic_password_generator` and override `allowed_chars()` to
    define subsets of characters used to generate random texts.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '`composite_password_generator` is also derived from `password_generator` and
    has a collection of `password_generator` objects that it uses to compose a random
    text. This is done in the overridden `generate()` method, which concatenates all
    the strings generated by the child components and then randomly shuffles them
    to produce a final string representing a password:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code can be used to generate passwords in the following manner:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You could use the password validator we wrote for the previous problem to make
    sure the passwords generated in this way do indeed meet the expected requirements.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 69\. Generating social security numbers
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 69. 生成社会保障号码
- en: 'The formats for both countries are very similar, although several details are
    different:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 两个国家的格式非常相似，尽管有一些细节不同：
- en: The value of the digit for the sex
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性别的数字值
- en: The length of the random part, and therefore the length of the entire number
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机部分的长度，因此整个数字的长度
- en: The number the checksum must be a multiple of
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 校验和必须是的倍数
- en: 'This problem can be solved using the *template method* design pattern, which
    defines the skeleton of an algorithm and lets subclasses redefine particular steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用*模板方法*设计模式来解决这个问题，该模式定义了算法的骨架，并允许子类重新定义特定步骤：
- en: '![](img/2ba24167-f7a0-4d1b-9065-75abe6616e95.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ba24167-f7a0-4d1b-9065-75abe6616e95.png)'
- en: '`social_number_generator` is a base class that has a public method called `generate()`
    that produces a new social security number for a specified sex and birth date.
    This method internally calls several protected virtual methods, `sex_digit()`,
    `next_random()`, and `modulo_value()`. These virtual methods are overridden in
    the two derived classes, `northeria_social_number_generator` and `southeria_social_number_generator`.
    In addition, a factory class holds instances of these social number generators
    and makes them available to the calling clients:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`social_number_generator`是一个基类，具有一个名为`generate()`的公共方法，用于为指定的性别和出生日期生成新的社会保障号码。此方法内部调用几个受保护的虚方法，`sex_digit()`、`next_random()`和`modulo_value()`。这些虚方法在两个派生类`northeria_social_number_generator`和`southeria_social_number_generator`中被覆盖。此外，一个工厂类持有这些社会号码生成器的实例，并使它们可用于调用客户端：'
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using this code, social security numbers can be generated as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，可以生成社会保障号码如下：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 70\. Approval system
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 70. 批准系统
- en: 'The problem described can be expressed in a series of `if … else if … else
    … endif` statements. An object-oriented version of this idiom is the *chain of
    responsibility* design pattern. This pattern defines a chain of receiver objects
    that have the responsibility of either handling a request or passing it to the
    next receiver in the chain if one exists. The following class diagram shows a
    possible implementation of the pattern for this problem:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所描述的问题可以用一系列`if … else if … else … endif`语句来表达。这种习惯用法的面向对象版本是*责任链*设计模式。该模式定义了一系列接收者对象，它们负责处理请求或将其传递给链中的下一个接收者（如果存在）。以下类图显示了该问题的可能模式实现：
- en: '![](img/676456df-25ff-47e3-8206-7ec6a5ea2f68.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/676456df-25ff-47e3-8206-7ec6a5ea2f68.png)'
- en: '`employee` is a class that represents an employee in the company. An employee
    may have a direct manager that is set with a call to the `set_direct_manager()` method.
    Every employee has a name and a role that defines their responsibilities and permissions.
    `role` is an abstract base class for possible roles and has a pure virtual method, `approval_limit()`,
    that derived classes such as `employee_role`, `team_manager_role`, `department_manager_role`,
    and `president_role` override to indicate the limit up to which an employee can
    approve expenses. The `approve()` method from the `employee` class is used to
    let an employee approve an expense. If the role of the employee allows them to
    approve an expense, they do so; otherwise, the request is passed to their direct
    manager, if any is defined:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`employee`是代表公司员工的类。员工可能有一个直接经理，可以通过调用`set_direct_manager()`方法来设置。每个员工都有一个名字和一个定义其责任和权限的角色。`role`是可能角色的抽象基类，并具有一个纯虚方法`approval_limit()`，派生类（如`employee_role`、`team_manager_role`、`department_manager_role`和`president_role`）覆盖以指示员工可以批准的费用上限。`employee`类中的`approve()`方法用于让员工批准费用。如果员工的角色允许他们批准费用，他们会这样做；否则，如果定义了直接经理，则将请求传递给他们的直接经理：'
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following example shows how this code can be used to approve expenses:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何使用此代码批准费用：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 71\. Observable vector container
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 71. 可观察向量容器
- en: 'The observable vector described in this problem is a typical example of a subject
    in the design pattern called observer. This pattern describes an object, called
    the **subject**, that maintains a list of dependent objects, called **observers**,
    and notifies them of any state changes by calling one of their methods. The class
    diagram shown here describes a possible pattern implementation for the proposed
    problem:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中描述的可观察向量是观察者设计模式中主题的典型示例。该模式描述了一个称为**主题**的对象，它维护一系列称为**观察者**的依赖对象，并通过调用它们的方法通知它们任何状态更改。此处显示的类图描述了所提出问题的可能模式实现：
- en: '![](img/c8b339bd-6ace-409b-aeb9-b95cb3999171.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8b339bd-6ace-409b-aeb9-b95cb3999171.png)'
- en: '`observable_vector` is a class that wraps an `std::vector` and exposes the
    required operations. It also maintains a list of pointers to `collection_observer`
    objects. This is a base class for objects that want to be informed of any state
    changes in the `observable_vector`. It has a virtual method called `collection_changed()`
    with an argument of type `collection_changed_notification` that contains information
    about the change. When any change in the internal state of `observable_vector`
    occurs, it calls this method on all the registered observers. Observers can be
    added to the vector with the `add_observer()` method, or removed from the vector
    by calling the `remove_observer()` method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`observable_vector`是一个包装`std::vector`并公开所需操作的类。它还维护一个指向`collection_observer`对象的指针列表。这是希望在`observable_vector`的任何状态更改时得到通知的对象的基类。它有一个名为`collection_changed()`的虚方法，带有`collection_changed_notification`类型的参数，其中包含有关更改的信息。当`observable_vector`的内部状态发生任何更改时，它会调用所有注册观察者的此方法。观察者可以使用`add_observer()`方法添加到向量中，或者通过调用`remove_observer()`方法从向量中移除：'
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following are examples of using the `observable_vector` class and getting
    notifications of the changes in its internal state:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`observable_vector`类并获取其内部状态更改通知的示例：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can take it as a further exercise to add more functionality to `observable_vector`,
    such as providing access to the elements using iterators.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将其视为进一步的练习，以添加更多功能到`observable_vector`，例如使用迭代器访问元素。
- en: 72\. Computing order price with discounts
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 72. 使用折扣计算订单价格
- en: 'The problem proposed here can be solved with the *strategy* pattern. This design
    pattern defines a family of algorithms and makes them interchangeable within the
    family. In this particular problem, both the discounts and the final order price
    calculators could be implemented based on the strategy pattern. The following
    diagram describes the hierarchy of discount types and their interchangeable use
    within the other classes, `customer`, `article`, `order_line`, and `order`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提出的问题可以用*策略*模式来解决。这种设计模式定义了一组算法，并使它们在该组内可互换。在这个特定的问题中，折扣和最终订单价格计算器都可以基于策略模式来实现。以下图表描述了折扣类型的层次结构及其在其他类`customer`、`article`、`order_line`和`order`中的可互换使用。
- en: '![](img/ef515e1d-dd0e-4413-9f46-13516bc7a64b.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef515e1d-dd0e-4413-9f46-13516bc7a64b.png)'
- en: 'The implementation of the discount types is shown here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 折扣类型的实现如下所示：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The classes that model customers, articles, and orders have only a minimum
    structure, in order to keep the solution simple. They are shown here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟顾客、文章和订单的类只有最少的结构，以保持解决方案的简单性。它们如下所示：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For computing the final price of an order, we could use various types of calculator.
    This is yet another instantiation of the strategy pattern:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算订单的最终价格，我们可以使用各种类型的计算器。这是策略模式的又一个实例：
- en: '![](img/717ac2bc-3067-4808-962d-f4af920797a9.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/717ac2bc-3067-4808-962d-f4af920797a9.png)'
- en: '`price_calculator` is an abstract base class that has a pure virtual method, `calculate_price()`.
    The classes derived from `price_calculator`, such as `cumulative_price_calculator`,
    provide the actual algorithm implementation by overriding the `calculate_price()`
    method. For simplicity, in this implementation only one concrete strategy for
    price calculation is provided. As a further exercise, you can implement others:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`price_calculator`是一个抽象基类，具有一个纯虚方法`calculate_price()`。从`price_calculator`派生的类，如`cumulative_price_calculator`，通过覆盖`calculate_price()`方法提供实际的算法实现。为简单起见，在这个实现中只提供了一个具体的价格计算策略。作为进一步的练习，您可以实现其他策略：'
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here are examples of how to compute the final order price using `cumulative_price_calculator`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`cumulative_price_calculator`计算最终订单价格的示例：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
