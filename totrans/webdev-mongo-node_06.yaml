- en: Controllers and View Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until this point, the controllers we wrote for our application were extremely
    basic. They were started with the simple task of sending text responses to the
    client. In the preceding chapter, we updated the controllers so that they render
    an HTML view and send the HTML code to the client instead of a simple text response.
    The primary job of a controller is to act as an entity which holds the logic that
    makes all of the necessary decisions to properly render a response to the client.
    In our case, this means retrieving and/or generating the data necessary for a
    page to appear completely.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the controllers so that they generate a data model and pass it to
    a view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including logic to support uploading and saving image files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the controllers to actually render dynamic HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including helpers for the partials that generate the website statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating on the UI to include improved usability via jQuery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **controller** can be defined as an entity that will be responsible for manipulating
    models and initiating the View render process with the data received from the
    corresponding models. In the code we have developed so far, we can see that the
    express router instance is used to tie functions to a corresponding route. These
    functions are nothing but controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For every route that we create in our router, the following two parameters
    are necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is the string for the route itself, which is `/images/:image_id`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter is a controller function that will be executed when that
    route is accessed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For any route that has anything to do with images, we rely on the image controller.
    Likewise, any route that has anything to do with the home page relies on the home
    controller, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The steps we will take to define our controllers in our app are purely organizational
    and based on personal preference. We created our controllers as modules so that
    our router isn't a big, long, convoluted mess of spaghetti code. We could have
    just as easily kept all of the logic contained in our controllers as functions
    directly within the routes themselves, but this would have been an organizational
    mess and made way for a very hard-to-read code to be maintained later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'As our sample app is fairly small, we currently have only two controllers:
    home and image. It is the responsibility of these controllers to build the appropriate
    View models for our HTML pages and to render the actual pages also. Any logic
    that is required to execute per page and build the View model will be done so
    via our controllers.'
  prefs: []
  type: TYPE_NORMAL
- en: View models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given that there is a single HTML View in our app, we will need to attach data
    to that page so that the template that is being rendered can be included in such
    a way that the dynamic areas of the page are replaced with the real content. To
    do this, we will need to generate a View model. During the rendering, the template
    engine will parse the template itself and look for a special syntax that indicates
    that specific sections should be replaced with values from the View model itself
    at runtime. We saw examples of this when we explored the Handlebars template framework
    in the preceding chapter. Think of this as a fancy runtime find and replace of
    your HTML templates--finding variables and replacing them with values stored in
    the View model sent to the template.
  prefs: []
  type: TYPE_NORMAL
- en: This process happens at the server, and the result is only sent as a response
    to the HTTP request that our application receives.
  prefs: []
  type: TYPE_NORMAL
- en: A View model is typically just a single JavaScript object that can be passed
    to the template. The template contains all of the necessary logic we will need
    to properly render the page. It is the task of the templating engine to produce
    the corresponding HTML by processing the templates with the associated models.
    The View model for a page will typically contain all of the data necessary to
    render the content-specific portions of that page. Using our application as an
    example, the View model for a specific image's page might contain the title of
    the image, its description, the information necessary to display the image, and
    various stats, such as number of likes, Views, and a collection of comments. A
    View model can be as simple or as complex as you like.
  prefs: []
  type: TYPE_NORMAL
- en: The term View model is used here to refer to the data form of the model, which
    will be tied to the template while rendering the HTML via any templating framework.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the home controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you take a look at our current home controller (`controllers/home.js`),
    you can see that the index function barely has any code in it whatsoever:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we want to do is build a basic View model using sample data
    so that we can see our View model at work. Replace that single `res.render` call
    with the following updated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we built a basic JavaScript collection of objects. The
    constant we declared is called `ViewModel`, but the name of this constant doesn't
    actually matter and can be whatever you want. The `const ViewModel` is an object
    that contains a single property called `images`, which is in itself an array.
  prefs: []
  type: TYPE_NORMAL
- en: The `images` array contains four sample images, each with a few basic properties--the
    most obvious properties were decided when deciding what kind of information we
    wanted per image. Each image in the collection has a `uniqueId`, `title`, `description`,
    `filename`, `Views`, `likes count`, and a `timestamp` property.
  prefs: []
  type: TYPE_NORMAL
- en: Once we set up our `ViewModel`, we simply pass it as the second parameter to
    the `res.render` call. Doing this while rendering a `View` makes the data in it
    available to the View itself. Now, if you recall from some of the template code
    we wrote for the home `index.Handlebars` View, we had a `{{#each images}}` loop
    that iterated through each image in the image collection of the View model passed
    to the template. Taking another look at our View model we created, we see that
    it only has a single property named `images`. The HTML code inside the Handlebars
    loop will then specifically reference the `uniqueId`, `filename`, and `title`
    properties for each image in the `images` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the changes to the home controller, launch your app again, and navigate
    to [http://localhost:3300](http://localhost:3300). You should see the four images
    that now appear on the home page in the Newest Images section (although, as you
    can see in the following screenshot, the images are still broken, as we didn''t
    actually create any image files):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cbdbd36-5f4e-41d5-8c49-0c9851f5f86c.png)'
  prefs: []
  type: TYPE_IMG
- en: The home page has a fairly simple controller and View model, and you might have
    noted that the sidebar is still completely empty. We'll cover the sidebar a little
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the image controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create the controller and View model for the image page. The controller
    for the image will be a little more complex, as we'll write the logic to handle
    the uploading and saving of the image files via the form on the home page.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `index` function in the image controller will look almost identical to the
    `index` function from the home controller. The only difference is that instead
    of generating an array of `images`, we will build a `ViewModel` for a single image.
    However, the `ViewModel` for this image will have a little more information than
    the one from the home page since we are building a page that renders a more detailed
    view of an image (versus the thumbnail collection on the home page). The most
    noteworthy inclusion is that of a comments array for the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking another look at the original `index` function in our `controllers/image.js`
    file, we can see the simple existing `res.render` line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to replace this line with a `ViewModel` and an updated `res.render`
    statement using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we declare a new `ViewModel` constant again--this time with an `image`
    property that contains the properties for the single image. In addition to the
    `image` property, there is also a `comments` property, which is an array of `comment`
    objects. You can see that each comment has various properties specific to a comment
    for each image. This JavaScript object is actually a pretty good preview of what
    our real data will wind up looking like once we include logic to connect our app
    to MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: After we build our sample `image` object and its collection of comments, we
    pass that to our `res.render` call, thus sending this new `ViewModel` directly
    to our image's Handlebars template. Again, if you review the HTML code in the
    `image.Handlebars` file, you can see where each property of the `ViewModel` is
    being displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, let''s run the application and make sure that our image page appears
    properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once the app is running and you've launched it in your browser, click on any
    of the images that are listed in the Newest Images section of the home page.
  prefs: []
  type: TYPE_NORMAL
- en: 'This should take you to an individual image page where you will see something
    like the page shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1d1fc03-f03c-4d4d-9842-084b65b95815.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that Title, Description, Likes, Views, and timestamp (converted to a different
    format for user readability) are all now appearing on the page. In addition, you
    can see a few comments listed near the image as well!
  prefs: []
  type: TYPE_NORMAL
- en: Uploading an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next feature we will need to implement in our image controller is the logic
    to handle when a user submits an image Upload Image on the home page. Even though
    the form is on the home page of our app, we decided to house the logic to handle
    uploading within our image controller because logically, this makes the most sense
    (since this feature primarily has to do with images, and not the home page per
    se). This was purely a personal decision, and you can house the logic wherever
    you please.
  prefs: []
  type: TYPE_NORMAL
- en: You should note that the HTML for the form on the home page has its action set
    to `/images`, and its method is `post`. This perfectly matches the route we set
    up previously, where we listen for a `post` to the `/images` route and call the
    image controller's `create` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `create` function in our image controller will have a few key responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: It should generate a unique filename for the image, which will also act as an
    identifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should save the uploaded file to the `filesystem` and ensure that it is an
    `image` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it should redirect the control to the `image/image_id` route once its
    task is complete, to display the actual image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we will work with the `filesystem` in this function, we will need to include
    a few modules from the Node.js core set of modules, specifically the `filesystem`
    (fs) and the `path` (path) modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin adding the necessary code for the Upload Image section, we
    will need a small fix to be applied on the configuration of the application. Further,
    we will need to add an extra module in the configure file to support the file
    uploads, namely `multer`. Add it as a dependency to our application using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go to the configuration file that is `server/configure.js` and `require`
    it via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can place this under the initially required modules in the file. Then,
    insert the following snippet under the Handlebars engine method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, our upload actions will work fine, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by first editing the `controllers/image.js` file and inserting
    the two new require statements at the very top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take the `create` function''s original code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace this original code with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a function called `saveImage` and executed it immediately after
    we declared it. This might look a little odd, but the reason for this will become
    clear when we implement database calls in the following chapter. The main reason
    is that we will call `saveImage` repeatedly to ensure that the unique identifier
    we generated is in fact unique and doesn't already exist in the database as a
    previously saved image's identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review a breakdown of the code that will be inserted in the `saveImage`
    function (replacing the `// to do...` comment). I will cover each line of code
    for this function and then give you the entire block of code at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to generate a random, six-digit alphanumeric string to represent
    a unique identifier for an image. This identifier will work in a similar fashion
    to other websites that provide short URLs for unique links (for example, *bit.ly*).
    To do this, we will first provide a string of possible characters that can be
    used while generating the random string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, loop-over for six times and randomly pull out a single character from
    our string of possible characters, appending it in each cycle. By the end of this
    `for` loop, we should have a string that consists of six random letters and/or
    numbers, for example, `a8bd73`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we declare three constants: where our uploaded files will be stored temporarily,
    the file extension of the file that was uploaded (for instance, `.png`, `.jpg`,
    and so on), and a destination where the uploaded image should ultimately reside.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For both the latter variables, we will use the path node module, which works
    great while dealing with filenames and paths and getting information from a file
    (such as a file extension). Next, we will move the image from its temporary upload
    path to its final destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code performs some validation. Specifically, it conducts checks
    to make sure that the uploaded file extension matches a list of allowable extensions,
    namely known image file types. If a valid image file was uploaded, it is moved
    from the `temp` folder via the `filesystem`''s `rename` function. Note how the
    `filesystem` (fs) `rename` function takes three parameters: the original file,
    the new file, and a `callback` function.'
  prefs: []
  type: TYPE_NORMAL
- en: The `callback` function is executed once the `rename` is complete. If the node
    doesn't work this way (always relying on `callback` functions), it's quite likely
    that your code will execute immediately following the execution of the `rename`
    function and try to work against a file that doesn't exist yet (that is, the `rename`
    function doesn't even finish doing its work). Using a `callback` function, we
    effectively tell the node that once the `rename` of the file is finished and the
    file is ready and placed where it should be, then it can execute the code in the
    `callback` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `else` condition that follow handles the situation when the uploaded file
    was invalid (that is, not an image), so we call the `unlink` function of the fs
    module, which will delete the original file (from the `temp` directory it was
    uploaded to) and then send a simple `JSON 500` with an error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the complete `saveImage` function (again, the following code will replace
    `// to do...` from earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With this new code in place, we can now successfully upload an image file via
    the form on the home page. Give it a try by launching the app and opening it in
    a browser. Once there, click on the Browse button in the main form, and select
    an `image` file from your computer. If successful, the `image` file should exist
    within the `public/upload` folder of your project with a new random filename.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you have the `public/upload` folders created in your project, or
    you will get runtime errors when you attempt to write files to a location that
    doesn't exist. The write permissions might need to be set on the folder, depending
    on your OS and security access.
  prefs: []
  type: TYPE_NORMAL
- en: After the upload form completes and the `create` controller function does its
    work, it will redirect you to the individual image page for the image that was
    uploaded.
  prefs: []
  type: TYPE_NORMAL
- en: Helpers for reusable code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, each of the pages that we have rendered display their `ViewModel` data
    perfectly, but that pesky sidebar still remains blank. We will fix this by creating
    a few modules for the sidebar content by implementing them as helper modules.
    These helper modules will be used repeatedly by various parts of our application
    and don't necessarily belong to the `controller` folder or the `server` folder.
    So, we'll just create a new home called `helpers` and store these modules there.
  prefs: []
  type: TYPE_NORMAL
- en: As we are just loading temporary fixture data into our `ViewModels`, the data
    we set up in the `helpers` and the `controllers` will all be replaced with actual
    live data once we implement MongoDB; we will do this in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The sidebar module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will create a module for the entire sidebar. This module will be responsible
    for calling multiple other modules to populate `ViewModel` for each section of
    the sidebar. As we will be populating each page's own `ViewModel` with data specifically
    for the sidebar, the sidebar module's function will accept that original `ViewModel`
    as a parameter. This is so that we can append data to the existing `ViewModel`
    for each page.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will be appending a sidebar property (which is a JavaScript object)
    that contains properties for each of the sections of the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, first create a file named `helpers/sidebar.js`, and insert
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you can see that you first required a module for each
    section of the sidebar. The existing `ViewModel` for any given page that displays
    the sidebar is the first parameter of the function. We added a sidebar property
    to `ViewModel` and set values for each property by calling the module for each
    section of the sidebar. Finally, we executed a `callback` that was passed in as
    the second parameter to the sidebar module. This `callback` is an anonymous function
    that we will use to execute the rendering of the HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: Let's update the home and image controllers to include a call to the sidebar
    module, as well as to defer rendering the HTML template for each page to the `callback`
    for the sidebar module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `controllers/home.js` and consider the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with this new block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the exact same changes to the `controllers/image.js` file, replacing `index`
    with `image`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, note how we executed the sidebar module and passed the existing `ViewModel`
    as the first parameter and a basic anonymous function as a `callback` for the
    second parameter. What we did was wait to render the HTML for the View until after
    the `sidebar` completed populating `ViewModel`. This is because of the asynchronous
    nature of Node.js. Suppose that we wrote the code in the following way instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, it''s quite likely that the `res.render` statement will execute before
    `sidebar` has even finished doing any work. This will become very important once
    we introduce MongoDB in the next chapter. Additionally, as we are now using the
    `sidebar` module in each controller, ensure that you `require` it at the top of
    both controllers by including the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that our `sidebar` module is complete, and it's being called from both controllers,
    let's complete the `sidebar` by creating each of the submodules that are required.
  prefs: []
  type: TYPE_NORMAL
- en: The stats module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The stats module will display a few random pieces of statistics about our app.
    Specifically, it will show the count for the total number of `images`, `comments`,
    `Views`, and `likes` for the entire website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `helpers/stats.js` file and insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This module is pretty basic, and all it does is create a standard JavaScript
    object with a few properties for the various stats, each set initially to 0.
  prefs: []
  type: TYPE_NORMAL
- en: The images module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `images` module is responsible for returning various collections of images.
    Initially, we will create a `popular` function that will be used to return a collection
    of the most popular images on the website. Initially, this collection will simply
    be an array of `image` objects with the sample fixture data present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `helpers/images.js` file, and insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The comments module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the image's `helper` module, the `comments` module will return a
    collection of the newest comments posted to the site. An idea of particular interest
    is that each comment also has an image attached to it, so that the actual image
    for each comment can be displayed as a thumbnail when displaying the list of comments
    (otherwise, we lose context when we see a random list of comments with no related
    image).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `helpers/comments.js` file, and insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Again, this is just a basic JavaScript array of objects with a few properties
    for each comment, one of which is an actual image and its properties (the `image`
    property should look familiar, since it's the same as one of the items in the
    image's `helper` module).
  prefs: []
  type: TYPE_NORMAL
- en: Testing the sidebar implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our `sidebar` module is completed along with its dependent submodules
    for the various `stats`, `images`, and `comments`, it's time to give our application
    another test run. Launch the node server, and open the application in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: You should now see the `sidebar`, complete with content, on both the home page
    and the image landing page.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating on the UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our application working fairly well and can actually interact
    with it, it's time to step back and take a look at some of the areas we might
    be able to improve.
  prefs: []
  type: TYPE_NORMAL
- en: One area is the Post Comment form on the image page. I don't think it's necessary
    that this form is always visible, but instead it should be made available only
    when someone actually wants to post a comment.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, I'd love the Like button to not have to post a full form submission
    to the server and cause the entire page to reload (just as the form on the home
    page does when it uploads an image). We will use jQuery to submit an AJAX call
    to the server to handle the likes and send and retrieve data in real time without
    ever reloading the page.
  prefs: []
  type: TYPE_NORMAL
- en: To make these tweaks, we will need to introduce a small amount of JavaScript
    on the page to add a little interactivity. To make things even easier, we'll use
    the popular jQuery JavaScript library to make creating interactive features a
    breeze.
  prefs: []
  type: TYPE_NORMAL
- en: The jQuery has been around for a number of years and has been explosively popular
    in frontend development. It allows you to manipulate the **Document Object Model**
    (**DOM**), that is, the HTML structure of any page, extremely easily, which you
    will see in the next section. You can learn more about jQuery at [http://jquery.com](http://jquery.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'You might not have noticed, but in the HTML code that was provided for the
    `main.Handlebars` layout file, jQuery was already included as an external `script`
    tag (referencing jQuery hosted on a CDN). Additionally, a local `scripts.js` tag
    is also included, where we will put our custom jQuery JavaScript code for the
    changes we will make to the UI. When you look at the very bottom of `main.Handlebars`,
    you can see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first script tag points to Google's code **Content Delivery Network** (**CDN**),
    which means that we don't have to worry about hosting that file with our code.
    The second file, however, is our own file, so we will need to make sure that exists.
  prefs: []
  type: TYPE_NORMAL
- en: CDN is a means of delivering a file from a globally distributed network of caching
    servers. What this means, generally speaking, is that files that are very commonly
    downloaded by web visitors (such as jQuery) can be loaded much quicker via a regionally
    closer download source as well as improved caching. If multiple websites use the
    same CDN URL to host jQuery, for example, it stands to reason that a visitor to
    your website might have already downloaded jQuery when visiting a previous unrelated
    website. Therefore, your website will load that much quicker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `public/js/scripts.js` file, and insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a standard code block that you''ll see almost every time anyone uses
    jQuery. What this code does is execute an anonymous function within the `$()`
    jQuery wrapper, which is shorthand for writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code basically means that the `callback` function will wait until
    the page is fully loaded and ready before executing. This is important because
    we don't want to apply UI event handlers and/or effects to DOM elements that don't
    actually exist yet because the page is still loading. This is also another reason
    why the script tags in the `main.Handlebars` layout file are the last lines of
    the page; it is so that they are the last to load, ensuring that the document
    has already been fully downloaded and is ready to be manipulated.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s address the `post-comment` functionality. We want to hide the
    comment form by default, and then display it only when a user clicks on the Post
    Comment button under an image (to the right of the Like button). Insert the following
    code inside the `callback` function where the `// to do...` comment exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The first line of code executes the `hide` function on the HTML div that has
    a `post-comment` ID. We then immediately apply an event handler to the HTML button
    with a `btn-comment` ID. The event handler we apply is for `onClick`, because
    we want it to execute the anonymous function we provided whenever a user clicks
    on that button. That function simply prevents the default behavior (the default
    behavior for that particular element; in this case, a button) and then calls the
    show jQuery function, which reveals the `post-comment` div that was previously
    hidden. The `event.preventDefault()` part is important because if we didn't include
    it, the action of clicking on the button would do what a browser expects it to
    do and try to execute our custom JavaScript function at the same time. If we didn't
    include this, it's likely that our UI would behave in ways that are less than
    ideal. A good example of this is that if you want to override the default behavior
    of a standard HTML link, you can assign an `onClick` event handler and do whatever
    you want. However, if you don't perform `event.preventDefault()`, the browser
    will send the user to the HREF for that link, regardless of what your code is
    trying to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add some code to handle the Like button functionality. We will
    add an event handler for the button, the same way we did for the Post Comment
    button, using jQuery''s `.on` function. After the code that you added previously,
    insert this additional block of code inside the `ready` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code attaches an `onClick` event handler to the `btn-like` button.
    The event handler first retrieves the `data(''id'')` attribute from the Like button
    (assigned via the `image.Handlebars` HTML template code and `ViewModel`) and then
    performs a jQuery AJAX post to the `/images/:image_id/like` route. Recall the
    following line from our Node `server/routes.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Once that AJAX call is done, another anonymous `callback` function will be executed
    that will change the text of the HTML element with a `likes-count` class and replace
    it with the data that was returned from the AJAX call--in this case, the updated
    total count of likes (typically, it would be whatever it was previously plus one).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to test this functionality, we will need to implement some fixture
    data in our `like` function inside the `image` controller. Edit `controllers/image.js`,
    and within the `like` function, replace the existing `res.send` function call
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: All this code does is return JSON to the client with a simple object that contains
    a single likes property with a value of `1`. In the next chapter, when we introduce
    MongoDB to the app, we'll update this code to actually increase the count of likes
    and return the true value for the liked image.
  prefs: []
  type: TYPE_NORMAL
- en: With all of those changes in place, you should be able to relaunch the node
    server and open the website in your browser. Click on any image on the home page
    to view the image page and then click on the Like button to see it change from
    `0` to `1`. Don't forget to check out the fancy new Post Comment button too; clicking
    on this should reveal the comment form.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we had some basic HTML pages that appeared
    in a browser via our application, but they contained no content and no logic whatsoever.
    We implemented the logic for each of our controllers and discussed the ViewModel
    and how to populate pages with content.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to displaying content on our pages via a ViewModel, we also implemented
    the code to handle uploading and saving image files to the local `filesystem`.
  prefs: []
  type: TYPE_NORMAL
- en: We tweaked the UI slightly to include some subtle enhancements using jQuery
    by revealing the comment form and used AJAX to track likes instead of relying
    on a full page postback.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the groundwork has been laid for our ViewModels and controllers, let's
    tie it all together using MongoDB and start working with real data. In the next
    chapter, we will update the controllers once again, this time implementing the
    logic to read from and save data to our MongoDB server.
  prefs: []
  type: TYPE_NORMAL
