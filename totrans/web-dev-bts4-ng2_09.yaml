- en: Chapter 9. Communication and Data Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about working with HTTP requests and storing data on the server.
    We will learn how to use the built-in HTTP library to work with endpoints. Also,
    we will learn how to use **Observables** to work with data. At the end of the
    chapter, we will learn how to work with Firebase as the persistence layer of the
    app. As usual, we will continue to build the project we started to develop in
    previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the chapter, you will have a solid understanding of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: HttpModule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Firebase tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to Firebase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Terminal, create the folder `ecommerce` , and move into the folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the contents of the project from the folder `chapter_9/1.ecommerce-seed`
    into the new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following script to install the npm modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the TypeScript watcher and lite server with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This script opens the web browser and navigates to the welcome page of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Client to server communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The web browsers and servers function as a **client-server system** . In general,
    the web server keeps the data and shares it with any number of web browsers on
    request. The web browsers and servers must have a common language, and they must
    follow rules so that both know what to expect. The language and rules of communication
    are defined in communications protocols. The **Transmission Control Protocol**
    ( **TCP** ) is a standard that defines how to establish and maintain a network
    conversation via which application programs can exchange data. TCP works with
    the **Internet Protocol** ( **IP** ), which defines how computers send packets
    of data to each other. Together, TCP and IP are the basic rules defining the Internet.
    The web browsers and servers communicate via **TCP/IP** stack. To send data over
    a TCP/IP network requires four steps or layers:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Application layer** encodes the data being sent. It does not care about
    how the data gets between two points, and it knows very little about the status
    of the network. Applications pass data to the next layer in the TCP/IP stack and
    then continue to perform other functions until a reply is received.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Transport layer** splits the data into manageable chunks, and adds port
    number information. The Transport Layer uses port numbers for addressing, which
    range from 1 to 65,535\. Port numbers from 0 to 1,023 are called **well-known
    ports** . The numbers below 256 are reserved for public services that run on the
    Application layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Internet layer** adds IP addresses stating where the data is from and
    where it is going. It's the *glue* that holds networking together. It permits
    the sending, receiving, and routing of data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Link layer** adds **Media Access Control** ( **MAC** ) address information
    to specify which hardware device the message came from, and which hardware device
    the message is going to. The MAC address is fixed at the time the interface was
    manufactured and cannot be changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All client-server protocols operate in the Application layer. Application-layer
    protocol states the basic communication patterns. For the data exchange format
    to be formalized, the server implements an **Application Program Interface** (
    **API** ), such as a web service. The API is an abstraction layer for resources
    like databases and custom software. The **Hypertext Transfer Protocol** ( **HTTP**
    ) is the Application-layer protocol that implements the **World Wide Web** ( **WWW**
    ). While the web itself has many different facets, the primary purpose of HTTP
    is to transfer hypertext documents and other files from web servers to web clients.
  prefs: []
  type: TYPE_NORMAL
- en: Web API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The interaction between web clients and servers' assets happens via the defined
    interface called the  **Web API** . It is a server architectural approach providing
    programmable interfaces to a set of services serving different types of consumers.
    The Web API is typically defined as a set of HTTP request and response messages.
    In general, the structure of the reply message is represented in an **Extensible
    Markup Language** ( **XML** ) or **JavaScript Object Notation** ( **JSON** ) format.
  prefs: []
  type: TYPE_NORMAL
- en: In the epoch of Web 1.0, the Web API was synonymous for **Simple Object Access **
    **Protocol** ( **SOAP** ) based web services and **Service-Oriented Architecture**
    ( **SOA** ). In Web 2.0, this term is moving towards  **Representational State
    Transfer** ( **REST** ) style web resources and **Resource-Oriented Architecture**
    ( **ROA** ).
  prefs: []
  type: TYPE_NORMAL
- en: REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**REST** is an architectural style of the World Wide Web and is used for design
    networked applications. There is not a standard or W3C recommendation for REST.
    The term REST was introduced and defined in 2000 by *Roy Fielding* in his doctoral
    dissertation. Later, he used REST to design HTTP 1.1 and **Uniform Resource Identifiers**
    ( **URIs** ).'
  prefs: []
  type: TYPE_NORMAL
- en: 'REST as a programming approach is:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Platform-independent* so that the server can be installed on Linux, Windows,
    and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Language-independent* , so we can use C#, Java, JavaScript, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standards-based and can run on top of HTTP standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'REST uses simple HTTP protocol to make calls between clients and servers rather
    than using a complicated mechanism such as a **Remote Procedure Call** ( **RPC**
    ), **Common Object Request Broker Architecture** ( **CORBA** ), or **SOAP** .
    Any application calls RESTful makes conforms to the constraints of REST:'
  prefs: []
  type: TYPE_NORMAL
- en: The **client-server constraint** means that the client and server are separated
    so that they may be replaced and developed independently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client and server communication is based on **stateless constraint** , so
    there is no client context stored on the server between requests and each request
    contains all the information necessary to service the request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **cacheable constraint** defines whether the server responses must implicitly
    or explicitly mark themselves as cacheable, or not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To comply with **layer systems constraints** , the client and server use the
    layered architecture to improve the overall system capability and scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server can follow the **code on demand optional constraints** to customize
    the functionality of the client by the transfer of executable code such as JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RESTful applications use HTTP requests for all four **CRUD** ( **Create, Read,
    Update,** and **Delete** ) operations. REST doesn't include security, encryption,
    session management, and so on but we can build them on the top of HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at a typical endpoint we used to read the product: `http://localhost:9000/product/123`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'There is just a URL sent to the server using a simple HTTP GET request. The
    `product` here is the resource in the URL. There is a standard convention in REST
    design to use nouns to identify resources. REST can handle more complex requests,
    like: `http://localhost:3000/products?category=1` .'
  prefs: []
  type: TYPE_NORMAL
- en: If necessary, we can utilize the HTTP `POST` method to send long parameters
    or binaries inside the POST body.
  prefs: []
  type: TYPE_NORMAL
- en: REST response formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For most of the time, the server responds with XML, **Comma-Separated Values**
    ( **CSV** ), or JSON formats in REST. The choice depends on the format''s advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: XML is easily expandable and type safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSV is very compact
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON is easy to parse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST and AJAX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use the  **Asynchronous JavaScript and XML** ( **AJAX** ) client-side technique
    to create asynchronous web applications. AJAX uses `XMLHttpRequest` objects to
    send requests to the server to dynamically change the web page. The AJAX and REST
    requests are similar.
  prefs: []
  type: TYPE_NORMAL
- en: REST API design guidelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What is the next step we need to take to create the proper REST API? That question
    has no simple answer, and since there''s no one widely adopted standard that works
    in all cases I recommend we get the answer from well-known sources such as Microsoft
    REST API Guidelines, available at: [https://github.com/Microsoft/api-guidelines](https://github.com/Microsoft/api-guidelines)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HttpModule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have developed only the frontend of our application and it is therefore
    pretty useless. We need somewhere to store our products and categories so that
    we can fetch them later on. To do this, we're going to connect to a server, which
    is going to house a RESTful API that serves up JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Out of the box, Angular 2 includes `HttpModule` to organize some low-level methods
    of fetching and posting our data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the new `HttpModule` in our project, we have to import it as a separate
    add-on module called `@angular/http` , shipped in a separate script file as part
    of the Angular npm package. We import the `@angular/http` in the `systemjs.config.js`
    file configured `SystemJS` to load that library when we need it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our application will access `HttpModule` services from anywhere in the application,
    so we should register them by adding the `HttModule` to the list of `imports`
    of the `AppModule` . After the bootstrap, all the `HttpModule` services become
    available to the root level of `AppComponent` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The in-memory Web API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because we don''t have a real web server that can handle our requests, we will
    use a mock service to mimic the behavior of the real one. That approach has the
    following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It rapidly stubs out API designs and new endpoints. **Service mocking** gives
    you the ability to use **Test Driven Development** ( **TDD** ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It shares APIs between team members. We won't have downtime whilst the frontend
    team waits for the other team to finish. This approach makes the financial argument
    for mocking unusually high.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It takes control of simulated responses and performance conditions. We can use
    mocks to create a proof of concept, as a wireframe, or as a demo, so they can
    be very cost efficient to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It has disadvantages that we should know about:'
  prefs: []
  type: TYPE_NORMAL
- en: We have to do double the work and sometimes this can mean quite a lot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has deployment constraints if you need to deploy it somewhere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mocking code is subject to bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mock is only a representation of what it is mocking, and it can misrepresent
    the real service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The in-memory Web API is an optional service in the `angular-in-memory-web-api`
    library. It''s not part of Angular 2, so we need to install it as a separate npm
    package and register for module loading by `SystemJS` inside the `systemjs.config.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create an `InMemoryDataService` class which implements `InMemoryDbService`
    , to create an in-memory database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `createDb` method should create a *database* object hash whose keys are
    collection names and whose values are arrays of the group objects. It is safe
    to call it again because it returns new arrays with new objects. That allows `InMemoryBackendService`
    to morph the arrays and objects without touching the source data. I moved the
    datasets from `ProductService` and `CategoryService` in this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Analogous with the `HttModule` , we are importing the `InMemoryWebApiModule`
    and `InMemoryDataService` into the list of `imports` of the `AppModule` . They
    replace the default `Http` client backend within in-memory Web API alternative
    services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The method `forRoot` prepares the in-memory Web API in the root application
    module to create an in-memory database in the moment of bootstrapping. It has
    a second parameter of `InMemoryBackendConfigArgs` type and keeps `InMemoryBackend`
    configuration options such as delay (in milliseconds) to simulate latency, host
    for this service, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Now everything is ready to change both `ProductService` and `CategoryService`
    to start them using an `HTTP` service.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Angular **HTTP client** communicates with a server via AJAX requests using
    an HTTP protocol. Components of our project will never talk directly to HTTP client
    services. We delegate data access to service classes. Let''s update the imports
    in `ProductService` as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, fetch the products with the `Http` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, we are using a standard HTTP GET request to fetch the set of products.
    The `InMemoryWebApiModule` quite cleverly understands the query parameters in
    the requested URL. Here, the `ProductGridComponent` utilizes the `ProductService`
    to display our grid of products on the web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `products` property here is just an array of products. We use a simple
    `NgFor` directive to iterate through them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The source code changes in `CategoryService` a bit differently because of the
    nature of the categories data. The set of categories is static, so we don''t need
    to fetch them every time and can keep them in the cache inside `CategoryService`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the `getCategory` method, we can easily find the category by ID because we
    simply fetch it from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP Promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carefully look at how we return the data from an HTTP GET request. We use the
    `toPromise` method just after the `get` method of the `Http` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: So, why do we need this method and what exactly does it do?
  prefs: []
  type: TYPE_NORMAL
- en: 'Almost all the `Http` service methods return a RxJS `Observable` . Observables
    are a powerful way to manage asynchronous data flows. To convert a RxJS `Observable`
    into a `Promise` , we use the `toPromise` operator. It just fetches a single chunk
    of data and returns it immediately. Before using the `toPromise` operator, we
    need to import it from RxJS implicitly because the library is quite extensive
    and we should include only those features that we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Let's talk about `Observable`  and why `Http` uses them everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code for this at `chapter_9/2.ecommerce-promise` .
  prefs: []
  type: TYPE_NORMAL
- en: RxJS library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **RxJS** is a project actively developing by Microsoft in collaboration
    with many open source developers. There is a set of libraries organized as an
    API for asynchronous and event-based programming. We use Observables to represent
    the asynchronous data streams. There are many operators to query and Schedulers
    to parameterize the concurrency in them. In short--the RxJS is a combination of
    Observer and Iterator patterns and functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before use we can import all core modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Better import only necessary functionality if you care about the size of your
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The RxJs is huge, and I suggest to refer to the official website to learn more:
    [http://reactivex.io](http://reactivex.io)'
  prefs: []
  type: TYPE_NORMAL
- en: Observables versus promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our days the **Observables** are a proposed feature for JavaScript version
    ES2016 (ES7), so we use the RxJS as the polyfill library to bring them into the
    project until the next new version of JavaScript is released. Angular 2 has basic
    support for Observables and we use RxJS to extend this functionality. Promises
    and Observables bring the abstractions that help us deal with the asynchronous
    nature of our applications with several key differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Observables emit multiple values over time, in contrast to Promises which can
    return only one value or error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observables are treated like arrays and allow us to use operators, collection-like
    methods to manipulate values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observables can be cancelled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observables can be retried with one of the retry operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So we use `toPromise` specially to convert the stream of data from a request
    into a single value. Do we really need that? I''ve made some changes in the project
    to show you how easy it is to use Observables in Angular 2 applications. Just
    have a look at the modified version of `ProductService` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We use several transformation operators from the RxJS package in the preceding
    code, so don''t forget to import them from the package. There are many operators
    in RxJS helping us to organize different sorts of transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: The `map` operator transforms the items by applying a function to each of them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `flatMap` , `concatMap` , and `flatMapIterable` operators transform the
    items into Observables or Iterables and flatten them into one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `switchMap` operator transforms the items into Observables. The items emitted
    from the most-recently transformed Observable will be mirrored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `scan` operator sequentially applies a function to each emitted item to
    emit only successive values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `groupBy` operator helps divide and organize Observables by key to emit
    the groups of items from the original one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `buffer` operator combines emitted items into bundles. It emits bundles
    instead of emitting one item at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **cast** casts all items from the source Observable into a particular type
    before reemitting them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RxJS is really big and I recommend starting to learn more about it from the
    official website: [https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'When successful a request returns an instance of the `Response` class. The
    response data is in JSON string format, so we must parse that string into JavaScript
    objects which we do by calling the `json` method of the `Response` class. As usual,
    we should deal with errors because we have to be prepared for something to go
    wrong, as it surely will. We catch errors by calling the `handleError` method
    of our class. Bear in mind, we must transform the error into a user-friendly message,
    and return it in a new, failed observable via `Observable.throw` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two different techniques to display Observable data on the web page.
    The first approach is organizing a subscription of Observable data as implemented
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We subscribed to all changes that happen in `ProductService` and immediately
    assign them to the `product` property, so Angular delivers them into the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach is to forward the Observable result to the template as implemented
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We then forward the Observable result to the template via the `product`  property
    where the `async` pipe in the `NgFor` handles the subscription:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, we may need to start one request, then cancel it and make a different
    request before the server has responded to the first one. It is complicated to
    implement such a sequence with Promises, so let's have a look how Observables
    can help us.
  prefs: []
  type: TYPE_NORMAL
- en: Observables in search-by-title
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have a feature to search products by title. The user types the title and
    then presses the **Go** button to request data from the server. We can improve
    the user experience here, so that when the user types a title into the search
    box, we will make repeated HTTP requests for products filtered by title. Look
    at the updated markup of `ProductSearchComponent` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We removed the **Go** button. An input element gathers the search title from
    the user and calls the `searchProduct` method after each `keyup` event. The `searchProduct`
    method updates the query parameters of the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ProductGridComponent` listens to the stream of query parameters change
    in the `route` and manipulates the stream before it reaches the `productService`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we wait for the user to stop typing for at least 300
    milliseconds with the `debounceTime` operator. Only changed search values make
    it through to the service via the `distinctUntilChanged` operator. Later, we fetch
    category and search query parameters and request products from `productService`
    .
  prefs: []
  type: TYPE_NORMAL
- en: We can quickly start the server and open our web application in the browser
    to check that all works as expected. From that point, we can demonstrate our project
    to colleagues or stakeholders as a proof of concept that we will use in future
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need a real database and hosting server to finish development and test
    everything in the real environment. Let's use Firebase to store and sync our data
    in real time and deliver web content faster.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code for this at `chapter_9/3.ecommerce-promise` .
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Firebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Firebase** is a *Realtime NoSQL JSON Database* . Any piece of data is accessible
    by URL. Firebase contains SDK for different platforms, such as JavaScript for
    the Web, IOS, Android, and so on. It includes authentication baked inside core
    libraries, so we can quickly authenticate users directly from clients via OAuth
    provided by GitHub, Google, Twitter, and Facebook. It also supports anonymous
    and password authentication. Firebase provides a hosting service for static assets
    through the Firebase Console or CLI. Firebase uses web sockets to update data
    on all connected clients in real time.'
  prefs: []
  type: TYPE_NORMAL
- en: If you've never used Firebase before you need to register an account first.
    Open your web browser and navigate to[https://firebase.google.com/](https://firebase.google.com/)
    . Click on **SIGN IN** and use your Google account to set up your Firebase account.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Firebase project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are planning to use the Firebase SDK library to access and store data. However,
    before that, we need to add Firebase to our web application. We''ll need a Firebase
    project, the Firebase SDK, and a short snippet of initialization code that has
    a few details about our project. Click **Go to console** or open the **Firebase
    Console** from the following address: [https://firebase.google.com/console](https://firebase.google.com/console)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Create New Project** button and add a project name and your
    country of origin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Firebase project](Image00135.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In less than a minute, we will have access to the Firebase relative database,
    authentication, storage, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Firebase CLI tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the Firebase CLI tools to manage, view, and deploy our project
    to Firebase from a Terminal. Let''s open the Terminal, navigate to our project,
    and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After installation, we will have a globally available Firebase command. Now,
    we can sign into Firebase from the Terminal. Remember you must already have set
    up a Google account to proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This command establishes connection to your remote Firebase account and grants
    access to our projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing Firebase CLI tools](Image00136.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you interested in knowing what commands the Firebase CLI supports, please
    go to the official website: [https://firebase.google.com/docs/cli/](https://firebase.google.com/docs/cli/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a project directory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the Firebase CLI to perform many trivial tasks, such as running
    the local server or for deployment. Before using it, we need to initialize a project
    directory for the folder which will contain the `firebase.json` file. Usually
    we use the root folder of the Angular project as the Firebase project directory.
    Open the Terminal, navigate to the root folder of our project and execute the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This command will guide you through setting up the project directory. If necessary,
    you can run this command again safely.
  prefs: []
  type: TYPE_NORMAL
- en: '![Initializing a project directory](Image00137.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Please answer `Yes` to the question: `Configure as a single-page app (rewrite
    all URLs to /index.html)?` The Firebase CLI creates the `rewrites` settings inside
    the `firebase.json` file. We use a rewrite because we want to show the same content
    for multiple URLs. This is applicable for our application because we configured
    the Angular Component Router using the default HTML 5 `pushState` strategy. It
    produces URLs that are easier for users to understand and it preserves the option
    to do server-side rendering later.'
  prefs: []
  type: TYPE_NORMAL
- en: Importing data into Firebase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before use, we need to import our data into the Firebase database. Open the
    Firebase console, find your project and click to move it in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing data into Firebase](Image00138.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Find the **Database** menu item on the sidebar and click it. That brings the
    Firebase Realtime Database instance onto the stage. Click the context menu button
    on the right side and, from the drop-down menu, choose **Import JSON** . I prepared
    the `firebase.import.json` file for import, so just select it from the root folder
    of our project and click on **Import** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing data into Firebase](Image00139.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Firebase Realtime Database stores the data as JSON objects. It looks like
    a cloud-hosted JSON tree. In contradistinction to an SQL database, there are no
    tables or records. Each data incorporated to the JSON tree becomes a node in the
    existing JSON structure with an associated key. We can provide our own keys, such
    as `category` or `product` IDs, or Firebase can provide them for us in a moment
    when we save data with a POST request.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The keys must be UTF-8 encoded and cannot be longer than 768 bytes. They can''t
    contain ., $, #, [,], /, or ASCII control characters such as 0-31 or 127.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The data structure of the Dream Bean website is quite simple and contains only
    two entities with a product to category relationship. The Firebase Realtime Database
    supports nesting data up to 32 levels deep, and the first temptation is to add
    `category` into `product` , but be careful doing that because, when you retrieve
    data later, Firebase will return the product and all of its child nodes as well.
    Plus, we will have trouble when we try to grant someone read or write access to
    nodes. The best solution here is denormalize our data to keep the structure as
    flat as possible. We can follow these recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: Split data into separate paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an index or key to your data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an index or key to fetch relational data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the beginning stage, we deliberately added `categoryId` into the product
    entity to quickly and efficiently fetch data by index:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing data into Firebase](Image00140.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Firebase database rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firebase always creates default rules for each new database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Firebase database rules](Image00141.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The rules of the Firebase Realtime Database are quite flexible and expression
    based. We can use JavaScript-like language to define:'
  prefs: []
  type: TYPE_NORMAL
- en: The structure of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure data with the Firebase Authentication service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By default, the database rules require Firebase authentication and grant full
    read and write permissions only to authenticated users, so it isn''t accessible
    to everyone. We will change the rules to organize read access to everyone but
    keep write access to authenticated users. Rules can be configured in two different
    ways. The easiest way to create an immediate effect is to use the Firebase console,
    so let''s open it, select the **Database** menu from the side bar and choose the
    **Rules**  tab. You should see the text area with the current rules. You can manually
    change them or copy the following rules and paste them into the text area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Click **Publish** to apply the new rules on the database. Another way to manage
    database rules is to create a special JSON file, so the Firebase CLI will use
    this file when we deploy our project into Firebase. Open the Terminal, navigate
    into our project and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, choose the **Database: Deploy Firebase Realtime Database Rules** option.
    Leave the default answer to all the questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Firebase database rules](Image00142.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the `database.rules.json` and update it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, once the data's been imported into the database, its time to connect our
    project to it.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to Firebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To organize communication, we need the **AngularFire2** library to integrate
    Firebase Realtime observers and authentication with Angular2.
  prefs: []
  type: TYPE_NORMAL
- en: Installing AngularFire2 and Firebase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, install the AngularFire2 and Firebase SDK libraries as npm modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to install Typescript 2 locally because AngularFire2 depends
    on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, update the `systemjs.config.js` file with those two libraries because
    they need to be mapped with `SystemJS` for module loading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The AngularFire2 and Firebase setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to set up the AngularFire2 module and Firebase configuration before
    use. Open the `app.module.ts` file and import the `AngularFireModule` . Now open
    the web browser, navigate to the Firebase console, and select your project (if
    it was not already open). Next, click on the  **Add Firebase to your app** link:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The AngularFire2 and Firebase setup](Image00143.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Firebase creates the initialization code snippet, which we will use in our
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The AngularFire2 and Firebase setup](Image00144.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the initialization configuration and copy to the clipboard. Switch back
    to our project and paste it so our code will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We are ready to use Firebase in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting categories from Firebase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'AngularFire2 syncs data as lists with the help of `FirebaseListObservable`
    , so open the `category.service.ts` file and import it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We inject the `AngularFire` service into the constructor. It creates the `FirebaseListObservable`
    through the `AngularFire.database` service, as we call it in the `getCategories`
    method with the relative URL.
  prefs: []
  type: TYPE_NORMAL
- en: Getting products from Firebase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s a different story for fetching data for the products. It is not enough
    to have only one URL, we need to use query parameters. The list method of the
    `AngularFire.database` service has a second parameter object that we can use to
    specify the query parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We use Firebase Realtime Database queries to retrieve data based on various
    factors selectively. To construct a query for `products` , we start by specifying
    how we want the data to be ordered using one of the ordering functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The `orderByChild` retrieves ordered nodes by a child key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `orderByKey` retrieves ordered nodes by their keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `orderByValue` retrieves ordered nodes by the value of their children
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `orderByPriority` retrieves ordered nodes by priority value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The result of the `orderByChild` function for a specified child key will be
    ordered as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Children with a null value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Children with a false Boolean value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Children with a true Boolean value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Children with a numeric value sorted in ascending order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Children with a string sorted lexicographically in ascending order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Children with objects sorted lexicographically by key name in ascending order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Firebase database keys can only be strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the `orderByKey` function will be returned in ascending order
    by key name as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Children with a key that can be parsed as a 32-bit integer come first and are
    sorted in ascending order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Children with a string value key come next and are sorted in ascending order
    lexicographically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result of the `orderByValue` function will be ordered by its value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Firebase database priority values can only be numbers and strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the `orderByPriority` function will be the ordering of children,
    and is determined by their priority and key as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Children with no priorities are sorted by key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Children with a number are sorted numerically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Children with a string are sorted lexicographically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Children who have the same priority are sorted by key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After we''ve decided how the retrieved data should be ordered, we can use the
    limit or range methods to conduct complex queries:'
  prefs: []
  type: TYPE_NORMAL
- en: The `limitToFirst` creates a query limited to the first set number of children
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `limitToLast` creates a query limited to the last set number of children
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `startAt` creates a query with a particular starting point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `endAt` creates a query with a specific ending point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `equalTo` creates a query with a particular matching value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `limitToFirst` and `limitToLast` queries to set a maximum number
    of children the Firebase will return. Using `startAt` and `endAt` queries helps
    us to choose the arbitrary starting and ending points in the JSON tree. The `equalTo`
    query filters data based on **exact matching** .
  prefs: []
  type: TYPE_NORMAL
- en: 'When we select the category we create a query based on a combination, `orderByChild`
    and `equalTo` , because we know the exact value of `categoryId` to filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user searches by inputting the title, we use a combination of `orderByChild`
    , `startAt` , and `endAt` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `\uf8ff` character used in the preceding query helps us create a trick.
    It's a very high value in the Unicode range, and because it's after most regular
    characters in Unicode, the query matches all values that start with the user's
    input value.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the application to Firebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our application has only static content, and that means that we can deploy
    it to Firebase Hosting. We can do this with a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The Firebase CLI deploys our web application to the domain: `https://<your-firebase-app>.firebaseapp.com`
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can manage and rollback deployments from the Firebase console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying the application to Firebase](Image00145.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code for this chapter at `chapter_9/4.ecommerce-firebase`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discovered what data persistence is, and how important it
    is in client to server communications. We started with a brief tour of the Web
    APIs before diving deeper into REST to provide a reminder of the main principles
    of both.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at Angular 2's departure from the `HttpModule` and we discussed how
    to use it to organize client to server communications. As a bonus, we learnt that
    we can use the in-memory web API to create proofs of concept, wireframes, or demos.
  prefs: []
  type: TYPE_NORMAL
- en: Observables are a proposed feature for JavaScript version ES2016 (ES7), and
    we talked about the RxJS polyfill library used in Angular 2 with Observables to
    help us deal with the asynchronous nature of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Firebase is a real-time no-SQL JSON database which keeps any piece of data accessible
    by URL. Firebase contains SDK for different platforms, such JavaScript for the
    Web, IOS, and Android. We demonstrated how to use it as a persistence layer of
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](text00099.html#page "Chapter 10. Advanced Angular Techniques")
    , *Advanced Angular Techniques* , we will secure our data with the help of the
    Firebase platform. We will learn how to install `ng2-bootstrap` and how this will
    enable us to create directives in an easier way. Finally, we will end by building
    the project we started to develop in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
