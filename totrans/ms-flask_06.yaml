- en: Chapter 6. Securing Your App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a mostly functioning blog app, but it is missing some crucial features,
    such as user login, registration, and adding and editing posts from the browser.
    The user login functionality can be created in many different ways, so each of
    the sections demonstrates mutually exclusive methods to create logins. The first
    way is directly using the browser's cookies, and the second way is using a Flask
    extension named **Flask Login**.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we jump right into making a user authentication system, there is a lot
    of setup code. To run any type of authentication, our app will need the following
    elements common to all:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the user models will need proper password hashing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, a login form and a registration form will be needed to validate user
    input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third, a login view and a registration view with templates for each will be
    needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fourth, various social logins need to be set up in order to tie them into the
    login system when it is implemented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until now, our users had their passwords stored as a plain text in the database.
    This is a major security flaw. If any malicious user were to gain access to the
    data in the database, they could log in to any account. The fallout of such a
    breach would be greater than our site. Large amounts of people on the Internet
    use a common password for many sites.
  prefs: []
  type: TYPE_NORMAL
- en: If an attacker had access to an e-mail and password combination, it is very
    likely that this information could be used to log in to a Facebook account or
    even a bank account.
  prefs: []
  type: TYPE_NORMAL
- en: To protect our user passwords, they will be encrypted with a one-way encryption
    method named a **hashing algorithm**. A one-way encryption means that after information
    is encrypted, the original information cannot be regained from the result. However,
    given the same data, the hashing algorithm will always produce the same result.
    The data given to the hashing algorithm can be anything from a text file to a
    movie file. In this case, the data is just a string of characters. With this functionality,
    our passwords can be stored as **hashes** (data that has been hashed). Then, when
    a user enters their password in the login or registration page, the text entered
    for the password will be sent through the same hashing algorithm, and the stored
    hash and the entered hash will be verified.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many hashing algorithms, most of which are not secure because they
    are easy to **brute force**. Hackers continuously try sending data through a hashing
    algorithm until something matches. To best protect the user passwords, bcrypt
    will be our hashing algorithm of choice. **Bcrypt** is purposely designed to be
    inefficient and slow (milliseconds vs. microseconds) for the computer to process,
    thereby making it harder to brute force. To add bcrypt to our project, the package
    **Flask Bcrypt** will need to be installed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the second Flask extension that will be initialized on the `app` object,
    the other being the SQLAlchemy object. The `db` object was stored in the `models.py`
    file, but there is no obvious place to initialize Flask Bcrypt. To hold all future
    extensions, add the file named `extensions.py` in the same directory as the `__init__.py`
    file. Inside, Flask Bcrypt will have to be initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It is then added to the `app` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Bcrypt is now ready to use. To have our `User` object use bcrypt, we will add
    two methods that set the password and check if a string matches the stored hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, our `User` models can store passwords securely. Next, our login process
    needs to use these methods to create new users and check passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Three forms are required: a login form, a registration form, and a form for
    our **post creation** page. The login form will have username and password fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Along with the normal validations, our `LoginForm` method will also check whether
    the username passed exists and will use the `check_password()` method to check
    the hashes.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting your form from spam with reCAPTCHA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The registration form will have a username field, a password field with a confirmation
    field, and a special field named a reCAPTCHA field. A CAPTCHA is a special field
    on a web form that checks whether whoever is entering data into the form is actually
    a person, or an automated program that is spamming your site. reCAPTCHA is simply
    one implementation of a CAPTCHA. reCAPTCHA has been integrated into WTForms as
    it is the most popular implementation on the Web.
  prefs: []
  type: TYPE_NORMAL
- en: To use reCAPTCHA, you will need a reCAPTCHA login from [https://www.google.com/recaptcha/intro/index.html](https://www.google.com/recaptcha/intro/index.html).
    As reCAPTCHA is a Google product, you can log in with your Google account.
  prefs: []
  type: TYPE_NORMAL
- en: Once you log in, it will ask you to add a site. In this case, any name will
    do, but the domain field must have `localhost` as an entry. Once you deploy your
    site, your domain must also be added to this list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have added a site, dropdowns with instructions on server and client
    integration will appear. The given `script` tag will need to be added to the templates
    of our login and registration views when we create them. What WTForms needs from
    this page are the keys, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Protecting your form from spam with reCAPTCHA](img/B03929_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Remember to never show these keys to public. As these keys are only registered
    to `localhost`, they can be shown here without recourse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these keys to the `config` object in the `config.py` file so that WTForms
    can access them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is our registration form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The post creation form will just contain a text input for the title and a text
    area input for the post content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Creating views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous chapter, the index view containing the redirect to the blog
    home was stored in the `create_app` function. That was alright for one view. Now,
    this section is going to add many views on the base URL of the site. As such,
    we need a new controller in `controllers/main.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The login and registration views will create our form objects and pass them
    to the templates. For now, the login form will not do anything if the data passed
    validates. The actual login functionality will be added in the next section. However,
    the registration view will create a new user if the data passes validation. Along
    with the login and registration views, there needs to be a logout view, which
    will do nothing for now as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main.py` controller, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `login.html` and `register.html` templates used in the preceding code (placed
    in the `templates/main` folder) can be made with the `form` macro created in [Chapter
    3](ch03.html "Chapter 3. Creating Views with Templates"), *Creating Views with
    Templates*, but the `script` tag from reCAPTCHA cannot be added to `register.html`
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, there needs to be a way for our child templates to add new JavaScript
    files to the `base.html` template. There also needs to be a way for our views
    to flash messages to the user with the Flask `flash` function. A new content block
    has to be added to the `base.html` file along with a loop over the messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Your login page should now resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating views](img/B03929_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your registration page should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating views](img/B03929_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we need to create the post creation and editing page so something can be
    secured. The two pages will need to transform the text area field into a **WYSIWYG**
    (short for **What You See Is What You Get**) editor to handle wrapping the post
    text in HTML. In the `blog.py` controller, add the following views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This functionality is much like the code used to add new comments. The data
    of the text field is set in the view because there is no easy way to set the contents
    of `TextAreaField` inside a template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `new.html` template will need a JavaScript file for the WYSIWYG editor.
    **CKEditor** is very simple to install and use. Now, our `new.html` file can be
    created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is all that is needed to have the user''s input stored as HTML in the
    database. Because we passed the safe filter in our post template, the HTML code
    appears correctly on our post pages. The `edit.html` template is similar to the
    `new.html` template. The only difference is the `form` opening tag and the creation
    of the `title` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `post.html` template will need a button for authors to link them to the
    edit page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When we are able to detect the current user, the edit button will only be shown
    to the user who created the post.
  prefs: []
  type: TYPE_NORMAL
- en: Social logins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integrating alternative login and registration options into your site becomes
    more important as time goes on. Every month, there is another announcement that
    passwords have been stolen from a popular website. Implementing the following
    login options means that our site's database never stores a password for that
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Verification is handled by a large brand name company, which the user already
    places their trust in. By using social logins, the amount of trust a user has
    to place in the website they are using is much lower. Your login process also
    becomes much shorter for the user, decreasing the barrier to entry to your app.
  prefs: []
  type: TYPE_NORMAL
- en: Socially authenticated users act as normal users, and unlike the password-based
    login methods, they all can be used in tandem.
  prefs: []
  type: TYPE_NORMAL
- en: OpenID
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**OpenID** is an open protocol that allows users on one site to be authenticated
    by any third-party site that implements the protocol, which are called **Relaying
    Parties** (**RPs**). An OpenID login is represented as a URL from one of the RPs,
    typically the profile page of the website.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To know a full list of sites that use OpenID and how to use each, go to [http://openid.net/get-an-openid/](http://openid.net/get-an-openid/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To add OpenID to Flask, a Flask extension named **Flask-OpenID** will be needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Our app will need a couple of things to implement OpenID:'
  prefs: []
  type: TYPE_NORMAL
- en: A new form object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The form validation on the login and registration pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A callback after the form submission to log the user in or create a new user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `extensions.py` file, the OpenID object can be initialized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `__init__.py` file, the `oid` object is registered to the `app` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `form` object will only need the URL of the RP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'On the login and registration views, `OpenIDForm()` will be initialized, and
    if the data is valid, a login request will be sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Both the views have the new decorator `@oid.loginhandler`, which tells Flask-OpenID
    to listen for authentication information coming back from the RP. With OpenID,
    logging in and registering are the same. It is possible to create a user from
    the login form and to log in from the registration form. The same field appears
    on both pages to avoid user confusion.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle the user creation and login, a new function in the `extensions.py`
    file is needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This function is called after every successful response from the RP. If the
    login is successful and a user object does not exist for the identity, this function
    creates a new `User` object. If one already exists, the upcoming authentication
    methods will log the user in. OpenID does not require all possible information
    to be returned, so it is possible that rather than a full name, only an e-mail
    will be returned. This is why the username can be the nickname, full name, or
    e-mail. The `db` and `User` object are imported inside the function to avoid cyclical
    imports from the `models.py` file importing the `bcrypt` object.
  prefs: []
  type: TYPE_NORMAL
- en: Facebook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To log in with Facebook, and later Twitter, a protocol named **OAuth** is used.
    Our app will not use OAuth directly, instead another Flask extension will be used
    named **Flask OAuth**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To use Facebook login, our app needs to define a Facebook OAuth object with
    our app's keys. Define a view that redirects the user to the login authorization
    process on Facebook's server, and a function on the Facebook method to load the
    `auth` token from the login process.
  prefs: []
  type: TYPE_NORMAL
- en: First, a Facebook app needs to be created at [http://developers.facebook.com](http://developers.facebook.com).
    Once you create a new app, look for the panel that lists your app's id and secret
    key.
  prefs: []
  type: TYPE_NORMAL
- en: '![Facebook](img/B03929_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Use these values while adding the following code to `extensions.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Facebook developer interface, be sure to add a new authorized website
    as `http://localhost:5000/` or the login will not work. In the `main.py` controller,
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The first route, `facebook_login`, is just a redirect to the login process
    on Facebook''s website. The `facebook_authorized` view receives the response from
    Facebook''s servers and, just like the OpenID process, either creates a new user
    or logs the user in. Now to start the process, add the following link to the registration
    and login templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Twitter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Twitter login process is very similar. To create a Twitter app and receive
    your keys, go to [https://apps.twitter.com/](https://apps.twitter.com/). In `extensions.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main.py` controller, add the following views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'These views perform the same function as their Facebook counterparts. Finally,
    in the register and login templates, add the following link to start the login
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Using the session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One way to create authentication in Flask is to use the `session` object. The
    `session` object is an object in Flask that creates an easy way for the server
    to store information in the user's browser with cookies. The stored data is cryptographically
    signed with the app's secret key. If the user attempts to modify the cookie, then
    the sign will no longer be valid and the cookie will not be read.
  prefs: []
  type: TYPE_NORMAL
- en: 'The session object has the same API as a `dict` object. To add data to it,
    simply use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To retrieve data, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To log a user in, a username key will be added to the session and set to the
    username of the current user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To log the user out, the key can be popped from the session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether a user is currently logged in, the view can test if the username
    key exists in the session. Consider the following new post view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Some of our templates will need access to the current user object. At the start
    of every request, our `blog` blueprint can check whether the username is in the
    session. If so, add the `User` object to the `g` object, which is accessible through
    the templates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Our login check can be changed to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the edit button on the post page should only appear when the current
    user is the author:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The edit page itself should also perform the following check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now our app has a fully featured login system with a traditional username and
    password combination and many social logins as well. However, there are some features
    that are not covered in this system. For example, what if we wanted some users
    to be able to only comment while giving others permission to create posts? Also,
    our login system does not implement a `Remember Me` function. To cover this functionality,
    we will refactor our app to use a Flask extension named **Flask Login** instead
    of directly using the session.
  prefs: []
  type: TYPE_NORMAL
- en: Flask Login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start using Flask Login, it needs to be downloaded first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The main Flask Login object is the `LoginManager` object. Like the other Flask
    extensions, initialize the `LoginManager` object in `extensions.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some configuration options that need to be changed on the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding configuration values define which view should be treated as the
    login page and what the message to the user while logging in should look like.
    Setting the option `session_protection` to `strong` better protects against malicious
    users tampering with their cookies. When a tampered cookie is identified, the
    session object for that user is deleted and the user is forced to log back in.
    The `load_user` function takes an id and returns the `User` object. It's for Flask
    Login to check whether an id identifies the correct user object.
  prefs: []
  type: TYPE_NORMAL
- en: The `User` model needs to be updated to include some methods for Flask Login.
    First is `is_authenticated` to check whether the `User` object has been logged
    in. Next is `is_active,` which checks whether the user has gone through some sort
    of activation process, such as an e-mail confirmation. Otherwise, it allows site
    administrators to ban a user without deleting their data. Then, `is_anonymous`
    checks whether this user is anonymous and not logged in. Finally, a `get_id` function
    returns a unique `unicode` identifier for that `User` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This app will use a simple implementation for this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In Flask Login, every user on the site inherits from some user object. By default,
    they inherit an `AnonymousUserMixin` object. If your site needs some functionality
    with anonymous users, you can create a class that inherits from `AnonymousUserMixin`
    and set it as the default user class with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To better understand the concept of **mixins**, visit [https://en.wikipedia.org/wiki/Mixin](https://en.wikipedia.org/wiki/Mixin).
  prefs: []
  type: TYPE_NORMAL
- en: 'To log in a user with Flask Login, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Flask Login then takes care of all of the session handling. To have the user
    be remembered, add `remember=True`, to the `login_user` call. A checkbox can be
    added to the login form to give users the choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the login view, add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To log the current user out, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To protect a view from unauthorized users and send them to the login page,
    add the `login_required` decorator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Flask Login also provides a proxy to the logged in user with `current_user`.
    This proxy is available in views and templates alike. So, in our blog controller,
    the custom `before_request` handler can be deleted, and our calls to `g.current_user`
    should be replaced with `current_user`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, with Flask Login, our app''s login system is more Pythonic and secure.
    There is one last feature to implement: user roles and permissions.'
  prefs: []
  type: TYPE_NORMAL
- en: User roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add user permissions to our application, our `User` model will need a many-to-many
    relationship to a `Role` object, and it will need another Flask extension named
    **Flask Principal**.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our code from [Chapter 2](ch02.html "Chapter 2. Creating Models with SQLAlchemy"),
    *Creating Models with SQLAlchemy*, adding a many-to-many relationship to the `User`
    object is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'From the command line, populate the roles table with three roles: admin, poster,
    and default. These will act as the main permissions for Flask Principal.'
  prefs: []
  type: TYPE_NORMAL
- en: Flask Principal works around the idea of an identity. Something in the application,
    a `User` object in our case, has an identity associated with it. The identity
    provides `Need` objects, which at their core are just named tuples. `Needs` define
    what the identity can do. Permissions are initialized with `Need`, and they define
    what `Need` objects a resource needs to be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flask Principal provides two convenient `Need` objects: `UserNeed` and `RoleNeed`,
    which are exactly what is needed for our app. In `extensions.py`, Flask Principal
    will be initialized and our `RoleNeed` objects will be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Flask Principal requires a function that adds `Need` objects to it after the
    identity has changed. Because this function requires access to the `app` object,
    this function will reside in the `__init__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the identity is changed, it will add a `UserNeed` and all of the `RoleNeed`
    objects as well. The identity changes when the user logs in or logs out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user logs in, their identity will trigger the `on_identity_loaded`
    method, and set their `Need` objects up. Now if we had a page that we wanted only
    posters to have access to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also replace our user check in the same view with a `UserNeed` check
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Visit the documentation of Flask Principal at [https://pythonhosted.org/Flask-Principal/](https://pythonhosted.org/Flask-Principal/)
    to understand how to create much more complex `Need` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our users now have secure logins, multiple login and registration options, and
    explicit access permissions. Our app has everything that is needed to be a full-fledged
    blog app. In the next chapter, the book will stop following this example application
    in order to introduce a technology called **NoSQL**.
  prefs: []
  type: TYPE_NORMAL
