- en: Cleaning Up Your Code
  prefs: []
  type: TYPE_NORMAL
- en: This chapter assumes that you already have experience with JSX and you want
    to improve your skills to use it effectively. To use JSX/TSX without any problems
    or unexpected behaviors, it is essential to understand how it works under the
    hood, and the reasons why it is a useful tool for building UIs.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to write clean JSX/TSX code, maintain it, and know where it comes
    from, how it gets translated to JavaScript, and what features it provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is JSX and why should we use it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Babel and how can we use it to write modern JavaScript code?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main features of JSX and the differences between HTML and JSX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices to write JSX in an elegant and maintainable way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How linting, and ESLint in particular, can make our JavaScript code consistent
    across applications and teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of functional programming and why following a functional paradigm
    will make us write better React components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js 12+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how React changes the concept of separation
    of concerns, moving the boundaries inside components. We also learned how  React  uses
    the elements returned by the components to display the UI on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at how we can declare our elements inside our components.
  prefs: []
  type: TYPE_NORMAL
- en: 'React provides two ways to define our elements. The first one is by using JavaScript
    functions, and the second one is by using JSX, an optional XML-like syntax. The
    following is a screenshot of the examples section of the official React.js website
    ([https://reactjs.org/#examples](https://reactjs.org/#examples)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c47b0f53-2804-4466-b2e2-74e4f74880ff.png)'
  prefs: []
  type: TYPE_IMG
- en: To begin with, JSX is one of the main reasons why people fail to approach React,
    because looking at the examples on the home page and seeing JavaScript mixed with
    HTML for the first time can seem strange to most of us.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as we get used to it, we realize that it is very convenient, precisely
    because it is similar to HTML and looks very familiar to anyone who  has  already
    created UIs on the web. The opening and closing tags make it easier to represent
    nested trees of elements, something that would have been unreadable and hard to
    maintain using plain JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at JSX in more detail in the following sub-sections.
  prefs: []
  type: TYPE_NORMAL
- en: Babel 7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use JSX (and some features of ES6) in our code, we  have  to install the
    new Babel 7\. Babel is a popular JavaScript compiler widely adopted within the
    React community.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, it is important to clearly  understand  the problems it can solve
    for us and why we need to add a step to our process. The reason is that we want
    to use features of the language that have not yet been added in the browser, our
    target environment. Those advanced features make our code cleaner for developers,
    but the browser cannot understand and execute it.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to write our scripts in JSX and ES6 and, when we are ready to
    ship, we compile the sources into ES5, the standard specification implemented
    in major browsers today.
  prefs: []
  type: TYPE_NORMAL
- en: Babel can compile ES6 code into ES5 JavaScript, as well as compile JSX into
    JavaScript functions. This process is called  **transpilation**  because it compiles
    the source into a new source rather than into an executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In older versions of Babel 6.x, you installed the `babel-cli` package and you
    got `babel-node` and `babel-core`, and now everything is separated: `@babel/core`,
    `@babel/cli`, `@babel/node`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Babel, we need to install  `@babel/core`  and  `@babel/node` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you do not want to install it globally (developers usually tend to avoid
    this), you can install Babel locally to a project and run it through an `npm`  script,
    but for this chapter, a global instance is fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the installation is complete, we can run the following command to compile
    any JavaScript file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: One of the reasons why Babel is so powerful is because it is highly configurable.
    Babel is just a tool to transpile a source file into an output file, but to apply  some  transformations,
    we need to configure it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, there are some very useful presets of configurations that we can easily
    install and use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the installation is complete, we create a configuration file called `.babelrc`
    in the `root` folder, and put the following lines into it to tell Babel to use
    those presets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: From this point on, we can write ES6 and JSX in our source files and execute
    the output files in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that our  environment  has been set up to support JSX, we can dive into
    the most basic example: generating a  `div`  element. This is how you would create
    a  `div` element with the `_jsx` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the JSX for creating a `div` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It looks similar to regular HTML.
  prefs: []
  type: TYPE_NORMAL
- en: The big difference is that we are writing the markup inside a  `.js`  file,
    but it is  important  to note that JSX is only syntactic sugar, and it gets  transpiled  into
    JavaScript before being executed in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, our  `<div />` element is translated into `_jsx('div', {})`  when we
    run Babel, which is something we should always keep in mind when we write our
    templates.
  prefs: []
  type: TYPE_NORMAL
- en: In React 17, `React.createElement('div')` is deprecated, now internally using
    `react/jsx-runtime` to render the JSX, meaning that we will have something such
    as `_jsx('div', {})`. Basically, this means that you don't need to import the
    React object anymore in order to write JSX code.
  prefs: []
  type: TYPE_NORMAL
- en: DOM elements and React components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With JSX, we can create both  HTML  elements and React components; the only  difference  is
    whether or not they start with a capital letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to render an HTML button, we use  `<button />`, while to render
    the  `Button`  component, we use  `<Button />`. The first button is  transpiled  into
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The second one is transpiled into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The difference here is that in the first call, we are passing the type of the
    DOM element as a string, while in the second call, we are passing the component
    itself, which means that it should exist in the scope to work.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, JSX supports self-closing tags, which are pretty good
    for keeping the code terse and do not require us to repeat unnecessary tags.
  prefs: []
  type: TYPE_NORMAL
- en: Props
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JSX is very convenient when your DOM elements or React components have props.
    Using XML is pretty easy to set attributes on elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent in JavaScript would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is far less readable, and even with only a couple of attributes, it is
    harder to read without a bit of reasoning.
  prefs: []
  type: TYPE_NORMAL
- en: Children
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JSX  allows you to define children to describe the tree of elements and compose
    complex UIs. A basic example is a link with text inside it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be transpiled into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Our link can be enclosed inside a `div` element for some layout requirements,
    and the JSX snippet to achieve that is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript equivalent is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It should now be clear how the *XML-like* syntax of JSX makes everything more
    readable and maintainable, but it is always important to know the JavaScript parallel
    to our JSX has control over the creation of elements. The good part is that we
    are not limited to having elements as children of elements, but we can use JavaScript
    expressions, such as functions or variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we have to enclose the expression within curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The same applies to non-string attributes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you see, any variable or function should be enclosed with curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: Differences with HTML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have looked at the similarities between JSX and HTML. Let's now look
    at the little differences between them and the reasons they exist.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We must always keep in mind that JSX is not a  standard  language and that it
    gets transpiled into JavaScript. Because of this, some attributes cannot be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, instead of  `class`, we have to use  `className`, and instead
    of  `for`, we have to use  `htmlFor`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this is that `class` and `for` are reserved words in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Style
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A pretty significant difference is the way the `style` attribute works. We will
    look at how to use it in more detail in *Chapter 8, Making Your Components Look
    Beautiful*, but now we will focus on the way it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `style` attribute does not accept a CSS string as the HTML parallel does,
    but it expects a JavaScript object where the style names are *camelCased*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, you can pass an object to the `style` prop, meaning you can
    even  have your styles in a separate variable if you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is the best way to have better control of your inline styles.
  prefs: []
  type: TYPE_NORMAL
- en: Root
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One important difference with HTML worth  mentioning  is that since JSX elements
    get translated into JavaScript functions, and you cannot return two functions
    in JavaScript, whenever you have multiple elements at the same level, you are
    forced to wrap them in a parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the following works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Before, React forced you to return an element wrapped with an `<div>` element
    or any other tag; since React 16.2.0, it is possible to return an array directly
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can even  return a string directly, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, React now has a new feature called `Fragment` that also works as a special
    wrapper for elements. It can be specified with `React.Fragment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can use empty tags (`<></>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`Fragment` won''t render anything visible on the DOM; it is just a helper tag
    to wrap your React elements or components.'
  prefs: []
  type: TYPE_NORMAL
- en: Spaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There's one thing that could be a little bit tricky in the beginning and, again,
    it  concerns  the fact that we should always keep in mind that JSX is not HTML,
    even if it has XML-like syntax. JSX handles the spaces between text and elements
    differently from HTML, in a way that's counter-intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In a browser that interprets HTML, this code would give you `My name is Carlos`,
    which is exactly what we expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JSX, the same code would be rendered as `MynameisCarlos`, which is because
    the three nested lines get transpiled as individual children of the `div` element,
    without taking the spaces into account. A common solution to get the same output
    is putting a space explicitly between the elements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, we are using an empty string wrapped inside a JavaScript
    expression to force the compiler to apply a space between the elements.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A couple  more  things are worth mentioning before really starting regarding
    the way you define Boolean attributes in JSX. If you set an attribute without
    a value, JSX assumes that its value is `true`, following the same behavior as
    the HTML  `disabled`  attribute, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that if we want to set an attribute to `false`, we have to declare
    it explicitly as false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is another example of the Boolean attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This can be confusing in the beginning, because we may think that omitting an
    attribute would mean `false`, but it is not like that. With React, we should always
    be explicit to avoid confusion.
  prefs: []
  type: TYPE_NORMAL
- en: Spread attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important feature is the  **spread attribute**  operator (`...`), which comes
    from the rest/spread properties for ECMAScript proposal, and is very convenient
    whenever we want to pass all the attributes of a JavaScript object to an element.
  prefs: []
  type: TYPE_NORMAL
- en: A common practice that leads to fewer bugs is not to pass entire JavaScript
    objects down to children by reference, but to use their primitive values, which
    can be easily validated, making components more robust and error-proof.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gets transpiled into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Template literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Templates literals** are string literals allowing embedded expressions. You
    can use multiline strings and string interpolation features with them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Template literals are enclosed by the backtick (`` ``) character instead of
    double or single quotes. Also, template literals can contain placeholders. You
    can add them using the dollar sign and curly braces (`${expression}`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Common patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how JSX works and can master it, we are ready to see how to
    use it in the right way following some useful conventions and techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Multiline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's start with a very simple one. As stated previously, one of the  main  reasons
    we should prefer JSX over React's  `_jsx` function is because of its XML-like
    syntax, and because balanced opening and closing tags are perfect to represent
    a tree of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we should try to use it in the right way and get the most out of
    it. One example is as follows; whenever we have nested elements, we should always
    go multiline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is preferable to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The exception is if the children are not elements such as text or variables.
    In that case, it makes sense to remain on the same line and avoid adding noise
    to the markup, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Always remember to wrap your elements inside parentheses when you write them
    on multiple lines. JSX always gets replaced by functions, and functions written
    on a new line can give you an unexpected result because of automatic semicolon
    insertion. Suppose, for example, that you are returning JSX from your render method,
    which is how you create UIs in React.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example works  fine  because the  `div` element is on the same
    line as the `return`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following, however, is not right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for this is that you would then have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This is why you have to wrap the statement in parentheses, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Multi-properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common problem in writing JSX comes  when  an element has multiples attributes.
    One solution is to write all the attributes on the same line, but this would lead
    to very long lines that we do not want in our code (see the following section
    for how to enforce coding style guides).
  prefs: []
  type: TYPE_NORMAL
- en: 'A common solution is to write each attribute on a new line, with one level
    of indentation, and then align the closing bracket with the opening tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Conditionals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Things get more interesting  when  we start working with  **conditionals**,
    for example, if we want to render some components only when certain conditions
    are matched. The fact that we can use JavaScript in our conditions is a big plus,
    but there are many different ways to express conditions in JSX, and it is important
    to understand the benefits and problems of each one of these to write code that
    is both readable and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to show a logout button only if the user is currently logged
    in to our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple snippet to start with is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This works, but it is not very readable, especially if there are multiple components
    and multiple conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JSX, we can use an inline condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This works because if the condition is `false`, nothing gets rendered, but if
    the condition is `true`, the  `createElement`  function of `LoginButton`  gets
    called, and the element is returned to  compose  the resulting tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the condition has an alternative (the classic  `if...else`  statement) and
    we want, for example, to show a logout button if the user is logged in and a login
    button otherwise, we can use JavaScript''s  `if...else` statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, and better still, we can use a ternary condition that makes
    the code more compact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find the ternary condition used in popular repositories, such as the
    Redux  real-world example ([https://github.com/reactjs/redux/blob/master/examples/real-world/src/components/List.js#L28](https://github.com/reactjs/redux/blob/master/examples/real-world/src/components/List.js#L28)),
    where the ternary is used to show a Loading label if the component is fetching
    the data, or Load More inside a button depending on the value of the `isFetching`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now look at the best solution for when things get more complicated and,
    for example, we have to check more than one variable to determine whether to render
    a component or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, it is clear that using the inline condition is a good solution,
    but the readability is strongly impacted. Instead, we can create a helper function
    inside our component and use it in JSX to verify the condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this change makes the code more readable and the condition more
    explicit. If you look at this code in 6 months, you will still find it clear just
    by reading the name of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same applies to computed properties. Suppose you have two single properties
    for currency and value. Instead of creating the price string inside `render`,
    you can create a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This is better because it is isolated and you  can  easily test it if it contains
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to conditional statements, other solutions require using external
    dependencies. A good practice is to avoid external dependencies as much as we
    can to keep our bundle smaller, but it may be worth it in this particular case
    because improving the readability of our templates is a big win.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first solution is  `render-if`, which we can install with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then easily use it in our projects, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, we wrap our conditions inside the  `renderIf`  function.
  prefs: []
  type: TYPE_NORMAL
- en: The utility function that gets returned can be used as a function that receives
    the JSX markup to be shown when the condition is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: One goal is to never add too much logic inside our components. Some of them
    will require a bit of it, but we should try to keep them as simple as possible
    so that we can easily spot and fix errors.
  prefs: []
  type: TYPE_NORMAL
- en: We should at least try to keep the  `renderIf` method as clean as  possible  and
    to do that, we can use another utility library, called  `react-only-if`, which
    lets us write our components as if the condition is  always  `true` by setting
    the conditional function using a **Higher-Order Component** (**HOC**).
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about HOCs extensively in  *Chapter 4*,  *Exploring Popular Composition
    Patterns*, but for now, you just need to know that they are functions that receive
    a component and return an enhanced one by adding some properties or modifying
    their behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the library, we need to install it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it is installed, we can use it in our apps in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As you can see here, there is no logic at all inside the component itself.
  prefs: []
  type: TYPE_NORMAL
- en: We pass the condition as the first parameter of the  `onlyIf`  function, and
    when the condition is matched, the component is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: The function used to validate the condition receives the props, state, and context
    of the component.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, we avoid polluting our component with conditionals so that it is
    easier to understand and reason about.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A very common operation in UI development is to  display  lists of items. When
    it comes to showing lists, using JavaScript as a template language is a very good
    idea.
  prefs: []
  type: TYPE_NORMAL
- en: If we write a function that returns an array inside our JSX template, each element
    of the array gets compiled into an element.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen before, we can use any JavaScript expressions inside curly braces,
    and the most common way to generate an array of elements, given an array of objects,
    is to use  `map`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive into a real-world example. Suppose you have a list of users, each
    one with a name property attached to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an unordered list to show the users, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This snippet is incredibly simple and incredibly powerful at the same time,
    where the power of HTML and JavaScript converge.
  prefs: []
  type: TYPE_NORMAL
- en: Control statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Conditionals and loops are very  common  operations in UI templates, and you
    may feel wrong using the JavaScript ternary or the `map` function to perform them.
    JSX has been built in such a way that it only abstracts the creation of the elements,
    leaving the logic parts to real JavaScript, which is great except that sometimes,
    the code becomes less clear.
  prefs: []
  type: TYPE_NORMAL
- en: In general, we aim to remove all the logic from our components, and especially
    from our render methods, but sometimes we have to show and hide elements according
    to the state of the application, and very often we have to loop through collections
    and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you feel that using JSX for that kind of operation will make your code more
    readable, there is a Babel plugin available to do just that:  `jsx-control-statements`.'
  prefs: []
  type: TYPE_NORMAL
- en: This follows the same philosophy as JSX, and it does not add any real functionality
    to the language; it is just syntactic sugar that gets compiled into JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it is installed, we have to add it to the list of our Babel plugins in
    our `.babelrc` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: From now on, we can use the syntax provided by the plugin and Babel will transpile
    it together with the  common  JSX syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'A conditional statement written using the plugin looks like the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This gets transpiled into a ternary expression as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `If` component is great, but if, for some reason, you have nested conditions
    in your render method, it can easily become messy and hard to follow. This is
    where the `Choose` component comes in handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the preceding code gets transpiled into multiple ternaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there is a  component  (always remember that we are not talking about
    real components but just syntactic sugar) to manage the loops that is also very
    convenient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code gets transpiled into a `map` function – no magic there.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are used to using  **linters**, you might  wonder  why the linter is
    not complaining about that code. The `user` variable does not exist before the
    transpilation, nor is it wrapped in a function. To avoid those linting errors,
    there is another plugin to install:  `eslint-plugin-jsx-control-statements`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you did not understand the previous sentence, don't worry; we will talk about
    linting in the upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: Sub-rendering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is worth stressing that we always  want  to keep our components very small
    and our render methods very clean and simple.
  prefs: []
  type: TYPE_NORMAL
- en: However, that is not an easy goal, especially when you are creating an application
    iteratively, and in the first iteration, you are not sure exactly how to split
    the components into smaller ones. So, what should we be doing when the `render`
    method becomes too big to maintain? One solution is to split it into smaller functions
    in a way that lets us keep all the logic in the same component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This is not always considered best practice because it seems more obvious to
    split the component into smaller ones. However, sometimes it helps to keep the
    render  method  cleaner. For example, in the Redux real-world examples, a sub-render
    method is used to render the *load more* button.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are JSX power users, it is time to move on and see how to follow
    a style guide within our code to make it consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Styling code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to implement EditorConfig and ESLint to
    improve your code quality by validating your code style. It is important to have
    a standard  code style in your team and avoid using different code styles.
  prefs: []
  type: TYPE_NORMAL
- en: EditorConfig
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**EditorConfig** helps developers to maintain consistent coding styles between
    different IDEs.'
  prefs: []
  type: TYPE_NORMAL
- en: EditorConfig is supported by a lot of editors. You can check whether your editor
    is supported or not on the official website, [https://www.editorconfig.org](https://www.editorconfig.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to create a file called `.editorconfig` in your `root` directory –
    the configuration I use is this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: You can affect all the files with `[*]`, and specific files with `[.extension]`.
  prefs: []
  type: TYPE_NORMAL
- en: Prettier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Prettier** is an opinionated code formatter, supported by many languages
    that can be integrated with most editors. This plugin is really useful because
    you can format the code on saving and you don''t need to discuss the code style
    in code reviews, which will save you a lot of time and energy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you work with Visual Studio Code, you have to install the Prettier extension
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7a10a5dd-0c4b-43fc-837d-f95b014dd3c4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, if you want to configure the option to format when you save a file, you
    need to go to Settings, search `Format on Save`, and check that option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f1a9fade-d007-40df-a295-54f736f126d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will affect all your projects because it is a global setting. If you want
    to apply this option just in a specific project, you have to create a `.vscode`
    folder inside your project and a `settings.json` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can configure the options you want in your `.prettierrc` file – this
    is the configuration I normally use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This will help you or your team to standardize the code style.
  prefs: []
  type: TYPE_NORMAL
- en: ESLint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We always try to write the  best  code possible, but sometimes errors happen,
    and spending a few hours catching a bug due to a typo is very frustrating. Luckily,
    some tools can help us check the correctness of our code as soon as we type it.
    These tools are not able to tell us whether our code is going to do what it's
    supposed to do, but they can help us to avoid syntactical errors.
  prefs: []
  type: TYPE_NORMAL
- en: If you come from a static language, such as C#, you are used to getting that
    kind of warning inside your IDE. Douglas Crockford  made linting popular in JavaScript
    with JSLint (initially released in 2002) a few years ago; then we had JSHint,
    and finally, the de facto standard in the React world nowadays is  ESLint.
  prefs: []
  type: TYPE_NORMAL
- en: '**ESLint** is an open-source project released in 2013 that became popular thanks
    to the fact that it is highly configurable and extensible.'
  prefs: []
  type: TYPE_NORMAL
- en: In the JavaScript ecosystem, where libraries and techniques change very quickly,
    it is crucial to have a tool that can be easily extended with plugins, and rules
    that can be enabled and disabled when needed. Most importantly, nowadays we use
    transpilers, such as Babel, and experimental features that are not part of the
    standard version of JavaScript, so we need to be able to tell our linter which
    rules we are following in our source files. Not only does a linter help us to
    make fewer errors, or at least find those errors sooner, but it enforces some
    common coding style guides, which is important especially in big teams with many
    developers, each one with their favorite coding style.
  prefs: []
  type: TYPE_NORMAL
- en: It is very hard to read the code in a code base where different files, or even
    various functions, are written using inconsistent styles. For that reason, let's
    look at ESLint in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First of all, we have to install ESLint and some plugins as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the executable is installed, we can run it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The output will tell us if there are errors within the file.
  prefs: []
  type: TYPE_NORMAL
- en: When we install and run it for the first time, we do not see any errors because
    it is completely configurable and it does not come with any default rules.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start configuring ESLint. It can be configured using a  `.eslintrc`  file
    that  lives  in the root folder of the project. To add some rules, let''s create
    a  `.eslintrc` file configured for TypeScript and add one basic rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This configuration file needs a bit of explanation:  `"semi"`  is the name
    of the rule and  `[2, "never"]`  is the value. It is not very intuitive the first
    time you see it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'ESLint rules have three levels that determine the severity of the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '`off` (or `0`): The rule is disabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`warn` (or `1`): The rule is a warning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error` (or `2`): The rule throws an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are using the `2` value because we want ESLint to throw an error every time
    our code does not follow the rule. The second parameter tells ESLint that we want
    the semicolon to never be used (the opposite is  *always).* ESLint and its plugins
    are very well documented, and for any single rule, you can find the description
    of the rule and some examples of when it passes and when it fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create an `index.ts` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run  `eslint index.js`, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This is great; we set up the linter and it is helping us follow our first rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are other rules that I prefer to turn off or change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Git Hooks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To avoid having  unlinted  code in our repository, what we can do is add ESLint
    at one point of our process using Git Hooks. For example, we can use `husky` to
    run our linter in a Git Hook called `pre-commit`, and it is also useful to run
    our unit tests on the Hook called `pre-push`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `husky`, you need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in our `package.json` file, we can add this node to configure the tasks
    we want to run in the Git Hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: There is a special option (flag) for the ESlint command called `--fix` – with
    this option, ESLint will try to fix all our linter errors automatically (not all
    of them). Be careful with this option because sometimes it can affect a little
    bit of our code style. Another useful flag is `--ext` to specify the extensions
    of the files we want to validate, in this case just the `.tsx` and `.ts` files.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn about how **Functional Programming** (**FP**)
    works and topics such as first-class objects, purity, immutability, currying,
    and composition.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from following the best practices when we write JSX  and  using a linter
    to enforce consistency and find errors earlier, there is one more thing we can
    do to clean up our code: follow an FP style.'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in *Chapter 1*, *Taking Your First Steps with React*, React has
    a declarative programming approach that makes our code more readable. FP is a
    declarative paradigm, where side effects are avoided and data is considered immutable
    to make the code easier to maintain and reason about.
  prefs: []
  type: TYPE_NORMAL
- en: Don't consider the following sub-sections as an exhaustive guide to FP; it is
    only an introduction to get started with some concepts that are commonly used
    in React of which you should be aware.
  prefs: []
  type: TYPE_NORMAL
- en: '**First-class functions**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript has first-class functions because they are treated like any other
    variable, meaning you can pass a function as a parameter to other functions, or
    it can be returned by another function and be assigned as a value to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to introduce the concept of  **Higher-Order Functions** (**HoFs**).
    HoFs are functions that take a function as a parameter, and optionally some other
    parameters, and  return  a function. The returned function is usually enhanced
    with some special behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Here, a function is adding two numbers that enhance a function that logs all
    the parameters and then executes the original function.
  prefs: []
  type: TYPE_NORMAL
- en: This concept is pretty important to understand because in the React world, a
    common pattern is to use HOCs to treat our components as functions, and to enhance
    them with common behaviors. We will see HOCs and other patterns in *Chapter 4*,
    *Exploring Popular Composition Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: Purity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important aspect of FP is to write pure functions. You  will  encounter this
    concept very often in the React ecosystem, especially if you look into libraries
    such as Redux.
  prefs: []
  type: TYPE_NORMAL
- en: What does it mean for a function to be pure?
  prefs: []
  type: TYPE_NORMAL
- en: A function is pure when there are no side effects, which means that the function
    does not change anything that is not local to the function itself.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a function that changes the state of an application, or modifies
    variables defined in the upper scope, or a function that touches external entities,
    such as the **Document Object Model** (**DOM**), is considered impure. Impure
    functions are harder to debug, and most of the time it is not possible to apply
    them multiple times and expect to get the same result.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following function is pure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: It can be run multiple times, always getting the same result, because nothing
    is stored anywhere and nothing gets modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function is not pure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Running `add(1)` twice, we get two different results. The first time we get
    `1`, but the second time we get `2`, even if we call the same function with the
    same parameter. The reason we get that behavior is that the global state gets
    modified after every execution.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how to write pure functions that don't  mutate  the state, but
    what if we need to change the value of a variable? In FP, a function, instead
    of changing the value of a variable, creates a new  variable  with a new value
    and returns it. This way of working with data is called  **immutability**.
  prefs: []
  type: TYPE_NORMAL
- en: An immutable value is a value that cannot be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function doesn't follow immutability because it changes the value
    of the given array. Again, if we call the same function twice, we get different
    results.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can change the preceding function to make it immutable using  `concat`,
    which returns a new array without modifying the given one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: After we have run the function twice, `myArr` still has its original value.
  prefs: []
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common technique in FP is  currying.  **Currying**  is the  process  of converting
    a function that takes multiple arguments into a function one argument at a time
    and returning  another  function. Let's look at an example to clarify the concept.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the  `add`  function we have seen before and transform it into
    a curried function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We can instead define the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We use it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: This is a pretty convenient way of writing functions because, since the first
    value is stored after the application of the first parameter, we can reuse the
    second function multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, an important concept in FP that  can  be applied to React is **composition**.
    Functions (and components) can be combined to produce new functions with more
    advanced features and properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'These functions can be composed together to create a new function that adds
    two numbers and then doubles the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Following this paradigm, we end up with small, simple, testable pure functions
    that can be composed together.
  prefs: []
  type: TYPE_NORMAL
- en: FP and UIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last step is to learn how we  can  use FP to build UIs, which is what we
    use React for.
  prefs: []
  type: TYPE_NORMAL
- en: 'We  can  think about a UI as a function to which the state of the application
    is applied as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: We expect this function to be idempotent so that it returns the same UI given
    the same state of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Using React, we create our  UIs  using components we  can  consider functions,
    as we will see in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Components  can  be composed to form the final UI, which is a property of FP.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of similarities in the way we build UIs with React and the principles
    of FP, and the more we are aware of it, the better our code will be.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned a great deal about how JSX works and how to use
    it in the right way in our components. We started from the basics of the syntax
    to create a solid knowledge base that will enable us to master JSX and its features.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part, we looked at how to configure Prettier and how ESLint and
    its plugins can help us find problems faster and enforce a consistent style guide
    across our code base.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we went through the basics of FP to understand the important concepts
    to use when writing a React application.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our code is clean, we are ready to start digging deeper into React
    and learn how to write truly reusable components in the next chapter.
  prefs: []
  type: TYPE_NORMAL
