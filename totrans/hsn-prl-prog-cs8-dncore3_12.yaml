- en: Async, Await, and Task-Based Asynchronous Programming Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced asynchronous programming practices and
    solutions available in C#, even prior to .NET Core. We also discussed scenarios
    where asynchronous programming can be handy, and where it should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will dig more deeply into asynchronous programming, and
    will introduce two keywords that make writing asynchronous code very easy. We
    will be covering the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to `async` and `await`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Async delegates and lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The** Task-Based Asynchronous Pattern** (**TAP**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling in asynchronous code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Async with PLINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring async code performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guidelines for using async code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with an introduction to the `async` and `await` keywords, which
    were first introduced in C# 5.0 and adopted in .NET Core as well.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Readers should have a good understanding of the **Task Parallel Library **(**TPL**) and
    C#. The source code for this chapter is available on GitHub at [https://github.com/PacktPublishing/-Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter09](https://github.com/PacktPublishing/-Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing async and await
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`async` and `await` are two very popular keywords among .NET Core developers
    writing asynchronous code with the new asynchronous APIs provided by .NET Framework.
    They are used for marking code when calling asynchronous operations. In the last
    chapter, we discussed the challenges of converting a synchronous method into an
    asynchronous one. Previously, we did this by breaking down the method into two
    methods, `BeginMethodName` and `EndMethodName`, which can be called asynchronously.
    This approach makes the code clumsy and difficult to write, debug, and maintain.
    With the `async` and `await` keywords, however, the code can stay how it was in
    the synchronous implementation, with only small changes required. All the difficult
    work of breaking down the method, executing the asynchronous method, and getting
    the response back to the program is done by the compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: All new I/O APIs provided by .NET Framework support task-based asynchrony, which
    we discussed in the previous chapter. Let's now try to understand a few scenarios
    involving I/O operations, wherein we can take advantage of the `async` and `await`
    keywords. Let's say we want to download data from a public API that returns data
    in JSON format. In older versions of C#, we can write synchronous code using the
    `WebClient` class available in the `System.Net` namespace, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add a reference to the `System.Net` assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, create an object of the `WebClient` class and call the `DownloadString`
    method by passing the URL of the page to download. The method will run synchronously,
    and the calling thread will be blocked until the download operation is finished.
    This can hamper the performance of the server (if used in server-side code) and
    the responsiveness of the application (if used in Windows application code).
  prefs: []
  type: TYPE_NORMAL
- en: To improve performance and responsiveness, we can use the asynchronous version
    of the `DownloadString` method, which was introduced much later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a method that creates a download request for a remote resource that
    is `http://www.aspnet.com` and subscribes to the `DownloadStringCompleted` event,
    rather than waiting for the download to complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the `DownloadComplete` event handler, which gets fired when the
    download is finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have used the **Event-Based Asynchronous Pattern**
    (**EAP**). As you can see, we have subscribed to the `DownloadCompleted` event,
    which will be raised by the `WebClient` class once the download is finished. Then,
    we have made a call to the `DownloadStringAsync` method, which will call the code
    asynchronously and return immediately, avoiding the need to block the thread.
    When the download finishes in the background, the `DownloadComplete` method will
    be called, and we can receive either the error, using the `e.Error` property,
    or the data, using the `e.Result` property of `DownloadStringCompletedEventArgs`.
  prefs: []
  type: TYPE_NORMAL
- en: If we run the preceding code in a Windows application, the results will be as
    expected, but the response will always be received by a worker thread (which executes
    in the background), and not by the main thread. As Windows application developers,
    we need to be mindful of the fact that we cannot update the UI controls from the `DownloadComplete`
    method, and that all such calls need to be delegated back to the main UI thread
    using techniques such as Invoke in classic Windows Forms, or Dispatcher in **Windows
    Presentation Foundation** (**WPF**). The best thing about using the Invoke/Dispatcher
    approach is that the main thread is never blocked, and the application is, therefore,
    more responsive as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: In the code samples accompanying this book, we have included scenarios for Windows
    Forms as well as for WPF, although .NET Core doesn't yet support Windows applications
    or WPF. This support is expected to be introduced in the next version of Visual
    Studio, VS 2019.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to run the preceding code in a .NET Core console application from
    the main thread, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can modify the `DownloadComplete` method by adding a `Console.WriteLine`
    statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: According to the logic, the program should download the page asynchronously,
    print the output, and wait for the user input before it terminates. When we run
    the preceding code, we will see that the program terminates without printing anything
    and without waiting for the user input. Why did this happen?
  prefs: []
  type: TYPE_NORMAL
- en: As already stated, the main thread gets unblocked as soon as it calls the `DownloadStringAsync`
    method. The main thread doesn't wait for the callback to execute. This is by design,
    and asynchronous methods are expected to behave in this manner. However, since
    the main thread has nothing else to do and has already done what it was expected
    to do, which was calling the method, the application terminates.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a web application developer, you might face a similar problem if you use
    the preceding code in a server-side application using Web Forms or ASP.NET MVC.
    The IIS thread executing your request will return immediately, without waiting
    for the download to finish, if you have called the method asynchronously. The
    results will therefore not be as expected. We are not expecting the code to print
    the output to the console in a web application, and the `Console.WriteLine` statement
    is simply ignored when run in web application code. Suppose your logic is to return
    the web page as a response to the client request. We can achieve this using the `WebClient`
    class synchronously, as shown in the following example, using ASP.NET MVC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem here is that the preceding code will block the thread, which can
    have an impact on the performance of the server and lead to a self-inflicted **Denial-of-Service**
    (**DoS**) attack, which occurs when a lot of users hit a portion of the application
    concurrently. As more and more threads are hit and become blocked, there will
    be a point at which the server won''t have any threads free to process client
    requests, and will start queueing requests. Once the queue limit is reached, the
    server will start throwing a 503 error: Service Unavailable.'
  prefs: []
  type: TYPE_NORMAL
- en: We cannot use the `DownloadStringAsync` method because the moment it is called,
    the thread will return a response back to the client, without waiting for `DownloadComplete`
    to finish. We need a way to make the server thread wait without blocking it. `async`
    and `await` come to our rescue in such a scenario. Apart from helping us to achieve
    our objective, they also help us to have clean code that is easy to write, debug,
    and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate `async` and `await`, we can use another important class of .NET
    Core, `HttpClient`, which is available in the `System.Net.Http` namespace. `HttpClient`
    should be used instead of `WebClient`, as it has full support for task-based asynchronous
    operations, has a vastly improved performance, and supports HTTP methods such
    as GET, POST, PUT, and DELETE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an async version of the preceding code, using the `HttpClient` class
    and introducing the `async` and `await` keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to change the method signature to include the `async` keyword.
    This is an instruction to the compiler that this method will execute asynchronously
    where necessary. Then, we wrap the return type of the method inside `Task<T>`.
    This is important since .NET Framework supports task-based async operations, and
    all async methods must return `Task`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create an instance of the `HttpClient` class and call the `GetAsync()`
    method, passing the URL of the resource that you want to download. Unlike the
    EAP pattern, which relies on callbacks, we instead just write the `await` keyword
    with the call. This makes sure of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The method executes asynchronously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The calling thread gets unblocked so that it can go back to the thread pool
    and process other client requests, thus making the server responsive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the download is complete, the `ThreadPool` receives an interrupt signal
    from the processor, and it will take out a free thread from the `ThreadPool`,
    which can be either the same thread that was operating on the request or a different
    thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ThreadPool` thread receives the response and starts executing the rest
    of the method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the download finishes, we can read the content that is downloaded by using
    another async operation, called `ReadAsStringAsync()`. This section has shown
    that it is easy to write async methods that resemble their synchronous counterparts,
    making their logic straightforward as well.
  prefs: []
  type: TYPE_NORMAL
- en: The return type of async methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding example, we changed the return type of the method from `IAsyncResult`
    to `Task<IAsyncResult>`. There can be three return types from async methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All async methods must return a `Task` in order to be awaited (using the `await`
    keyword). This is because, once you call them, they don't return immediately,
    but rather, they execute a long-running task asynchronously. In doing this, the
    caller thread may switch in and out of context as well.
  prefs: []
  type: TYPE_NORMAL
- en: '`void` can be used with asynchronous methods where the caller thread doesn''t
    want to wait. These methods can be any operation that can happen in the background
    that''s not part of the response being returned to the user. For example, logging
    and auditing can be made asynchronous. This means that they can be wrapped inside
    async `void` methods. The caller thread will return immediately on calling the
    operation, and the logging and auditing operations will take place later on. It''s
    thus highly recommended to return a `Task` instead of `void` from asynchronous
    methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Async delegates and lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use the `async` keyword to create asynchronous delegates and lambda expressions
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a synchronous delegate that returns the square of a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make the preceding delegate asynchronous by appending the `async` keyword,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, lambda expressions can be converted, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Asynchronous methods work in a chain. Once you have made any one method asynchronous,
    then all methods that call that method need to be converted to being asynchronous
    as well, thus creating a long chain of asynchronous methods.
  prefs: []
  type: TYPE_NORMAL
- en: Task-based asynchronous patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](a001ad9c-7e57-4af7-961f-91c1e983b937.xhtml), *Task Parallelism*,
    we discussed how the TAP can be achieved using the `Task` class. There are two
    ways to implement this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler method, using the `async` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The manual method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see how these methods operate, in the subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler method, using the async keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we use the `async` keyword to make any method asynchronous, the compiler
    carries out the required optimization to execute the method asynchronously, using
    the TAP internally. An async method must return either `System.Threading.Task`
    or `System.Threading.Task<T>`. The compiler takes care of executing the method
    asynchronously and returns results or exceptions back to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the TAP manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already shown how to implement the TAP manually in the EAP and **Asynchronous
    Programming Model** (**APM**). Implementing this pattern gives us more control
    over the overall implementation of the method. We can create a `TaskCompletionSource<TResult>`
    class and then perform an asynchronous operation. When the asynchronous operation
    finishes, we can return the result back to the caller by calling the `SetResult`,
    `SetException`, or `SetCanceled` methods of the `TaskCompletionSource<TResult>`
    class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created a method returning `Task<int>` that can work
    on any `System.IO.FileStream` object as an extension method. Within the method,
    we created a `TaskCompletionSource<int>` object, and then called the asynchronous
    operation provided by the `FileStream` class to read the file into a byte array.
    If the read operation finishes successfully, we return the results back to the
    caller using the `SetResult` method; otherwise, we return the exceptions using
    the `SetException` method. Finally, the method returns the underlying task from
    the `TaskCompletionSource<int>` object to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling with async code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the case of synchronous code, all exceptions are propagated to the top of
    the stack until they are handled by a try-catch block or they are thrown as an
    unhandled exception. When we await on any asynchronous method, the call stack
    will not be the same, as the thread has made a transition from the method to the
    thread pool, and is now coming back. C#, however, has made it easier for us to
    do exception handling by changing the exception behavior for async methods. All
    async methods return either `Task` or `void`. Let's try to understand both scenarios
    with examples, and see how the programs will behave.
  prefs: []
  type: TYPE_NORMAL
- en: A method that returns Task and throws an exception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say we have the following method, which is `void`. As a best practice,
    we return `Task` from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The method throws an exception after a delay of two seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will try to call this method using various methods to try to understand
    the behavior of how exceptions are handled for async methods. The following scenarios
    will be discussed in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling the async method from outside the try-catch block without the `await`
    keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling the async method from inside the try-catch block without the `await`
    keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling the async method with the `await` keyword from outside the try-catch
    block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods returning `void`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will see these methods in detail in the subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: An async method from outside a try-catch block without the await keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following is a sample async method that returns a `Task`.  The method, in
    turn, calls another method, `DoSomethingFaulty ()`, which throws an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our `DoSomethingFaulty()` method implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the code for the `AsyncReturningTaskExample()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a call to this method from the `Main()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Async main is a handy addition to C# from version 7.1 onward. It became broken
    in release 7.2 but was fixed back in .NET Core 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the program calls the async method—that is `AsyncReturningTaskExample()`—without
    using the `await` keyword. The `AsyncReturningTaskExample()` method further calls
    the `DoSomethingFaulty()` method, which throws an exception. The following output
    is produced when we run this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88073eb0-9010-45f1-838e-1239ced84266.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the case of synchronous programming, the program would have resulted in
    an unhandled exception, and it would have crashed. But here, the program continues
    as if nothing happened. This is due to the way in which `Task` objects are handled
    by the framework. In this case, the task will return to the caller with a Status
    of Faulted, as can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27e57487-af51-4fc0-94a8-7c5a17059fa6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A better code would have been to check the task status and fetch all exceptions
    if there are any:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As we saw in [Chapter 2](a001ad9c-7e57-4af7-961f-91c1e983b937.xhtml), *Task
    Parallelism*, this task returns an instance of `AggregateExceptions`. To get all
    inner exceptions thrown, we can use the `Flatten()` method, as demonstrated in
    the previous screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: An async method from inside the try-catch block without the await keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's change the method to move the call to the async method `GetSomethingFaulty()` inside
    the try-catch block, and call from the `Main()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `Main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the `Scenario2CallAsyncWithoutAwaitFromInsideTryCatch()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This time, we see that the exception will be thrown and received by the catch
    block, after which time the program will resume as normal.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth taking a look at the value of the `Task` object inside the `Main`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e97dd4ef-dfcd-4677-b88d-d4e855a6c81b.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, if task creation is not carried out inside the try-catch block,
    the exceptions will be unobserved. This can cause issues, since the logic may
    not work as expected. A best practice is to always wrap the task creation inside
    the try-catch block.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, since the exceptions were handled, the execution returned normally
    from the async method. The status of the returned task becomes `RanToCompletion`.
  prefs: []
  type: TYPE_NORMAL
- en: Calling an async method with the await keyword from outside the try-catch block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code block shows the code for the method that calls the faulty
    method, `DoSomethingFaulty()`, and waits for the method to finish, using the `await`
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the call from the `Main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The behavior of the program, in this case, will be the same as in the first
    scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Methods returning void
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the methods return `void` instead of `Task`, the program will crash. You
    can try running the following code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a method returning `void` instead of `Task`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is a call from the `Main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There will be no output, as the program will crash.
  prefs: []
  type: TYPE_NORMAL
- en: Although it makes sense to never return `void` from async methods, mistakes
    do happen. We should write code so that it never crashes or only crashes gracefully
    after logging exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can handle this globally by subscribing to two global event handlers, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will handle all unhandled exceptions in the program, and
    accounts for good practices in exception management. The program should not crash
    randomly, and, if it needs to crash at all, then it should log information and
    clean up all resources.
  prefs: []
  type: TYPE_NORMAL
- en: Async with PLINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PLINQ is a very handy tool for developers, to improve the performance of applications
    by executing a set of tasks in parallel. Creating a number of tasks can improve
    performance, but, if tasks are blocking in nature, then the application will end
    up creating lots of blocking threads and, at some point, will become unresponsive.
    This is especially true if the task is executing some I/O operations. Here is
    a method that needs to download 100 pages from the web as quickly as possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the preceding code, being synchronous, has a complexity of *O(n)*.
    If one request takes one second to finish, the method will take at least 100 seconds
    (n = 100 here).
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the download faster (assuming we have a good server configuration that
    can handle this load multiplied by the number of users your application wants
    to support), we need to make this method parallel. We can do this using `Parallel.ForEach`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Suddenly, the code starts complaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The ''await'' operator can only be used within an async lambda expression.
    Consider marking this lambda expression with the ''async'' modifier.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because we have used a lambda expression, which needs to be made async
    as well, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The code will now compile and work as expected, with much-improved performance.
    Talking more about performance in the next section, we will dig more deeply into
    how to measure the performance of asynchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring the performance of async code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Async code can improve the performance and responsiveness of applications, but
    there are trade-offs. In the case of GUI-based applications, such as Windows Forms
    or WPF, if a method is taking a long time, it makes sense to make it async. For
    server applications, however, you need to measure the trade-off between the extra
    memory utilized by the blocked threads and the extra processor overhead required
    to make methods asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code, which creates three tasks. Each task runs asynchronously,
    one after another. As one method finishes, it goes on to execute another task
    asynchronously. The total time taken to finish the method can be calculated using
    `Stopwatch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0d8cd2f-b74e-4b8c-ba02-0640678401d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is as good as writing synchronous code. The benefit is that the thread
    is not blocked, but the overall performance of the application is poor since all
    code now runs synchronously. We could change the preceding code to improve the
    performance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this is a better use of Parallel and async to get an improved
    performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7c04eec-fc9f-43ca-8fe3-a329e7f7046b.png)'
  prefs: []
  type: TYPE_IMG
- en: To understand async better, we also need to understand which thread runs our
    code. Since new async APIs work with the `Task` class, all the calls are executed
    by the `ThreadPool` thread. When we make async calls—say, to fetch data from a
    network—the control gets transferred to the I/O completion port thread, which
    is managed by the OS. Usually, this is only one thread that is shared across all
    network requests. When the I/O request completes, the OS fires an interrupt signal
    that adds a job to the queue of the I/O completion port. In the case of server-side
    applications, which usually work in **Multi-Threaded Apartment** (**MTA**) mode,
    any thread can start an async request and any other thread can receive it.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of Windows applications, however, (including both WinForms and WPF),
    which work in **Single-Threaded Apartment** (**STA**) mode, it becomes important
    that an async call gets returned to the same thread that started it (normally
    a UI thread). Every UI thread in a Windows application has a `SynchronizationContext` that
    makes sure that the code is always executed by the correct thread. This is important
    due to control ownership. To avoid cross-threading issues, only the owner thread
    can change the values of the controls. The most important method of the `SynchronizationContext`
    class is `Post`, which can make a delegate run in the right context, thus avoiding
    cross-threading issues.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we await a task, the current `SynchronizationContext` is captured.
    Then, when the method needs to be resumed, the `await` keyword internally uses
    the `Post` method to resume the method in the captured `SynchronizationContext`.
    Calling the `Post` method is very costly, however, but there is a built-in performance
    optimization provided by the framework. The `Post` method doesn't get called if
    the captured `SynchronizationContext` is the same as the current `SynchronizationContext` of
    the returning thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are writing a class library and we don''t really care about which `SynchronizationContext` the
    call will be returned to, we can completely turn off the `Post` method. We can
    achieve this by calling the `ConfigureAwait()` method on the returning task, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have learned the important aspects of asynchronous programming. We
    now need to know the guidelines for using async code while programming!
  prefs: []
  type: TYPE_NORMAL
- en: Guidelines for using async code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some guidelines/best practices while writing with asynchronous code are the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid using async void.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Async chain all the way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `ConfigureAwait` wherever possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn more about these in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid using async void
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen how returning `void` from async methods actually affects
    the exception handling. Async methods should return `Task` or `Task<T>` so that
    exceptions can be observed and not become unhandled.
  prefs: []
  type: TYPE_NORMAL
- en: Async chain all the way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mixing async and blocking methods will have an impact on performance. Once
    we decide to make a method async, the entire chain of methods that are supposed
    to be called from that method should be made async as well. Not doing so can sometimes
    result in a deadlock, as demonstrated in the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If we call the `Deadlock()` method from any ASP.NET or GUI-based application,
    it would create a deadlock, although the same code would run fine in a console
    application. When we call the `DelayAsync()` method, it captures the current `SynchronizationContext`,
    or the current `TaskScheduler` if the `SynchronizationContext` is null. When the
    awaited task is complete, it tries to execute the remainder of the method with
    the captured context. The problem here is that there is already a thread that's
    waiting synchronously for the async method to finish. In this situation, both
    threads will be waiting for the other thread to finish, thus causing a deadlock. This
    problem is raised only in GUI-based or ASP.NET applications because they rely
    on the `SynchronizationContext` that can only execute one chunk of code at a time. Console
    applications, on the other hand, utilize `ThreadPool` instead of `SynchronizationContext`.
    When the await finishes, the pending async method part is scheduled on a `ThreadPool`
    thread. The method is completed on a separate thread and returns the task back
    to the caller, so there is no deadlock.
  prefs: []
  type: TYPE_NORMAL
- en: Never try to create sample `async`/`await` code in a console application and
    copy and paste it in a GUI or ASP.NET application, as they have different models
    for executing async code.
  prefs: []
  type: TYPE_NORMAL
- en: Using ConfigureAwait wherever possible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We could have avoided deadlock in the preceding code example by completely
    skipping the use of `SynchronizationContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When we use `ConfigureAwait(false)`, the method is awaited. When the await completes,
    the processor tries to execute the rest of the async method within the thread
    pool context. The method is able to complete with no issues since there are no
    blocking contexts. The method completes its returned task, and there's no deadlock.
  prefs: []
  type: TYPE_NORMAL
- en: We have come to the end of this chapter. Let's now see all we have learned!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed two very important constructs that make writing
    asynchronous code very easy. All the heavy work is done by the compiler when we
    use these keywords, and the code looks very similar to its synchronous counterpart.
    We also discussed which thread the code runs on when we make methods asynchronous,
    and the performance penalty associated with utilizing `SynchronizationContext`.
    Finally, we looked at how we can turn off the `SynchronizationContext` completely
    to improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce parallel debugging techniques using Visual
    Studio. We will also learn the tools available in Visual Studio to help in parallel
    code debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What keyword is used to unblock a thread inside async methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`async`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`await`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Thread.Sleep`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Task`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following are valid return types for async methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`void`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Task`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Task<T>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IAsyncResult`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TaskCompletionSource<T>` can be used to implement a task-based async pattern
    manually.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we write `Main` methods as async?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Yes'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'No'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which property of the `Task` class can be used to check whether an exception
    has been thrown by an async method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IsException`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IsFaulted`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should always use `void` as a return type for async methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
