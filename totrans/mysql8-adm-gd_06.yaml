- en: MySQL 8 Storage Engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about setting up a new system, data dictionary,
    and system database. Detailed information was provided on caching techniques,
    globalization, different types of components, and plugin configuration, along
    with several types of log files which are very important for administration.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter gives detailed information on MySQL 8 storage engines. It explains
    the `InnoDB` storage engine and its features in detail and also provides a practical
    guideline on custom storage engine creation and how to make it pluggable so that
    it can be installed in MySQL 8\. The topics that we will be covering in this chapter
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of storage engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several types of storage engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `InnoDB` storage engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom storage engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of storage engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Storage engines are MySQL components for handling the SQL operations used in
    different types of tables. MySQL storage engines are designed to manage different
    types of tasks in different types of environments. It is very important to know
    and choose which storage engine is best suited for the system or application requirements.
    In following sections, we will get to know in detail about the types of storage
    engines, the default storage engine, and the creation of custom storage engines.
  prefs: []
  type: TYPE_NORMAL
- en: Let us go through and see why the storage engine is a very important component
    in databases, including MySQL 8\. Storage engines work with database engines to
    perform various types of tasks in different environments. They execute create,
    read, update, and delete operations in the form of statements on data from the
    database. It looks quite simple when you provide the `ENGINE` parameter with the
    create table statement but there is configuration for plenty of operations to
    be done on the data for each of the requests sent via SQL statements. It is much
    more than just persisting data - the engine takes care of features such as storage
    limits, transactions, locking granularity/level, multi-version concurrency control,
    geospatial data types, geospatial indexing, B-tree indexes, T-tree indexes, `Hash`
    indexes, full-text search indexes, clustered indexes, data caches, index caches,
    compressed data, encrypted data, cluster databases, replication, foreign keys,
    back up, query caches, and updating statistics for the data dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL storage engine architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MySQL storage engine's pluggable architecture allows a database professional
    to select any storage engine for the specialization required in any particular
    application. The MySQL Storage engine architecture provides an easy application
    model and API with the consistency that isolates the database administrator and
    the application programmer from all the low-level implementation details underlying
    at the storage level. Thus, the application always works above different storage
    engines' different capabilities. It provides standard management and support services
    that are common for all underlying storage engines.
  prefs: []
  type: TYPE_NORMAL
- en: Storage engines perform activities on the data that is persisted at the physical
    server level. Such modular and efficient architecture provides solutions to specific
    needs of any particular application, such as transaction processing, high availability
    situations, or data warehousing, and at the same time has the advantage of independent
    interfaces and services from the underlying storage engines.
  prefs: []
  type: TYPE_NORMAL
- en: The database administrator and the application programmer interact with the
    MySQL database by Connector APIs and services on top of the storage engines. The
    application is shielded by the MySQL server architecture from the detailed level
    complexity of the storage engines by providing easy to use APIs that are consistent
    and applicable on all the storage engines. If the application requires changes
    in the underlying storage engine, or if one or more storage engines are added
    to support the needs of the application, no major coding or process changes are
    required to get things working.
  prefs: []
  type: TYPE_NORMAL
- en: Several types of storage engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we know the importance of storage engines and critical decisions to identify
    which storage engines to use from plenty of storage engines available for MySQL
    8\. Let us take a look at what is available and with which specifications. InnoDB
    is the name that first entered your thoughts when you started thinking of storage
    engines, right?
  prefs: []
  type: TYPE_NORMAL
- en: InnoDB is the default and most general-purpose storage engine in MySQL 8 and
    it is recommended by Oracle to use for tables as well as for special use cases.
    The MySQL server has a pluggable storage engine architecture that enables storage
    engine loading as well as unloading from the already running MySQL server.
  prefs: []
  type: TYPE_NORMAL
- en: To identify which storage engines your server supports is made very easy in
    MySQL 8\. We only have to go to the MySQL shell or prompt and use the `SHOW ENGINES`
    statement. Hit the statement when prompted and result will be the list of engines
    with a few columns, such as Engine, Support, Transactions, Savepoints, and Comment.
  prefs: []
  type: TYPE_NORMAL
- en: Values in Support column, DEFAULT, YES, and NO, indicate that a storage engine
    is available and currently set as the default storage.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the InnoDB storage engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`InnoDB` is the default and most general-purpose storage engine in MySQL 8,
    providing high reliability and high performance.'
  prefs: []
  type: TYPE_NORMAL
- en: If you have not configured a different default storage engine, then issuing
    the SQL statement `CREATE TABLE` without the `ENGINE = clause` creates a table
    with the storage engine `InnoDB` as the default engine in MySQL 8.
  prefs: []
  type: TYPE_NORMAL
- en: The features and advantages offered by the `InnoDB` storage engine are explained
    later in the *The InnoDB storage engine* section.
  prefs: []
  type: TYPE_NORMAL
- en: Custom storage engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: storage engine architecture in MySQL 5.1 and all the later versions and MySQL
    8 have taken advantage of the flexible storage engine architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The storage engine pluggable architecture provides the capability to create
    and add new storage engines without recompilation of the server, adding directly
    to a running MySQL server. The architecture makes it very easy to develop and
    deploy new storage engines to MySQL 8.
  prefs: []
  type: TYPE_NORMAL
- en: We will develop a new storage engine by using the pluggable feature of the MySQL
    storage engine architecture in the upcoming *Creating a custom storage engine* section.
  prefs: []
  type: TYPE_NORMAL
- en: Several types of storage engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a closer look at the widely used storage engines
    that are supported by MySQL 8\. But before checking on them, let us see how the
    storage engine architecture has made it pluggable and provided flexibility to
    enable using multiple storage engines in the same schema or server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the list of storage engines supported in MySQL 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '`InnoDB`: The default storage engine for MySQL 8\. It is an `ACID` compliant
    (transaction-safe) storage engine that has commit, roll back, and crash-recovery
    for protecting the user data and `referential-integrity` constraints to maintain
    data integrity, and much more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MyISAM`: The storage engine with tables having a small footprint. It has table-level
    locking and so is mostly used in read-only or read-mostly data workloads, such
    as in data warehousing and web configurations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Memory`: The storage engine previously known as the `HEAP` engine. It keeps
    data in RAM, which provides faster data access, mostly used in quick lookups of
    non-critical data environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CSV`: The storage engine with tables as comma-separated values in text files
    and tables. They are not indexed and are mostly used for importing and dumping
    data in `CSV` format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Archive`: The storage engine comprises compact, unindexed tables, intended
    to store and retrieve a huge amount of historical, archived, or security audit
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Blackhole`: The storage engine with tables that can be used for replication
    configuration. A query always returns an empty set. `DML` SQL statements are sent
    to slave servers. It accepts data but data is not stored, such as in a Unix `/dev/null` device
    use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Merge`: The storage engine provides the capability to logically group a series
    of similar `MyISAM` tables and refer to them as one object instead of separate
    table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Federated`: The storage engine that can link many separate physical MySQL
    servers into one logical database. It is ideal for data marts or distributed environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Example`: The storage engine that does nothing but works as a `stub`. It is
    primarily used by the developers who illustrate how to begin writing new storage
    engines in the MySQL source code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL does not restrict using the same storage engine for an entire server or
    schema; instead, specifying the engine at table level makes it flexible based
    on the type of data and the use case of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Pluggable storage engine architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The MySQL server uses the pluggable storage engine architecture, which enables
    storage engine loading as well as unloading from already running MySQL servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Plugging in a storage engine**: Before a storage engine can be used in the
    server, the storage engine plugin shared library has to be loaded into MySQL with
    the `INSTALL PLUGIN` SQL statement. If you create a `MYEXAMPLE` engine plugin
    that is named `MyExample` and the shared library is named `MyExample.so`, then
    you need to load them with the following statement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For installing a storage engine, the user issuing the preceding statement must
    have the `INSERT` privilege for the `mysql.plugin` table and the plugin file must
    be present in the MySQL plugin directory. The shared library also must be present
    in the MySQL server plugin directory given in the `plugin_dir` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unplugging a storage engine**: Before unplugging a storage engine, make sure
    that no tables are using the storage engine. If a storage engine is unplugged
    and is needed by any existing tables, the tables become inaccessible and will
    only be present on disk as applicable. If you unplug the `MYEXAMPLE` engine plugin
    named `MyExample` then execute the following statement for unplugging the storage
    engine:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The common database server layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MySQL pluggable storage engine is responsible for executing I/O operations
    on the actual data and also to cater to the specific application needs that includes
    enabling and enforcing the required features whenever required. Using a specific
    or single storage engine will more likely result in more efficiency and higher
    database performance because the engine enables the features only needed for a
    particular application, and resulting in less system overhead on the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'A storage engine supports the following unique infrastructure components or
    keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Concurrency**: Some applications have granular lock levels (such as row-level
    locks) requirements more than others. Overall performance and overhead due to
    locking can be affected by choosing the right/wrong locking strategy and this
    also includes multi-version concurrency control or snapshot read capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transaction support**: Very well-defined requirements exist, such as `ACID`
    compliance and more if the application needs transactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Referential integrity**: The server can enforce relational database referential
    integrity using `DDL` -defined foreign keys if required..'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physical storage**: This includes everything from the page size of tables
    and indexes and also includes the format used for storing data on a physical disk
    as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Index support**: This includes indexing strategies based on the application
    needs, as each of the storage engines have their own indexing methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory caches**: The caching strategies based on the application needs, as
    each of the storage engines have their own caching methods along with common memory
    caches across all the storage engines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance aids**: This involves bulk insert handing, database check pointing,
    multiple I/O threads for parallel operations, thread concurrency, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Miscellaneous target features**: This may includes support for security restrictions
    on certain data manipulation operations, geospatial operations, and other similar
    features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the preceding infrastructure components are designed to support a specific
    set of features for a particular application's needs and so it is very important
    to understand the application requirement very carefully and select the right
    storage engine, as it may impact on the overall system efficiency and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the storage engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you create new table using the `CREATE TABLE` statement, you can specify
    which engine to be used for the table with the `ENGINE` table option. If you do
    not specify the `ENGINE` table option then the default storage engine will be
    used instead. `InnoDB` is the default engine for MySQL 8.0\. You can also convert
    a table from one storage engine to another storage engine by using the `ALTER
    TABLE` statement, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The default storage engine can be set for the current session by setting the
    `default_storage_engine` variable, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The default storage engine for `TEMPORARY` tables using `CREATE TEMPORARY TABLE`
    can be set separately by setting the `default_tmp_storage_engine` variable at
    either startup or runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The MyISAM storage engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `MyISAM` storage engine uses tables having a small footprint. It has table-level
    locking implemented and so is mostly used where there are read-only or read-mostly
    data workloads, such as in data warehousing and web configurations. Each of the
    `MyISAM` tables are stored with two files on disk. The filename begins with the
    table name and its extension type, one with the `.MYD` extension for the data
    file and another with the `.MYI` extension for the index file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `MyISAM` engine, there are several startup options specified with `mysqld`
    that can change the behavior of `MyISAM` tables; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This option will set the mode in the automatic recovery of crashed tables in
    `MyISAM`.
  prefs: []
  type: TYPE_NORMAL
- en: Spaces needed for keys in `MyISAM`, `B-Tree` indexes are used by `MyISAM` tables
    and space compression is used in `String` indexes. If a string is the first part
    of the index then prefix compression is also done, which overall makes the index
    file size smaller. The prefix compression helps if many strings have a similar
    prefix. By using the table option `PACK_KEYS=1` in `MyISAM` tables, prefix compression
    can also be applied on the numbers if there are many numbers with a similar prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning is not supported for `MyISAM` tables in MySQL 8.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important tables characteristics for `MyISAM` tables are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: All data values stored have the low byte first order, which makes the data independent
    of machine and operating systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All numeric key values are stored with high byte first order, which permits
    better index compression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MyISAM` table is limited with *(2^(32))²(1.844E+19)* rows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MyISAM` table is limited to a maximum number of 64 indexes per table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MyISAM` table columns is limited to a maximum number of 16 columns per index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrent inserts are supported in `MyISAM`, if a table does not have any free
    blocks in the middle of the data files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TEXT` and `BLOB` type columns can also be indexed in `MyISAM`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In indexed columns, `NULL` values are permitted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the columns can have a different character set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also support for a true `VARCHAR` type column with a starting length stored
    of 1 or 2 byte, tables with `VARCHAR` columns with a fixed or dynamic row length,
    and `UNIQUE` constraints with an arbitrary length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`MyISAM` **table storage formats: The following three different types of
    storage formats listed are supported in `MyISAM`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Static` **table**: The default format for the tables in the `MyISAM` storage
    engine, with fixed-sized columns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dynamic` **table**: As the name suggests, the format that contains variable
    sized columns, including `VARCHAR`, `BLOB` , or `TEXT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Compressed` **table**: The table format for keeping read-only data and compressed
    formats in `MyISAM` storage engine tables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two formats, fixed and dynamic, are chosen automatically based on
    the column type used. The compressed format can be created by using the `myisampack` utility.
  prefs: []
  type: TYPE_NORMAL
- en: '**`MyISAM` table problems**: The file format has been extensively tested but
    some circumstances arise that result in corrupted database tables. Let us look
    at such circumstances and the way to recover those tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We could get corrupted tables in the event of any of the following events :'
  prefs: []
  type: TYPE_NORMAL
- en: If the `mysqld` process is killed in the middle of a write
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is an unexpected computer shutdown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is any hardware failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a table is being modified at the same time by the MySQL server and an external
    program, such as `myisamchk`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MySQL or `MyISAM` code has a software bug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the health of the table with the `CHECK TABLE` statement and attempt to
    repair any corrupted `MyISAM` table by using the `REPAIR TABLE` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also possible issue you get with `MyISAM` tables and that is tables
    are not being closed properly. In order to identify if the table is closed properly
    or not, each `MyISAM` index file keeps a counter in the header. The counter can
    be incorrect under the following circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: If a table is copied without issuing `LOCK TABLES` and `FLUSH TABLES`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL crashed before the final close during an update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mysqld` is using the table and at the same time it is modified by another
    program: `myisamcheck --recover` or `myisamchk --update-state`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MEMORY storage engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `MEMORY` storage engine, also previously known as the `HEAP` engine, keeps
    data in `RAM`, which provides faster data access. It is mostly used in quick lookups
    of non-critical data environments. It creates special-purpose tables with contents
    stored in memory but the data is vulnerable to crashes, power outages, and hardware
    issues. Therefore, these tables are used in temporary work areas or possibly using
    read only data that is cached after the data is pulled from other tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should choose whether use `MEMORY` or `NDB Cluster.` You should check if
    the application is required for important, highly available, or frequently updated
    data and consider whether `NDB Cluster` is the better choice or not. `NDB Cluster`
    provides the same features as the `MEMORY` engine, but with higher performance
    levels and additional features not provided by `MEMORY` engine. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: Low contention between clients by multiple thread operations and row-level locking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalability with statements mixes, including writes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data durability; it supports optional disk-backed operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared-nothing architecture, providing multiple-host operations without a single
    point of failure, enabling 99.999% availability for the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic data distributions across nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for variable length data types, including `BLOB` and `TEXT`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partitioning** is not supported in `MEMORY` tables.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance** depends on how busy the server is and the effect of single
    thread execution with table lock overhead during updates processing. The table
    locking during updates processing causes a slowdown of concurrent usage from multiple
    sessions on `MEMORY` tables.'
  prefs: []
  type: TYPE_NORMAL
- en: '**MEMORY tables characteristics**: Table definitions are stored on the MySQL
    data dictionary and do not create any files on the disk. The following are the
    table feature highlights:'
  prefs: []
  type: TYPE_NORMAL
- en: 100% dynamic hashing for inserts and space is allocated in small blocks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No extra key space or overflow area or extra space for free lists is required.
    Reuse of deleted rows when new records inserted by putting rows in linked lists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed length row-storage format, `VARCHAR` , is stored with fixed length. Cannot
    store `BLOB` or `TEXT` columns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AUTO_INCREMENT` columns are supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Indexing** in `HASH` and `BTREE` types are supported by the `MEMORY` storage
    engine. `MEMORY` tables have a maximum of 64 indexes per table, a maximum of 16
    columns per index and a maximum key length of 3,072 bytes. `MEMORY` tables also
    can have `non-unique` keys.'
  prefs: []
  type: TYPE_NORMAL
- en: '**User created and temporary tables**: Internal temporary tables are created
    by the server on the fly while processing queries. Two types of tables differ
    in storage conversion, where the `MEMORY` tables are not subject to conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: When an internal temporary table becomes too large, it is converted to on-disk
    storage by the server automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User created `MEMORY` tables are never converted by the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data loading can be performed using the `--init-file` option, using `INSERT
    INTO ... SELECT` or `LOAD DATA INFILE` statements from any persistence data source
    if required.
  prefs: []
  type: TYPE_NORMAL
- en: The CSV storage engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This storage engine stores data in the form of comma-separated values in text
    files. The engine is always compiled into the MySQL server and the source can
    be examined from the `storage/csv` directory of your MySQL distribution.
  prefs: []
  type: TYPE_NORMAL
- en: The data file created by the server begins with the given table and the extension
    of `.CSV`. The data file is a plain text file containing data in the comma-separate
    values format.
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL server creates a corresponding metafile along with a `CSV` table that
    stores information about the state of the table and the count for the rows that
    exists in the table. The metafile is also stored with the table name at the beginning
    with the `.CSM` extension.
  prefs: []
  type: TYPE_NORMAL
- en: '**Repairing and checking** `CSV` **tables**: The storage engine supports `CHECK`
    and `REPAIR` statements to verify and possibly repair a damaged `CSV` table. You
    can use the `CHECK TABLE` statement to verify or validate the table and use the `REPAIR
    TABLE` statement to repair a table that copies valid rows from an existing `CSV`
    data file and replaces an existing file with newly copied/recovered rows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During repair, only rows from the `CSV` data file to the first damaged row gets
    copied to the new table or copied data file. The rest of the rows after the damaged
    row gets removed from the table, including valid rows, so I suggest that you take
    enough back up of the data file prior to proceeding with the repair.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing or partitioning is not supported in the `CSV` storage engine and all
    the tables created with the `CSV` storage engine must have the `NOT NULL` attribute
    on all the columns.
  prefs: []
  type: TYPE_NORMAL
- en: The ARCHIVE storage engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ARCHIVE` storage engine creates special-purpose tables that are used for
    storing huge amounts of unindexed data with a very small footprint.
  prefs: []
  type: TYPE_NORMAL
- en: When the `ARCHIVE` table is created, it begins with the table name and ends
    with the `.ARZ` extension. During optimization operations, a file with an `.ARN`
    extension may appear.
  prefs: []
  type: TYPE_NORMAL
- en: '`The AUTO_INCREMENT` column attribute is supported by the engine. It also supports
    `INSERT`, `REPLACE`, `SELECT`, and `BLOB` columns (all but spatial data types)
    but it does not support `DELETE,` `UPDATE`, `ORDER`, or `BY` operations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Partitioning** is not supported by the `ARCHIVE` storage engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Storage**: The engine uses lossless data compression with `zlib` and the
    rows get compressed as inserted. It supports the `CHECK TABLE` operation. Several
    types of insertion are used in the engine:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INSERT` statement sends rows into a compression buffer, and the buffer gets
    flushed as necessary. Insertion in the compression buffer is protected by the
    lock and flush will only occur if `SELECT` is requested.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once completed a bulk buffer can be seen. It can only be seen if any other inserts
    occur at the same time. Here flush will not occur upon `SELECT`, unless while
    loading any normal insert.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Retrieval**: After retrieval, rows gets uncompressed as requested and it
    does not use any row cache. A complete table scan is performed for the `SELECT`
    operation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SELECT` checks how many rows are available currently and reads only that number
    of rows. It is performed as a consistent read operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of rows reported by `SHOW TABLE STATUS` is always accurate for the
    `ARCHIVE` tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `OPTIMIZE TABLE` or `REPAIR TABLE` operations to achieve better compression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The BLACKHOLE storage engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `BLACKHOLE` storage engine acts as a black hole. It accepts data but does
    not store it and a query always returns an empty result.
  prefs: []
  type: TYPE_NORMAL
- en: The server only adds the table definition in the global data dictionary when
    you create a `BLACKHOLE` table and no files are associated with the table.
  prefs: []
  type: TYPE_NORMAL
- en: All kinds of **indexing** is supported in the `BLACKHOLE` storage engine and
    so the same can be included in the table definition.
  prefs: []
  type: TYPE_NORMAL
- en: '**Partitioning** is not supported in the `BLACKHOLE` storage engine.'
  prefs: []
  type: TYPE_NORMAL
- en: Insertion to the table does not store any data but if binary logging is enabled
    for statements, then the statements are logged and replicated to the slave servers.
    Such a mechanism is useful as a filter or repeater.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BLACKHOLE` storage engine has the following possible uses:'
  prefs: []
  type: TYPE_NORMAL
- en: Dump file syntax verification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overhead measurement using binary logging enabled or disabled with a `BLACKHOLE`
    performance comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can also be used for finding any performance bottlenecks, except for the
    storage engine itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto increment columns**: As the engine is a no-op engine, it will not increment
    any field values but it has implications in the replication, which can be very
    important. Consider a scenario that has the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: The master server has a `BLOCKHOLE` table with an auto increment field with
    a primary key
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The same table exists on the slave server but uses the `MyISAM` engine
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insertion is performed into the master server's table without setting any auto
    increment value in the `INSERT` statement or using the `SET INSERT_ID` statement
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the preceding scenario, the replication will fail on the primary key column
    with a duplicate entry.
  prefs: []
  type: TYPE_NORMAL
- en: The MERGE storage engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `MERGE` storage engine, known also as the `MRG_MyISAM` engine, is collection
    of similar tables that can be used as one table instead. Here, "similar" means
    that all the tables have similar column data types and indexing information. It
    is not possible to merge tables with the columns listed in a different order or
    to have the same data types in respective columns or have indexing in a different
    order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the list of differences in tables that will not restrict a
    merge:'
  prefs: []
  type: TYPE_NORMAL
- en: Names of respective columns and indexes can be different.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments in between tables, columns, and indexes can be different.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AVG_ROW_LENGTH`, `MAX_ROWS` , or `PACK_KEYS` table options can be different.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a `MERGE` table is created, MySQL also creates a `.MRG` file on the disk
    with the names of underlying `MyISAM` tables being used as one. The format of
    the table is stored in the MySQL data dictionary and the underlying tables do
    not require to be in the same database as the `MERGE` table.
  prefs: []
  type: TYPE_NORMAL
- en: Having privileges are a must for `SELECT`, `UPDATE`, and `DELETE` on the `MyISAM`
    tables that are being mapped with the `MERGE` table and so `SELECT`, `INSERT`,
    `UPDATE`, and `DELETE` statements on the `MERGE` table can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the `DROP TABLE` statement on the `MERGE` table will drop only the
    specification for the `MERGE` and nothing is impacted on the underlying tables.
  prefs: []
  type: TYPE_NORMAL
- en: Using `MERGE` tables has the following security issues. If the user has access
    to the `MyISAM` table `t1`, then the user can create the `MERGE` table `m1` that
    can access `t1`. Now, if the user's privileges on the table `t1` are revoked,
    the user can still continue accessing table `t1` by using table `m1`.
  prefs: []
  type: TYPE_NORMAL
- en: The FEDERATED storage engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FEDERATED` storage engine can link many separate physical MySQL servers
    into one logical database and so it can let you access data from a remote MySQL
    server without using either replication or cluster technology.
  prefs: []
  type: TYPE_NORMAL
- en: When we query to the local `FEDERATED` table, that automatically pulls the data
    from the remote federated tables and the data is not required to be stored on
    local tables.
  prefs: []
  type: TYPE_NORMAL
- en: The `FEDERATED` storage engine is not supported by default in the MySQL server
    but starting the server with the `--federated` option will enable the `FEDERATED`
    engine option.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `FEDERATED` table is created the table definition is the same as other
    tables, but the physical storage of the associated data is handled on the remote
    server instead. The `FEDERATED` table consists of the following two elements:'
  prefs: []
  type: TYPE_NORMAL
- en: A **remote server** with a database table consisting of a table definition and
    the associated table data. This type of table can be any supported by the remote
    server that includes `MyISAM` or `InnoDB` as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **local server** with a database table consisting of a table definition the
    same as the respective table on the remote server. The table definition is stored
    in the data dictionary and no associated data file on the local server is stored.
    Instead, in addition to the table definition, it keeps a connection string that
    is pointing to the remote table itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the flow of information between the local and remote server
    when a SQL statement is executed on the `FEDERATED` table:'
  prefs: []
  type: TYPE_NORMAL
- en: The engine checks each of the columns the table has and builds an appropriate
    SQL statement that refers to the remote table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The MySQL client API is used for sending the SQL statement to the remote server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The statement is processed by the remote server and the respective result is
    retrieved by the local server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The EXAMPLE storage engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `EXAMPLE` storage engine is only a stub engine and the purpose of the engine
    is to provide examples in the MySQL source code, which helps developers to write
    new storage engines.
  prefs: []
  type: TYPE_NORMAL
- en: To work with the `EXAMPLE` engine source code, look at the `storage/example`
    directory of the MySQL source code distribution download.
  prefs: []
  type: TYPE_NORMAL
- en: No files are created if the table is created with the `EXAMPLE` engine. Data
    cannot be stored in the `EXAMPLE` engine and it returns empty results.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing and partitioning is not supported in the `EXAMPLE` storage engine.
  prefs: []
  type: TYPE_NORMAL
- en: The InnoDB storage engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`InnoDB` is the most general-purpose storage engine and is the default engine
    in MySQL 8, providing high reliability and high performance .'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the key advantages offered by the `InnoDB` storage engine:'
  prefs: []
  type: TYPE_NORMAL
- en: Its `DML` operations follows the `ACID` model and transactions have commit,
    rollback, and crash-recovery features to protect user data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Oracle-style` gives consistent reads and row level locking increases the performance
    of multi-user concurrency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each `InnoDB` table has a primary key index, known as the clustered index, that
    arranges data on the disk in order to optimize queries based on primary key and
    minimizes I/O during primary key lookups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By supporting foreign keys, inserts, deletes, and updates are checked, ensuring
    consistency across different tables in order to maintain data integrity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the key benefits of using `InnoDB` tables:'
  prefs: []
  type: TYPE_NORMAL
- en: If the server crashes due to any hardware or software issue, regardless of what
    changes were being processed in the server at that time, you're not required to
    do anything special after restarting the server. It has a crash recovery system
    that takes care of changes that were committed during the crash of the server.
    It will go to those changes and start where the processing was left off.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The engine has it's own buffer pool used for caching table and indexing data
    to memory based on data accessed. Frequently used data is fetched directly from
    the cache memory and so it speeds up processing. In dedicated servers, it takes
    up to 80% of physical memory assigned to be used in the buffer pool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting related data to tables using foreign key setup enforces referential
    integrity which prevents inserting any unrelated data to a secondary table without
    the respective data in the primary table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case of corrupt data in the memory or disk, the checksum mechanism gives
    an alert about the corrupt data before we get to use it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change buffering automatically optimizes `Insert`, `Update`, and `Delete`. `InnoDB`
    also allows concurrent read and write access to the same table and caching data
    changes to streamline the disk I/O.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the same data rows are accessed from the table repeatedly, the Adaptive
    Hash Index feature makes the lookups faster and gives performance benefits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compression is allowed on tables and associated indexes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring on internal workings and performance details of the storage engine is
    easy by querying `INFORMATION_SCHEMA` or `Performance Schema` tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let us look at each of the areas of the storage engine where `InnoDB` is
    enhanced or optimized to provide very efficient and enhanced performance.
  prefs: []
  type: TYPE_NORMAL
- en: ACID model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ACID` model is a group of database design principles with an emphasis on
    reliability, which is most important for mission critical applications and business
    data.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL has components such as the `InnoDB` storage engine that closely adhere to
    the `ACID` model. Therefore, data is safe and not corrupted, even in exceptional
    cases of hardware malfunctions or software crashes.
  prefs: []
  type: TYPE_NORMAL
- en: With MySQL 8, `InnoDB` supports atomic `DDL`, ensuring that the `DDL` operations
    are fully committed or rolled back, even if the server is halted while performing
    the operation. Now `DDL` logs can be written to the `mysql.innodb_ddl_log` configuration
    for the data dictionary tables, enabling the `innodb_print_ddl_logs` configuration
    option to print `DDL` recovery logs to `stderr`.
  prefs: []
  type: TYPE_NORMAL
- en: Multiversioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: InnoDB is a multiversioned storage engine. That means it has the capability
    to keep old versions of changed row data information and support transnational
    features, such as concurrency and roll back. The information is stored in the
    tablespace, data structure, and named rollback segment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Internally, for each of the rows getting stored in the database, `InnoDB` creates
    three fields: 6-byte `DB_TRX_ID`, 7-byte `DB_ROLL_PTR` (called a roll pointer)
    and 6-byte `DB_ROW_ID`. With these fields, `InnoDB` creates clustered indexes
    to keep the information of changed row data in the database.'
  prefs: []
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will give a brief introduction to the major components
    of the `InnoDB` architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Buffer pool**: Area of main memory where tables and indexing data are cached
    to speed up processing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Change buffer**: Special data structure where changes to secondary index
    pages are cached'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adaptive Hash Index**: Enables in-memory database, such as lookups, operations
    on systems with balanced and appropriate combinations of the buffer pool''s memory
    and workload'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redo log buffer**: Memory area where data is held to be written on the redo
    log'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System tablespace**: Storage area where the `doublewrite` buffer, undo logs,
    and the change buffer, prior to the MySQL 8 data dictionary information, are stored'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Doublewrite buffer**: Storage area in the system tablespace where pages are
    written that are flushed from the buffer pool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Undo logs**: Collection of undo log records which are associated with any
    single transaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File-per-table tablespaces**: Single-table tablespace added to its own data
    file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**General tablespaces**: Shared tablespace created by the `CREATE TABLESPACE`
    syntax'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Undo tablespace**: One or more files with undo logs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Temporary tablespace**: Utilized for non-compressed temporary tables and
    their related objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redo log**:Disk-based data structure used for correcting incomplete transaction
    data during crash recovery'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With MySQL 8, the `InnoDB` storage engine utilizes the global MySQL data dictionary
    and not its own storage engine-specific data dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Locking and transaction model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section gives brief information on locking used by `InnoDB` and the transaction
    model implemented by `InnoDB`. `InnoDB` uses the following different lock types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shared and exclusive locks**: Two types of standard row-level locking are
    implemented. A shared lock allows you to read a row to different transactions;
    an exclusive lock holds to update or delete a row and does not allow you to even
    read the row to any different transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intention locks**: Table level locks to support multiple granularity locking
    by which `InnoDB` practically maintains the coexistence of row-level locks and
    entire table-level locks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Record locks**: Index record lock that prevents any other transaction to
    insert, update, or delete the record.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gap locks**: Lock applies on a gap (range) between index records.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Next-key locks**: Combination of index record lock plus gap lock on the gap
    for the preceding index record.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Insert intention locks**: Type of gap lock which is set by `INSERT` operation
    just before the row insertion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AUTO-INC locks**: Special table-level lock for inserting records with the `AUTO_INCREMENT`
    column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Predicate locks for spatial indexes**: Lock on spatial index, enabling support
    for isolation levels in tables with spatial indexes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal of following the transaction model is to unite traditional two-phase
    locking with the best of the multiversioning database properties. Row-level locking
    is performed and queries are run with nonlocking consistent reads. `InnoDB` takes
    care of transaction isolation levels, autocommit, rollback and commit, and locking
    reads. It allows nonlocking consistent reads as applicable. `InnoDB` also uses
    a mechanism to avoid phantom rows and a configuration to support automatic deadlock
    detection.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section provides brief information about the configuration and procedures
    used in the `InnoDB` initialization startup for different `InnoDB` components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`InnoDB` **startup configuration**: This involves specifying startup options,
    log file configuration, storage considerations, system tablespace data files,
    undo tablespaces, temporary tablespaces, page sizes, and memory configurations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InnoDB` **for read-only operation**: This enables a MySQL instance for read-only
    operation, using the `--innodb-read-only=1` option, which is very helpful when
    using read-only media such as `CD` or `DVD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InnoDB` **buffer pool configuration**: Configures the buffer pool size, multiple
    instances, flushing, and monitoring'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InnoDB` **change buffering**: Configures the change buffer options for secondary
    index caching'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thread concurrency for** `InnoDB`: Concurrent thread count limit configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The number of background** `InnoDB` **I/O threads:** Configures the number
    of background threads servicing I/O read/write operations on data pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using asynchronous I/O on Linux**: A configuration to use native asynchronous
    I/O subsytems on Linux'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The** `InnoDB` **master thread I/O rate**: Configures overall I/O capacity
    for a master thread working in the background, responsible for multiple tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spin lock polling**: Configures a spin wait delay period to control the maximum
    delay for frequent polling between multiple threads requesting to acquire `mutexes`
    or `rw-locks`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InnoDB` **purge scheduling**: Configures purge threads for applicable scalability'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimizer statistics for** `InnoDB`: Configures persistent and non-persistent
    optimizer statistics parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The merge threshold for index pages**: Configures `MERGE_THRESHOLD` to reduce
    merge-split behavior'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enabling automatic configuration for** **a dedicated MySQL Server**: Configures
    the dedicated server option `--innodb_dedicated_server` , which makes automatic
    configuration for the buffer pool size and log file size'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tablespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section provides brief information on tablespaces and operations related
    to tablespaces performed in `InnoDB`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resizing the `InnoDB` system tablespace**: Increasing and decreasing the
    size of the system tablespace with configuration while starting/restarting the
    MySQL server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C**hanging the number or size of `InnoDB` redo log files**: Configures `innodb_log_files_in_group`
    and `innodb_log_file_size` values respectively in `my.cnf` prior to starting/restarting
    the MySQL server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using raw disk partitions for the system tablespace**: Configures the raw
    disk partitions to be used as data files in the system tablespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InnoDB` **File-Per-Table tablespaces**: The feature `innodb_file_per_table`
    enabled by default which ensures that each of the tables and associated indexes
    are stored in a separate `.idb` data file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuring undo tablespaces**: A configuration to set the number of undo
    tablespaces where an undo log resides.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Truncating undo tablespaces**: Configures `innodb_undo_log_truncate` to enable
    truncating undo tablespace files exceeding the maximum limit defined in `innodb_max_undo_log_size`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InnoDB` **general tablespaces**: A shared tablespace created using the `CREATE
    TABLESPACE` statement. It is similar to a system tablespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InnoDB` **tablespace encryption**: Support for data encryption in tables stored
    as file-per-table tablespaces which use the `AES` block-based encryption algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tables and indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section provides brief information on `InnoDB` tables and indexes and
    their related operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating `InnoDB` tables**: Creates tables using the `CREATE TABLE` statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The physical row structure of an** `InnoDB` **table**: Depends on the specified
    row format during the table creation. If not specified, uses the default, `DYNAMIC`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Moving or copying `InnoDB` tables**: Different techniques for moving or copying
    some or all `InnoDB` tables to a different instance or server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Converting tables from `MyISAM` to `InnoDB`**: Considers guidelines and tips
    while converting `MyISAM` tables to `InnoDB` tables, except a partitioned table,
    which is not supported with MySQL 8.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AUTO_INCREMENT` **handling in** `InnoDB`: Configures the mode for `AUTO_INCREMENT`
    with the `innodb_autoinc_lock_mode` parameter as 0,1, and 2 for traditional, consecutive,
    or interleaved, respectively, where interleaved is the default mode from MySQL
    8.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limits on `InnoDB` tables**: A table can contain a maximum of 1,017 columns,
    a maximum of 64 secondary indexes, and several other limits defined based on the
    page size, table size, and data-row formats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clustered and secondary indexes**: `InnoDB` uses a special index called a
    clustered index. The rest of the indexes are called secondary indexes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The physical structure of `InnoDB` index**: For spatial indexes, `InnoDB`
    uses the `R-tree` data structure, a specialized data structure. For rest of the
    indexes, the `B-tree` data structure is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sorted index builds**: Bulk load when creating or rebuilding indexes for
    inserts. They are known as sorted index builds, and are not supported in spatial
    indexes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InnoDB` `FULLTEXT` **indexes**: Created for text-based columns - `char`, `varchar`,
    or `text` type. They help to speed up queries and searching operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: INFORMATION_SCHEMA tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section provides usage examples for `InnoDB` `INFORMATION_SCHEMA` tables
    and related information.
  prefs: []
  type: TYPE_NORMAL
- en: It provides metadata, statistics, and status information about the different
    aspects of the `InnoDB` storage engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of `InnoDB` `INFORMATION_SCHEMA` tables can be retrieved by executing
    the `SHOW TABLES` statement on the `INFORMATION_SCHEMA` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Tables about compression**: The number of compression operations and the
    amount of time spent for compression-related information provided in the `INNODB_CMP` and `INNODB_CMP_RESET`
    tables. Memory allocation during compression is provided in the `INNODB_CMPMEM`
    and `INNODB_CMPMEM_RESET` tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transaction and locking information**: `INNODB_TRX` has information on transactions
    currently executing and the `data_locks` and `data_lock_waits` tables from the `Performance
    Schema` table give information about the locks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Schema object tables**: This provides metadata information about the `InnoDB`
    schema objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FULLTEXT` **index tables**: This provides metadata information about `FULLTEXT`
    indexes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Buffer pool tables**: This provides status information and metadata about
    the pages in the buffer pool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metrics table**: This provides performance and resource related information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Temporary table information table**: This provides metadata information about
    all users and system-created temporary tables currently active in an `InnoDB`
    instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Retrieving `InnoDB` tablespace metadata**: This provides metadata information
    about all the types of tablespaces in an `InnoDB` instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new view, `INNODB_TABLESPACES_BRIEF`, has been added to provide the name,
    path, flag, space, and space type data.
  prefs: []
  type: TYPE_NORMAL
- en: A new table, `INNODB_CACHED_INDEXES`, has been added to provide the number of
    index pages cached in the buffer pool for each index.
  prefs: []
  type: TYPE_NORMAL
- en: Memcached plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL 8 provides you with the `InnoDB` memcached plugin named `daemon_memcached`,
    which can help us in managing data easily. It will automatically store and retrieve
    data from `InnoDB` tables and provide `get`, `set`, and `incr` operations that
    remove performance overhead by skipping SQL parsing, which speeds up data operations.
    The `memcached` plugin uses the integrated `memcached` daemon that automatically
    retrieves and stores data from and to the `InnoDB` table, enabling the MySQL server
    to send data quickly to the `key-value` store.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the major benefits of using the `InnoDB memcached` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: Accesses the `InnoDB` storage engine directly, reducing parsing and planning
    SQL overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`memcached` uses the same process space as the MySQL server, reducing network
    overhead'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data written or requested in the `memcached` protocol is transparently written
    or queried from `InnoDB` tables, reducing having to go through SQL layer overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifies application logic by automatically transfering between disk and memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MySQL database stores data so that it is protected against corruption, crashes,
    or outages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensures high availability using the `daemon_memcached` plugin on the master
    server and MySQL replication in combination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeated data requests are cached using the `InnoDB` buffer pool, providing
    high speed processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the data is stored in the `InnoDB` tables, the data consistency is enforced
    automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `InnoDB memcached` plugin supports multiple get operations (fetching multiple
    key/value pairs in a single `memcached` query) and range queries.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom storage engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL AB introduced pluggable storage engine architecture in MySQL 5.1 and all
    later versions, including MySQL 8, have taken advantage of the flexible storage
    engine architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The storage engine pluggable architecture provides the capability to create
    and add new storage engines without recompiling the server, adding directly to
    a running MySQL server. The architecture makes it very easy to develop and deploy
    new storage engines to MySQL 8.
  prefs: []
  type: TYPE_NORMAL
- en: When developing new storage engine, it is required to take care of all the components
    that work for and with storage engines. These include installation handlers, operations
    on table such as creating, opening, and closing, `DML`, indexing, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will cover how you can start developing a new storage engine
    on a high-level basis with reference to the MySQL documentation provided in the
    development community. The creation of a custom storage engine requires a working
    knowledge of development with `C` and `CPP`, and compilation with `cmake` and
    `Visual Studio`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating storage engine source files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to implement a new storage engine is to begin by copying and
    modifying the `EXAMPLE` storage engine. The files `ha_example.cc` and `ha_example.h` can
    be found in the `storage/example` directory of the MySQL source distribution.
  prefs: []
  type: TYPE_NORMAL
- en: When copying the files, change the names from `ha_example.cc` and `ha_example.h` to
    something appropriate to your storage engine, such as `ha_foo.cc` and `ha_foo.h`.
  prefs: []
  type: TYPE_NORMAL
- en: After you have copied and renamed the files, you must replace all instances
    of `EXAMPLE` and `example` with the name of your storage engine.
  prefs: []
  type: TYPE_NORMAL
- en: Adding engine-specific variables and parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A plugin can implement status and system variables and in this section we have
    covered the changes to variables and parameters with appropriate values and data
    types.
  prefs: []
  type: TYPE_NORMAL
- en: The server plugin interface enables plugins to expose status and system variables
    using the `status_vars` and `system_vars` members of the general plugin descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: '`status_vars` is a member of the general plugin descriptor. If the value is
    not 0, then it points to an array of the `st_mysql_show_var` structure where each
    of them describe one status variable followed by a structure with all the members
    set to 0\. The definition for the `st_mysql_show_var` structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When the plugin is installed, the plugin name and the name value are joined
    with an underscore to form the name displayed by the `SHOW STATUS` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list shows the permissible status variable type values and what
    the corresponding variable should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SHOW_BOOL`: This is a pointer to the `boolean` variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHOW_INT`: This is a pointer to the `integer` variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHOW_LONG`: This is a pointer to the long `integer` variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHOW_LONGLONG`: This is a pointer to the `longlong integer` variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHOW_CHAR`: This is a `String` index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHOW_CHAR_PTR`: This is a pointer to `String` indexes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHOW_ARRAY`: This is a pointer to another `st_mysql_show_var array`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHOW_FUNC`: This is a pointer to a function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHOW_DOUBLE`: This is a pointer to a `double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All session and global system variables have to be published to `mysqld` before
    they are used. This is precisely done by constructing a `NULL` terminated array
    of the variables and linking to it in the plugin public interface.
  prefs: []
  type: TYPE_NORMAL
- en: All mutable and plugin system variables are stored internally in the `HASH` structure.
  prefs: []
  type: TYPE_NORMAL
- en: The display of the server command-line help text is generated by compiling `DYNAMIC_ARRAY` of
    all the relevant variables, sorting and iterating through them to display each
    option.
  prefs: []
  type: TYPE_NORMAL
- en: During the plugin installation process, the server processes command-line options,
    immediately after the plugin has been successfully loaded but the plugin initialization
    function is yet to be called.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins loaded at `runtime` do not benefit from any configuration options and
    must have usable defaults. Once they are installed, they are loaded at `mysqld`
    initialization time and configuration options can be set at the command line or
    within `my.cnf`.
  prefs: []
  type: TYPE_NORMAL
- en: The `thd` parameter should be considered as read-only in plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the handlerton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The handlerton (the short form of handler singleton) defines the storage engine.
    It contains method pointers to methods applied to the storage engine as a whole,
    instead of methods that work on a per-table basis. Examples of such methods include
    transaction methods which handle commits and rollbacks operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example from the `EXAMPLE` storage engine is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There are 30 `handlerton` elements, only few of which are mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: Handling handler installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the first method call in your storage engine required for creating a
    new handler instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the `handlerton` is defined in the source file, there must be the instantiation
    method defined in method header. The following is an example from the `CSV` engine
    displaying the instantiation method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding example, the method accepts a pointer to the
    table. The handler is responsible for managing and returning the handler object. After
    the method header definition, the method is named with the method pointer in the
    `create()` `handlerton` element. This identifies the method as being responsible
    for generating new handler instances when requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'The instantiation method for the `MyISAM` storage engine is shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Defining filename extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Storage engines must provide a list of extensions used by the storage engine
    associated to a given table, its data, and indexes to the MySQL server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extensions should be given in the form of a null-terminated string array and
    the same is returned when the [`custom-engine.html#custom-engine-api-reference-bas_ext
    bas_ext()`] method is called, as shown in the following block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: By providing extension information, you can also skip implementing `DROP TABLE` functionality,
    as the MySQL server will implement the same by closing the table and deleting
    all files with the extensions specified.
  prefs: []
  type: TYPE_NORMAL
- en: Creating tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After handler instantiation, the creation of the table method should be followed.
    The storage engine must implement the [`custom-engine.html#custom-engine-api-reference-create
    create()`] method, as shown in the following block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding displayed method should create all the necessary files but it
    does not open the table. The MySQL server will call separately for the table to
    be opened.
  prefs: []
  type: TYPE_NORMAL
- en: The `*name` parameter is for passing the name of the table and the `*form` parameter
    is for passing the `TABLE` structure. The table structure defines the table and
    matches the contents of `tablename.frm`. Storage engines must not modify the `tablename.frm` file
    as that will result in errors or unpredictable issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `*info` parameter is structure with information on the `CREATE TABLE` statement.
    It is used to create the table and the structure is defined in the `handler.h`
    file. The following is the structure for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Storage engines can ignore the contents of `*info` and `*form` because the creation
    and the initialization of the data files is only really required when used by
    the storage engine.
  prefs: []
  type: TYPE_NORMAL
- en: Opening a table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prior to any read or write operations performed on any table, the MySQL server
    calls the [`custom-engine.html#custom-engine-api-reference-open handler::open()`]
    method to open the table index and data files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter is for the name of the table being opened. The second parameter
    is for the file operation to take. The values are defined in `handler.h`: `O_RDONLY
    - Open read only`, `O_RDWR - Open read/write`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final option dictates if the handler should check for a lock on the table
    before opening. The following options are available to choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The typical storage engine will implement some form of shared access control
    in order to prevent file corruption in a multi-threaded environment. For example,
    see the `get_share()` and `free_share()` methods of `sql/example/ha_tina.cc` for implementing
    file locking.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing basic table scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic storage engines implement a read-only level of table scanning
    and they might be used to support SQL queries for requesting information from
    the logs and other data files that are populated outside of MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the methods is the first step towards the creation of
    advanced storage engines. The following shows the method calls made during a nine-row
    table scan of the `CSV` engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following methods can be implemented to take care of specific operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementing the** `store_lock()`: This method can modify the lock level,
    ignoring or adding locks for many tables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementing the** `external_lock()`: This method is called when the `LOCK
    TABLES` statement is issued'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementing the** `rnd_init()`: This method is used in table scanning for
    resetting counters and pointers at the start of a table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementing the** `info(uinf flag)`: This method is used to provide extra
    table information to the optimizer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementing the** `extra()`: This method is used to provide extra hints
    information to the storage engine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementing the** `rnd_next()`: This method is called on each row of scanning
    until `EOF` is reached or the search condition is satisfied'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closing a table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the MySQL server has completed all the requested operations with the table,
    it will call the `custom-engine.html#custom-engine-api-reference-close close()` method.
    It will close the file pointers and release all the related resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Storage engines using the shared access methods are seen in the `CSV` engine. Other
    example engines must remove the same from the shared structure, as displayed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Storage engines use their own share management systems. They should use the
    required methods in order to remove the handler instance from the share for the
    respective table opened in their handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your storage engine is compiled as a shared object, during loading if you
    get an error such as `undefined symbol: _ZTI7handler`, then make sure you compile
    and link your extension using the same flags as the server uses. The usual reason
    for this error is that LDFLAGS are missing the *-fno-rtti* option.'
  prefs: []
  type: TYPE_NORMAL
- en: Reference for advanced custom storage engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have gone through the preceding sections in detail, giving high-level information
    for custom storage engine components and the required changes. For implementing
    `INSERT`, `UPDATE`, `DELETE`, indexing, and so on, in a custom storage engine,
    requires a working knowledge of development with `C/CPP` and compilation with
    `cmake` and `Visual Studio`. For advanced development for the custom storage engines,
    please refer to the detailed information given at [https://dev.mysql.com/doc/internals/en/custom-engine.html](https://dev.mysql.com/doc/internals/en/custom-engine.html)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you have learned the different database engines available in MySQL 8
    and we learned why we should care about storage engines and available storage
    engine options in MySQL 8\. We covered in detail the`InnoDB` storage engine and
    related important features already provided within the `InnoDB` storage engine.
    Now you are practically able to create a custom storage engine as per the system
    requirement and make it pluggable in MySQL 8\. An important aspect was to choose
    a suitable storage engine for your system, which is covered detail.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about how indexing works in MySQL 8, the
    new features introduced related to indexing, the different types of indexing,
    and how to use indexing on your tables. Along with that, a comparison will also
    be provided along with in-depth knowledge of various ways of index implementation.
  prefs: []
  type: TYPE_NORMAL
