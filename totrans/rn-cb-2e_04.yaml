- en: Implementing Complex User Interfaces - Part II
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will cover more recipes on building UIs with React Native. We'll
    get our first look at linking to other applications and websites, handling a change
    in device orientation, and how to build a form for collecting user input.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with universal applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting orientation changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a WebView to embed external websites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking to websites and other applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a form component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with universal applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the benefits of using React Native is its ability to easily create universal applications.
    We can share a lot of code between phone and tablet applications. The layouts
    might change, depending on the device, but we can reuse pieces of code for both
    types of device across layouts.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will build an app that runs on phones and tablets. The tablet
    version will include a different layout, but we will reuse the same internal components.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will show a list of contacts. For now, we will load the
    data from a `.json` file. We will explore how to load remote data from a **Representational
    State Transfer** (**REST**) API in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's open the following URL and copy the generated JSON to a file called `data.json` at
    the root of the project. We will use this data to render the list of contacts.
    It returns a JSON object of fake user data at [http://api.randomuser.me/?results=20](http://api.randomuser.me/?results=20).
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a new app called `universal-app`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s open `App.js` and import the dependencies we''ll need in this app, as
    well as our `data.json` file we created in the previous *Getting ready *section.
    We''ll also import a `Device` utility from `./utils/Device`, which we will build
    in a later step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re going to create the main `App` component and its basic layout.
    This top-level component will decide whether to render the phone or tablet UI. We
    are only rendering two `Text` elements. The `renderDetail` text should be displayed
    on tablets only and the `renderMaster` text should be displayed on phones and
    tablets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the `App` component, we''ll add a few basic styles. The styles temporarily
    include `paddingTop: 40` so that our rendered text is not overlapped by the device''s
    system bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to run our app as it is, it will fail with an error telling us that
    the `Device` module cannot be found, so let''s create it. The purpose of this
    utility class is to calculate whether the current device is a phone or tablet,
    based on the screen dimensions. It will have an `isTablet` method and an `isPhone` method.
    We need to create a `utils` folder in the root of the project and add a `Device.js`
    for the utility. Now we can add the basic structure of the utility:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start building out the utility by creating two methods: one to get the
    dimensions in portrait and the other to get the dimensions in landscape. Depending
    on the device rotation, the values of `width` and `height` will change, which
    is why we need these two methods to always get the correct values, whether the
    device is `landscape` or `portrait`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create the two methods our app will use to determine whether the
    app is running on a tablet or a phone. To calculate this, we need to get the dimensions
    in portrait mode and compare them with the dimensions we have defined for a tablet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we open the app, we should see two different texts being rendered,
    depending on whether we''re running the app on a phone or a tablet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/4b04e46d-e2f8-4753-b51a-2a5053e3f3a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The utility works as expected! Let''s return to working on the `renderMaster`
    method of the main `App.js`. We want this method to render the list of contacts
    that live in the `data.json` file. Let''s import a new component, which we''ll
    build out in the following steps, and update the `renderMaster` method to use
    our new component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a new `UserList` folder. Inside this folder, we need to create
    the `index.js` and `styles.js` files for the new component. The first thing we
    need to do is import the dependencies into the new `index.js`, create the `UserList`
    class, and export it as the `default`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve already covered how to create a list. If you are not clear on how the
    `ListView` component works, read the *Displaying a list of items* recipe in [Chapter
    2](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml), *Creating a Simple React Native
    App*. In the constructor of the class, we will create the `dataSource` and then
    add it to the `state`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `render` method also follows the same pattern introduced in the `ListView`
    recipe, *Displaying a list of items,* from [Chapter 2](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml),
    *Creating a Simple React Native App*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we need to define the `renderContact` method to render each
    of the rows. We are using the `TouchableOpacity` component as the main wrapper,
    which will allow us to use a callback function to perform some actions when a
    list item is pressed. For now, we are not doing anything when the button is pressed.
    We will learn more about communicating between components using Redux in [Chapter
    9](769c6947-a93b-4ede-95a3-e92cb4044a5e.xhtml), *Implementing Redux*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t have a way to capitalize the texts using styles, so we need to use
    JavaScript for that. The `capitalize` function is quite simple, and sets the first
    letter of the given string to uppercase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We are almost done with this component. All that''s left are the `styles`.
    Let''s open the `/UserList/styles.js` file and add styles for the main container
    and the toolbar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, for each row, we want to render the image of each contact on the left,
    and the contact''s name and phone number on the right:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s switch over to the `App.js` file and remove the `paddingTop` property
    we used for making text legible in *step 7*; the line to be removed is shown in
    bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to run our app, we should be able to see a really nice list on the
    phone as well as the tablet, and the same component on the two different devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/3a0e3972-6f01-4526-855d-67962d131503.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are already displaying two different layouts based on the current device!
    Now we need to work on the `UserDetail` view, which will show the selected contact.
    Let''s open `App.js`, import the `UserDetail` views, and update the `renderDetail` method,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, in this recipe, we are not focusing on sending data from
    one component to another, but instead on rendering a different layout in tablets
    and phones. Therefore, we will always send the first record to the user details
    view for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things simple and to make the recipe as short as possible, for the
    user details view, we will only display a toolbar and some text showing the first
    and last name of the given record. We are going to use a stateless component here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to style this component. We want to assign three-quarters
    of the screen to the details page and one-quarter to the master list. This can
    be done easily by using flexbox. Since the `UserList` component has a `flex` property
    of `1`, we can set the `flex` property of `UserDetail` to `3`, allowing `UserDetail`
    to take up 75% of the screen. Here are the styles we''ll add to the `/UserDetail/styles.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to run our app again, we will see that on the tablet, it will render
    a nice layout showing both the list view and the detail view, while on the phone
    it only shows the list of contacts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b50ed65a-c2a9-4d6a-bb60-d8c18e038932.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `Device` utility, we imported a dependency that React Native provides
    called `Dimension` for getting the dimensions of the current device. We also defined
    a `tablet` constant in the `Device` utility, which is an object containing the `width` and `height`
    that is used with `Dimension` to calculate whether the device is a tablet or not.
    The values of this constant are based on the smallest Android tablet available
    on the market.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, we got the width and height by calling the `Dimensions.get("window")` method,
    and then we got the maximum and minimum values depending on the orientation we
    wanted.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 12*, it's important to note that we used an arrow function to define
    the `renderContact` method. Using an arrow function keeps the correct binding
    scope, otherwise, the `this` in the call to `this.capitalize` would be bound to
    the wrong scope. Check the *See also *section for more information on how both
    the `this` keyword and arrow functions work.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good explanation of ES6 arrow functions from ponyfoo at [https://ponyfoo.com/articles/es6-arrow-functions-in-depth](https://ponyfoo.com/articles/es6-arrow-functions-in-depth)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An in-depth look at how `this` works in JavaScript by Kyle Simpson at [https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting orientation changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building complex interfaces, it's very common to render different UI components,
    based on the device's orientation. This is especially true when dealing with tablets.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will render a menu based on screen orientation. In landscape,
    we will render an expanded menu with icons and texts, and in portrait, we will
    only render the icons.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To support orientation changes, we are going to use Expo's helper utility called
    `ScreenOrientation`.
  prefs: []
  type: TYPE_NORMAL
- en: We will also use the `FontAwesome` component provided by the Expo package `@expo/vector-icons`.
    The *Using font icons* recipe in [Chapter 2](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml), *Creating
    a Simple React Native App, *describes how to use this component.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get started, let's create a new app called `screen-orientation`. We'll
    also need to make a tweak to the `app.json` file that Expo creates in the root
    of the directory. This file has a few basic settings Expo uses when building the
    app. One of these settings is `orientation`, which is automatically set to `portrait` for
    every new app. This setting determines the orientations the app allows, and can
    be set to `portrait`, `landscape`, or `default`. If we change this to `default`,
    our app will allow both portrait and landscape orientations.
  prefs: []
  type: TYPE_NORMAL
- en: To see these changes take effect, be sure to restart your Expo project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start by opening `App.js` and adding the imports we''ll be using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll add the empty `App` class for the component, along with some basic
    styles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With the shell of our app in place, we can now add the `render` method. In
    the `render` method, you''ll notice we''ve got a `View` component using the `onLayout`
    property, which will fire off whenever the orientation of the device changes.
    The `onLayout` will then run `this.handleLayoutChange`, which we will define in
    the next step. In the `Text` element, we simply display the value of `orientation`
    on the `state` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the `handleLayoutChange` method of our component, as well as
    the `getOrientation` function that the `handleLayoutChange` method calls. The `getOrientation` function
    uses the React Native `Dimensions` utility to get the width and height of the
    screen. If `height > width`, we know that the device is in portrait orientation,
    and if not, then it is in landscape orientation. By updating `state`, a re-render
    will be initiated, and the value of `this.state.orientation` will reflect the
    orientation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the app at this point, we''ll get the error TypeError: null is not
    an object: (evaluating ''this.state.orientation''). This happens because the `render`
    method is attempting to read from the `this.state.orientation` value before it''s
    even been defined. We can easily fix this problem by getting the orientation before
    `render` runs for the first time, via the React life cycle `componentWillMount` hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all it takes to get the basic functionality we''re looking for! Run
    the app again and you should see the displayed text reflect the orientation of
    the device. Rotate the device, and the orientation text should update:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/23ba5cc4-36e7-4728-ac3a-3bc00b4846fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that the orientation `state` value is updating properly, we can focus on
    the UI. As mentioned before, we will create a menu that renders the options slightly
    differently based on the current orientation. Let''s import a `Menu` component,
    which we''ll build out in the next steps, and update the `render` method of our
    `App` component to use the new `Menu` component. Notice that we are now passing
    `this.state.orientation` to the `orientation` property of the `Menu` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also update the styles for our `App` component. You can replace the
    styles from *step 2* with the following code. By setting the `flexDirection` to `row` on
    the `container` styles, we''ll be able to display the two components horizontally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s build out the `Menu` component. We''ll need to create a new `/Menu/index.js` file,
    which will define the `Menu` class. This component will receive the `orientation` property
    and decide how to render the menu options based on the `orientation` value. Let''s
    start by importing the dependencies for this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can define the `Menu` class. On the `state` object, we will define an
    array of `options`. These `option` objects will be used to define the icons. As
    discussed in the *Using font icons* recipe in the previous chapter we can define
    icons via keywords, as defined in the vector-icon directory, found at [https://expo.github.io/vector-icons/](https://expo.github.io/vector-icons/):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `render` method for this component loops through the array of `options` in
    the `state` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, inside the JSX in the last step, there''s a call to `renderOption`.
    In this method, we are going to render the icon and the label for each option.
    We''ll also use the orientation value to toggle showing the label, and to change
    the icon''s size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code block, notice that we are defining a `key` property. When
    dynamically creating a new component, we always need to set a `key` property.
    This property should be unique for each item, since it's used internally by React.
    In this case, we are using the index of the loop iteration. This way, we can be
    assured that every item will have a unique `key` value since the data is static.
    You can read more about it in the official documentation at [https://reactjs.org/docs/lists-and-keys.html](https://reactjs.org/docs/lists-and-keys.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll define the styles for the menu. First, we will set the `backgroundColor` to
    dark blue, and then, for each option, we''ll change the `flexDirection` to render
    the icon and label horizontally. The rest of the styles add margins and paddings
    so that the menu items are nicely spaced apart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run our application now, it will display the menu UI differently depending
    on the orientation of the screen. Rotate the device, and the layout will automatically
    update:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/12a5ad38-0756-4ed5-a189-2f3e4412e2c1.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we had a look at the `app.json` file that exists as part of
    every Expo project. There are many useful settings that can be adjusted in this
    file that affect the build process of the project. You can use this file to adjust
    orientation lock, define an app icon, and set a splash screen, among many other
    settings. You can review all of the settings supported by `app.json` in the Expo
    configuration documentation, hosted at [https://docs.expo.io/versions/latest/guides/configuration.html](https://docs.expo.io/versions/latest/guides/configuration.html).
  prefs: []
  type: TYPE_NORMAL
- en: Expo also provides the `ScreenOrientation` utility, which can be used instead
    to declare the allowed orientations for your app. Using the utility's main method
    `ScreenOrientation.allow(orientation)`, will overwrite the corresponding setting
    in `app.json`. The utility also provides more granular options than the setting
    in `app.json`, such as `ALL_BUT_UPSIDE_DOWN` and `LANDSCAPE_RIGHT`. For more on
    this utility, you can read the documentation at [https://docs.expo.io/versions/latest/sdk/screen-orientation.html](https://docs.expo.io/versions/latest/sdk/screen-orientation.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using a WebView to embed external websites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For many applications, it's required that external links can be visited and
    displayed within the app. This can be for showing a third-party website, online
    help, and the terms and conditions of using your app, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to open a WebView by clicking on a button in
    our app and dynamically setting the URL value. We'll also be using the `react-navigation`
    package for creating basic stack navigation in this recipe. Please check out the
    *Setting up and using navigation* recipe in [Chapter 3](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml), *Implementing
    Complex User Interfaces – Part I* for a deeper dive into building navigation.
  prefs: []
  type: TYPE_NORMAL
- en: If the needs of your app are better met by loading external websites via the
    device's browser, see the next recipe, *Linking to websites and other applications*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need to create a new app for our WebView-based recipe. Let''s name
    our new app `web-view`. We''ll also be using `react-navigation`, so be sure to
    install this as well. You can use `yarn` or `npm` to install the package. In the
    root of the project, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, install them using `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by opening the `App.js` file. In this file, we''ll be using the
    `StackNavigator` component provided by the `react-navigation` package. First,
    let''s add the imports we''ll be using in this file. `HomeScreen` is a component
    we will be building later in this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our imports, let''s use the `StackNavigator` component to
    define the first route; we''ll be using a `Home` route with links that should
    be displayed using the React Native `WebView` component. The `navigationOptions`
    property allows us to define a title to be displayed in the navigation header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to create the `HomeScreen` component. Let''s create a new
    folder in the root of our project, called `HomeScreen`, and add an `index.js`
    file to the folder. As usual, we can begin with our imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can declare our `HomeScreen` component. Let''s also add a `state` object
    to the component with a `links` array. This array has an object for each link
    we''ll be using in this component. I''ve provided four `links` for you to use;
    however, you can edit the `title` and `url` in each `links` array object to any
    websites you''d like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re ready to add a `render` function to this component. Here, we are using
    the `SafeAreaView` for the container element. This works just like a normal `View`
    element, but also accounts for the notch area on the iPhone X so that no part
    of our layout is obscured by the device bezels. You''ll notice that we are using `map` to
    map over the `links` array from the previous step, passing each one to the `renderButton`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have defined the `render` method, we'll need to create the `renderButton`
    method that it's using. This method takes each link as a parameter called `button`,
    and the `index`, which we'll use as the unique `key` for each element `renderButton`
    is creating. For more on this point, see the *Tip*in *step 12* of the second recipe
    in this chapter, *Detecting orientation changes*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `TouchableOpacity` button element will fire `this.handleButtonPress(button)`
    when pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to create the `handleButtonPress` method used in the previous step.
    This method uses the `url` and `title` properties from the passed-in `button`
    parameter. We can then use these in a call to `this.properties.navigation.navigate()`,
    passing in the name of the route we want to navigate to and the parameters that
    should be passed along to that route. We have access to a `property` called `navigation`
    because we are using `StackNavigator`, which we set up in *step 2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HomeScreen` component is done, except for the styles. Let''s add a `styles.js`
    file in the `HomeScreen` folder to define these styles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we open the app, we should see the `HomeScreen` component being rendered
    with our list of four link buttons, and a header with the title Home rendered
    in the native style on each device. Since there is no `Browser` route in our `StackNavigator`,
    however, the buttons will not actually do anything when pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b705e213-90c2-4eb1-b741-7a9a48c1835f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s return to the `App.js` file and add the `Browser` route. First, we''ll
    need to import the `BrowserScreen` component, which we''ll create in the following
    steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the `BrowserScreen` component has been imported, we can add it to
    the `StackNavigator` object to create a `Browser` route. In `navigationOptions`,
    we''re defining a dynamic title based on the parameters passed to the route. These
    parameters are the same as the object we passed into the `navigation.navigate()` call
    as the second argument in *step 7*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We are ready to create the `BrowserScreen` component. Let''s create a new folder
    in the root of the project called `BrowserScreen` with a new `index.js` file inside,
    then add the imports this component needs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BrowserScreen` component is fairly simple. It consists only of a render
    method that reads the `params` property from the `navigation.state` property passed
    in to call to the `this.properties.navigation.navigate` that fires when a button
    is pressed, as defined in *step 7*. All we need to do is render the `WebView`
    component and set its `source` property to an object with the `uri` property set
    to `params.url`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we go back to the app running in the simulator, we can see our WebView
    in action!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9fedd5d4-07d4-46c1-bfe4-2d0069f7c5e1.png)Hacker News and Smashing
    Magazine visited from our app'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a WebView to open external sites is a great way to allow a user to consume
    external websites while keeping them in our app. Many applications out there do
    this, allowing the user to return to the main portion of the app easily.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6*, we used an arrow function to bind the function in the `onPress`
    property to the scope of the current class instance, since we are using this function
    when looping through the array of links.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 7*, whenever a button is pressed, we use the title and URL that are
    bound to that button, passing them along as parameters as we navigate to the `Browser`
    screen. The `navigationOptions` in *step 11* use this same title value as the
    title of the screen. The `navigationOptions` take a function whose first parameter
    is an object containing `navigation`, which provides the parameters used when
    navigating. In *step 11*, we structure navigation from this object so that we
    can set the view's title to `navigation.state.params.title`.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the `StackNavigator` component provided by `react-navigation`, we
    get a header with OS-specific animations, built in with a back button. You can
    read the `StackNavigation` documentation for more information on this component
    at [https://reactnavigation.org/docs/stack-navigator.html](https://reactnavigation.org/docs/stack-navigator.html).
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 13* uses the URL passed to the `BrowserScreen` component to render a
    WebView by using the URL in the WebView''s `source` property. You can find a list
    of all available WebView properties in the official documentation located at [https://facebook.github.io/react-native/docs/webview.html](https://facebook.github.io/react-native/docs/webview.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Linking to websites and other applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned how to use a WebView to render a third-party website as an embedded
    part of our app. However, sometimes, we might want to use the native browser to
    open a site, link to other native system applications (such as email, phone, and
    SMS), or even deep link to a completely separate app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will link to an external site via both the native browser
    and a browser modal within our app, create links to the phone and messaging applications,
    and create a deep link that will open the Slack app and automatically load the
    #general channel in the [gitconnected.com](http://gitconnected.com) Slack group.'
  prefs: []
  type: TYPE_NORMAL
- en: You will need to run this app on a real device in order to open the links in
    this app that use the device's system applications, such as email, phone, and
    SMS links. In my experience, this will not work in the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a new app for this recipe. We'll call it `linking-app`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by opening `App.js` and adding the imports we''ll be using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s add both an `App` component and a `state` object. In this app,
    the `state` object will house all of the links that we''ll be using in this recipe
    in an array called `links`. Notice how the `url` property in each `links` object
    has a protocol attached to it (`tel`, `mailto`, `sms`, and so on). These protocols
    are used by the device to properly handle each link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The phone number used in the Text Support and Call Support buttons is an unused
    number at the time of writing, as generated by [https://fakenumber.org/](https://fakenumber.org/).
    This number is likely to still be unused, but this could possibly change. Feel
    free to use a different fake number for these links, just make sure to keep the
    protocol in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add the `render` function for our app. The JSX here is simple:
    we map over the `state.links` array from the previous step, passing each to our
    `renderButton` function defined in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build out the `renderButton` method used in the last step. For each
    link, we create a button with `TouchableOpacity` and set the `onPress` property
    to execute the `handleButtonPress` and pass it the `button` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Next, we can build out the `handleButtonPress` function. Here, we'll be using
    the `type` property that we've added to each object in the `links` array. If the
    type is `'internal link'`, we want to open the URL *within* our app using the
    Expo `WebBrowser` component's `openBrowserAsync` method, and for everything else,
    we'll use the React Native `Linking` component's `openURL` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If there''s a problem with the `openURL` call and the URL is using the `slack://`
    protocol, it means the device does not know how to handle the protocol, probably
    because the slack app isn''t installed. We''ll handle this problem with the `handleMissingApp`
    function, which we''ll add in the next step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now we can create our `handleMissingApp` function. Here, we use the React Native
    helper `Platform`, which provides information about the platform the app is running
    on. `Platform.OS` will always return the operating system, which, on phones, should
    always resolve to either `'ios'` or `'android'`. You can read more about the capabilities
    of `Platform` in the official documentation at [https://facebook.github.io/react-native/docs/platform-specific-code.html](https://facebook.github.io/react-native/docs/platform-specific-code.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the link to the Slack app does not work as expected, we''ll use `Linking.openURL`
    again; this time, to open the app in the app store appropriate for the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Our app doesn''t have any styles yet, so let''s add some. Nothing fancy here,
    just aligning the buttons in the center of the screen, coloring and centering
    text, and providing padding on each button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all there is to this app. Once we load the app, there should be a column
    of buttons representing each of our links. The Call Support and Email Support buttons
    will not work on the iOS simulator. Run this recipe on a real device to see all
    of the links working properly.:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/1890e7a8-6817-493e-8dc8-4b1be726e421.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 2*, we defined all the links that our app uses. Each link object has
    a `type` property that we use in the `handleButtonPress` method defined in *step
    5*.
  prefs: []
  type: TYPE_NORMAL
- en: This `handleButtonPress` function uses the link's type to determine which one
    of two strategies will be used. If the link's type is `'internal link'`, we want
    to open the link with the device browser as a modal that pops up within the app
    itself. For this purpose, we can use Expo's `WebBrowser` helper, passing the URL
    to its `openBrowserAsync` method. If the link's type is `'external link'`, we'll
    open the link with React Native's `Linking` helper. This lets you see the different
    ways you can open a website from your app.
  prefs: []
  type: TYPE_NORMAL
- en: The `Linking` helper can handle protocols other than HTTP and HTTPS as well.
    By simply using the proper protocol in the link we pass to `Linking.openURL`,
    we can open the telephone (`tel:`), messaging (`sms:`), or email (`mailto:`).
  prefs: []
  type: TYPE_NORMAL
- en: '`Linking.openURL` can also handle deep links to other applications, as long
    as the app you want to link to has a protocol for doing so, such as how we open
    Slack by using the `slack://` protocol. For more information on Slack''s deep
    linking protocol and what you can do with it, visit their documentation at [https://api.slack.com/docs/deep-linking](https://api.slack.com/docs/deep-linking).'
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, we `catch` any error caused by calling `Linking.openURL`, check
    whether the error was caused by the Slack protocol using `message.includes('slack://')`,
    and if so, we know the Slack app is not installed on the device. In this case,
    we fire `handleMissingApp`, which opens the app store link for Slack using the
    appropriate link, as determined by `Platform.OS`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Official documentation on the `Linking` module can be found at [https://docs.expo.io/versions/latest/guides/linking.html](https://docs.expo.io/versions/latest/guides/linking.html).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a form component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most applications require a way to input data, whether it's a simple registration
    and login form or a more complex component with many input fields and controls.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a form component to handle text inputs. We will
    collect data using different keyboards, and show an alert message with the resulting
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to create an empty app. Let's name it `user-form`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by opening `App.js` and adding our imports. The imports include
    the `UserForm` component that we''ll be building out in a later step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this component is going to be very simple, we are going to create a stateless
    component for our `App`. We will only render a top toolbar inside a `ScrollView` for
    the `UserForm` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add some styles to these components. We''ll add some colors and
    padding, as well as setting the `main` class to `flex: 1` to fill the remainder
    of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined the main `App` component. Now let''s get to work on the actual
    form. Let''s create a new directory called `UserForm` in the base of the project
    and add an `index.js` file. Then, we''ll import all the dependencies for this
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the class that will render the inputs and keep track of the data. We
    are going to save the data on the `state` object, so we''ll start by initializing
    `state` as an empty object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `render` method, we are going to define the components that we want
    to display, which in this case are three text inputs and a button. We are going
    to define a `renderTextfield` method that accepts a configuration object as a
    parameter. We''ll define the `name` of the field, the `placeholder`, and the `keyboard` type
    that should be used on the input. In addition, we''re also calling a `renderButton` method
    that will render the Save button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'To render the text fields, we are going to use the `TextInput` component in
    our `renderTextfield` method. This `TextInput` component is provided by React
    Native and works on both iOS and Android. The `keyboardType` property allows us
    to set the keyboard that we want to use. The four available keyboards on both
    platforms are `default`, `numeric`, `email-address`, and `phone-pad`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We already know how to render buttons and respond to the `Press` action. If
    this is unclear, I recommend reading the *Creating a reusable button with theme
    support* recipein [Chapter 3](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml), *Implementing
    Complex User Interfaces – Part I*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to define the `onPressButton` callback. For simplicity, we''ll just
    show an alert with the input data that we have on the `state` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We are almost done with this recipe! All we need to do is apply some styles
    – some colors, padding, and margins; nothing fancy really:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run our app, we should be able to see a form that uses native controls
    on both Android and iOS, as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d8fe94c6-7280-457d-9e40-bd332add30b9.png)You might not be able to
    see the keyboard as defined by `keyboardType` when running your app in a simulator.
    Run the app on a real device to ensure that the `keyboardType` is properly changing
    the keyboard for each `TextInput`.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 8*, we defined the `TextInput` component. In React (and React Native),
    we can use two types of input: controlled and uncontrolled components. In this
    recipe, we're using controlled input components, as recommended by the React team.
  prefs: []
  type: TYPE_NORMAL
- en: A controlled component will have a `value` property, and the component will
    always display the content of the `value` property. This means that we need a
    way to change the value when the user starts typing into the input. If we don't
    update that value, then the text in the input won't ever change, even if the user
    tries to type something.
  prefs: []
  type: TYPE_NORMAL
- en: In order to update the `value`, we can use the `onChangeText` callback and set
    the new value. In this example, we are using the state to keep track of the data
    and we are setting a new key on the state with the content of the input.
  prefs: []
  type: TYPE_NORMAL
- en: An uncontrolled component, on the other hand, will not have a `value` property
    assigned. We can assign an initial value using the `defaultValue` property. Uncontrolled components
    have their own state, and we can get their value by using an `onChangeText` callback,
    just as we can with controlled components.
  prefs: []
  type: TYPE_NORMAL
