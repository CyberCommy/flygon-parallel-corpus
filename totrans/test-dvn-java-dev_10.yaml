- en: Feature Toggles – Deploying Partially Done Features to Production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Do not let circumstances control you. You change your circumstances."'
  prefs: []
  type: TYPE_NORMAL
- en: – Jackie Chan
  prefs: []
  type: TYPE_NORMAL
- en: We have seen so far how TDD makes the development process easier and decreases
    the amount of time spent on writing quality code. But there's another particular
    benefit to this. As code is being tested and its correctness is proven, we can
    go a step further and assume that our code is production-ready once all tests
    have passed.
  prefs: []
  type: TYPE_NORMAL
- en: There are some software life cycle approaches based on this idea. Some **extreme
    programming** (**XP**) practices such as **continuous integration** (**CI**),
    continuous delivery, and **continuous deployment** (**CD**) will be introduced.
    The code examples can be found at [https://bitbucket.org/alexgarcia/packt-tdd-java/src/](https://bitbucket.org/alexgarcia/packt-tdd-java/src/),
    in the folder `10-feature-toggles`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration, delivery, and deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the application in production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature Toggles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration, delivery, and deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TDD goes hand in hand with CI, continuous delivery, or CD. Differences aside,
    all three techniques have similar goals. They are all trying to foster the continuous
    verification of production readiness of our code. In that respect, they are very
    similar to TDD. They each promote very short development cycles, continuous verification
    of the code we're producing, and the intention to continuously keep our application
    in a production-ready state.
  prefs: []
  type: TYPE_NORMAL
- en: The scope of this book does not permit us to go into the details of those techniques.
    Indeed, a whole book could be written on this subject. We'll just briefly explain
    the differences between the three. Practicing CI means that our code is at (almost)
    all times integrated with the rest of the system, and if there is a problem it
    will surface quickly. If such a thing happens, the priority is to fix the cause
    of that problem, meaning that any new development must take lower priority. You
    might have noticed a similarity between this definition and the way TDD works.
    The major difference is that with TDD, our primary focus is not the integration
    with the rest of the system. The rest is the same. Both TDD and CI try to detect
    problems fast and treat fixing them as the highest priority, putting everything
    else on hold. CI does not have the whole pipeline automated, and additional manual
    verifications are needed before the code is deployed to production.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery is very similar to CI, except that the former goes a bit
    further and has the whole pipeline automated, except the actual deployment to
    production. Every push to the repository that passed all verifications is considered
    valid for deployment to production. However, the decision to deploy is made manually.
    Someone needs to choose one of the builds and promote it to the production environment.
    The choice is political or functional. It depends on what and when we want our
    users to receive, even though each is production-ready.
  prefs: []
  type: TYPE_NORMAL
- en: '"Continuous Delivery is a software development discipline where you build software
    in such a way that the software can be released to production at any time."'
  prefs: []
  type: TYPE_NORMAL
- en: – Martin Fowler
  prefs: []
  type: TYPE_NORMAL
- en: Finally, CD is accomplished when the decision about what to deploy is automated
    as well. In this scenario, every commit that passed all verifications is deployed
    to production—no exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: In order to continuously integrate or deliver our code to production, branches
    cannot exist, or the time between creating them and integrating them with the
    mainline must be very short (less than a day, preferably a few hours). If that
    is not the case, we are not continuously verifying our code.
  prefs: []
  type: TYPE_NORMAL
- en: The true connection with TDD comes from the necessity to create validations
    before the code is committed. If those verifications are not created in advance,
    code pushed to the repository is not accompanied with tests and the process fails.
    Without tests, there is no confidence in what we did. Without TDD, there are no
    tests to accompany our implementation code. Alternatively, a delay in pushing
    commits to repository until tests are created but in that case, there is no continuous
    part of the process. Code is sitting on someone's computer until someone else
    is finished with tests. Code that sits somewhere is not continuously verified
    against the whole system.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, continuous integration, delivery, and deployment rely on tests
    to accompany the integration code (thus, relying on TDD) and on the practice of
    not using branches or having them very short-lived (very often merged to the mainline).
    The problem lies with the fact that some features cannot be developed that fast.
    No matter how small our features are, in some cases it might take days to develop
    them. During all that time, we cannot push to the repository because the process
    would deliver them to production. Users do not want to see partial features. There
    is no point having, for example, part of the login process delivered. If one were
    to see a login page with a username, password, and login button, but the process
    behind that button does not actually store that info and provides, let's say,
    an authentication cookie, then at best we would have confused the users. In some
    other cases, one feature cannot work without the other. Following the same example,
    even if a login feature is fully developed, without registration it is pointless.
    One cannot be used without the other.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine playing a puzzle. We need to have a rough idea of the final picture,
    but we are focused on one piece at the time. We pick a piece that we think is
    the easiest to place and combine it with its neighbors. Only when all of them
    are in place is the picture complete and we are finished.
  prefs: []
  type: TYPE_NORMAL
- en: The same applies to TDD. We develop our code by being focused on small units.
    As we progress, they start taking a shape and working with each other until they
    are all integrated. While we're waiting for that to happen, even though all our
    tests are passing and we are in a green state, the code is not ready for the end
    users.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to solve those problems and not compromise on TDD and CI/CD
    is to use Feature Toggles.
  prefs: []
  type: TYPE_NORMAL
- en: Feature Toggles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have also heard about this as **Feature Flipping** or **Feature Flags**.
    No matter which expression we use, they are all based on a mechanism that permits
    you to turn on and off the features of your application. This is very useful when
    all code is merged into one branch and you must deal with partially finished (or
    integrated) code. With this technique, unfinished features can be hidden so that
    users cannot access them.
  prefs: []
  type: TYPE_NORMAL
- en: Due to its nature, there are other possible uses for this functionality. As
    a circuit breaker when something is wrong with a particular feature, providing
    graceful degradation of the application, shutting down secondary features to preserve
    hardware resources for business core operations, and so on. Feature Toggles, in
    some cases, can go even further. We might use them to enable features only to
    certain users, based on, for example, geographic location or their role. Another
    use is that we can enable new features for our testers only. That way, end users
    would continue to be oblivious of the existence of some new features, while testers
    would be able to validate them on a production server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, there are some aspects to remember when using Feature Toggles:'
  prefs: []
  type: TYPE_NORMAL
- en: Use toggles only until they are fully deployed and proven to work. Otherwise,
    you might end up with spaghetti code full of `if`/`else` statements containing
    old toggles that are not in use any more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not spend too much time testing toggles. It is, in most cases, enough to
    confirm that the entry point into some new feature is not visible. That can be,
    for example, a link to the new feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not overuse toggles. Do not use them when there is no need for them. For
    example, you might be developing a new screen that is accessible through a link
    in the home page. If that link is added at the end, there might be no need to
    have a toggle that hides it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many good frameworks and libraries for application feature handling.
    Two of them are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Togglz** ([http://www.togglz.org/](http://www.togglz.org/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FF4J** ([http://ff4j.org/](http://ff4j.org/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These libraries offer a sophisticated way to manage features, even adding role-based
    or rules-based feature access. In many cases, you aren't going to need it, but
    these capabilities bring us the possibility of testing a new feature in production
    without opening it to all users. However, implementing a custom basic solution
    for feature toggling is quite simple, and we are going to go through an example
    to illustrate this.
  prefs: []
  type: TYPE_NORMAL
- en: A Feature Toggle example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we go with our demo application. This time, we're going to build a simple
    and small **REpresentational State Transfer** (**REST**)  service to compute,
    on demand, a concrete N^(th) position of Fibonacci's sequence. We will keep track
    of enabled/disabled features using a file. For simplicity, we will use Spring
    Boot as our framework of choice and Thymeleaf as a template engine. This is also
    included in the Spring Boot dependency. Find more information about Spring Boot
    and related projects at [http://projects.spring.io/spring-boot/](http://projects.spring.io/spring-boot/).
    Also, you can visit [http://www.thymeleaf.org/](http://www.thymeleaf.org/) to
    read more about the template engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the `build.gradle` file looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that application plugin is present because we want to run the application
    using the Gradle command `run`. Here is the application''s `main` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create the properties file. This time, we are going to use **YAML Ain''t
    Markup Language** (**YAML**) format, as it is very comprehensive and concise.
    Add a file called `application.yml` in the `src/main/resources` folder, with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Spring offers a way to load this kind of property file automatically. Currently,
    there are only two restrictions: the name must be `application.yml` and/or the
    file should be included in the application''s class path.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is our implementation of the feature''s `config` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the `fibonacci` service class. This time, the computation operation
    will always return `-1`, just to simulate a partially done feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a wrapper to hold the computed values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the `FibonacciRESTController` class, responsible for handling the `fibonacci`
    service queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `fibonacci` method is checking whether the `fibonacci` service
    should be enabled or disabled, throwing an `UnsupportedOperationException` for
    convenience in the last case. There are also two error-handling functions; the
    first one is for processing `UnsupportedOperationException` and the second is
    for generic exceptions handling.
  prefs: []
  type: TYPE_NORMAL
- en: Now that all the components have been set, all we need to do is execute Gradle's
  prefs: []
  type: TYPE_NORMAL
- en: '`run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will launch a process that will eventually set a server up on the
    following address: `http://localhost:8080`. This can be observed in the console
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once the application has started, we can perform a query using a regular browser.
    The URL of the query is `http://localhost:8080/fibonacci?number=7`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9da0fbdc-44da-432f-a293-4782b2751e9f.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the error received corresponds to the error sent by the REST
    API when the feature is disabled. Otherwise, the return should be `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Fibonacci service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of you might be familiar with Fibonacci's numbers. Here's a brief explanation
    anyway for those who don't know what they are.
  prefs: []
  type: TYPE_NORMAL
- en: Fibonacci's sequence is an integer sequence resulting from the recurrence *f(n)
    = f(n-1) - f(n - 2)*. The sequence starts with being *f(0) = 0* and *f(1) = 1*.
    All other numbers are generated applying the recurrence as many times as needed
    until a value substitution can be performed using either 0 or 1 known values.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144,...More info about Fibonacci''s
    sequence can be found here: [http://www.wolframalpha.com/input/?i=fibonacci+sequence](http://www.wolframalpha.com/input/?i=fibonacci+sequence)'
  prefs: []
  type: TYPE_NORMAL
- en: As an extra functionality, we want to limit how long the value computation takes,
    so we impose a constraint on the input; our service will only compute Fibonacci's
    numbers from `0` to `30` (both numbers included).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a possible implementation of a class computing Fibonacci''s numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of brevity, the TDD Red-Green-Refactor process is not explicitly
    explained in the demonstration, but has been present through development. Only
    the final implementation with the final tests is presented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we can now turn on the `fibonacci` feature in the `application.yml` file,
    perform some queries with the browser, and check how is it going:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute Gradle''s `run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can fully test our REST API using the browser, with a number between
    `0` and `30`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa63d9c5-147d-49a5-95ad-99b9cb66c21d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we test it with a number bigger than `30`, and lastly by introducing
    characters instead of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/554eb35c-9550-4abf-8bb8-2a88ef7eaae9.png)'
  prefs: []
  type: TYPE_IMG
- en: Working with the template engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are enabling and disabling the `fibonacci` feature, but there are many other
    cases where the Feature Toggle can be very useful. One of them is hiding a web
    link that links to an unfinished feature. This is an interesting use because we
    can test what we released to production using its URL, but it will be hidden for
    the rest of the users for as long as we want.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this behavior, we are going to create a simple web page using
    the already mentioned Thymeleaf framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we add a new `control` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, map this new flag in a configuration class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to create two templates. The first one is the home page. It contains
    some links to different Fibonacci number computations. These links should be visible
    only when the feature is enabled, so there''s an optional block to simulate this
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The second one just shows the value of the computed Fibonacci number and also
    a link to go back to the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In order to get both templates to work, they should be in a specific location.
    They are `src/main/resources/templates/home.html` and `src/main/resources/templates/fibonacci.html` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the masterpiece, which is the controller that connects all this and
    makes it work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that this controller and the previous one seen in the REST API example
    share some similarities. This is because both are constructed with the same framework
    and use the same resources. However, there are slight differences between them;
    one is annotated as `@Controller` instead of both being `@RestController`. This
    is because the web controller is serving template pages with custom information,
    while the REST API generates a JSON object response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this working, again using this Gradle command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the generated home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9b8caa6-9e02-4fc0-876b-ed6f62e03ca4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is shown when visiting the Fibonacci number link:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5aaee666-9dbf-4a26-ad4e-40880a149824.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But we turn off the feature using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Relaunching the application, we browse to the home page and see that those
    links are not shown anymore, but we can still access the page if we already know
    the URL. If we manually write `http://localhost:8080/web/fibonacci?number=15`,
    we can still access the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56aced76-f40d-47b9-9178-488ff47cf1bc.png)'
  prefs: []
  type: TYPE_IMG
- en: This practice is very useful, but it usually adds unnecessary complexity to
    your code. Don't forget to refactor the code, deleting old toggles that you won't
    use anymore. It will keep your code clean and readable. Also, a good point is
    getting this working without restarting the application. There are many storage
    options that do not require a restart, databases being the most popular.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Feature Toggles are a nice way to hide and/or handle partially finished functionalities
    in production environments. This may sound weird for those deploying code to production
    on demand, but it is quite common to find this situation when practicing continuous
    integration, delivery, or deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have introduced the technique and discussed the pros and cons. We have also
    enumerated some of the typical cases where toggling features can be helpful. Finally,
    we have implemented two different use cases: a Feature Toggle with a very simple
    REST API, and a Feature Toggle in a web application.'
  prefs: []
  type: TYPE_NORMAL
- en: Although the code presented in this chapter is fully functional, it isn't very
    common to use a file-based property system for this matter. There are many libraries
    more suitable for production environments that can help us to implement this technique,
    providing a lot of capabilities, such as using a web interface to handle features,
    storing preferences in a database, or allowing access to concrete user profiles.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we are going to put the TDD concepts described in the book
    all together. We are going to name some good practices and recommendations that
    are very useful when programming in the TDD way.
  prefs: []
  type: TYPE_NORMAL
