- en: Feature Toggles – Deploying Partially Done Features to Production
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Do not let circumstances control you. You change your circumstances."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: – Jackie Chan
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: We have seen so far how TDD makes the development process easier and decreases
    the amount of time spent on writing quality code. But there's another particular
    benefit to this. As code is being tested and its correctness is proven, we can
    go a step further and assume that our code is production-ready once all tests
    have passed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: There are some software life cycle approaches based on this idea. Some **extreme
    programming** (**XP**) practices such as **continuous integration** (**CI**),
    continuous delivery, and **continuous deployment** (**CD**) will be introduced.
    The code examples can be found at [https://bitbucket.org/alexgarcia/packt-tdd-java/src/](https://bitbucket.org/alexgarcia/packt-tdd-java/src/),
    in the folder `10-feature-toggles`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration, delivery, and deployment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the application in production
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature Toggles
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration, delivery, and deployment
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TDD goes hand in hand with CI, continuous delivery, or CD. Differences aside,
    all three techniques have similar goals. They are all trying to foster the continuous
    verification of production readiness of our code. In that respect, they are very
    similar to TDD. They each promote very short development cycles, continuous verification
    of the code we're producing, and the intention to continuously keep our application
    in a production-ready state.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The scope of this book does not permit us to go into the details of those techniques.
    Indeed, a whole book could be written on this subject. We'll just briefly explain
    the differences between the three. Practicing CI means that our code is at (almost)
    all times integrated with the rest of the system, and if there is a problem it
    will surface quickly. If such a thing happens, the priority is to fix the cause
    of that problem, meaning that any new development must take lower priority. You
    might have noticed a similarity between this definition and the way TDD works.
    The major difference is that with TDD, our primary focus is not the integration
    with the rest of the system. The rest is the same. Both TDD and CI try to detect
    problems fast and treat fixing them as the highest priority, putting everything
    else on hold. CI does not have the whole pipeline automated, and additional manual
    verifications are needed before the code is deployed to production.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery is very similar to CI, except that the former goes a bit
    further and has the whole pipeline automated, except the actual deployment to
    production. Every push to the repository that passed all verifications is considered
    valid for deployment to production. However, the decision to deploy is made manually.
    Someone needs to choose one of the builds and promote it to the production environment.
    The choice is political or functional. It depends on what and when we want our
    users to receive, even though each is production-ready.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '"Continuous Delivery is a software development discipline where you build software
    in such a way that the software can be released to production at any time."'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: – Martin Fowler
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Finally, CD is accomplished when the decision about what to deploy is automated
    as well. In this scenario, every commit that passed all verifications is deployed
    to production—no exceptions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: In order to continuously integrate or deliver our code to production, branches
    cannot exist, or the time between creating them and integrating them with the
    mainline must be very short (less than a day, preferably a few hours). If that
    is not the case, we are not continuously verifying our code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The true connection with TDD comes from the necessity to create validations
    before the code is committed. If those verifications are not created in advance,
    code pushed to the repository is not accompanied with tests and the process fails.
    Without tests, there is no confidence in what we did. Without TDD, there are no
    tests to accompany our implementation code. Alternatively, a delay in pushing
    commits to repository until tests are created but in that case, there is no continuous
    part of the process. Code is sitting on someone's computer until someone else
    is finished with tests. Code that sits somewhere is not continuously verified
    against the whole system.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, continuous integration, delivery, and deployment rely on tests
    to accompany the integration code (thus, relying on TDD) and on the practice of
    not using branches or having them very short-lived (very often merged to the mainline).
    The problem lies with the fact that some features cannot be developed that fast.
    No matter how small our features are, in some cases it might take days to develop
    them. During all that time, we cannot push to the repository because the process
    would deliver them to production. Users do not want to see partial features. There
    is no point having, for example, part of the login process delivered. If one were
    to see a login page with a username, password, and login button, but the process
    behind that button does not actually store that info and provides, let's say,
    an authentication cookie, then at best we would have confused the users. In some
    other cases, one feature cannot work without the other. Following the same example,
    even if a login feature is fully developed, without registration it is pointless.
    One cannot be used without the other.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Imagine playing a puzzle. We need to have a rough idea of the final picture,
    but we are focused on one piece at the time. We pick a piece that we think is
    the easiest to place and combine it with its neighbors. Only when all of them
    are in place is the picture complete and we are finished.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The same applies to TDD. We develop our code by being focused on small units.
    As we progress, they start taking a shape and working with each other until they
    are all integrated. While we're waiting for that to happen, even though all our
    tests are passing and we are in a green state, the code is not ready for the end
    users.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to solve those problems and not compromise on TDD and CI/CD
    is to use Feature Toggles.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Feature Toggles
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have also heard about this as **Feature Flipping** or **Feature Flags**.
    No matter which expression we use, they are all based on a mechanism that permits
    you to turn on and off the features of your application. This is very useful when
    all code is merged into one branch and you must deal with partially finished (or
    integrated) code. With this technique, unfinished features can be hidden so that
    users cannot access them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Due to its nature, there are other possible uses for this functionality. As
    a circuit breaker when something is wrong with a particular feature, providing
    graceful degradation of the application, shutting down secondary features to preserve
    hardware resources for business core operations, and so on. Feature Toggles, in
    some cases, can go even further. We might use them to enable features only to
    certain users, based on, for example, geographic location or their role. Another
    use is that we can enable new features for our testers only. That way, end users
    would continue to be oblivious of the existence of some new features, while testers
    would be able to validate them on a production server.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, there are some aspects to remember when using Feature Toggles:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Use toggles only until they are fully deployed and proven to work. Otherwise,
    you might end up with spaghetti code full of `if`/`else` statements containing
    old toggles that are not in use any more.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not spend too much time testing toggles. It is, in most cases, enough to
    confirm that the entry point into some new feature is not visible. That can be,
    for example, a link to the new feature.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要花太多时间测试切换。在大多数情况下，确认某个新功能的入口点不可见就足够了。例如，这可以是指向新功能的链接。
- en: Do not overuse toggles. Do not use them when there is no need for them. For
    example, you might be developing a new screen that is accessible through a link
    in the home page. If that link is added at the end, there might be no need to
    have a toggle that hides it.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要过度使用切换。当不需要时不要使用它们。例如，您可能正在开发一个可以通过主页上的链接访问的新屏幕。如果该链接是在最后添加的，可能没有必要有一个隐藏它的切换。
- en: 'There are many good frameworks and libraries for application feature handling.
    Two of them are the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多用于应用程序特性处理的良好框架和库。其中两个是以下：
- en: '**Togglz** ([http://www.togglz.org/](http://www.togglz.org/))'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Togglz** ([http://www.togglz.org/](http://www.togglz.org/))'
- en: '**FF4J** ([http://ff4j.org/](http://ff4j.org/))'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FF4J** ([http://ff4j.org/](http://ff4j.org/))'
- en: These libraries offer a sophisticated way to manage features, even adding role-based
    or rules-based feature access. In many cases, you aren't going to need it, but
    these capabilities bring us the possibility of testing a new feature in production
    without opening it to all users. However, implementing a custom basic solution
    for feature toggling is quite simple, and we are going to go through an example
    to illustrate this.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库提供了一种复杂的方式来管理特性，甚至添加基于角色或规则的特性访问。在许多情况下，您可能不需要它，但这些功能使我们有可能在生产中测试新功能而不向所有用户开放。但是，实现自定义基本解决方案以进行特性切换非常简单，我们将通过一个示例来说明这一点。
- en: A Feature Toggle example
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性切换示例
- en: Here we go with our demo application. This time, we're going to build a simple
    and small **REpresentational State Transfer** (**REST**)  service to compute,
    on demand, a concrete N^(th) position of Fibonacci's sequence. We will keep track
    of enabled/disabled features using a file. For simplicity, we will use Spring
    Boot as our framework of choice and Thymeleaf as a template engine. This is also
    included in the Spring Boot dependency. Find more information about Spring Boot
    and related projects at [http://projects.spring.io/spring-boot/](http://projects.spring.io/spring-boot/).
    Also, you can visit [http://www.thymeleaf.org/](http://www.thymeleaf.org/) to
    read more about the template engine.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看看我们的演示应用程序。这一次，我们将构建一个简单而小的**REpresentational State Transfer**（**REST**）服务，以按需计算Fibonacci序列的具体N^(th)位置。我们将使用文件跟踪启用/禁用的特性。为简单起见，我们将使用Spring
    Boot作为我们的框架选择，并使用Thymeleaf作为模板引擎。这也包含在Spring Boot依赖项中。在[http://projects.spring.io/spring-boot/](http://projects.spring.io/spring-boot/)上找到有关Spring
    Boot和相关项目的更多信息。此外，您可以访问[http://www.thymeleaf.org/](http://www.thymeleaf.org/)了解有关模板引擎的更多信息。
- en: 'This is how the `build.gradle` file looks:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`build.gradle`文件的样子：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Note that application plugin is present because we want to run the application
    using the Gradle command `run`. Here is the application''s `main` class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，应用程序插件存在，因为我们希望使用Gradle命令“run”运行应用程序。这是应用程序的“main”类：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will create the properties file. This time, we are going to use **YAML Ain''t
    Markup Language** (**YAML**) format, as it is very comprehensive and concise.
    Add a file called `application.yml` in the `src/main/resources` folder, with the
    following content:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建属性文件。这一次，我们将使用**YAML Ain't Markup Language**（**YAML**）格式，因为它非常全面和简洁。在`src/main/resources`文件夹中添加一个名为`application.yml`的文件，内容如下：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Spring offers a way to load this kind of property file automatically. Currently,
    there are only two restrictions: the name must be `application.yml` and/or the
    file should be included in the application''s class path.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了一种自动加载这种属性文件的方法。目前只有两个限制：名称必须是`application.yml`和/或文件应包含在应用程序的类路径中。
- en: 'This is our implementation of the feature''s `config` file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们对特性“config”文件的实现：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is the `fibonacci` service class. This time, the computation operation
    will always return `-1`, just to simulate a partially done feature:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`fibonacci`服务类。这一次，计算操作将始终返回`-1`，只是为了模拟一个部分完成的功能：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We also need a wrapper to hold the computed values:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个包装器来保存计算出的值：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is the `FibonacciRESTController` class, responsible for handling the `fibonacci`
    service queries:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`FibonacciRESTController`类，负责处理`fibonacci`服务查询：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that the `fibonacci` method is checking whether the `fibonacci` service
    should be enabled or disabled, throwing an `UnsupportedOperationException` for
    convenience in the last case. There are also two error-handling functions; the
    first one is for processing `UnsupportedOperationException` and the second is
    for generic exceptions handling.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`fibonacci`方法正在检查`fibonacci`服务是否应启用或禁用，在最后一种情况下为方便抛出`UnsupportedOperationException`。还有两个错误处理函数；第一个用于处理`UnsupportedOperationException`，第二个用于处理通用异常。
- en: Now that all the components have been set, all we need to do is execute Gradle's
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有组件都已设置好，我们需要做的就是执行Gradle的
- en: '`run` command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`run`命令：'
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The command will launch a process that will eventually set a server up on the
    following address: `http://localhost:8080`. This can be observed in the console
    output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将启动一个进程，最终将在以下地址上设置服务器：`http://localhost:8080`。这可以在控制台输出中观察到：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once the application has started, we can perform a query using a regular browser.
    The URL of the query is `http://localhost:8080/fibonacci?number=7`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序启动后，我们可以使用常规浏览器执行查询。查询的URL是`http://localhost:8080/fibonacci?number=7`。
- en: 'This gives us the following output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下输出：
- en: '![](img/9da0fbdc-44da-432f-a293-4782b2751e9f.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9da0fbdc-44da-432f-a293-4782b2751e9f.png)'
- en: As you can see, the error received corresponds to the error sent by the REST
    API when the feature is disabled. Otherwise, the return should be `-1`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，收到的错误对应于REST API在禁用特性时发送的错误。否则，返回值应为`-1`。
- en: Implementing the Fibonacci service
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Fibonacci服务
- en: Most of you might be familiar with Fibonacci's numbers. Here's a brief explanation
    anyway for those who don't know what they are.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Fibonacci's sequence is an integer sequence resulting from the recurrence *f(n)
    = f(n-1) - f(n - 2)*. The sequence starts with being *f(0) = 0* and *f(1) = 1*.
    All other numbers are generated applying the recurrence as many times as needed
    until a value substitution can be performed using either 0 or 1 known values.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'That is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144,...More info about Fibonacci''s
    sequence can be found here: [http://www.wolframalpha.com/input/?i=fibonacci+sequence](http://www.wolframalpha.com/input/?i=fibonacci+sequence)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: As an extra functionality, we want to limit how long the value computation takes,
    so we impose a constraint on the input; our service will only compute Fibonacci's
    numbers from `0` to `30` (both numbers included).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a possible implementation of a class computing Fibonacci''s numbers:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For the sake of brevity, the TDD Red-Green-Refactor process is not explicitly
    explained in the demonstration, but has been present through development. Only
    the final implementation with the final tests is presented:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Also, we can now turn on the `fibonacci` feature in the `application.yml` file,
    perform some queries with the browser, and check how is it going:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Execute Gradle''s `run` command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we can fully test our REST API using the browser, with a number between
    `0` and `30`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa63d9c5-147d-49a5-95ad-99b9cb66c21d.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: 'Then, we test it with a number bigger than `30`, and lastly by introducing
    characters instead of numbers:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/554eb35c-9550-4abf-8bb8-2a88ef7eaae9.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: Working with the template engine
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are enabling and disabling the `fibonacci` feature, but there are many other
    cases where the Feature Toggle can be very useful. One of them is hiding a web
    link that links to an unfinished feature. This is an interesting use because we
    can test what we released to production using its URL, but it will be hidden for
    the rest of the users for as long as we want.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this behavior, we are going to create a simple web page using
    the already mentioned Thymeleaf framework.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we add a new `control` flag:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, map this new flag in a configuration class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We are going to create two templates. The first one is the home page. It contains
    some links to different Fibonacci number computations. These links should be visible
    only when the feature is enabled, so there''s an optional block to simulate this
    behavior:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The second one just shows the value of the computed Fibonacci number and also
    a link to go back to the home page:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In order to get both templates to work, they should be in a specific location.
    They are `src/main/resources/templates/home.html` and `src/main/resources/templates/fibonacci.html` respectively.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the masterpiece, which is the controller that connects all this and
    makes it work:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that this controller and the previous one seen in the REST API example
    share some similarities. This is because both are constructed with the same framework
    and use the same resources. However, there are slight differences between them;
    one is annotated as `@Controller` instead of both being `@RestController`. This
    is because the web controller is serving template pages with custom information,
    while the REST API generates a JSON object response.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this working, again using this Gradle command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is the generated home page:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9b8caa6-9e02-4fc0-876b-ed6f62e03ca4.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: 'This is shown when visiting the Fibonacci number link:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5aaee666-9dbf-4a26-ad4e-40880a149824.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: 'But we turn off the feature using the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Relaunching the application, we browse to the home page and see that those
    links are not shown anymore, but we can still access the page if we already know
    the URL. If we manually write `http://localhost:8080/web/fibonacci?number=15`,
    we can still access the page:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56aced76-f40d-47b9-9178-488ff47cf1bc.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: This practice is very useful, but it usually adds unnecessary complexity to
    your code. Don't forget to refactor the code, deleting old toggles that you won't
    use anymore. It will keep your code clean and readable. Also, a good point is
    getting this working without restarting the application. There are many storage
    options that do not require a restart, databases being the most popular.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实践非常有用，但通常会给您的代码增加不必要的复杂性。不要忘记重构代码，删除您不再使用的旧切换。这将使您的代码保持清晰和可读。另外，一个很好的点是在不重新启动应用程序的情况下使其工作。有许多存储选项不需要重新启动，数据库是最受欢迎的。
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Feature Toggles are a nice way to hide and/or handle partially finished functionalities
    in production environments. This may sound weird for those deploying code to production
    on demand, but it is quite common to find this situation when practicing continuous
    integration, delivery, or deployment.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 功能切换是在生产环境中隐藏和/或处理部分完成的功能的一种不错的方式。对于那些按需部署代码到生产环境的人来说，这可能听起来很奇怪，但在实践持续集成、交付或部署时，发现这种情况是相当常见的。
- en: 'We have introduced the technique and discussed the pros and cons. We have also
    enumerated some of the typical cases where toggling features can be helpful. Finally,
    we have implemented two different use cases: a Feature Toggle with a very simple
    REST API, and a Feature Toggle in a web application.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了这项技术并讨论了其利弊。我们还列举了一些典型情况，说明切换功能可以帮助解决问题。最后，我们实现了两种不同的用例：一个具有非常简单的REST
    API的功能切换，以及一个Web应用中的功能切换。
- en: Although the code presented in this chapter is fully functional, it isn't very
    common to use a file-based property system for this matter. There are many libraries
    more suitable for production environments that can help us to implement this technique,
    providing a lot of capabilities, such as using a web interface to handle features,
    storing preferences in a database, or allowing access to concrete user profiles.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章中介绍的代码是完全功能的，但通常不常使用基于文件的属性系统来处理此事。有许多更适合生产环境的库可以帮助我们实现这种技术，提供许多功能，例如使用Web界面处理功能、将偏好存储在数据库中或允许访问具体用户配置文件。
- en: In the next chapter we are going to put the TDD concepts described in the book
    all together. We are going to name some good practices and recommendations that
    are very useful when programming in the TDD way.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把书中描述的TDD概念整合在一起。我们将提出一些编程TDD方式时非常有用的良好实践和建议。
