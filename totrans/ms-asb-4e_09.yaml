- en: '*Chapter 7*: Controlling Task Conditions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is a system for running tasks on one or more hosts, and ensuring that
    operators understand whether changes have occurred (and indeed whether any issues
    were encountered). As a result, Ansible tasks result in one of four possible statuses: `ok`, `changed`, `failed`,
    or `skipped`. These statuses perform a number of important functions.
  prefs: []
  type: TYPE_NORMAL
- en: From the perspective of an operator running an Ansible playbook, they provide
    an overview of the Ansible run that has been completed—whether anything changed
    or not and whether there were any failures that need addressing. In addition,
    they determine the flow of the playbook—for example, if a task results in a `changed` status,
    we might want to perform a restart of the service, but otherwise leave it running.
    Ansible possesses all the necessary functions to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if a task results in a `failed` status, the default behavior of Ansible
    is not to attempt any further tasks on that host. Tasks can also make use of conditionals
    that check the status of previous tasks to control operations. As a result, these
    statuses, or task conditions, are central to just about everything Ansible does,
    and it is important to understand how to work with them and hence control the
    flow of a playbook to cater for cases where, for example, a failure might occur.
    We'll look at how exactly to handle such things in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll explore this in detail, focusing specifically on the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling what defines a failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recovering gracefully from a failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling what defines a change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating over a set of tasks using loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the examples presented in this chapter, you will need a Linux machine
    running **Ansible 4.3** or newer. Almost any flavor of Linux should do—for those
    interested in specifics, all the code presented in this chapter was tested on
    **Ubuntu Server 20.04 LTS** unless stated otherwise, and on Ansible 4.3\. The
    example code that accompanies this chapter can be downloaded from GitHub at this
    URL: [https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter07).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3AVXxME](https://bit.ly/3AVXxME).'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a failure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most modules that ship with Ansible have differing criteria for what constitutes
    an error. An error condition is highly dependent upon the module and what the
    module is attempting to accomplish. When a module returns an error, the host will
    be removed from the set of available hosts, preventing any further tasks or handlers
    from being executed on that host. Furthermore, the `ansible-playbook` and `ansible`
    executables will exit with a non-zero exit code to indicate failure. However,
    we are not limited by a module's opinion of what an error is. We can ignore errors
    or redefine an error condition.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A task condition named `ignore_errors` is used to ignore errors. This condition
    is a Boolean, meaning that the value should be something Ansible understands to
    be `true`, such as `yes`, `on`, `true`, or `1` (string or integer).
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how to use `ignore_errors`, let''s create a playbook where we
    attempt to query a web server that doesn''t exist. Typically, this would be an
    error, and if we don''t define `ignore_errors`, we get the default behavior; that
    is, the host will be marked as failed and no further tasks will be attempted on
    that host. Create a new playbook called `error.yaml`, as follows, to look further
    at this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this playbook with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The single task in this playbook should result in an error that looks like
    that shown in *Figure 7.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Running a playbook that deliberately induces a task error'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_07_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Running a playbook that deliberately induces a task error
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s imagine that we didn''t want Ansible to stop here, and instead
    we wanted it to continue. We can add the `ignore_errors` condition to our task
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, when we run the playbook using the same command as before, our error will
    be ignored, as shown in *Figure 7.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Running the same playbook but with the ignore_errors task condition
    added'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_07_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – Running the same playbook but with the ignore_errors task condition
    added
  prefs: []
  type: TYPE_NORMAL
- en: Any further tasks for that host will still be attempted and the playbook does
    not register any failed hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an error condition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ignore_errors` condition is a bit of a blunt instrument. Any error generated
    from the module used by the task will be ignored. Furthermore, the output, at
    first glance, still appears like an error and may be confusing to an operator
    attempting to discover a real failure. A more subtle tool is the `failed_when`
    condition. This condition is more like a fine scalpel, allowing a playbook author
    to be very specific as to what constitutes an error for a task. This condition
    performs a test to generate a Boolean result, much like the `when` condition.
    If the condition results in a Boolean `true` value, the task will be considered
    a failure. Otherwise, the task will be considered successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `failed_when` condition is quite useful when used in combination with the
    `command` or `shell` module and registering the result of the execution. Many
    programs that are executed can have detailed non-zero exit codes that mean different
    things. However, these Ansible modules all consider an exit code of anything other
    than `0` to be a failure. Let''s look at the `iscsiadm` utility. This utility
    can be used for many things related to iSCSI. For the sake of demonstration, we''ll
    replace our `uri` module in `error.yaml` and attempt to discover any active `iscsi`
    sessions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this playbook using the same command as before; unless you happen to be
    on a system with active iSCSI sessions, you will see output very much like that
    in *Figure 7.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Running a playbook to discover active iSCSI sessions without
    any failure handling'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_07_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – Running a playbook to discover active iSCSI sessions without any
    failure handling
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The `iscsiadm` tool may not be installed by default, in which case you will
    get a different error from the preceding one. On our Ubuntu Server 20.04 test
    machine, it was installed using the following command: `sudo apt install open-iscsi`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can just use the `ignore_errors` condition, but that would mask other problems
    with `iscsi`, so instead of this, we want to instruct Ansible that an exit code
    of `21` is acceptable. To that end, we can make use of the registered variable
    to access the `rc` variable, which holds the return code. We''ll make use of this
    in a `failed_when` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We simply stated that any exit code other than `0` or `21` should be considered
    a failure. Run the playbook again, but this time with added verbosity, using the
    `-v` flag on your command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming again that you have no active iSCSI sessions, the output will look
    like that shown in *Figure 7.4*. Use of the `-v` flag is, of course, not mandatory,
    but it is helpful in this case as it shows us the exit code of the `iscsiadm`
    utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Running the same playbook but handling failures based on the
    command exit code'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_07_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – Running the same playbook but handling failures based on the command
    exit code
  prefs: []
  type: TYPE_NORMAL
- en: The output now shows no error, and, in fact, we see a new data key in the results—`failed_when_result`.
    This shows whether our `failed_when` statement rendered `true` or `false`; it
    was `false` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many command-line tools do not have detailed exit codes. In fact, most typically
    use `0` for success and another non-zero code for all failure types. Thankfully,
    the `failed_when` statement is not just limited to the exit code of the application;
    it is a free-form Boolean statement that can access any sort of data required.
    Let''s look at a different problem, one involving `Git`. We''ll imagine a scenario
    where we want to ensure that a particular branch does not exist in a `Git` checkout.
    This task assumes a `Git` repository is checked out in the `/srv/app` directory.
    The command to delete a `Git` branch is `git branch -D`. Let''s have a look at
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For this code to work, you will need to check a `Git` repository out into the
    preceding directory. If you don''t have one to test with, you can easily create
    one using the following commands (just make sure you don''t have anything important
    in `/srv/app` that could get overwritten!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once you have done this, you are ready to run the updated playbook task we detailed
    previously. Like before, we'll add verbosity to the output so that we can better
    understand the behavior of our playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The `ansible.builtin.command` and `ansible.builtin.shell` modules use a different
    format for providing module arguments. `ansible.buitin.command` itself is provided
    in free form, while module arguments go into an `args` hash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the playbook as described should yield an error, as `git` will produce
    an exit code of `1`, as the branch does not exist, as shown in *Figure 7.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Running a git command in an Ansible playbook with no error handling'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_07_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – Running a git command in an Ansible playbook with no error handling
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the error was not handled gracefully, and the play for `localhost`
    has been aborted.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: We're using the `ansible.builtin.command` module to easily demonstrate our topic
    despite the existence of the `ansible.builtin.git` module. When dealing with Git
    repositories, the `ansible.builtin.git` module should be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without the `failed_when` and `changed_when` conditions, we would have to create
    a two-step task combo to protect ourselves from errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the scenario where the branch doesn''t exist, running these tasks should
    look as in *Figure 7.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Handling errors using two tasks in an Ansible playbook'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_07_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – Handling errors using two tasks in an Ansible playbook
  prefs: []
  type: TYPE_NORMAL
- en: 'While the two-task set is functional, it is not efficient. Let''s improve upon this
    and leverage the `failed_when` functionality to reduce the two tasks to one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Multiple conditions that would normally be joined with `and` can instead be
    expressed as list elements. This can make playbooks easier to read and logic issues
    easier to find.
  prefs: []
  type: TYPE_NORMAL
- en: 'We check the command return code for anything other than `0` and then use the
    `search` filter to search the `stderr` value with a `branch.*not found` regex.
    We use Jinja2 logic to combine the two conditions, which will evaluate to an inclusive `true` or `false` option,
    as shown in *Figure 7.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Handling errors efficiently in a single task within an Ansible
    playbook'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_07_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – Handling errors efficiently in a single task within an Ansible
    playbook
  prefs: []
  type: TYPE_NORMAL
- en: This demonstrates how we can redefine failure in an Ansible playbook, and gracefully
    handle conditions that would otherwise disrupt a play. We can also redefine what
    Ansible sees as a change, and we will look at this next.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to defining a task failure, it is also possible to define what constitutes
    a changed task result. This capability is particularly useful with the `ansible.builtin.command` family
    of modules (`command`, `shell`, `raw`, and `script`). Unlike most other modules,
    the modules of this family do not have an inherent idea of what a change may be.
    In fact, unless otherwise directed, these modules only result in `failed`, `changed`,
    or `skipped`. There is simply no way for these modules to assume a changed versus
    unchanged condition, as they cannot be expected to understand or interpret every
    possible shell command you might execute using them.
  prefs: []
  type: TYPE_NORMAL
- en: The `changed_when` condition allows a playbook author to instruct a module on
    how to interpret a change. Just like `failed_when`, `changed_when` performs a
    test to generate a Boolean result. Frequently, the tasks used with `changed_when` are
    commands that will exit non-zero to indicate that no work is needed to be done;
    so, often, authors will combine `changed_when` and `failed_when` to fine-tune
    the task result evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our previous example, the `failed_when` condition caught the case where
    there was no work to be done but the task still showed a change. We want to register
    a change on the exit code `0`, but not on any other exit code. Let''s expand our
    example task to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run our task when the branch still does not exist (again adding
    verbosity to the output to help us see what''s going on under the hood), we''ll
    see output similar to that shown in *Figure 7.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Extending our Git playbook with a changed_when task condition'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_07_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8 – Extending our Git playbook with a changed_when task condition
  prefs: []
  type: TYPE_NORMAL
- en: Note how the `changed` key now has the value `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just for the sake of completeness, we''ll change the scenario so that the branch
    does exist and run it again. To create the branch, simply run `git branch badfeature` from
    the `/srv/app` directory. Now, we can execute our playbook once again to see the
    output, which should now look like that shown in *Figure 7.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Testing the same playbook when the badfeature branch exists
    in our test repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_07_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.9 – Testing the same playbook when the badfeature branch exists in
    our test repository
  prefs: []
  type: TYPE_NORMAL
- en: This time, our output is different; it's registering a change, and the `stdout` data
    shows the branch being deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Special handling of the command family
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A subset of the command family of modules (`ansible.builtin.command`, `ansible.builtin.shell`,
    and `ansible.builtin.script`) has a pair of special arguments that will influence
    whether the task work has already been done, and thus, whether or not a task will
    result in a change. The options are `creates` and `removes`. These two arguments
    expect a file path as a value. When Ansible attempts to execute a task with the
    `creates` or `removes` arguments, it will first check whether the referenced file
    path exists.
  prefs: []
  type: TYPE_NORMAL
- en: If the path exists and the `creates` argument was used, Ansible will consider
    that the work has already been completed and will return `ok`. Conversely, if
    the path does not exist and the `removes` argument is used, then Ansible will
    again consider the work to be complete, and it will return `ok`. Any other combination
    will cause the work to actually happen. The expectation is that whatever work
    the task is doing will result in either the creation or removal of the file that
    is referenced.
  prefs: []
  type: TYPE_NORMAL
- en: 'The convenience of `creates` and `removes` saves developers from having to
    do a two-task combo. Let''s create a scenario where we want to run the `frobitz`
    script from the `files/` subdirectory of our project root. In our scenario, we
    know that the `frobitz` script will create a path, `/srv/whiskey/tango`. In fact,
    the source of `frobitz` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t want this script to run twice as it can be destructive to any existing
    data. Replacing the existing tasks in our `error.yaml` playbook, the two-task
    combo will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the playbook with added verbosity as we have done throughout this chapter
    so far. If the `/srv/whiskey/tango` path already exists, the output will be as
    shown in *Figure 7.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – A two-task play to conditionally run a destructive script only
    when necessary'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_07_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.10 – A two-task play to conditionally run a destructive script only
    when necessary
  prefs: []
  type: TYPE_NORMAL
- en: If the `/srv/whiskey/tango` path did not exist, the `ansible.builtin.stat` module
    would have returned far less data, and the `exists` key would have a value of `false`.
    Thus, our `frobitz` script would have been run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll use `creates` to reduce this down to a single task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The `ansible.builtin.script` module is actually an `action_plugin`, which will
    be discussed in [*Chapter 10*](B17462_10_Final_JC_ePub.xhtml#_idTextAnchor183), *Extending
    Ansible*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, our output will be slightly different, as *Figure 7.11* shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Making our previous playbook more efficient by combining all
    task conditions into one task'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_07_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.11 – Making our previous playbook more efficient by combining all task
    conditions into one task
  prefs: []
  type: TYPE_NORMAL
- en: On this occasion, we simply skipped running the script altogether as the directory
    already existed before the playbook was even run. This saves time during the playbook
    execution and also prevents any potentially destructive actions that might occur
    from running a script.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Making good use of `creates` and `removes` will keep your playbooks concise
    and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Suppressing a change
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, it can be desirable to completely suppress changes. This is often
    used when executing a command in order to gather data. The command execution isn't
    actually changing anything; instead, it's just gathering info, like the `ansible.builtin.setup` module.
    Suppressing changes on such tasks can be helpful for quickly determining whether
    a playbook run resulted in any actual change in the fleet.
  prefs: []
  type: TYPE_NORMAL
- en: 'To suppress changes, simply use `false` as an argument to the `changed_when` task
    key. Let''s extend one of our previous examples to discover the active `iscsi` sessions
    to suppress changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, no matter what comes in the return data, Ansible will treat the task as `ok` rather
    than changed, as *Figure 7.12* shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Suppressing changes in Ansible playbooks'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_07_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.12 – Suppressing changes in Ansible playbooks
  prefs: []
  type: TYPE_NORMAL
- en: Thus, there are only two possible states to this task now—`failed` and `ok`.
    We have actually negated the possibility of a `changed` task result. Of course,
    failures when running code are a part of life, and it is important that we are
    able to handle these gracefully in our playbooks. In the next section, we will
    look at how this is achieved in Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Error recovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While error conditions can be narrowly defined, there will be times when real
    errors happen. Ansible provides a method to react to true errors, a method that
    allows running additional tasks when an error occurs, defining specific tasks
    that always execute even if there was an error, or even both. This method is the
    **block** feature.
  prefs: []
  type: TYPE_NORMAL
- en: The blocks feature, introduced with Ansible version 2.0, provides some additional
    structure to related sets of play task. Blocks can group tasks together into a
    logical unit, which can have task controls applied to the unit (or block) as a
    whole. In addition, a block of tasks can have optional `rescue` and `always` sections,
    which execute on condition of an error and regardless of the error state, respectively.
    We will explore how these work in the following two sections.
  prefs: []
  type: TYPE_NORMAL
- en: Using the rescue section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `rescue` section of a block defines a logical unit of tasks that will be
    executed should an actual failure be encountered within the block. As Ansible
    performs the tasks within a block, executing from top to bottom as it normally
    does, when an actual failure is encountered, execution will jump to the first
    task of the `rescue` section of the block (if it exists; this section is optional).
    Then, tasks are performed from top to bottom until either the end of the `rescue`
    section is reached or another error is encountered.
  prefs: []
  type: TYPE_NORMAL
- en: After the `rescue` section completes, task execution continues with whatever
    comes after the block, as if there were no errors. This provides a way to gracefully
    handle errors, allowing `cleanup` tasks to be defined so that a system is not
    left in a completely broken state, and the rest of a play can continue. This is
    far cleaner than a complex set of task-registered results and task conditionals
    based on the error status.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this, let's create a new task set inside a block. This task set
    will have an unhandled error in it that will cause execution to switch to the `rescue` section,
    from where we'll perform a `cleanup` task.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also provide a task after the block to ensure execution continues. We''ll
    reuse the `error.yaml` playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The two tasks listed in the `block` section are executed in the order in which
    they are listed. Should one of them result in a `failed` result, the following
    code shown in the `rescue` block will be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, this task is executed regardless of the earlier tasks. Note how the
    lower indentation level means it gets run at the same level as the block, rather
    than as part of the `block` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Try executing this playbook to observe its behavior; add verbosity to the output
    as we have throughout this chapter to help you understand what is going on. When
    this play executes, the first task will result in an error, and the second task
    will be passed over. Execution continues with the `cleanup` tasks, and should
    look as in *Figure 7.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Executing a playbook containing a block with a rescue section'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_07_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.13 – Executing a playbook containing a block with a rescue section
  prefs: []
  type: TYPE_NORMAL
- en: Not only was the `rescue` section executed, but the rest of the play completed as
    well, and the whole `ansible-playbook` execution was considered successful in
    spite of the earlier task failure inside the block. Let's build on this example
    in the next section by looking at the `always` section of a block.
  prefs: []
  type: TYPE_NORMAL
- en: Using the always section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to `rescue`, we can also use another section, named `always`. This
    section of a block will always be executed irrespective of whether there were
    errors. This feature is handy for ensuring that the state of a system is always left
    functional, irrespective of whether a block of tasks was successful. As some tasks
    of a block may be skipped due to an error, and a `rescue` section is only executed
    when there is an error, the `always` section provides the guarantee of task execution
    in every instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extend our previous example and add an `always` section to our block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerunning our playbook as in the previous section, we see the additional task
    displayed, as shown in *Figure 7.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Running an Ansible playbook containing a block with both rescue
    and always sections'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_07_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.14 – Running an Ansible playbook containing a block with both rescue
    and always sections
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that the `always` section does indeed always execute, we can alter
    the play so that the Git task is considered successful using the task conditionals
    we developed in the earlier section, *Defining an error condition*. The first
    part of this modified playbook is shown in the following snippet for your reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note the changed `failed_when` condition, which will enable the `git` command
    to run without being considered a failure. The rest of the playbook (which should,
    by now, have been built up in the previous examples) remains unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, when we execute the playbook, our `rescue` section is skipped over,
    our previously masked-by-error task is executed, and our `always` block is still
    executed, as *Figure 7.15* demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 – Executing a playbook containing a block with rescue and always
    sections but without task errors'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_07_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.15 – Executing a playbook containing a block with rescue and always
    sections but without task errors
  prefs: []
  type: TYPE_NORMAL
- en: Note also that our previously lost task is now executed, as the failure condition for
    the `delete branch bad` task was changed such that it no longer fails in this
    play. In a similar manner, our `rescue` section is no longer needed, and all other
    tasks (including the `always` section) complete as expected. In the final part
    of our look at error recovery in Ansible, we'll see how to handle errors caused
    by unreliable environments.
  prefs: []
  type: TYPE_NORMAL
- en: Handling unreliable environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far in this chapter, we have focused on gracefully handling errors, and changing
    the default behavior of Ansible with respect to changes and failures. This is
    all well and good for tasks, but what about if you are running Ansible in an unreliable
    environment? For example, poor or transient connectivity might be used to reach
    the managed hosts, or hosts might be down on a regular basis for some reason.
    The latter example might be a dynamically scaled environment that could be scaled
    up in times of high load and scaled back when demand is low to save on resources—hence
    you cannot guarantee that all hosts will be available at all times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, a playbook keyword, `ignore_unreachable`, handles exactly these cases,
    and ensures that all tasks are attempted on our inventory even for hosts that
    get marked as unreachable during the execution of a task. This is in contrast
    to the default behavior where Ansible will stop processing tasks for a given host
    once the first error occurs. As in so many cases, this is best explained by means
    of an example, so let''s reuse the `error.yaml` playbook to create such a case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to try to delete the `badfeature` branch from a Git repository
    on two remote hosts as defined in our inventory. This inventory will look a little
    different from the others we have used throughout this book, as we will deliberately
    create two fictitious hosts that are unreachable. It doesn''t matter what you
    actually call these hosts, or what IP addresses you define, but for the example
    to work as described in this section, the hosts must not be reachable. My inventory
    file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have deliberately created an inventory of hosts that don''t exist, we
    know they will get marked as `unreachable` as soon as the first task is attempted.
    In spite of this, there is a second task that absolutely must be attempted if
    at all possible. Let''s run the playbook as it is and see what happens; the output
    should look like that shown in *Figure 7.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16 – Attempting a two-task play on an inventory with unreachable
    hosts'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_07_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.16 – Attempting a two-task play on an inventory with unreachable hosts
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the output, the task called `important task` was never
    attempted—the play was aborted after the first task since the hosts were unreachable.
    However, let''s use our newly discovered flag to change this behavior. Change
    the code so that it looks like the code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, note that even though the hosts were unreachable on the first attempt,
    our second task is still executed, as *Figure 7.17* shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.17 – Attempting the same two-task play on unreachable hosts, but
    this time ignoring reachability'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_07_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.17 – Attempting the same two-task play on unreachable hosts, but this
    time ignoring reachability
  prefs: []
  type: TYPE_NORMAL
- en: This is useful if, like the `debug` command, it might run locally, or perhaps
    it is vital and should be attempted even if connectivity was down on the first
    attempt. So far in this chapter, you have learned about the tools Ansible provides
    to handle a variety of error conditions with grace. Next, we will proceed to look
    at controlling the flow of tasks using loops—an especially important tool for
    making code concise and preventing repetition.
  prefs: []
  type: TYPE_NORMAL
- en: Iterative tasks with loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loops deserve a special mention in this chapter. So far, we have focused on
    controlling the flow of a playbook in a top-to-bottom fashion—we have changed
    the various conditions that might be evaluated as the playbook runs, and we have
    also focused on creating concise, efficient code. What happens, however, if you
    have a single task, but need to run it against a list of data; for example, creating
    several user accounts, directories, or indeed something more complex?
  prefs: []
  type: TYPE_NORMAL
- en: Looping changed in Ansible 2.5—prior to this, loops were generally created with
    keywords such as `with_items` and you may still see this in legacy code. Although
    some backward compatibility remains, it is advisable to move to the newer `loop` keyword
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a simple example—we need to create two directories. Create `loop.yaml` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this, as expected, our two directories get created, as *Figure
    7.18* shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.18 – Running a simple playbook to create two directories'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_07_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.18 – Running a simple playbook to create two directories
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you can see this code is repetitive and inefficient. Instead, we could
    change it to something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the use of the special `item` variable, which is now used to define the path from
    the `loop` items at the bottom of the task. Now, when we run this code, the output
    looks somewhat different, as *Figure 7.19* shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19 – A playbook to create the same two directories, but this time
    using'
  prefs: []
  type: TYPE_NORMAL
- en: a loop for more efficient code
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_07_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.19 – A playbook to create the same two directories, but this time using
    a loop for more efficient code
  prefs: []
  type: TYPE_NORMAL
- en: The two directories were still created exactly as before, but this time within
    a single task. This makes our playbooks much more concise and efficient. Ansible
    offers many more powerful looping options, including nested loops and the ability
    to create loops that will carry on until a given criterion is met (often referred
    to as `do until` loops in other languages), as opposed to a specific limited set
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: '`do until` loops are incredibly useful when waiting for a certain condition
    to be met. For example, if we wanted to wait until a flag file is written to the
    filesystem, we could use the `ansible.builtin.stat` module to query the file,
    register the result of the module run to a variable, and then run this in a loop
    until the condition that the file exists is met. The following code fragment shows
    exactly this—it will loop (`retries`) five times, with a 10-second delay between
    each retry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Nested loops can be created in one of two ways—either by iterating over nested
    lists or by iterating over an included tasks file. For example, let''s assume
    we want to create two new files, each in two paths (as defined by two lists in
    Ansible). Our code might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have used the `product` Jinja2 filter to create a nested list out
    of the two variable lists, which `loop` then faithfully iterates for us. Running
    this playbook should yield output that looks like that in *Figure 7.20*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.20 – Running a playbook using a nested loop built with the product
    Jinja2 filter'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_07_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.20 – Running a playbook using a nested loop built with the product
    Jinja2 filter
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create a nested loop by including an external tasks file within
    an outer loop and then placing an inner loop within the tasks file. Now, if you
    do this without doing anything further, both loops will use the `item` loop variable,
    which of course will clash. To prevent this from being an issue, it is necessary
    to use one of the special `loop_control` parameters to change the loop variable
    name for the outer loop. Thus, using the same header code and variables as before,
    we could change our original task to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The included tasks file would then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This code performs exactly the same function as the first nested loop example,
    but is a little more cumbersome as it requires an external tasks file. In addition,
    you will see from the screenshot in *Figure 7.21* that the way that it operates
    is somewhat different. This is important to factor in when you are building nested
    loops as this may (or may not) be what you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.21 – Building nested loops in Ansible through an included tasks
    file, using the loop_control variable'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_07_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.21 – Building nested loops in Ansible through an included tasks file,
    using the loop_control variable
  prefs: []
  type: TYPE_NORMAL
- en: It could be said that it's easier to read this format, though, and ultimately
    it is up to you to determine which you prefer for your needs, and indeed whether
    one is more suitable for you than the other. Full details of loop creation techniques
    and parameters are available in the Ansible documentation here: [https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned that it is possible to define specifically how
    Ansible perceives a failure or a change when a specific task is run, how to use
    blocks to gracefully handle errors and perform cleanup, and how to write tight,
    efficient code using loops.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, you should now be able to alter any given task to provide specific
    conditions under which Ansible will fail it or consider a change successful. This
    is incredibly valuable when running shell commands, as we have demonstrated in
    this chapter, and also serves when defining specialized use cases for existing
    modules. You should also now be able to organize your Ansible tasks into blocks,
    ensuring that if failures do occur, recovery actions can be taken that would otherwise
    not need to be run. Finally, you should now be able to write tight, efficient
    Ansible playbooks using loops, removing the need for repetitive code and lengthy,
    inefficient playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll explore the use of roles for organizing tasks, files,
    variables, and other content.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, Ansible will stop processing further tasks for a given host after
    the first failure occurs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) True
  prefs: []
  type: TYPE_NORMAL
- en: b) False
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ansible.builtin.command` and `ansible.builtin.shell` modules'' default
    behavior is to only ever give a task status of `changed` or `failed`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) True
  prefs: []
  type: TYPE_NORMAL
- en: b) False
  prefs: []
  type: TYPE_NORMAL
- en: You can store the results from a task using which Ansible keyword?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `store:`
  prefs: []
  type: TYPE_NORMAL
- en: b) `variable:`
  prefs: []
  type: TYPE_NORMAL
- en: c) `register:`
  prefs: []
  type: TYPE_NORMAL
- en: d) `save:`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following directives can be used to change the failure condition
    of a task?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `error_if:`
  prefs: []
  type: TYPE_NORMAL
- en: b) `failed_if:`
  prefs: []
  type: TYPE_NORMAL
- en: c) `error_when:`
  prefs: []
  type: TYPE_NORMAL
- en: d) `failed_when:`
  prefs: []
  type: TYPE_NORMAL
- en: You can combine multiple conditional statements in Ansible using which of the
    following?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `and`
  prefs: []
  type: TYPE_NORMAL
- en: b) `or`
  prefs: []
  type: TYPE_NORMAL
- en: c) The YAML list format (which works the same as a logical `AND`)
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the above
  prefs: []
  type: TYPE_NORMAL
- en: Changes can be suppressed with which of the following?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a) `suppress_changed: true`'
  prefs: []
  type: TYPE_NORMAL
- en: 'b) `changed_when: false`'
  prefs: []
  type: TYPE_NORMAL
- en: 'c) `changed: false`'
  prefs: []
  type: TYPE_NORMAL
- en: 'd) `failed_when: false`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a `block` section, all tasks are executed in order on all hosts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Until the first error occurs
  prefs: []
  type: TYPE_NORMAL
- en: b) Regardless of any error condition
  prefs: []
  type: TYPE_NORMAL
- en: Which optional section of a block gets run only if an error occurs in the block
    tasks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `recover`
  prefs: []
  type: TYPE_NORMAL
- en: b) `rescue`
  prefs: []
  type: TYPE_NORMAL
- en: c) `always`
  prefs: []
  type: TYPE_NORMAL
- en: d) `on_error`
  prefs: []
  type: TYPE_NORMAL
- en: 'Tasks in the `always` section of a block are run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Regardless of what happened in either the block tasks or the `rescue` section
  prefs: []
  type: TYPE_NORMAL
- en: b) Only if the `rescue` section did not get run
  prefs: []
  type: TYPE_NORMAL
- en: c) Only if no errors were encountered
  prefs: []
  type: TYPE_NORMAL
- en: d) When called manually by the user
  prefs: []
  type: TYPE_NORMAL
- en: 'The default name of the variable referencing the current element of a loop
    is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `loopvar`
  prefs: []
  type: TYPE_NORMAL
- en: b) `loopitem`
  prefs: []
  type: TYPE_NORMAL
- en: c) `item`
  prefs: []
  type: TYPE_NORMAL
- en: d) `val`
  prefs: []
  type: TYPE_NORMAL
