- en: Chapter 2. Evolution of C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we look back at the entire history of C#, leading up to the
    latest version. We will not be able to cover everything, but we will touch on
    the major features, especially the ones which are historically relevant. Each
    release brought unique features that would serve as the building blocks for innovations
    in versions yet to come.
  prefs: []
  type: TYPE_NORMAL
- en: C# 1.0 – in the beginning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When C# was introduced, Microsoft wanted to take the best features of many
    other languages and runtimes. It was an object oriented language, with a runtime
    that actively manages memory for you. Some of the features of this language (and
    framework) are:'
  prefs: []
  type: TYPE_NORMAL
- en: Object oriented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managed memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rich base class library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common Language Runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type safety
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regardless of your technology background, there was something in C# that you
    could relate to.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is impossible to talk about C#, without first talking about the runtime,
    called the **Common Language Runtime** (**CLR**). One of the major underpinnings
    of the CLR was the ability to interoperate with multiple languages, which meant
    that you would be able to write your program in a number of different languages,
    and it would run on the same runtime. This interoperability was accomplished by
    agreeing to a common set of data types, referred to as the **common type system**.
  prefs: []
  type: TYPE_NORMAL
- en: Before the .NET Framework, there was really no clear mechanism for different
    languages to talk to each other. A string in one environment may not match the
    concept of a string in another language and would they be null terminated? Are
    they encoded in ASCII? How is that number represented? There was simply no way
    to know, because each language did its own thing. Of course people tried to come
    up with solutions to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: In the Windows world, the most well-known solution was to use the **Component
    Object Model** (**COM**), which used a type library to describe the types contained
    therein. By exporting this type library, a program could talk to other processes
    that may or may not have been written using another technology, because you were
    sharing details about how to communicate. However this was not without complexity,
    as anyone who wrote COM libraries using Visual Basic 6 could tell you. Not only
    was the process generally somewhat opaque because the tool abstracted out the
    underlying technology, but deployment was a nightmare. There was even a well-known
    phrase for working with it, DLL Hell.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET Framework was, in part, a response to this problem. It introduces the
    common type system into the picture, which are rules that every language running
    on the CLR needs to adhere to, including common data types such as strings and
    numeric types, the way object inheritance works, and type visibility.
  prefs: []
  type: TYPE_NORMAL
- en: For maximum flexibility, instead of compiling directly to native binary code,
    an intermediate representation of program code is used as the actual binary image,
    which is distributed and executed, called **MSIL** . This MSIL is then compiled
    the first time you run the program, so that optimizations can be put in place
    for the specific processor architecture that the program is being run on (the
    **Just-In-Time** (**JIT**) compiler). This means that a program that runs on the
    server and on a desktop could have different performance characteristics based
    on the hardware. In the past, you would have had to compile two different versions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Runtime](img/6761EN_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another benefit of inherent, multilingual support, is that it served as a migration
    strategy. A number of different languages came out at the same time as C#. Companies
    that had an existing codebase in various languages could easily convert their
    program to a .NET friendly version, which was CLR compatible, and subsequently
    use it from other .NET languages such as C#. Some of the languages include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VB.NET**: This is the natural successor to the popular Visual Basic 6.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**J#**: This is a version of the Java language for .NET.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Managed extensions for C++**: With a flag, and a few new keywords and syntax,
    you could take an existing C++ application, and compile it to a version compatible
    with the CLR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While a number of these languages shipped, and were pitched as fully supported,
    these days the only ones that really remain of the original languages that shipped
    are VB.Net and C#, and to a lesser degree, C++/CLI. Many new languages such as
    F#, IronPython, and IronRuby have sprung up on the CLR over the years, and they
    remain active in development, with vibrant communities.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Common Language Runtime provides a **garbage collector** , which means that
    memory will be collected automatically when an object is no longer referenced
    by other objects. This was not a new concept of course; many languages such as
    JavaScript and Visual Basic support garbage collection. Unmanaged languages, on
    the other hand, let you manually allocate memory on the heap if you so choose.
    And although this ability gives you way more power when it comes to the kinds
    of low-level solutions you can implement, it also gives you more opportunities
    to make mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the two kinds of data types that the CLR allows for:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Value types**: These data types are created using the `struct` keyword'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reference types**: These data types are created using the `class` keyword'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every primitive data type in C#, such as `int` and `float`, is `struct`, while
    every class is a reference type. There are some semantics around how these types
    are allocated internally (stack versus heap), but for day-to-day use those differences
    are usually not important.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can of course create your own custom types of both kinds. For example,
    the following is a simple value type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'By changing a single keyword, you can change this object to a reference type
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are two major differences between `struct` instances and `class` instances.
    Firstly, a `struct` instance cannot inherit, or be inherited from. The `class`
    instances, however, are the primary vehicles for creating object oriented hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, `class` instances participate in the garbage collection process,
    while `struct` instances do not, at least not directly. Many discussions on the
    Internet tend to generalize the memory allocation strategy of value types as being
    allocated on the stack, while reference types are allocated on the heap (see the
    following diagram), but that is not the whole story:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Memory management](img/6761EN_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is generally some truth to this, because when you instantiate `class`
    in a method, it will always go on the heap, while creating a value type such as
    an `int` instance will go on the stack. But if the value type is wrapped in a
    reference type, for example, when the value type is a field in a `class` instance,
    then it will be allocated on the heap along with the rest of the class data.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The name C# is a cheeky reference to the C language, just as C++ was C (plus
    some stuff), C# too is largely similar in syntax to C and C++, though with some
    obvious changes. Unlike C, C# is an object oriented language, but with a few interesting
    features that make it easier and more efficient to write than other object oriented
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'One example of this is the property getters and setters. In other languages,
    if you want to control how you expose access and modifications to the data of
    a `class` instance, you would have to make the field private so an outsider could
    not change it directly. Then you would make two methods, one prefixed with `get`
    to retrieve the value, and one prefixed with `set` to the value. In C#, the compiler
    takes care of generating those method pairs for you. Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Another interesting innovation is how C# provides first class event support.
    In other languages such as Java, they approximated events by, for example, having
    a method called `setOnClickListener(OnClickListener listener)` . To use it, you
    have to define a new class that implements the `OnClickListener` interface and
    pass it in. This technique definitely works, but can be kind of verbose. With
    C#, you can define what is called a **delegate** to represent a method as a proper,
    self-contained object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This `delegate` can then be used as an event on a class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To register for notification when the event is raised, you can just create
    the delegate and use the `+=` syntax to add it to the delegate list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The language will automatically add the delegate to a list of delegates, which
    will be notified whenever the event is raised. In Java, that kind of behavior
    would have to be implemented manually.
  prefs: []
  type: TYPE_NORMAL
- en: There were many other interesting syntactic features when C# was launched, such
    as the way exceptions worked, the using statement, and others. But in the interest
    of brevity, let's move on.
  prefs: []
  type: TYPE_NORMAL
- en: Base Class Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, C# comes with a rich and vast framework called the **Base Class
    Library** (**BCL**). The BCL provides a wide array of functionality as shown in
    the next diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Base Class Library](img/6761EN_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The diagram shows a few of the namespaces that are included in the base class
    library (emphasis on a few). While there are a large number of other namespaces,
    these are a few of the most important ones, which provide the infrastructure for
    many of the features and libraries that have been released by Microsoft and third
    parties.
  prefs: []
  type: TYPE_NORMAL
- en: One of the data structure types you discover when learning how to program is
    the one that deals with collection of information. Typically, you learn to write
    most of the programs and algorithms using arrays. With an array though, you have
    to know the size of the collection ahead of time. The `System.Collections` namespace
    comes with a set of collection of data structures that make it easy to handle
    an unknown amount of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the very first program I ever wrote (described briefly in the previous chapter),
    I used an array that was pre-allocated. To keep things simple, the array was allocated
    with an arbitrarily large number of elements so that I would not run out of spaces
    in the array. Of course, that would never work in a non-trivial program written
    professionally because you will either run out of space if you encounter a larger
    than expected set of data, or it will be wasteful of memory. Here, we can use
    one of the most basic collection types, the `ArrayList` collection, to overcome
    that problem, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, an instance of the `ArrayList` collection was created, but no
    size was specified. This is because collection types manage their sizes internally.
    This abstraction relieves you of the size responsibility so you can worry about
    bigger things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the other collection types that are available are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HashTable`: This type allows you to provide a lookup key and a value. It is
    often used to create very simple in-memory databases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stack`: This is a first in, last out data structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Queue`: This is a first in, first out data structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at the concrete collection, classes do not really tell the whole story
    though. If you follow the inheritance chain, you will notice that every collection
    implements an interface called `IEnumerable`. This will come to be one of the
    most important interfaces in the whole language so getting familiar with it early
    on is important.
  prefs: []
  type: TYPE_NORMAL
- en: '`IEnumerable`, and the sister class, `IEnumerator` , abstract the concept of
    enumeration over a collection of items. You will always see these interfaces used
    in tandem, and they are very simple. You can see this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, you may wonder why collections implement `IEnumerable`, which
    has a single method that returns an `IEnumerator`, rather than just implementing
    `IEnumerator` directly. The enumerator is responsible for enumerating through
    a collection. But there is a good reason for this. If the collection itself was
    the enumerator, then you would not be able to iterate over the same collection
    concurrently. So each call to `GetEnumerator()` will generally return a separate
    enumerator, though that is by no means a requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the interface is very simple, it turns out that having this abstraction
    is very powerful. C# implements a nice shorthand syntax for iterating over a collection
    without having to do the regular `for` loop using an index variable that you have
    to pass in. This is explained in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `foreach` syntax works because it is shorthand for the code the compiler
    will actually generate. It will generate code to interact with the enumerable
    behind the scenes. So the loop in the previous example will look like the compiled
    MSIL, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we have an example of the C# compiler generating code, that is different
    from what you have actually written. This will be the key in the evolution of
    C# to make the common patterns of code that you write easier to express, allowing
    you to be more efficient and productive.
  prefs: []
  type: TYPE_NORMAL
- en: To some developers, C# was a cheap imitation of Java when it first came out.
    But to developers like me, it was a breath of fresh air, offering performance
    improvements over interpreted languages such as VBScript, extra safety and simplicity
    from languages such as C++, and more low level power than languages such as JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: C# 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first major update of the C# language, Runtime, and .NET Framework was a
    big one. This release focused on making the language more concise and easier to
    write.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first update added a small capability to the property syntax. In 1.0, if
    you wanted a read only property, your only choice was to exclude the setter, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'All internal logic had to interact with the `_value` member directly. In many
    cases this was fine, except for cases where you needed to have some sort of logic
    governing when and how you were allowed to change that value. Or similarly, if
    you needed to raise an event, you would have to create a private method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Well no more in C# 2.0, as you can now create a private setter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A small feature, but it increased consistency because separate getter and setter
    methods were one of the things that C# tried to get rid of from the first version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting addition is that of **nullable** types. With value types,
    the compiler will not allow you to set them to a null value, however, you now
    have a new key character that you can use to signify a nullable value type as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Just by adding the question mark, the value type is marked as nullable, and
    you can use the `.HasValue` and `.Value` properties to make decisions on what
    to do in the case of null.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Delegates are a great addition to C# over other languages. They are the building
    blocks of the event systems. One drawback, however, in the way they were implemented
    in C# 1.0 is that they make reading code a bit more difficult, because the code
    that executes when the event is raised is actually written elsewhere. Continuing
    the trend of code simplification, **anonymous methods** let you write the code
    inline. For example, given the following delegate definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create an instance of the delegate using an anonymous method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is inline, short, and easy to understand. It also allows you to use
    delegates much like first-class functions in other languages such as JavaScript.
    But it goes beyond simply being easier to read. If you wanted to pass a parameter
    to a delegate that did not accept a parameter in C# 1.0, you had to create a custom
    class to wrap both the method implementation and the stored value. This way, when
    the delegate is invoked (thus executing the target method), it has access to the
    value. Any early multi-threaded code was full of code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This class accepts a value in the constructor and stores it in a private member.
    Then later when the delegate is invoked, the value can be used, as in this case
    using it to start a new thread. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With anonymous delegates, the compiler can step in and greatly simplify the
    usage pattern mentioned previously as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This might look simple, but there is some serious compiler magic going on here.
    The compiler has analyzed the code, realized that the anonymous method requires
    the `value` variable in the method body, and automatically generated a class similar
    to the `CustomThreadStarter` that we would have had to create in C# 1.0\. The
    result is code that you can easily read because it is all there, right in context
    with the rest.
  prefs: []
  type: TYPE_NORMAL
- en: Partial classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C# 1.0, it was common practice to use code generators to automate things
    such as custom collections. When you wanted to add your own methods and properties
    to the generated code, you would generally have to inherit from the class, or
    in some cases, directly edit the generated file. This meant that you had to be
    very careful to avoid regenerating the code, or risk overwriting your custom logic.
    You will find a comment similar to the following one in many first generation
    tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'C# 2.0 adds an additional keyword to your arsenal, `partial`. With **partial**
    classes, you can break up your classes among multiple files. To see this in action,
    create the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This represents the automatically generated code. Notice that the file contains
    `.generated` in the filename; this is a convention that was adopted, though is
    not necessary for this to work, it is just that both files are part of the same
    project. Then in a separate file, you can include the rest of the implementation
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: All members would then be available on the resulting type at runtime, as the
    compiler takes care to stitch the class together. You are free to regenerate the
    first file at will, without the risk of overwriting your changes.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The major feature addition of C# 2.0 is **generics**, which allows you to create
    classes that can be reused with multiple types of objects. In the past, this kind
    of programming could only be accomplished in two ways. You can use a common base
    class for the parameter, so that any object that inherits from that class can
    be passed in regardless of the concrete implementation. That works, sort of, but
    it becomes very limiting when you want to create a very general purpose data structure.
    The other method is really just a derivative of the first. Instead of using a
    base class of your own definition, go all the way up the inheritance tree and
    use `object` for your type parameter.
  prefs: []
  type: TYPE_NORMAL
- en: This works because all the types in .NET derive from `object`, so you can pass
    in anything. This is the method used by the original collection classes. But even
    this has problems, especially when it comes to passing in value types due to the
    effects of boxing. You also have to cast the type back out from object every single
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, all of these problems can be mitigated by using generics as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have defined a **generic type parameter** called `T`. The
    actual name of the generic type parameter can be anything, `T` is just used as
    a convention. When you instantiate the `Message` class, you can specify the kind
    of object you want to store in the `Value` property using this syntax, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So you can assign an integer to the field without worrying about performance,
    because the value will not be boxed. You also do not have to cast it when you
    want to use it, as you would if using object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generics are super powerful, but they are not omnipotent. To highlight a key
    deficiency, we will go over one of the first things that just about every C# developer
    tried when 2.0 was first released—generic math. Developers of applications that
    are math heavy will likely be using a mathematical library for their domain. For
    example, game developers (or really, anyone doing anything that involves 2D or
    3D spatial calculations) will always need a good `Vector` structure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'But the problem is that it is using the `float` data type for calculations.
    If you wanted to generalize it and support other numeric types such as `int`,
    `double`, or `decimal`, what do you do? Upon first glance, you would think that
    you could use generics to support this scenario as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Compiling this will result in an error, **Operator '+=' cannot be applied to
    operands of type 'T' and 'T'**. This is because, by default, only members from
    the `object` data type are available for the generic parameter, due to the fact
    that the compiler has no way of knowing what methods (and by extension, operations)
    are defined on the type you are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, Microsoft anticipated this to some degree, and added something
    called **generic type constraints** . These constraints let you give the compiler
    a hint at what kind of types callers will be allowed to use, which in turn means
    that you can use the features that you constrain. For example, look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have added a constraint that says that the type parameter `T` must
    be an `IEnumerable`. As a result, you can write the code and be safe in the knowledge
    that any caller that calls this method will only ever use a type that implements
    the `IEnumerable` interface as the type parameter. Some of the other parameter
    constraints you can use are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`class`: This says that the type parameter must be a reference type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct`: This implies that only value types are allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new()`: There must be a public constructor without parameters on this type.
    It will allow you to use syntax like `T value = new T()` to create new instances
    of the type parameter. Otherwise, the only thing you can do is something like
    `T value = default(T)`, which will return null for reference types, and zero for
    numeric primitives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<name of interface>`: This limits the type parameters to use the interface
    mentioned here, as shown with `IEnumerable` mentioned previously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<name of class>`: Any type used with this constraint must be of this type,
    or inherit from this type at some point in the inheritance chain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, because numeric data structures are value types, they cannot
    inherit, and thus have no common type to use in a type constraint that will give
    you the mathematical operators needed to do math.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule of thumb, generics are most useful in "framework" style code,
    which is to say general infrastructure for your applications, or data structures
    such as collections. In fact, some great new collection types became available
    in C# 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: Generic collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generics are perfect for collections because the collection itself doesn''t
    really have to interact with the objects that it contains; it just needs a place
    to put them. So with a collection, there are no constraints on the type parameter.
    All of the new generic collections can be found in the namespace as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As we discussed earlier, the most basic collection type that was in C# 1.0
    was an `ArrayList` collection, which worked really well at the time. However,
    value types would be boxed as it used `object` as its payload type, and you had
    to cast the object out into your target object type every time you wanted to pull
    out a value. With generics, we now have `List<T>` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage is practically identical to the `ArrayList` collection, but with
    the performance benefits of generics. Some of the other types available as generic
    classes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Queue<T>`: This is the same as the non-generic `Queue`, **first in, first
    out** (**FIFO**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stack<T>`: There are no differences here from the non-generic version of the
    `Stack`, **last in, first out** (**LIFO**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dictionary<T, K>`: This takes the place of the `Hashtable` collection from
    C# 1.0\. It uses two generic parameters for the key and value of each dictionary
    item. This means that you can use a key other than a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterator methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perhaps one of the more unique features to arrive in C# 2.0 was that of **iterator**
    methods. They are a way of having the compiler automatically generate a custom
    iteration over a sequence. That description is kind of abstract, admittedly, so
    the easiest way to explain it is with some code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous method, you see a method that returns `IEnumerable<string>`.
    In the method body, however, there are simply four consecutive lines of code that
    use the `yield` keyword. This tells the compiler to generate a custom enumerator
    that breaks up the method into each individual part between the yields, so that
    it is executed when a caller enumerates the returned value. This is shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: There are a lot of different ways to approach and use iterators, but the highlight
    here is how the C# compiler is getting smarter in this release. It is able to
    take your code and expand it. This lets you write code at a higher level of abstraction,
    which is an ongoing theme in the evolution of C#.
  prefs: []
  type: TYPE_NORMAL
- en: C# 3.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you thought C# 2.0 was a big update, the 3.0 release was even bigger! It
    is difficult to do justice to it in a single chapter (let alone part of a chapter).
    So we are going to focus on the main features, especially as it relates to the
    evolution of C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'First though, we should talk about the difference between C#, the CLR, and
    the .NET Framework. Up until now, they all mostly had the same version (that is
    C# 2.0, CLR 2.0, and .NET Framework 2.0), however, they released an update to
    the .NET Framework (3.0) that had no language or CLR changes. Then with .NET 3.5,
    they released C# 3.0\. The following diagram explains these differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '![C# 3.0](img/6761EN_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Confusing, I know. Although both the C# language and the .NET Framework received
    an upgrade, the CLR remained unchanged. It is hard to believe, especially in light
    of all the new features, but it goes to show how forward thinking the developers
    of the CLR have been, and how well-engineered and extensible the C# language/compiler
    is that they were able to add new features without new runtime support.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As usual, we will begin reviewing the syntactic changes of the language for
    this release. First are properties, which as you will remember are already an
    improvement over the old school getter and setter methods. In C# 3.0, the compiler
    can automatically generate the backing field for simple getters and setters as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This feature alone cuts out many lines of code from classes that have many
    properties. Another nice feature introduced is that of **object initializers**
    . Take the following simple class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to create an instance and initialize it, you would normally have
    to write code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'But with an object initializer, you can do this at the same time as object
    instantiation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will actually generate pretty much the same code as before, so
    there is no semantic difference. But you can write your code in a much more concise
    and easy-to-read manner. Collections get a similar treatment as you can now initialize
    arrays with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And dictionaries, which were notoriously verbose to initialize, can now be
    created very easily as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these improvements makes the very act of typing code easier and quicker.
    But it seems that the C# language designers were not content to stop there. Every
    time you instantiated a new variable, you were forced to write out the entire
    type name, when you start getting to complex generic types this can add a lot
    of extra characters to your program. Fear not! You do not even need to do that
    in C# 3.0! Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as it is clear what type is being assigned on the right side of the
    equation, the compiler can take care of figuring out the type on the left side.
    Astute readers will no doubt recognize the `var` keyword from JavaScript. Though
    it looks similar, it is not the same at all. C# is still statically typed, which
    means that every variable must be known at compile time. The following code will
    not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in effect, this is just a shortcut to help you type fewer characters, the
    compiler is just really good at inferring these things. In fact, that is not the
    only thing it can infer. If there is enough context, it can also infer generic
    type parameters. For example, consider the following simple generic method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When you call it, rather than stating the type in the call, the compiler can
    look at the type of class that is being passed in, and simply assume that this
    is the type that should be used for the type parameter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, I imagine someone on the C# language team said: "While we''re
    making existing syntax optional, why not do away with the need for class definitions
    entirely!" And it would seem they did just that. If you need a data type to hold
    a few fields, you can declare it inline as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will automatically create a class that matches the type that you
    just created. There are a few limitations to this feature: you have to use the
    `var` keyword, and you cannot return an anonymous type from a method. Very useful
    when you are writing an algorithm and need a quick, yet complex data type.'
  prefs: []
  type: TYPE_NORMAL
- en: All of these little syntax changes add up and make the C# language a pleasure
    to write in. They also are a lead in for the next big feature we are going to
    talk about.
  prefs: []
  type: TYPE_NORMAL
- en: LINQ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Language Integrated Query**(**LINQ**) is the flagship feature of C# 3.0\.
    It acknowledges the fact that much of a modern day program revolves around querying
    for data in one way or another. LINQ is a set of diverse features that gives the
    language first class support for querying data from a multitude of sources. It
    does so by providing a strong abstraction around the concept of querying, and
    then adding language support.'
  prefs: []
  type: TYPE_NORMAL
- en: The C# language team started with the premise that SQL was already a great syntax
    for working with set-based data. But, unfortunately, it was not a part of the
    language; it required a different runtime, such as SQL Server, and only worked
    in that context. LINQ requires no such context switch, so you can simply get a
    reference to your data source, and query away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conceptually, there are the following, high level kind of operations that you
    can do with a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filtering**: This is performed where you exclude items from a set based on
    some criteria'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aggregation**: This involves common aggregation actions such as grouping,
    and summation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Projection**: This is extracting or converting items from a set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is what a simple LINQ query looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: It looks like SQL, kind of. There have been many questions over the years over
    why the syntax does not start with the select statement like it does in SQL, but
    the reason comes down to tooling. When you start typing, they want you to be able
    to get IntelliSense when typing every part of the query. By starting with the
    'from', you are essentially telling the compiler what type will be used in the
    rest of the query, which means it can give you type-time support.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the interesting things about LINQ is that it works for any `IEnumerable`.
    Think about that for a second, every single collection in your program is now
    easily searchable. And that is not all, you can aggregate and shape the output
    as well. For example, say you wanted to get a count of cities in each state as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This query uses the group by clause to group the values by a common key, in
    this case by state. The final output is also a new anonymous type that has two
    properties, the name, and the collection of cities in that state. Running this
    program will output this for Florida as **FL has 2 cities in this collection**.
  prefs: []
  type: TYPE_NORMAL
- en: So far in these examples, we have been using what is called **query syntax**
    . This is nice because it is very familiar to those who know SQL. However, just
    as with SQL, more complex queries can sometimes get rather verbose and complicated
    to read. There is another way to write LINQ queries that, for some, can be much
    easier to read, and perhaps even slightly more flexible called the **LINQ method
    syntax**, it is built upon another new feature of the language.
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Normally, the only way of extending functionality of a type is to inherit from
    the class and add the features to the subtype. All users have to use the new type
    to get the benefits of that new type. However, this may not always be an option,
    for example, if you are using a third-party library with value types (as you cannot
    inherit from a value type). Let us say we have the following `struct` in a third-party
    library, where we do not have access to modify the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'With extension methods, you have the capability to add new methods to this
    type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Extension methods must be placed in a public static class. The method itself
    will be static, and will use the `this` keyword on the first parameter to signify
    the type to attach to. Using the previous method looks like the method has always
    been a part of the type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You can add the extension methods to any type, whether value type, or reference
    type. Also interfaces and sealed classes can be extended. If you look at all of
    the changes in C# 3.0, you will notice that you are now writing less code because
    the compiler is generating more and more of it behind the scenes for you. The
    result is code that looks similar to some of the other dynamic languages such
    as JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: C# 4.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the fourth iteration of the language, Microsoft tried to simplify the versioning
    confusion it created over the previous few releases by incrementing the version
    of every component to 4.0.
  prefs: []
  type: TYPE_NORMAL
- en: '![C# 4.0](img/6761EN_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: C# 4.0 brings more dynamic functionality into the language and continues the
    work of making C# a very powerful, yet agile language. Some of the features added
    are primarily to make interoperation with native platform code easier. Things
    such as covariance, contra variance, and optional parameters, simplify the process
    of doing things, calling the interop assemblies for interacting with Microsoft
    Word, for example. All in all, not very earth-shaking stuff, at least for your
    average day-to-day developer.
  prefs: []
  type: TYPE_NORMAL
- en: However, with a new keyword that was added, `dynamic`, C# takes a step closer
    to becoming a very dynamic language; or at the very minimum, inheriting many of
    the qualities of dynamic languages. Remember when generics were introduced, if
    you had a bare type parameter (that is, with no type constraints), it was treated
    as an object. The compiler had no additional information about what kind of methods
    and properties the type had access to at runtime, and as such you could only interact
    with it as an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C# 4.0, you now have a way of writing code that can bind to the correct
    properties and methods at runtime. The following is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are migrating a project from an earlier version of the framework, make
    sure you add a reference to `Microsoft.CSharp.dll,` when using dynamic programming.
    You will receive a compilation error if this is not present.
  prefs: []
  type: TYPE_NORMAL
- en: In this hypothetical scenario, you have a method that returns a `string`. The
    variable that is receiving the return value of the `GetAString()` method is marked
    with the `dynamic` keyword. This means that every property and method that you
    call on that object will be dynamically evaluated at runtime. This lets C# easily
    interop with dynamic languages, such as IronPython and IronRuby, in addition to
    your own custom dynamic types.
  prefs: []
  type: TYPE_NORMAL
- en: Does this mean that C# is no longer statically typed? No, quite the opposite;
    C# is still statically typed, just that in this case you have told the compiler
    to handle this code differently. It does this by rewriting your dynamic code to
    use the **Dynamic Language Runtime** (**DLR**), which actually compiles out expression
    trees of your code that are evaluated at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily create your own dynamic objects by inheriting from the built-in
    class called `DynamicObject` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In this simple example, we inherit from `DynamicObject` and override a few
    methods to get and set the member value. These values are stored internally in
    a dictionary so that you can pull out the correct value when the DLR asks for
    it. Using this class is very reminiscent of how flexible objects are in JavaScript.
    Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If you need to store a new value, simply set the property. And if you want to
    define a new method, you can use a delegate as the value for the member. Of course,
    you must realize that this will not be as fast as having a regular statically
    typed class, every value must be looked up at runtime, and because values are
    stored as objects internally, any value type will be boxed. But sometimes those
    drawbacks are completely acceptable, especially when it can simplify your code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For me, it has been an amazing journey, watching C# evolve from the very first
    version until today. Each subsequent release was more powerful than the previous,
    and there was a very solid theme of code simplification throughout. The compiler
    itself has gotten better and better at generating code on your behalf, so that
    you can implement very powerful features in your programs without having the cognitive
    burden of verbosely implementing the infrastructure (generics, iterators, LINQ,
    and the DLR)
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we looked at some of the major features that were introduced
    in each version of C#
  prefs: []
  type: TYPE_NORMAL
- en: '**C# 1.0**: Memory Management, Base Class Library, and syntax features such
    as properties and events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C# 2.0**: Generics, iterator methods, partial classes, anonymous methods,
    and syntactic updates such as visibility modifiers on properties and nullable
    types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C# 3.0**: **Language Integrated Query** (**LINQ**), extension methods, automatic
    properties, object initializers, type inference (`var`), and anonymous types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C# 4.0**: The **Dynamic Language Runtime** (**DLR**), and co- and contra
    variance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we move to the latest release, C# 5.0.Iliquamet quae volor aut ium ea dolore
    doleseq uibusam, quiasped utem atet etur sus.
  prefs: []
  type: TYPE_NORMAL
