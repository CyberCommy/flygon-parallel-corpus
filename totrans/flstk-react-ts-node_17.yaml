- en: '*Chapter 14*: Setting Up Postgres and a Repository Layer with TypeORM'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll learn about setting up a repository layer using Postgres
    as our database and TypeORM as our library for accessing the database. We'll build
    our database schema and, with the help of TypeORM, we'll be able to perform **CRUD**
    (**Create, Read, Update, Delete**) operations for our application. This is a crucial
    chapter as the core activity of our backend will be to retrieve and update data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our Postgres database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding object relational mappers by using TypeORM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building our repository layer using Postgres and TypeORM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book will not be teaching you about relational databases. So, you should
    have a basic understanding of SQL, including simple querying and table structures,
    as well as web development using Node. We will once again be using Node and Visual
    Studio Code to write our code.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository is available at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in the `Chap14` folder.
  prefs: []
  type: TYPE_NORMAL
- en: To set up the [*Chapter 14*](B15508_14_Final_JC_ePub.xhtml#_idTextAnchor216)
    code folder, go to your `HandsOnTypescript` folder and create a new folder called
    `Chap14`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our Postgres database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will install and set up a Postgres database. Relational
    databases are still very relevant, and these days NoSQL databases are all the
    rage. However, according to StackOverflow, Postgres continues to be one of the
    world's most popular databases. Additionally, its performance is world class,
    beating MongoDB by a significant margin ([https://www.enterprisedb.com/news/new-benchmarks-show-postgres-dominating-mongodb-varied-workloads](https://www.enterprisedb.com/news/new-benchmarks-show-postgres-dominating-mongodb-varied-workloads)).
    So, Postgres is what we will be using as our database technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install our Postgres database. We will use the installer provided by
    EDB. EDB is a third-party company that provides tools and services for supporting
    Postgres:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the URL [https://www.enterprisedb.com/downloads/postgres-postgresql-downloads](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads)
    and select the download for your platform. I will be using version 12.4 for Mac,
    which is the latest Mac version as of the time of writing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept all the defaults on the installer, including the list of components to
    be installed, as shown here:![Figure 14.1 – Postgres Setup screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.01_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.1 – Postgres Setup screen
  prefs: []
  type: TYPE_NORMAL
- en: Once your install finishes, start up the `pgAdmin` application. This application
    is the administrator application for Postgres. You should see a screen like this:![Figure
    14.2 – First view of pgAdmin
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.02_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.2 – First view of pgAdmin
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it is a web browser application. I have some other servers on
    my installation, but your install should not have any if this is your first `pgAdmin`
    install.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's create a new server group called `HandsOnFullStackGroup` so we can
    keep our work separate from others. A server group is just a container to house
    multiple server instances, and each server can have multiple databases inside
    them. Note that a server **does not** indicate a single physical machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, select the option for **Server Group** by right-clicking over the **Servers**
    item, as shown here:![Figure 14.3 – pgAdmin adding a server group
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.03_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.3 – pgAdmin adding a server group
  prefs: []
  type: TYPE_NORMAL
- en: Next, create a server by right-clicking on the new `SuperForumServers` on the
    first screen, as follows:![Figure 14.4 – The Create - Server tab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.04_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.4 – The Create - Server tab
  prefs: []
  type: TYPE_NORMAL
- en: Now, select the second tab, `localhost` as the `postgres`. The Postgres account
    is the root administrator account, so you need to remember this password. Here's
    a screenshot of this tab:![Figure 14.5 – The Connection tab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.05_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.5 – The Connection tab
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Save** and your server will be created. You should see the following
    view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.6 – View of the new HandsOnFullStackGroup and SuperForumServers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.06_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.6 – View of the new HandsOnFullStackGroup and SuperForumServers
  prefs: []
  type: TYPE_NORMAL
- en: Notice that there is already a database called **postgres** there. This database
    is empty, but can be used to store global data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the database for our application. However, before we can
    do that, we need to create a new account specifically to use in relation to our
    new database. Using the default administrator account, postgres, would not be
    a good idea as, if it were to be hacked, it would give the attacker access to
    our entire server:'
  prefs: []
  type: TYPE_NORMAL
- en: In `pgAdmin`, right-click on `superforumsvc`. Then, in the **Definition** tab,
    set your own password. Next, go to the **Privileges** tab and **make sure** to
    enable login. The rest you can keep as the default settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, right-click on the `SuperForum` and select **superforumsvc** as **Owner**:![Figure
    14.7 – Creating the SuperForum database
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.07_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.7 – Creating the SuperForum database
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, click **Save**. Your view should now show this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.8 – New database and user'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.08_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.8 – New database and user
  prefs: []
  type: TYPE_NORMAL
- en: Terrific! We now have a database. If we were not using an ORM, we would have
    to go through the tedious process of manually creating our tables and fields.
    But, as you'll see, TypeORM saves us from this grunt work, as well as providing
    us with great language features to query our database.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll dig into TypeORM. We'll learn about how it works
    and how it helps us, at many levels, to interact with our database.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding object relational mappers by using TypeORM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll learn what **Object Relational Mapper** (**ORM**) technology
    is. We'll also learn about TypeORM, one of the most popular ORM frameworks for
    JavaScript. ORM can make working with databases a lot easier and reduce some cognitive
    load for the developer.
  prefs: []
  type: TYPE_NORMAL
- en: As a programmer, you know that different programming languages have types that
    are incompatible. For example, JavaScript, despite the name, cannot use or even
    access Java types directly. In order for either language to use the types from
    the other, we would need to do some sort of translation. In part, this is the
    reason for having services such as the Web API. The Web API provides all data
    to callers as a string format, like JSON. This allows any caller to use the data
    since it can be read by any language.
  prefs: []
  type: TYPE_NORMAL
- en: Database to coding language conversion has similar type incompatibilities. So,
    normally after making a query that returns data, we would have to take each field's
    value from the database and manually write code to convert it to a specific type
    in the coding language. However, if we use an ORM, most of this work goes away.
  prefs: []
  type: TYPE_NORMAL
- en: An ORM is designed so that it *knows* how to map database fields into code fields
    and handles that translation work for us. Additionally, most ORMs have some sort
    of capability to autocreate tables and fields on the database based on entity
    structures created in code. You can think of entities as types on the coding language
    side that represent similar objects to tables on the database side. For example,
    if we have an entity called `User` in our JavaScript, it would be expected that
    we would have a table called `Users` on the database to match it (it's plural
    because a table holds more than one user).
  prefs: []
  type: TYPE_NORMAL
- en: This feature alone can save an enormous amount of time and effort for developers,
    but on top of this, a good ORM will also have features to help build queries,
    insert parameters safely (reducing the chance of SQL injection attacks), and also
    handle transactions. Transactions are atomic database operations that must complete
    in their entirety or all the actions involved are undone.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A SQL injection attack is an attempt by a malicious person to insert SQL code
    that is different from the one originally intended by the developers. It can result
    in issues such as data loss and application failure.
  prefs: []
  type: TYPE_NORMAL
- en: For our application, we will be using TypeORM. TypeORM is a popular and highly
    rated ORM for TypeScript, with over 20,000 likes on GitHub. It provides all of
    the features mentioned and is easy to get started with, although becoming an advanced
    user does take considerable effort. It supports multiple databases, including
    Microsoft SQL, MySQL, and Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: It will save us a great deal of time with its rich feature set, and because
    many JavaScript projects use TypeORM, there is a large community of developers
    that can help if you run into issues when using it.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about ORM technology. We learned what it is and
    why it's important and valuable to use. In the next section, we will be using
    TypeORM to build our own project. Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Building our repository layer using Postgres and TypeORM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll learn about the importance of using a repository layer.
    Having a separate layer for a large and important part of our application can
    help make code refactoring easier. It is also helpful in terms of understanding
    how the app works since major sections are logically separated out.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B15508_01_Final_JC_ePub.xhtml#_idTextAnchor017), *Understanding
    TypeScript*, we learned about **Object-Oriented Programming** (**OOP**). One of
    the major mechanisms for implementing OOP design is the use of abstraction. By
    creating our database access code in its own separate layer, we are using abstraction.
    As you may recall, one of the benefits of abstraction is that it hides the implementation
    of the code internally and exposes an interface to outside callers. Additionally,
    because all code related to accessing the database is in one place, we don't have
    to hunt around to find our database query code. We know which layer of our application
    this code lives in. Keeping code logically separate is known as the separation
    of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s get started with building our repository layer:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to copy our server code that we created in [*Chapter 13*](B15508_13_Final_JC_ePub.xhtml#_idTextAnchor208),
    *Setting Up Session State Using Express and Redis*. Go to the `Chapter13` folder
    in the source code and copy the `super-forum-server` folder into the `Chapter14`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to install TypeORM and its related dependencies. Run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, before we can start creating our Entities database, we need to create
    a configuration file so that our TypeORM code can access our Postgres database.
    This means that we also have to update our `.env` file with our database configurations.
    Open the `.env` file and add these variables. Our server was installed locally,
    so `PG_HOST` has the value `localhost`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The port the server uses for communication is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Our database account name is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the password you created for your own database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our database name is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned before, TypeORM will create our tables and fields for us and maintain
    them as they change. `PG_SYNCHRONIZE` enables that feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Of course, once you go live in production, you must disable this feature so
    as to prevent unwanted database changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The location of our Entity files, including subdirectories, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The root directory for our entities is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`PG_LOGGING` determines whether to enable logging on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Logs should be enabled in production in order to trace issues. However, logs
    can create huge files, so we won't enable it for our development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can create our TypeORM configuration file. In the root of our project,
    `Chap13/super-forum-server`, create the file `ormconfig.js` and add this code
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we get our `.env` configurations by requiring them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Which database type will we connect to? Since TypeORM supports multiple databases,
    we need to indicate this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the values use the configurations from our `.env` file, so they
    are self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, we're ready to start creating our entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve installed our dependencies and set up the configuration to
    the database, let''s create our first entity, the User. Change the directory to
    the `Chap14/super-forum-server` folder and then create, inside the `src` folder,
    a folder called `repo`. We''ll place all of our repository code there. Then, create
    a file inside `repo` called `User.ts` with the following code in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'These TypeORM imports will allow us to create our `User` entity class. `Entity`,
    `PrimaryGeneratedColumn`, and `Column` are what are known as decorators. Decorators
    are attributes placed just before a relevant line of code that provide additional
    configuration information about a field or object. You can think of them as a
    shortcut. Instead of writing some long lines of code, you can simply add a tag
    that sets configurations. We''ll see examples in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is a validator for length.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes our first use of decorators. The `Entity` decorator tells TypeORM
    that the class that is about to be defined is an entity with the name `Users`.
    In other words, in our code we will have objects called `User` that map directly
    to tables in our database called `Users`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In databases, every table must have a unique identifying field. This is what
    `PrimaryGeneratedColumn` indicates. The field name will be `id`. Notice that the
    """ in `id` is not capitalized. We''ll fix this issue later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have our first use of the `Column` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it is used to define the database field `Email`, which will
    be called `email` in our TypeScript code. So again, decorators are being used
    to map our code objects to database entities. Now, let''s go through the `Column`
    decorator more closely. First, it defines that our column is of the `varchar`
    database type. Again, database types are different from code types, as shown here.
    Next, we see the `name` field, which is set to `Email`. This will be the exact
    name of this field in the `Users` table. Then we have `length`, which indicates
    the maximum allowed character count of this field. The `unique` attribute tells
    Postgres to enforce the fact that each `User` entry must have a unique email.
    And finally, we have `nullable` set to `false`, which means this field must have
    a value in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we used the `Length` decorator to make sure that the field entered has
    a minimum and maximum character length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The two fields, `userName` and `password`, have `varchar` as columns, with
    similar settings to `email`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, here we see a `confirmed` field that is of the `boolean` type. The `confirmed`
    field will show whether the newly registered user account has been email verified
    yet. Note, it''s pretty self-explanatory, but the default setting indicates that
    at the moment the record is inserted into the database, unless explicitly set,
    it will be set to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: And finally, here's the `isDisabled` field, which will allow us to disable an
    account for management purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! Now we can see whether TypeORM will create our new `Users` table on
    our behalf. The last thing we need to do is connect to the Postgres database from
    our code. Update `index.ts` like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We have imported the `createConnection` function from TypeORM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've called `createConnection`. But notice that our code is now wrapped
    in a function called `main` that is `async`. The reason we needed this is that
    `createConnection` is an `async` call and requires an `await` prefix. So, we had
    to wrap it in an `async` function, which is what the `main` function does.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining code is the same, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the code is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: And finally, we've called our `main` function to execute it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s run our application by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: However, we have a small issue. Our `id` column is not using capitalization
    even though our other columns are. Let's fix that. Open the `User.ts` file again
    and simply change the name setting of the `PrimaryGeneratedColumn` decorator to
    be `Id` instead of `id` (only in the decorator; leave the `id` field name in our
    JavaScript). If your server is not running, start it again. But after it restarts,
    refresh the `id` column has been updated to `Id`. This is a terrific feature of
    TypeORM, as manually changing column names or constraints can sometimes be painful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Great! Now we just need to create our other entities: `Thread` and `ThreadItem`.
    Again, `Thread` is the initial starting post in our forum and `ThreadItems` are
    the responses. First, stop your server so that it doesn''t create our database
    items before we''re ready. Now, since this is mostly repetitive, I''ll just show
    the code here without comment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The imports for both these files will be identical and as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Thread` entity looks like this for now (we''ll be adding more fields once
    we build our table relationships):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`ThreadItem` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, both entities are pretty straightforward. Now, restart your
    server and you should see the two new tables: **Threads** and **ThreadItems**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.10 – Threads and ThreadItems'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.10_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.10 – Threads and ThreadItems
  prefs: []
  type: TYPE_NORMAL
- en: 'We still have many fields to add, such as the points column. But first, let''s
    build out some relationships between tables. For example, every table should have
    an association with a specific user. Let''s begin by adding these relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, stop your server. Then, in your `User.ts` file, add this to the bottom
    of your class. I''ll assume you know how to add any required imports by now and
    won''t mention them further:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `OneToMany` decorator shows that for each individual `User`, there are potentially
    multiple `Threads` associated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add this to the bottom of your `Thread.ts` file''s `Thread` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `ManyToOne` decorator shows that every `Thread`, of multiple threads, has
    only one `User` associated with it. Although teaching SQL is beyond the scope
    of this book, put simply, these relationships act as constraints on the database,
    meaning we are prevented from inserting data that does not make sense; for example,
    having multiple `Users` *owning* a single `Thread`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s establish the relationship of our `Thread` to `ThreadItems`. Add
    this code to the `Thread` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this shows that one `Thread` can have multiple `ThreadItems` associated
    with it. Now, let''s update our `ThreadItem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'A `ThreadItem`, like a `Thread`, can only have one `User` associated with it
    as the owner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Each `ThreadItem` can only have one parent `Thread`. Now, if you restart the
    server, you should see these new relationships:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.11 – Relationships'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.11_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.11 – Relationships
  prefs: []
  type: TYPE_NORMAL
- en: You will see in the `Threads` and `ThreadItems` tables that new columns have
    been added. For example, in `ThreadItems`, `userId` and `threadId` were added
    to indicate their respective relationships. However, in the `Users` table, nothing
    was added. This is because the `Users` table has a `OneToMany` relationship with
    the `Threads` table. Therefore, this relationship is indicated by the constraint
    shown in the image for the `CREATE TABLE public."Threads"` script. As you can
    see, there is a constraint for the `userId` column. So, by indicating that each
    thread has a single `User` associated with it, it implicitly indicates that each
    `User` can have one or more `Threads` that it owns.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's set up our points system. In the case of points, that is, likes or
    dislikes, we need to allow users to be able to vote either up or down only once.
    However, there's no way to indicate that in terms of a single table. So, we'll
    create two new tables, `ThreadPoints` and `ThreadItemPoints`, which will have
    associations with relevant `Users`, `Threads`, and `ThreadItems`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, shut down your server and then create the `ThreadPoint.ts` file. Then,
    add this code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what we''re doing here in this code is saying that this point is for a
    specific `User` and `Thread`. We are also indicating that if the `isDecrement`
    field is `true`, then this constitutes a dislike. This means that points have
    three possible states: no points at all, a like, or a dislike. We''ll write some
    code in our repository queries later to handle these three states.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add this code to the `User.ts` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Again, this code completes the associations in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following to the `Thread.ts` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This also completes the association with `ThreadPoint`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to do the same thing for `ThreadItemPoints`. Create `ThreadItemPoint.ts`
    and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This is a pretty similar setup to `ThreadPoint`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we update our `User` class by adding the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And we update our `ThreadItem` class by adding this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: And this completes the associations needed in relation to `ThreadItemPoint`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re not done yet though. You may recall from [*Chapter 11*](B15508_11_Final_JC_ePub.xhtml#_idTextAnchor167),
    *What We Will Learn – Online Forum Application*, that our threads will have categories,
    so we need to create that entity and its relationship as well:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create the `ThreadCategory.ts` file and add this code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`ThreadCategory` has a pretty similar setup to the other entities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add this to the `Thread.ts` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This, of course, creates the relationship between `Thread` and `ThreadCategory`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, run the server and it should create the tables and associations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we've created the entities that we need and also their associations. But
    whenever we add data to a database, we want to log when it was created or changed.
    However, implementing this will create identical fields across all entities, and
    we don't want to write the same code over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, since TypeScript allows us to use inheritance in classes, let''s create
    a base type that has these fields that we need and then have each entity simply
    inherit from this base class. Additionally, TypeORM requires that our entities
    inherit from its own base class in order to be able to connect to its API. So,
    then let''s add the TypeORM base class in our own base class as well:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `Auditable.ts` and add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`Getpgusername` is the service account `superforumsvc` and that''s what this
    field will default to, unless explicitly set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This field will default to the current time and date, `now()`, unless explicitly
    set.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the fields are pretty self-explanatory as to what they do.
    However, notice that our base class, `Auditable`, also extends the TypeORM base
    class called `BaseEntity`. This `BaseEntity` inheritance is what allows our entities
    to access the Postgres database through TypeORM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, so that''s the new `Auditable` base class covered. Now we want to make
    our entities inherit it. This is simple. For example, in the `User` class, just
    add the `extends` keyword and add the `Auditable` class like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeat this process for every entity and then restart your server (remember
    to add your import statements as needed). Once you refresh your view, you should
    see the new fields like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.12 – User updated for Auditable'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.12_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.12 – User updated for Auditable
  prefs: []
  type: TYPE_NORMAL
- en: 'Awesome! Now we can create our repository library that will actually call into
    our database. Since we created our Session State in the last chapter, [*Chapter
    13*](B15508_13_Final_JC_ePub.xhtml#_idTextAnchor208), *Setting Up Session State
    Using Express and Redis*, let''s create our authentication-related calls first:'
  prefs: []
  type: TYPE_NORMAL
- en: Before we create our main code, we need to do something first. You may recall
    from [*Chapter 11*](B15508_11_Final_JC_ePub.xhtml#_idTextAnchor167), *What We
    Will Learn – Online Forum Application*, we used a function called `isPasswordValid`
    to check that the user's password was sufficiently long and complex. We will need
    to reuse that code on our server because, as I mentioned then, validation in general
    should be done on both the client and server. So, let's temporarily copy the `PasswordValidator.ts`
    file and the `common/validators` folder structure into our server project, and
    later I'll show a method for sharing code across multiple projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s also create a validator for email addresses. Create an `EmailValidator.ts`
    file in the same `common/validators` directory and add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Here, I've checked for an empty address.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: And here, I've checked for the @ symbol.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: And finally, here I've checked for white space.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If no issue is found, an empty string is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `UserRepo.ts` file and add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: First, we have our imports, including our validators.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`saltRounds` is for password encryption, as you''ll soon see.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We will use the `UserResult` type to indicate whether an error occurred during
    authentication. As you can see, it is basically a wrapper around the `User` object.
    We're using this object as the return type of our functions. We're doing this
    because when making network calls or other complex calls, it's not unusual for
    something to go wrong. Therefore, having the ability to include error or status
    messages with our objects is beneficial. Note how both members, `messages` and
    `user`, are optional. This will come in handy once we start using this type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This is the start of our `register` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've run our two validators, `isPasswordValid` and `isEmailValid`. Notice
    how we've used an object literal as our return object and not included the `user`
    member. Again, TypeScript only cares about the shape of our objects matching the
    shape of the type. So, in this case, since our `UserResult` member, `user`, is
    optional, we can create a `UserResult` object that does not include it. TypeScript
    is really flexible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've encrypted our password using the `saltRounds` constant and `bcryptjs`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: And then, if we pass our validations, we `create` our `User` entity and then
    immediately `save` it. These two methods are both from TypeORM, and note that
    when making changes to the Entities database, you `save` function or else it will
    not complete on the server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Then, we return the new entity and again, since our call has no errors, we only
    return the `user` object without any `messages`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this new function, `register`, with a real network call. Update
    the `index.ts` file like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we now import `bodyParser`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have set up our `bodyParser`, so we can read `json` parameters from
    posts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'All this code remains the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we removed the previous `get` route and replaced it with `post`
    on the register URL. This call now runs our `UserRepo` `register` function and,
    if it is successful, it sends a message back with the new user''s ID. If it''s
    not successful, it sends back the error message from the repo call. In this case,
    we just use the first message, as we''ll be removing these routes and replacing
    them with GraphQL in [*Chapter 15*](B15508_15_Final_JC_ePub.xhtml#_idTextAnchor222),
    *Adding GraphQL Schema – Part I*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll start testing. However, we need to switch to using Postman instead
    of curl. Postman is a free application that will allow us to make `GET` and `POST`
    calls to our server while accepting session cookies. It''s very easy to use:'
  prefs: []
  type: TYPE_NORMAL
- en: First, go to [https://www.postman.com/downloads](https://www.postman.com/downloads)
    and download and install Postman for your system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Following installation, the first thing you should do is run a `GET` call on
    the root of the site using Postman. I''ve created a simple route for the root,
    in `index.ts`, that will initialize the session and its cookie. Run the `GET`
    call on our site like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.13 – Running Postman on the root of the site'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.13_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.13 – Running Postman on the root of the site
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you can run this same `GET` call:'
  prefs: []
  type: TYPE_NORMAL
- en: Below the top tab labelled **GET**, you should see a dropdown to the left. Select
    **GET** and add the local URL. There are no parameters, so just click **Send**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, toward the bottom-left, you will see another dropdown. Select **Cookies**
    and you should see our cookie called **superforum**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now you have the cookie required to maintain the Session State. So, we can
    now continue our testing, starting with the `register` function:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new tab, select `http://localhost:5000/register`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Headers** tab and insert **Content-Type**, as shown here:![Figure
    14.14 – Content-Type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.14_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.14 – Content-Type
  prefs: []
  type: TYPE_NORMAL
- en: Now, select the `email`, although it's invalid, the `userName`, and a `password`,
    which is also invalid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: But still, this failure is good, as we have confirmed our validation is working.
  prefs: []
  type: TYPE_NORMAL
- en: Let's fix the password and try again. Update the password to `Test123!@#` and
    run it again like this:![Figure 14.16 – Trying to register again
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.16_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.16 – Trying to register again
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see the message **Please enter valid email address**. Again,
    this is what we want, as clearly the email given is not valid.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try one more time. Update the email to `test@test.com` and run this:![Figure
    14.17 – Successful registration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.17_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.17 – Successful registration
  prefs: []
  type: TYPE_NORMAL
- en: The output message, `10` as I was doing some testing in preparing this book.
    ID fields will normally start at `1`. If you don't see this result again, make
    sure you ran Postman on the root of our website while using a `GET` call.
  prefs: []
  type: TYPE_NORMAL
- en: Sweet! That worked! Now, let's look at our `Users` table to check that the user
    was indeed added:![Figure 14.18 – A new user added to the Users table
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.18_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.18 – A new user added to the Users table
  prefs: []
  type: TYPE_NORMAL
- en: You can run the query shown by right-clicking on the `Users` table in `pgAdmin`
    and selecting `Scripts > SELECT Script`. You can run the script by clicking on
    the play button at the top. But, as you can see, our user was inserted into the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s update `UserRepo` with our `login` function. Add the following
    code to the end of `UserRepo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Not much to show here. We try and find a user with the given `userName`. If
    not found, a message is sent back that the `user` is not found, using a function
    called `userNotFound`. I'm using a function because we will reuse this message
    later. It's a simple function, so I won't cover it here (it's in the source code).
    If the user is found, then we first see whether the account was confirmed. If
    not, we provide an error regarding it. Next, we check their password by using
    `bcryptjs`, since we used that tool to encrypt it during registration. If it does
    not match, we also provide an error regarding that. If all goes well and the `user`
    exists, we return the `user`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try running this as well. Update `index.ts` by adding this new route
    just below the register route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This is quite similar to our `register` route. However, here we save the user's
    `id` to the Session State and then send back a message using that session.
  prefs: []
  type: TYPE_NORMAL
- en: Let's run this route and see what happens. Again, open a new tab in Postman
    and run the settings as shown here. **Remember** to add the **Content-Type** header
    in the **Headers** tab:![Figure 14.19 – Login route
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.19_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.19 – Login route
  prefs: []
  type: TYPE_NORMAL
- en: Again, this is good to see as our validations are working.
  prefs: []
  type: TYPE_NORMAL
- en: Go to your `pgAdmin` and open the same screen you used to run the `SELECT` query
    to see our first inserted user. Then, run this SQL to update our user's `confirmed`
    column to be `true`:![Figure 14.20 – Update user's confirmed field
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.20_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.20 – Update user's confirmed field
  prefs: []
  type: TYPE_NORMAL
- en: Once you run your query, you should see the same message, as shown in *Figure
    14.20*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s run Postman to try and log in again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.21 – Logging in the user'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.21_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.21 – Logging in the user
  prefs: []
  type: TYPE_NORMAL
- en: Now, our users can log in and, based on the returned message, we can now see
    that our Session State is being used. I've created the `logout` function and route
    in the source code. I won't show it here since it's simple.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you're attempt to save to the session fails, make sure that your Redis service
    is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Awesome! We''ve come a long way. We now have working session-based authentication,
    but we''re not done yet. We need to create ways of inserting `Threads` and `ThreadItems`,
    as well as retrieving them. Let''s start with `Threads`:'
  prefs: []
  type: TYPE_NORMAL
- en: Before we create our new `ThreadRepo` repository, let's build a small helper.
    In `UserRepo`, we had a type called `UserResult` that had an array of messages
    and a user as members. You'll notice that any repo of `Threads`, `ThreadItems`,
    and `Categories` will need a similar construction. It should have an array of
    messages and entities, although the entity returned will be an array of items
    and not just one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This seems like a good place to use TypeScript Generics, so that we can share
    a single result type across all these entities. Let's create a new general-purpose
    result object type called `QueryResult`. We learned about TypeScript Generics
    in [*Chapter 2*](B15508_02_Final_JC_ePub.xhtml#_idTextAnchor025), *Exploring TypeScript*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `QueryArrayResult.ts` and add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it's very similar to the original `UserResult`. However, this
    type uses a generic of type `T` to indicate any of our entities.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The `pg` dependency also has a type called `QueryArrayResult`. When importing
    our dependency, please make sure you import our file, and not `pg`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use this new `QueryArrayResult` type in our `ThreadRepo`. Create
    a new file, `ThreadRepo.ts`, inside the `repo` folder and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The parameters shown are needed because every `Thread` must be associated with
    a user and a category. Do note, however, that `userId` is coming from our session.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Here we validate our `title` and `message`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Here, we take our session provided `userId` and try and find a matching `user`.
    We need this `user` object later to create our new `Thread`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Here we get a `category` object, because again we need to pass it during the
    creation of our new `Thread`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we pass `title`, `body`, `user`, and `category` in order to
    create our new `Thread`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: We are only returning messages as we don't need to return the actual object.
    Also, returning an object that is not required is inefficient in terms of API
    payload size.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can continue, we need to add some `ThreadCategories` to our database
    so that we can actually use the `createThread` function. Go to the source code
    and find the `utils/InsertThreadCategories.txt` file. Copy and paste these `insert`
    statements into a query screen of `pgAdmin` and run it. This will create the listed
    `ThreadCategories`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to add our route for creating `Threads`. Add the following code
    to `index.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In this super simple call, we pass parameters to the `createThread` function.
    Again, our `userId` comes from our session, since a user should be logged in in
    order to be allowed to post, and then we simply return the result message.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Let's try running this route. First, however, run the logout route in Postman.
    You'll find it on the `http://localhost:5000/logout` URL. I'm sure you can set
    up Postman yourself now. Once that is done, let's try and run the `createthread`
    route and hopefully, it should fail validation:![Figure 14.22 – Test createthread
    route
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.22_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.22 – Test createthread route
  prefs: []
  type: TYPE_NORMAL
- en: Yes, it failed validation as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's log in again so that our session gets created. Go ahead and do that
    with Postman again, and then run the `createthread` route again. This time, it
    should work with the message, **Thread created successfully**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'OK. Now we need two more functions, one to get a single `Thread` by its ID,
    and another to get all the threads for `ThreadCategory`. Add this code to `ThreadRepo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This `getThreadById` function is pretty simple. It just looks for a single thread
    based on an ID.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This `getThreadsByCategoryId` function is much more interesting. `Thread.createQueryBuilder`
    is a special function in TypeORM that allows us to build more sophisticated queries.
    The function's `thread` parameter is an alias used to represent the Threads table
    in our query. So, if you look at the rest of the query, such as the `where` clause,
    you can see that we use `thread` as a prefix for fields or relationships. The
    `leftJoinAndSelect` function means that we want to do a SQL left join, but also
    we want to return the related entity, in this case, `ThreadCategory`, with the
    result set. `OrderBy` is pretty self-explanatory, and `getMany` just means to
    return all items.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the code is pretty straightforward. Let''s test `getThreadsByCategoryId`
    as a route. Add this to the `index.ts` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have made our call to `getThreadsByCategoryId` using the `categoryId`
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: In this `if else` code, we either have all titles displayed or the error displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the code is as before. Run this in your Postman client and you
    should see this. Again, your ID numbers may vary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.23 – Test threadsbycategory route'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.23_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.23 – Test threadsbycategory route
  prefs: []
  type: TYPE_NORMAL
- en: I'll leave the testing of `getThreadById` up to you, as it's pretty easy. Again,
    the source code is in our project repository.
  prefs: []
  type: TYPE_NORMAL
- en: The code for `ThreadItems` is almost identical and is in our source code. So,
    I won't review it here. Now, we do need a few more functions for getting things
    such as `ThreadCategories` to populate our React app's `LeftMenu`. We also need
    to retrieve points for our `Threads` and `ThreadItems`. And we also need relevant
    `Thread` data for our `UserProfile` screen. However, those calls will repeat a
    lot of the concepts we learned in this section, and we'll have to create routes
    that we'll ultimately end up deleting once we start our GraphQL server code. Therefore,
    let's leave those for [*Chapter 15*](B15508_15_Final_JC_ePub.xhtml#_idTextAnchor222),
    *Adding GraphQL Schema – Part I*, where we can also start integrating the backend
    GraphQL code with our React frontend.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to build a repository layer and make queries
    into Postgres using TypeORM. We'll be reusing our query skills once we start integrating
    GraphQL in the next chapter, so this is important knowledge that we'll continue
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to set up a Postgres database and how to query
    it using an ORM, TypeORM. We also learned how to keep our code cleanly separated
    by using a repository layer.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn how to enable GraphQL on our server. We'll
    also finish our database queries and integrate our backend into our React frontend.
  prefs: []
  type: TYPE_NORMAL
