- en: Chapter 2. Entities and Mapping Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discovered the concepts behind Doctrine, we learned
    how to use Composer to install it, we set up the Doctrine Command Line Tools and
    we dived into the Entity Manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first entity class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping it to its related database table and columns with annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a command helper provided by Doctrine to automatically generate the database
    schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating some fixtures data and dealing with the Entity Manager to display our
    data in a web user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because we are building a blog, our main entity class will be called `Post`,
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Entities and Mapping Information](graphics/4104OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our `Post` entity class has the following four properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: The unique identifier of the post across the database table (and the
    blog)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: The post''s title'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body`: The post''s body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`publicationDate`: The date of publication of the post'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Entity class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As explained in [Chapter 1](ch01.html "Chapter 1. Getting Started with Doctrine
    2"), *Getting Started with Doctrine 2*, a Doctrine entity is just a PHP object
    that will be saved in the database. Doctrine annotations are added in the PHP
    `DocBlock` comments of the Entity class properties. Annotations are used by Doctrine
    to map the object to the related database's table and properties to columns.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The original purpose of **DocBlocks** is integrating technical documentation
    directly in the source code. The most popular documentation generator that parses
    DocBlocks is **phpDocumentator** which is available on this website: [http://www.phpdoc.org](http://www.phpdoc.org).'
  prefs: []
  type: TYPE_NORMAL
- en: Each entity, once persisted through Doctrine, will be related to a row of the
    database's table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file `Post.php` containing our entity class in the `src/Blog/Entity/`
    location with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Generating getters and setters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Doctrine command-line tools that we configured in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Doctrine 2"), *Getting Started with Doctrine 2*, include a useful
    command that generates getter and setter methods of an Entity class for us. We
    will use it to save us from having to write those of the `Post` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to generate getters and setters of all entity classes
    of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have several entities and don't want to generate getters and setters
    for all of them, use the `filter` option with the `orm:generate:entities` command.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping with Doctrine annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Post` is a simple class with four properties. The setter for `$id` isn''t
    actually generated. Doctrine populates the `$id` instance variable directly in
    the entity hydration phase. We will see later how we delegate the ID generation
    to the DBMS.'
  prefs: []
  type: TYPE_NORMAL
- en: Doctrine annotations are imported from the `\Doctrine\ORM\Mapping` namespace
    with `use` statements. They are used in DocBlocks to add mapping information to
    the class and its properties. DocBlocks are just a special kind of comment starting
    with `/**`.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing about the @Entity annotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `@Entity` annotation is used in the class-level DocBlock to specify that
    this class is an entity class.
  prefs: []
  type: TYPE_NORMAL
- en: The most important attribute of this annotation is `repositoryClass`. It allows
    specifying a custom entity repository class. We will learn about entity repositories,
    including how to make a custom one, in [Chapter 4](ch04.html "Chapter 4. Building
    Queries"), *Building Queries*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the @Table, @Index, and @UniqueConstraint annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `@Table` annotation is optional. It can be used to add some mapping information
    to the table related to the entity class.
  prefs: []
  type: TYPE_NORMAL
- en: The related database table name is default to the entity class name. Here, it
    is `Post`. It can be changed using the `name` attribute of the annotation. This
    is a good practice to let Doctrine automatically generate the table and column
    names but it can be useful to change them to match a preexisting schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we use the `@Table` annotation to create indexes on the underlying
    table. To do that, we use an attribute called `indexes` that contains a list of
    indexes. Each index is defined by an `@Index` annotation. Each `@Index` must contain
    the following two attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: The name of the index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`columns`: The list of indexed columns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the `Post` entity class, we create an index on the `publicationDate` column
    called `publication_date_idx`.
  prefs: []
  type: TYPE_NORMAL
- en: The last optional attribute of the `@Table` annotation is `uniqueConstraints`
    (not used here). It allows creating SQL level unique constraints on columns and
    groups of columns. Its syntax is similar to `@Index:name` to name the constraint
    and `columns` to specify the columns on which it applies the constraints.
  prefs: []
  type: TYPE_NORMAL
- en: This attribute is only used by the schema generator. Even if the `uniqueConstraints`
    attribute is used, Doctrine will not automatically check that a value is unique
    across a table. The underlying DBMS will do this, but it can lead to DBMS level
    SQL errors. If we want to enforce uniqueness of data, we should perform a check
    prior to saving new data.
  prefs: []
  type: TYPE_NORMAL
- en: Diving into the @Column annotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each property is mapped to a database column thanks to the `@Column` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the mapped database column defaults to the property name but can
    be changed with the `name` parameter. As for table names, it's better to let Doctrine
    generate names by itself.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As in the case of table names, column names will default to entity class property
    names (Camel case if the PSR style is correctly followed).
  prefs: []
  type: TYPE_NORMAL
- en: Doctrine also comes with an underscore naming strategy (for instance, the database
    table related to a class called `MyEntity` will be `my_entity`) and it is possible
    to write custom strategies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Learn more about this in the Doctrine documentation: [http://docs.doctrine-project.org/en/latest/reference/namingstrategy.html](http://docs.doctrine-project.org/en/latest/reference/namingstrategy.html)'
  prefs: []
  type: TYPE_NORMAL
- en: If a property is not marked with the `@Column` annotation, Doctrine will ignore
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Its `type` attribute indicates the Doctrine Mapping Type of the column (see
    next section). It is the only required attribute of this annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This annotation supports some more attributes. Like for every other annotation,
    the full list of supported attributes is available in the Doctrine documentation.
    The most important attributes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`unique`: If `true`, the value of this column must be unique across the related
    database table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nullable`: If `false`, the value can be `NULL`. By default, columns cannot
    be `NULL`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`length`: The length of the column for values of the `string` type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale`: The scale for columns for values of the `decimal` type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`precision`: The precision for columns for values of the `decimal` type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As for `@Table`, Doctrine does not use attributes of the `@Column` annotation
    to validate data. These attributes are only used for the mapping and to generate
    the database schema. Nothing more. For security and user experience reasons, you
    must validate every piece of data provided by users. This book does not cover
    this topic. If you do not want to handle data validation manually, try the Symfony
    Validator Component from [http://symfony.com/components/Validator](http://symfony.com/components/Validator).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It''s also possible to use lifecycle events (see [Chapter 5](ch05.html "Chapter 5. Going
    Further"), *Going Further*) to handle data validation: [http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/cookbook/validation-of-entities.html](http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/cookbook/validation-of-entities.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing about the @Id and @GeneratedValue annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `$id` property is a bit special. This is a column mapped to an integer,
    but this is mainly the unique identifier of our object.
  prefs: []
  type: TYPE_NORMAL
- en: Through the `@Id` annotation, this column will be used as the primary key of
    the table.
  prefs: []
  type: TYPE_NORMAL
- en: By default, it is the responsibility of the developer to ensure that the value
    of this property is unique across the table. Almost all DBMSs provide mechanisms
    to automatically increment an identifier at the insertion of a new row. The `@GeneratedValue`
    annotation takes advantage of this. When a property is marked with `@GeneratedValue`,
    Doctrine will delegate the generation of the identifier to the underlying DBMS.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other ID generation strategies are available at [http://docs.doctrine-project.org/en/latest/reference/basic-mapping.html#identifier-generation-strategies](http://docs.doctrine-project.org/en/latest/reference/basic-mapping.html#identifier-generation-strategies).
  prefs: []
  type: TYPE_NORMAL
- en: Doctrine also supports composite primary keys. Just add an `@Id` annotation
    to all columns of your composite primary key.
  prefs: []
  type: TYPE_NORMAL
- en: We will study another example using a unique string as identifier in [Chapter
    3](ch03.html "Chapter 3. Associations"), *Associations*.
  prefs: []
  type: TYPE_NORMAL
- en: Using other annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lot of Doctrine mapping annotations exist. We will use some new annotations
    in [Chapter 3](ch03.html "Chapter 3. Associations"), *Associations* to create
    relations between entities.
  prefs: []
  type: TYPE_NORMAL
- en: The full list of available annotation is given in the Doctrine documentation
    at [http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/annotations-reference.html](http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/annotations-reference.html).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Doctrine Mapping Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Doctrine Mapping Types used in the `@Column` annotation are neither SQL types
    nor PHP types but they are mapped to both. For instance, the Doctrine `text` type
    will be casted to the `string` PHP type in the entity and stored in a database
    column with the `CLOB` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a correspondence table for Doctrine Mapping Type of PHP type
    and SQL type:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Doctrine Mapping Type | PHP Type | SQL Type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `string` | `string` | `VARCHAR` |'
  prefs: []
  type: TYPE_TB
- en: '| `integer` | `integer` | `INT` |'
  prefs: []
  type: TYPE_TB
- en: '| `smallint` | `integer` | `SMALLINT` |'
  prefs: []
  type: TYPE_TB
- en: '| `bigint` | `string` | `BIGINT` |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean` | `boolean` | `BOOLEAN` |'
  prefs: []
  type: TYPE_TB
- en: '| `decimal` | `double` | `DECIMAL` |'
  prefs: []
  type: TYPE_TB
- en: '| `date` | `\DateTime` | `DATETIME` |'
  prefs: []
  type: TYPE_TB
- en: '| `time` | `\DateTime` | `TIME` |'
  prefs: []
  type: TYPE_TB
- en: '| `datetime` | `\DateTime` | `DATETIME` or `TIMESTAMP` |'
  prefs: []
  type: TYPE_TB
- en: '| `text` | `string` | `CLOB` |'
  prefs: []
  type: TYPE_TB
- en: '| `object` | object using the `serialize()` and `unserialize()` methods | `CLOB`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `array` | `array` using `serialize()` and `unserialize()` methods | `CLOB`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | `double` | `FLOAT` (double precision) |'
  prefs: []
  type: TYPE_TB
- en: '| `simple_array` | `array` using `implode()` and `explode()`Values cannot contain
    comma. | `CLOB` |'
  prefs: []
  type: TYPE_TB
- en: '| `json_array` | `object` using `json_encode()` and `json_decode()` methods
    | `CLOB` |'
  prefs: []
  type: TYPE_TB
- en: '| `guid` | `string` | `GUID` or `UUID` if supported by the DBMS, `VARCHAR`
    either |'
  prefs: []
  type: TYPE_TB
- en: '| `blob` | `resource stream` (see [http://www.php.net/manual/en/language.types.resource.php](http://www.php.net/manual/en/language.types.resource.php))
    | `BLOB` |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Keep in mind that we can create custom types. To learn more about this, refer
    to: [http://docs.doctrine-project.org/en/latest/cookbook/custom-mapping-types.html](http://docs.doctrine-project.org/en/latest/cookbook/custom-mapping-types.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the database schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Doctrine is smart enough to generate the database schema corresponding to the
    entity mapping information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's a good practice to always design entities first and to generate the related
    database schema after that.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we will again use Command-Line Tools installed in the first chapter.
    Type this command in the root directory of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following text must be printed in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ATTENTION: This operation should not be executed in a production environment.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating database schema...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Database schema created successfully!**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A new table called `Post` has been created in the database. You can use the
    SQLite client to show the structure of the generated table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It should return the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is the structure of the table Post:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the database schema](graphics/4104OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Doctrine is also able to generate the schema for MySQL and other supported
    DBMS. If we configure our app to use a MySQL server as a DBMS and we run the same
    command, the generated table will look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the database schema](graphics/4104OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Installing Data fixtures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Fixtures** are fake data that allow testing of an app without having to do
    the tedious task of manually creating data after each install. They are useful
    for automated testing processes and make it easier for a new developer to start
    working on our projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any application should be covered with automated tests. The blog app we are
    building is covered by Behat ([http://behat.org/](http://behat.org/)) tests. They
    are provided in downloads available on the Packt website.
  prefs: []
  type: TYPE_NORMAL
- en: Doctrine has an extension called Data Fixtures that ease fixtures creation.
    We will install it and use it to create some fake blog posts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type this command in the root of the project to install Doctrine Data Fixtures
    through Composer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step to using Doctrine Data Fixtures is to create a fixture class.
    Create a file called `LoadPostData.php` in the `src/Blog/DataFixtures` directory
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This `LoadPostData` class contains the logic to create fake data. It creates
    ten blog posts with a generated title, a date of publication, and a text body.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LoadPostData` class implements the `load()`method defined in the `\Doctrine\Common\DataFixtures\FixtureInterface`
    directory. This method takes in parameters for an `EntityManager` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some reminders of [Chapter 1](ch01.html "Chapter 1. Getting Started with Doctrine
    2"), *Getting Started with Doctrine 2*: Calls to `EntityManager::persist()` sets
    the state of each new entity to managed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The call to the `flush()` method, at the end of the process, will make Doctrine
    execute `INSERT` queries to effectively save data in the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We still need to create a loader for our fixtures class. Create a file called
    `load-fixtures.php` in the `bin/` directory of your project with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this utility, we initialize our app and get an Entity Manager as explained
    in [Chapter 1](ch01.html "Chapter 1. Getting Started with Doctrine 2"), *Getting
    Started with Doctrine 2*. Then, we instantiate the fixtures loader provided by
    Doctrine Data Fixtures and tell it where to find our fixtures files.
  prefs: []
  type: TYPE_NORMAL
- en: We only have the `LoadPostData` class for now but we will create additional
    fixtures in the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The `ORMExecutor` method is instanced and executed. It uses `ORMPurger` to erase
    existing data from the database. Then it populates the database with our fixtures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command in the root directory of our project to load our
    fixtures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Our fixtures have been inserted in the database. Note that every time you run
    this command, all data in the database is permanently deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check that our database has been populated with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see ten rows similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**1|Blog post number 1|Lorem ipsum dolor sit amet, consectetur adipiscing elit.|2013-11-08
    20:01:13**'
  prefs: []
  type: TYPE_NORMAL
- en: '**2|Blog post number 2|Lorem ipsum dolor sit amet, consectetur adipiscing elit.|2013-11-09
    20:01:13**'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a simple UI to deal with our posts. This interface will let us
    create, retrieve, update, and delete a blog post. You may have already guessed
    that we will use the Entity Manager to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'For concision and to focus on the Doctrine part, this UI will have many drawbacks.
    *It should not be used in any kind of production or public server*. The primary
    concerns are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Not secure at all**: Everyone can access everything, as there is no authentication
    system, no data validation, and no CSRF protection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Badly designed**: There is no separation of concerns, no use of an MVC-like
    pattern, no REST architecture, no object-oriented code, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And of course this will be… graphically minimalistic!
  prefs: []
  type: TYPE_NORMAL
- en: 'Cross Site Request Forgery (CSRF): [http://en.wikipedia.org/wiki/Cross-site_request_forgery](http://en.wikipedia.org/wiki/Cross-site_request_forgery)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Separation of concerns: [http://en.wikipedia.org/wiki/Separation_of_concerns](http://en.wikipedia.org/wiki/Separation_of_concerns)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Model-View-Controller (MVC) meta-pattern: [http://en.wikipedia.org/wiki/Model-view-controller](http://en.wikipedia.org/wiki/Model-view-controller)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Representational state transfer (REST): [http://en.wikipedia.org/wiki/Representational_state_transfer](http://en.wikipedia.org/wiki/Representational_state_transfer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For real-world apps, you should take a look at Symfony, a powerful framework
    that includes Doctrine and a ton of features (the validation component already
    presented, a form framework, a template engine, an internationalization system,
    and so on): [http://symfony.com/](http://symfony.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: Listing posts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'That being said, create the page that lists posts in the `web/index.php` file
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This first file is the main page of the blog. It lists all posts and display
    links to pages for creating, updating, or deleting posts.
  prefs: []
  type: TYPE_NORMAL
- en: After the app initialization, we get an `EntityManager` using the code we have
    written to configure Command-Line Tools in the first chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We use this `EntityManager` to retrieve the repository of our `\Blog\Entity\Post`
    entities. For now, we use the default entity repository provided by Doctrine.
    We will learn more about them in [Chapter 4](ch04.html "Chapter 4. Building Queries"),
    *Building Queries*. This default repository provides a `findAll()` method that
    retrieves a collection of all entities hydrated from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `Collection` interface is similar to a regular PHP array (with some enhancements).
    This class is part of Doctrine Common: [http://www.doctrine-project.org/api/common/2.4/class-Doctrine.Common.Collections.Collection.html](http://www.doctrine-project.org/api/common/2.4/class-Doctrine.Common.Collections.Collection.html)'
  prefs: []
  type: TYPE_NORMAL
- en: When calling it, Doctrine will query the database to find all rows of the `Post`
    table and populate a collection of `\Blog\Entity\Post` objects with the retrieved
    data. This collection is assigned to the `$posts` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To browse this page, run the following command in the root directory of your
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This runs the built-in PHP webserver. Go to `http://localhost:8000` in your
    favorite web browser, and you'll see our ten fake posts.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If it does not work, be sure that your PHP version is at least 5.4.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and editing posts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s time to create a page to add new blog posts. This same page will also
    allow editing an existing post. Put it in the `web/edit-post.php` file as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This page is a bit trickier:'
  prefs: []
  type: TYPE_NORMAL
- en: When called with an `id` parameter in the URL, it works on the `Post` entity
    with the given ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A best practice would be to use slugs instead of identifiers. They hide an
    application''s internals, can be memorized by humans, and are better for Search
    Engine Optimization: [http://en.wikipedia.org/wiki/Slug_(publishing)](http://en.wikipedia.org/wiki/Slug_(publishing)).'
  prefs: []
  type: TYPE_NORMAL
- en: With no `id` parameter, it instantiates a new `Post` entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When called with the `GET` HTTP method, it displays a form populated with the
    current data of the `Post` in the case of an edit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When called with the `Post` HTTP method (when the form is submitted), it creates
    or updates a `Post` entity, then redirects to the homepage of the blog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an ID is provided through the URL, the `find()` method of the Entity Manager
    is used to retrieve the entity stored in the database with this ID. Doctrine queries
    the database and hydrates the entity for us.
  prefs: []
  type: TYPE_NORMAL
- en: If no `Post` with this ID is found, the `NULL` value is assigned to the `$post`
    variable instead of an instance of `\Blog\Entity\Post`. To avoid further errors,
    we throw an exception if this is the case. To find out more about PHP exceptions,
    refer to the website [http://php.net/manual/en/language.exceptions.php](http://php.net/manual/en/language.exceptions.php).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we call the `persist()` method of the Entity Manager with our new entity
    as a parameter. As explained in [Chapter 1](ch01.html "Chapter 1. Getting Started
    with Doctrine 2"), *Getting Started with Doctrine 2*, this call to the `persist()`
    method sets the state of the entity to managed. It is necessary only for new entities
    because entities retrieved through Doctrine already have the managed state.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set the publication date of our newly created object. Thanks to the
    Doctrine mapping system, we just need to pass a `\DateTime` instance to the `setPublicationDate()`
    method and the ORM will convert it to the format needed by the DBMS for us (refer
    to the type correspondence table).
  prefs: []
  type: TYPE_NORMAL
- en: We also set the `$title` and `$body` properties using the fluent interface of
    getters and setters generated previously.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you don''t know about fluent interface, read the following article: [http://martinfowler.com/bliki/FluentInterface.html](http://martinfowler.com/bliki/FluentInterface.html)'
  prefs: []
  type: TYPE_NORMAL
- en: When the call to the `flush()` method occurs, the Entity Manager tells Doctrine
    to synchronize all managed entities to the database. In this case, only our `Post`
    entity is managed. If it's a new entity, an `INSERT` SQL statement will be generated.
    If it's an existing entity, an `UPDATE` statement will be sent to the DBMS.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Doctrine automatically wraps all operations done when the `EntityManager::flush()`
    method is called in a transaction. If an error occurs, the database state is restored
    as it was before the flush call (rollback).
  prefs: []
  type: TYPE_NORMAL
- en: This is usually the best option, but if you have specific needs, this auto-commit
    mode can be deactivated. This can be referred to at [http://docs.doctrine-project.org/en/latest/reference/transactions-and-concurrency.html](http://docs.doctrine-project.org/en/latest/reference/transactions-and-concurrency.html).
  prefs: []
  type: TYPE_NORMAL
- en: Deleting posts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a page to delete posts in the `web/delete-post.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We retrieve the post we want to delete using the ID parameter in the URL. We
    tell Doctrine to schedule it for removal with the call to the `EntityManager::remove()`
    method. After this call, the state of the entity is removed. When the `flush()`
    method is called, Doctrine executes a `DELETE` SQL query to remove data from the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that after the call to the `flush()` method and the deletion from the database,
    the entity still exists in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a minimal but working blog app! Thanks to Doctrine, persisting,
    retrieving, and removing data to a database has never been so easy.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to use annotations to map entity classes to database tables
    and rows, we generated a database schema without typing a line of SQL, we created
    fixtures and we used the Entity Manager to synchronize data with the database.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to map and manage One-To-One, One-To-Many/Many-To-One,
    and Many-To-Many associations between entities.
  prefs: []
  type: TYPE_NORMAL
