- en: Detecting and Exploiting SQL Injection Vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 5](part0057.html#1MBG20-5a228e2885234f4ba832bb786a6d0c80), *Password
    Testing*, we learned about the different authentication methods, and we created
    a password brute forcing tool. In this chapter, we're going to learn about one
    of the most dangerous vulnerabilities that can affect web applications, **SQL
    injection** (**SQLi**).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to take a look at:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to SQL injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting SQL injection issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting a SQL injection to extract data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced SQLi exploiting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to SQL injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is SQL injection? It is a type of input manipulation vulnerability. As
    the name suggests, it is a vulnerability where the attacker manipulates the web
    application in order to inject arbitrary SQL code into the application database.
    This vulnerability affects mainly web applications that use DBs to store and retrieve
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, most web applications use a DB, thus the united web apps affected
    by this vulnerability are huge. The main cause for this problem is when the web
    application uses data that is coming from an untrusted source to dynamically construct
    a SQL query. If the injection is successful, attackers can:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract arbitrary data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insert tampered data into the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bypass authentication authorizations, and access controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take control of the server by executing OS commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, it allows you to do a lot of things in the web application,
    which, for an attacker, is pretty good.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine we have a login form in our web application. This login form will be
    handled by our server-side code, which will obtain the username and the password
    from the `POST` content. It will be assigned to the variables, a name, and pass.
    Then, these two variables will be used to dynamically construct the SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When our users provide valid usernames and passwords such as `admin` and `superRoot`,
    the login will be successful. But what will happen if a user provides special
    characters and structure to his/her input?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine the same example, but this time, the attacker inserts a `''`
    or `1=1` as the name and password. What will happen here? The resulting SQL query
    is valid. It will return all rows from the table users, since `1=1` is always
    true. This means that it will return all the results in the user''s table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the case of this login screen, it will log the attacker in with the first
    users of the table. Many times, the first user is `admin`, except if there are
    some users called `Aaron` and `Charl`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: SQLi versus blind SQLi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a web application is vulnerable to an SQL injection, but the results of
    the injection are not visible to the attacker, is called blind SQLi.
  prefs: []
  type: TYPE_NORMAL
- en: 'Admins, developers, and frameworks are handling errors in order to avoid leaking
    information. When no results or errors are visible to the attacker, we still have
    some methods that can help exploit the SQL injection in a blind way. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Boolean**: This method is based on injecting payloads that alter the outcome
    of the original query, which results in different returned page content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time based**: This method is based on injecting payloads that trigger a delay
    time for the SQL server while processing our query, which, in turn, slows down
    the response time of our request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We're going to learn more about these techniques in more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting SQL injection issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to learn how to detect SQL injections and how to
    alternate this in Python. We're going to look at what the different methods for
    detecting an SQLi in a web application are. Then, we'll proceed to automate the
    detection of these issues based on one of the methods. Finally, we'll enumerate
    the columns used in the query and also identify valid column names in the table.
  prefs: []
  type: TYPE_NORMAL
- en: Methods for detecting SQLi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to detect SQLi, we have three methods available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Error based**: This method injects payloads that break out of the original
    query and generate an SQL error on the server, which can be detected in the content
    of the returned pages:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Boolean**: This method injects payloads that alter the outcome of the original
    query, which makes the application return different page content. Basically, we''ll
    identify the size of a valid page versus the size of an invalid page, and then
    we perform Boolean queries like the one we can see here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If the first number of the version of the database is `5`, we're going to get
    the page with the ID `1008`. If not, we're going to get the error page. If we
    want the exact database version, we need to automate this query and guess the
    value for each position.
  prefs: []
  type: TYPE_NORMAL
- en: '**Time-based**: This method injects a payload that triggers a delay in the
    SQL server while processing the query. If this delay is big enough and there is
    no considerable lag in the network, we can tell whether the query was executed
    correctly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Automating the detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go back to the editor and open, this in `Section-6`, `SQLinjector-0.py`.
    It's important to highlight that all the content and scripts are based on MySQL
    database and will only work with this database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `import` section, we have the same content we were using in [Chapter
    5](part0057.html#1MBG20-5a228e2885234f4ba832bb786a6d0c80), *Password Testing*.
    Then, we have the typical `banner` and `usage` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have the `start` function, which has nothing new. Then, we have the
    common options. We have two parameters, which are the URL to test and the dictionary
    of injections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we move to the function `launcher`. This will replace the `FUZZ` token,
    with all the `injection` strings provided in the input file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It will then call the `injector` and print the results. The function `injector`
    is the next SQL injection, based on errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: For this purpose, we have the array errors, which has the limited number of
    strings we found in `Mysql` errors. Then, we perform the `requests`, and if we
    find an error, we add the URL to the results array, which, finally, will be printed
    in the launcher function.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s try this script. Remember the interesting files that we identified
    with our brute force script in [Chapter 4](part0049.html#1ENBI0-5a228e2885234f4ba832bb786a6d0c80),
    *Resources Discovery*? There was one file in particular that we needed to focus
    on. It''s `/users.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This file seems to take an input and return the user and row for that user
    ID. Let''s see what happens if we put `1`. You can see we get a response with
    the `ID: 1`, `Name: johnny`, and `role: test` in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Excellent! Let's copy the URL to use as the input for our script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go to the console and run the SQL injector with the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These are the URLs that we copy from the browser and the injection files that
    we created for this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, press *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the script detected the SQL error generated by the following
    characters; single quote and parenthesis.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check the browser to see the error that these characters generate. Now,
    in the browser, replace this `1` with `''` and press *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that when generating an SQL error, we can manipulate that query.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to improving the SQL injector script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the script `SQLinjector-1.py`. You can see that we have two new functions, `detect_columns`
    and `detect_columns_names`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`detect_columns` tries to identify how many columns are being used in this
    select and, how many we are trying to manipulate. This information is important
    in order to craft our SQL query. In order to do so, we use the order by technique.
    We can add order by `X`, where `X` is a number. If the number is less than or
    equal to the number of columns, it will return results; if not, it will return
    an error. So, if we try this until we get an error, this will mean that the number
    of columns is less than `X`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this in the browser. Now, we try with `a'' order by 1`. We need
    to finish the query with `-- -` to avoid errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'With `1`, we get results. So, they use at least one column. Let''s try with
    three. We get `Unknown column ''3'' in ''order close''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This means that there are less than three columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, it would be `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We also, have a new function called `detect_columns_names`. This function tries
    to identify valid column names in the table being used by the SQL query. This
    is useful because it will help us to tailor our query to extract data. We're going
    to use the group by technique. We add `group by` and the name of a column. If
    it exists, it will return valid results; if not, we get an error. The array `column_names`
    has a list of interesting names for columns, but in reality, you need an extensive
    dictionary of words to identify as many columns as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see an example in the browser. This time, we are going to use `group`
    and we are going to use `password` as a column name.
  prefs: []
  type: TYPE_NORMAL
- en: 'And then, we hit *Enter*. We can see that it is valid and we are getting the `admin` results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'But what if we use `username` for the column name? We can add `username` in
    the group statement. We can see that the column `username` is not valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Hence, we know the error message to identify invalid column names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s run the script in the command line. We are going to change to `SQLinjection-1.py`
    and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we get the same results as before, plus the number of columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, the number of columns is `2` and some of the column names found
    are `name`, `passwd`, `id`, and `role`.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have created an SQL injector detector.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting a SQL injection to extract data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to learn how to exploit SQL injections and how
    to alternate this in Python. We're going to learn what kind of data we can extract
    with an SQL injection, and then we're going to alternate some of these techniques,
    such as automating basic data extractions in our SQL injector script from the
    previous section.
  prefs: []
  type: TYPE_NORMAL
- en: What data can we extract with an SQLi?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we identify a valid SQL injection, it''s time to decide what we''re going
    to look for. Here, we have a list of the most typical things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic data**: For example, database version, user running the database, current
    database, database directory, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced data**: MySQL usernames and passwords, databases, table names, column
    names, and content from tables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OS files**: We can read any file in the file system as long as the user running
    the database has privileges'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are some of the most useful and typically extracted data. I encourage
    you to continue learning what other things you can do once you have a working
    SQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: A good starting point is the pentestmonkey Cheat Sheet ([http://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet](http://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet)).
  prefs: []
  type: TYPE_NORMAL
- en: Automating basic extractions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we want to obtain after we get a working SQL injection is information
    about the database we're working with, such as the database version, the current
    user, the current database, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do so, we need to use `SELECT @@ version;`. We'll obtain the database
    version. `SELECT user();`, will get you the user that is running the database.
    For our example, we must use the following injection to get the version; `'union
    SELECT1, @@version;-- -`. We need `1` before the `@@version` to match the number
    of columns we have on the query, which is the number of columns that have been
    affected by the SQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, there were two columns; that's why we add `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go to our editor and continue with the file `SQLinjector-2.py`. We have
    added two new functions in order to obtain the version and current user from the
    database. You will notice that we have the following injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `%20` is the URL encoded version of the space character. We are using the `CONCAT`
    command to concatenate the string talk at the beginning of the result and at the
    end. The strings will serve as tokens to identify the output of the query in the
    HTML result. Now, we'll see the code we need to extract the version.
  prefs: []
  type: TYPE_NORMAL
- en: We do this by processing the results using a regular expression to identify
    the tokens talk and extract the string found between them. We define the regular
    expression, then we use the `findall` function from the `re` library with the
    content of the request response, and then we iterate over the results.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, there should be only one. We will do the same process to get the
    database version by using `@@version` instead of `user`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we want to obtain the MySQL usernames and password hashes. The query we
    need for this is `SELECT user, password from mysql.user;`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that this will only work if the user that is making the connection
    to the database has the privileges to access the table. Best practices recommend
    the game phase, but many people still do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We added the function `steal_users` to extract this data. We''ll use the same
    techniques as before with the tokens to identify the output in the HTML results.
    Let''s run it in the command line and see the outputs. We''ll use the same command
    line as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we can see the new data that has been extracted. The database version is
    printed. In this case, it is `5.6.28`. It also gives us a hint on the OS; `Ubuntu
    15.10.1`. The user running the database is root, which means that we have high
    privileges that will allow us to do more interesting things such as, for example,
    accessing the table `MySQL.user`, where the usernames and passwords hashes are
    stored.
  prefs: []
  type: TYPE_NORMAL
- en: We can see the hashes for the user `root`, `debian-sys-maint`, and `phpmyadmin`.
    The repetitions are happening because of the different host entries that are associated
    with each user. These password hashes can be cracked with a tool like John the
    ripper if you need to do so. Great. You have a pretty good idea of the target,
    so let's continue extracting data.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced SQLi exploiting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to add a function to read all the table names from
    the database, and we are going to add a function to read the files from the database
    server OS.
  prefs: []
  type: TYPE_NORMAL
- en: First, we're going to see how we can obtain all the table names that are in
    the database in order to see if we see something of interest, and then we're going
    to add the capability to reach finals from the OS file system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s open the file `SQLinjector-3.py`. We have a new function in here
    that will help us obtain the table names in the different schemas, except the
    ones we are filtering out to reduce the noise in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The structure is the same as before; we have the query we need, with the tokens
    to help pass the results and the regular expression for passing it, and then we
    print the results. Finally, we have the function call in the `launcher`. Let's
    run it again in the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the command line, let''s run it with the same parameters as before, with `SQLinjector-3.py`
    and the same parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Great, you can now see in the output that we get the schema name and the table
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, `pyweb` and `phpmyadmin` are the schema and the others are the
    table `user` and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to the last example. Let''s go to the editor and open the file
    `SQLinjection-4.py`. This is pretty cool, and it opens a new world of opportunities
    for the attacker. Let''s see the new function, `read_file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The query we are going to use to read files is highlighted in the preceding
    code. Basically, the new thing here is the use of the function `LOAD_FILE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this function, which as the name suggests, will load a file, and
    we will put the content in the column we choose in the query. We are going to
    use it with a union. Then, in the `launcher`, we need to call this function with
    the file we want to read. In this example, we are using `filename="/etc/passwd"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This file contains the users for the Linux OS. Let''s run it in the command
    line. Use the same command line as before, just change the file name to `SQLinjector-4.py`.
    And boom, we have the content of the exact password file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we can learn a little bit more about the system. Let's take a moment to
    think on all that we have achieved by abusing a simple programming mistake; we
    are obtaining a vast amount of information from the database and the OS - and
    this is still the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend playing with this until you're comfortable with the techniques.
    If something doesn't work, review your SQL syntax. It is very common to make mistakes
    at the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to enumerate the table names from the database
    using SQL injection, and we also learned how to read files from the OS file system
    via SQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to review the tools, such as SQL map or SQL brute, to learn more about
    how these tools work.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](part0081.html#2D7TI0-5a228e2885234f4ba832bb786a6d0c80), *Intercepting
    HTTP Requests*, we're going to learn about HTTP proxies, and we're going to create
    our own based on the mitmproxy tool.
  prefs: []
  type: TYPE_NORMAL
