- en: Showing Progress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is all about communicating progress to the user. React Native has
    different components to handle the different types of progress that you want to
    communicate. First, you'll learn why you need to communicate progress like this
    in the first place. Then, you'll learn how to implement progress indicators and
    progress bars. After that, you'll see specific examples that show you how to use
    progress indicators with navigation while data loads, and how to use progress
    bars to communicate the current position in a series of steps.
  prefs: []
  type: TYPE_NORMAL
- en: Progress and usability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you have a microwave oven that has no window and makes no sound.
    The only way to interact with it, is by pressing a button labeled cook. As absurd
    as this device sounds, it's what many software users are faced with—there's no
    indication of progress. Is the microwave cooking anything? If so, how do we know
    when it will be done?
  prefs: []
  type: TYPE_NORMAL
- en: One way to improve the microwave situation is to add sound. This way, the user
    gets feedback after pressing the cook button. You've overcome one hurdle, but
    the user is still left guessing—where's my food? Before you go out of business,
    you had better add some sort of progress measurement display, such as a timer.
  prefs: []
  type: TYPE_NORMAL
- en: It's not that UI programmers don't understand the basic principles of this usability
    concern; it's just that we have stuff to get done and this sort of thing simply
    slips through the cracks in terms of priority. In React Native, there are components
    for giving the user indeterminate progress feedback, and for giving precise progress
    measurements. It's always a good idea to make these things a top priority if you
    want a good user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Indicating progress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll learn how to use the `ActivityIndicator` component.
    As the name suggests, you render this component when you need to indicate to the
    user that something is happening. The actual progress may be indeterminate, but
    at least you have a standardized way to show that something is happening, despite
    there being no results to display yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an example so that you can see what this component looks like.
    Here''s the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<ActivityIndicator>` component is platform agnostic. Here''s how it looks
    on iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8030d118-69a1-47ed-853a-6a7124769ee9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It renders an animated spinner in the middle of the screen. This is the large
    spinner, as specified in the `size` property. The `ActivityIndicator` spinner
    can also be small, which makes more sense if you''re rendering it inside another
    smaller element. Now let''s take a look at how this looks on an Android device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/afc16e23-452a-47f7-be38-f8f2d646acd8.png)'
  prefs: []
  type: TYPE_IMG
- en: The spinner looks different, as it should, but your app conveys the same thing
    on both platforms—you're waiting for something.
  prefs: []
  type: TYPE_NORMAL
- en: This example just spins forever. Don't worry, there's a more realistic progress
    indicator example coming up that shows you how to work with navigation and loading
    API data.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring progress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The downside of indicating that progress is being made is that there's no end
    in sight for the user. This leads to a feeling of unease, like when waiting for
    food in a microwave with no timer. When you know how much progress has been made,
    and how much is left to go, you feel better. This is why it's always better to
    use a deterministic progress bar whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the `ActivityIndicator` component, there's no platform-agnostic component
    in React Native for progress bars. So, we'll have to make one ourselves. We'll
    create a component that uses `ProgressViewIOS` on iOS and `ProgressBarAndroid` on
    Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s handle the cross-platform issues first. React Native knows to import
    the correct module based on its file extension. Here''s what the `ProgressBarComponent.ios.js`
    module looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You''re directly exporting the `ProgressViewIOS` component from React Native.
    You''re also exporting properties for the component that are specific to the platform.
    In this case, it''s an empty object because there are no properties that are specific
    to `<ProgressViewIOS>`. Now, let''s take a look at the `ProgressBarComponent.android.js`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This module uses the exact same approach as the `ProgressBarComponent.ios.js`
    module. It exports the Android-specific component as well as Android-specific
    properties to pass to it. Now, let''s build the `ProgressBar` component that the
    application will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let's walk through what's going on in this module, starting with the imports.
    The `ProgressBarComponent` and `progressProps` values are imported from our `ProgressBarComponent`
    module. React Native determines which module to import this from.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you have the `ProgressLabel` utility component. It figures out what label
    is rendered for the progress bar based on the `show` property. If `false`, nothing
    is rendered. If `true`, it renders a `<Text>` component that displays the progress
    as a percentage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, you have the `ProgressBar` component itself, when our application will
    import and use. This renders the label and the appropriate progress bar component.
    It takes a `progress` property, which is a value between `0` and `1`. Now let''s
    put this component to use in the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, the `<ProgressBar>` component is rendered at 0%. In the `componentDidMount()`
    method, the `updateProgress()` function uses a timer to simulate a real process
    that you want to show progress for. Here''s what the iOS screen looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/43a111b5-2eca-44c8-9c6f-e931c23859ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s what the same progress bar looks like on Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ec0a7014-f585-40d4-ab79-b2351815ca52.png)'
  prefs: []
  type: TYPE_IMG
- en: Navigation indicators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in the chapter, you were introduced to the `ActivityIndicator` component.
    In this section, you'll learn how it can be used when navigating an application
    that loads data. For example, the user navigates from page (screen) one to page
    two. However, page two needs to fetch data from the API to display for the user.
    So while this network call is happening, it makes more sense to display a progress
    indicator instead of a screen devoid of useful information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing this is actually kind of tricky because you have to make sure that the
    data required by the screen is fetched from the API each time the user navigates
    to the screen. Your goals should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Have the `Navigator` component automatically fetch API data for the scene that's
    about to be rendered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the promise that's returned by the API call as a means to display the spinner
    and hide it once the promise has resolved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since your components probably don''t care about whether or not a spinner is
    displayed, let''s implement this as a generic higher-order component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This `loading()` function takes a component—the `Wrapped` argumentand returns
    a `LoadingWrapper` component. The returned wrapper accepts a `promise` property,
    and when it resolves or rejects, it changes the `loading` state to `false`. As
    you can see in the `render()` method, the `loading` state determines whether the
    spinner is rendered or the `Wrapped` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `loading()` higher-order function in place, let''s take a look at
    the first screen component that you''ll use with `react-navigation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This module exports a component that''s wrapped with the `loading()` function
    created earlier. It wraps the `First` component so that a spinner is displayed
    while the `promise` property is pending. The last step is getting that promise
    into the component whenever the user navigates to a given page. This happens in
    the route configuration in the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Instead of just passing the screen components directly to the router config
    argument of `createStackNavigator()`, you're passing an object for each screen.
    The `screen` property allows you to provide the actual screen component to render.
    In this case, you're passing it a promise property by calling an API function
    that resolves data needed by the component. This is how the `loading()` function
    is able to display a spinner while waiting for the promise to resolve. The first
    screen doesn't have to worry about displaying a loading screen.
  prefs: []
  type: TYPE_NORMAL
- en: Step progress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final example, you'll build an app that displays the user's progress
    through a predefined number of steps. For example, it might make sense to split
    a form into several logical sections and organize them in such a way that as the
    user completes one section, they move to the next step. A progress bar would be
    helpful feedback for the user.
  prefs: []
  type: TYPE_NORMAL
- en: You'll insert a progress bar into the navigation bar, just below the title,
    so that the user knows how far they've gone and how far is left to go. You'll
    also reuse the `ProgressBar` component that you implemented earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the result first. There are four screens in this app
    that the user can navigate to. Here''s what the first page (scene) looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/28469123-c5dc-4323-a57b-74d385d63093.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The progress bar below the title reflects the fact that the user is 25% through
    the navigation. Let''s see what the third screen looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4df4b66f-8144-4f5f-b445-0c64f978fe74.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The progress is updated to reflect where the user is in the route stack. Let''s
    take a look at the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This app has four screens. The components that render each of these screens
    is stored in the `routes` constant, which is then used to configure the stack
    navigator using `createStackNavigator()`. The reason for creating the `routes`
    array is so that it can be used by the `progress()` function that is passed to
    the initial route (`First`) as a route parameter. This function takes the current
    route name as an argument and looks up its index position in routes. For example,
    `Second` is in the number `2` position (index of 1 + 1) and the length of the
    array is `4`. This will set the progress bar to 50%.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how the `progress` function is used by the `First` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The function is accessed as `navigation.state.params.progress()`. It's passed
    the value of `navigation.state.routeName` to get the progress value for the current
    page. Also, the calls to `navigation.navigate()` have to pass `navigation.state.params`
    so that the `progress()` function is available to the screen. If you don't do
    this, then `progress()` will only be available to the first screen because it's
    set using the `initialRouteParams` option within the `App` component.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about how to show your users that something is
    happening behind the scenes. First, we discussed why showing progress is important
    for the usability of an application. Then, you implemented a basic screen that
    indicated progress was being made. You then implemented a `ProgressBar` component,
    used to measure specific progress amounts.
  prefs: []
  type: TYPE_NORMAL
- en: Indicators are good for indeterminate progress, and you implemented navigation
    that showed progress indicators while network calls were pending. In the final
    section, you implemented a progress bar that showed the user where they were in
    a predefined number of steps.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, you'll see React Native maps and geolocation data
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's the difference between a progress bar and an activity indicator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A progress bar is determinate whereas a progress indicator is used to indicate
    an indeterminate amount of time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no difference. A progress bar and a progress indicator are actually
    the same thing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A progress bar renders a horizontal bar—everything else is considered a progress
    indicator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does the React Native `ActivityIndicator` component work the same on iOS and
    Android?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, this component is not platform agnostic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, this component is platform agnostic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you use the `ProgressViewIOS` and the `ProgressBarAndroid` components
    in a platform agnostic way?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can define your own `ProgressBar` component that imports other components
    with platform-specific file extensions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can't; you have to implement platform-checking logic everywhere that you
    want to use a progress bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the following links for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/activityindicator](https://facebook.github.io/react-native/docs/activityindicator)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/progressviewios](https://facebook.github.io/react-native/docs/progressviewios)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/progressbarandroid](https://facebook.github.io/react-native/docs/progressbarandroid)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
