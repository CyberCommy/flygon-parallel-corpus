- en: Implementing Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll go step by step through the process of adding Redux
    to our app. We''ll cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Redux and preparing our project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining reducers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating with a remote API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting the store to the views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing offline content using Redux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing network connectivity status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point during the development of most applications, we'll need a better
    way to handle the state of the overall app. This will ease sharing data across
    components and provide a more robust architecture for scaling our app in the future.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get a better understanding of Redux, the structure of this chapter
    will differ from previous chapters, since we'll be creating one app through all
    of these recipes. Each recipe in this chapter will depend on the last recipe.
  prefs: []
  type: TYPE_NORMAL
- en: We will be building a simple app for displaying user posts, and we'll use a
    `ListView` component to display the data returned from the API. We'll be using
    the excellent mock data API we've used before located at [https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com).
  prefs: []
  type: TYPE_NORMAL
- en: Installing Redux and preparing our project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll install Redux in an empty application, and we'll define
    the basic folder structure of our app.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll need a new empty app for this recipe. Let's call it `redux-app`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also need two dependencies: `redux` for handling state management and `react-redux` for
    gluing together Redux and React Native. You can install them from the command
    line with yarn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can use `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As part of this recipe, we'll build out the folder structure that the app will
    use. Let's add a `components` folder with an `Album` folder inside of it to hold
    the photo album component. We'll also need a `redux` folder to hold all of our
    Redux code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `redux` folder, let's add an `index.js` file for Redux initialization.
    We also need a `photos` directory, with an `actions.js` file and a `reducer.js`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For now, the `App.js` file will only contain an `Album` component, which we''ll
    define later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Getting started*, we installed the `redux` and `react-redux` libraries.
    The `react-redux` library contains the necessary bindings to integrate Redux with
    React. Redux is not exclusively designed to work with React. You can use Redux
    with any other JavaScript libraries out there. By using `react-redux`, we'll be
    able to seamlessly integrate Redux into our React Native application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 2*, we created the main folders we''ll use for our app:'
  prefs: []
  type: TYPE_NORMAL
- en: The `components` folder will contain our app components. In this case, we're
    only adding one `Album` component to keep this recipe simple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `redux` folder will contain all of the Redux related code (initialization,
    actions, and reducers).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a medium to large app, you will probably want to separate your React Native
    components further. The React community standard is to split the app''s components
    into three separate types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Components`: The community calls them presentational components. In simple
    terms, these are the kind of components that are not aware of any business logic
    or Redux actions. These components only receive data via props and should be reusable
    on any other project. A button or panel would be a perfect example of a presentational
    component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Containers`: These are components that directly receive data from Redux and
    are able to call actions. In here, we''ll define components such as a header that
    displays the logged in user. Usually, these components internally use presentational
    components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pages/Views`: These are the main modules in the app that use containers and
    presentational components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on structuring your Redux powered components, I recommend
    the excellent article, *Structure your React-Redux project for scalability and
    maintainability*, at the following link*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[https://levelup.gitconnected.com/structure-your-react-redux-project-for-scalability-and-maintainability-618ad82e32b7](https://levelup.gitconnected.com/structure-your-react-redux-project-for-scalability-and-maintainability-618ad82e32b7)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need to create a `redux/photos` folder. In this folder, we''ll
    create the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `actions.js` file, which will contain all of the actions the app can perform.
    We will talk more about actions on the next recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `reducer.js` file, which will contain all the code managing the data in
    the Redux store. We will dig deeper into this subject in later recipes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An action is a payload of information that sends data to the store. Using these
    actions is the *only* way components can request or send data to the Redux store,
    which serves as the global state object for the entire app. An action is just
    a plain JavaScript object. We'll be defining functions that return these actions.
    A function that returns an action is called an action creator.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll create the actions to load the initial images for the
    gallery. During this recipe, we'll be adding hardcoded data, but later on, we'll
    request this data from an API to create a more realistic scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's continue working on the code from the previous recipe. Make sure to follow
    those steps in order to have Redux installed and build out the folder structure
    that we'll use for this project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll need to define types for each the action. Open the `redux/photos/actions.js`
    file. Action types are defined as constants that can later be referenced in actions
    and reducers, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create our first action creator. Every action needs a `type` property
    to define it, and actions will often have a `payload` property of data to pass
    along with the action. In this recipe, we''re hardcoding a mock API response made
    up of an array of two photo objects, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need an action creator for each action we want the app to be able to
    execute, and we want this app to be able to add and remove images. First, let''s
    add the `addBookmark` action creator, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, we''ll need another action creator for removing photos:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 1*, we defined the action's type to indicate what it does, which in
    this case is fetch images. We use a constant since it will be used in multiple
    places, including action creators, reducers, and tests.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, we declared an action creator. Actions are simple JavaScript objects
    that define an event that happens in our app that will affect the state of the
    app. We use actions to interact with data that lives in the Redux store.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s only one single requirement: each action must have a `type` property.
    In addition, an action will often include a `payload` property that holds data
    relevant to the action. In this case, we are using an array of photo objects.'
  prefs: []
  type: TYPE_NORMAL
- en: An action is valid as long as the `type` property is defined. If we want to
    send anything else, it is a common convention to use the `payload` property as
    popularized by the flux pattern. However, the name property isn't inherently special.
    We could name this `params` or `data` and the behavior would remain the same.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, we have defined the action creators, which are simple functions that
    return actions. In order to use them, we need to use the `dispatch` method provided
    by the Redux `store`. We will learn more about the store in later recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Defining reducers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have created a few actions for our app. As discussed earlier,
    actions define that something should happened, but we haven't created anything
    for putting the action into motion. That's where reducers come in. Reducers are
    functions that define how an action should affect the data in the Redux `store`.
    All accessing of data in the `store` happens in a reducer.
  prefs: []
  type: TYPE_NORMAL
- en: Reducers receive two parameters: `state` and `action`. The `state` parameter
    represents the global state of the app, and the `action` parameter is the action
    object being used by the reducer. Reducers return a new `state`  parameter reflecting
    the changes that are associated with a given `action`  parameter. In this recipe,
    we'll introduce a reducer for fetching the photos by using the actions we defined
    in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe depends on the previous recipe, *Defining actions**.* Be sure to
    start from the beginning of this chapter to avoid any problems or confusion.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by opening the `photos/reducer.js` file and importing all of the
    action types we defined in the previous recipe, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll define an initial state object for the state in this reducer. It has
    a `photos` property initialized to an empty array for the currently loaded photos,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now define the `reducer` function. It''ll receive two parameters, the
    current state and the action that has been dispatched, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: React Native components can also have a `state` object, but that is an entirely
    separate `state` from that which Redux uses. In this context, `state` refers to
    the global state stored in the Redux `store`.
  prefs: []
  type: TYPE_NORMAL
- en: 'State is immutable, so instead of manipulating state, inside the reducer function,
    we need to return a new state for the current action, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to add a new bookmark to the array, all we need to do is get the payload
    of the action and include it in the new array. We can use the spread operator
    to spread the current photos array on `state`, then add `action.payload` to the
    new array, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to remove an item from the array, we can use the filter method,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is to combine all of the reducers that we have. In a larger
    app, you will likely have reason to break your reducers into separate files. Since
    we''re only using one reducer, this step is technically optional, but it illustrates
    how multiple reducers can be combined together with Redux''s `combineReducers`
    helper. Let''s use it in the `redux/index.js` file, which we''ll also use to initiate
    the Redux store in the next recipe, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 1*, we imported all of the action types that we declared in the previous
    recipe. We use these types to determine what action should be taken and how `action.payload`
    should affect the Redux state.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, we defined the initial state of the `reducer` function. For now,
    we only need an empty array for our photos, but we could add other properties
    to the state, such as Boolean properties of `isLoading` and `didError` to track
    loading and error states. These can, in turn, be used to update the UI during
    and in response to `async` actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 3*, we defined the `reducer` function, which receives two parameters:
    the current state and the action that is being dispatched. We set the initial
    state to `initialState` if we are not provided with one. This way, we can ensure
    that the photos array exists at all times within the app, which will help in avoiding
    errors in cases where actions get dispatched that don''t affect the Redux state.'
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4*, we defined an action for fetching photos. Remember that state is
    never directly manipulated. If the action's type matches the case, a new state
    object is created by combining the current `state.photos` array with the incoming
    photos on `action.payload`.
  prefs: []
  type: TYPE_NORMAL
- en: The `reducer` function should be pure. This means there shouldn't be side effects
    on any of the input values. Mutating the state or the action is bad practice and
    should always be avoided. A mutation can lead to inconsistent data or not triggering
    a render correctly. Also, in order to prevent side effects, we should avoid executing
    any AJAX requests inside the reducer.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, we created the action for adding a new element to the photos array,
    but instead of using `Array.push`, we are returning a new array and appended the
    incoming element to the last position to avoid mutating the original array on
    the state.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6*, we added an action for removing the bookmark from the state. The
    easiest way to do this is by using the `filter` method so we can ignore the element
    with the ID that was received on the action's payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 7*, we use the `combineReducers` function to merge all of the reducers
    into a single global state object that will be saved in the store. This function
    will call each reducer with the key in the state that corresponds to that reducer;
    this function is exactly the same as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The photos reducer has only been called on the part of the state that cares
    about photos. This will help you avoid managing all state data in a single reducer.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Redux store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Redux store is responsible for updating the information that is calculated
    on the state inside reducers. It is a single global object, which can be accessed
    via the store's `getState` method.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll tie together the actions and the reducer we created in
    previous recipes. We will use the existing actions to affect data that lives in
    the store. We will also learn how to log changes on the state by subscribing to
    the store changes. This recipe serves more as a proof of concept of how actions,
    reducers, and the store work together. We'll dive deeper into how Redux is more
    commonly used within apps later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s open the `redux/index.js` file and import the `createStore` function
    from `redux`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Creating the store is extremely simple; all we need to do is call the function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'imported in *step 1* and send the reducers as the first parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! We''ve set up the store, so now let''s dispatch some actions. The
    next steps in this recipe will be removed from the final project since they''re
    for testing our setup. Let''s start by importing the action creators we would
    like to dispatch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Before dispatching any actions, let''s subscribe to the store, which will allow
    us to listen to any changes that occur in the store. For our current purposes,
    we only need to `console.log` the result of `store.getState()`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s dispatch some actions and see the resulting state in the Developer console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to add a new bookmark, we need to dispatch the `addBookmark` action
    creator with the photos object as the parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove an item, we pass along the `id` of the photo we want to remove to
    the action creator, since this is what the reducer is using to find the item that
    should be deleted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing all of these actions, we can stop listening to changes on the
    store by running the unsubscribe function we created in *step 4* when we subscribed
    to the store, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to import the `redux/index.js` file into the `App.js` file, which will
    run all of the code in this recipe so we can see the related `console.log` messages
    in the Developer console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 3*, we imported the action creators we created in the earlier recipe, *Defining
    actions*. Even though we don't yet have a UI, we can use the Redux store and observe
    the changes as they happen. All it takes is calling an action creator and then
    dispatching the resulting action.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, we called the `dispatch` method from the `store` instance. `dispatch`
    takes an action, which is created by the `loadBookmarks` action creator. The reducer
    will be called in turn, which will set the new photos on the state.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our UI in place, we'll dispatch the actions in a similar fashion
    from our components, which will update the state, ultimately triggering a re-render
    of the component, displaying the new data.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with a remote API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are currently loading the bookmarks from hardcoded data in the action. In
    a real app, we're much more likely to be getting data back from an API. In this
    recipe, we'll use a Redux middleware to help with the process of fetching data
    from an API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll be using `axios` to make all AJAX requests. Install
    it with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can install it with `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For this recipe, we''ll be using the Redux middleware, `redux-promise-middleware`.
    Install the package with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can install it with `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This middleware will create and automatically dispatch three related actions
    for each AJAX request made in our app: one when a request begins, one when a request
    succeeds, and one for when a request fails. Using this middleware, we are able
    to define an action creator that returns an action object with a *promise* for
    a payload. In our case, we''ll be creating the `async` action, `FETCH_PHOTOS`,
    whose payload is an API request. The middleware will create and dispatch an action
    of the `FETCH_PHOTOS_PENDING` type. When the request resolves, the middleware
    will create and dispatch either an action of the `FETCH_PHOTOS_FULFILLED` type with
    the resolved data as the `payload` if the request was successful or an action
    of the `FETCH_PHOTOS_REJECTED` type with the error as a `payload` if the request
    failed.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by adding the new middleware to our Redux store. In the `redux/index.js`
    file, let''s add the Redux method, `applyMiddleware`. We''ll also add the new
    middleware we just installed, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the call to `createStore` that we defined previously, we can pass in `applyMiddleware`
    as the second parameter. `applyMiddleware` takes one parameter, which is the middleware
    we want to use, `promiseMiddleware`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Unlike some other popular Redux middleware solutions such as `redux-thunk`, `promiseMiddleware`
    must be invoked when it is passed to `applyMiddleware`. It is a function that
    returns the middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to be making real API requests in our actions now, so we need
    to import `axios` into `redux/photos/actions`. We''ll also add the API''s base
    URL. We are using the same dummy data API we used in previous chapters, hosted
    at [http://jsonplaceholder.typicode.com](http://jsonplaceholder.typicode.com),
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll update our action creators. We''ll first update the types we need
    for handling AJAX requests, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of returning dummy data as `payload` for this action, we''ll return
    a `GET` request. Since this is a `Promise`, it will trigger our new middleware.
    Also, notice how the action''s type is `FETCH_PHOTOS`. This will cause the middleware
    to automatically create `FETCH_PHOTOS_PENDING`, `FETCH_PHOTOS_FULFILLED` with
    a `payload` of resolved data when successful, and `FETCH_PHOTOS_REJECTED` with
    a `payload` of the error that occurred, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like the `FETCH_PHOTOS` action, we''ll be making use of the same middleware
    provided types for the `ADD_PHOTO` action, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The action creator itself will no longer just return the passed in photo as
    the `payload`, but instead will pass a `POST` request promise for adding the image
    via the API, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can follow the same pattern to convert the `REMOVE_PHOTO` action into an
    AJAX request that uses the API to *delete* a photo. Like the other two action
    creators for `ADD_PHOTO` and `FETCH_PHOTOS`, we''ll define the action types for
    each action, then return the delete `axios` request as the action''s `payload`.
    Since we''ll need `photoId` in the reducer when we remove the image object from
    the Redux store, we also pass that along as an object on the action''s `meta` property,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to revisit our reducers to adjust the expected payload. In `redux/reducers.js`,
    we''ll start by importing all of the action types we''ll be using, and we''ll
    update `initialState`. For reasons that will be apparent in the next recipe, let''s
    rename the array of photos on the `state` object to `loadedPhotos`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the reducer itself, update each case to take the `FULFILLED` variation of
    the base action: `FETCH_PHOTOS` becomes `FETCH_PHOTOS_FULFILLED`, `ADD_PHOTOS`
    becomes `ADD_PHOTOS_FULFILLED`, and `REMOVE_PHOTOS` becomes `REMOVE_PHOTOS_FULFILLED`.
    We''ll also update all of the references to the photos array of `state` from `photos`
    to `loadedPhotos`.  When using `axios`, all response objects will contain a `data`
    parameter that holds the actual data received from the API, which means we''ll
    also need to update all references of `action.payload` to `action.payload.data`.
    And in the `REMOVE_PHOTO_FULFILLED` reducer, we can no longer find `photoId` at `action.payload.id`,
    which is why we passed `photoId` on the action''s `meta` property in *step 8*,
    therefore `action.payload.id` becomes `action.meta.photoId`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 2*, we applied the middleware that was installed in the *Getting started*
    section. As mentioned before, this middleware will allow us to make just one action
    creator for AJAX actions that automatically creates individual action creators
    for the `PENDING`, `FULFILLED`, and `REJECTED` request states.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, we defined the `fetchPhotos` action creator. You'll recall from
    the previous recipes that actions are plain JavaScript objects. Since we defined
    a Promise on the action's payload property, `redux-promise-middleware` will intercept
    this action and automatically create the three associated actions for the three
    possible request states.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 7* and *step 8*, we defined the `addPhoto` action creator and the `removePhoto`
    action creator which, just like `fetchPhotos`, have an AJAX request as the action
    payload.
  prefs: []
  type: TYPE_NORMAL
- en: By utilizing this middleware, we are able to avoid repeating the same boilerplate
    over and over for making different AJAX requests.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we only handled the success conditions of the AJAX requests
    made in the app. It would be wise in a real app to also handle the error states
    represented with actions types ending in `_REJECTED`. This will be a great place
    to handle an error by saving it to the Redux store, so that the view can display
    error information when it occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the store to the view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have set up the state, we have included middleware, and we've defined
    actions, action creators, and reducers for interacting with a remote API. However,
    we are not able to show any of this data on the screen. In this recipe, we'll
    enable our component to access the store that we have created.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe depends on all of the previous ones, so make sure to follow each
    recipe preceding this one.
  prefs: []
  type: TYPE_NORMAL
- en: In the first recipe of this chapter, we installed the `react-redux` library
    along with our other dependencies. In this recipe, we are finally going to make
    use of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also be using a third-party library for generating random color hexes,
    which we''ll use to request colored images from the placeholder image service
    at [https://placehold.it/](https://placehold.it/). Before we begin, install `randomcolor`
    with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can install it with `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by wiring the Redux store to the React Native app in `App.js`.
    We''ll start with the imports, importing `Provider` from `react-redux` and the
    store we created earlier. We''ll also import the `Album` component we''ll be defining
    shortly, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s the job of  the `Provider` to connect our Redux store to the React Native
    app so that the app''s components can communicate with the store. `Provider` should
    be used to wrap the entire app, and since this app lives in the `Album` component,
    we''ll wrap the `Album` component with the `Provider` component. `Provider` takes
    a `store` prop, where we''ll pass in our Redux store. The app and the store are
    wired:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s turn to the `Album` component. The component will live at `components/Album/index.js`.
    We''ll start with the imports. We''ll import the `randomcolor` package for generating
    random color hexes, as mentioned in the *Getting started* section. We''ll also
    import `connect` from `react-redux`, and the action creators we defined in previous
    recipes. `connect` will wire our app to the Redux store, and we can then use the
    action creators to affect the store''s state, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the `Album` class, however, instead of directly exporting `Album`
    as the `default` export, we''ll use `connect` to wire `Album` to the store. Note
    that `connect` is called with two sets of parentheses and that the component is
    passed into the second set, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The first set of parentheses in a call to `connect` takes two function parameters:
    `mapStateToProps` and `mapDispatchToProps`. We''ll define `mapStateToProps` first,
    which takes `state` as a parameter. This `state` is our global Redux state object
    containing all of our data. The function returns an object of the pieces of `state`
    that we want to use in our component. In our case, we just need the `loadedPhotos`
    property from the `photos` reducer. By setting this value to `photos` in the return
    object, we can expect `this.props.photos` to be the value stored in `state.photos.loadedPhotos`.
    And it will change automatically when the Redux store is updated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the `mapDispatchToProps` function will map our action creators to
    the component''s props as well. The function receives the Redux method, `dispatch`,
    which is used to execute an action creator. We''ll map the execution of each action
    creator to a key of the same name, so that `this.props.fetchPhotos()` will execute `dispatch(fetchPhotos())`,
    and so on, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve got our Redux store wired to our component, let''s create the
    component itself. We can make use of the `componentDidMount` life cycle hook to
    fetch our photos, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need a method for adding photos. Here, we''ll use the `randomcolor`
    package (imported as `randomColor` by convention) to create an image with the
    [placehold.it](http://placehold.it) service. The generated color string comes
    back with a hash prefixing the hex value, which the request to the image service
    doesn''t want, so we can simply remove it with a `replace` call. To add the photo,
    we just call the `addPhoto` function mapped to `props`, passing in the new `photo`
    object, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need a `removePhoto` function. All this function needs to do is
    call the `removePhoto` function that has been mapped to `props`, passing in the
    ID of the photo to be removed, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The template for the app will need a `TouchableOpacity` button for adding photos,
    a `ScrollView` for holding all of the images in a scrollable list, and all of
    our images. Each `Image` component will also be wrapped in a `TouchableOpacity`
    component for calling the `removePhoto` method when an image is pressed, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll add styles so that the app has a layout, as follows. There''s
    nothing here we haven''t covered many times before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The app is complete! Clicking on the Add Photo button will add a new photo
    to the beginning of the list of images, and pressing an image will remove it.
    Note, since we are using a dummy data API, the `POST` and `DELETE` requests will
    return proper responses for the given action. However, no data is actually added
    or deleted to the database. This means that the image list will reset if the app
    is refreshed, and that you can expect errors if you attempt to delete any photos
    you''ve just added with the Add Photo button. Feel free to connect this app to
    a real API and database to see the expected results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/46c604eb-1e47-4f34-af62-5854ca99c453.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 4*, we used the `connect` method provided by `react-redux` to empower
    the `Album` component with a connection to the Redux store we've been working
    on this entire chapter. The call to `connect` returns a function that is immediately
    executed via the second set of parentheses. By passing the `Album` component into
    this returning function, `connect` glues the component and the store together.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, we defined the `mapStateToProps` function. The first parameter
    in this function is `state` from the Redux store, which is injected into the function
    by `connect`. Whatever keys are defined in the object returned from `mapStateToProps`
    will be properties on the component's `props`. The value of these props will be
    subscribed to `state` in the Redux store, so that any change affecting these pieces
    of `state` will be automatically updated within the component.
  prefs: []
  type: TYPE_NORMAL
- en: While `mapStateToProps` will map `state` in the Redux store to the component
    props, `mapDispatchToProps` will map the *action creators* to the component props.
    In *step 6*, we defined this function. It has the special Redux method, `dispatch`,
    injected into it for calling action creators that live in the store. `mapDispatchToProps`
    returns an object, mapping the `dispatch` calls for actions to the components
    props at the specified keys.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 7*, we created the `componentDidMount` method. All the component needs
    to do to get the photos it needs while mounting is to call the action creator
    mapped to `this.props.fetchPhotos`. That's all! The `fetchPhotos` action creator
    will be dispatched. The `fetchPhoto` action returned from the action creator will
    be processed by the `redux-promise-middleware` we applied in a previous recipe
    since the `payload` property of this action has a Promise stored on it in the
    form of an `axios` AJAX request. The middleware will intercept the action, process
    the request, and send a new action to the reducers with the resolved data on the `payload`
    property. If it was a successful request, the action with the `FETCH_PHOTOS_FULFILLED`
    type will be dispatched with the resolved data, and if not, the `FETCH_PHOTOS_REJECTED`
    action will be dispatched with the error as `payload`. On success, the case in
    the reducer for handling `FETCH_PHOTOS_FULFILLED` will execute, `loadedPhotos`
    will be updated in the store, and in turn, `this.props.photos` will also be updated.
    Updating the component props will trigger a re-render, and the new data will be
    displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 8* and *step 9*, we followed the same pattern to define `addPhoto`
    and `removePhoto`, which call the action creators of the same name. The action
    produced by the action creators are handled by the middleware, the proper reducer
    handles the resulting action, and if the `state` in the Redux store changes, all
    subscribed props will be automatically updated!
  prefs: []
  type: TYPE_NORMAL
- en: Storing offline content using Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redux is an excellent tool for keeping track of an app's state while it it's
    running. But what if we have data that we need to store without using an API?
    For instance, we could save the state of a component so that when a user closes
    and reopens the app, the previous state of that component can be restored, allowing
    us to persist a piece of an app's persistent across sessions. Redux data persistence
    could also be useful for caching information to avoid calling the API more than
    necessary. You can refer to the *Masking the application upon network connection
    loss* recipe in [Chapter 8](b41f8c20-f817-4b29-992b-18f8bcd6f071.xhtml), *Working
    with Application Logic and Data*, for more information on how to detect and handle
    network connectivity status.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe depends on the previous ones, so make sure to follow along with
    all of the previous recipes. In this recipe, we''ll be using the `redux-persist`
    package to persist the data in our app''s Redux store. Install it with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can install it with `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by adding the dependencies we''ll need in `redux/index.js`. The `storage`
    method we''re importing from `redux-persist` here will use React Native''s `AsyncStorage`
    method to store Redux data between sessions, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll be using a simple `config` object for configuring our `redux-persist`
    instance. `config` requires a `key` property for the key used to store the data
    with `AsyncStore` and a storage property that takes the `storage` instance, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use the `persistReducer` method we imported in *step 1*. This method
    takes the `config` object we created in *step 2 *as the first argument and our
    reducers as the second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s update our store to use the new `persistedReducer` method. Also
    note how we no longer export `store` as the default export, since we''ll need
    two exports from this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The second export we need from this file is `persistor`. `persistor` will work
    to persist the Redux store between sessions. We can create `persistor` by calling
    the `persistStore` method and passing in `store`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve got both `store` and `persistor` as exports from `redux/index.js`,
    we''re ready to apply them in `App.js`. We''ll start by importing them, and we''ll
    import the `PersistGate` component from `redux-persist`. `PersistGate` will ensure
    that our cached Redux store is loaded before any components are loaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s update the `App` component to use `PersistGate`. The component takes
    two props: the imported `persistor` prop and a `loading` prop. We''ll be passing `null`
    to the `loading` prop, but if we had a loading indicator component, we could pass
    this in, and `PersistGate` would display this loading indicator as data is restored,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to test the persistence of our Redux store, let''s adjust the `componentDidMount`
    method in the `Album` component. We''ll delay the call to `fetchPhotos` for two
    seconds, so that we can see the saved data before it is fetched again from the
    API, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Depending on what kind of data you're persisting, this kind of functionality
    could be applied to a number of situations, including persisting user data and
    app state, even after the app's been closed. It can also be used to improve the
    offline experience of an app, caching API requests if they can't be made right
    away and providing users with data filled views.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 2*, we created the config object for configuring `redux-persist`. The
    object is only required to have the `key` and `store` properties, but also supports
    quite a few others. You can see all of the options this config takes via the type
    definition hosted here: [https://github.com/rt2zz/redux-persist/blob/master/src/types.js#L13-L27](https://github.com/rt2zz/redux-persist/blob/master/src/types.js#L13-L27).
  prefs: []
  type: TYPE_NORMAL
- en: In *step 7*, we used the `PersistGate` component, which is how the documentation
    recommends delaying rendering until restoring persisted data is complete. If we
    have a loading indicator component, we can pass it to the `loading` prop for being
    displayed while data is restored.
  prefs: []
  type: TYPE_NORMAL
