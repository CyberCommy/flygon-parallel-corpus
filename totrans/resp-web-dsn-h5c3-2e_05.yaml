- en: Chapter 5. CSS3 – Selectors, Typography, Color Modes, and New Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last few years, CSS has enjoyed a raft of new features. Some enable us
    to animate and transform elements, others allow us to create background images,
    gradients, mask and filter effects, and others still allow us to bring SVG elements
    to life.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will get to all those capabilities in the next few chapters. Firstly I think
    it will be useful to look at some of the fundamentals that have changed in CSS
    in the last few years: how we select elements on the page, the units we can use
    to style and size our elements, and how existing (and future) pseudo-classes and
    pseudo-elements make CSS ever more powerful. We will also look at how we can create
    forks in our CSS code to facilitate the features supported in different browsers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The anatomy of a CSS rule (what defines a rule, declaration and property, and
    value pairs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick and handy CSS tricks for responsive designs (multiple columns, word wraps,
    truncation/text ellipsis, scrolling areas)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facilitating feature forks in CSS (how to have some rules apply to some browsers
    and other rules apply to others)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use sub-string attribute selectors to select HTML elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What nth-based selectors are and how we can use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What pseudo classes and pseudo elements are (`:empty`, `::before`, `::after`,
    `:target`, `:scope`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new selectors in CSS Level 4 Selectors module (`:has`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What CSS variables and custom properties are and how to write them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the CSS `calc` function is and how to use it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making use of viewport related units (`vh`, `vw`, `vmin`, and `vmax`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make use of web typography with `@font-face`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RGB and HSL color modes with Alpha transparency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No one knows it all
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No one can know everything. I've been working with CSS for over a decade and
    on a weekly basis I still discover something new in CSS (or rediscover something
    I'd forgotten). As such, I don't feel that trying to know every possible CSS property
    and value permutation is actually a worthy pursuit. Instead, I think it's more
    sensible to develop a good grasp of what's possible.
  prefs: []
  type: TYPE_NORMAL
- en: As such, we are going to concentrate in this chapter on some of the techniques,
    units, and selectors I have found most useful when building responsive web designs.
    I'm hoping you'll then have the requisite knowledge to solve most problems that
    come your way when developing a responsive web design.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a CSS rule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before exploring some of what CSS3 has to offer, to prevent confusion, let''s
    establish the terminology we use to describe a CSS rule. Consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This rule is made up of the selector (`.round`) and then the declaration (`border-radius:
    10px;`). The declaration is further defined by the property (`border-radius:`)
    and the value (`10px;`). Happy we''re on the same page? Great, let''s press on.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Remember to check support for your users**'
  prefs: []
  type: TYPE_NORMAL
- en: As we delve into CSS3 more and more, don't forget to visit [http://caniuse.com/](http://caniuse.com/),
    if you ever want to know what the current level of browser support is available
    for a particular CSS3 or HTML5 feature. Alongside showing browser version support
    (searchable by feature), it also provides the most recent set of global usage
    statistics from [http://gs.statcounter.com/](http://gs.statcounter.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Quick and useful CSS tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In my day-to-day work, I've found I use some CSS3 features constantly and others
    hardly ever. I thought it might be useful to share those I've used most often.
    These are CSS3 goodies that can make life easier, especially in responsive designs.
    They solve problems that used to be minor headaches with relative ease.
  prefs: []
  type: TYPE_NORMAL
- en: CSS multi-column layouts for responsive designs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ever needed to make a single piece of text appear in multiple columns? You
    could solve the problem by splitting the content into different markup elements
    and then styling accordingly. However, altering markup for purely stylistic purposes
    is never ideal. The CSS multi-column layout specification describes how we can
    span one or more pieces of content across multiple columns with ease. Consider
    the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With CSS multi-columns you can make all that content flow across multiple columns
    in a number of ways. You could make the columns a certain column width (for example,
    12em) or instead you could specify that the content needs to span a certain number
    of columns (for example, 3).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the code needed to achieve each of those scenarios. For columns
    of a set width, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will mean, no matter the viewport size, the content will span across columns
    that are 12em in width. Altering the viewport will adjust the number of columns
    displayed dynamically. You can view this in the browser by looking at `example_05-01`
    (or at the GitHub repository: [https://github.com/benfrain/rwd](https://github.com/benfrain/rwd)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider how the page renders on an iPad in portrait orientation (768px wide
    viewport):'
  prefs: []
  type: TYPE_NORMAL
- en: '![CSS multi-column layouts for responsive designs](img/3777_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And then on Chrome in the desktop (approximately 1100px wide viewport):'
  prefs: []
  type: TYPE_NORMAL
- en: '![CSS multi-column layouts for responsive designs](img/3777_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Simple responsive text columns with minimum work; I like it!
  prefs: []
  type: TYPE_NORMAL
- en: Fixed columns, variable width
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you''d rather keep a fixed number of columns and vary the width, you can
    write a rule like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Adding a gap and column divider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can take things even further by adding a specified gap for the columns and
    a divider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us a result like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a gap and column divider](img/3777_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To read the specification on the CSS3 Multi-column Layout Module, visit [http://www.w3.org/TR/css3-multicol/](http://www.w3.org/TR/css3-multicol/).
  prefs: []
  type: TYPE_NORMAL
- en: For the time being, despite being at CR status at the W3C, you'll likely still
    need vendor prefixes on the column declarations for maximum compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: The only caveat I would place on using CSS multi-column is that for longer spans
    of text it can lead to a flawed user experience. In these instances the user will
    have to scroll up and down the page to read the columns of text, which can become
    a little laborious.
  prefs: []
  type: TYPE_NORMAL
- en: Word wrapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How many times have you had to add a big URL into a tiny space and, well, despaired?
    Take a look at [http://rwd.education/code/example_05-04](http://rwd.education/code/example_05-04).
    The problem can also be seen in the following screenshot; notice that the URL
    is breaking out of its allocated space.
  prefs: []
  type: TYPE_NORMAL
- en: '![Word wrapping](img/3777_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s easy to fix this issue with a simple CSS3 declaration, which as chance
    would have it, also works in older versions of Internet Explorer as far back as
    5.5! Just add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: to the containing element, which gives an effect as shown in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Word wrapping](img/3777_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hey presto, the long URL now wraps perfectly!
  prefs: []
  type: TYPE_NORMAL
- en: Text ellipsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Text truncation used to be the sole domain of server side technology. Nowadays
    we can do text ellipsis/truncation with CSS alone. Let's consider how.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this markup (you can view this example online at `rwd.education/code/ch5/example_05-03/`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'But we actually want to truncate the text at 520px wide. So it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text ellipsis](img/3777_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the CSS to make that happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the specification for the `text-overflow` property at [http://dev.w3.org/csswg/css-ui-3/](http://dev.w3.org/csswg/css-ui-3/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever the width of the content exceeds the width defined (the width can
    just as happily be set as a percentage such as 100% if it''s inside a flexible
    container) it will be truncated. The `white-space: no-wrap` property/value pair
    is used to ensure that the content doesn''t wrap inside the surrounding element.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating horizontal scrolling panels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hopefully you know the kind of thing I mean? Horizontal scrolling panels are
    common on the iTunes store and Apple TV for showing panels of related content
    (movies, albums, and so on). Where there is enough horizontal space, all the items
    are viewable. When space is limited (think mobile devices) the panel is scrollable
    from side to side.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scrolling panels work particularly well on modern Android and iOS devices.
    If you have a modern iOS or Android device to hand, take a look at this next example
    on that, alongside a desktop browser like Safari or Chrome: [http://rwd.education/code/ch5/example_05-02/](http://rwd.education/code/ch5/example_05-02/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ve created a scrolling panel of the top-grossing films of 2014\. It looks
    something like this on an iPhone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating horizontal scrolling panels](img/3777_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I'm actually cheating a little. The key to this technique is the `white-space`
    property, which has actually been around since CSS 2.1 ([http://www.w3.org/TR/CSS2/text.html](http://www.w3.org/TR/CSS2/text.html)).
    However, I'm going to use it alongside the new Flexbox layout mechanism, so hopefully
    you'll indulge me regardless?
  prefs: []
  type: TYPE_NORMAL
- en: To get the basics of this technique working we just need a wrapper narrower
    than the sum of its contents and to set it's width to auto in the *x* axis. This
    way, it won't scroll if there is enough space but it will if there isn't.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'By using `white-space: nowrap` we are saying ''do not wrap these elements when
    you find white space''. Then to keep everything in a single line, we set all the
    first children of that container to display inline. We''re using `inline-flex`
    here but it could just as easily be inline, `inline-block`, or `inline-table`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**::before and ::after pseudo-elements**'
  prefs: []
  type: TYPE_NORMAL
- en: If viewing the sample code you will notice that the `::before` pseudo element
    is used to display the number of the item. If using pseudo-elements, remember
    that for `::before` or `::after` to display, they must have a content value, even
    if just whitespace. When these pseudo-elements are displayed, they then behave
    like the first and last child of that element respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things a little more aesthetically pleasing I''m going to hide the
    scroll bar where I can. Unfortunately these are browser specific so you will need
    to add these by hand (an Autoprefixer tool won''t add them as they are proprietary
    properties). I''m also going to add touch style inertia scrolling for WebKit browsers
    (typically iOS devices). Now the updated `.Scroll_Wrapper` rule looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Where space is limited, we get a nice scrollable horizontal panel. Otherwise,
    the content just fits.
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, a couple of caveats to this pattern. Firstly, at the time
    of writing, Firefox has no property that allows you to hide the scroll bars. Secondly,
    older Android devices can't perform horizontal scrolling (no, really). I therefore
    tend to qualify this pattern with the help of feature detection. We'll look at
    how that works next.
  prefs: []
  type: TYPE_NORMAL
- en: Facilitating feature forks in CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you're building out a responsive web design, attempting to provide a single
    design that works everywhere, on every device, it's a simple fact that you'll
    frequently encounter situations when features or techniques are not supported
    on certain devices. In these instances you'll likely want to create a fork in
    your CSS; if the browser supports a feature, provide one chunk of code, if they
    don't, they get different code. It's the kind of situation that gets handled by
    `if/else` or `switch` statements in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: We currently have two possible approaches. One is entirely CSS based but with
    fewer browser implementations, and the other is only made possible with the help
    of a JavaScript library but enjoys far broader support. Let's consider each in
    turn.
  prefs: []
  type: TYPE_NORMAL
- en: Feature queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The native solution to forking code in CSS is to use 'Feature Queries', part
    of the CSS Conditional Rules Module Level 3 ([http://www.w3.org/TR/css3-conditional/](http://www.w3.org/TR/css3-conditional/)).
    However, right now, CSS Conditional Rules lack support in Internet Explorer (as
    of version 11) and Safari (including iOS devices up to iOS 8.1) so support is
    hardly ubiquitous.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature queries follow a similar syntax to media queries. Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here the styles will only get applied if the browser supports the `flashing-sausages`
    property. I'm quite confident that no browser is ever going to support a `flashing-sausages`
    feature (and if they do, I want full credit) so none of the styles inside the
    `@supports` block will be applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a more practical example. How about we use Flexbox for when
    browsers support it, and fallback to another layout technique when they don''t.
    Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here we are defining one block of code for when the browser supports a feature,
    and another lot for when it doesn't. This pattern is fine if the browser supports
    `@supports` (yes, I realise that is confusing) but if it doesn't, it won't apply
    any of those styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to cover off devices that don''t support `@supports`, you''re better
    off writing your default declarations first and then your `@supports` specific
    one after, so that the prior rule will be overruled if support for `@support`
    exists, and the `@support` block will be ignored if the browser doesn''t support
    it. Our prior example could therefore be reworked to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Combining conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also combine conditionals. Let''s suppose we only wanted to apply some
    rules if both Flexbox and `pointer: coarse` were supported (in case you missed
    it, we covered the ''pointer'' interaction media feature back in [Chapter 2](ch02.html
    "Chapter 2. Media Queries – Supporting Differing Viewports"), *Media Queries –
    Supporting Differing Viewports*). Here is what that might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have used the `and` keyword but we could use `or` as well as, or instead
    of it. For example, if we were happy to apply styles if those two prior property/value
    combinations were supported, or 3D transforms were supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note in that prior example, the extra set of parenthesis that separates the
    flex and pointer conditional from the transform conditional.
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, as I already mentioned, support for `@support` is far from universal.
    Boohoo! What's a responsive web designer to do? Fear not, there's a great JavaScript
    tool that is more than capable of rising to this challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Modernizr
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until `@supports` is more widely implemented in browsers, we can use a JavaScript
    tool called Modernizr. At present, it's simply the most robust manner in which
    to facilitate forks in your code.
  prefs: []
  type: TYPE_NORMAL
- en: When forks are needed in CSS, I try and adopt a progressive enhancement approach.
    Progressive enhancement means starting with simple accessible code; code that
    will provide, at the very least, a functional design for less capable devices.
    Then that code is progressively enhanced for more capable devices.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll talk a lot more about progressive enhancement in [Chapter 10](ch10.html
    "Chapter 10. Approaching a Responsive Web Design"), *Approaching a Responsive
    Web Design*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look how we can facilitate progressive enhancement and forking our CSS
    code with Modernizr.
  prefs: []
  type: TYPE_NORMAL
- en: Feature detection with Modernizr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you''re a web developer, it''s likely you have heard of Modernizr, even
    if you have perhaps not used it. It''s a JavaScript library that you include in
    your page that feature tests the browser. To start using Modernizr, it''s as simple
    as including a link to the downloaded file in the `head` section of your pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With that in place, when the browser loads the page, any of the included tests
    are run. If the browser passes the test, Modernizr handily (for our purposes)
    adds a relevant class to the root HTML tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, after Mondernizr has done its thing, the classes on the HTML tag
    for a page might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In that instance just a few features have been tested: animations, transforms,
    SVG, inline SVG, and support for touch. With those classes in place, the code
    can be forked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the widget item is just 1rem high ordinarily, but
    if the touch class is present on the HTML (thanks to Modernizr), then the widget
    would be 2rem high.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could flip the logic too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This way we would default to the item being 2rem high, and adjust down if the
    `no-touch` class was present.
  prefs: []
  type: TYPE_NORMAL
- en: Whichever way you want to structure things, Modernizr provides a widely supported
    way to fork features. You'll find it especially useful when you want to use features
    like `transform3d` but still provide a working substitute for browsers that can't
    make use of it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modernizr can provide accurate tests for most things you'll likely need to fork
    code on, but not all. For example, overflow-scrolling is notoriously difficult
    to accurately test for. In situations where a class of devices isn't playing happily,
    it may make more sense to fork your code on a different feature. For example,
    as older Android versions have difficulty with horizontal scrolling you might
    fork with `no-svg` (as Android 2-2.3 doesn't support SVG either).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you may wish to combine tests to make your own custom test. That's
    a little outside the scope here but if that's something that interests you, take
    a look at [http://benfrain.com/combining-modernizr-tests-create-custom-convenience-forks/](http://benfrain.com/combining-modernizr-tests-create-custom-convenience-forks/).
  prefs: []
  type: TYPE_NORMAL
- en: New CSS3 selectors and how to use them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSS3 gives incredible power for selecting elements within a page. You may not
    think this sounds very glitzy but trust me, it will make your life easier and
    you'll love CSS3 for it! I'd better qualify that bold claim.
  prefs: []
  type: TYPE_NORMAL
- en: CSS3 attribute selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You''ve probably used CSS attribute selectors to create rules. For example,
    consider the following rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This would target any image tags in the markup which have an `alt` attribute.
    Or, let''s say we wanted to select all elements with a `data-sausage` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: All you need is to specify the attribute in squared brackets.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `data-*` type attribute was introduced in HTML5 to provide a place for custom
    data that can't be stored sensibly by any other existing mechanism. The specification
    description for these can be found at [http://www.w3.org/TR/2010/WD-html5-20101019/elements.html](http://www.w3.org/TR/2010/WD-html5-20101019/elements.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also narrow things down by specifying what the attribute value is.
    For example, consider the following rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This would only target images which have an `alt` attribute of `sausages`.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So far, so 'big deal we could do that in CSS2'. What does CSS3 bring to the
    party?
  prefs: []
  type: TYPE_NORMAL
- en: CSS3 substring matching attribute selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CSS3 lets us select elements based upon the substring of their attribute selector.
    That sounds complicated. It isn''t! The three options are whether the attribute
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with the prefix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contains an instance of
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ends with the suffix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see what they look like.
  prefs: []
  type: TYPE_NORMAL
- en: The 'beginning with' substring matching attribute selector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the ''beginning with'' substring matching attribute selector to
    select both of those images like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The key character in all this is the `^` symbol (the symbol is called the **caret**,
    although it is often referred to as the 'hat' symbol too) which means "begins
    with". Because both `alt` tags begin with `film` our selector selects them.
  prefs: []
  type: TYPE_NORMAL
- en: The 'contains an instance of' substring matching attribute selector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ''contains an instance of'' substring matching attribute selector has the
    following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Like all attribute selectors, you can combine them with a type selector (one
    that references the actual HTML element used) if needed, although personally I
    would only do that if I had to (in case you want to change the type of element
    used).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try an example. Consider this markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The key character in all this is the `*` symbol that in this context means "contains".
  prefs: []
  type: TYPE_NORMAL
- en: The 'begins with' selector would not have worked in with this markup as the
    string inside the attribute didn't *begin with* 'cream'. It did however *contain*
    'cream' so the 'contains an instance of' substring attribute selector finds it.
  prefs: []
  type: TYPE_NORMAL
- en: The 'ends with' substring matching attribute selector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The "ends with" substring matching attribute selector has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'An example should help. Consider this markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Suppose we only want to select the element with scones, cream, and jam in the
    `data-ingredients` attribute (the first element). We can't use the 'contains an
    instance of' (it will select all three) or 'begins with' (it will only select
    the last one) substring attribute selector. However, we can use the 'ends with'
    substring attribute selector.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The key character in all this is the `$` (dollar) symbol which means "ends with".
  prefs: []
  type: TYPE_NORMAL
- en: Gotchas with attribute selection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a ''gotcha'' with attribute selection that''s it''s important to grasp:
    attributes are seen as a single string. Consider this CSS rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'It might surprise you to know that it would not select this, even though one
    of the words inside the attribute begins with `film`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: That's because the `data-film` attribute here doesn't begin with `film`, in
    this case it begins with awful (and if you've seen *Moulin Rouge* you'll know
    that it begins awfully too—and never improves).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of ways around this, in addition to the substring matching
    selectors we looked at a moment ago. You could use the whitespace separated selector
    (note the tilde symbol), which has support all the way back to Internet Explorer
    7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You could select the entire attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you only wanted to select based upon the presence of a couple of strings
    inside an attribute, you could join a couple (or as many as were needed) of ''contains
    an instance of'' substring attribute selectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There's no 'right' thing to do, it really just depends on the complexity of
    the string you are trying to select.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute selectors allow you to select IDs and classes that start with numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before HTML5, it wasn't valid markup to start IDs or class names with a number.
    HTML5 removes that restriction. When it comes to IDs, there are still some things
    to remember. There should be no spaces in the ID name and it must be unique on
    the page. For more information visit [http://www.w3.org/html/wg/drafts/html/master/dom.html](http://www.w3.org/html/wg/drafts/html/master/dom.html).
  prefs: []
  type: TYPE_NORMAL
- en: Now, although you can start ID and class values with numbers in HTML5, CSS still
    restricts you from using ID and class selectors that start with a number ([http://www.w3.org/TR/CSS21/syndata.html](http://www.w3.org/TR/CSS21/syndata.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Lucky for us, we can easily workaround this by using an attribute selector.
    For example, `[id="10"]`.
  prefs: []
  type: TYPE_NORMAL
- en: CSS3 structural pseudo-classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSS3 gives us more power to select elements based upon where they sit in the
    structure of the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a common design treatment; we're working on the navigation bar
    for a larger viewport and we want to have all but the last link over on the left.
  prefs: []
  type: TYPE_NORMAL
- en: 'Historically, we would have needed to solve this problem by adding a class
    name to the last link so that we could select it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This in itself can be problematic. For example, sometimes, just getting a content
    management system to add a class to a final list item can be frustratingly difficult.
    Thankfully, in those eventualities, it's no longer a concern. We can solve this
    problem and many more with CSS3 structural pseudo-classes.
  prefs: []
  type: TYPE_NORMAL
- en: The :last-child selector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CSS 2.1 already had a selector applicable for the first item in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'However, CSS3 adds a selector that can also match the last:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look how that selector could fix our prior problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also useful selectors for when something is the only item: `:only-child`
    and the only item of a type: `:only-of-type`.'
  prefs: []
  type: TYPE_NORMAL
- en: The nth-child selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `nth-child` selectors let us solve even more difficult problems. With the
    same markup as before, let's consider how nth-child selectors allow us to select
    any link(s) within the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, what about selecting every other list item? We could select the odd
    ones like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you wanted to select the even ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Understanding what nth rules do
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the uninitiated, nth-based selectors can look pretty intimidating. However,
    once you've mastered the logic and syntax you'll be amazed what you can do with
    them. Let's take a look.
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS3 gives us incredible flexibility with a few nth-based rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nth-child(n)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nth-last-child(n)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nth-of-type(n)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nth-last-of-type(n)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ve seen that we can use (odd) or (even) values already in an nth-based
    expression but the (n) parameter can be used in another couple of ways:'
  prefs: []
  type: TYPE_NORMAL
- en: As an integer; for example, `:nth-child(2)` would select the second item
  prefs: []
  type: TYPE_NORMAL
- en: As a numeric expression; for example, `:nth-child(3n+1)` would start at 1 and
    then select every third element
  prefs: []
  type: TYPE_NORMAL
- en: The integer based property is easy enough to understand, just enter the element
    number you want to select.
  prefs: []
  type: TYPE_NORMAL
- en: The numeric expression version of the selector is the part that can be a little
    baffling for mere mortals. If math is easy for you, I apologize for this next
    section. For everyone else, let's break it down.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down the math
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s consider 10 spans on a page (you can play about with these by looking
    at `example_05-05`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'By default they will be styled like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As you might imagine, this gives us 10 squares in a line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Breaking down the math](img/3777_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: OK, let's look at how we can select different ones with nth-based selections.
  prefs: []
  type: TYPE_NORMAL
- en: 'For practicality, when considering the expression within the parenthesis, I
    start from the right. So, for example, if I want to figure out what (2n+3) will
    select, I start with the right-most number (the three here indicates the third
    item from the left) and know it will select every second element from that point
    on. So adding this rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Results in this in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Breaking down the math](img/3777_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, our nth selector targets the third list item and then every
    subsequent second one after that too (if there were 100 list items, it would continue
    selecting every second one).
  prefs: []
  type: TYPE_NORMAL
- en: How about selecting everything from the second item onwards? Well, although
    you could write `:nth-child(1n+2)`, you don't actually need the first number 1
    as unless otherwise stated, n is equal to 1\. We can therefore just write `:nth-child(n+2)`.
    Likewise, if we wanted to select every third element, rather than write `:nth-child(3n+3)`,
    we can just write `:nth-child(3n)` as every third item would begin at the third
    item anyway, without needing to explicitly state it. The expression can also use
    negative numbers, for example, `:nth-child(3n-2)` starts at -2 and then selects
    every third item.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also change the direction. By default, once the first part of the selection
    is found, the subsequent ones go down the elements in the DOM (and therefore from
    left to right in our example). However, you can reverse that with a minus. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This example finds the third item again, but then goes in the opposite direction
    to select every two elements (up the DOM tree and therefore from right to left
    in our example):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Breaking down the math](img/3777_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hopefully, the nth-based expressions are making perfect sense now?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `nth-child` and `nth-last-child` differ in that the `nth-last-child` variant
    works from the opposite end of the document tree. For example, `:nth-last-child(-n+3)`
    starts at 3 from the end and then selects all the items after it. Here''s what
    that rule gives us in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Breaking down the math](img/3777_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, let''s consider `:nth-of-type` and `:nth-last-of-type`. While the
    previous examples count any children regardless of type (always remember the `nth-child`
    selector targets all children at the same DOM level, regardless of classes), `:nth-of-type`
    and `:nth-last-of-type` let you be specific about the type of item you want to
    select. Consider the following markup (`example_05-06`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If we used the selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though all the elements have the same `span-class`, we will only actually
    be targeting the `span` elements (as they are the first type selected). Here is
    what gets selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Breaking down the math](img/3777_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will see how CSS4 selectors can solve this issue shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**CSS3 doesn''t count like JavaScript and jQuery!**'
  prefs: []
  type: TYPE_NORMAL
- en: If you're used to using JavaScript and jQuery you'll know that it counts from
    0 upwards (zero index based). For example, if selecting an element in JavaScript
    or jQuery, an integer value of 1 would actually be the second element. CSS3 however,
    starts at 1 so that a value of 1 is the first item it matches.
  prefs: []
  type: TYPE_NORMAL
- en: nth-based selection in responsive web designs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just to close out this little section I want to illustrate a real life responsive
    web design problem and how we can use nth-based selection to solve it.
  prefs: []
  type: TYPE_NORMAL
- en: Remember the horizontal scrolling panel from `example_05-02`? Let's consider
    how that might look in a situation where horizontal scrolling isn't possible.
    So, using the same markup, let's turn the top 10 grossing films of 2014 into a
    grid. For some viewports the grid will only be two items wide, as the viewport
    increases we show three items and at larger sizes still we show four. Here is
    the problem though. Regardless of the viewport size, we want to prevent any items
    on the bottom row having a border on the bottom. You can view this code at `example_05-09`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how it looks with four items wide:'
  prefs: []
  type: TYPE_NORMAL
- en: '![nth-based selection in responsive web designs](img/3777_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See that pesky border below the bottom two items? That's what we need to remove.
    However, I want a robust solution so that if there were another item on the bottom
    row, the border would also be removed on that too. Now, because there are a different
    number of items on each row at different viewports, we will also need to change
    the nth-based selection at different viewports. For the sake of brevity, I'll
    show you the selection that matches four items per row (the larger of the viewports).
    You can view the code sample to see the amended selection at the different viewports.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You'll notice here that we are chaining the nth-based pseudo-class selectors.
    It's important to understand that the first doesn't filter the selection for the
    next, rather the element has to match each of the selections. For our preceding
    example, the first element has to be the first item of four and also be one of
    the last four.
  prefs: []
  type: TYPE_NORMAL
- en: Nice! Thanks to nth-based selections we have a defensive set of rules to remove
    the bottom border regardless of the viewport size or number of items we are showing.
  prefs: []
  type: TYPE_NORMAL
- en: '![nth-based selection in responsive web designs](img/3777_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The negation (:not) selector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another handy selector is the negation pseudo-class selector. This is used
    to select everything that isn''t something else. Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'And then these styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Our final rule will make every element with a class of `.a-div` orange and round,
    with the exception the `div` that also has the `.not-me` class. You can find that
    code in the `example_05-07` folder of the code samples (remember, you can grab
    them all at [http://rwd.education/](http://rwd.education/)).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far we have looked primarily at what's known as structural pseudo-classes
    (full information on this is available at [http://www.w3.org/TR/selectors/](http://www.w3.org/TR/selectors/)).
    However, CSS3 has many more selectors. If you're working on a web application,
    it's worth looking at the full list of UI element states pseudo-classes ([http://www.w3.org/TR/selectors/](http://www.w3.org/TR/selectors/)),
    as they can, for example, help you target rules based on whether something is
    selected or not.
  prefs: []
  type: TYPE_NORMAL
- en: The empty (:empty) selector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I''ve encountered situations where I have an element that includes some padding
    on the inside and gets content dynamically inserted. Sometimes it gets content,
    sometimes it doesn''t. The trouble is, when it doesn''t include content, I still
    see the padding. Consider the HTML and CSS in `example_05-08`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Without anything content in that `div` I still see the `background-color`.
    Thankfully, we can easily hide it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'However, just be careful with the `:empty` selector. For example, you might
    think this is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: It isn't! Look at the whitespace in there. Whitespace is not no space!
  prefs: []
  type: TYPE_NORMAL
- en: 'However, just to confuse matters, be aware that a comment doesn''t affect whether
    an element has whitespace or not. For example, this is still considered empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Amendments to pseudo-elements**'
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo-elements have been around since CSS2 but the CSS3 specification revises
    the syntax of their use very slightly. To refresh your memory, until now, `p:first-line`
    would target the first line in a `<p>` tag. Or `p:first-letter` would target the
    first letter. Well, CSS3 asks us to separate these pseudo-elements with a double
    colon to differentiate them from pseudo-classes (such as `nth-child()`). Therefore,
    we should write `p::first-letter` instead. Note, however, that Internet Explorer
    8 and lower versions don't understand the double colon syntax, they only understand
    the single colon syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Do something with the :first-line regardless of viewport
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One thing that you may find particularly handy about the `:first-line` pseudo-element
    is that it is specific to the viewport. For example, if we write the following
    rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As you might expect, the first line is rendered in an awful shade of pink. However,
    on a different viewport, it renders a different selection of text.
  prefs: []
  type: TYPE_NORMAL
- en: So, without needing to alter the markup, with a responsive design, there's a
    handy way of having the first visual line of text (as the browser renders it,
    not as it appears in the markup) appear differently than the others.
  prefs: []
  type: TYPE_NORMAL
- en: CSS custom properties and variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks to the popularity of CSS pre-processors, CSS is starting to gain some
    more 'programmatic' features. The first of which is custom properties. They are
    more often referred to as variables although that is not necessarily their only
    use case. You can find the full specification at [http://dev.w3.org/csswg/css-variables/](http://dev.w3.org/csswg/css-variables/).
    Be warned, as of early 2015, browser implementations are few and far between (only
    Firefox).
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS custom properties allow us to store information in our style sheets that
    can then be utilized in that style sheet or perhaps acted upon with JavaScript.
    An obvious use case would be to store a font-family name and then reference it.
    Here is how we create a custom property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the `:root` pseudo-class to store the custom property in
    the document root (although you can store them inside any rule you like).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `:root` pseudo-class always references the top-most parent element in a
    document structure. In an HTML document this would always be the HTML tag but
    for an SVG document (we look at SVG in [Chapter 7](ch07.html "Chapter 7. Using
    SVGs for Resolution Independence"), *Using SVGs for Resolution Independence*),
    it would reference a different element.
  prefs: []
  type: TYPE_NORMAL
- en: A custom property always begins with two dashes, then the custom name, and then
    its end, signified like every other property in CSS; with a colon.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reference that value with the `var()` notation. Like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: You could obviously store as many custom properties as you need in this manner.
    The main benefit of this approach is that you can change the value inside the
    variable and every rule that makes use of the variable gets the new value without
    having to amend them directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s envisaged that in future these properties might be parsed and utilized
    by JavaScript. For more on that kind of craziness, you might be interested in
    the new CSS Extensions module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://dev.w3.org/csswg/css-extensions/](http://dev.w3.org/csswg/css-extensions/)'
  prefs: []
  type: TYPE_NORMAL
- en: CSS calc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How many times have you been trying to code out a layout and thought something
    like, "it needs to half the width of the parent element minus exactly 10px"? This
    is particularly useful with responsive web design, as we never know the size of
    the screen that will be viewing our web pages. Thankfully CSS now has a way to
    do this. It''s called the `calc()` function. Here''s that example in CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Addition, subtraction, division, and multiplication are supported so it's possible
    to solve a bunch of problems that have been impossible without JavaScript in the
    past.
  prefs: []
  type: TYPE_NORMAL
- en: Browser support is quite good, but a notable exception is Android 4.3 and below.
    Read the specification at [http://www.w3.org/TR/css3-values/](http://www.w3.org/TR/css3-values/).
  prefs: []
  type: TYPE_NORMAL
- en: CSS Level 4 selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of new selector types being specified for CSS Selectors Level
    4 (the latest version available was the Editor's Draft dated December 14, 2014,
    ([http://dev.w3.org/csswg/selectors-4/](http://dev.w3.org/csswg/selectors-4/)).
    However, as I write this, there are no implementations of them in browsers. As
    such we will just look at one example as they are liable/probable to change.
  prefs: []
  type: TYPE_NORMAL
- en: The Relational Pseudo-class selector is from the 'Logical Combinations' ([http://dev.w3.org/csswg/selectors-4/](http://dev.w3.org/csswg/selectors-4/))
    section of the latest draft.
  prefs: []
  type: TYPE_NORMAL
- en: The :has pseudo class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This selector takes this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This would add padding to any item `a` tag that contains a `figcaption`. You
    could invert the selection in combination with the negation pseudo class too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This would add the padding if the `a` tag did not contain a `figcaption` element.
  prefs: []
  type: TYPE_NORMAL
- en: I'll be honest and say that right now, there aren't many new selectors in that
    draft that get me excited. But who knows what they'll come up with by the time
    they start being available to use in browsers?
  prefs: []
  type: TYPE_NORMAL
- en: Responsive viewport-percentage lengths (vmax, vmin, vh, vw)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s change tack now. We''ve looked at how we can select items in our responsive
    world. But how about how we size them? The CSS Values and Units Module Level 3
    ([http://www.w3.org/TR/css3-values/](http://www.w3.org/TR/css3-values/)), ushered
    in viewport relative units. These are great for responsive web design as each
    unit is a percentage length of the viewport:'
  prefs: []
  type: TYPE_NORMAL
- en: The vw unit (for viewport width)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: vh unit (for viewport height)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: vmin unit (for viewport minimum; equal to the smaller of either vw or vh)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: vmax (viewport maximum; equal to the larger of either vw or vh)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browser support isn't bad either ([http://caniuse.com/](http://caniuse.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Want a modal window that''s 90% of the browser height? It''s as easy as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As useful as viewport relative units are, some browsers have curious implementations.
    Safari in iOS 8, for example, changes the viewable screen area as you scroll from
    the top of a page (it shrinks the address bar) but doesn't make any changes to
    the reported viewport height.
  prefs: []
  type: TYPE_NORMAL
- en: However, you can perhaps find more utility for these units when coupled with
    fonts. For example, it's now trivially easy to create text that scales in size
    depending upon the viewport.
  prefs: []
  type: TYPE_NORMAL
- en: Now, I could show you that right now. However, I'd like to use a distinct font,
    so that regardless of whether you are viewing the example on a Windows, Mac, or
    Linux box we will all see the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: OK, I'll be honest, this is a cheap ploy to allow me to document how we can
    use web fonts with CSS3.
  prefs: []
  type: TYPE_NORMAL
- en: Web typography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For years the web has had to make do with a boring selection of 'web safe' fonts.
    When some fancy typography was essential for a design, it was necessary to substitute
    a graphical element for it and used a text-indent rule to shift the actual text
    from the viewport. Oh, the joy!
  prefs: []
  type: TYPE_NORMAL
- en: There were also a few inventive methods for adding fancy typography to a page
    along the way. sIFR ([http://www.mikeindustries.com/blog/sifr/](http://www.mikeindustries.com/blog/sifr/))
    and Cufón ([http://cufon.shoqolate.com/generate/](http://cufon.shoqolate.com/generate/))
    used Flash and JavaScript respectively to re-make text elements appear as the
    fonts they were intended to be. Thankfully, CSS3 provides a means of custom web
    typography that is now ready for the big time.
  prefs: []
  type: TYPE_NORMAL
- en: The @font-face CSS rule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `@font-face` CSS rule has been around since CSS2 (but subsequently absent
    in CSS 2.1). It was even supported partially by Internet Explorer 4 (no, really)!
    So what's it doing here, when we're supposed to be talking about CSS3?
  prefs: []
  type: TYPE_NORMAL
- en: Well, as it turns out, `@font-face` was re-introduced for the CSS3 Fonts module
    ([http://www.w3.org/TR/css3-fonts](http://www.w3.org/TR/css3-fonts)). Due to the
    historic legal quagmire of using fonts on the web, it's only in recent years that
    it has started to gain serious traction as the de facto solution for web typography.
  prefs: []
  type: TYPE_NORMAL
- en: Like anything on the web that involves assets, there is no single file format.
    Just as images can come in JPG, PNG, GIF, and other formats, fonts have their
    own set of formats to choose from. The Embedded OpenType (files with an `.eot`
    extension) font was Internet Explorer's (and not anyone else's) preferred choice.
    Others favor the more common TrueType (`.ttf` file extension), whilst there is
    also SVGs and Web Open Font Format (`.woff` / `.woff2` extension).
  prefs: []
  type: TYPE_NORMAL
- en: Right now, it's necessary to serve multiple file versions of the same font to
    cover the different browser implementations.
  prefs: []
  type: TYPE_NORMAL
- en: However, the good news is that adding each custom font format for every browser
    is easy. Let's see how!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing web fonts with @font-face
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CSS provides a `@font-face` 'at-rule' to reference online fonts that can then
    be used to display text.
  prefs: []
  type: TYPE_NORMAL
- en: There are now a number of great sources for viewing and acquiring web fonts;
    both free and paid. My personal favorite for free fonts is Font Squirrel ([http://www.fontsquirrel.com/](http://www.fontsquirrel.com/))
    although Google also offers free web fonts, ultimately served with the `@font-face`
    rule ([http://www.google.com/webfonts](http://www.google.com/webfonts)). There
    are also great, paid services from Typekit ([http://www.typekit.com/](http://www.typekit.com/))
    and Font Deck ([http://www.fontdeck.com/](http://www.fontdeck.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: For this exercise, I'm going to download Roboto. It's the Font used for later
    Android handsets so if you have one of those it will be familiar. Otherwise, all
    you need to know is that it's a lovely interface font designed to be highly legible
    on small screens. You can grab it yourself at [http://www.fontsquirrel.com/fonts/roboto](http://www.fontsquirrel.com/fonts/roboto).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you can download a 'subset' of your font, specific to the language you intend
    to use, do so. It means, the resultant file size will be much smaller as it won't
    contain glyphs for languages you have no intention of using.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having downloaded the `@font-face` kit, a look inside the ZIP file reveals
    folders of the different Roboto fonts. I''m choosing the Roboto Regular version
    and inside that folder the font exists in various file formats (WOFF, TTF, EOT,
    and SVG), plus a `stylesheet.css` file containing a font stack. For example, the
    rule for Roboto Regular looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Much like the way vendor prefixes work, the browser will apply styles from that
    list of properties (with the lower properties, if applicable, taking precedence)
    and ignore ones it doesn't understand. That way, no matter what the browser, there
    should be a font that it can use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, although this block of code is great for fans of copy and paste, it''s
    important to pay attention to the paths the fonts are stored in. For example,
    I tend to copy the fonts from the ZIP file and store them in a folder inventively
    called `fonts` on the same level as my `css` folder. Therefore, as I''m usually
    copying this font stack rule into my main style sheet, I need to amend the paths.
    So, my rule becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s then just a case of setting the correct font and weight (if needed) for
    the relevant style rule. Look at `example_05-10`, it''s the same markup as `example_05-09`,
    we are merely declaring this `font-family` as the default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: An added bonus with web fonts is that, if the composite uses the same fonts
    you are using in the code, you can plug the sizes in direct from the composite
    file. For example, if the font is 24px in Photoshop, we either plug that value
    straight in or convert it to a more flexible unit such as REM (assuming a root
    font-size of 16px, 24 / 16 = 1.5rem).
  prefs: []
  type: TYPE_NORMAL
- en: However, as I mentioned before, we now have viewport relative sizes at our disposal.
    We can use them here to scale the text relative to the amount of viewport space.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: If you open that example in the browser and resize the viewport you will see
    that with just a few lines of CSS we have text that scales to the available space.
    Beautiful!
  prefs: []
  type: TYPE_NORMAL
- en: A note about custom @font-face typography and responsive designs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `@font-face` method of web typography is, on the whole, great. The only
    caveats to be aware of when using the technique with responsive designs are in
    relation to the font file size. By way of an example, if the device rendering
    our example required the SVG font format of Roboto Regular, it would need to fetch
    an extra 34 KB, compared with using the standard web-safe fonts such as Arial.
    We have used an English subset in our example which reduces the file size but
    that isn't always an option. Be sure to check the size of custom fonts and be
    judicious with their use if you want the best possible site performance.
  prefs: []
  type: TYPE_NORMAL
- en: New CSS3 color formats and alpha transparency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we have looked at how CSS3 has given us new powers of
    selection and the ability to add custom typography to our designs. Now, we'll
    look at ways that CSS3 allows us to work with color that were simply not possible
    before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, CSS3 provides two new ways to declare color: RGB and HSL. In addition,
    these two formats enable us to use an alpha channel alongside them (RGBA and HSLA
    respectively).'
  prefs: []
  type: TYPE_NORMAL
- en: RGB color
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Red, Green, and Blue** (**RGB**) is a coloring system that''s been around
    for decades. It works by defining different values for the red, green, and blue
    components of a color. For example, a red color might be defined in CSS as a HEX
    (hexadecimal) value, `#fe0208`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For a great post describing how to understand HEX values more intuitively,
    I can recommend this blog post at Smashing Magazine: [http://www.smashingmagazine.com/2012/10/04/the-code-side-of-color/](http://www.smashingmagazine.com/2012/10/04/the-code-side-of-color/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, with CSS3, that color can equally be described by an RGB value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Most image editing applications show colors as both HEX and RGB values in their
    color picker. The Photoshop color picker, has R, G, and B boxes showing the values
    for each channel. For example, the R value might be 254, the G value 2, and the
    B value 8\. This is easily transferable to the CSS `color` property value. In
    the CSS, after defining the color mode (for example, RGB) the values for red,
    green, and blue colors are comma separated in that order within parenthesis (as
    we have in the previous code).
  prefs: []
  type: TYPE_NORMAL
- en: HSL color
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides RGB, CSS3 also allows us to declare color values as **Hue, Saturation,
    and Lightness** (**HSL**).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**HSL isn''t the same as HSB!**'
  prefs: []
  type: TYPE_NORMAL
- en: Don't make the mistake of thinking that the **Hue, Saturation, and Brightness**
    (**HSB**) value shown in the color picker of image editing applications such as
    Photoshop is the same as HSL—it isn't!
  prefs: []
  type: TYPE_NORMAL
- en: What makes HSL such a joy to use is that it's relatively simple to understand
    the color that will be represented based on the values given. For example, unless
    you're some sort of color picking ninja, I'd wager you couldn't instantly tell
    me what color rgb(255, 51, 204) is? Any takers? No, me neither. However, show
    me the HSL value of hsl(315, 100%, 60%) and I could take a guess that it is somewhere
    between Magenta and Red color (it's actually a festive pink color). How do I know
    this? Simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'HSL works on a 360° degree color wheel. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HSL color](img/3777_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first figure in a HSL color definition represents Hue. Looking at our wheel
    we can see that Yellow is at 60°, Green at 120°, Cyan at 180°, Blue at 240°, Magenta
    at 300°, and finally Red at 360°. So as the aforementioned HSL color had a hue
    of 315, it's easy to know that it will be between Magenta (at 300°) and Red (at
    360°).
  prefs: []
  type: TYPE_NORMAL
- en: The following two values in an HSL definition are for saturation and lightness,
    specified as percentages. These merely alter the base hue. For a more saturated
    or 'colorful' appearance, use a higher percentage in the second value. The final
    value, controlling the Lightness, can vary between 0 percent for black and 100
    percent for white.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, once you''ve defined a color as an HSL value, it''s also easy to create
    variations on it, merely by altering the saturation and lightness percentages.
    For example, our red color can be defined in HSL values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to make a slightly darker color, we could use the same HSL value
    and merely alter the lightness (the final value) percentage value only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In conclusion, if you can remember the mnemonic 'Young Guys Can Be Messy Rascals'
    (or any other mnemonic you care to memorize) for the HSL color wheel, you'll be
    able to approximately write HSL color values without resorting to a color picker,
    and also create variations upon it. Show that trick to the savant Ruby, Node,
    and .NET guys and gals at the office party and earn some quick kudos!
  prefs: []
  type: TYPE_NORMAL
- en: Alpha channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far you'd be forgiven for wondering why on earth we'd bother using HSL or
    RGB instead of our trusty HEX values we've been using for years. Where HSL and
    RGB differ from HEX is that they allow the use of an alpha transparency channel
    so something beneath an element can 'show through'.
  prefs: []
  type: TYPE_NORMAL
- en: 'An HSLA color declaration is similar in syntax to a standard HSL rule. However,
    in addition, you must declare the value as `hsla` (rather than merely `hsl`) and
    add an additional opacity value, given as a decimal value between 0 (completely
    transparent) and 1 (completely opaque). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The RGBA syntax follows the same convention as the HSLA equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Why not just use opacity?**'
  prefs: []
  type: TYPE_NORMAL
- en: CSS3 also allows elements to have opacity set with the opacity declaration.
    A value is set between 0 and 1 in decimal increments (for example, opacity set
    to .1 is 10 percent). However, this differs from RGBA and HSLA in that setting
    an opacity value on an element effects the entire element. Whereas, setting a
    value with HSLA or RGBA meanwhile allows particular parts of an element to have
    an alpha layer. For example, an element could have an HSLA value for the background
    but a solid color for the text within it.
  prefs: []
  type: TYPE_NORMAL
- en: Color manipulation with CSS Color Module Level 4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although in the very early specification stages, it should be possible in the
    not too distant future to enjoy color manipulations in CSS using the `color()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Until there is wide browser support, this kind of thing is best handled by CSS
    pre/post processors (do yourself a favor and buy yourself a book on the subject
    right now; I recommend *Sass and Compass for Designers* by that wonderful chap,
    Ben Frain).
  prefs: []
  type: TYPE_NORMAL
- en: You can follow the progress of the CSS Color Module Level 4 at [http://dev.w3.org/csswg/css-color-4/](http://dev.w3.org/csswg/css-color-4/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've learned how to easily select almost anything we need
    on the page with CSS3's new selectors. We've also looked at how we can make responsive
    columns and scrolling panels for content in record time and solve common and annoying
    problems such as long URL wrapping. We now also have an understanding of CSS3's
    new color module and how we can apply colors with RGB and HSL complete with transparent
    alpha layers for great aesthetic effects.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we've also learned how to add web typography to a design with
    the `@font-face` rule, finally freeing us from the shackles of the humdrum selection
    of web-safe fonts. Despite all these great new features and techniques, we've
    only picked at the surface of what we can do with CSS3\. Let's move on now and
    look at even more ways CSS3 can make a responsive design as fast, efficient, and
    maintainable as possible with CSS3 text shadows, box shadows, gradients, and multiple
    backgrounds.
  prefs: []
  type: TYPE_NORMAL
