- en: '*Chapter 4*: Handling Errors in Your Programs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about **error handling** in C programs in Linux—specifically,
    how to catch errors and print relevant information about them. We will also learn
    how to incorporate this knowledge with what we have previously learned about **stdin**,
    **stdout**, and **stderr**.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue on the path of system calls and learn about a particular variable
    called **errno**. Most system calls use this variable to save specific error values
    when an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors in your programs will make them more stable. Errors do occur;
    it's just a matter of handling them correctly. A well-handled error does not seem
    like an error to the end user. For example, instead of letting your program crash
    in some mysterious way when the hard drive is filled, it's better to catch the
    error and print a human-readable and friendly message about it. That way, it merely
    appears as information to the end user and not an error. That, in turn, will make
    your programs seem friendlier and, most of all, more stable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Why error handling is important in system programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling some common errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling and `errno`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling more `errno` macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `errno` with `strerror()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using errno with `perror()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning an error value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you'll need the GCC compiler, the Make tool, and all the manual
    pages (dev and POSIX) installed. We covered how to install GCC and Make in [*Chapter
    1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)*, Getting the Necessary Tools
    and Writing Our First Linux Programs*, and the manual pages in [*Chapter 3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*,
    Diving Deep into C in Linux*. You will also need the generic Makefile that we
    created in [*Chapter 3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*, Diving
    Deep into C in Linux*. Place that file in the same directory as the code you are
    writing for this chapter. You'll find a copy of that file—along with all other
    source code files we will write here—in the GitHub folder for this chapter, at
    [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch4](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch4).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/39rJIdQ](https://bit.ly/39rJIdQ)'
  prefs: []
  type: TYPE_NORMAL
- en: Why error handling is important in system programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe is a short introduction to what error handling is. We will also
    see an example of a common error: *insufficient access rights*. Knowing these
    basic skills will make you a better programmer in the long run.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll only need the GCC compiler, preferably installed via
    the meta-package or group install, as we covered in [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)*,
    Getting the Necessary Tools and Writing Our First Linux Programs*. Make sure that
    the Makefile mentioned in the *Technical requirements* section is placed in the
    same directory as the source code for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to explore a common error and how to handle it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will write the program without any `simple-touch-v1.c`. The program
    will create an empty file that the user specifies as an argument. The `PATH_MAX`
    macro is new to us. It contains the maximum number of characters we can use in
    a path on our Linux system. It''s defined in the `linux/limits.h` header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try to run the program and see what happens. If we don''t give
    it any arguments, it will print an error message and return `1`. When we give
    it a file that doesn''t exist, it will create it with the permissions 644 (we''ll
    cover permissions in the next chapter):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what happens if we try to create a file outside of our home directory;
    that is, a directory where we don''t have write permissions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This seems to have worked since it didn''t complain—but it hasn''t. Let''s
    try to check out the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s rewrite the file so that it prints an error message—*Couldn''t create
    file*—to stderr in case `creat()` fails to create a file. To accomplish this,
    we wrap the entire call to `creat()` in an `if` statement. Name the new version
    `simple-touch-v2.c`. The changes from the previous version are highlighted here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the new version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s rerun it, both with a file that we can create and one that
    we can''t. When we try to create a file that we don''t have permission to, we
    will get an error message stating *Couldn''t create file*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we used a system call, `creat()`, that creates a file on the
    filesystem. The function takes two arguments: the first is the file to be created,
    while the second is which file access mode the newly created file shall have.
    In this case, we set the file''s `644`, which is read and write for the user who
    owns the file, and read for the owner''s group and all others. We will cover file
    access modes in more depth in [*Chapter 5*](B13043_05_Final_SK_ePub.xhtml#_idTextAnchor182)*,
    Working with File I/O and Filesystem Operations*.'
  prefs: []
  type: TYPE_NORMAL
- en: Nothing "bad" will happen if it can't create the file we ask it to create. It
    just returns -1 to the calling function (`main()` in this case). This means that
    in the first version of our program, it seems like everything has worked just
    fine and that the file has been created when, in fact, it hasn't. It's up to us,
    as programmers, to catch that return code and act on it. We can find the return
    values of the function in its manual page, `man 2 creat`.
  prefs: []
  type: TYPE_NORMAL
- en: In the second version of the program, we added an `if` statement to check for
    -1\. If the function returns -1, an error message is printed to stderr, and 1
    is returned to the shell. We have now informed both the user and any programs
    that might depend on this program to create a file.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching the return values of functions is the most common—and most straightforward—way
    to check for errors. We should all make this a habit. As soon as we use some function,
    we should check its return value (as long as it's reasonable, of course).
  prefs: []
  type: TYPE_NORMAL
- en: Handling some common errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at some common errors we can handle. Knowing what
    errors to look for is step one of mastering error handling. A police officer can't
    catch the bad guys if they don't know which crimes to look for.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at both errors that can occur due to resource limitations on a
    computer, permission errors, and mathematical errors. It's important to remember,
    though, that most functions return a special value (often -1 or some predefined
    value) when errors occur. The actual data is returned when no errors occur.
  prefs: []
  type: TYPE_NORMAL
- en: We will also briefly touch on the subject of handling buffer overflows. Buffer
    overflows are a vast subject that deserves a book of its own, but some short examples
    can help.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we'll write shorter code samples and compile them with GCC and
    Make. We'll also read some man pages from the *POSIX Programmer's Manual*. If
    you are using Debian or Ubuntu, you have to install these manual pages first,
    which we did in the *Getting information about Linux- and Unix-specific header
    files* section of [*Chapter 3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*,
    Diving Deep into C in Linux*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to find errors that are most likely to occur when using a specific
    function is to read the **RETURN VALUE** section of the function''s manual page.
    Here, we will look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Most `creat()`, `open()`, and `write()`. Look under the `errno` with more specific
    information. We will cover `errno` later in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, take a look at the manual page for the power function, `pow()`. Scroll
    down to the `pow()` function returns the answer to a calculation, it can''t return
    0 or -1 if an error occurs; this could be the answer to some calculation. Instead,
    some special numbers are defined that are referred to as `HUGE_VAL`, `HUGE_VALF`,
    and `HUGE_VALL`. On most systems, though, these are defined as infinity. However,
    we can still use these macros to test for them, as shown in the following example.
    Name the file `huge-test.c`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program and test it. Remember to link to the `math` library with
    `-lm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Other errors that can occur that don''t give us return values are mostly overflow
    errors. This is especially true when handling `strcat()` has `strncat()`, `strdup()`
    has `strndup()`, and so on. Use these whenever possible. Write the following program
    and name it `str-unsafe.c`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, compile it using Make (and the Makefile that we have placed in this directory).
    Notice that we will get a warning from the compiler here since we aren''t using
    the `argc` variable. This warning comes from the `-Wextra` option to GCC. However,
    this is just a warning stating that we never used `argc` in our code, so we can
    ignore this message. Always read the warning messages; sometimes, things may be
    more severe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, test this with different input lengths. If we don''t provide any input
    at all or if we give it too much input (more than 9 characters), a segmentation
    fault will occur:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s rewrite the program. First, we must make sure the user typed in an argument;
    second, we must replace `strcat()` with `strncat()`. Name the new version `str-safe.c`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile it. This time, we won''t get a warning about `argc` since we''re using
    it in the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run it with various input lengths. Notice how the long text gets cut
    off at the ninth character, preventing a segmentation fault. Also, note that we
    have handled the segmentation fault on an empty input by requiring precisely one
    argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Step 2*, we looked at some manual pages to get a feel for what kind of errors
    we can expect to handle when dealing with them. Here, we learned that most system
    calls return -1 on errors and that most errors have something to do with either
    permissions or system resources.
  prefs: []
  type: TYPE_NORMAL
- en: In *Steps 2* and *3*, we saw how math functions can return special numbers on
    errors (since the usual numbers—0, 1, and -1—can be valid answers to a calculation).
  prefs: []
  type: TYPE_NORMAL
- en: In *Steps 4* to *9*, we briefly touched on the subject of handling user input
    and `strcat()`, `strcpy()`, and `strdup()` are unsafe since they copy whatever
    they get, even though the destination buffer doesn't have enough space for it.
    When we gave the program a string longer than 10 characters (nine actually, since
    the `NULL` character takes up one place), the program crashed with a *segmentation
    fault*.
  prefs: []
  type: TYPE_NORMAL
- en: These *str* functions have equivalent functions with *n* characters in their
    name; for example, `strncat()`. These functions only copy the size given to them
    as the third argument. In our example, we specified the size as `sizeof(buf)-1`,
    which in our program is 9\. The reason we used one less than the actual size of
    `buf` is to make room for the null-terminating character (`\0`) at the end. It's
    better to use `sizeof(buf)` than to use a literal number. If we would have used
    the literal number 9 here and then changed the size of the buffer to 5, we would
    most likely forget to update the number for `strncat()`.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling and errno
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the system call functions in Linux and other UNIX-like systems set a
    special variable called `errno` variable.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll learn what `errno` is, how to read values from it, and
    when it is set. We'll also see an example use case of `errno`. Learning about
    `errno` is imperative to system programming, primarily since it's used in conjunction
    with system calls.
  prefs: []
  type: TYPE_NORMAL
- en: The next few recipes in this chapter are closely tied to this recipe. In this
    recipe, we'll learn about `errno`; in the following three recipes, we'll learn
    how to interpret the error codes we get from `errno` and print human-readable
    error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You'll need the same components for this recipe that we used in the previous
    one; that is, the GCC compiler, the Make tool, and the *POSIX Programmer's Manual*,
    all of which we have already installed. If not, see [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)*,
    Getting the Necessary Tools and Writing Our First Linux Programs*, and the *Getting
    information about Linux- and UNIX-specific header files* section of [*Chapter
    3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*, Diving Deep into C in Linux*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll continue building on `simple-touch-v2.c` from the first
    recipe in this chapter. Here, we''ll extend it so that it prints some more useful
    information if it can''t create a file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code into a file and save it as `simple-touch-v3.c`. In
    this version, we''ll use the `errno` variable to check if the error is caused
    by a permission error (`EACCES`) or some other, unknown error. The changed code
    has been highlighted here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile this version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s run the new version. This time, the program gives us more information
    about what went wrong. If it''s a permission error, it will tell us that. Otherwise,
    it will print `Unknown error`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first difference we'll notice in this version is that we now include a header
    file called `errno.h`. This file is required if we wish to use the `errno` variable
    and the many error `EACCES`, which we used in our new version.
  prefs: []
  type: TYPE_NORMAL
- en: The next difference is that we now use `sizeof(filename)-1` instead of `PATH_MAX-1`
    for the size argument to `strncpy()`. This was something we learned in the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have the `if (errno == EACCES)` line, which checks the `errno` variable
    for `EACCES`. We can read about these macros, such as `EACCES`, in both `man errno.h`
    and `man 2 creat`. This particular macro means *permission denied*.
  prefs: []
  type: TYPE_NORMAL
- en: When we use `errno`, we should first check the return value from the function
    or system call, as we did here with the `if` statement around `creat()`. The `errno`
    variable is just like any other variable, meaning that it isn't cleared after
    the system call. If we were to check `errno` directly, before checking the function's
    return value, `errno` could contain an error code from a previous error.
  prefs: []
  type: TYPE_NORMAL
- en: In our version of `touch`, we only handle this specific error. Next, we have
    an `else` statement, which catches all other errors and prints an `Unknown error`
    message.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 3*, we generated an `Unknown error` message by trying to create a file
    in a directory that doesn't exist on our system. In the next recipe, we'll extend
    our program so that it can take more macros into account.
  prefs: []
  type: TYPE_NORMAL
- en: Handling more errno macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll continue to handle more `errno` macros in our version of `touch` in this
    recipe. In the previous recipe, we managed to provoke an `Unknown error` message
    since we only handled permission denied errors. Here, we'll find out what exactly
    caused that error and what it is called. We'll then implement another `if` statement
    to handle it. Knowing how to find the correct `errno` macros will help you gain
    a deeper understanding of computing, Linux, system calls, and error handling.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once again, we'll examine the manual pages to find the information we are looking
    for. The only things that are needed for this recipe are the manual pages, the
    GCC compiler, and the Make tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by reading the manual page for `creat()` by using `man 2 creat`. Scroll
    down to the `ENOENT` (short for *Error No Entry*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s implement a new `if` statement that handles `ENOENT`. Name the new version
    `simple-touch-v4.c`. The complete program is as follows. The changes from the
    previous version are highlighted here. Also, note that we have removed the brackets
    for some of the `if` statements in the highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the new version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run it and generate some errors. This time, it will print an error message
    when the directory does not exist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this version, I removed the brackets from the inner `if`, `else if`, and
    `else` statements to save space. This is valid code if there is only one statement
    under each of the `if`, `else if`, and `else`. However, this is potentially dangerous
    since it's easy to make a mistake. If we were to write more statements in one
    of the `if` statements, those would not be a part of the `if` statement, even
    though it looks correct and compiles with no errors. The name for this is *misleading
    indentation*. The indentation fools the brain, thinking it's right.
  prefs: []
  type: TYPE_NORMAL
- en: The next new thing in the code is the `else if (errno == ENOENT)` line and the
    lines below it. This is where we handle the `ENOENT` error macro.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Almost all of the functions listed in `man 2 syscalls` set the `errno` variable.
    Take a look at some of the manual pages for these functions and scroll down to
    `errno` macros the different functions sets.
  prefs: []
  type: TYPE_NORMAL
- en: Also, read `man errno.h`, which contains useful information about these macros.
  prefs: []
  type: TYPE_NORMAL
- en: Using errno with strerror()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of looking up every possible errno macro and figuring out which ones
    apply and what they mean, it's easier to use a function called `strerror()`. This
    function converts the `errno` code into a readable message. Using `strerror()`
    is much faster than implementing everything ourselves. It's a lot safer, too,
    since there's less of a risk that we mess something up. Whenever there's a function
    available to ease the manual work for us, we should use it.
  prefs: []
  type: TYPE_NORMAL
- en: Do note that this function is meant to convert the `errno` macro into a readable
    error message. If we want to handle a particular error in some specific way, we
    still need to use the actual `errno` value.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The requirements from the previous recipe apply to this recipe. This means we
    need the GCC compiler, the Make tool (along with the Makefile), and the manual
    pages.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll continue developing our own version of `touch`. We''ll
    continue from the previous version. This time, we will rewrite the `if` statements
    we made for the different macros and use `strerror()` instead. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code and save it as `simple-touch-v5.c`. Notice how the
    code has been smaller now that we have replaced the `if` statements with `strerror()`.
    This version is much cleaner. The changes from the previous version are highlighted
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile this new version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try it out. Notice how the program now prints error messages describing
    what has gone wrong. We didn''t even have to check the `errno` variable against
    possible errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'All the `if`, `else if`, and `else` statements have now been replaced with
    a single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We have also saved the value from `errno` in a new variable called `errornum`.
    We did this because on the next error that occurs, the value in `errno` will be
    overwritten by the new error code. To safeguard against showing the wrong error
    message in case `errno` gets overwritten, it's safer to save it to a new variable.
  prefs: []
  type: TYPE_NORMAL
- en: We then used the error code stored in `errornum` as an argument to a new function
    called `strerror()`. This function translates the error code into a human-readable
    error message and returns that message as a string. That way, we don't have to
    create `if` statements ourselves for every possible error that can occur.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 3*, we saw how `strerror()` had translated the `EACCES` macros into
    *Permission denied*, and `ENOENT` into *No such file or directory*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `man 3 strerror` manual page, you'll find a similar function that can
    print error messages in the user's preferred locale.
  prefs: []
  type: TYPE_NORMAL
- en: Using errno with perror()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we used `strerror()` to get a string containing a human-readable
    error message from `errno`. There's another function similar to `strerr()` called
    `perror()`. Its name stands for **print error**, and that's what it does; it prints
    the error message directly to *stderr*.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll write the sixth version of our simple touch program. This
    time, we'll replace both of the `fprinf()` lines with `perror()`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The only programs necessary for this recipe are the GCC compiler and the Make
    tool (along with the generic Makefile).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create an even shorter and better version of `simple-touch`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code into a file and save it as `simple-touch-v6.c`. This
    time, the program is even smaller. We have removed the two `fprintf()` statements
    and replaced them with `perror()` instead. The changes from the previous version
    are highlighted here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile it using Make:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it and witness the change in the error message''s output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we have replaced both the `fprintf()` lines with a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `perror()` function takes one argument, a string with a description or function
    name. In this case, I chose to give it the generic error message `Can't create
    file`. When `perror()`prints the error message, it grabs the last error code in
    `errno` (notice we didn't specify any error code variable) and applies that error
    message after the text `Can't create file`. Hence, we don't need the `fprintf()`
    lines anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Even though `errno` isn't explicitly stated in the call to `perror()`, it still
    uses it. If another error occurs, then the next call to `perror()` will print
    that error message instead. The `perror()` function always prints the *last* error.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some great tips in the manual page, `man 3 perror`. For example, it's
    a good idea to include the name of the function that caused the error. This makes
    it easier to debug the program when users are reporting bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Returning an error value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though human-readable error messages are important, we must not forget
    to return a value to the shell that indicates an error. We have already seen that
    returning 0 means that everything is okay, while returning something else (most
    of the time, 1) means that some kind of error did occur. However, we can return
    more specific values if we want so that other programs relying on our program
    can read those numbers. For example, we can actually return the `errno` variable
    since it is just an integer. All the macros we have seen, such as `EACCES` and
    `ENOENT`, are integers (13 and 2 for `EACCES` and `ENOENT`, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to return the `errno` numbers to the shell
    to provide more specific information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The same set of programs mentioned in the previous recipe apply to this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will make the seventh version of our `simple-touch` program.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are only going to change a single line in this version from the previous
    one. Open up `simple-touch-v6.c` and change the `return` statement just below
    the `perror()` line to `return errno;`. Save the new file as `simple-touch-v7.c`.
    The latest version is as follows, with the changed line highlighted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the new version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it and check the exit codes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The error macros defined in `errno.h` are regular integers. So, if we, for example,
    return `EACCES`, we return the number 13\. So, what is happening here (when an
    error occurs) is that, first, `errno` is set behind the scenes. Then, `perror()`
    uses the value stored in `errno` to print a human-readable error message. Finally,
    the program returns to the shell with the integer stored in `errno`, indicating
    to other programs what went wrong. We should be a bit careful with this, though,
    since there are some reserved return values. For example, in the shell, the return
    value `2` often means *Missuse of shell builtins*. However, in `errno`, the return
    value `2` means *No such file or directory* (`ENOENT`). This shouldn't cause you
    too much trouble, but keep it in mind just in case.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a small program called `errno` that can print all macros and their
    integers. This tool isn't installed by default, though. The name of the package
    is `moreutils`.
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, you can print a list of all the macros by running the `errno
    -l` command, where the `l` option stands for *list*.
  prefs: []
  type: TYPE_NORMAL
- en: To install the package in *Debian* and *Ubuntu*, type `apt install moreutils`
    as root.
  prefs: []
  type: TYPE_NORMAL
- en: To install the package in *Fedora*, use `dnf install moreutils` as root.
  prefs: []
  type: TYPE_NORMAL
- en: On *CentOS* and *Red Hat*, you must first add the `epel-release` repository
    with `dnf install epel-release`, then install the package with `dnf install moreutils`
    as root. At the time of writing, there are some dependency issues with CentOS
    8 regarding `moreutils`, so it might not work.
  prefs: []
  type: TYPE_NORMAL
