- en: Using the Scapy Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scapy is powerful Python tool used to build and craft the packets then send
    them on the wire. You can build any type of network stream and send it on the
    wire. It can help you to test your network using different packet streams and
    manipulate the response returned from the source.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Scapy framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Scapy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating packets and network streams using Scapy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing and replaying packets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scapy ([https://scapy.net](https://scapy.net)) is one of the powerful Python
    tools that is used to capture, sniff, analyze, and manipulate network packets.
    It can also build a packet structure of layered protocols and inject a wiuthib
    stream into the network. You can use it to build a wide number of protocols on
    top of each other and set the details of each field inside the protocol, or, better,
    let Scapy do its magic and choose the appropriate values so that each one can
    have a valid frame. Scapy will try to use the default values for packets if not
    overridden by users. The following values will be set automatically for each stream:'
  prefs: []
  type: TYPE_NORMAL
- en: The IP source is chosen according to the destination and routing table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The checksum is automatically computed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source Mac is chosen according to the output interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ethernet type and IP protocol are determined by the upper layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scapy can be programmed to inject a frame into a stream and to resend it. You
    can, for example, inject a 802.1q VLAN ID into a stream and resend it to execute
    attacks or analysis on the network. Also, you can visualize the conversation between
    two endpoints and graph it using `Graphviz` and `ImageMagick` modules.
  prefs: []
  type: TYPE_NORMAL
- en: Scapy has its own **Domain-Specific Language** (**DSL**) that enables the user
    to describe the packet that he wants to build or manipulate and to receive the
    answer in the same structure. This works and integrates very well with Python
    built-in data types, such as lists and dictionaries. We will see in examples that
    the received packets from the network are actually a Python list, and we can iterate
    the normal list functions over them.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scapy supports both Python 2.7.x and 3.4+, starting from Scapy version 2.x.
    However, for versions lower than 2.3.3, Scapy needs Python 2.5 and 2.7, or 3.4+
    for versions after that. Since we already installed that latest Python version,
    it should be fine to run the latest version of Scapy without a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Also, Scapy has an older version (1.x), which is deprecated and doesn't provide
    support for Python 3 and works only on Python 2.4.
  prefs: []
  type: TYPE_NORMAL
- en: Unix-based systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get the latest and greatest version, you need to use python pip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The output should look something like the following screenshot:![](../images/00207.jpeg)
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that Scapy is installed successfully, access the Python console and
    try to import the `scapy` module into it. If no import error is reported back
    to the console then the installation completed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00208.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Some additional packages are required to visualize the conversation and to
    capture the packets. Use the following commands depending on your platform to
    install the additional packages:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing in Debian and Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the following command to install additional packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Installing in Red Hat/CentOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the following command to install additional packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You may need to install `epel` repository on a CentOS-based system and update
    the system if you don't find any of the preceding packages available in the main
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Windows and macOS X Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scapy is built and design to run on linux-based system. However it also can
    run on other operating systems. You can install and port it on both windows ported
    on both Windows and macOS, with some limitations on each platform. For a Windows-based
    system, you basically need to remove the WinPcap driver and use the Npcap driver
    instead (don't install both versions at the same time to avoid any conflict issues).
    You can read more about Windows installation at [http://scapy.readthedocs.io/en/latest/installation.html#windows](http://scapy.readthedocs.io/en/latest/installation.html#windows).
  prefs: []
  type: TYPE_NORMAL
- en: For macOS X, you will need to install some python bindings and use the libdnet
    and libpcap libraries. Full installation steps are available at [http://scapy.readthedocs.io/en/latest/installation.html#mac-os-x](http://scapy.readthedocs.io/en/latest/installation.html#mac-os-x).
  prefs: []
  type: TYPE_NORMAL
- en: Generating packets and network streams using Scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned before, Scapy has its own DSL language, which is integrated
    with python. Also, you can access the Scapy console directly and start to send
    and receive packets directly from the Linux shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The output of the preceding command is as follows:![](../images/00209.jpeg)
  prefs: []
  type: TYPE_NORMAL
- en: Notice there are a couple of warning messages about some missing *optional*
    packages, such as `matplotlib` and `PyX`, but this should be fine and won't affect
    the Scapy core functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start first by checking the supported protocols inside scapy. Run the `ls()`
    function to list all supported protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The output is quite lengthy and will span multiple pages if posted here, so
    you can take a quick look on the Terminal instead to check it.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's develop hello world application and run it using SCAPY. The program
    will send a simple ICMP packet to server's gateway. I installed a Wireshark and
    configured it to listen to a network interface that will receive a stream from
    the automation server (which hosts Scapy).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, on the Scapy terminal, execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Return to Wireshark, and you should see the communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00210.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s analyze the command that Scapy executes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Send**: This is a built-in function in Scapy **Domain Specific Language** (**DSL**)
    that instructs Scapy to send a single packet (and doesn''t listen for any response
    back; it just sends one packet and exits).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IP:** Now, inside this class, we will start building packet layers. Starting
    with the IP layer, we need to specify the destination host that will receive the
    packet (in that case, we use the `dst` argument to specify the destination). Note
    also that we can specify the source IP in the `src` argument; however, Scapy will
    consult the host routing table and find the suitable source IP and put it in the
    packet. You can provide additional parameters, such as **time to live** (**TTL**),
    and Scapy will override the default one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/** : Although it looks like the normal division operator used in Python,
    it''s used in Scapy DSL to differentiate between packet layers and stack them
    over each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ICMP():** A built-in class used to create an ICMP packet with a default value.
    One of the values that could be provided to the function is the ICMP type, which
    determines the message type: `echo`, `echo reply`, `unreachable`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Welcome to Enterprise Automation Course:** If a string is injected into the
    ICMP payload. Scapy will automatically convert it to a suitable format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we didn't specify the Ethernet layer in the stack and didn't provide
    any mac addresses (either source or destination). This is again filled by default
    in scapy to create a valid frame. It will automatically check the host ARP table
    and find the mac address for the source interface (and destination also, if it
    exists), them format then into an Ethernet frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'A final thing to note before moving on to the next example is that you can
    use the same `ls()` function we used before to list all supported protocols to
    get the default values for each protocol, then set it to any other value when
    we call the protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00211.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now do something more complex (and evil!). Assume we have two routers
    that form VRRP relationships between each other, and we need to to break this
    relationship to become the new master, or at least create a flapping issue in
    the network, as in the following topology:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00212.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Recall that routers configured to run VRRP join to multicast address (`255.0.0.18`)
    in order to receive the advertisements from other routers. The destination MAC
    address for the VRRP packet should contain the VRRP group number in last two numbers.
    Also it contains the router priority used in election process between routers.
    We will build a Scapy script that sends a VRRP announcement with a higher priority
    than is configured in the network. This will cause our Scapy server to be elected
    as the new master:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example:'
  prefs: []
  type: TYPE_NORMAL
- en: First we imported some needed layers that we stacked over each other from the `scapy.layers`
    module. For example, the `inet` module contains the layers `IP()` , `Ether()`,
    `ARP()`, `ICMP()`, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, we will need the VRRP layers, which could be imported from `scapy.layers.vrrp`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, we will build a VRRP packet and store it in the `vrrp_packet` variable.
    This packet contains the VRRP group number in the mac address inside ethernet
    frame . The multicast address will be inside the IP layer. Also we will configure
    a higher priority number inside the VRRP layer. That way we will have a valid
    VRRP announcement and router will accept it. We provided each layer with information
    such as the destination mac address (VRRP MAC + Group number) and the multicast
    IP (`225.0.0.18`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we used the `sendp()` function and provided it with a crafted `vrrp_packet`.
    The `sendp()` function will send a packet at layer 2, unlike the `send()` function,
    which we used in the previous example to send packets, but at layer 3\. The `sendp()` function
    won't try to resolve the hostname like the `send()` function and will only operate
    at layer 2\. Also, since we need to send this announcement continuously, we configured
    both `loop` and `inter` arguments to send announcements every 2 seconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The script output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00213.jpeg)You can combine this attack with ARP poisoning and
    VLAN hopping attacks so you can change the mac address in the layer 2, switch
    to the Scapy server MAC address, and perform a **m****an in the middle** (**MITM**)
    attack.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scapy also contains some classes that perform scan. For example, you can execute
    an ARP scan on the network range by using `arping()` and specifying the IP address
    in regex format inside it. Scapy will send an ARP request to all hosts on these
    subnets and inspect the reply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](../images/00214.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The script output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00215.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: According to received packets, only one host is responding back to SCAPY meaning
    it's only host on the scanned subnet. The host mac and IP addresses are listed
    in the reply also
  prefs: []
  type: TYPE_NORMAL
- en: Capturing and replaying packets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scapy has the ability to listen to the network interface and capture all incoming
    packets on it. It can write it on a `pcap` file in the same way that `tcpdump`
    works, but Scapy provides additional functions that can read and replay a `pcap`
    file, in the network again.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with a simple packet replay, we will instruct Scapy to read a normal
    `pcap` file captured from the network (either using `tcpdump` or Scapy itself)
    and send it again to the network. This is very useful if we need to test the behavior
    of the network if a specific traffic pattern travels through it. For example,
    we may have a network firewall configured to block FTP communication. We can test
    the functionality of the firewall by hitting it with FTP data replayed from Scapy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we have the FTP captured `pcap` file and we need to replay
    it to the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `PcapReader()` will take the `pcap` file as an input and analyze it to get
    each packet alone and add it as an item inside the `pkts` list. Now we can iterate
    over the list and show each packet content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00216.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, you can get specific layer information via the `get_layer()` function
    that accesses packet layers. For example, if we were interested in getting the
    raw data without the header so we can build the transmitted file, we could use
    the following script to get the required data in hex then convert it to ASCII
    later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have to surround the `get_layer()` method with a try-except clause
    as some layers don't contain the raw data (such as FTP control messages). Scapy
    will throw the error and the script will exit. Also, we can rewrite the script
    as an `if` clause that will add content to `ftp_data` only if the packet has the
    raw layer in it.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid any errors while reading the `pcap` file, make sure you save (or export)
    your `pcap` file as Wireshark/tcpdump format, as shown here, and not the default
    format:![](../images/00217.jpeg)
  prefs: []
  type: TYPE_NORMAL
- en: Injecting data inside packets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can manipulate the packet and change its contents before replaying it back
    to the network. Since our packets are actually stored as items inside the list,
    we can iterate over those items and replace specific information. For example,
    we can change mac addresses, IP addresses, or add additional layers to each packet
    or for specific packets matching a condition. However, we should note that manipulating
    packets in specific layers such as the IP and TCP and changing the content will
    result in an invalid checksum for the whole layer and the receiver may drop the
    packet for that reason.
  prefs: []
  type: TYPE_NORMAL
- en: Scapy has an amazing feature (yes I know, I keep saying amazing many times but
    Scapy really is an awesome tool). It will automatically calculate the checksum
    for us based on the new content if we delete the original one in the `pcap` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we will modify the previous script and change a few packet parameters,
    then rebuild the checksum before sending the packets to the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous script:'
  prefs: []
  type: TYPE_NORMAL
- en: We used the `PcapReader()` class to read the content of the FTP `pcap` file
    and store the packets in a `pkts` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we iterated over the packet and assigned the payload to`new_pkt` so we
    could manipulate the content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, the packet itself is considered as an object from the class. We can
    access the `src` and `dst` members and set them to any desired values. Here, we
    set the destination to the gateway and the source to a different value than the
    original packet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting a new IP value will invalidate the checksum, so we deleted both the
    IP and TCP checksum using the `del` keyword. Scapy will recalculate them again
    based on the new packet contents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we appended the `new_pkt` to the empty `p_out` list and sent it using
    the `send()` function. Notice that we can specify the exit interface in the send
    function or just leave it and Scapy will consult the host routing table; it will
    get the correct exit interface per packet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The script output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00218.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, if we still run the Wireshark in the gateway, we will notice that Wireshark
    captures the `ftp` packet stream with the checksum value set after recalculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00219.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Packet sniffing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scapy has a built-in packet capture function called `sniff()`. By default,
    it will monitor all interfaces and capture all packets if you don''t specify any
    filters or a certain interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The script output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00220.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can of course provide filters and specific interfaces to monitor whether
    the condition is matched. For example, in the preceding output we can see a mix
    of ICMP, TCP, SSH, and DHCP traffic hitting all interfaces. If we''re interested
    only in getting ICMP traffic on eth0, then we can provide the filter and `iface`
    arguments to sniff the function, and it will only filter all traffic and record
    only the ICMP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The script output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00221.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice how we capture only the ICMP communications on eth0 interfaces, and all
    other packets are discarded due to the filter applied on them. The *iface* value
    accepts a single interface that we used in the script or a list of interfaces
    to monitor them.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the advanced features of sniff is `stop_filter`, which is a Python function
    applied to each packet to determine if we have to stop the capture after that
    packet. For example, if we set `stop_filter = lambda x: x.haslayer(TCP)` then
    we will stop the capture once we hit a packet with a TCP layer. Also, the `store`
    option allows us to store the packets in the memory (which is by default enabled)
    or discard them after applying a specific function on each packet. This is a great
    feature if you''re getting real-time traffic from the wire to SCAPY and don''t
    want to write them to memory, if you set the store argument to false inside the
    sniff function, then SCAPY will apply any custom function you developed before
    (to get some information from packet for example or re-send them to different
    destination..etc) then won''t store the original packet in the memory and will
    discard it. This will save some memory resources during sniffing.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing the packets to pcap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we can write our sniffed packets to a standard `pcap` file and open
    it with Wireshark as usual. This happens via a simple `wrpcap()` function that
    writes the list of packets to a `pcap` file. The `wrpcap()` function accepts two
    arguments—the first one is the full path to a file location, and the second is
    the packet list captured before using the `sniff()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to leverage the Scapy framework to build any
    type of packet containing any network layer and populated it with our values.
    Also, we saw how to capture packets on the interface and replay them.
  prefs: []
  type: TYPE_NORMAL
