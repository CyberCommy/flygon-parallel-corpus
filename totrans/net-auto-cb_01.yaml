- en: Building Blocks of Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible is an enormously popular automation framework that has been used to
    automate IT operations for a long time. It simplifies the management of different
    infrastructure nodes and translates the business logic into well-defined procedures
    in order to implement this business logic. Ansible is written in Python and it
    mainly relies on SSH to communicate with infrastructure nodes to execute instructions
    on them. It started support for networking devices beginning with Ansible 1.9,
    and with Ansible 2.9, its current support for network devices has grown extensively.
    It can interact with network devices using either SSH or via API if the network
    vendors support APIs on their equipment. It also provides multiple advantages,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**An easy learning curve:** Writing Ansible playbooks requires knowledge of
    YAML and Jinja2 templates, which are easy to learn, and its descriptive language
    is easy to understand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Agentless:** It doesn''t require an agent to be installed on the remotely
    managed device in order to control this device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensible:** Ansible comes equipped with multiple modules to execute a variety
    of tasks on the managed nodes. It also supports writing custom modules and plugins
    to extend Ansible''s core functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Idempotent:** Ansible will not change the state of the device unless it needs
    to in order to change its setting to reach the desired state. Once it is in this
    desired state, running Ansible Playbooks against the device will not alter its
    configurations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will introduce the main components of Ansible and outline
    the different features and options that Ansible supports. The following are the
    main recipes that will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Ansible's inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ansible's variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Ansible's playbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ansible's conditionals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ansible's loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing secrets with Ansible Vault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Jinja2 with Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ansible's filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ansible Tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing Ansible's settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ansible Roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of this chapter is to have a basic understanding of the different
    Ansible components that we will utilize throughout this book in order to interact
    with the networking device. Consequently, all the examples in this chapter are
    not focused on managing networking devices. Instead, we will focus on understanding
    the different components in Ansible in order to use them effectively in the next
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the requirements for installing Ansible and running all of our Ansible
    playbooks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A Linux **Virtual Machine** (**VM**) with either of the following distributions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubuntu 18.04 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CentOS 7.0 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internet connectivity for the VM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the Linux machine is outside the scope of this recipe. However, the
    easiest approach to setting up a Linux VM with any OS version is by using *Vagrant *to
    create and set up the Ansible VM.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The machine on which we install Ansible (this is known as the Ansible control
    machine) should be running on any Linux distribution. In this recipe, we will
    outline how to install Ansible on both an Ubuntu Linux machine or a CentOS machine.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To install Ansible, we need a Linux VM using either an Ubuntu 18.04+ OS or CentoS
    7+ OS. Furthermore, this machine needs to have internet access for Ansible to
    be installed on it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is written in Python and all its modules need Python to be installed
    on the Ansible control machine. Our first task is to ensure that Python is installed
    on the Ansible control machine, as outlined in the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most Linux distributions have Python installed by default. However, if Python
    is not installed, here are the steps for installing it on Linux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On an Ubuntu OS, execute the following command:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'On a CentOS OS, execute the following command:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have validated that Python is installed, we can start to install Ansible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On an Ubuntu OS, execute the following command:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'On a CentOS OS, execute the following command:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works..
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to install Ansible is by using the package manager specific
    to our Linux distribution. We just need to make sure that we have enabled the
    required repositories to install the latest version of Ansible. In both Ubuntu
    and CentOS, we need to enable extra repositories that provide the latest version
    for Ansible. In CentOS, we need to install and enable the **Extra Packages for
    Enterprise Linux Repository** (**EPEL ****repo**), which provides extra software
    packages and has the latest Ansible packages for CentOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this method, we will install Ansible and all the requisite system packages
    needed to run the Ansible modules. In both Ubuntu and CentOS, this method will
    also install Python 2 and run Ansible using Python 2\. We can validate the fact
    that Ansible is installed and which version is used by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we can check that Ansible is working as expected by trying to connect
    to the local machine using the `ping` module as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this method, we can see that it has the following issues:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses Python 2 as the execution environment, but we want to use Python 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It updates the Python packages installed on the system, which might not be desirable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn't provide us with the granularity needed in order to select which version
    of Ansible to use. Using this method, we will always install the latest version
    of Ansible, which might not be what we need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to install Ansible in a Python 3 environment and to have more control
    over the version of Ansible deployed, we are going to use the pip Python program
    to install Ansible as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Python 3 if it is not present, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `python3-pip` package:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Install Ansible:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify that Ansible has been installed successfully, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Installing Ansible using this method ensures that we are using Python 3 as our
    execution environment and allows us to control which version of Ansible to install,
    as outlined in the example shown.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use this method as our Ansible installation method and all the
    subsequent chapters will be based on this installation procedure.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 13](557deee4-fa1a-4128-a277-dc3a3a85fe05.xhtml), *Advanced Techniques
    and Best Practices for Ansible*, we will outline yet another method for installing
    Ansible using Python virtual environments.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding the installation of Ansible, please check the
    following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Building Ansible's inventory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After installing Ansible, we need to define Ansible's inventory, which is a
    text file that defines the nodes that Ansible will manage. In this recipe, we
    will outline how to create and structure Ansible's inventory file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to create a folder that will contain all the code that we will outline
    in this chapter. We create a folder called `ch1_ansible`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to create the inventory file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `hosts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Using any text editor, open the file and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The Ansible inventory file can have any name. However, as a best practice, we
    will use the name `hosts `to describe the devices in our inventory.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ansible inventory files define the hosts that will be managed by Ansible
    (in the preceding example, this is `csr1-2` and `mx1-2` ) and how to group these
    devices into custom-defined groups based on different criteria. The groups are
    defined with `[]`. This grouping helps us to define the variables and simplify
    the segregation between the devices and how Ansible interacts with them. How we
    group the devices is based on our use case, so we can group them as per the vendor
    (Juniper and IOS) or function (core and edge).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also build hierarchies for the groups using the children, which is outlined
    in the inventory file. The following diagram shows how the hosts are grouped and
    how the group hierarchy is built:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9f400a5c-801d-4a28-9d42-282a2f058a6d.png)'
  prefs: []
  type: TYPE_IMG
- en: Using Ansible's variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible stores the information for the nodes that it manages using Ansible variables.
    Ansible variables can be declared in multiple locations. However, in observing
    the best practices for Ansible, we will outline the two main parts where Ansible
    looks for variables for the nodes that are declared in the inventory file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to follow along with this recipe, an Ansible inventory file must be
    already defined as outlined in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the inventory file, we define hosts and we group the hosts into groups.
    We now define two directories that Ansible searches for group variables and host
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two folders, `group_vars` and `host_vars`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `ios.yml` and `junos.yml` files inside `group_vars`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `mx1.yml` and `csr1.yml` inside `host_vars`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Populate variables in all the files, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We created the following structure of directories and files to host our variables,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/20d311f1-1f4b-4e27-8624-733306a36a08.png)'
  prefs: []
  type: TYPE_IMG
- en: All files inside the `group_vars` directory contain the group variables for
    the groups that we have defined in our inventory and they apply to all the hosts
    within this group. As for the files within `host_vars`, they contain variables
    for each host. Using this structure, we can group variables from multiple hosts
    into a specific group file and variables that are host-specific will be placed
    in a separate file specific to this host.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to `host_vars` and `group_vars`, Ansible supports the definition
    of variables using other techniques, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `vars` keyword within the play to specify multiple variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `vars_files` to define variables in a file and having Ansible read these
    variables from this file while running the playbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying variables at the command line using the `--e` option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to the user-defined variables that we can specify, Ansible has
    some default variables that it builds dynamically for its inventory. The following
    table captures some of the most frequently used variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `inventory_hostname` |  The name of the hosts as defined in the inventory
    (for example, `csr1` and `mx1`) |'
  prefs: []
  type: TYPE_TB
- en: '| ` play_hosts` |  A list of all the hosts included in the play |'
  prefs: []
  type: TYPE_TB
- en: '|  `group_names` |  A list of all the groups that a specific host is a part
    of (for example, for `csr1` this will be [edge, Cisco, network]) |'
  prefs: []
  type: TYPE_TB
- en: Building Ansible's playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Ansible playbook is the fundamental element in Ansible that declares what
    actions we would like to perform on our managed hosts (specified in the inventory).
    An Ansible playbook is a YAML-formatted file that defines a list of tasks that
    will be executed on our managed devices. In this recipe, we will outline how to
    write an Ansible playbook and how to define the hosts that will be targeted by
    this playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to follow along with this recipe, an Ansible inventory file must already
    be defined, along with all the group- and host-specific variable files created
    in accordance with previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new file called `playbook.yml` inside the `ch1_ansible` folder and
    incorporate the following lines in this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the playbook as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Ansible playbook is structured as a list of plays and each play targets
    a specific group of hosts (defined in the inventory file). Each play can have
    one or more tasks to execute against the hosts in this play. Each task runs a
    specific Ansible module that has a number of arguments. The general structure
    of the playbook is outlined in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d47f5627-bbfa-4390-b115-2185f8a471ac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding playbook, we reference the variables that we defined in the
    previous recipe inside the `{{ }}` brackets. Ansible reads these variables from
    either `group_vars` or `host_vars`, and the module that we used in this playbook
    is the `debug` module, which displays as a custom message specified in the `msg`
    parameter to the Terminal output. The playbook run is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4b64c49d-83a9-4478-884e-8dc6cbeac062.png)'
  prefs: []
  type: TYPE_IMG
- en: We use the `-i` option in the `ansible-playbook` command in order to point to
    the Ansible inventory file, which we will use as our source to construct our inventory.
  prefs: []
  type: TYPE_NORMAL
- en: In this playbook, I have used the `all` keyword to specify all the hosts within
    the inventory. This is a well-known group name that Ansible dynamically constructs
    for all hosts within the inventory.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible's conditionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the core features of Ansible is conditional task execution. This provides
    us with the ability to control which tasks to run on a given host based on a condition/test
    that we specify. In this recipe, we will outline how to configure conditional
    task execution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to follow along with this recipe, an Ansible inventory file must be
    present and configured as outlined in the previous recipes. Furthermore, the Ansible
    variables for all our hosts should be defined as outlined in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new playbook called `ansible_cond.yml` inside the `ch1_ansible` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Place the following content in the new playbook as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the playbook as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible uses the `when` statement to provide conditional execution for the
    tasks. The `when` statement is applied at the task level and if the condition
    in the `when` statement evaluates to `true`, the task is executed for the given
    host. If `false`, the task is skipped for this host. The output as a result of
    running the preceding playbook is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3cf93206-e932-47d1-97e3-7869e77fea29.png)'
  prefs: []
  type: TYPE_IMG
- en: The `when` statement can take a single condition as seen in the first task,
    or can take a list of conditions as seen in the second task. If `when` is a list
    of conditions, all the conditions need to be true in order for the task to be
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: In the first task, the `when` statement is enclosed in *""* since the statement
    starts with a string**.** However, in the second statement, we use a normal `when`
    statement with no *""* since the `when` statement starts with a variable name.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding Ansible''s conditionals, please check the following
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible's loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, we need to run a task inside an Ansible playbook to loop over
    some data. Ansible's loops allow us to loop over a variable (a dictionary or a
    list) multiple times in order to achieve this behavior. In this recipe, we will
    outline how to use Ansible's loops.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to follow along with this recipe, an Ansible inventory file must be
    present and configured, as outlined in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new playbook called `ansible_loops.yml` inside the `ch1_ansible` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `group_vars/cisco.yml` file, incorporate the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `group_vars/juniper.yml` file, incorporate the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `ansible_loops.yml` file, incorporate the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the playbook as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works..
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible supports looping over two main iterable data structures: lists and
    dictionaries. We use the `loops` keyword when we need to iterate over lists (`snmp_servers`
    is a list data structure) and we use `with_dicts` when we loop over a dictionary
    (`users` is a dictionary data structure where the username is the key and the
    passwords are the values). In both cases, we use the `item` keyword to specify
    the value in the current iteration. In the case of `with_dicts`, we get the key
    using `item.key` and we get the value using `item.value`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding playbook run is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4c43a45f-afdd-4601-9a00-4d4bb748f882.png)'
  prefs: []
  type: TYPE_IMG
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding the different Ansible *looping constructs**, *please
    consult the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Securing secrets with Ansible Vault
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we are dealing with sensitive material that we need to reference in our
    Ansible playbooks, such as passwords, we shouldn't save this data in plain text.
    Ansible Vault provides a method to encrypt this data and therefore be safely decrypted
    and accessed while the playbook is running. In this recipe, we will outline how
    to use Ansible Vault in order to secure sensitive information in Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new file called `decrypt_passwd` as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `ansible-vault` creates a new file called `secrets`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following variables to this new `secrets` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new playbook called `ansible_vault.yml`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the playbook as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works..
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use the `ansible-vault` command to create a new file that is encrypted using
    a key specified by `-- vault-id`. We place this key/password in another file (which
    is called `decrypt_passwd` in our example) and we pass this file as an argument
    to `vault-id`. Inside this file, we can place as many variables as we need. Finally,
    we include this file as a variable file in the playbook using `vars_files`. The
    following is the content of the secret file in case we try to read it without
    decryption:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In order for Ansible to decrypt this file, we must supply the decryption password
    (stored in a `decrypt_passwd` file in this example) via the `--vault-id` option.
    When we run `ansible-playbook`, we must supply this decryption password, otherwise
    the `ansible-playbook` fails, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In case we don''t want to specify the encryption/decryption password in the
    text file, we can use `--ask-vault-pass` with the `ansible-playbook` command in
    order to input the password while running the playbook, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Using Jinja2 with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jinja2 is a powerful templating engine for Python and is supported by Ansible.
    It is also used to generate any text-based files, such as HTML, CSV, or YAML.
    We can utilize Jinja2 with Ansible variables in order to generate custom configuration
    files for network devices. In this recipe, we will outline how to use Jinja2 templates
    with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to follow along with this recipe, an Ansible inventory file must be
    present and configured as outlined in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new file inside the `group_vars` directory called `network.yml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `templates` directory and create a new `ios_basic.j2` file with
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `junos_basic.j2` file within the `templates` directory with the
    following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new playbook called `ansible_jinja2.yml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the Ansible playbook as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created the `network.yml` file in order to group all the variables that will
    apply to all devices under this group. After that, we create two Jinja2 files,
    one for Cisco IOS devices, and the other for Juniper devices. Inside each Jinja2
    template, we reference the Ansible variables using `{{}}`. We also use the `for`
    loop construct, `{% for server in ntp_servers %} `, supported by the Jinja2 templating
    engine in order to loop over the `ntp_servers` variable (which is a list) to access
    each item within this list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible provides the `template` module that takes two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src`: This references the Jinja2 template file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dest`: This specifies the output file that will be generated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case, we use the `{{inventory_hostname}}` variable in order to make the
    output configuration file unique for each router in our inventory.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `template` modules create the output file on the remotely managed
    nodes. However, this is not possible in our case since the managed devices are
    network nodes. Consequently, we use the `delegate_to: localhost` option in order
    to run this task locally on the Ansible control machine.'
  prefs: []
  type: TYPE_NORMAL
- en: The first play in the playbook creates the `configs` directory to store the
    configuration files for the network devices. The second play runs the template
    module on Cisco devices, and the third play runs the `template` task on Juniper
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the configuration file for one of the Cisco devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the configuration file for one of the Juniper devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding the Ansible template module,please consult the
    following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/latest/modules/template_module.html](https://docs.ansible.com/ansible/latest/modules/template_module.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible's filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible's filters are mainly derived from Jinja2 filters, and all Ansible filters
    are used to transform and manipulate data (Ansible's variables). In addition to
    Jinja2 filters, Ansible implements its own filters to augment Jinja2 filters,
    while also allowing users to define their own custom filters. In this recipe,
    we will outline how to configure and use Ansible filters to manipulate our input
    data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install `python3-pip` and Python''s `netaddr` library, since we will be using
    the Ansible IP filter, which requires Python''s `netaddr` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new Ansible playbook called `ansible_filters.yml`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, we are using the `blockinfile` module to create a new configuration
    file on the Ansible control machine. This module is very similar to the `template`
    module. However, we can write the Jinja2 expressions directly in the module in
    the `block` option. We define a new variable called `interfaces` using the `vars`
    parameter in the playbook. This variable is a list data structure where each item
    in the list is a dictionary data structure. This nested data structure specifies
    the IP prefix used on each interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Jinja2 expressions, we can see that we have used a number of filters
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{{ hostname | upper}}`: `upper` is a Jinja2 filter that transforms all the
    letters of the input string into uppercase. In this way, we pass the value of
    the hostname variable to this filter and the output will be the uppercase version
    of this value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{{intf.prefix | ipv4(1) | ipv4(''address'') }}`: Here, we use the Ansible
    IP address filter twice. `ipv4(1)` takes an input IP prefix and outputs the first
    IP address in this prefix. We then use another IP address filter, `ipv4(''address'')`,
    in order to only get the IP address part of an IP prefix. So in our case, we take
    `10.1.1.0/24` and we output `10.1.1.1` for the first interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{{intf.prefix | ipv4(''netmask'') }}`: Here, we use the Ansible IP address
    filter to get the netmask of the IP address prefix, so in our case, we get the
    `/24` subnet and transform it to `255.255.255.0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output file for the `csr1` router after this playbook run is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Using Ansible Tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible Tags is a powerful tool that allows us to tag specific tasks within
    a large Ansible playbook and provides us with the flexibility to choose which
    tasks will run within a given playbook based on the tags we specify. In this recipe,
    we will outline how to configure and use Ansible Tags.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new Ansible playbook called `ansible_tags.yml`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the playbook as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the playbook again, this time using tags, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use tags to mark both tasks and plays with a given tag in order to use
    it to control which tasks or plays get executed. This gives us more control when
    developing playbooks to allow us to run the same playbook. However, with each
    run, we can control what we are deploying. In the example playbook in this recipe,
    we have tagged the tasks as OSPF, BGP, or NTP and have applied the `routing` tag
    to both the OSPF and BGP tasks. This allows us to selectively run the tasks within
    our playbook as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With no tags specified, this will run all the tasks in the playbook with no
    change in the behavior, as shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/488df312-f5f4-4335-926b-f8679b6bf419.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the `ospf` tag, we will only run any task marked with this tag, as shown
    here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/1c0ed146-98f5-4685-b404-4cf019aea279.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the `routing` tag, we will run all tasks marked with this tag, as shown
    here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/6750a066-54c7-4c8d-af67-0d303272f82a.png)'
  prefs: []
  type: TYPE_IMG
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding Ansible Tags,please consult the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/latest/user_guide/playbooks_tags.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_tags.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Ansible's settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible has many setting that can be adjusted and controlled using a configuration
    file called `ansible.cfg`. This file has multiple options that control many aspects
    of Ansible, including how Ansible looks and how it connects to managed devices.
    In this recipe, we will outline how to adjust some of these default settings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new file called `ansible.cfg`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, Ansible''s settings are controlled by the `ansible.cfg` file located
    in the `/etc/ansible` directory. This is the default configuration file for Ansible
    that controls how Ansible interacts with managed nodes. We can edit this file
    directly. However, this will impact any playbook that we will use on the Ansible
    control machine, as well as any user on this machine. A more flexible and customized
    option is to include a file named `ansible.cfg` in the project directory and this
    includes all the options that you need to modify from their default parameters.
    In the preceding example, we outline only a small subset of these options, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`inventory`***:*** This option modifies the default inventory file that Ansible
    searches in order to find its inventory (by default, this is `/etc/ansible/hosts`).
    We adjust this option in order to let Ansible use our inventory file and stop
    using the `-i` operator to specify our inventory during each playbook run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vault_password_file`: This option sets the file that has the secret password
    for encrypting and decrypting `ansible-vault` secrets. This option removes the
    need to run Ansible playbooks with the `--vault-id` operator when using `ansible-vault`-encrypted
    variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gathering = explicit`: By default, Ansible runs a setup module to gather facts
    regarding the managed nodes while the playbook is running. This setup module is
    not compatible with network nodes since this module requires a Python interpreter
    on the managed nodes. By setting fact gathering to `explicit`, we disable this
    default behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding Ansible''s configuration settings,please consult
    the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings)'
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible Roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible Roles promotes code reusability and provides a simple method for packaging
    Ansible code in a simple way that can be shared and consumed. An Ansible role
    is a collection of all the required Ansible tasks, handlers, and Jinja2 templates
    that are packaged together in a specific structure. A role should be designed
    in order to deliver a specific function/task. In this recipe, we will outline
    how to create an Ansible role and how to use it in our playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the `ch1_ansible` folder, create a new folder called `roles` and create
    a new role called `basic_config`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `basic_config/vars/main.yml` file with the following variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `basic_config/tasks/main.yml` file with the following tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `basic_config/templates` folder, create the following structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new playbook, `pb_ansible_role.yml`, with the following content to
    use our role:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we start by creating the `roles` directory within our main
    folder. By default, when using roles, Ansible will look for roles in the following
    location in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: The `roles` folder within the current working directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/ansible/roles`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consequently, we create the `roles` folder within our current working directory
    (`ch1_ansible`) in order to host all the roles that we will create in this folder.
    We create the role using the `ansible-galaxy` command with the `init` option and
    the role name (`basic_config`), which will create the following role structure
    inside our `roles` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be seen from the preceding output, this folder structure is created
    using the `ansible-galaxy` command and this command builds the role in keeping
    with the best practice role layout. Not all these folders need to have a functional
    role that we can use, and the following list outlines the main folders that are
    commonly used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tasks` folder: This contains the `main.yml` file, which lists all the
    tasks that should be executed when we use this role.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `templates` folder: This contains all the Jinja2 templates that we will
    use as part of this role.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `vars` folder: This contains all the variables that we want to define and
    that we will use in our role. The variables inside the `vars` folder have very
    high precedence when evaluating the variables while running the playbook.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `handlers` folder: This contains the `main.yml` file, which includes all
    the handlers that should run as part of this role.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The role that we created has a single purpose, which is to build the basic configuration
    for our devices. In order to accomplish this task, we need to define some Ansible
    tasks as well as use a number of Jinja2 templates in order to generate the basic
    configuration for the devices. We list all the tasks that we need to run in the
    `tasks/main.yml` file and we include all the necessary Jinja2 templates in the
    `templates` folder. We define any requisite variable that we will use in our role
    in the `vars` folder.
  prefs: []
  type: TYPE_NORMAL
- en: We create a new playbook that will use our new role in order to generate the
    configuration for the devices. We call all the roles that we want to run as part
    of our playbook in the `roles` parameter. In our case, we have a single role that
    we want to run, which is the `basic_config` role.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we run our playbook, we can see that a new directory called `basic_config`
    is created with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding Ansible Roles,please consult the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html)'
  prefs: []
  type: TYPE_NORMAL
