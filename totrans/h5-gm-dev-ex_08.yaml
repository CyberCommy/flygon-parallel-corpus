- en: Chapter 8. Building a Multiplayer Draw-and-Guess Game with WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We built several local single player games in previous chapters. In this chapter,
    we will build a multiplayer game with the help of WebSockets. WebSockets enable
    us to create event-based server-client architecture. The messages passed between
    all connected browsers become instant. We will combine the canvas drawing, JSON
    data packing, and several techniques learned in previous chapters to build the
    draw-and-guess game.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Trying an existing multiuser sketchpad which shows drawings from different connected
    users through WebSockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing a WebSockets server which is implemented by `node.js`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting the server from a browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an instant chat room with WebSocket API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a multiuser drawing pad in Canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a draw-and-guess game by integrating the chat room and drawing with
    game logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the draw-and-guess game that we will create
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a Multiplayer Draw-and-Guess Game with WebSockets](img/1260_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, let's get on with it.
  prefs: []
  type: TYPE_NORMAL
- en: Trying an existing WebSockets web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start to build our WebSockets example, we will take a look at an existing
    multiuser sketchpad example. This example lets us know how the data is sent between
    browsers by using the WebSockets server instantly.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**A browser''s capability of using WebSockets**'
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, only Apple Safari and Google Chrome supported
    the WebSockets API. Mozilla Firefox and Opera dropped support on WebSockets because
    of a potential security issue on the protocol. Google Chrome is also planning
    to drop WebSockets until the security hole is fixed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following link from Mozilla explains why they disabled WebSockets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://hacks.mozilla.org/2010/12/websockets-disabled-in-firefox-4/](http://hacks.mozilla.org/2010/12/websockets-disabled-in-firefox-4/)'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Trying the multiuser sketchpad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the following link in a web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[http://www.chromeexperiments.com/detail/multiuser-sketchpad/](http://www.chromeexperiments.com/detail/multiuser-sketchpad/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will get an introduction page of the multiuser sketchpad. Right click on
    the **Launch Experiment** option and choose **Open link in new window**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The browser prompts a new window with the sketchpad application. Then, we repeat
    the preceding step again to open another instance of the sketchpad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put the two browsers side by side on the desktop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to draw something on either sketchpad. The drawing should appear on both
    sketchpads. In addition, the sketchpad is shared with everyone who is connecting.
    You may also see drawings from other users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows a cup drawn on the sketchpad by two users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Trying the multiuser sketchpad](img/1260_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just seen how browsers can be connected together in real time. We draw
    something on the sketchpad and all other connected users can view the drawings.
    In addition, we can see what others are drawing too.
  prefs: []
  type: TYPE_NORMAL
- en: The example is made by using the HTML5 WebSockets feature with a backend server
    to broadcast drawing data to all connected browsers.
  prefs: []
  type: TYPE_NORMAL
- en: The drawing part is built on a canvas which we already covered in *Chapter 4,
    Building* the *Untangle Game with Canvas and Drawing API*. The WebSocket API enables
    browsers to establish a persistent connection with the server. The backend is
    an event-based server named `node.js` which we will install and use in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a WebSocket server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTML5, WebSockets provides a client-side API to connect a browser to a backend
    server. This server has to support WebSockets protocol in order to keep the connection
    persistent.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Node.JS WebSocket server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will download and install a server named `Node.JS` on which
    we can install a WebSockets module.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Installing Node.JS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the following URL which contains the source code of the `Node.JS` server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://github.com/joyent/node](https://github.com/joyent/node)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Downloads** button on the page. It prompts a dialog asking which
    format to download. Just select the ZIP format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip the ZIP file in a working directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Linux or Mac OSX, use Terminal and change the directory to where the `node.js`
    file is located.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Node.JS` works out of the box in Linux and Mac. The following link provides
    an installer for installing it on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://node-js.prcn.co.cc/](http://node-js.prcn.co.cc/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `sudo make install` command installs `Node.JS` with root ownership and also
    installs the required third party libraries with root access. The following link
    discusses how we can install the `Node.JS` without using `sudo:`
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[http://increaseyourgeek.wordpress.com/2010/08/18/install-node-js-without-using-sudo/](http://increaseyourgeek.wordpress.com/2010/08/18/install-node-js-without-using-sudo/)'
  prefs: []
  type: TYPE_NORMAL
- en: The `sudo make install` command requires typing the password of the user in
    a system who has admin privileges. Type the password to continue the installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the installation, we can check whether the `node.js` is installed by
    checking its version with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command should print a version number of the `node.js`. In my
    case, it is version 0.5 pre:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will install the WebSockets library for the `Node.JS` server. Go to
    the following URL in a browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://github.com/miksago/node-websocket-server](http://https://github.com/miksago/node-websocket-server)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Downloads** button on the page and download the ZIP file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip the ZIP file in a directory. We will need the `lib` directory in this
    package later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just downloaded and installed the `Node.JS` server. We also downloaded the
    WebSockets library for the `node.js` server. We will build server logic on top
    of this server and the WebSockets library through the examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Node.js` server installation runs well on Unix or Linux operating systems.
    However, it requires a few more steps to install and run the `node.js` server
    on Windows. The following link shows how we can install the `node.js` server on
    Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/joyent/node/wiki/Building-node.js-on-Cygwin-(Windows)](http://https://github.com/joyent/node/wiki/Building-node.js-on-Cygwin-(Windows))'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a WebSockets server to broadcast the connection count
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just installed the `node.js` server with the WebSockets library. Now, we
    will build something to test the WebSockets. Imagine now we want a server that
    accepts connections from browsers and then broadcasts the connection count to
    all users.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Creating a WebSocket server that sends the total count of connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory named `server`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the entire `lib` folder in the `node-websocket-server` package in the `server`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file named `server.js` under the `server` directory with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Open the terminal and change to the server directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following command to execute the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get the following result if it works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just created a simple server logic that initialized the WebSockets library
    and listened to the connection event.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the WebSockets server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `Node.JS`, different functions are packed into modules. When we need a functionality
    in a specific module, we use `require` to load it. We load the WebSockets module
    and then initialize the server using the following code in the server logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`__dirname` represents the current directory of the server JavaScript file
    that is being executed. We placed the `lib` folder under the same folder of our
    server logic file. Therefore, the WebSockets server is in **current directory**
    | **lib** | **ws** | **server**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At last, we need to assign a port for the server to listen to by the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, `8000` is the port number with which a client
    connects to this server. We may choose a different port number, but we have to
    ensure that the chosen port number is not overlapped by other common server services.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to get more information about the global scope objects and variables
    from the `node.js` server, please visit their official document at the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://nodejs.org/docs/v0.4.3/api/globals.html](http://nodejs.org/docs/v0.4.3/api/globals.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Listening to the connection event on the server side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `node.js` server is event-based. This means that most logic is executed
    when a certain event is fired. The following code we used in the example listens
    to the `connection` event and handles it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `connection` event comes with a connection argument. We have an `id` property
    in the connection instance that we can use to distinguish each connected client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists two commonly used server events:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Server-side event for WebSockets node.js | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `connection` | Event fires when there is a new connection established by
    the client |'
  prefs: []
  type: TYPE_TB
- en: '| `close` | Event fires when a connection closes |'
  prefs: []
  type: TYPE_TB
- en: Getting a count of connected clients on the server side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can get the count of connected clients in the WebSockets `node.js` server
    by accessing the server manager. We can get the count by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Broadcasting a message to all connected browsers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the server gets a new `connection` event, we broadcast the updated count
    of the connection to all clients. Broadcasting a message to clients is easy. We
    just need to call the `broadcast` function in the `server` instance with a `string`
    argument as the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet broadcasts a server message to all connected browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Creating a client that connects to a WebSocket server and getting the total
    connections count
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We built the server in the last example and now we will build a client that
    connects to our WebSocket server and receives messages from the server. The message
    will contain the total connection count from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Showing the connection count in a WebSocket application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory named `client`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an HTML file named `index.htm` in the `client` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will add a few markups in our HTML file. Put the following code in the `index.htm`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Create a directory named `js` and put the jQuery JavaScript file inside.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file named `html5games.websockets.js` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We will test the code. First, we need to run the node server with our `server.js`
    code by node `server.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, open the `index.htm` file in a client directory in a web browser twice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inspect the server terminal. There should be log messages similar to the following
    indicating the connection information and total connection count:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we inspect the console panel in a browser. We get the total connection
    count once we have loaded the page. The following screenshot shows the result
    on the client side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Showing the connection count in a WebSocket application](img/1260_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just built a client that established a WebSockets connection to the server
    we built in the last section. The client then prints any message received from
    the server to the console panel in the Inspector.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing a WebSocket connection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In any browser that supports WebSockets, we can establish a connection by creating
    a new WebSocket instance with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `url` argument is a string with the WebSockets URL. In our example, we are
    running our server locally. Therefore, the URL we have used is `ws://127.0.0.1:8000`,
    where 8000 represents the port number of the server to which we are connecting.
    It is 8000 because the server is listening to the port 8000 when we built the
    server-side logic.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets client events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to the server, we have several WebSockets events on the client side.
    The following table lists the events we will use to deal with WebSockets:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Event name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `onopen` | Fired when a connection to the server is established |'
  prefs: []
  type: TYPE_TB
- en: '| `onmessage` | Fired when any message from the server is received |'
  prefs: []
  type: TYPE_TB
- en: '| `onclose` | Fired when the server closes the connection |'
  prefs: []
  type: TYPE_TB
- en: '| `onerror` | Fired when there is any error in the connection |'
  prefs: []
  type: TYPE_TB
- en: Building a chatting application with WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now know how many browsers are connected. Suppose we want to build a chat
    room where users can type a message in their respective browsers and broadcast
    the message to all the connected users instantly.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a message to the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will let the user input a message and then send the message to the `node.js`
    server. The server will then forward the message to all connected browsers. Once
    the browser receives the messages, it displays it in the chat area. In this case,
    the users are connected to the instant chat room once they load the web page.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Sending a message to the server through WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, code the server logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `server.js` and add the following highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now move on to the `client` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `index.htm` file and add the following markup in the `body` section.
    It provides inputs for the user to type and send messages to the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following code to the `html5games.websocket.js` JavaScript file.
    It sends the message to the server when the user clicks on the `send` button or
    presses the **Enter** key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Before testing our code, check the server terminal and see whether the node
    server is still running. Press **Ctrl+C** to terminate it and run it again by
    using the `node server.js` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `index.htm` in a web browser. You should see an input text field with a
    **Send** button as shown in the following screenshot:![Time for action Sending
    a message to the server through WebSockets](img/1260_08_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to type something in the input text field and then click on the **Send**
    button or press **Enter**. The input text is cleared.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, switch to the server terminal and we will see the server printing the
    text we just sent. You can also put the browser and server terminal side by side
    to see how instantly the message is sent from the client to the server. The following
    screenshot shows the server terminal with messages from two connected browsers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Sending a message to the server through WebSockets](img/1260_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just extended our connection example by adding an input text field for the
    users to type some text there and send it out. The text is sent as a message to
    the WebSockets server. The server will then print the received message in the
    terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a message from the client to the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to send a message from the client to the server, we call the following
    `send` method in the `WebSocket` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code snippet from our example, we get the message from the
    input text field and send it to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Receiving a message on the server side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the server side, we need to handle the message we just sent from the client.
    We have an event named `message` in the connection instance in the WebSocket `node.js`
    library. We can listen to the connection message event to receive a message from
    each client connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how we use the message event listener to print
    the message and the unique connection ID on the server terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Only string is accepted when sending and receiving messages between the server
    and the client. We cannot directly send objects. However, we can convert the data
    into a JSON-formatted string before transmitting. We will show an example of sending
    data objects later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting every received message on the server side to create a chat room
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last example, the server could receive messages sent from browsers. However,
    the server does nothing except print the received messages in the terminal. Therefore,
    we will add some logic to the server to broadcast the messages out.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Broadcasting the messages to all connected browsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `server.js` file for the server-side logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following highlighted code to the message event listener handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That is it for the server side. Move on to the `client` folder and open the
    `index.htm` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We want to display the chat messages in the chat history area. Add the following
    code to the HTML file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need the client-side JavaScript to handle the received message from
    the server. We used it to print it out into the console panel, replace the `console.log`
    code by the following highlighted code in the `onmessage` event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let's test our code. Terminate any running node server by **Ctrl + C**. Then
    run the server again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `index.htm` file twice and put them side by side. Type something in
    the text field and press **Enter**. The message will appear on both opened browsers.
    If you open many instances of the HTML file, the message should appear on all
    browsers. The following screenshot shows two browsers displaying the chat history
    side by side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Broadcasting the messages to all connected browsers](img/1260_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an extension of our previous examples. We discussed how a server broadcasts
    the connection count to all connected clients. We also discussed how the client
    sends a message to the server. In this example, we combine these two techniques
    to let the server broadcast the received messages to all connected users.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing between WebSockets and polling approaches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have ever built a web page chat room by using a server-side language
    and a database, then you may wonder what is the difference between the WebSocket
    implementation and the traditional one.
  prefs: []
  type: TYPE_NORMAL
- en: The traditional chat room method is often implemented by using a **polling**
    approach. The client asks the server for an update periodically. The server responds
    to the client with either no update or updated data. However, the traditional
    approach has several problems. The client does not get new data updated from the
    server until the next time it asks the server. This means that the data update
    is delayed with the periodic time and the response is not instant enough. If we
    want to improve this issue by shortening the polling duration, then more bandwidth
    is utilized because clients need to keep sending requests to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following graph shows requests between the client and the server. It shows
    that many useless requests are sent, but the server responds to the client without
    any new data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Comparing between WebSockets and polling approaches](img/1260_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There is a better polling approach named **long polling**. The client sends
    a request to the server and waits for the response. Instead of the traditional
    polling approach where the server responds with "no update", the server does not
    respond at all until there is something that needs to be pushed to the server.
    In this approach, the server can push something to clients whenever there is an
    update. Once the client receives a response from the server, it creates another
    request and waits for the next server notification. The following graph shows
    the long polling approach where clients ask for updates and the server responds
    only when there is an update:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Comparing between WebSockets and polling approaches](img/1260_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the WebSockets approach, the number of requests are way less than the polling
    approach. It is because the connection between the client and server is persistent.
    Once the connection is established, a request from either the client side or the
    server side is sent only when there is any update. For instance, a client sends
    a message to the server when it wants to update something to the server. The server
    also sends messages to clients only when it needs to notify the clients of a data
    update. No other useless requests are sent during the connection. Therefore, less
    bandwidth is utilized. The following graph shows the WebSockets approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Comparing between WebSockets and polling approaches](img/1260_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pop quiz The benefit of WebSockets verses the polling approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What are the benefits of using an event-based WebSockets approach to implement
    the multiuser chat room? How do these benefits make the message-passing so instant?
  prefs: []
  type: TYPE_NORMAL
- en: Making a shared drawing whiteboard with Canvas and WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose we want a shared sketchpad. Anyone can draw something on the sketchpad
    and all others can view it, just like the sketchpad example we played at the beginning
    of this chapter. We learned how messages are communicated between clients and
    servers. We will go further and send drawing data.
  prefs: []
  type: TYPE_NORMAL
- en: Building a local drawing sketchpad
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we deal with the data sending and the server handling, let's focus on
    making a drawing whiteboard. We will use the canvas to build a local drawing sketchpad.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Making a local drawing whiteboard with the Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will focus only on the client side in this section. Open the `index.htm`
    file and add the following `canvas` markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We will draw something on the canvas and we will need the mouse position relative
    to the canvas. We did this in *Chapter 4, Building* an *Untangle Game with Canvas
    and Drawing API*. Add the following style to the canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Then, we open the `html5games.websocket.js` JavaScript file to add the drawing
    logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the `websocketGame` global object with the following variable at the
    top of the JavaScript file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the jQuery `ready` function, we add the following mouse event handler code.
    The code handles the mouse down, move, and up events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'At last, we have the following function to draw a line on the canvas with the
    given starting and ending point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Save all files and open the `index.htm` file. We should see an empty space
    where we can draw something by using the mouse. The drawings are not sent to the
    server yet, so others cannot view our drawings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Making a local drawing whiteboard with the Canvas](img/1260_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just created a local drawing pad. This is like a whiteboard where the player
    can draw on the canvas by dragging the mouse. However, the drawing data is not
    sent to the server yet; all drawings are only displayed locally.
  prefs: []
  type: TYPE_NORMAL
- en: The `drawing line` function is the same that we used in *Chapter 4*. We also
    used the same code to get the mouse position relative to the canvas element. However,
    the logic of the mouse events is different from *Chapter 4*.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing on the canvas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we draw something on the computer, it often means that we click on the
    canvas and drag the mouse (or pen). The line is drawn until the mouse button is
    up. Then, the user clicks on another place and drags again to draw lines.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we have a Boolean flag named `isDrawing` to indicate if the
    user is drawing. The `isDrawing` flag is false by default. When the mouse button
    is down, we turn the flag to true. When the mouse is moving, we draw a line between
    the moved point and the last point when the mouse button is down. Then, we set
    the `isDrawing` flag to false again when the mouse button is up.
  prefs: []
  type: TYPE_NORMAL
- en: This is how the drawing logic works.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero Drawing with colors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Can we modify the drawing sketchpad by adding color support? How about adding
    five buttons with red, blue, green, black, and white color? The player can choose
    the color when drawing.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting the drawing to all connected browsers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will go further by sending our drawing data to the server and let the server
    broadcast the drawing to all connected browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Sending the drawing through WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to modify the server logic. Open the `server.js` file and replace
    the following code. It uses a JSON-formatted string for broadcasting, so we can
    send and receive data object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: On the client side, we need the logic to respond to the server with the same
    data object definition. Open the `html5games.websocket.js` JavaScript file in
    the **client** | **js** directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following constants to the `websocketGame` global variable. The same
    constants with the same values are also defined in the server side logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When handling the message event on the client-side, we convert the JSON formatted
    string back to the data object. If the data is a chat message, then we display
    it as chat history, otherwise we draw it on the canvas as a line segment. Replace
    the `onmessage` event handler with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When the mouse is moving, we not only draw the line on the canvas but also
    send the line data to the server. Add the following highlighted code to the mouse
    move event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need to modify the send message logic. We now pack the message in
    an object and format it as JSON when sending it to the server. Change the `sendMessage`
    function to the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Save all files and re-launch the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `index.htm` file in two browser instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, try the chat room feature by typing some messages and sending them.
    Then, try drawing something on the canvas. Both browsers should display the same
    drawing as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Sending the drawing through WebSockets](img/1260_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just built a multiuser sketchpad. This is similar to the sketchpad we
    tried at the beginning of this chapter. We extended what we learned when building
    a chat room by sending a complex data object as a message.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a data object to communicate between the client and the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to communicate correctly between the server and clients with several
    data packed into one message, we have to define a data object that both client
    and server understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several properties in the data object. The following table lists
    the properties with why we need them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property name | Why we need this property |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `dataType` | This is an important property that helps us to understand about
    the entire data. The data is either a chat message or a drawing line segment data.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `sender` | If the data is a chat message, the client needs to know who sent
    the message. |'
  prefs: []
  type: TYPE_TB
- en: '| `message` | When the data type is a chat message, we surely need to include
    the message content itself into the data object. |'
  prefs: []
  type: TYPE_TB
- en: '| `startX` | When the data type is a drawing line segment, we include the x/y
    coordinate of the starting point of the line. |'
  prefs: []
  type: TYPE_TB
- en: '| `startY` |   |'
  prefs: []
  type: TYPE_TB
- en: '| `endX` | When the data type is a drawing line segment, we include the x/y
    coordinate of the ending point of the line. |'
  prefs: []
  type: TYPE_TB
- en: '| `endY` |   |'
  prefs: []
  type: TYPE_TB
- en: 'In addition, we have the following constants defined on both the client side
    and the server side. These constants are for the `dataType` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'With these constants, we can compare the `dataType` by the following readable
    code instead of using the meaningless integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Packing the drawing lines data into JSON for broadcasting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used the `JSON.stringify` function in the last chapter when storing a JavaScript
    object into a JSON-formatted string in the local storage. Now, we need to send
    the data in a string format between the server and the client. We used the same
    method to pack the drawing lines data into an object and send it as a JSON string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how we pack the line segment data on the client
    side and send it to the server with a JSON-formatted string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Recreating the drawing lines after receiving them from other clients
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JSON parsing often comes as a pair of `stringify`. When we receive a message
    from the server, we have to parse it to the JavaScript object. The following code
    on the client side parses the data and either updates the chat history or draws
    a line based on the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Building a multiplayer draw-and-guess game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We built an instant chat room earlier in this chapter. Moreover, we just built
    a multiuser sketchpad. How about combining these two techniques and building a
    draw-and-guess game? A draw-and-guess game is a game in which one player is given
    a word to draw. All other players do not know the word and guess the word according
    to the drawing. The one who draws and who correctly guesses the word earn points.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Building the draw-and-guess game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will implement the game flow of the draw-and-guess game as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will add the game logic on the client side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `index.htm` file in the client directory. Add the following restart
    button right after the *send* button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Open the `html5games.websocket.js` JavaScript.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need a few more constants to determine different states during the game
    play. Add the following highlighted code to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we want a flag to indicate this player to in charge of drawing.
    Add the following Boolean global variable to the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When the client receives a message from the server, it parses it and checks
    whether it is a chat message of line drawing. We have another type of message
    now for handling the game logic named `GAME_LOGIC`. The game logic message contains
    different data for different game states. Add the following code to the `onmessage`
    event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We have added the game logic to the client side. There is some minor code on
    the client side containing the restart logic and preventing the non-drawing player
    to draw on the canvas. These codes can be found in the code bundle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is time to move on to the server side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the previous example, the server side is just in charge of broadcasting
    any incoming message to all connected browsers. This is not enough for a multiplayer
    game. The server will act as the game master that controls the game flow and winning
    determination. Therefore, delete the existing code in `server.js` and use the
    following code. The changes are highlighted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We will save all files and re-launch the server. Then, launch the `index.htm`
    file in two browser instances. One browser gets a message from the server informing
    the player to draw something. The other browser, on the other hand, informs the
    player to guess what the other is drawing within one minute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The player who is told to draw something can draw on the canvas. The drawings
    are broadcasted to other connected players. The players who are told to guess
    cannot draw anything on the canvas. Instead, players type what they guess in the
    text field and send to the server. If the guessing is correct, then the game ends.
    Otherwise, the game continues until the one-minute countdown finishes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Building the draw-and-guess game](img/1260_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just created a multiplayer draw-and-guess game in WebSockets and Canvas.
    The main difference between the game and the multiuser sketchpad is that the server
    now controls the game flow instead of letting all users draw.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the game flow of a multiplayer game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Controlling the game flow of a multiplayer game is much more difficult than
    a single game. We can simply use a few variables to control the game flow of a
    single game, but we have to use message passing to inform each player of specific
    updated game flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we require the following highlighted constant `GAME_LOGIC` for `dataType`.
    We use this `dataType` to send and receive a message which is related to the game
    logic control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: There are several states in the game flow. Before the game starts, the connected
    players are waiting for the game to start. Once there are enough connections for
    the multiplayer game, the server sends a game logic message to all players to
    inform them to start the game.
  prefs: []
  type: TYPE_NORMAL
- en: When the game is over, the server sends a game over state to all players. Then,
    the game finishes and the game logic halts until any player clicks on the restart
    button. Once the restart button is clicked, the client sends a game restart state
    to the server instructing the server to prepare a new game. Then, the game starts
    again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare the four game states as the following constants in both client and
    server, so they understand them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code on the server side holds an index to indicate which player
    is in turn now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The data which is sent to the player (whose turn it is) is different from the
    data that is sent to other players. The other players receive the following data
    with only a game start signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the player (who is in turn to draw) receives the following
    data with the word information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Enumerating connected clients on the serverside
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can enumerate all connected clients by using the `forEach` method in the
    `server manager` class. The following code shows the usage. It loops through each
    connection and calls the given `callback` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, the following code snippet prints all connections ID on the server
    terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Sending a message to a specific connection on the server side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We used broadcast in our previous examples to send a message to all connected
    clients. Besides sending the message to everyone, we can send it to a specific
    connection by using the `send` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `send` method requires two arguments. The `connectionID` is the unique ID
    of the target connection and `message` is the string that we want to send.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code extracted from our draw-and-guess game, we send special
    data to the player''s browser who now has to draw something. We use the `forEach`
    function to loop through the connections and check whether the connection is in
    turn to draw. Then, we pack the answer and send this data to this target connection
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Improving the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just created a multiplayer game which is playable. However, there is still
    lots to improve. In the following sections, we list two possible improvements
    in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Storing drawn lines on each game
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the game, the drawer draws lines and other players guess the drawing. Now,
    imagine that two players are playing and the third player joins. As there is no
    storage for the drawn lines anywhere, the third player cannot see what the drawer
    has drawn. This means that the third player has to wait until the game ends to
    play.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How can we let a player who has joined late continue the game without losing
    those drawn lines? How can we reconstruct the drawing for a newly connected player?
    How about storing all drawing data of the current game on the server?
  prefs: []
  type: TYPE_NORMAL
- en: Improving the answer checking mechanism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The answer checking on the server side compares the message with the `currentAnswer`
    variable to determine whether a player guessed correctly. The answer is treated
    as incorrect if the case does not match. It looks strange when the answer is "apples"
    and the player is told wrong when guessing "apple".
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How can we improve the answer checking mechanism? How about improving the answer
    checking logic to treat the answer as correct when using a different case or even
    similar words?
  prefs: []
  type: TYPE_NORMAL
- en: Decorating the draw-and-guess game with CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The game logic is basically finished and the game is playable already. However,
    we forgot to decorate the game to make it look appealing. We will use CSS styles
    to decorate our draw-and-guess game.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Decorating the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The decoration only applies to the client side. Open the `index.htm` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following CSS style link in the head:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We put all markups in the `body` inside `section` with `id=game`. Also, we
    add an `h1` title for the game as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Add a wording **Chat or Guess:** in front of the text field input, so the player
    knows where to type their guessing words.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a directory named `css` inside the `client` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file named `drawguess.css` and save it in the `css` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put the following styles in the CSS file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Save all files and open the `index.htm` file again in two browsers to play
    the game. As we only changed the decoration code, the game should look better
    now as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Decorating the game](img/1260_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just applied styles to our game and embedded a font from the **Google Font
    Directory** that looks like sketching text. The canvas is now styled to look more
    like a canvas with a thick border and subtle shadow.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned a lot in this chapter about connecting browsers to WebSockets. The
    messages and events from one browser are broadcasted to another browser in almost
    real time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we:'
  prefs: []
  type: TYPE_NORMAL
- en: Learned how WebSockets provide real-time events by drawing on an existing multiplayer
    sketchpad. It shows drawings from other users who are connected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installed a `Node.js` server with the WebSocket library. By using this server,
    we can easily build an event-based server to handle WebSocket requests from browsers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussed the relationship between the server and a client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built an instant chat room application. We learned how to implement a server
    script to broadcast incoming messages to other connected browsers. We also learned
    how to display a received message from the server on the client side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built a multiuser drawing board. We learned how to pack data in the JSON format
    to pass a message between the server and browsers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built a draw-and-guess game by integrating the chatting and drawing pad. We
    also learned how to create the game logic in a multiplayer game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have learned to build a multiplayer game, we are ready to build
    physics games with the help of the physics engine in the next chapter.
  prefs: []
  type: TYPE_NORMAL
