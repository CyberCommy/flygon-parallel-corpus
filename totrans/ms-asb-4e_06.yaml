- en: '*Chapter 5*: Infrastructure Management for Enterprises with AWX'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is clear that Ansible is an incredibly powerful and versatile automation
    tool, lending itself well to managing an entire estate of servers and network
    devices. Mundane, repetitive tasks can be made repeatable and straightforward,
    saving a great deal of time! Obviously, this is of great benefit in a corporate
    environment. However, this power comes at a price. If everyone has their own copy
    of Ansible on their own machines, how do you know who ran what playbook, and when?
    How do you ensure that all playbooks are correctly stored and version-controlled?
    Furthermore, how do you prevent the proliferation of superuser-level access credentials
    across your organization, while benefiting from the power of Ansible?
  prefs: []
  type: TYPE_NORMAL
- en: The answer to these questions comes in the form of AWX, an open-source enterprise
    management system for Ansible. AWX is the open-source, upstream version of the
    commercial Ansible Tower software available from Red Hat, and it offers virtually
    the same features and benefits, but without the support or product release cycle
    that Red Hat offers. AWX is a powerful, feature-rich product that includes not
    only a GUI to make it easy for non-Ansible users to run playbooks, but also a
    complete API for integration into larger workflows and CI/CD pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will give you a solid foundation for installing and using
    AWX, specifically covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting AWX up and running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating AWX with your first playbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going beyond the basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the examples presented in this chapter, you will need a Linux machine
    running Ansible 4.3 or newer. Almost any flavor of Linux should do; for those
    interested in specifics, all the code presented in this chapter was tested on
    Ubuntu Server 20.04 LTS unless stated otherwise, and on Ansible 4.3\. The example
    code that accompanies this chapter can be downloaded from GitHub at this URL:
    [https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action video from Packt: [https://bit.ly/3ndx73Q](https://bit.ly/3ndx73Q)'
  prefs: []
  type: TYPE_NORMAL
- en: Getting AWX up and running
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get stuck into installing AWX, it is worth briefly exploring what
    AWX is, and what it isn''t. AWX is a tool to be employed alongside Ansible. It
    does not duplicate or replicate, in any way, the features of Ansible. Indeed,
    when Ansible playbooks are run from AWX, the `ansible-playbook` executable is
    being called behind the scenes. AWX should be considered a complementary tool
    that adds the following benefits, on which many enterprises depend:'
  prefs: []
  type: TYPE_NORMAL
- en: Rich **role-based access control** (**RBAC**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with centralized login services (for example, LDAP or AD)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure credential management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auditability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accountability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lower barrier to entry for new operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved management of playbook version control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fully featured API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the AWX code runs in a set of Linux containers. However, the standard
    installation method has changed since the last edition of the book, and it is
    now preferred that you deploy AWX on Kubernetes. If you are already proficient
    at Kubernetes, you may wish to try and deploy this in your own environment, as
    AWX should run on Red Hat's OpenShift, the open-source OKD, and any one of the
    many other existing flavors of Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: If, however, you are not proficient in Kubernetes, or you are looking for some
    pointers on how to get started, then we will walk you through a complete installation
    of AWX from scratch in this part of the chapter. We will base this on the excellent
    `microk8s` distribution, which you can get up and running on a single node on
    Ubuntu Server with just one command!
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get started, one final note. Although Kubernetes is the preferred
    installation platform now, at the time of writing there is still an installation
    method available for Docker hosts. However, the maintainers of the AWX project
    note that this is targeted at development and test environments only, and has
    no official published release. As such, we will not cover this in this chapter.
    If you want to learn more, however, you can read the installation instructions
    at the following link: [https://github.com/ansible/awx/blob/devel/tools/docker-compose/README.md](https://github.com/ansible/awx/blob/devel/tools/docker-compose/README.md).'
  prefs: []
  type: TYPE_NORMAL
- en: With that covered, let's get started on our `microk8s`-based deployment. The
    installation process outlined here assumes you are starting from an unmodified
    Ubuntu Server 20.04 installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s install `microk8s` itself, using the `snap` available
    with Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The only other step required is to add your user account to the `microk8s`
    group so that you can run the remaining commands in this section without needing
    `sudo` privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to log out and back in again for the change in group membership
    to apply to your account. Once you have done this, let''s get started on preparing
    `microk8s` for our AWX deployment. We will need the `storage`, `dns`, and `ingress`
    add-ons for our deployment, so let''s go ahead and enable them using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re ready to install AWX Operator, which is in turn used to manage the
    rest of the installation. Installing this is as simple as running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will return immediately while the installation continues in the
    background. You can check on the status of the installation with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `STATUS` field should say `Running` for the AWX Operator deployment once
    it is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The previous command will clone the latest development release of AWX Operator.
    If you want to clone one of the releases, browse the *Releases* section of the
    repository, available at the following link, and check out your desired version: [https://github.com/ansible/awx-operator/releases](https://github.com/ansible/awx-operator/releases).
  prefs: []
  type: TYPE_NORMAL
- en: 'The screenshot in *Figure 5.1* shows the output following the successful deployment
    of AWX Operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The microk8s pod status following the successful deployment
    of AWX Operator'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_05_01.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – The microk8s pod status following the successful deployment of
    AWX Operator
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll create a simple self-signed certificate for our AWX deployment.
    If you have your own certificate authority, you are of course welcome to generate
    your own certificate with the appropriate signing for your environment. If you
    are generating a self-signed certificate using the command that follows, be sure
    to replace `awx.example.org` with the hostname you have assigned to your AWX server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create a secret (an object that contains a small amount of sensitive
    data) in Kubernetes containing our newly generated certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With this done, it''s time to think about storage. AWX is designed to source
    its playbooks from source control repositories such as Git, and as such, the default
    installation does not provide easy access to local playbook files. However, for
    the purposes of creating a working example in this book that everyone can follow,
    we will create a persistent volume to store local playbooks. Create a YAML file
    called `my-awx-storage.yml`, containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to create this storage using the YAML file we just
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to deploy AWX itself. To do this, we must create another YAML
    file that describes the deployment. We''ll call this one `my-awx.yml`, and for
    our example, it should contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploy AWX using this file with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The deployment will take a few minutes, especially the first time you run it,
    as container images have to be downloaded in the background. You can check on
    the status with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When the deployment is complete, all pods should show `STATUS` as `Running`,
    as shown in *Figure 5.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Kubernetes pod status after a successful AWX deployment'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_05_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Kubernetes pod status after a successful AWX deployment
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, deploying AWX is only of limited use if we are unable to access
    it. We will use the ingress add-on of Microk8s to create an ingress router so
    that we can access our AWX deployment at our chosen hostname (`awx.example.org`
    in this example), over the standard HTTPS port. Create another YAML file, this
    time called `my-awx-ingress.yml`. It should contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploy and then check this ingress definition with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don''t see an event with the `Reason` value set to `CREATE`, you may
    have to delete and then redeploy the ingress definition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A successful deployment of the ingress rule should look like that shown in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – A successful deployment of the ingress configuration for AWX'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_05_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – A successful deployment of the ingress configuration for AWX
  prefs: []
  type: TYPE_NORMAL
- en: 'The default username for logging into AWX is `admin`. However, the password
    is randomly generated and stored in a secret within Kubernetes. To retrieve this
    so you can log in for the first time, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You should now be able to log into your AWX deployment by pointing
    a web browser as the hostname you chose earlier. In this example, it would be
    [https://awx.example.org](https://awx.example.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'On the first run of AWX, many operations, such as building the database schema,
    are performed in the background. As such, it might initially appear that the GUI
    is not responding. If your pod statuses look healthy, simply wait, and in a few
    minutes you will see the login screen appear, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Accessing the login screen of AWX after deployment'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_05_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – Accessing the login screen of AWX after deployment
  prefs: []
  type: TYPE_NORMAL
- en: When you first log into AWX, you will be presented with a dashboard screen and
    a menu bar down the left-hand side. It is through this menu bar that we will explore
    AWX and perform our first configuration work. Equally, it is worth noting that
    when AWX is first installed, some example content is populated to help you get
    up to speed quicker. Feel free to explore the demo content, as the examples are
    different to those given in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Before we complete this section, consider the persistent volume we created earlier
    for storing our local playbooks. How do we get access to that? When using a simple
    single-node deployment of `microk8s` as we have used here, you can execute a few
    commands to query the environment and find out where the files should go.
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, retrieve the name of your `hostpath-provisioner` pod. It should
    look a little something like `hostpath-provisioner-5c65fbdb4f-jcq8b`, and can
    be retrieved using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Having established this unique name, run the following command to discover
    the local directory where files are being stored for your pods. Be sure to replace
    the unique `hostpath-provisioner` name with the one from your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, retrieve the unique name of your persistent volume claim for your
    AWX playbooks, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Your final path will be an amalgamation of these results, including `namespace`
    (`default` in this example), and your PVC name (defined as `awx-pvc` in the `my-awx-storage.yml`
    file earlier). Thus, on my demo system, my local playbooks should be placed under
    the following directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We will put some simple example playbooks into this directory later in the chapter,
    so it's worth locating it now and making a note of it so that you can access it
    easily for the later examples.
  prefs: []
  type: TYPE_NORMAL
- en: With AWX up and running on Microk8s, in the next section we will look at getting
    our first playbook integrated and running with AWX.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating AWX with your first playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a basic four-stage process involved in getting a playbook to run from
    AWX. Once you understand this, it paves the way for more advanced usage and fuller
    integration in an enterprise environment. In this part of the chapter, we will
    master these four stages in order to get to the point where we can run our first
    simple playbook, and this will give us the building blocks to move forward with
    AWX in confidence. The four stages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define an inventory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first three stages can be performed in any order, but the template mentioned
    in the final stage pulls together the three previously created facets. Therefore,
    it must be defined last. Also, note that there does not need to be a one-to-one
    relationship between these items. Several templates can be created from one project.
    This is also the case for inventories and credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get started, we need a simple playbook that we can use in our examples
    as we go through this part of the chapter. On the AWX host, locate the local AWX
    persistent volume folder (this is described in the previous section if you are
    running AWX on Microk8s). I will show examples from my demo system in the following
    commands, but your system will have its own unique IDs. Make sure you adjust the
    paths for your system – copying and pasting the ones from mine will almost certainly
    not work!
  prefs: []
  type: TYPE_NORMAL
- en: 'Every locally hosted project must have its own subdirectory within the persistent
    volume, so let''s create one here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now place the following example code into this folder, as `example.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With this done, we can proceed to defining a project.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A project, in AWX terms, is simply a collection of Ansible playbooks grouped
    together. These collections of playbooks are often retrieved from a **source control
    management** (**SCM**) system. Indeed, this is the recommended way to host Ansible
    playbooks in an enterprise. Using an SCM means that everyone is working from the
    same version of code, and all changes are tracked. These are the elements that
    are vital in an enterprise environment.
  prefs: []
  type: TYPE_NORMAL
- en: With regards to the grouping of playbooks, there is no right or wrong way to
    organize projects, so this is very much up to the teams involved. Put simply,
    one project links to one repository, and so where it makes sense for multiple
    playbooks to live in one repository, it would make sense for them to live in one
    project within AWX. This is not a requirement, however – you can have just one
    playbook per project if it suits your needs best!
  prefs: []
  type: TYPE_NORMAL
- en: As previously discussed, it is also possible to store Ansible playbooks locally.
    This is useful when testing or when starting out, and we will utilize this capability
    in our example here, as it ensures everyone reading this book can complete the
    examples with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Log into the AWX interface using the `admin` account and click on the **Projects** link
    on the left-hand menu bar. Then click on the **Add** button near the top right
    of the window. This creates a new blank project for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we do not need to worry about all the fields (we''ll discuss these
    in detail later). However, we do need to configure the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/Table_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The end result should look something like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Creating your first project in AWX using our local playbook
    directory'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_05_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – Creating your first project in AWX using our local playbook directory
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Save** button to store your edits. That's it – you have defined
    your first project in AWX! From here, we can define an inventory.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an inventory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inventories in AWX work exactly the same as the inventories that we worked with
    in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The* *System
    Architecture and Design of Ansible*, where we referenced them using the command
    line. They can be static or dynamic, can consist of groups and/or individual hosts,
    and can have variables defined on a global per group or per-host basis – we are
    now simply defining them through a user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Inventories** item on the left-hand menu bar. As with projects,
    we want to define something new, so click on the **Add** button near the top right
    of the window. A drop-down list will appear. Select **Add Inventory** from this
    list.
  prefs: []
  type: TYPE_NORMAL
- en: When the **Create new inventory** screen appears, enter a name for the inventory
    (for example, `Mastery Demo`), and then click the **Save** button.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You must save your blank inventory before you can start defining hosts or groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this is completed, you should have a screen that looks something like
    that shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Creating a new empty inventory in AWX'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_05_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – Creating a new empty inventory in AWX
  prefs: []
  type: TYPE_NORMAL
- en: Once you have saved the new inventory, note the tabs along the top of the inventories
    sub-pane – **Details**, **Access**, **Groups**, **Hosts**, **Sources**, and **Jobs**.
    You will find tabs like these on almost every pane in the AWX user interface –
    we also saw them after we defined our first project earlier in this chapter (we
    just didn't need to use them at that stage).
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping our example simple, we will define one host in a group to run our example
    playbook against. Click on the **Groups** tab, and then click on the **Add** button
    to add a new inventory group. Give the group a name and click **Save**, as shown
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Creating a new inventory group in AWX'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_05_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – Creating a new inventory group in AWX
  prefs: []
  type: TYPE_NORMAL
- en: 'Now click on the **Hosts** tab, and then click on the **Add** button and select
    **Add new host** from the drop-down menu. Enter the IP address of your AWX host
    into the **Name** field (or the FQDN if you have set up DNS resolution). You can
    also add a description to the host if you wish, then click **Save**. The end result
    should look something like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Creating a new host in the Mastery Group group of the Mastery
    Demo inventory'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_05_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.8 – Creating a new host in the Mastery Group group of the Mastery Demo
    inventory
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Variables** box seen on most of the inventory screens expects variables
    to be defined in YAML or JSON format, and not the INI format we used on the command
    line. Where earlier we had defined variables such as `ansible_ssh_user=james`,
    we would now enter `ansible_ssh_user: james` if the YAML mode is selected.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well done! You''ve just created your first inventory in AWX. If we were to
    create this inventory on the command line, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It might be simple, but it paves the way for us to run our first playbook. Next,
    let's look at the concept of credentials in AWX.
  prefs: []
  type: TYPE_NORMAL
- en: Defining credentials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the ways in which AWX lends itself to an enterprise is the secure storage
    of credentials. Ansible, given its nature and typical use cases, is often given
    the *keys to the kingdom* in the form of SSH keys or passwords that have root
    or other administrative-level privileges. Even if encrypted in a vault, the user
    running the playbook will have the encryption password and hence can obtain the
    credentials. Obviously, having many people with uncontrolled access to administrator
    credentials may not be desirable. Luckily for us, AWX solves this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a simple example. Suppose my test host (the one that we defined the
    inventory for previously) has a `root` password of `Mastery123!`. How do we store
    this securely?
  prefs: []
  type: TYPE_NORMAL
- en: First of all, navigate to the **Credentials** menu item, and then click the
    **Add** button (as we have done previously) to create something new. Give the
    credential an appropriate name (for example, `Mastery Login`), and then click
    on the **Credential Type** dropdown to expand the list of available credential
    types (you can even create your own if you can't see the ones you need in here!).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see that there are many different credential types that AWX can store.
    For a machine login, such as ours, we want to select the `Machine` type. Once
    the credential type is set, you will see that the screen changes and fields appropriate
    to creating a machine credential have appeared. We could define the login based
    on the SSH key and various other parameters, but in our simple example, we will
    simply set the username and password to the appropriate values, as shown in the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Adding a new machine credential in AWX'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_05_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.9 – Adding a new machine credential in AWX
  prefs: []
  type: TYPE_NORMAL
- en: Now, save the credential. If you now go back to edit the credential, you will
    note that the password disappears and is replaced by the string `ENCRYPTED`. It
    is now impossible to retrieve the password (or SSH key, or other sensitive data)
    through the AWX user interface directly. You will notice that you can replace the
    existing value (by clicking on the curly arrow to the left of the now grayed-out
    password field), but cannot see it. The only way to get the credential would be
    to get both connectivity to the backend database and the encryption key for the
    database that was used at the time of installation. This means even someone performing
    a `SELECT` operation on the database itself won't be able to see the key, as database
    rows containing sensitive data are all encrypted with a key that is autogenerated
    at install time. While this clearly has massive security benefits for an organization,
    it must also be pointed out that the loss of the backend database, or the encryption
    key associated with it, would result in a complete loss of the AWX configuration.
    As a result, it is important (as with any infrastructure deployment) to back up
    your AWX deployment and associated secrets, in case you need to recover from a
    potential disaster situation.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, AWX has protected your sensitive access data in a manner not totally
    dissimilar to Ansible Vault. Of course, Ansible Vault remains a command-line tool
    and, although vault data can be used in playbooks in AWX exactly as it can when
    Ansible is used on the command line, vault creation and modification remains a
    command line-only activity. With our credential in place, let's proceed to the
    final step necessary to run our first ever playbook from AWX – defining a template.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A job template – to give it its full name – is a way of pulling together all
    the previously created configuration items, along with any other required parameters,
    to run a given playbook against an inventory. Think of it as defining how you
    would run `ansible-playbook` if you were on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dive right in and create our template by carrying out the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Templates** in the left-hand menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Add** button to create a new template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Add Job Template** from the drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As a minimum to run our first job, you will need to define the following fields
    on the **Create New Job Template** screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/Table_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This should result in a screen that looks something like that shown in the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Creating a new template in AWX'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_05_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.10 – Creating a new template in AWX
  prefs: []
  type: TYPE_NORMAL
- en: 'With all the fields populated, as in the previous screenshot, click on the **Save** button.
    Congratulations! You are now ready to run your first playbook from AWX. To do
    so, navigate back to the list of templates and click on the small rocketship icon
    to the right of our newly created template. Immediately upon doing so, you will
    see the job execute and will see the output from `ansible-playbook` that we are
    familiar with from the command line, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – The output from our first playbook template run in AWX'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_05_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.11 – The output from our first playbook template run in AWX
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, you can see the raw output from `ansible-playbook`. You can
    access the **Jobs** screen any time by clicking on the **Jobs** menu item on the
    menu bar, and browsing all jobs that have been run. This is excellent for auditing
    the various activities that AWX has been orchestrating, especially in a large
    multi-user environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the **Jobs** screen, you can see the **Details** tab, where all
    the fundamental parameters we defined earlier are listed, such as **Project** and **Template**.
    Also displayed is useful information for auditing purposes, such as information
    regarding the user the job was launched by, and times that the job started and finished.
    A screenshot of this is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – The Details tab from our playbook template run'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_05_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.12 – The Details tab from our playbook template run
  prefs: []
  type: TYPE_NORMAL
- en: While AWX is capable of much more, these fundamental stages are central to most
    of the tasks you will want to perform in AWX. Therefore, gaining an understanding
    of their usage and sequence is essential in learning how to use AWX. Now that
    we have the fundamentals under our belts, in the next section we will take a look
    at some of the more advanced things you can do with AWX.
  prefs: []
  type: TYPE_NORMAL
- en: Going beyond the basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now covered the basics necessary to run your first playbook from AWX
    – the basics required for most Ansible automation within this environment. Of
    course, we can't possibly cover all the advanced features AWX has to offer in
    a single chapter. In this section, we will therefore highlight a few of the more
    advanced facets to explore if you wish to learn more about AWX.
  prefs: []
  type: TYPE_NORMAL
- en: Role-based access control (RBAC)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have only looked at using AWX from the perspective of the built-in `admin` user.
    Of course, one of AWX's enterprise-level features is RBAC. This is achieved by
    the use of **users** and **teams**. A team is basically a group of users, and
    users can be a member of one or more teams.
  prefs: []
  type: TYPE_NORMAL
- en: Both users and teams can be created manually in the AWX user interface, or through integration with
    an external directory service, such as LDAP or Active Directory. In the case of
    directory integration, teams would most likely be mapped to groups within the
    directory, though rich configuration allows for administrators to define the exact
    nature of this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The RBAC's within AWX are rich. For example, a given user can be granted the `Admin` role
    within one team, and either the `Member` or `Read` roles in another.
  prefs: []
  type: TYPE_NORMAL
- en: User accounts themselves can be set up as system administrators, normal users,
    or system auditors.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, as we stepped through the basic setup part of this chapter,
    you will have noticed the tabs on just about every page of the AWX user interface.
    Among these, there is almost always a tab called **Permissions**, which allows
    true fine-grained access control to be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a given user of the **Normal User** type could be given the `Admin` role
    within their assigned team. However, they can then be assigned the `READ` role
    on a given project, and this more specific privilege supersedes the less specific `Admin`
    role set at the **Team** level. So, when they log in, they can see the project in
    question but can't change it or execute any tasks – for example, an update from
    the SCM.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule of thumb, more specific privileges supersede less specific
    ones. So, those at a project level will take precedence over those at a team or user level.
    Note that, for items where no permission is specified via either a user or their team,
    that person will not even see that item when logged into the user interface. The
    only exception to these rules are system administrators, who can see everything
    and perform any action. Assign this type to user accounts sparingly!
  prefs: []
  type: TYPE_NORMAL
- en: There is a great deal to explore when it comes to RBAC. Once you get the hang
    of it, it is easy to create secure and tightly locked-down deployments of AWX
    where everyone has just the right amount of access.
  prefs: []
  type: TYPE_NORMAL
- en: Organizations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AWX contains a top-level configuration item called an **organization**. This is
    a collection of **inventories**, **projects**, **job templates**, and **teams** (these,
    in turn, are a grouping of **users**). Hence, if you have two distinct parts of
    an enterprise that have entirely different requirements but still require the
    use of AWX, they can share a single AWX instance without the need for overlapping
    configuration in the user interface by virtue of organizations.
  prefs: []
  type: TYPE_NORMAL
- en: While users of the system administrator type have access to all organizations,
    normal users will only see their associated organizations and configuration. These
    are a really powerful way of segregating access to the different parts of an enterprise
    deployment of AWX.
  prefs: []
  type: TYPE_NORMAL
- en: By way of example, when we created our inventory earlier in the chapter, you
    will have noticed that we ignored the **Organization** field (this was set to
    default – the only organization that exists on a new AWX install). If we were
    to create a new organization called `Mastery`, then anyone who was not a member
    of this organization would be unable to see this inventory, regardless of the
    permissions or privileges they have (the exception to this being the **System
    administrator** user type, which can see everything).
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some AWX configuration items, such as projects (which may need to update from
    an SCM) or job templates (which perform a specific task), may need to be run on
    a regular basis. Having a powerful tool such as AWX, but then requiring operators
    to log in regularly to perform routine tasks, would be pointless. Therefore, AWX
    has built-in scheduling.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the definition page for any project or template, simply look for the **Schedules** tab,
    and you then have a rich range of scheduling options available to you – *Figure
    5.13* shows an example of the creation of a daily schedule, running every day
    from the 7th to the 11th of May 2021 at 1 pm in the London time zone. Note that
    this schedule is being created against the `Mastery Template` job template that
    we created earlier, and so will automatically run this playbook template on the
    defined schedule:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Creating a daily schedule to run the Mastery Template job template
    created earlier'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_05_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.13 – Creating a daily schedule to run the Mastery Template job template
    created earlier
  prefs: []
  type: TYPE_NORMAL
- en: Note the variety of options available to you for scheduling. To help you ensure
    that the schedule suits your requirements, a detailed breakdown of the schedule
    is shown when you save the new schedule. When you have schedules running unattended,
    along with multiple users logging into a system such as AWX, it is vital that
    you can maintain oversight of what is going on. Thankfully, AWX has rich features
    to allow auditing of the events that occur, and we will take a look at these in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the risks of running Ansible on the command line is that once a particular
    task has been run, its output is lost forever. It is, of course, possible to turn
    on logging for Ansible. However, in an enterprise, this would need to be enforced,
    which would be difficult with lots of operators having root access to a given
    Ansible machine, be it their own laptop or a server elsewhere. Thankfully, as
    we saw in our earlier example, AWX stores not only the details of who ran what
    tasks and when but also stores all the output from the `ansible-playbook` runs.
    In this way, compliance and auditability are achieved for enterprises wishing
    to use Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Simply navigate to the **Jobs** menu item, and a list of all previously run
    jobs (that the user has permission to see) will be shown. It is even possible
    to repeat previously completed jobs directly from this screen simply by clicking
    on the rocketship icon next to the job in question. Note that this immediately
    launches the job with the same parameters it was launched with last time, so be
    sure that clicking it is what you want to do!
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.14* shows the job history for our demo AWX instance being used for
    the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – The job history pane of the AWX instance being used for the
    book'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_05_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.14 – The job history pane of the AWX instance being used for the book
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on the numbered entry in the **Name** column takes you to the **Output**
    and **Details** tab panes that we saw in *Figure 5.11* and *Figure 5.12*, but
    of course, relevant to the specific job run you clicked on. While you can clean
    up the job history, the jobs remain there for you to examine until you delete
    them. Also note the two grayed-out buttons at the top of *Figure 5.14*. Using
    these, you can cancel running jobs (useful if for any reason they get stuck or
    fail) and also delete multiple entries from the job history. This is great for
    cleaning up once you have finished your auditing.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, with playbooks, there is no one-size-fits-all solution, and sometimes
    we need operators to be able to input unique data at the time of running playbooks.
    AWX provides a feature for exactly this purpose called surveys, and we will look
    at this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Surveys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, when launching a job template, it is not possible (or desirable)
    to define all information upfront. While it is perfectly possible to define parameters
    using variables in the AWX user interface, this is not always desirable, or indeed
    user friendly, as the variables must be specified in valid JSON or YAML syntax.
    In addition, users who have only been granted the `Read` role on a template will
    not be able to edit that template definition – this includes the variables! However,
    there might be a valid reason for them to set a variable, even though they shouldn't
    be editing the template itself.
  prefs: []
  type: TYPE_NORMAL
- en: Surveys provide the answer to this, and on any job template you have created,
    you will find a tab at the top marked **Survey**. A survey is essentially a questionnaire
    (hence the name!) defined by an administrator that asks for input in a user-friendly
    manner and where simple user input validation is performed. Once validated, the
    entered values are stored in Ansible variables, just as they would be if they
    had been defined in YAML or JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we wanted to capture the `http_port` variable value for a job
    template when it is run, we could create a survey question, as shown in *Figure
    5.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – Creating a survey question to capture a valid HTTP port number
    into a variable'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_05_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.15 – Creating a survey question to capture a valid HTTP port number
    into a variable
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created all your questions, note that you need to turn surveys
    on for your job template, as shown in *Figure 5.16*, otherwise the questions will
    not appear when it is run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – Turning on surveys for a job template'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_05_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.16 – Turning on surveys for a job template
  prefs: []
  type: TYPE_NORMAL
- en: Now, when the playbook is run, the user is prompted to enter a value, and AWX
    ensures it is an integer in the specified range. A sensible default is also defined. Let's
    now move forward to looking at a more advanced way of using job templates in AWX,
    called workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Workflow templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Playbook runs, especially from AWX, can be complex. For example, it might be
    desirable to update a project from an SCM system and any dynamic inventories first.
    We might then run a job template to roll out some updated code. If this fails,
    however, it would almost certainly be desirable to roll back any changes that
    were made (or take other remedial action). When you click on the now-familiar
    **Add** button to add a new template, you will see two options in the drop-down
    menu – **Job template** (we have already used this), and **Workflow template**.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the required fields are filled in for the new workflow template and
    it is saved, you will automatically enter **Workflow Visualizer** (to get back
    to this in the future, simply access your workflow template through the GUI in
    the normal manner, and then click on the **Visualizer** tab). The workflow visualizer
    builds up a flow, from left to right, of tasks for AWX to perform. For example,
    the following screenshot shows a workflow where our demo project is initially
    synchronized with its SCM.
  prefs: []
  type: TYPE_NORMAL
- en: 'If that step succeeds (denoted by the green link to the next block), the demo
    job template is run. If that in turn succeeds, then the mastery template is run.
    If any of the preceding steps fail, then the workflow stops there (though an **On
    Failure** action can be defined at any stage). Based on this simple building block
    premise and the ability to perform subsequent actions in the event of success,
    failure, or always, will enable you to build large-scale operational flows within
    AWX. This will all be achieved without having to build up huge monolithic playbooks.
    *Figure 5.17* shows our simple workflow in the visualizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – The workflow visualizer in AWX'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_05_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.17 – The workflow visualizer in AWX
  prefs: []
  type: TYPE_NORMAL
- en: Using this tool, we can powerfully build up multi-step workflows, taking intelligent
    action after each stage, depending on whether it succeeded or not.
  prefs: []
  type: TYPE_NORMAL
- en: Everything we have discussed so far is great if you are interacting directly
    with the AWX GUI. However, what happens if you have set up unattended actions
    to run, but wish to be notified about their results (especially if they fail)?
    Equally, how can you notify a team if someone runs a potentially service-impacting
    change? You'll find the answers to these questions in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Notifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you examined the AWX user interface, you will have noticed that most screens
    have a tab called **Notifications**. AWX has the ability to integrate with many
    popular communication platforms, such as Slack, IRC, Pagerduty, and even good
    old-fashioned email (this list is not exhaustive). Once the configuration for
    a given platform is defined through the user interface, notifications can then
    be sent when specific events occur. These events will vary according to the item
    you are wishing to generate notifications from. For example, with job templates,
    you can choose to be notified when the job starts, when it succeeds, and/or when
    it fails (and any combination of those events). You can generate different notification
    types for different events. For example, you could notify a Slack channel of a
    template being started, but email your ticketing system if the template fails
    to automatically generate a ticket to prompt further investigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, *Figure 5.18* shows our previously configured `Mastery Template`
    set up to email a given recipient list in the event that its execution fails.
    On start, and on success, no notification is given (though this can be turned
    on, of course):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – Setting up email notifications for failed runs of Mastery Template'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_05_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.18 – Setting up email notifications for failed runs of Mastery Template
  prefs: []
  type: TYPE_NORMAL
- en: All notifications defined in AWX appear in the **Notifications** tab. However,
    they do not have to be added once defined. It is simply up to the user to turn
    the **Start**, **Success**, and **Failure** notifications on or off for each notification
    service.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more way to interact with AWX without using the GUI. This, of course,
    is through the API, which we'll look at in the final part of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this chapter of the book, we have looked at all AWX operations using
    the GUI, as this is probably the easiest and most visual way to explain their
    functions and usage. However, one of the key features of AWX for any enterprise
    is the API, which is a complete feature that enables us to perform all of the
    operations completed here (and more) without having to touch the UI.
  prefs: []
  type: TYPE_NORMAL
- en: This is an incredibly powerful tool, especially with regards to integration
    into larger workflows. For example, you could hook AWX into your CI/CD pipeline
    using the API, and upon a successful build of your code, you could trigger an
    AWX job to deploy a test environment to run it in (and even deploy the code to
    that environment). Similarly, you can automatically create job templates, inventory
    items, and all other aspects of the configuration through the API.
  prefs: []
  type: TYPE_NORMAL
- en: The API itself is browsable, and you can access it by adding `/api` or `/api/v2`
    to the URL of your AWX server (for version 1 and version 2 of the API respectively).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although normally you would integrate these into a larger application or workflow,
    it is easy to demonstrate the API usage with `curl`. For example, suppose we want
    to retrieve a list of the inventories defined in our AWX server. We can do that
    with a command like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Naturally, you will need to substitute your credentials into the `--user` parameter
    and the correct FQDN for your AWX server into the URL in the command. Once done,
    this command will retrieve details of all the inventories defined in AWX in JSON
    format – you don't need to pipe this through Python's `json.tool` tool – it just
    makes the output more readable for a human!
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we could launch our mastery example template through the API. All
    configuration elements of AWX have a unique numeric ID associated with them that
    we must use to access them. Thus, for example, let''s retrieve the list of job
    templates from AWX using the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking through the JSON output, I can see that our `Mastery Template` has
    an `id` of `12` on my system. Also, because I set up a survey on this template
    for one of the earlier examples in this chapter, the JSON output is telling me
    that I need to specify some variables before the template can be launched. There
    are a number of items in the output of the `GET` query that might need to be set
    before a playbook can be launched, so it is worth reviewing them carefully before
    putting your `API POST` together. *Figure 5.19* shows the output from the `API
    GET` call, displaying the variables that must be set before the template can be
    launched:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – Partial output from the API GET call on job template 12'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_05_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.19 – Partial output from the API GET call on job template 12
  prefs: []
  type: TYPE_NORMAL
- en: 'This variable data can be specified using the `extra_vars` data field in the
    API, so we can craft an API call like the following to launch the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this command will include use details such as the job ID so
    that we can query the job run if we wish to. In my example, the job ID returned
    was `10`, so I can query the status of this job (including whether it was successful
    or not) with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even retrieve the output of the `ansible-playbook` command from the
    job run, using an API call like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Although you are unlikely to be driving the API using `curl` in a production
    environment, it is hoped that these simple, repeatable examples will help to get
    you started on your journey of AWX integration using the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is even a CLI available for AWX that can be installed through Python''s
    `pip` packaging system. This CLI uses a naming and command structure that is consistent
    with the HTTP-based API we have discussed in this section, and given the similarity,
    this is therefore left as an optional exercise. However, to get you started, the
    official documentation for the AWX CLI can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible-tower/latest/html/towercli/index.html](https://docs.ansible.com/ansible-tower/latest/html/towercli/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Although the documentation mentions Ansible Tower, it is just as valid when
    used with the open-source AWX software.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That concludes our whistle-stop tour of AWX. In this chapter, we showed that
    AWX is straightforward to install and configure once you know the core four-step
    process involved. We also showed how to build on this process with features such
    as surveys, notifications, and workflows.
  prefs: []
  type: TYPE_NORMAL
- en: You learned that AWX is straightforward to install (in fact, it installs with
    Ansible!), and how to add SSL encryption to it. You then gained an understanding
    of how the platform works, and how to go from a fresh install to building out
    projects, inventories, credentials, and templates to run Ansible jobs. You learned
    that there are many additional features that build on this. These were covered
    in the final part of this chapter in order to help you build a robust enterprise
    management system for Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will return to the Ansible language and look at the
    benefits of the Jinja2 templating system.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWX runs either in standalone Docker containers or Kubernetes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) True
  prefs: []
  type: TYPE_NORMAL
- en: b) False
  prefs: []
  type: TYPE_NORMAL
- en: AWX provides which of the following to enterprises looking to manage their automation
    processes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) A web UI
  prefs: []
  type: TYPE_NORMAL
- en: b) A feature-complete API
  prefs: []
  type: TYPE_NORMAL
- en: c) Source control integration
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the above
  prefs: []
  type: TYPE_NORMAL
- en: AWX directly supports the secure management of credentials for automation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) True
  prefs: []
  type: TYPE_NORMAL
- en: b) False
  prefs: []
  type: TYPE_NORMAL
- en: AWX provides a graphical development environment for creating and testing Ansible
    playbooks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) True
  prefs: []
  type: TYPE_NORMAL
- en: b) False
  prefs: []
  type: TYPE_NORMAL
- en: AWX can schedule unattended jobs to run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) True
  prefs: []
  type: TYPE_NORMAL
- en: b) False
  prefs: []
  type: TYPE_NORMAL
- en: In AWX, the pre-configured parameter set for an `ansible-playbook` run is known
    as what?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Job Configuration
  prefs: []
  type: TYPE_NORMAL
- en: b) Ansible Template
  prefs: []
  type: TYPE_NORMAL
- en: c) Job Template
  prefs: []
  type: TYPE_NORMAL
- en: d) Ansible Run
  prefs: []
  type: TYPE_NORMAL
- en: AWX can have its configuration divided between different parts of a business
    through the creation of which of the following?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Teams
  prefs: []
  type: TYPE_NORMAL
- en: b) Organizations
  prefs: []
  type: TYPE_NORMAL
- en: c) Deploying a second AWX server
  prefs: []
  type: TYPE_NORMAL
- en: d) Groups
  prefs: []
  type: TYPE_NORMAL
- en: In AWX, it is possible to tell which of the following?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) When a playbook was run
  prefs: []
  type: TYPE_NORMAL
- en: b) Who ran the playbook
  prefs: []
  type: TYPE_NORMAL
- en: c) What parameters were passed to the playbook
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the above
  prefs: []
  type: TYPE_NORMAL
- en: User-friendly variable definition in AWX is provided via which feature?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Forms
  prefs: []
  type: TYPE_NORMAL
- en: b) e-Forms
  prefs: []
  type: TYPE_NORMAL
- en: c) extra vars
  prefs: []
  type: TYPE_NORMAL
- en: d) Surveys
  prefs: []
  type: TYPE_NORMAL
- en: Projects in AWX are made up of what?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Logical teams of users
  prefs: []
  type: TYPE_NORMAL
- en: b) Logical folders of playbooks
  prefs: []
  type: TYPE_NORMAL
- en: c) A task management system
  prefs: []
  type: TYPE_NORMAL
- en: d) Logical collections of roles
  prefs: []
  type: TYPE_NORMAL
