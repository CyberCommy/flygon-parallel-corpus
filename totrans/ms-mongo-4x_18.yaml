- en: Fault Tolerance and High Availability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will try to fit in the information that we didn't manage
    to discuss in the previous chapters, and we will place emphasis on some other
    topics. Throughout the previous 13 chapters, we have gone all the way from the
    basic concepts to effective querying, to administration and data management, to
    scaling and high availability concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss how our application design should be accommodating and proactive
    with regard to our database needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Day-to-day operations are another area that we will discuss, including tips
    and best practices that can help us to avoid nasty surprises down the line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In light of recent attempts by ransomware to infect and hold MongoDB servers
    hostage, we will offer more tips on security.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we will try to sum up the advice that's been given in a series of checklists
    that should be followed to ensure that the best practices are properly set up
    and followed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will describe some useful tips for application design that
    we did not cover or emphasize enough in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Schema-less doesn't mean schema design-less
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A big part of MongoDB's success can be attributed to the increased popularity
    of ORM/ODMs. Especially with languages like JavaScript and the MEAN stack, the
    developer can use JavaScript from the frontend (Angular/Express) to the backend
    (Node.js) to the database (MongoDB). This is frequently coupled with an ODM that
    abstracts away the internals of the database, mapping collections to Node.js models.
  prefs: []
  type: TYPE_NORMAL
- en: The major advantage is that developers don't need to fiddle with the database
    schema design, as this is automatically provided by the ODM. The downside is that
    database collections and schema designs are left up to the ODM, which does not
    have the business domain knowledge of different fields and access patterns.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of MongoDB and other NoSQL-based databases, this boils down to making
    architectural decisions based not only on immediate needs, but also on what needs
    to be done down the line. On an architectural level, this may mean that instead
    of a monolithic approach, we can combine different database technologies for our
    diverse and evolving needs by using a graph database for graph-related querying,
    a relational database for hierarchical, unbounded data, and MongoDB for JSON retrieval,
    processing, and storage.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, many of MongoDB's successful use cases come from the fact that it's
    not being used as a one-size-fits-all solution, but only for the use cases that
    make sense.
  prefs: []
  type: TYPE_NORMAL
- en: Read performance optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss some tips for optimizing read performance.
    Read performance is directly correlated to the number of queries and their complexity.
    Performing fewer queries in a schema without complex nested data structures and
    arrays will generally result in better read performance. However, many times,
    optimizing for read performance can mean that the write performance will degrade.
    This is something to keep in mind and continuously measure when we are making
    performance optimizations in MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Consolidating read querying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should aim to have as few queries as possible. This can be achieved by embedding
    information into sub-documents instead of having separate entities. This can lead
    to an increased write load, as we have to keep the same data points in multiple
    documents and maintain their values everywhere when they change in one place.
  prefs: []
  type: TYPE_NORMAL
- en: 'The design considerations here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The read performance benefits from data duplication/denormalization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data integrity benefits from data references (`DBRef` or in-application
    code, using an attribute as a foreign key).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should denormalize, especially if our read/write ratio is too high (our data
    rarely changes values, but it gets accessed several times in between) if our data
    can afford to be inconsistent for brief periods of time, and, most importantly,
    if we absolutely need our reads to be as fast as possible and are willing to pay
    the price in consistency/write performance.
  prefs: []
  type: TYPE_NORMAL
- en: The most obvious candidates for fields that we should denormalize (embed) are
    dependent fields. If we have an attribute or a document structure that we don't
    plan to query on its own, but only as part of a contained attribute/document,
    then it makes sense to embed it, rather than have it in a separate document/collection.
  prefs: []
  type: TYPE_NORMAL
- en: Using our MongoDB `books` example, a book can have a related data structure
    that refers to a review from a reader of the book. If our most common use case
    is showing a book along with its associated reviews, then we can embed reviews
    into the book document.
  prefs: []
  type: TYPE_NORMAL
- en: The downside to this design is that when we want to find all of the book reviews
    by a user, this will be costly, as we will have to iterate all of the books for
    the associated reviews. Denormalizing users and embedding their reviews can be
    a solution to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: A counterexample is data that can grow unbounded. In our example, embedding
    reviews along with heavy metadata can lead to an issue if we hit the 16 MB document
    size limit. A solution is to distinguish between data structures that we expect
    to grow rapidly and those that we don't, and to keep an eye on their sizes through
    monitoring processes that query our live dataset at off-peak times and reporting
    on attributes that may pose a risk down the line.
  prefs: []
  type: TYPE_NORMAL
- en: Don't embed data that can grow unbounded.
  prefs: []
  type: TYPE_NORMAL
- en: When we embed attributes, we have to decide whether we will use a sub-document
    or an enclosing array.
  prefs: []
  type: TYPE_NORMAL
- en: When we have a unique identifier to access the sub-document, we should embed
    it as a sub-document. If we don't know exactly how to access it or we need the
    flexibility to be able to query for an attribute's values, then we should embed
    it in an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, with our `books` collection, if we decide to embed reviews into
    each book document, we have the following two design options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A book document with an array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A book with an embedded document:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The array structure has the advantage that we can directly query MongoDB for
    all of the reviews with a `rating` greater than `4` through the embedded array
    reviews.
  prefs: []
  type: TYPE_NORMAL
- en: Using the embedded document structure, on the other hand, we can retrieve all
    of the reviews the same way that we would using the array, but if we want to filter
    them, it has to be done on the application side, rather than on the database side.
  prefs: []
  type: TYPE_NORMAL
- en: Defensive coding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More of a generic principle, **defensive coding** refers to a set of practices
    and software designs that ensures the continuing functionality of a piece of software
    under unforeseen circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'It prioritizes code quality, readability, and predictability*. *Readability
    was best explained by John F. Woods in his *comp.lang.c++* post, on September
    24, 1991:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Always code as if the guy who ends up maintaining your code will be a violent
    psychopath who knows where you live. Code for readability."'
  prefs: []
  type: TYPE_NORMAL
- en: Our code should be readable and understandable by humans, as well as by machines.
    With code quality metrics, as derived by static analysis tools, code reviews,
    and bugs reported/resolved, we can estimate the quality of our code base and aim
    for a certain threshold at each sprint, or when we are ready to release. Code
    predictability, on the other hand, means we should always expect results in unexpected
    input and program states.
  prefs: []
  type: TYPE_NORMAL
- en: These principles apply to every software system. In the context of system programming
    using MongoDB, there are some extra steps that we must take to ensure that code
    predictability and, subsequently, quality are measured by the number of resulting
    bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB limitations that will result in a loss of database functionality should
    be monitored and evaluated on a periodic basis, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Document size limit**: We should keep an eye on the collections in which
    we expect to have documents growing the most, running a background script to examine
    document sizes and alert us if we have documents approaching the limit (16 MB),
    or if the average size has grown significantly since the last check.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data integrity checks**: If we are using denormalization for read optimization,
    then it''s a good practice to check for data integrity. Through a software bug
    or a database error, we may end up with inconsistent duplicate data among collections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Schema checks**: If we don''t want to use the document validation feature
    of MongoDB, but rather we want a lax document schema, it''s still a good idea
    to periodically run scripts to identify fields that are present in our documents,
    and their frequencies. Then, along with relative access patterns, we can identify
    whether these fields can be identified and consolidated. This is mostly useful
    if we are ingesting data from another system wherein data input changes over time,
    which may result in a wildly varying document structure on our end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data storage checks**: This mostly applies when using MMAPv1, where document
    padding optimization can help performance. By keeping an eye on document size
    relative to its padding, we can make sure that our size-modifying updates won''t
    incur a move of the document in physical storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the basic checks that we should implement when defensively coding
    for our MongoDB application. On top of this, we need to defensively code our application-level
    code to make sure that when failures occur in MongoDB, our application will continue
    operating—perhaps with degraded performance, but still operational.
  prefs: []
  type: TYPE_NORMAL
- en: An example of this is replica set failover and failback. When our replica set
    master fails, there is a brief period to detect this failure and the new master
    is elected, promoted, and operational. During this brief period, we should make
    sure that our application continues to operate in read-only mode, instead of throwing
    500 errors. In most cases, electing a new primary is done in seconds, but in some
    cases we may end up in the minority end of a network partition and unable to contact
    a master for a long period of time. Similarly, some secondaries may end up in
    a recovering state (for example, if they fall way behind the master in replication);
    our application should be able to pick a different secondary in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Designing for secondary access is one of the most useful examples of defensive
    coding. Our application should weigh between fields that can only be accessed
    by the primary to ensure data consistency and fields that are okay to be updated
    in near real-time, instead of in real time, in which case we can read these from
    secondary servers. By keeping track of replication lag for our secondaries by
    using automated scripts, we can have a view of our cluster's load and how safe
    it is to enable this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Another defensive coding practice is to always perform writes with journaling
    on. Journaling helps to recover from server crashes and power failures.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we should aim to use replica sets as early as possible. Other than
    the performance and workload improvements, they help us to recover from server
    failures.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring integrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of this adds up to a greater adoption of monitoring tools and services.
    As much as we can script some of them, integrating with cloud and on-premise monitoring
    tools can help us to achieve more in a smaller amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The metrics that we keep a track of should do one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Detect failures**: Failure detection is a reactive process, where we should
    have clear protocols in place for what happens when each of the failure detection
    flags goes off. For example, what should the recovery steps be if we lose a server,
    a replica set, or a shard?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prevent failures**: Failure prevention, on the other hand, is a proactive
    process, designed to help us catch problems before they become a potential source
    of failure in the future. For example, CPU/storage/memory usage should be actively
    monitored with yellow and red thresholds, and clear processes should be put in
    place as to what we should do in the event that we reach either threshold.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When connecting to our production MongoDB servers, we want to make sure that
    our operations are as lightweight as possible (and are certainly non-destructive)
    and do not alter the database state in any sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two useful utilities that we can chain to our queries are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `query` will only take up to `999` ms, and will then return an exceeded
    time limit error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Our `query` will examine `1000` documents at the most, in order to find results
    and then return (no error raised).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we can, we should bind our queries by time or document result size
    to avoid running unexpectedly long queries that may affect our production database.
    A common reason for accessing our production database is troubleshooting degraded
    cluster performance. This can be investigated via cloud monitoring tools, as we
    described in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The `db.currentOp()` command, through the MongoDB shell, will give us a list
    of all of the current operations. We can then isolate the ones that have large
    `.secs_running` values and identify them through the `.query` field.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to kill an in-progress operation that takes a long time, we need
    to note the value of the `.opid` field and pass it on `db.killOp(<opid>)`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it's important to recognize (from an operational standpoint) that everything
    may go wrong. We must have a backup strategy in place that is implemented consistently.
    Most importantly, we should practice restoring from backup to make sure that it
    works as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the recent waves of ransomware that were locking down unsecured MongoDB
    servers, asking for ransom payments in cryptocurrency from the administrators
    to unlock the MongoDB servers, many developers have become more security-conscious.
    Security is one of the items on a checklist that we, as developers, may not prioritize
    highly enough, due to the optimistic belief that it won't happen to us. The truth
    is, in the modern internet landscape, everyone can be a target of automated or
    directed attacks, so security should always be taken into account, from the early
    stages of the design to after production deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling security by default
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every database (other than local development servers, perhaps) should be set
    up with the following in the `mongod.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: SSL should always be enabled, as we described in the relevant [Chapter 8](687220c0-264a-4edb-9e04-c10b0c180766.xhtml),
    *Monitoring, Backup, and Security*.
  prefs: []
  type: TYPE_NORMAL
- en: 'REST and HTTP status interfaces should be disabled by adding the following
    lines to `mongod.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Access should be restricted to only communication between application servers
    and MongoDB servers, and only in the interfaces that are required. Using `bind_ip`,
    we can force MongoDB to listen to specific interfaces, instead of the default
    binding to every interface-available behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Isolating our servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We should secure our infrastructure perimeter with AWS VPC or the equivalent
    from the cloud provider of our choice. As an extra layer of security, we should
    isolate our servers in a cloud of their own, only allowing external connections
    to reach our application servers and never allowing them to directly connect to
    our MongoDB servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d29f3744-2d98-4abf-81d5-786fc70bb182.png)'
  prefs: []
  type: TYPE_IMG
- en: We should invest in role-based authorization. Security lies not only in protecting
    against data leaks caused by external actors, but also in making sure that internal
    actors have the appropriate levels of access to our data. Using role-based authorization
    at the MongoDB level, we can make sure that our users have the appropriate levels
    of access.
  prefs: []
  type: TYPE_NORMAL
- en: Consider Enterprise Edition for large deployments. Enterprise Edition offers
    some convenient features concerning security, more integrations with well-known
    tools, and should be evaluated for large deployments, with an eye for changing
    needs as we transition from a single replica set to an enterprise-complex architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Checklists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Operations require the completion of many tasks and complexity. A good practice
    is to keep a set of checklists with all of the tasks that need to be performed
    and their order of significance. This will ensure that we don''t let something
    slip through. A deployment and security checklist, for example, could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hardware**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage**: How much disk space is needed per node? What is the growth rate?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage technology**: Do we need SSD versus HDD? What is the throughput of
    our storage?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RAM**: What is the expected working set? Can we fit it in the RAM? If not,
    are we going to be okay with SSD instead of HDD? What is the growth rate?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CPU**: This usually isn''t a concern for MongoDB, but it could be if we planned
    to run CPU-intensive jobs in our cluster (for example, aggregation or `MapReduce`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network**: What are the network links between servers? This is usually trivial
    if we are using a single data center, but it can get complicated if we have multiple
    data centers and/or offsite servers for disaster recovery.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable auth.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable SSL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable REST/HTTP interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolate our servers (for example, VPC).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization is enabled. With great power comes great responsibility. Make
    sure that the powerful users are the ones that you trust. Don't give potentially
    destructive powers to inexperienced users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A monitoring and operations checklist could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Monitoring**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage of hardware (CPU, memory, storage, and network).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Health checks, using Pingdom or an equivalent service to make sure that we get
    a notification when one of our servers fails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Client performance monitoring: Integrating periodic mystery shopper tests using
    service as a customer in a manual or automated way, from an end-to-end perspective,
    in order to find out if it behaves as expected. We don''t want to learn about
    application performance issues from our customers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use MongoDB Cloud Manager monitoring; it has a free tier, it can provide useful
    metrics, and it is the tool that MongoDB engineers can take a look at if we run
    into issues and need their help, especially as a part of support contracts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disaster recovery**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Evaluate the risk**: What is the risk, from a business perspective, of losing
    MongoDB data? Can we recreate this dataset? If yes, how costly is it in terms
    of time and effort?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Devise a plan**: Have a plan for each failure scenario, with the exact steps
    that we need to take in case something happens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test the plan**: Having a dry run of every recovery strategy is as important
    as having one. Many things can go wrong in disaster recovery, and having an incomplete
    plan (or one that fails in each purpose) is something that we shouldn''t allow
    to happen under any circumstance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Have an alternative to the plan**: No matter how well we devise a plan and
    test it, anything can go wrong during planning, testing, or execution. We need
    to have a backup plan for our plan, in case we can''t recover our data using plan
    A. This is also called plan B, or the last resort plan. It doesn''t have to be
    efficient, but it should alleviate any business reputation risks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load test**: We should make sure that we load test our application end to
    end before deployment, with a realistic workload. This is the only way to ensure
    that our application will behave as expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following links for further information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://mo.github.io/2017/01/22/mongo-db-tips-and-tricks.html](http://mo.github.io/2017/01/22/mongo-db-tips-and-tricks.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://studio3t.com/whats-new/tips-for-sql-users-new-to-mongodb/](https://studio3t.com/whats-new/tips-for-sql-users-new-to-mongodb/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.hostreview.com/blog/170327-top-7-mongodb-performance-tips-must-know](https://www.hostreview.com/blog/170327-top-7-mongodb-performance-tips-must-know)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://groups.google.com/forum/#!msg/comp.lang.c++/rYCO5yn4lXw/oITtSkZOtoUJ](https://groups.google.com/forum/#!msg/comp.lang.c++/rYCO5yn4lXw/oITtSkZOtoUJ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered some topics that were not detailed in previous chapters.
    It is important to apply the best practices according to our workload requirements.
    Read performance is usually what we want to optimize for; that is why we discussed
    consolidating queries and the denormalization of our data.
  prefs: []
  type: TYPE_NORMAL
- en: Operations are also important when we go from deployment to ensuring the continuous
    performance and availability of our cluster. Security is something that we often
    don't think about until it affects us. That's why we should invest the time beforehand
    to plan and make sure that we have the measures in place to be sufficiently secure.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we introduced the concept of checklists to keep track of our tasks
    and to make sure that we complete all of them before major operational events
    (deployment, cluster upgrades, moving to sharding from replica sets, and so on).
  prefs: []
  type: TYPE_NORMAL
