- en: Generating newMessage and newLocationMessage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成newMessage和newLocationMessage
- en: In the previous chapter, we looked into Socket.io and WebSockets, to enable
    two-way communication between the server and the client. In this chapter, we'll
    discuss how to generate text and geolocation messages. We looked into generating
    `newMessage` and `newLocationMessage` objects and then writing test case for both
    type of messages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们研究了Socket.io和WebSockets，以实现服务器和客户端之间的双向通信。在本章中，我们将讨论如何生成文本和地理位置消息。我们研究了生成`newMessage`和`newLocationMessage`对象，然后为两种类型的消息编写了测试用例。
- en: Message generator and tests
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息生成器和测试
- en: In this section you are going to break out some functionality currently in `server.js`
    into a separate file, and we're also going to set up our test suite so that we
    can verify if those utility functions are working as expected.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将把`server.js`中的一些功能分解成一个单独的文件，并且我们还将设置我们的测试套件，以便我们可以验证这些实用函数是否按预期工作。
- en: For the moment, our goal is going to be to create a function that helps us generate
    the `newMessage` object. Instead of having to define the object every single time,
    we'll simply pass in two arguments to a function, the name and the text, and it'll
    generate the object so we don't have to do that work.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的目标是创建一个帮助我们生成`newMessage`对象的函数。我们将不再需要每次都定义对象，而是只需将两个参数传递给一个函数，即名称和文本，它将生成对象，这样我们就不必做这项工作了。
- en: Generating the newMessage object using the utility function
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用实用函数生成newMessage对象
- en: To generate `newMessage`, we are going to make a separate file that we load
    into `server.js` with a method we call instead of defining the object. Inside
    the `server` folder, we'll make a new directory called `utils`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成`newMessage`，我们将制作一个单独的文件，然后将其加载到`server.js`中，而不是定义对象。在`server`文件夹中，我们将创建一个名为`utils`的新目录。
- en: 'Inside `utils` we''ll make a file called `message.js`. This will store our
    utility functions related to messaging, and in our case, we''ll make a new one
    called `generateMessage`. Let''s make a variable called `generateMessage`. This
    is going to be a function and will take the two arguments I talked about earlier,
    `from` and `text`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在`utils`中，我们将创建一个名为`message.js`的文件。这将存储与消息相关的实用函数，而在我们的情况下，我们将创建一个名为`generateMessage`的新函数。让我们创建一个名为`generateMessage`的变量。这将是一个函数，并将使用我之前提到的两个参数，`from`和`text`：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It will then return an object just like the objects we pass in as the second
    argument to emit in `server.js`. Now all we need to do is `return` an object,
    specifying `from` as the from argument, `text` as the text argument, and `createdAt`,
    which is going to get generated by calling a `new Date` and calling its `getTime`
    method:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它将返回一个对象，就像我们在`server.js`中作为第二个参数传递给emit的对象一样。现在我们需要做的就是`return`一个对象，指定`from`作为from参数，`text`作为text参数，以及`createdAt`，它将通过调用`new
    Date`并调用其`getTime`方法来生成：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With this in place our utility function is now done. All we need to do is export
    it down below, `module.exports`. We''ll set that equal to an object that has a
    `generateMessage` property equal to the `generateMessage` variable we have defined:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的实用函数现在已经完成。我们需要做的就是在下面导出它，`module.exports`。我们将把它设置为一个对象，该对象具有一个`generateMessage`属性，该属性等于我们定义的`generateMessage`变量：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We'll eventually be able to integrate this into `server.js`, but before we do
    that let's go ahead and write some test cases to make sure it works as expected.
    This means we will need to install Mocha, and we'll also need to install the Expect
    assertion library. Then we'll set up our `package.json` scripts and write the
    test case.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们将能够将其集成到`server.js`中，但在这样做之前，让我们先编写一些测试用例，以确保它按预期工作。这意味着我们需要安装Mocha，并且还需要安装Expect断言库。然后我们将设置我们的`package.json`脚本并编写测试用例。
- en: Writing test cases
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试用例
- en: 'First up, inside the Terminal, we''re going to install, using `npm install`,
    two modules. We need Expect, which is our assertion library, `@1.20.2`, and `mocha`
    to run our test suite at version `5.0.5`. We''ll then use the `--save-dev` flag
    to add these as development dependencies:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在终端中，我们将使用`npm install`安装两个模块。我们需要Expect，这是我们的断言库，版本为`@1.20.2`，以及`mocha`来运行我们的测试套件，版本为`5.0.5`。然后，我们将使用`--save-dev`标志将它们添加为开发依赖项：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's go ahead and run this command, and once it's done we can move into `package.json`
    and set up those test scripts.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个命令，一旦完成，我们就可以进入`package.json`并设置这些测试脚本。
- en: They're going to be identical to the ones we used in the last project in the
    previous chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它们将与我们在上一章的上一个项目中使用的测试用例相同。
- en: 'Inside `package.json` we now have our two `dev` dependencies, and inside the
    scripts we can get started by removing the old test script. We''ll add those two
    scripts, `test` and `test-watch`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`中，我们现在有两个`dev`依赖项，在脚本中，我们可以通过删除旧的测试脚本来开始。我们将添加这两个脚本，`test`和`test-watch`：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Adding the test-watch script
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加test-watch脚本
- en: 'Let''s go ahead and fill out the basics first. We''ll set `test` equal to an
    empty string for the moment, and `test-watch`. The `test-watch` script, as we
    know, simply calls `nodemon`, calling the `npm test` script, `nodemom --exec`,
    then `npm test` inside single quotes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先填写基础知识。我们将把`test`设置为空字符串，然后是`test-watch`。我们知道，`test-watch`脚本只是调用`nodemon`，调用`npm
    test`脚本，`nodemom --exec`，然后在单引号内调用`npm test`：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will get the job done. Now when we run `nodemon` here, we're actually running
    the globally-installed `nodemon`; we can also install it locally to fix that.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这将完成任务。现在当我们在这里运行`nodemon`时，我们实际上正在运行全局安装的`nodemon`；我们也可以在本地安装它来修复这个问题。
- en: 'To get that done, all we''re going to do is run `npm install nodemon`, add
    the most recent version, which is version `1.17.2`, and use the `--save-dev` flag
    to install it:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我们要做的就是运行`npm install nodemon`，添加最新版本，即版本`1.17.2`，并使用`--save-dev`标志进行安装：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now when we install `nodemon` like this, our application no longer relies on
    that global `nodemon` installation. So if someone else grabs this from GitHub,
    they're going to be able to get started without needing to install anything globally.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们像这样安装 `nodemon` 时，我们的应用程序不再依赖于全局的 `nodemon` 安装。因此，如果其他人从 GitHub 获取这个应用程序，他们将能够开始而无需全局安装任何东西。
- en: Adding the test script
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加测试脚本
- en: Next up is the `test` script. It first has to set up those environment variables
    that we're going to be configuring; we'll do that later. For now, all we're going
    to do is run `mocha`, passing in the pattern for the files we want to test.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `test` 脚本。它首先必须设置我们将要配置的环境变量；我们稍后会这样做。现在，我们要做的只是运行 `mocha`，传入我们要测试的文件的模式。
- en: 'The files we want to test are in that `server` directory. They could be in
    any subdirectory, so we''ll use `**`, and the files, regardless of their name,
    are going to end in `test.js`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要测试的文件在 `server` 目录中。它们可以在任何子目录中，所以我们将使用 `**`，而文件，无论它们的名称如何，都将以 `test.js`
    结尾：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this in place, we are done. We can now run our test suite.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们就完成了。现在我们可以运行我们的测试套件。
- en: Running the test suite for the message utility
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行消息实用程序的测试套件
- en: 'Over in the Terminal, if I run `npm test`, all we''re going to see is that
    we have zero tests in place:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，如果我运行 `npm test`，我们将看到的是我们没有任何测试：
- en: '![](img/df69226c-ef6e-4c23-aece-44589f81f192.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df69226c-ef6e-4c23-aece-44589f81f192.png)'
- en: 'Here we have the `server-test` file globbing pattern; it could not resolve
    any files. We can fix this issue by simply adding a test file. I''m going to add
    a test file for the message utility, `message.test.js`. Now we can go ahead and
    rerun the `npm test` command. This time around it does indeed find a file and
    we see we have zero passing tests, which is a great starting point:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有 `server-test` 文件的 globbing 模式；它无法解析任何文件。我们可以通过简单地添加一个测试文件来解决这个问题。我将为消息实用程序添加一个测试文件，`message.test.js`。现在我们可以继续重新运行
    `npm test` 命令。这一次它确实找到了一个文件，我们看到我们没有通过测试，这是一个很好的起点：
- en: '![](img/7f043155-68af-43f7-aae5-66b040c5e59b.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f043155-68af-43f7-aae5-66b040c5e59b.png)'
- en: Inside `message.test.js`, we'll need to add a test for the message function
    we just defined. Now this test is going to verify that the object we get back
    is what we would expect given the parameters we passed in. We'll set up the basic
    structure of the test file together, and you'll write the individual test case.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `message.test.js` 中，我们需要为刚刚定义的消息函数添加一个测试。现在这个测试将验证我们得到的对象是否符合我们根据传入的参数所期望的。我们将一起设置测试文件的基本结构，然后你将编写单个测试用例。
- en: 'First up we need to load in Expect using `var expect = require(''expect'')`.
    This will let us make our assertions about the return value from our `generateMessage`
    function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用 `var expect = require('expect')` 加载 Expect。这将让我们对从我们的 `generateMessage`
    函数返回的值进行断言：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The next thing we''re going to do is add a `describe` block. Here, we''re going
    to add a `describe` block for the function `generateMessage`, and inside the callback
    function we''ll have all of the test cases for that function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要做的是添加一个 `describe` 块。在这里，我们将为函数 `generateMessage` 添加一个 `describe` 块，并在回调函数中添加该函数的所有测试用例：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Before we can actually create a test case and fill it out, we do need to load
    in the module we''re testing. I''ll make a variable and using ES6 destructuring.
    We''re going to pull off `generateMessage`, and then we can go ahead and require
    it using `require`, specifying the local path, `./message`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际创建测试用例并填写之前，我们确实需要加载我们正在测试的模块。我将创建一个变量并使用 ES6 解构。我们将取出 `generateMessage`，然后我们可以使用
    `require` 来引入它，指定本地路径 `./message`：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It''s in the same directory as the test file where we currently are, so there''s
    no reason to do any directory moving. With this in place we can now add the individual
    test case, `it (''should generate the correct message object'')`. This is going
    to be a synchronous test, so there is no need to provide done. All you need to
    do is call `generateMessage` with two values, `from` and `text`. You''re going
    to get the response back, and store the response in variable:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 它与我们当前所在的测试文件相同的目录中，所以没有理由进行任何目录移动。有了这个设置，我们现在可以添加单个测试用例，`it ('should generate
    the correct message object')`。这将是一个同步测试，因此无需提供 done。你只需要调用 `generateMessage` 传入两个值，`from`
    和 `text`。你将得到响应，并将响应存储在变量中：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then you''re going to make some assertions about the response. First up, assert
    that from is correct, assert from matches the value you passed in. You''re also
    going to assert that the text matches up, and lastly you''re going to assert that
    the `createdAt` value is a number:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你将对响应进行一些断言。首先，断言 from 是正确的，断言 from 与你传入的值匹配。你还将断言文本匹配，最后你将断言 `createdAt`
    值是一个数字：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It doesn't matter what number it is; you're going to use the `toBeA` method
    to check the type and assert `createdAt` is number. To get this done, the first
    thing I'll do is define some variables.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它不管是什么数字；你将使用 `toBeA` 方法来检查类型并断言 `createdAt` 是数字。为了完成这个任务，我将首先定义一些变量。
- en: 'To get started I''ll make a from variable to store the from value. I''ll go
    ahead and use `Jen`. I''ll also make a `text` variable to store the text value,
    `Some message`. Now what I want to do is make my final variable, which is going
    to store the response, the `message` that comes back from the `generateMessage`
    function, which is exactly what I''m going to call. I''m going to call `generateMessage`
    passing in the two necessary arguments, the `from` argument and the `text` argument:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将创建一个 from 变量来存储 from 的值。我将使用 `Jen`。我还将创建一个 `text` 变量来存储文本值，`Some message`。现在我想做的是创建我的最终变量，它将存储响应，即从
    `generateMessage` 函数返回的 `message`，这正是我要调用的。我将调用 `generateMessage`，传入两个必要的参数，`from`
    参数和 `text` 参数：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next up, and the final thing, we need to do is make assertions about this object
    that comes back. I''m going to expect that `message.createdAt` is a number using
    `toBeA` and passing in the type `number`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，最后一件事，我们需要对返回的对象进行断言。我期望`message.createdAt`是一个使用`toBeA`和传入类型`number`的数字：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This was the first assertion you needed to make to verify the property is correct.
    Next up we''re going to `expect` that message has certain properties inside it.
    We''re going to do this using the `toInclude` assertion, though you could have
    created two separate statements: one for `message.from` and a separate one for
    `message.text`. All of those are valid solutions. I''ll just use `toInclude` and
    specify some things that message should include:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你需要做的第一个断言，以验证属性是否正确。接下来，我们将期望该消息内部具有某些属性。我们将使用`toInclude`断言来做到这一点，尽管你可以创建两个单独的语句：一个用于`message.from`，另一个用于`message.text`。所有这些都是有效的解决方案。我将只使用`toInclude`并指定消息应该包含的一些内容：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'First up, it should have a `from` property equal to the `from` variable. We
    can go ahead and use ES6 to define that; and the same thing is going to happen
    for `text`, `text` should equal `text` and we''re going to use ES6 to set that
    up. We can even simplify this further using `from, text`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它应该有一个`from`属性等于`from`变量。我们可以继续使用ES6来定义；对于`text`，`text`应该等于`text`，我们将使用ES6来设置。我们甚至可以使用`from,
    text`来进一步简化这个过程：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With this in place our test case is now done and we can go ahead and remove
    these commented outlines, and the final thing you needed to do was run the test
    suite from the Terminal by running `npm test`. When we do it what do we get? We
    get our one test under `generateMessage`, should generate correct message object,
    and it is indeed passing, which is fantastic:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的测试用例现在已经完成，我们可以继续删除这些注释轮廓，你需要做的最后一件事是通过在终端运行`npm test`来运行测试套件。当我们这样做时，我们会得到什么？我们得到了我们在`generateMessage`下的一个测试，应该生成正确的消息对象，它确实通过了，这太棒了：
- en: '![](img/f79e1123-da6d-446d-b698-e5c2eda9b07b.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f79e1123-da6d-446d-b698-e5c2eda9b07b.png)'
- en: Now that we have some tests verifying our function works as expected, let's
    go ahead and integrate it into our application by moving into `server.js` and
    replacing all of the objects we pass to the emit function with calls to our new
    function.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一些测试来验证我们的函数是否按预期工作，让我们继续将其集成到我们的应用程序中，方法是进入`server.js`，并用我们的新函数调用替换传递给emit函数的所有对象。
- en: Integrate the utility function into our application
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将实用函数集成到我们的应用程序中
- en: 'The first step in this process will be to import the function we just created.
    I''m going to do that creating a constant in `server.js`. We''ll use ES6 destructuring
    to grab `generateMessage`, and we''re going to grab it off of a call to `require`.
    Now we''re requiring a local file in a different directory. We''re going to start
    with `./`, go into the `utils` directory since we''re currently in the `server`
    directory, and then grab the file message by specifying it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的第一步是导入我们刚刚创建的函数。我将在`server.js`中创建一个常量来做到这一点。我们将使用ES6解构来获取`generateMessage`，并且我们将从`require`的调用中获取它。现在我们正在要求一个不同目录中的本地文件。我们将从`./`开始，进入`utils`目录，因为我们当前在`server`目录中，然后通过指定文件名`message`来获取它：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we have access to `generateMessage`, and instead of creating these objects
    we can call `generateMessage`. In `socket.emit`, we''re going to replace `Welcome
    to the chat app` and the `Admin` variables with arguments `generateMessage (''Admin'',
    ''Welcome to the chat app'')`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以访问`generateMessage`，而不是创建这些对象，我们可以调用`generateMessage`。在`socket.emit`中，我们将用参数`generateMessage ('Admin',
    'Welcome to the chat app')`替换`Welcome to the chat app`和`Admin`变量：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We have the exact same functionality but now we're using a function to generate
    that object for us, which is going to make scaling that out a lot easier. It's
    also going to make updating what is inside a message much easier as well. Next
    up, we can change the one we have down below for *New user joined*. We're going
    to go ahead and replace this with the call to `generateMessage` as well.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有完全相同的功能，但现在我们使用一个函数来为我们生成该对象，这将使得扩展变得更容易。这也将使得更新消息内部的内容变得更容易。接下来，我们可以更改下面的*New
    user joined*。我们也将用对`generateMessage`的调用来替换这个。
- en: 'Once again this one''s from the `Admin` so the first argument will be the string
    `Admin`, the second argument is the text `New user joined`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这次也是来自`Admin`，所以第一个参数将是字符串`Admin`，第二个参数是文本`New user joined`：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This one is done too, and the final one is the one that actually gets sent
    to the user from a user, which means we have `message.from` and `message.text`;
    those are going to be our arguments. We''re going to call `generateMessage` with
    those two arguments, `message.from`, and `message.text` as the second argument:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个也完成了，最后一个是实际从用户那里发送给用户的，这意味着我们有`message.from`和`message.text`；这些将是我们的参数。我们将使用这两个参数`message.from`和`message.text`调用`generateMessage`作为第二个参数：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With this in place we are done. The last thing left to do for this section
    is test that this is working as expected. I''m going to start up the server using
    `nodemon`, without a space between `node` and `mon`, `server/server.js`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就完成了。这一部分剩下的最后一件事是测试它是否按预期工作。我将使用`nodemon`启动服务器，`node`和`mon`之间没有空格，`server/server.js`：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once the server is up, we can go ahead and test things out by opening up a couple
    of tabs with the Developer Tools open.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器启动，我们可以通过打开几个带有开发者工具的标签页来测试一下。
- en: 'For the first tab I''m going to visit `localhost:3000`. Inside the console
    we should see our new message printing, the object looks the same even though
    it''s now generated by the function, and we can test that everything else is working
    as expected too by opening up a second tab and opening up its Developer Tools:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个标签页，我将访问`localhost:3000`。在控制台中，我们应该看到我们的新消息打印出来，即使它现在是由函数生成的，对象看起来是一样的，我们也可以通过打开第二个标签页并打开其开发者工具来测试其他一切是否按预期工作：
- en: '![](img/1e0c1175-3c4c-4958-a83f-0109b0922d06.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e0c1175-3c4c-4958-a83f-0109b0922d06.png)'
- en: This time around the first tab should see a new message, here we have a `New
    user joined` text, that's still working. If we emit a custom message from this
    second tab, it should show up in the first. I'm going to use the up arrow key
    to run one of our previous `createMessage` event emitters.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，第一个选项卡应该看到一个新消息，这里有一个`New user joined`的文本，仍然有效。如果我们从第二个选项卡发出自定义消息，它应该出现在第一个选项卡中。我将使用上箭头键运行我们之前的`createMessage`事件发射器之一。
- en: 'I''m going to fire off the function, and if I go to the first tab we do indeed
    get the message, which is fantastic:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我将触发这个函数，如果我去第一个选项卡，我们确实会收到消息，这太棒了：
- en: '![](img/adfa80a5-d2de-4918-9ff2-f3a4d95a839e.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/adfa80a5-d2de-4918-9ff2-f3a4d95a839e.png)'
- en: This should work, prints in the first tab and it also prints in the second since
    we're calling `io.emit` as opposed to the broadcast method.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该有效，在第一个选项卡中打印，也会在第二个选项卡中打印，因为我们调用的是`io.emit`而不是广播方法。
- en: 'Now that everything is working, we are done; we can make a commit and wrap
    this section. I''m going to call `git status` from the Terminal. Here we have
    new files as well as modified ones, which means we''re going to want to call `git
    add .`. Next up, we can call `git commit` with a message flag, `create generateMessage
    utility`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都正常了，我们完成了；我们可以提交并结束这一部分。我将从终端调用`git status`。这里我们有新文件和修改过的文件，这意味着我们需要调用`git
    add .`。接下来，我们可以调用`git commit`并使用消息标志，`create generateMessage utility`：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: I'm going to push this up to GitHub and that is it for this one. In the next
    section, we're going to take a look at `Socket.io` acknowledgments.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把这个推送到GitHub，这就是这个部分的全部内容。在下一节中，我们将看一下`Socket.io`的确认。
- en: Event acknowledgements
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件确认
- en: 'In this section you''re going to learn how to use event acknowledgments. That''s
    a fantastic feature inside `Socket.io`. In order to illustrate exactly what they
    are and why you''d ever want to use them, we''re going to quickly run through
    the diagram for the chat app. These are the two events that we actually have in
    our application, if you remember the first one is the newMessage Event, it gets
    emitted by the server and it gets listened to by the client, it sends across the
    from, text, and createdAt properties, all of which are required to render the
    message to the screen:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，你将学习如何使用事件确认。这是`Socket.io`中的一个很棒的功能。为了准确说明它们是什么以及为什么你想要使用它们，我们将快速浏览一下聊天应用程序的图表。这是我们应用程序中实际存在的两个事件，如果你还记得，第一个是newMessage事件，它由服务器发出，并由客户端监听，它发送from、text和createdAt属性，所有这些属性都是必需的，以便将消息呈现到屏幕上。
- en: '![](img/7644a516-1cea-4937-a566-8b47601df728.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7644a516-1cea-4937-a566-8b47601df728.png)'
- en: 'Now the event that we''re going to be updating is the createMessage Event.
    This one gets emitted by the client and listened to by the server:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要更新的事件是createMessage事件。这个事件由客户端发出，服务器监听：
- en: '![](img/c844762f-db12-40b6-b6d6-ff93e3404b20.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c844762f-db12-40b6-b6d6-ff93e3404b20.png)'
- en: Once again we are sending some data across from and text. Now the problem with
    our createMessage Event is that the data flows in one direction. The data comes
    from a form inside the browser. It then gets sent over to the server and the server
    is kind of stuck. Sure, the data might be valid, the from and text fields might
    be correctly set up. In that case, we can emit a newMessage Event, rendering it
    to every browser who's connected to the server, but if the server receives invalid
    data it has no way to let the client know that something went wrong.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次从文本中发送一些数据。现在我们的createMessage事件存在的问题是数据只能单向流动。数据来自浏览器内的表单，然后发送到服务器，服务器就有点卡住了。当然，数据可能是有效的，from和text字段可能设置正确。在这种情况下，我们可以发出newMessage事件，将其呈现给连接到服务器的每个浏览器，但是如果服务器接收到无效数据，它就无法让客户端知道出了什么问题。
- en: 'What we need is a way to acknowledge we got a request and have the option to
    send some data back. In this case we''re going to add an acknowledgment for createMessage.
    If the client emits a valid request with valid from and text properties, we''re
    going to acknowledge it, sending back no error message. If the data sent from
    client to server is invalid we''re going to acknowledge it sending back the errors,
    so the client knows exactly what it needs to do to send a valid request. Now the
    result is going to look a little bit like this, and the data flow from server
    to client is going to be done via a callback:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种确认我们收到请求并有选项发送一些数据的方法。在这种情况下，我们将为createMessage添加一个确认。如果客户端发出有效的请求，并且from和text属性有效，我们将确认它，发送回无错误消息。如果从客户端发送到服务器的数据无效，我们将确认它，发送回错误消息，这样客户端就知道需要做什么才能发送有效的请求。现在结果看起来会有点像这样，服务器到客户端的数据流将通过回调完成：
- en: '![](img/f788065b-0262-41bf-965b-6df284c1d5a8.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f788065b-0262-41bf-965b-6df284c1d5a8.png)'
- en: Your acknowledgment could be anything you like. In our case it could be was
    the message data valid? If you're creating an email application, you might only
    send the acknowledgement back to the client when the email was successfully sent.
    You don't need to send data, which is what we're going to do when valid data is
    sent across the pipeline. We're simply going to say, hey we got that message,
    everything's good to go, and the client can respond to that.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你的确认可以是任何你喜欢的。在我们的情况下，它可能是消息数据有效吗？如果你正在创建一个电子邮件应用程序，你可能只在成功发送电子邮件时向客户端发送确认。当有效数据通过管道发送时，你不需要发送数据，这就是当有效数据发送时我们要做的。我们只需要说，嘿，我们收到了那条消息，一切都很顺利，客户端可以对此做出响应。
- en: Now that we've gone through this, let's go ahead and implement it into our application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经完成了这一部分，让我们继续将其实现到我们的应用程序中。
- en: Setting up acknowledgements
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置确认
- en: Setting up acknowledgments really isn't that bad if you already have a listener
    in place. All you have to do is make a quick change to the listener and a quick
    change to the emitter, and everything will work as expected.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有一个监听器，设置确认真的不难。你只需要快速更改监听器和发射器，一切都会按预期工作。
- en: Now in this case, the listener happens to be on the server and the emitter is
    going to be on the client, but acknowledgments also work in the other direction.
    I can emit an event from the server and I can acknowledge it from the client.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这种情况下，监听器恰好在服务器上，发射器将在客户端上，但确认也可以在另一个方向上工作。我可以从服务器发射一个事件，并且可以在客户端上确认它。
- en: 'In order to set this up we are going to emit a `createMessage` event over inside
    `index.js` using `socket.emit`, and we''re going to pass in the same arguments
    we would otherwise. The first one is the event name, `createMessage`, and we''re
    going to pass in some valid data, an object with those two properties. We can
    set `from` equal to something like `Frank`, and we can set a `text` property equal
    to something like `Hi`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置这个，我们将使用`socket.emit`在`index.js`中发射一个`createMessage`事件，并且我们将传递相同的参数。第一个是事件名称，`createMessage`，然后我们将传递一些有效的数据，一个具有这两个属性的对象。我们可以将`from`设置为`Frank`，并且我们可以将`text`属性设置为`Hi`：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now with this in place we have a standard event emitter and a standard event
    listener. I can go ahead and start up the app using `nodemon` and we can make
    sure everything is working as expected, `nodemon server/server.js`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了这个，我们有了一个标准的事件发射器和一个标准的事件监听器。我可以继续使用`nodemon`启动应用程序，确保一切都按预期工作，`nodemon
    server/server.js`：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once the server is up we can visit it in the browser, I''m going to open up
    the Developer Tools as well. Then we''re going to go to `localhost:3000`, and
    you can see over inside of the Terminal we have `createMessage` showing up, and
    we also have `newMessage` showing up here. We have the `newMessage` for our little
    `Welcome to the chat app` greeting, and we have the `newMessage` from `Frank`,
    which we emitted:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器启动，我们可以在浏览器中访问它，我也会打开开发者工具。然后我们将转到`localhost:3000`，你可以看到在终端中我们有`createMessage`显示出来，我们还有`newMessage`显示在这里。我们有`newMessage`用于我们的小`Welcome
    to the chat app`问候语，以及我们从`Frank`那里发射的`newMessage`：
- en: '![](img/98585275-6297-4746-8a5a-459b8ce85cdc.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98585275-6297-4746-8a5a-459b8ce85cdc.png)'
- en: Now the goal here is to send an acknowledgement from the server back to the
    client that we got the data.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这里的目标是从服务器发送一个确认回到客户端，证明我们已经收到了数据。
- en: Sending an acknowledgement from server to the client
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从服务器发送确认到客户端
- en: In order to get this done we have to make a change to both the listener and
    the emitter. If you only make a change to one it is not going to work as expected.
    We're going to start with the event emitter. We want a way to run some code when
    the acknowledgement has been sent from the server back to the client.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我们必须对监听器和发射器进行更改。如果你只对其中一个进行更改，它将不会按预期工作。我们将从事件发射器开始。我们希望在从服务器发送确认到客户端时运行一些代码。
- en: Updating the event emitter
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新事件发射器
- en: 'To send acknowledgement `d=from` server to client, we''re going to add a third
    argument which is going to be a callback function. This function is going to fire
    when the acknowledgement arrives at the client, and we can do anything we like.
    For now we''ll just print using `console.log(''Got it'')`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从服务器向客户端发送确认，我们将添加一个第三个参数，这将是一个回调函数。当确认到达客户端时，这个函数将被触发，我们可以做任何我们喜欢的事情。现在我们只是使用`console.log('Got
    it')`打印：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now this is all we need to do bare-bones style to add an acknowledgement to
    the client.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这就是我们需要做的最基本的事情，为客户端添加一个确认。
- en: Updating the event listener
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新事件监听器
- en: 'It''s also pretty simple on the server; we''re going to add a second argument
    to our `callback` argument list. The first one is still going to be the data that
    was emitted, the second one though is going to be a function that we''re going
    to refer to as `callback`. And we can call it anywhere in `socket.on` to acknowledge
    that we got the request:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上也很简单；我们将在`callback`参数列表中添加第二个参数。第一个仍然是被发射的数据，但第二个将是一个我们将称之为`callback`的函数。我们可以在`socket.on`中的任何地方调用它来确认我们已经收到了请求：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When we call this function, like we're going to call it right here, it is in
    turn going to send an event back to the frontend and it is going to call the function
    as we have it in event emitter in `index.js`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用这个函数时，就像我们现在要调用它一样，它将会向前端发送一个事件，然后会调用`index.js`中的事件发射器中的函数。
- en: 'This means that if I save both files we can play around with acknowledgments
    over in the browser. I''m going to refresh the app, and what do we get? We get
    Got it:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我保存这两个文件，我们可以在浏览器中玩一下确认。我将刷新应用程序，我们会得到什么？我们得到了Got it：
- en: '![](img/8fd062aa-1af4-494f-a8c4-0937594e2184.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fd062aa-1af4-494f-a8c4-0937594e2184.png)'
- en: 'That means our data successfully went to the server; we can prove that by seeing
    the `console.log` statement in the Terminal, the server acknowledged it got the
    data by calling callback:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的数据成功传输到了服务器；我们可以通过在终端中看到`console.log`语句来证明这一点，服务器通过调用回调函数确认它已经收到了数据：
- en: '![](img/1b37a8ea-3715-47c2-ba77-a991b4ce67a3.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b37a8ea-3715-47c2-ba77-a991b4ce67a3.png)'
- en: And in the Developers Tool, Got it prints.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发者工具中，Got it打印出来了。
- en: Now acknowledgments are pretty useful, but they're even more useful when you
    send data back. If the data for the message is invalid, for example, we're probably
    going to want to send some errors back, something we will be doing a little later.
    For now though, we can play around with an acknowledgment by sending anything
    we want back.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在确认是非常有用的，但当你发送数据回去时，它们会更有用。例如，如果消息的数据无效，我们可能会想要发送一些错误回去，这是我们稍后将要做的事情。不过，现在我们可以通过发送任何我们想要的东西来玩一下确认。
- en: 'We send data back by providing one argument to callback, if you want to add
    multiple things simply specify an object adding as many properties as you like.
    In our case, though, we can send a string as the only argument to `callback`.
    I''m going to set my string to `This is from the server`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向回调提供一个参数来发送数据回去，如果你想添加多个东西，只需指定一个对象，添加尽可能多的属性。不过，在我们的情况下，我们可以将一个字符串作为`callback`的唯一参数发送。我将把我的字符串设置为`This
    is from the server`：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This string is going to be passed into the callback and it''s going to end
    up inside of our callback in `index.js`. This means I can create a variable for
    that value, we can call it `data` or anything else you like, and we can print
    it to the screen or do something with it. For now we''re just going to print it
    to the screen:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If I save `index.js`, we can test that everything is working as expected. I'm
    going to go ahead and give the app a refresh, and what do we see?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f9d2613-c564-4e64-b9ba-b9f5599c8cdc.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: We see Got it, meaning we got the acknowledgment, and we see the data, the data
    that was sent from the server to the client.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgments play an important role in real-time applications. Let's go back
    to that email app example for a second, imagine I type in some values like a to
    value and a text value when I send the e-mail. I want to get an acknowledgement
    back that either email sent successfully, or email was not sent, in which case
    I want to know why; maybe it was a form error where I can show some error messages
    to the user or maybe the server was down for maintenance or something like that.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Either way, acknowledgments allow the request listener to send something back
    to the request emitter. Now that we know how to use acknowledgments we're going
    to integrate them into our application. That is coming up in the next section,
    as we add an actual form field to our `index.html` file where users can submit
    new messages and view them.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The message form and jQuery
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section you're going to add a form field to your `index.html` file.
    This is going to render an input field and a button to the screen, and the user
    is going to be able to interact with that as opposed to having to call `socket.emit`
    from the Developer Tools, which is not a sustainable option for real users. This
    only works for us developers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Now in order to get started we're going to be editing `index.html`, then we're
    going to move into `index.js`. We're going to add a listener that's going to wait
    for the form to be submitted, and inside of that listener callback, we are going
    to fire `socket.emit` with the data typed in the field. We're also going to take
    a moment to render all incoming messages to the screen. At the end of this section,
    we'll have a ugly, yet working, chat application.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Using the jQuery library
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now before we do any of that, we are going to be using a library called jQuery
    to do DOM manipulation, which means that we want to be able to do stuff with our
    rendered HTML, but we want to be able to do that from our JavaScript file. We''re
    going to use jQuery to make that a lot easier in terms of cross-browser compatibility.
    To grab this library, we''re going to head over to Google Chrome, go to [jquery.com](http://jquery.com/),
    and you can grab the most recent version. The version is not going to matter for
    here, as we''re using very basic features available in all versions:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ddd476fc-950d-4a25-8a42-dc7c52cf7bc7.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: 'I''ll grab the most recent version 3.3.1\. Then I''ll go ahead and download
    the compressed production version by right-clicking and opening it in a new tab:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9539a35-4ea1-4cf5-baab-348758914222.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: Here we have the actual JavaScript that we want to load in to our application,
    which means we can right-click some sort of empty area, click on Save As, and
    go into our projects folder, `Desktop` | `node-chat-app` | `public` | `js`. Inside
    of `js`, I'm going to create a new directory called `libs`, where we'll store
    third-party JavaScript. We're going to be working with a few more client-side
    JavaScript libraries throughout the section, so it's nice to create a folder to
    stay organized. I'm going to save that in there, close the tab as well as the
    downloads area, and now we can go ahead and load it in to `index.html` and add
    our form.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Adding the form field in index.html
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Down here just between `socket.io` and `index.js` we''re going to add a new
    script tag to load in jQuery. We''ve got to specify that `src` attribute with
    the path to the file `/js/libs`, followed by a forward slash and the file name,
    `jquery-3.3.1.min.js`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，就在`socket.io`和`index.js`之间，我们要添加一个新的脚本标签来加载jQuery。我们必须指定`src`属性，路径是`/js/libs`，后面跟着一个斜杠和文件名`jquery-3.3.1.min.js`：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now let's go ahead and set up our `form` tag; this is going to render our form
    fields to the browser. If you're not familiar with these tags that is perfectly
    fine, simply follow along and I'll explain as we go.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们设置我们的`form`标签；这将把我们的表单字段呈现到浏览器上。如果你对这些标签不熟悉，那没关系，跟着做，我会一边解释。
- en: Setting up the form tag
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置表单标签
- en: 'First step, we need a `form` tag; this creates a form that''s submittable by
    the user. This is exactly what we''re going to use to submit our messages. And
    on this `form` tag we''re going to add one attribute; it''s the `id` attribute
    which lets us give this element a unique identifier, making it really easy to
    target with our JavaScript a bit later on:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步，我们需要一个`form`标签；这会创建一个用户可以提交的表单。这正是我们要用来提交我们的消息的。在这个`form`标签上，我们要添加一个属性；就是`id`属性，它让我们给这个元素一个唯一的标识符，这样以后用JavaScript就很容易定位它：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Remember, we're going to want to add a listener to this element. When the form
    gets submitted, we're going to want to do something in our JavaScript file. Notably
    what we're going to want to do is call `socket.emit`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们要给这个元素添加一个监听器。当表单被提交时，我们要在我们的JavaScript文件中做一些事情。特别是我们要做的是调用`socket.emit`。
- en: 'I''m going to set `id` equal to, inside quotes, `message-form`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我要把`id`设置为，引号内，`message-form`：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that we have our form tag complete we can add some tags inside of it. To
    get started we''re going to add a `button` which is going to appear at the `bottom`
    of the `form`. This `button` on click is going to submit the `form`. I''m opening
    and closing my tag, and just inside I can type whatever text I want to appear
    on the `button`. I''m going to go with `Send`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的表单标签完成了，我们可以在里面添加一些标签。首先，我们要添加一个`button`，它会出现在`form`的`底部`。这个`button`在点击时会提交`form`。我打开并关闭我的标签，然后在里面可以输入任何我想要出现在`button`上的文本。我要选择`Send`：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Adding the text field
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加文本字段
- en: 'Now that we have our `button` in place, the only thing we need to do is add
    the little text field. This is going to be the text field where a user types their
    message. This is going to require us to use an `input tag`, and instead of opening
    and closing an `input` tag, we''re going to use the self-closing syntax:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`button`就位了，唯一需要做的就是添加一个小文本字段。这将是用户输入消息的文本字段。这将需要我们使用一个`input`标签，而不是打开和关闭一个`input`标签，我们将使用自关闭的语法：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Because we don''t need to actually put anything inside it like we do for `button`,
    or for `form`, we are going to be adding quite a few attributes onto input, first
    up, name, we want to give this field a unique name, something like `message` is
    going to get the job done. We also want to go ahead and set the type. There are
    a lot of different types for `input` tags. Types could include something like
    a checkbox, or in our case the type we''re going to use inside quotes is `text`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不需要像`button`或`form`那样在里面放任何东西，我们要给`input`添加很多属性，首先是`name`，我们要给这个字段一个唯一的名称，类似`message`就可以了。我们还要设置类型。`input`标签有很多不同的类型。类型可以包括复选框之类的，或者在我们的情况下，我们要在引号内使用的类型是`text`：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The last attribute we''re going to add to `input` is called `placeholder`.
    We''re going to set this value equal to, inside quotes, a string. This string
    is going to get rendered in the field in a light gray before the user actually
    enters a value. I''m going to tell the user that this is where their `Message`
    goes:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要添加到`input`的最后一个属性叫做`placeholder`。我们要把这个值设置为，引号内，一个字符串。在用户实际输入值之前，这个字符串会以浅灰色呈现在字段中。我要告诉用户这就是他们的`Message`的地方：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With this in place we can actually test out our form's rendering.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们实际上可以测试一下我们表单的渲染。
- en: Testing the form's rendering
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试表单的渲染
- en: 'We can do the testing by starting at the server using `nodemon`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过启动服务器使用`nodemon`来进行测试：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The server is up, I'm going to visit Google Chrome, and go to `localhost:3000`.
    You'll notice something kind of cool, I haven't actually visited the URL yet but
    you can see that the connection has already occurred. Chrome does some lazy loading,
    if it thinks you're going to go to a URL it's actually going to make the request;
    so when I do visit it, it loads even faster. Now if I visit `localhost:3000` what
    do we get?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器已经启动，我要访问Google Chrome，然后转到`localhost:3000`。你会注意到一些很酷的东西，我实际上还没有访问过这个URL，但你可以看到连接已经发生了。Chrome进行了一些懒加载，如果它认为你要去一个URL，它实际上会发出请求；所以当我访问它时，它加载得更快。现在如果我访问`localhost:3000`，我们会得到什么？
- en: '![](img/fa4e5cb4-2f38-4897-99a8-068369aad5ea.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa4e5cb4-2f38-4897-99a8-068369aad5ea.png)'
- en: We get our little form, we can type in a message like `Test` and we can send
    it off. Now by default forms are very old school. If I try to submit this form,
    it's actually going to go through a full page refresh, and then it's going to
    add the data, like our message text, as a query string on the URL. This is not
    what we want to do, we want to run some custom JavaScript on form submit. So we're
    going to attach a custom event listener and override the default behavior. To
    get that done we are going to have to use jQuery, and we're going to need to select
    this `form` field.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了我们的小表单，我们可以输入一个消息，比如`Test`，然后发送出去。现在默认情况下，表单非常老式。如果我试图提交这个表单，它实际上会进行完整的页面刷新，然后会把数据，比如我们的消息文本，作为查询字符串添加到URL上。这不是我们想要做的，我们想要在表单提交时运行一些自定义JavaScript。所以我们要附加一个自定义事件监听器并覆盖默认行为。为了完成这个，我们需要使用jQuery，并且需要选择这个`form`字段。
- en: Using jQuery to select element
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jQuery选择元素
- en: 'Before we dive into `index.js` let''s take a quick moment to talk about how
    we can use `jQuery` to select elements. `jQuery`, which is accessible via the
    `jQuery` variable, takes your selector as its argument. Then, we''re going to
    add a string and we can select our elements. For example, if we want to select
    all the paragraph tags on the screen we would type `p` in the quotes:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: These are really similar to CSS selectors if you're familiar with them, and
    as shown, we've selected our paragraph tag.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'I could also go ahead and select all of the `div` inside my program, or I could
    select elements by ID or class, and that''s what we''re going to do. In order
    to select an element by ID we first start with the pound sign (`#`), then we type
    the name. In our case we have a `form` called `message-form`, and if I fire this
    off we do indeed get that back:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3b37ba2-bfaf-485b-8833-c56ef7191a1e.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: This is going to allow us to add an event listener.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Adding the selector element to index.js
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside `index.js` we''re going to add that exact same selector near the bottom,
    `jQuery`, calling it with our selector `#message-form`. Now we''re going to add
    an event listener, and the event listener is going to look pretty similar to our
    `Socket.io` event listeners. We are going to be calling on, and we are going to
    be providing, those two arguments, the event name inside quotes, `submit`, and
    a `function`, which is going to fire when a user tries to submit the `form`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now unlike our `Socket.io` event listeners, we are going to get one argument
    in the `function`, an `e` event argument, and we are going to need to access this.
    We''re going to need to access this event argument in order to override that default
    behavior that causes the page refresh. Right here we''re going to call `e.preventDefault`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `preventDefault` method prevents the default behavior for the event, and
    by default a submit event goes through that page refresh process.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'We can go ahead and test that everything is working by going into Google Chrome,
    giving the page a refresh. I''m also going to remove the query string from the
    URL. Now we can type in some sort of message like `test`, hit Send, and you can
    see that nothing happens. Nothing happens because we overrode the default behavior,
    all we need to do to make something happen is call `socket.emit` in `index.js`.
    We''re going to emit the `createMessage`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, we''re going to go ahead and provide our data. Now the name `from` field
    for now is just going to be `User` in uppercase. We''re going to leave this as
    anonymous for the moment, although we will be updating that a bit later. Now for
    the text field, this is going to come from the `form`. We''re going to want to
    add a selector and get the value back. Let''s go ahead and do that using `jQuery`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We''re going to call `jQuery` once again, and we''re going to select the input
    in the `index.html` file. We can go ahead and select it by its name, `name="message"`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In order to get that done we''re going to open up brackets in `socket.emit`
    in `index.js`, setting `name` equal to `message`. This is going to select any
    element that has a `name` attribute equal to `message`, which is just our one,
    and we can go ahead and get its value using the `.val` method:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'No semicolon required since we''re inside object creation. With this in place
    we can now go ahead and add our callback function for our acknowledgment. For
    the moment it doesn''t really do anything, but that''s perfectly fine. We have
    to add it in order to fulfill the acknowledgement set up we currently have in
    place:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now that we have our event listener set up, let's go ahead and test this out.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Testing the update event listener
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m going to head back into Chrome, give the page a refresh, type in some
    message like `This should work`, and when we submit the form we should see it
    show up over here as a new message:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/745dcf89-0e1d-46ef-a43d-059101886cec.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: 'I''m going to send it off and you can see that right inside the Terminal, we
    have a user sending `This should work`, and it also shows up in Chrome:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff37e724-ba40-4ed2-8df6-08a1e49a739e.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: 'The same thing is true if I open up a second connection, I''m going to open
    up the Developer Tools so we can see exactly what''s happening behind the scenes.
    I''m going to type some message like `From tab 2`, Send it off:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6c66dd6-dde0-453a-9cd3-8ead6fd3cb2f.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: 'We should see it over in tab 1, and we do:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a22faa0-6e61-4131-87a8-1a2cdf5fcfd6.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: Perfect, everything is working as expected. Now obviously the setup is not complete;
    we want to wipe that form value after we send the message, and we want to take
    care of a few other UI-related things, but for now it is working pretty well.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: With a basic form in place, the second thing we're going to do is render incoming
    messages to the screen. Now once again it is going to look pretty ugly, but it
    will get the job done.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Rendering incoming messages to the screen
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get this done we have to create a place inside our DOM, inside our `index.html`
    file, where we can render the messages. Once again we're going to give this element
    an ID that we can easily access over inside `index.js`, so we can render those
    messages.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Creating an ordered list to render messages
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First up, what we''re going to do is create an ordered list by creating an
    `ol` tag just like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This list is going to let us add items to it, and those items are going to
    be the individual messages. Now we are going to be giving this an `id` attribute.
    I''m going to call `id`, in this case, `messages`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now this is all we need to do in `index.html`, all of the heavy lifting is going
    to happen over inside `index.js`. When a new message comes in we want to add something
    inside of the ordered list so that gets rendered to the screen.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Over inside `index.js` we can get this done by modifying our callback function
    when a new message arrives.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Using jQuery to create element in index.js
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we''re going to do is create a list item, and we''re going
    to do this once again using jQuery. We''re going to make a variable, this variable
    is going to be called `li`, and we''re going to go ahead and use jQuery slightly
    differently:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Rather than using `jQuery` to select an element, we''re going to use `jQuery`
    to create an element, then we can modify that element and add it into the markup,
    making it visible. Inside quotes, we''re going to open and close an `li` tag,
    just like we would inside `index.html`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now that we have this in place we have to go ahead and set its text property,
    I'm going to set `li.text`, by calling `li.text` with the value I want to use.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case the text is going to require us to set up a little template string,
    inside the template string we are going to go ahead and use the data that comes
    back. For now we''re going to use the `from` attribute and the `text` attribute.
    Let''s get started with who it''s `from`, then we''ll add a little colon and a
    space to separate that from the actual `message`, and finally, we''ll inject `message.text`
    at the end:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now at this point we''ve created an element but we haven''t rendered it to
    the DOM. What we''re going to do is use `jQuery` to select that brand new element
    we created, we gave it an ID of `messages`, and we''re going to `append` something
    to it by calling the `append` method:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This is going to add it as its last child, so there''s already three items
    in the list; the newest one will show up below those three as the fourth item
    in our ordered list. All we have to do is call `append` as a function, passing
    in our list item:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: And with this in place we are done. Now if you're not familiar with `jQuery`
    this can be a bit overwhelming, but I promise the techniques we use here we'll
    be using throughout the book. By the end, you'll be much more comfortable selecting
    and creating elements.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Testing the incoming messages
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and test things out over inside Google Chrome. I''m going to
    refresh tab 1, and when I do you can see our two messages, Welcome to the chat
    app shows up and Frank says Hi:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ad84232-822d-4f69-9d40-42a821b92550.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: 'Now Welcome to the chat app should show up. The Frank Hi message is coming
    from `socket.emit` inside `index.js`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can actually go ahead and remove that, we no longer need to automatically
    emit messages since we have a `form` set up to get that done for us. Once again
    we can save the file, refresh the browser and this time around we have a nice
    little setup, Welcome to the chat app:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b6c4e36-7bc6-439f-b553-469dbbe85937.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: 'I''m going to do the same thing for our second tab. This time around we get
    Welcome to the chat app and in the first tab we get New user joined; this is fantastic:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c0342a2-a143-475b-9cd2-ab6b3bd8a2f6.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: 'Now the true test is going to be to send a message from one tab to the other,
    `This should go to tab 2`. I''m going to Send this off, and when I click on this
    button, it''s going to emit the event that''s going to go to the server, and the
    server is going to send it to everyone connected:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5df3ee7d-73a7-4064-b55c-7b55a44b986e.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: 'Here, I can see This should go to tab 2 renders, and over inside my second
    tab we get the message as well:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2bf72bc9-0838-4109-aa72-b64cfd615bf2.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: Now we're not quite done with the UI or the actual user experience; custom names
    and timestamps are coming up, but we do have a fantastic start. We now have a
    form where we can submit messages and we can see all the incoming messages inside
    the browser, which means we do not need to do anything in the Developer Tools
    anymore in terms of emitting or reading our messages. That is it for this one,
    let's go ahead and wrap things up by making a commit now that we have some working
    changes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Making a commit for the message form
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m going to shut down the server, clear the output, and run `git status`
    so we can double-check all our changes; everything looks good here:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c246efa-4f88-4d88-bec4-17b468d7a292.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
- en: 'I''m going to use `git add` to add all of the files, including my untracked
    jQuery file to the repo. Then I use `git commit` to make the `commit`. I''m going
    to use the `-m` flag here, and a good message for this one would be `Add form
    for messages and show incoming messages in browser`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once we have this in place, we can go ahead and `push` this up to GitHub. I
    am going to take a moment to deploy to Heroku now that we have something real,
    visible, and tangible to use; `git push heroku master` is going to get that done:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf7f1ecf-765a-48f4-a2e3-e344e1b27626.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: Once this is up, we'll be able to visit it in the browser. As you can see over
    inside my console, `Socket.io` is trying to reconnect to the server. Unfortunately,
    we're not going to be bringing it back up so it's going to try a little longer.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Here we are, we're verifying the deploy and everything is up and running. You
    can either run `heroku open` or copy the URL directly. I'm going to go ahead and
    close my two localhost tabs and open up the actual Heroku app.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Right here, we do get our Welcome to the chat app message and we do get our
    form; everything looks good so far. I''m going to go ahead and open up a different
    browser like Safari. I''m going to go to the chat app as well, and we''re going
    to bring these windows side by side. Over inside Safari I''m going to type a little
    message, `This is live on Heroku`, click on Send or hit the *enter* key, and instantly
    it shows up in the other browser in the other tab. This is because our live socket
    server is transmitting this data:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54ddfc39-b0a9-40c7-9e68-8f8d39890d1c.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: This could happen between any computer in the world, you do not need to be on
    my machine since we're using a real Heroku URL. Now that everything is working
    on Heroku, we are done.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Geolocation
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you're going to start part one of a two-part series on geolocation.
    Instead of just sending text back and forth, we're also going to set it up so
    I can beam my actual coordinates, my longitude and latitude, to everyone else
    connected to the chat app. Then we can render a link and that link could go wherever
    we like; in our case, we're going to set it up to pull up a Google Maps page where
    the actual location of the user who sent their location is marked.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Now to actually fetch a user's location we're going to use the geolocation API,
    which is available in your client-side JavaScript, and it's actually a pretty
    well-supported API. It's available on all modern browsers, whether that's mobile
    or desktop, and the documentation can be found by Googling `geolocation api`,
    and looking for the MDN documentation page.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'The MDN Docs, or the Mozilla Developer Network, are my favorite docs for client-side
    technologies, such as your web APIs, your CSS and your HTML guidelines:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90af9d91-82b8-4986-a747-86839916d9f0.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: Now as I mentioned this is a well supported feature, you can pretty much use
    it everywhere except for older versions of Internet Explorer and the Opera Mini
    browser. But all your major desktop and mobile browsers are going to support this,
    and if the browser is old, we will set up a little message to let them know their
    browser does not support geolocation. If you ever want to learn more about geolocation
    or explore features that we do not cover in this section, you can refer to this
    page, though we will be using most of the features geolocation has to offer.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Send Location button to the application
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started what we're going to do is add a new button to our application.
    It's going to sit alongside of Send and it's going to say something like Send
    Location. When the user clicks that Send Location button we're going to use the
    geolocation API. Usually, this is going to require the user to confirm they want
    to share their location with this tab in the browser, that pop-up box is going
    to happen, it's going to be triggered by the browser, there's no way around that.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: You're going to need to make sure the user actually wants to share their location.
    Once you have the coordinates you're going to emit an event, that's going to go
    to the server, the server is going to send it to all the other connected users
    and we're going to be able to render that information in a nice link.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'To kick things off we''re going to add that button, this is going to be the
    button that starts the entire process. Over inside Atom, inside `index.html`,
    we''re going to add a button just below our `form` tag. It''s going to be outside
    our existing form. We''re going to add the `button` tag, and we''re going to go
    ahead and give this an ID of `send-location`. Now as for the visible `button`
    text we can go ahead and use `Send``Location` as our string, and save the file:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If we go ahead and refresh our app in the browser, we should now see we have
    our Send Location button showing up:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ef04e95-11c7-460e-a0fd-903e4cbe19fd.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: We're going to fix all this later when we add the default styles, but for now
    this does get the job done.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Now clicking this button currently is not going to do anything, it's not tied
    to a `form` so it's not going to do any weird `form` submissions or page reloads.
    All we need to do is add a `click` listener to this button and we'll be able to
    run whatever code we like. In our case, we're going to run that geolocation code.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Adding a click listener to the Send Location button
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to add a `click` listener, inside Atom, inside `index.js`, and
    we're going to add some code down near the bottom.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the first thing I want to do is create a variable, and I''m going to call
    this variable `locationButton`; this is going to store our selector. This is the
    jQuery selector that targets the button we just created, because we''re going
    to need to reference it multiple times and storing it in a variable saves the
    need to make those calls again. We''re going to call `jQuery` like we''ve done
    for our other selectors, passing in one argument, a string, and we''re selecting
    something by ID, which means we got to start with that hash sign (`#`), and the
    actual ID is `send-location`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now that we have this in place we can go ahead and do whatever we like. In
    our case, what we''re going to be doing is add a click event, and we want to do
    something when someone clicks that button. To get that done we''re going to go
    to `locationButton.on`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This is identical to doing the `jQuery`, selecting the ID `send-location`, both
    of these are going to do the same thing. The benefit of the first solution is
    that we have a reusable variable,, which we are going to reference later on. Making
    two jQuery calls to the same selector, wastes time because it is going to require
    jQuery to manipulate the DOM, fetching that information, and that's expensive.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '`locationButton.on` is going to be our event listener. We''re listening for
    the `click` event, inside quotes for the first argument, and the second argument
    as always is going to be our `function`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This function is going to get called when someone clicks the button.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Checking access to the geolocation API
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For now all we're going to do is check if the user has access to that geolocation
    API. If they don't we want to go ahead and print a message.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to create an `if` statement. The geolocation API exists on `navigator.geolocation`,
    and we want to run some code if it doesn''t exist:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'So we''re going to flip it. If there is no geolocation object on navigator
    we want to do something. We''re going to use `return` to prevent the rest of the
    function from executing, and we''re going to call the `alert` function available
    in all browsers that pops up one of those default alert boxes that makes you click
    on OK:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We're going to use this as opposed to a fancier modal. If you are using something
    like Bootstrap or Foundation, you can implement one of their built-in tools.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, though, we''re going to use `alert`, which takes just one argument
    (a string, your message) `Geolocation not supported by your browser`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now users who don't have support for this are going to see a little message,
    as opposed to wondering whether or not anything actually happened.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Fetching a user's position
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To actually fetch a user''s position we''re going to use a function available
    on geolocation. To access it we''ll add `navigator.geolocation.getCurrentPosition`
    inside the `locationButton.on` function next to the `if` statement. The `getCurrentPosition`
    function is a function that starts the process. It''s going to actively get the
    coordinates for the user. In this case, it''s going to find the coordinates based
    off of the browser, and this takes two functions. The first one is your `success`
    function, right here we can add our first callback. This is going to get called
    with the location information, we''re going to name this argument `position`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The second argument to `getCurrentPosition` is going to be our error handler
    if something goes wrong. We''re going to create a `function` and we''ll be alerting
    a message to the user when we''re not able to fetch the location using `alert`.
    Let''s go ahead and call `alert` a second time, printing a message like `Unable
    to fetch location`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This is going to print `if` someone gets prompted to share their location with
    the browser but they click on Deny. We're going to say `Hey, we can't fetch the
    location if you don't give us that permission`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the only case left is the success case. This is where we''re going to `emit`
    the event. But before we do that, let''s go ahead and simply log it to the screen
    so we can take a peek at what is happening inside the `position` argument:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'I''m going to log this to the screen, our server is going to restart, and over
    inside Google Chrome we can open up the Developer Tools, refresh the page, and
    click on that Send Location button. Now this is going to work on desktop and mobile.
    Some mobile browsers are going to require you to be on HTTPS, which is something
    that we''re going to have set up for Heroku, as you know the Heroku URL is secure
    which means it''s not going to work on localhost. You can always test your mobile
    browsers by deploying the app to Heroku and running it there. For now, though,
    I will be able to click on Send Location. This is going to go ahead and start
    that process; the process can take up to a second:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95fc6021-4e94-4132-8aac-0c445c9736da.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
- en: Now as you can see I did get my geolocation position. But I was never prompted
    as to whether or not I wanted to share my location; that's because I've already
    given it permission. Over the top-right corner, I can go ahead and click on Clear
    these settings for future visits, this means that I'm going to need to reauthorize.
    If I refresh the page and click on Send Location again, you're going to see this
    little box, which is probably going to show up for you. You can either block it,
    if I block it it's going to print Unable to fetch location; or you can accept
    it.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m going to clear those settings one more time, give the page a refresh,
    and this time I am going to accept the location sharing, And we''re going to get
    the geolocation printing out in the console:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47a485e7-d9ed-43b7-aa3f-cfff1aabe748.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
- en: Now once we get it we can go ahead and dive in, the object itself is pretty
    simple, we have a timestamp of exactly when we fetched the data, this is useful
    if you're tracking a user over time, which we're not doing. We also have our coordinates,
    we have all sorts of properties we're not going to use like `accuracy`, `altitude`,
    which doesn't exist, and other related ones. We also have `speed` which is `null`.
    The only two we're ever going to use off this object is `latitude` and `longitude`,
    which do indeed exist.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: This is the information we want to pass to the server so the server can send
    it to everybody else. This means we're going to go into the `position` object,
    go into the `coords` object, and grab those two.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Adding the coordinates object in the users position
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and do that over inside Atom, we are going to call `socket.emit` and
    `emit` a brand new event, one we do not have registered yet. We''re going to call
    this one `createLocationMessage`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `createLocationMessage` event is not going to take the standard text; instead,
    it''s going to take those `longitude` and `latitude` coordinates. We''re going
    to specify both of them starting with `latitude`; we want to set `latitude` equal
    to `position.coords.latitude`. This is the variable that we explored over inside
    of the console, and we''re going to do the same thing for `longitude`, setting
    it equal to `position.coords.longitude`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now that we have this in place we can actually go ahead and listen for this
    event over in the server, and when we get it what we're going to do is pass the
    above data along to all the connected users.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Passing coordinates data with the connected users
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go ahead and do just that over inside `server.js`, registering a new event
    listener. I'm going to remove the old commented out broadcast call that's no longer
    needed in `createMessage`. Just below `createMessage`, we're going to call `socket.on`
    again, specifying a listener for this event, `createLocationMessage`, just as
    we defined it over inside `index.js`. Now we are using ES6 since we're in Node,
    which means we can go ahead and set up our arrow function. We're going to have
    one argument, this is going to be the `coords`, and we can go ahead and finish
    off the arrow function.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In here we''re going to be able to run whatever code we like. For the moment
    all we''re going to do is `emit` a `newMessage` event passing along the coordinates,
    although later in the chapter, we''ll be making this a lot nicer, setting up that
    URL for Google Maps. Right now, though, we''re going to call `io.emit`, `emit`
    a `newMessage` event, and provide the necessary data by calling `generateMessage`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'For the moment `generateMessage` is going to take some bogus username, I''m
    going to go ahead and type in `Admin`, and we are going to set the text, for now
    we''re simply going to set it equal to the coordinates. Let''s go ahead and use
    a template string to set that up. We''re going to first inject the `latitude`,
    which is available on `coords.latitude`, then we''re going to go ahead and add
    a comma, a space, and we''ll inject the `longitude`, `coords.longitude`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now that we have this call in place the location information is going to get
    passed back and forth between the users, and we can go ahead and actually prove
    this.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'Over inside the browser I''m going to give this page a refresh, and I''m also
    going to open up a second tab. In this second tab I''m going to click on Send
    Location. It''s not going to prompt me if I want to share my location since I''ve
    already told it I do want to share my location with this tab. You can see we have
    our Admin message and we have our `latitude`, and the `longitude`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4cd2187-d6cf-48cd-a45d-11e04a1fdbce.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
- en: We also have it over inside the second tab. If I take this information we can
    actually Google it and prove that it is working as expected. Later in the chapter,
    we're going to be setting up a nice link so this information isn't visible; it'll
    be there but the user doesn't really need to know the coordinates, what they really
    want is a link to a map. That's what we're going to set up, but for now we can
    put this in Google, Google is going to show us exactly where it is and the coordinates
    are indeed correct. I am in Philadelphia, which means the location was correctly
    fetched for these localhost tabs.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Rendering clickable link in place of text coordinates
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we got the data flowing, and now we're going to make it a little more
    useful. Instead of rendering `latitude` and `longitude` information as text, we're
    going to render a clickable link. A user will be able to click that link; when
    they receive the location from someone else, it's going to bring them over to
    Google Maps and they'll be able to view exactly where the other user is. This
    is going to be much more useful than spitting out the text `latitude` and `longitude`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Now in order to get that done we are going to need to tweak how we transmit
    the coordinate data. The way we send the data is still fine over inside `index.js`,
    we are still going to `emit`, `createLocationMessage`. But inside `server.js`
    instead of emitting a new message, we need to `emit` something else entirely.
    We're going to set up a new event called `newLocationMessage`, we're going to
    `emit` that, and then over inside `index.js` we'll write a handler for `newLocationMessage`
    similar to `newMessage` but distinctly different. Instead of rendering some text,
    it's going to help us render a link.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Sorting out the URL structure
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now in order to get started before we can do any of this we have to figure out
    exactly what sort of URL structure we're going to use to get that data, the `latitude`
    and `longitude` information, showing up correctly in Google Maps. And there's
    actually a pretty uniform way to set up the URL, which is going to make this really
    easy.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'To show you exactly what URL we''re going to be using, let''s go ahead and
    open up a new tab. The URL is going to go to `https://www.google.com/maps`. Now
    from here we are going to be providing a query parameter, and the query parameter
    will be specifying; it''s called `q`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b1d69b0-0c11-4dd7-8938-7f9e30e4807b.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
- en: And it is going to expect the `latitude` and `longitude` to be the value separated
    by a comma. Now we actually have that here in the `localhost:3000` tab. Although
    there will be a little space between the comma, either way we can copy that value,
    head back over into the other tab, paste it in, and just remove the space.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: With this in place we now have a URL that we can use inside our application.
    Now when I hit *enter*, we are going to view a map at the correct location, but
    you'll notice the URL changes. That's perfectly fine; as long as we send the user
    to this URL, it doesn't really matter what it ends up becoming. I'm going to hit
    *enter*; you can see right away we are getting a Google Map, and as the page loads
    the URL is indeed going to change.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Now we're looking at something completely different from what we typed in, but
    the actual pin, the red pin, it is correct within a couple of houses. Now with
    that knowledge we can generate a URL that follows that same format, spit that
    out inside the website, and we'll have that clickable link where someone can view
    the location of someone else.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Emitting newLoactionMessage
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, let''s go ahead and move into Atom into `server.js`, and instead
    of emitting a `newMessage` event we''re going to emit `newLocationMessage`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now we don't have a handler for that over in `index.js`, but that's perfectly
    fine, we'll set that up later in the section. Now we are going to need to change
    the data we send across too. Currently, we're sending the plain text data; what
    we want to do is generate a URL. We're actually going to create a completely separate
    function for generating a location message, and we'll call it `generateLocationMessage`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now this function is going to take some arguments to generate the data; Just
    like we have for the `generateMessage` function, we're going to start with the
    from name and then move on to the data specific to this function, that's going
    to be the `latitude` and `longitude`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m going to remove our template string and we''re going to pass in the raw
    values. The first value will be `coords.latitude` and the second one will be `coords.longitude`.
    Now it''s the second coordinate value but it is indeed the third argument:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'With this arguments list set up, we can actually go ahead and define `generateLocation`.
    We''ll be able to export it, require it in this file and then everything is going
    to work as expected. Let''s go ahead and load it in up top before we actually
    add it to the message file. We are going to load `generateLocationMessage` alongside
    `generateMessage`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Let's save `server.js` and move into our `message` file.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Adding generateLocationMessage in the message.js file
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now the function that we're about to create is going to look really similar
    to this, we're going to take some data in and we're going to return an object.
    The big difference is that we'll be generating that URL as well. Instead of `from`,
    `text`, and `createdAt`, we're going to have `from`, `URL`, and `createdAt`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make a new variable, we can call this variable `generateLocationMessage`,
    and we can go ahead and set it equal to a function that takes those three arguments
    `from`, `latitude`, and `longitude`:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now we can finish off the arrow function (`=>`) adding the arrow and our curly
    braces, and inside of here we can get started by returning the empty object:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now we''re going to set up those three properties from property, the URL property
    and `createdAt`. Here `from` is going to be easy; just like we do for `generateMessage`,
    we''re simply going to reference the argument. The URL one is going to be a little
    trickier; for now we''ll set that equal to an empty template string, we''ll come
    back to it in a moment. And finally, `createdAt`, we''ve done that before; we''re
    going to set it equal to a timestamp by getting a `new Date` and calling `getTime`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now for the URL we''re going to need to use that exact same format that we
    just typed into the browser, [https://www.google.com/maps](https://www.google.com/maps).
    Then we''ve got to set up our query parameter, adding our question mark and our
    `q` param, setting it equal to the `latitude` followed by a comma, and followed
    by the `longitude`. We''re going to inject the `latitude`, add a comma, and then
    inject the `longitude`:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now we''re done! `generateLocationMessage` is going to work as expected, although
    you will be writing a test case a little later on. For now we can simply export
    it. I''m going to export `generateLocationMessage`, like this:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now the data is going to flow from the client by calling `emit`, passing in
    `generateLocationMessage`. We''re going to get the `latitude` and `longitude`.
    Over inside the `server.js`, we are then going to `emit` the `newLocationMessage`
    event with the object that we just defined over inside `generateLocationMessage`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Adding an event listener for newLocationMessage
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last piece to the puzzle to really get all this working is to add an event
    listener for the `newLocationMessage` event. In `index.js` we can call `socket.on`
    to do just that. We''re going to pass in our two arguments. First up is the event
    name we want to listen for, `newLocationMessage`, and the second and final argument
    is our `function`. This is going to get called with the `message` information
    once the event occurs:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Now that we have this, we can go ahead and start generating the DOM elements
    that we want to spit out to the user, and just like we did above, we're going
    to make a list item and we're going to add our anchor tag, our link inside of
    it.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to make a variable called `list item` and we''re going to make
    a new element using `jQuery`. As that first argument we''re going to pass in our
    string and we are going to go ahead and set it equal to the list item:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Next up we can go ahead and create the second element we''re going to need.
    I''m going to make a variable, call this variable `a` for the anchor tag, and
    set it equal to the return value once again to a call to `jQuery`. This time around
    we''re going to create the anchor tag. Now the anchor tag uses the `a` tag, and
    the contents inside of the tag, that''s the link text; in our case, we''re going
    to go with `My current location`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now we are going to be specifying one attribute on the anchor tag. This is
    going to be a non-dynamic attribute, meaning it''s not going to come from the
    message object, this one is going to be called `target`, and we''re going to set
    `target` equal to `" _blank"`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'When you set target equal to `_blank`, it tells the browser to open up the
    URL in a new tab as opposed to redirecting the current tab. If we redirected the
    current tab, I''d get kicked out of the chatroom. If I clicked one of the links
    with the target set to `blank`, we''ll simply open up a new tab to view the Google
    Maps information:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Next up, we''re going to go ahead and set some properties on these attributes.
    We''re going to set the text using `li.text`. This is going to let us set the
    person''s name as well as that colon. Right inside template strings, we are going
    to inject the value `message.from`. After that value, we''re going to add a colon
    and a space:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Next up, we''re going to go ahead and update our anchor tag, `a.attr`. You
    can set and fetch attributes on your jQuery-selected elements using this method.
    If you provide one argument, like `target`, it fetches the value, in which case
    it would return the string `_blank`. If you specify two arguments, it actually
    sets the value. Here, we can set the `href` value equal to our URL, which we have
    under `message.url`:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Now you'll notice for all these dynamic values, I'm not simply adding them in
    template strings. Instead, I'm using these safe methods like `li.text` and `a.attribute`.
    This prevents any malicious behavior; if someone tries to inject HTML, they shouldn't
    be injecting using this code.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in place we can now go ahead and append the anchor tag to the end
    of the list item, which is going to add it after the text we just set using `li.append`,
    and we''re going to append the anchor tag. And now we can go ahead and add all
    of this to the DOM using the exact same statement in case of `newMessage` event
    listener. I''m going to copy and paste it in the `newLocagtionMesaage` event listener:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: With this in place we are done. Now I'm going to save `index.js` and restart
    things over in the browser. We made quite a few changes so it's alright if you
    had a few typos; as long as you're able to track them down it's no big deal.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m going to refresh both of my tabs over inside Chrome; this is going to
    get the new connections up and running using the latest client-side code, and
    to kick things off I''m going to send a simple message from the second tab to
    the first tab. It''s showing up here in the second tab, and if I go over to the
    first tab we see User: test. Now I can click on Send Location, this is going to
    take about one to three seconds to actually get the location. Then it''s going
    to go through the `Socket.io` chain and what do we get? We get the link My current
    location showing up for user one:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5a7b4c9-9e97-44e3-a1c2-421e7aac51f2.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
- en: And for user two as well. Now if I click on that link, it should open up a brand
    new tab with the proper URL, `latitude`, and `longitude` information rendered
    in it.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Right here, we have the location for the user who clicked that Send Location
    button. With this in place, we have a fantastic geolocation feature. All you do
    is you click on the button; it fetches your current location no matter where you
    are, and it renders a clickable link so anyone else can view it inside Google
    Maps. Now before we go, I would like you to add a single test case for that brand
    new `generateLocationMessage` function.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Adding test case for generateLocationMessage
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Over inside the Terminal, I can shut down the server and use `clear` to clear
    the output. If I run our test suite using `npm test`, we see that we have our
    one test and it''s passing:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da8ce85e-06f6-43db-8b43-970298c45298.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
- en: Your job is going to be to add a second test case over inside of `message.test.js`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll get started together. Right here, we''re going to add a `describe` block,
    describe the `generateLocationMessage` function, and you''re going to be responsible
    for adding a test case inside of the callback:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In here, you''re going to call `it (''should generate correct location object'')`.
    Next up, we can go ahead and add our function, this is going to be a synchronous
    test so there is no need to add the done argument:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Now, we are going to write a test case pretty similar to one for `generateMessage`
    event, although instead of passing in `from` and `text`, you're going to pass
    in `from`, `latitude`, and `longitude`. Then you're going to make some assertions
    about the values you get back. Then we're going to run the test case and make
    sure everything passes over inside the Terminal.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Adding variables for the test case
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started I''m going to make two variables. I''m going to make a `from`
    variable and I''ll set that equal to something like `Deb`. Then we can go ahead
    and create a `latitude` variable, I''m going to set that equal to `15`. And we
    can go ahead and create a variable `longitude` setting that equal to something
    like `19`:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Then I can go ahead and finally create a `url` variable. The `url` variable
    is going to be the final result, the URL I would expect to get back. Now that
    URL is going to be inside of quotes [https://www.google.com/maps](https://www.google.com/maps),
    and then we''re going to add the appropriate query parameter given the information
    we''re going to pass in. If the latitude is `15`, we would expect `15` after the
    equal sign, and if the longitude is `19` after the comma, we would expect `19`:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now that we have that in place we can actually go ahead and call our function
    storing the response. I''m going to make a variable called `message`, then we''re
    going to go ahead and call `generateLocationMessage`, which currently isn''t required,
    we can do that in just a second. And we''re going to pass in our three arguments
    `from`, `latitude`, and `longitude`:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now let''s go ahead and also pull off `generateLocationMessage` along with
    `generateMessage`:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Now the only thing left to do is make our assertions.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Making assertion for generateLocationMessage
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to start much the same way. I''m actually going to copy these
    two lines from `generateMessage` to the `generateLocationMessage` test case:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We''re expecting the `message.createdAt` property to be a number which it should
    be, then we''re expecting message to include a `from` property equal to `Deb`,
    and we''re going to expect it to have a `url` property equal to the `url` string
    we defined:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: If both of these assertions pass then we know the object returned from `generateLocationMessage`
    is correct.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Running the test case for generateLocationMessage
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m going to rerun the test suite over inside the Terminal, and everything
    should work as expected:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21812fff-2637-4f3a-8b45-0be53bdc281f.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
- en: 'And that''s it for this one! We have geolocation all set up, we have our link
    rendered, we are in great shape to continue on. I''m going to go ahead and add
    a `commit` over inside the Terminal. I''m going to run the `clear` command to
    clear the `Terminal` output, then we''ll run `git status` to see all our changed
    files and we can use `git commit` with the `-am` flag to add a message for this
    one, `Add geolocation support via geolocation api`:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: I'm going to go ahead and commit this and push it up to GitHub, and we can also
    take a quick moment to deploy this to Heroku as well using `git push heroku master`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: This is going to deploy our latest code which has geolocation stuff built in.
    We'll be able to run this, and this code is going to run on things like the Chrome
    mobile browser because we'll be on HTTPS. Google Chrome's browser on mobile and
    other mobile browsers have pretty strict security guidelines as to when they'll
    send geolocation information. It is going to need to be over an HTTPS connection,
    which is exactly what we have here. I'm going to open up our Heroku app in a few
    tabs. We'll open it up in tab one and we'll also open it up in a second tab. I'm
    going to click on that Send Location button. I do need to approve this since it's
    a different URL, yes I do want them to be able to use my location. It's going
    to grab the location, send it off, and the first tab gets the link. I click on
    the link and hopefully we get the same spot.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we worked on generating text and location messages. We looked
    into generating the `newMessage` object and then writing a test case for it. Then,
    we learned about how to use event acknowledgments. Then we added the message form
    field and rendered an input field and a button to the screen. We also discussed
    the concept of jQuery and used that to select and create incoming message elements.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: In the geoloaction section, we gave a new button to the user. This new button
    allow the users to send their location. We set up a `click` listener for that
    Send Location button, which means every time a user clicks it, we do something
    as per their access to geoloaction API. If they do not have access to the geolocation
    API, we simply print a message. If they do have access we try to fetch the location.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look into styling our chat page and make it look
    more like a real web app.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
