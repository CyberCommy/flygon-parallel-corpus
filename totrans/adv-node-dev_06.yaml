- en: Generating newMessage and newLocationMessage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked into Socket.io and WebSockets, to enable
    two-way communication between the server and the client. In this chapter, we'll
    discuss how to generate text and geolocation messages. We looked into generating
    `newMessage` and `newLocationMessage` objects and then writing test case for both
    type of messages.
  prefs: []
  type: TYPE_NORMAL
- en: Message generator and tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section you are going to break out some functionality currently in `server.js`
    into a separate file, and we're also going to set up our test suite so that we
    can verify if those utility functions are working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: For the moment, our goal is going to be to create a function that helps us generate
    the `newMessage` object. Instead of having to define the object every single time,
    we'll simply pass in two arguments to a function, the name and the text, and it'll
    generate the object so we don't have to do that work.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the newMessage object using the utility function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To generate `newMessage`, we are going to make a separate file that we load
    into `server.js` with a method we call instead of defining the object. Inside
    the `server` folder, we'll make a new directory called `utils`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `utils` we''ll make a file called `message.js`. This will store our
    utility functions related to messaging, and in our case, we''ll make a new one
    called `generateMessage`. Let''s make a variable called `generateMessage`. This
    is going to be a function and will take the two arguments I talked about earlier,
    `from` and `text`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It will then return an object just like the objects we pass in as the second
    argument to emit in `server.js`. Now all we need to do is `return` an object,
    specifying `from` as the from argument, `text` as the text argument, and `createdAt`,
    which is going to get generated by calling a `new Date` and calling its `getTime`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place our utility function is now done. All we need to do is export
    it down below, `module.exports`. We''ll set that equal to an object that has a
    `generateMessage` property equal to the `generateMessage` variable we have defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We'll eventually be able to integrate this into `server.js`, but before we do
    that let's go ahead and write some test cases to make sure it works as expected.
    This means we will need to install Mocha, and we'll also need to install the Expect
    assertion library. Then we'll set up our `package.json` scripts and write the
    test case.
  prefs: []
  type: TYPE_NORMAL
- en: Writing test cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First up, inside the Terminal, we''re going to install, using `npm install`,
    two modules. We need Expect, which is our assertion library, `@1.20.2`, and `mocha`
    to run our test suite at version `5.0.5`. We''ll then use the `--save-dev` flag
    to add these as development dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let's go ahead and run this command, and once it's done we can move into `package.json`
    and set up those test scripts.
  prefs: []
  type: TYPE_NORMAL
- en: They're going to be identical to the ones we used in the last project in the
    previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `package.json` we now have our two `dev` dependencies, and inside the
    scripts we can get started by removing the old test script. We''ll add those two
    scripts, `test` and `test-watch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Adding the test-watch script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and fill out the basics first. We''ll set `test` equal to an
    empty string for the moment, and `test-watch`. The `test-watch` script, as we
    know, simply calls `nodemon`, calling the `npm test` script, `nodemom --exec`,
    then `npm test` inside single quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will get the job done. Now when we run `nodemon` here, we're actually running
    the globally-installed `nodemon`; we can also install it locally to fix that.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get that done, all we''re going to do is run `npm install nodemon`, add
    the most recent version, which is version `1.17.2`, and use the `--save-dev` flag
    to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now when we install `nodemon` like this, our application no longer relies on
    that global `nodemon` installation. So if someone else grabs this from GitHub,
    they're going to be able to get started without needing to install anything globally.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the test script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next up is the `test` script. It first has to set up those environment variables
    that we're going to be configuring; we'll do that later. For now, all we're going
    to do is run `mocha`, passing in the pattern for the files we want to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The files we want to test are in that `server` directory. They could be in
    any subdirectory, so we''ll use `**`, and the files, regardless of their name,
    are going to end in `test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we are done. We can now run our test suite.
  prefs: []
  type: TYPE_NORMAL
- en: Running the test suite for the message utility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Over in the Terminal, if I run `npm test`, all we''re going to see is that
    we have zero tests in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df69226c-ef6e-4c23-aece-44589f81f192.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here we have the `server-test` file globbing pattern; it could not resolve
    any files. We can fix this issue by simply adding a test file. I''m going to add
    a test file for the message utility, `message.test.js`. Now we can go ahead and
    rerun the `npm test` command. This time around it does indeed find a file and
    we see we have zero passing tests, which is a great starting point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f043155-68af-43f7-aae5-66b040c5e59b.png)'
  prefs: []
  type: TYPE_IMG
- en: Inside `message.test.js`, we'll need to add a test for the message function
    we just defined. Now this test is going to verify that the object we get back
    is what we would expect given the parameters we passed in. We'll set up the basic
    structure of the test file together, and you'll write the individual test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'First up we need to load in Expect using `var expect = require(''expect'')`.
    This will let us make our assertions about the return value from our `generateMessage`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we''re going to do is add a `describe` block. Here, we''re going
    to add a `describe` block for the function `generateMessage`, and inside the callback
    function we''ll have all of the test cases for that function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can actually create a test case and fill it out, we do need to load
    in the module we''re testing. I''ll make a variable and using ES6 destructuring.
    We''re going to pull off `generateMessage`, and then we can go ahead and require
    it using `require`, specifying the local path, `./message`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s in the same directory as the test file where we currently are, so there''s
    no reason to do any directory moving. With this in place we can now add the individual
    test case, `it (''should generate the correct message object'')`. This is going
    to be a synchronous test, so there is no need to provide done. All you need to
    do is call `generateMessage` with two values, `from` and `text`. You''re going
    to get the response back, and store the response in variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you''re going to make some assertions about the response. First up, assert
    that from is correct, assert from matches the value you passed in. You''re also
    going to assert that the text matches up, and lastly you''re going to assert that
    the `createdAt` value is a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It doesn't matter what number it is; you're going to use the `toBeA` method
    to check the type and assert `createdAt` is number. To get this done, the first
    thing I'll do is define some variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started I''ll make a from variable to store the from value. I''ll go
    ahead and use `Jen`. I''ll also make a `text` variable to store the text value,
    `Some message`. Now what I want to do is make my final variable, which is going
    to store the response, the `message` that comes back from the `generateMessage`
    function, which is exactly what I''m going to call. I''m going to call `generateMessage`
    passing in the two necessary arguments, the `from` argument and the `text` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, and the final thing, we need to do is make assertions about this object
    that comes back. I''m going to expect that `message.createdAt` is a number using
    `toBeA` and passing in the type `number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This was the first assertion you needed to make to verify the property is correct.
    Next up we''re going to `expect` that message has certain properties inside it.
    We''re going to do this using the `toInclude` assertion, though you could have
    created two separate statements: one for `message.from` and a separate one for
    `message.text`. All of those are valid solutions. I''ll just use `toInclude` and
    specify some things that message should include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'First up, it should have a `from` property equal to the `from` variable. We
    can go ahead and use ES6 to define that; and the same thing is going to happen
    for `text`, `text` should equal `text` and we''re going to use ES6 to set that
    up. We can even simplify this further using `from, text`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place our test case is now done and we can go ahead and remove
    these commented outlines, and the final thing you needed to do was run the test
    suite from the Terminal by running `npm test`. When we do it what do we get? We
    get our one test under `generateMessage`, should generate correct message object,
    and it is indeed passing, which is fantastic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f79e1123-da6d-446d-b698-e5c2eda9b07b.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have some tests verifying our function works as expected, let's
    go ahead and integrate it into our application by moving into `server.js` and
    replacing all of the objects we pass to the emit function with calls to our new
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Integrate the utility function into our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step in this process will be to import the function we just created.
    I''m going to do that creating a constant in `server.js`. We''ll use ES6 destructuring
    to grab `generateMessage`, and we''re going to grab it off of a call to `require`.
    Now we''re requiring a local file in a different directory. We''re going to start
    with `./`, go into the `utils` directory since we''re currently in the `server`
    directory, and then grab the file message by specifying it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have access to `generateMessage`, and instead of creating these objects
    we can call `generateMessage`. In `socket.emit`, we''re going to replace `Welcome
    to the chat app` and the `Admin` variables with arguments `generateMessage (''Admin'',
    ''Welcome to the chat app'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We have the exact same functionality but now we're using a function to generate
    that object for us, which is going to make scaling that out a lot easier. It's
    also going to make updating what is inside a message much easier as well. Next
    up, we can change the one we have down below for *New user joined*. We're going
    to go ahead and replace this with the call to `generateMessage` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again this one''s from the `Admin` so the first argument will be the string
    `Admin`, the second argument is the text `New user joined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This one is done too, and the final one is the one that actually gets sent
    to the user from a user, which means we have `message.from` and `message.text`;
    those are going to be our arguments. We''re going to call `generateMessage` with
    those two arguments, `message.from`, and `message.text` as the second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place we are done. The last thing left to do for this section
    is test that this is working as expected. I''m going to start up the server using
    `nodemon`, without a space between `node` and `mon`, `server/server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Once the server is up, we can go ahead and test things out by opening up a couple
    of tabs with the Developer Tools open.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first tab I''m going to visit `localhost:3000`. Inside the console
    we should see our new message printing, the object looks the same even though
    it''s now generated by the function, and we can test that everything else is working
    as expected too by opening up a second tab and opening up its Developer Tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e0c1175-3c4c-4958-a83f-0109b0922d06.png)'
  prefs: []
  type: TYPE_IMG
- en: This time around the first tab should see a new message, here we have a `New
    user joined` text, that's still working. If we emit a custom message from this
    second tab, it should show up in the first. I'm going to use the up arrow key
    to run one of our previous `createMessage` event emitters.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m going to fire off the function, and if I go to the first tab we do indeed
    get the message, which is fantastic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/adfa80a5-d2de-4918-9ff2-f3a4d95a839e.png)'
  prefs: []
  type: TYPE_IMG
- en: This should work, prints in the first tab and it also prints in the second since
    we're calling `io.emit` as opposed to the broadcast method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that everything is working, we are done; we can make a commit and wrap
    this section. I''m going to call `git status` from the Terminal. Here we have
    new files as well as modified ones, which means we''re going to want to call `git
    add .`. Next up, we can call `git commit` with a message flag, `create generateMessage
    utility`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: I'm going to push this up to GitHub and that is it for this one. In the next
    section, we're going to take a look at `Socket.io` acknowledgments.
  prefs: []
  type: TYPE_NORMAL
- en: Event acknowledgements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section you''re going to learn how to use event acknowledgments. That''s
    a fantastic feature inside `Socket.io`. In order to illustrate exactly what they
    are and why you''d ever want to use them, we''re going to quickly run through
    the diagram for the chat app. These are the two events that we actually have in
    our application, if you remember the first one is the newMessage Event, it gets
    emitted by the server and it gets listened to by the client, it sends across the
    from, text, and createdAt properties, all of which are required to render the
    message to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7644a516-1cea-4937-a566-8b47601df728.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now the event that we''re going to be updating is the createMessage Event.
    This one gets emitted by the client and listened to by the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c844762f-db12-40b6-b6d6-ff93e3404b20.png)'
  prefs: []
  type: TYPE_IMG
- en: Once again we are sending some data across from and text. Now the problem with
    our createMessage Event is that the data flows in one direction. The data comes
    from a form inside the browser. It then gets sent over to the server and the server
    is kind of stuck. Sure, the data might be valid, the from and text fields might
    be correctly set up. In that case, we can emit a newMessage Event, rendering it
    to every browser who's connected to the server, but if the server receives invalid
    data it has no way to let the client know that something went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need is a way to acknowledge we got a request and have the option to
    send some data back. In this case we''re going to add an acknowledgment for createMessage.
    If the client emits a valid request with valid from and text properties, we''re
    going to acknowledge it, sending back no error message. If the data sent from
    client to server is invalid we''re going to acknowledge it sending back the errors,
    so the client knows exactly what it needs to do to send a valid request. Now the
    result is going to look a little bit like this, and the data flow from server
    to client is going to be done via a callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f788065b-0262-41bf-965b-6df284c1d5a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Your acknowledgment could be anything you like. In our case it could be was
    the message data valid? If you're creating an email application, you might only
    send the acknowledgement back to the client when the email was successfully sent.
    You don't need to send data, which is what we're going to do when valid data is
    sent across the pipeline. We're simply going to say, hey we got that message,
    everything's good to go, and the client can respond to that.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've gone through this, let's go ahead and implement it into our application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up acknowledgements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up acknowledgments really isn't that bad if you already have a listener
    in place. All you have to do is make a quick change to the listener and a quick
    change to the emitter, and everything will work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Now in this case, the listener happens to be on the server and the emitter is
    going to be on the client, but acknowledgments also work in the other direction.
    I can emit an event from the server and I can acknowledge it from the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to set this up we are going to emit a `createMessage` event over inside
    `index.js` using `socket.emit`, and we''re going to pass in the same arguments
    we would otherwise. The first one is the event name, `createMessage`, and we''re
    going to pass in some valid data, an object with those two properties. We can
    set `from` equal to something like `Frank`, and we can set a `text` property equal
    to something like `Hi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now with this in place we have a standard event emitter and a standard event
    listener. I can go ahead and start up the app using `nodemon` and we can make
    sure everything is working as expected, `nodemon server/server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the server is up we can visit it in the browser, I''m going to open up
    the Developer Tools as well. Then we''re going to go to `localhost:3000`, and
    you can see over inside of the Terminal we have `createMessage` showing up, and
    we also have `newMessage` showing up here. We have the `newMessage` for our little
    `Welcome to the chat app` greeting, and we have the `newMessage` from `Frank`,
    which we emitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98585275-6297-4746-8a5a-459b8ce85cdc.png)'
  prefs: []
  type: TYPE_IMG
- en: Now the goal here is to send an acknowledgement from the server back to the
    client that we got the data.
  prefs: []
  type: TYPE_NORMAL
- en: Sending an acknowledgement from server to the client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to get this done we have to make a change to both the listener and
    the emitter. If you only make a change to one it is not going to work as expected.
    We're going to start with the event emitter. We want a way to run some code when
    the acknowledgement has been sent from the server back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the event emitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To send acknowledgement `d=from` server to client, we''re going to add a third
    argument which is going to be a callback function. This function is going to fire
    when the acknowledgement arrives at the client, and we can do anything we like.
    For now we''ll just print using `console.log(''Got it'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now this is all we need to do bare-bones style to add an acknowledgement to
    the client.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the event listener
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s also pretty simple on the server; we''re going to add a second argument
    to our `callback` argument list. The first one is still going to be the data that
    was emitted, the second one though is going to be a function that we''re going
    to refer to as `callback`. And we can call it anywhere in `socket.on` to acknowledge
    that we got the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When we call this function, like we're going to call it right here, it is in
    turn going to send an event back to the frontend and it is going to call the function
    as we have it in event emitter in `index.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that if I save both files we can play around with acknowledgments
    over in the browser. I''m going to refresh the app, and what do we get? We get
    Got it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fd062aa-1af4-494f-a8c4-0937594e2184.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That means our data successfully went to the server; we can prove that by seeing
    the `console.log` statement in the Terminal, the server acknowledged it got the
    data by calling callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b37a8ea-3715-47c2-ba77-a991b4ce67a3.png)'
  prefs: []
  type: TYPE_IMG
- en: And in the Developers Tool, Got it prints.
  prefs: []
  type: TYPE_NORMAL
- en: Now acknowledgments are pretty useful, but they're even more useful when you
    send data back. If the data for the message is invalid, for example, we're probably
    going to want to send some errors back, something we will be doing a little later.
    For now though, we can play around with an acknowledgment by sending anything
    we want back.
  prefs: []
  type: TYPE_NORMAL
- en: 'We send data back by providing one argument to callback, if you want to add
    multiple things simply specify an object adding as many properties as you like.
    In our case, though, we can send a string as the only argument to `callback`.
    I''m going to set my string to `This is from the server`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This string is going to be passed into the callback and it''s going to end
    up inside of our callback in `index.js`. This means I can create a variable for
    that value, we can call it `data` or anything else you like, and we can print
    it to the screen or do something with it. For now we''re just going to print it
    to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If I save `index.js`, we can test that everything is working as expected. I'm
    going to go ahead and give the app a refresh, and what do we see?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f9d2613-c564-4e64-b9ba-b9f5599c8cdc.png)'
  prefs: []
  type: TYPE_IMG
- en: We see Got it, meaning we got the acknowledgment, and we see the data, the data
    that was sent from the server to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgments play an important role in real-time applications. Let's go back
    to that email app example for a second, imagine I type in some values like a to
    value and a text value when I send the e-mail. I want to get an acknowledgement
    back that either email sent successfully, or email was not sent, in which case
    I want to know why; maybe it was a form error where I can show some error messages
    to the user or maybe the server was down for maintenance or something like that.
  prefs: []
  type: TYPE_NORMAL
- en: Either way, acknowledgments allow the request listener to send something back
    to the request emitter. Now that we know how to use acknowledgments we're going
    to integrate them into our application. That is coming up in the next section,
    as we add an actual form field to our `index.html` file where users can submit
    new messages and view them.
  prefs: []
  type: TYPE_NORMAL
- en: The message form and jQuery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section you're going to add a form field to your `index.html` file.
    This is going to render an input field and a button to the screen, and the user
    is going to be able to interact with that as opposed to having to call `socket.emit`
    from the Developer Tools, which is not a sustainable option for real users. This
    only works for us developers.
  prefs: []
  type: TYPE_NORMAL
- en: Now in order to get started we're going to be editing `index.html`, then we're
    going to move into `index.js`. We're going to add a listener that's going to wait
    for the form to be submitted, and inside of that listener callback, we are going
    to fire `socket.emit` with the data typed in the field. We're also going to take
    a moment to render all incoming messages to the screen. At the end of this section,
    we'll have a ugly, yet working, chat application.
  prefs: []
  type: TYPE_NORMAL
- en: Using the jQuery library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now before we do any of that, we are going to be using a library called jQuery
    to do DOM manipulation, which means that we want to be able to do stuff with our
    rendered HTML, but we want to be able to do that from our JavaScript file. We''re
    going to use jQuery to make that a lot easier in terms of cross-browser compatibility.
    To grab this library, we''re going to head over to Google Chrome, go to [jquery.com](http://jquery.com/),
    and you can grab the most recent version. The version is not going to matter for
    here, as we''re using very basic features available in all versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ddd476fc-950d-4a25-8a42-dc7c52cf7bc7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I''ll grab the most recent version 3.3.1\. Then I''ll go ahead and download
    the compressed production version by right-clicking and opening it in a new tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9539a35-4ea1-4cf5-baab-348758914222.png)'
  prefs: []
  type: TYPE_IMG
- en: Here we have the actual JavaScript that we want to load in to our application,
    which means we can right-click some sort of empty area, click on Save As, and
    go into our projects folder, `Desktop` | `node-chat-app` | `public` | `js`. Inside
    of `js`, I'm going to create a new directory called `libs`, where we'll store
    third-party JavaScript. We're going to be working with a few more client-side
    JavaScript libraries throughout the section, so it's nice to create a folder to
    stay organized. I'm going to save that in there, close the tab as well as the
    downloads area, and now we can go ahead and load it in to `index.html` and add
    our form.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the form field in index.html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Down here just between `socket.io` and `index.js` we''re going to add a new
    script tag to load in jQuery. We''ve got to specify that `src` attribute with
    the path to the file `/js/libs`, followed by a forward slash and the file name,
    `jquery-3.3.1.min.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now let's go ahead and set up our `form` tag; this is going to render our form
    fields to the browser. If you're not familiar with these tags that is perfectly
    fine, simply follow along and I'll explain as we go.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the form tag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First step, we need a `form` tag; this creates a form that''s submittable by
    the user. This is exactly what we''re going to use to submit our messages. And
    on this `form` tag we''re going to add one attribute; it''s the `id` attribute
    which lets us give this element a unique identifier, making it really easy to
    target with our JavaScript a bit later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Remember, we're going to want to add a listener to this element. When the form
    gets submitted, we're going to want to do something in our JavaScript file. Notably
    what we're going to want to do is call `socket.emit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m going to set `id` equal to, inside quotes, `message-form`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our form tag complete we can add some tags inside of it. To
    get started we''re going to add a `button` which is going to appear at the `bottom`
    of the `form`. This `button` on click is going to submit the `form`. I''m opening
    and closing my tag, and just inside I can type whatever text I want to appear
    on the `button`. I''m going to go with `Send`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Adding the text field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our `button` in place, the only thing we need to do is add
    the little text field. This is going to be the text field where a user types their
    message. This is going to require us to use an `input tag`, and instead of opening
    and closing an `input` tag, we''re going to use the self-closing syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we don''t need to actually put anything inside it like we do for `button`,
    or for `form`, we are going to be adding quite a few attributes onto input, first
    up, name, we want to give this field a unique name, something like `message` is
    going to get the job done. We also want to go ahead and set the type. There are
    a lot of different types for `input` tags. Types could include something like
    a checkbox, or in our case the type we''re going to use inside quotes is `text`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The last attribute we''re going to add to `input` is called `placeholder`.
    We''re going to set this value equal to, inside quotes, a string. This string
    is going to get rendered in the field in a light gray before the user actually
    enters a value. I''m going to tell the user that this is where their `Message`
    goes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: With this in place we can actually test out our form's rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the form's rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can do the testing by starting at the server using `nodemon`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The server is up, I'm going to visit Google Chrome, and go to `localhost:3000`.
    You'll notice something kind of cool, I haven't actually visited the URL yet but
    you can see that the connection has already occurred. Chrome does some lazy loading,
    if it thinks you're going to go to a URL it's actually going to make the request;
    so when I do visit it, it loads even faster. Now if I visit `localhost:3000` what
    do we get?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa4e5cb4-2f38-4897-99a8-068369aad5ea.png)'
  prefs: []
  type: TYPE_IMG
- en: We get our little form, we can type in a message like `Test` and we can send
    it off. Now by default forms are very old school. If I try to submit this form,
    it's actually going to go through a full page refresh, and then it's going to
    add the data, like our message text, as a query string on the URL. This is not
    what we want to do, we want to run some custom JavaScript on form submit. So we're
    going to attach a custom event listener and override the default behavior. To
    get that done we are going to have to use jQuery, and we're going to need to select
    this `form` field.
  prefs: []
  type: TYPE_NORMAL
- en: Using jQuery to select element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we dive into `index.js` let''s take a quick moment to talk about how
    we can use `jQuery` to select elements. `jQuery`, which is accessible via the
    `jQuery` variable, takes your selector as its argument. Then, we''re going to
    add a string and we can select our elements. For example, if we want to select
    all the paragraph tags on the screen we would type `p` in the quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: These are really similar to CSS selectors if you're familiar with them, and
    as shown, we've selected our paragraph tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'I could also go ahead and select all of the `div` inside my program, or I could
    select elements by ID or class, and that''s what we''re going to do. In order
    to select an element by ID we first start with the pound sign (`#`), then we type
    the name. In our case we have a `form` called `message-form`, and if I fire this
    off we do indeed get that back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3b37ba2-bfaf-485b-8833-c56ef7191a1e.png)'
  prefs: []
  type: TYPE_IMG
- en: This is going to allow us to add an event listener.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the selector element to index.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside `index.js` we''re going to add that exact same selector near the bottom,
    `jQuery`, calling it with our selector `#message-form`. Now we''re going to add
    an event listener, and the event listener is going to look pretty similar to our
    `Socket.io` event listeners. We are going to be calling on, and we are going to
    be providing, those two arguments, the event name inside quotes, `submit`, and
    a `function`, which is going to fire when a user tries to submit the `form`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now unlike our `Socket.io` event listeners, we are going to get one argument
    in the `function`, an `e` event argument, and we are going to need to access this.
    We''re going to need to access this event argument in order to override that default
    behavior that causes the page refresh. Right here we''re going to call `e.preventDefault`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `preventDefault` method prevents the default behavior for the event, and
    by default a submit event goes through that page refresh process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can go ahead and test that everything is working by going into Google Chrome,
    giving the page a refresh. I''m also going to remove the query string from the
    URL. Now we can type in some sort of message like `test`, hit Send, and you can
    see that nothing happens. Nothing happens because we overrode the default behavior,
    all we need to do to make something happen is call `socket.emit` in `index.js`.
    We''re going to emit the `createMessage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''re going to go ahead and provide our data. Now the name `from` field
    for now is just going to be `User` in uppercase. We''re going to leave this as
    anonymous for the moment, although we will be updating that a bit later. Now for
    the text field, this is going to come from the `form`. We''re going to want to
    add a selector and get the value back. Let''s go ahead and do that using `jQuery`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to call `jQuery` once again, and we''re going to select the input
    in the `index.html` file. We can go ahead and select it by its name, `name="message"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to get that done we''re going to open up brackets in `socket.emit`
    in `index.js`, setting `name` equal to `message`. This is going to select any
    element that has a `name` attribute equal to `message`, which is just our one,
    and we can go ahead and get its value using the `.val` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'No semicolon required since we''re inside object creation. With this in place
    we can now go ahead and add our callback function for our acknowledgment. For
    the moment it doesn''t really do anything, but that''s perfectly fine. We have
    to add it in order to fulfill the acknowledgement set up we currently have in
    place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our event listener set up, let's go ahead and test this out.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the update event listener
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m going to head back into Chrome, give the page a refresh, type in some
    message like `This should work`, and when we submit the form we should see it
    show up over here as a new message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/745dcf89-0e1d-46ef-a43d-059101886cec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I''m going to send it off and you can see that right inside the Terminal, we
    have a user sending `This should work`, and it also shows up in Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff37e724-ba40-4ed2-8df6-08a1e49a739e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The same thing is true if I open up a second connection, I''m going to open
    up the Developer Tools so we can see exactly what''s happening behind the scenes.
    I''m going to type some message like `From tab 2`, Send it off:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6c66dd6-dde0-453a-9cd3-8ead6fd3cb2f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We should see it over in tab 1, and we do:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a22faa0-6e61-4131-87a8-1a2cdf5fcfd6.png)'
  prefs: []
  type: TYPE_IMG
- en: Perfect, everything is working as expected. Now obviously the setup is not complete;
    we want to wipe that form value after we send the message, and we want to take
    care of a few other UI-related things, but for now it is working pretty well.
  prefs: []
  type: TYPE_NORMAL
- en: With a basic form in place, the second thing we're going to do is render incoming
    messages to the screen. Now once again it is going to look pretty ugly, but it
    will get the job done.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering incoming messages to the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get this done we have to create a place inside our DOM, inside our `index.html`
    file, where we can render the messages. Once again we're going to give this element
    an ID that we can easily access over inside `index.js`, so we can render those
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an ordered list to render messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First up, what we''re going to do is create an ordered list by creating an
    `ol` tag just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This list is going to let us add items to it, and those items are going to
    be the individual messages. Now we are going to be giving this an `id` attribute.
    I''m going to call `id`, in this case, `messages`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now this is all we need to do in `index.html`, all of the heavy lifting is going
    to happen over inside `index.js`. When a new message comes in we want to add something
    inside of the ordered list so that gets rendered to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Over inside `index.js` we can get this done by modifying our callback function
    when a new message arrives.
  prefs: []
  type: TYPE_NORMAL
- en: Using jQuery to create element in index.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we''re going to do is create a list item, and we''re going
    to do this once again using jQuery. We''re going to make a variable, this variable
    is going to be called `li`, and we''re going to go ahead and use jQuery slightly
    differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than using `jQuery` to select an element, we''re going to use `jQuery`
    to create an element, then we can modify that element and add it into the markup,
    making it visible. Inside quotes, we''re going to open and close an `li` tag,
    just like we would inside `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have this in place we have to go ahead and set its text property,
    I'm going to set `li.text`, by calling `li.text` with the value I want to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case the text is going to require us to set up a little template string,
    inside the template string we are going to go ahead and use the data that comes
    back. For now we''re going to use the `from` attribute and the `text` attribute.
    Let''s get started with who it''s `from`, then we''ll add a little colon and a
    space to separate that from the actual `message`, and finally, we''ll inject `message.text`
    at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now at this point we''ve created an element but we haven''t rendered it to
    the DOM. What we''re going to do is use `jQuery` to select that brand new element
    we created, we gave it an ID of `messages`, and we''re going to `append` something
    to it by calling the `append` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This is going to add it as its last child, so there''s already three items
    in the list; the newest one will show up below those three as the fourth item
    in our ordered list. All we have to do is call `append` as a function, passing
    in our list item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: And with this in place we are done. Now if you're not familiar with `jQuery`
    this can be a bit overwhelming, but I promise the techniques we use here we'll
    be using throughout the book. By the end, you'll be much more comfortable selecting
    and creating elements.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the incoming messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and test things out over inside Google Chrome. I''m going to
    refresh tab 1, and when I do you can see our two messages, Welcome to the chat
    app shows up and Frank says Hi:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ad84232-822d-4f69-9d40-42a821b92550.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now Welcome to the chat app should show up. The Frank Hi message is coming
    from `socket.emit` inside `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can actually go ahead and remove that, we no longer need to automatically
    emit messages since we have a `form` set up to get that done for us. Once again
    we can save the file, refresh the browser and this time around we have a nice
    little setup, Welcome to the chat app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b6c4e36-7bc6-439f-b553-469dbbe85937.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I''m going to do the same thing for our second tab. This time around we get
    Welcome to the chat app and in the first tab we get New user joined; this is fantastic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c0342a2-a143-475b-9cd2-ab6b3bd8a2f6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now the true test is going to be to send a message from one tab to the other,
    `This should go to tab 2`. I''m going to Send this off, and when I click on this
    button, it''s going to emit the event that''s going to go to the server, and the
    server is going to send it to everyone connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5df3ee7d-73a7-4064-b55c-7b55a44b986e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, I can see This should go to tab 2 renders, and over inside my second
    tab we get the message as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2bf72bc9-0838-4109-aa72-b64cfd615bf2.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we're not quite done with the UI or the actual user experience; custom names
    and timestamps are coming up, but we do have a fantastic start. We now have a
    form where we can submit messages and we can see all the incoming messages inside
    the browser, which means we do not need to do anything in the Developer Tools
    anymore in terms of emitting or reading our messages. That is it for this one,
    let's go ahead and wrap things up by making a commit now that we have some working
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: Making a commit for the message form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m going to shut down the server, clear the output, and run `git status`
    so we can double-check all our changes; everything looks good here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c246efa-4f88-4d88-bec4-17b468d7a292.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I''m going to use `git add` to add all of the files, including my untracked
    jQuery file to the repo. Then I use `git commit` to make the `commit`. I''m going
    to use the `-m` flag here, and a good message for this one would be `Add form
    for messages and show incoming messages in browser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have this in place, we can go ahead and `push` this up to GitHub. I
    am going to take a moment to deploy to Heroku now that we have something real,
    visible, and tangible to use; `git push heroku master` is going to get that done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf7f1ecf-765a-48f4-a2e3-e344e1b27626.png)'
  prefs: []
  type: TYPE_IMG
- en: Once this is up, we'll be able to visit it in the browser. As you can see over
    inside my console, `Socket.io` is trying to reconnect to the server. Unfortunately,
    we're not going to be bringing it back up so it's going to try a little longer.
  prefs: []
  type: TYPE_NORMAL
- en: Here we are, we're verifying the deploy and everything is up and running. You
    can either run `heroku open` or copy the URL directly. I'm going to go ahead and
    close my two localhost tabs and open up the actual Heroku app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right here, we do get our Welcome to the chat app message and we do get our
    form; everything looks good so far. I''m going to go ahead and open up a different
    browser like Safari. I''m going to go to the chat app as well, and we''re going
    to bring these windows side by side. Over inside Safari I''m going to type a little
    message, `This is live on Heroku`, click on Send or hit the *enter* key, and instantly
    it shows up in the other browser in the other tab. This is because our live socket
    server is transmitting this data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54ddfc39-b0a9-40c7-9e68-8f8d39890d1c.png)'
  prefs: []
  type: TYPE_IMG
- en: This could happen between any computer in the world, you do not need to be on
    my machine since we're using a real Heroku URL. Now that everything is working
    on Heroku, we are done.
  prefs: []
  type: TYPE_NORMAL
- en: Geolocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you're going to start part one of a two-part series on geolocation.
    Instead of just sending text back and forth, we're also going to set it up so
    I can beam my actual coordinates, my longitude and latitude, to everyone else
    connected to the chat app. Then we can render a link and that link could go wherever
    we like; in our case, we're going to set it up to pull up a Google Maps page where
    the actual location of the user who sent their location is marked.
  prefs: []
  type: TYPE_NORMAL
- en: Now to actually fetch a user's location we're going to use the geolocation API,
    which is available in your client-side JavaScript, and it's actually a pretty
    well-supported API. It's available on all modern browsers, whether that's mobile
    or desktop, and the documentation can be found by Googling `geolocation api`,
    and looking for the MDN documentation page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MDN Docs, or the Mozilla Developer Network, are my favorite docs for client-side
    technologies, such as your web APIs, your CSS and your HTML guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90af9d91-82b8-4986-a747-86839916d9f0.png)'
  prefs: []
  type: TYPE_IMG
- en: Now as I mentioned this is a well supported feature, you can pretty much use
    it everywhere except for older versions of Internet Explorer and the Opera Mini
    browser. But all your major desktop and mobile browsers are going to support this,
    and if the browser is old, we will set up a little message to let them know their
    browser does not support geolocation. If you ever want to learn more about geolocation
    or explore features that we do not cover in this section, you can refer to this
    page, though we will be using most of the features geolocation has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Send Location button to the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started what we're going to do is add a new button to our application.
    It's going to sit alongside of Send and it's going to say something like Send
    Location. When the user clicks that Send Location button we're going to use the
    geolocation API. Usually, this is going to require the user to confirm they want
    to share their location with this tab in the browser, that pop-up box is going
    to happen, it's going to be triggered by the browser, there's no way around that.
  prefs: []
  type: TYPE_NORMAL
- en: You're going to need to make sure the user actually wants to share their location.
    Once you have the coordinates you're going to emit an event, that's going to go
    to the server, the server is going to send it to all the other connected users
    and we're going to be able to render that information in a nice link.
  prefs: []
  type: TYPE_NORMAL
- en: 'To kick things off we''re going to add that button, this is going to be the
    button that starts the entire process. Over inside Atom, inside `index.html`,
    we''re going to add a button just below our `form` tag. It''s going to be outside
    our existing form. We''re going to add the `button` tag, and we''re going to go
    ahead and give this an ID of `send-location`. Now as for the visible `button`
    text we can go ahead and use `Send``Location` as our string, and save the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If we go ahead and refresh our app in the browser, we should now see we have
    our Send Location button showing up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ef04e95-11c7-460e-a0fd-903e4cbe19fd.png)'
  prefs: []
  type: TYPE_IMG
- en: We're going to fix all this later when we add the default styles, but for now
    this does get the job done.
  prefs: []
  type: TYPE_NORMAL
- en: Now clicking this button currently is not going to do anything, it's not tied
    to a `form` so it's not going to do any weird `form` submissions or page reloads.
    All we need to do is add a `click` listener to this button and we'll be able to
    run whatever code we like. In our case, we're going to run that geolocation code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a click listener to the Send Location button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to add a `click` listener, inside Atom, inside `index.js`, and
    we're going to add some code down near the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the first thing I want to do is create a variable, and I''m going to call
    this variable `locationButton`; this is going to store our selector. This is the
    jQuery selector that targets the button we just created, because we''re going
    to need to reference it multiple times and storing it in a variable saves the
    need to make those calls again. We''re going to call `jQuery` like we''ve done
    for our other selectors, passing in one argument, a string, and we''re selecting
    something by ID, which means we got to start with that hash sign (`#`), and the
    actual ID is `send-location`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have this in place we can go ahead and do whatever we like. In
    our case, what we''re going to be doing is add a click event, and we want to do
    something when someone clicks that button. To get that done we''re going to go
    to `locationButton.on`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This is identical to doing the `jQuery`, selecting the ID `send-location`, both
    of these are going to do the same thing. The benefit of the first solution is
    that we have a reusable variable,, which we are going to reference later on. Making
    two jQuery calls to the same selector, wastes time because it is going to require
    jQuery to manipulate the DOM, fetching that information, and that's expensive.
  prefs: []
  type: TYPE_NORMAL
- en: '`locationButton.on` is going to be our event listener. We''re listening for
    the `click` event, inside quotes for the first argument, and the second argument
    as always is going to be our `function`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This function is going to get called when someone clicks the button.
  prefs: []
  type: TYPE_NORMAL
- en: Checking access to the geolocation API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For now all we're going to do is check if the user has access to that geolocation
    API. If they don't we want to go ahead and print a message.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to create an `if` statement. The geolocation API exists on `navigator.geolocation`,
    and we want to run some code if it doesn''t exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'So we''re going to flip it. If there is no geolocation object on navigator
    we want to do something. We''re going to use `return` to prevent the rest of the
    function from executing, and we''re going to call the `alert` function available
    in all browsers that pops up one of those default alert boxes that makes you click
    on OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We're going to use this as opposed to a fancier modal. If you are using something
    like Bootstrap or Foundation, you can implement one of their built-in tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, though, we''re going to use `alert`, which takes just one argument
    (a string, your message) `Geolocation not supported by your browser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Now users who don't have support for this are going to see a little message,
    as opposed to wondering whether or not anything actually happened.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching a user's position
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To actually fetch a user''s position we''re going to use a function available
    on geolocation. To access it we''ll add `navigator.geolocation.getCurrentPosition`
    inside the `locationButton.on` function next to the `if` statement. The `getCurrentPosition`
    function is a function that starts the process. It''s going to actively get the
    coordinates for the user. In this case, it''s going to find the coordinates based
    off of the browser, and this takes two functions. The first one is your `success`
    function, right here we can add our first callback. This is going to get called
    with the location information, we''re going to name this argument `position`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The second argument to `getCurrentPosition` is going to be our error handler
    if something goes wrong. We''re going to create a `function` and we''ll be alerting
    a message to the user when we''re not able to fetch the location using `alert`.
    Let''s go ahead and call `alert` a second time, printing a message like `Unable
    to fetch location`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This is going to print `if` someone gets prompted to share their location with
    the browser but they click on Deny. We're going to say `Hey, we can't fetch the
    location if you don't give us that permission`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the only case left is the success case. This is where we''re going to `emit`
    the event. But before we do that, let''s go ahead and simply log it to the screen
    so we can take a peek at what is happening inside the `position` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'I''m going to log this to the screen, our server is going to restart, and over
    inside Google Chrome we can open up the Developer Tools, refresh the page, and
    click on that Send Location button. Now this is going to work on desktop and mobile.
    Some mobile browsers are going to require you to be on HTTPS, which is something
    that we''re going to have set up for Heroku, as you know the Heroku URL is secure
    which means it''s not going to work on localhost. You can always test your mobile
    browsers by deploying the app to Heroku and running it there. For now, though,
    I will be able to click on Send Location. This is going to go ahead and start
    that process; the process can take up to a second:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95fc6021-4e94-4132-8aac-0c445c9736da.png)'
  prefs: []
  type: TYPE_IMG
- en: Now as you can see I did get my geolocation position. But I was never prompted
    as to whether or not I wanted to share my location; that's because I've already
    given it permission. Over the top-right corner, I can go ahead and click on Clear
    these settings for future visits, this means that I'm going to need to reauthorize.
    If I refresh the page and click on Send Location again, you're going to see this
    little box, which is probably going to show up for you. You can either block it,
    if I block it it's going to print Unable to fetch location; or you can accept
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m going to clear those settings one more time, give the page a refresh,
    and this time I am going to accept the location sharing, And we''re going to get
    the geolocation printing out in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47a485e7-d9ed-43b7-aa3f-cfff1aabe748.png)'
  prefs: []
  type: TYPE_IMG
- en: Now once we get it we can go ahead and dive in, the object itself is pretty
    simple, we have a timestamp of exactly when we fetched the data, this is useful
    if you're tracking a user over time, which we're not doing. We also have our coordinates,
    we have all sorts of properties we're not going to use like `accuracy`, `altitude`,
    which doesn't exist, and other related ones. We also have `speed` which is `null`.
    The only two we're ever going to use off this object is `latitude` and `longitude`,
    which do indeed exist.
  prefs: []
  type: TYPE_NORMAL
- en: This is the information we want to pass to the server so the server can send
    it to everybody else. This means we're going to go into the `position` object,
    go into the `coords` object, and grab those two.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the coordinates object in the users position
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and do that over inside Atom, we are going to call `socket.emit` and
    `emit` a brand new event, one we do not have registered yet. We''re going to call
    this one `createLocationMessage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `createLocationMessage` event is not going to take the standard text; instead,
    it''s going to take those `longitude` and `latitude` coordinates. We''re going
    to specify both of them starting with `latitude`; we want to set `latitude` equal
    to `position.coords.latitude`. This is the variable that we explored over inside
    of the console, and we''re going to do the same thing for `longitude`, setting
    it equal to `position.coords.longitude`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have this in place we can actually go ahead and listen for this
    event over in the server, and when we get it what we're going to do is pass the
    above data along to all the connected users.
  prefs: []
  type: TYPE_NORMAL
- en: Passing coordinates data with the connected users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go ahead and do just that over inside `server.js`, registering a new event
    listener. I'm going to remove the old commented out broadcast call that's no longer
    needed in `createMessage`. Just below `createMessage`, we're going to call `socket.on`
    again, specifying a listener for this event, `createLocationMessage`, just as
    we defined it over inside `index.js`. Now we are using ES6 since we're in Node,
    which means we can go ahead and set up our arrow function. We're going to have
    one argument, this is going to be the `coords`, and we can go ahead and finish
    off the arrow function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In here we''re going to be able to run whatever code we like. For the moment
    all we''re going to do is `emit` a `newMessage` event passing along the coordinates,
    although later in the chapter, we''ll be making this a lot nicer, setting up that
    URL for Google Maps. Right now, though, we''re going to call `io.emit`, `emit`
    a `newMessage` event, and provide the necessary data by calling `generateMessage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'For the moment `generateMessage` is going to take some bogus username, I''m
    going to go ahead and type in `Admin`, and we are going to set the text, for now
    we''re simply going to set it equal to the coordinates. Let''s go ahead and use
    a template string to set that up. We''re going to first inject the `latitude`,
    which is available on `coords.latitude`, then we''re going to go ahead and add
    a comma, a space, and we''ll inject the `longitude`, `coords.longitude`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have this call in place the location information is going to get
    passed back and forth between the users, and we can go ahead and actually prove
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over inside the browser I''m going to give this page a refresh, and I''m also
    going to open up a second tab. In this second tab I''m going to click on Send
    Location. It''s not going to prompt me if I want to share my location since I''ve
    already told it I do want to share my location with this tab. You can see we have
    our Admin message and we have our `latitude`, and the `longitude`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4cd2187-d6cf-48cd-a45d-11e04a1fdbce.png)'
  prefs: []
  type: TYPE_IMG
- en: We also have it over inside the second tab. If I take this information we can
    actually Google it and prove that it is working as expected. Later in the chapter,
    we're going to be setting up a nice link so this information isn't visible; it'll
    be there but the user doesn't really need to know the coordinates, what they really
    want is a link to a map. That's what we're going to set up, but for now we can
    put this in Google, Google is going to show us exactly where it is and the coordinates
    are indeed correct. I am in Philadelphia, which means the location was correctly
    fetched for these localhost tabs.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering clickable link in place of text coordinates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we got the data flowing, and now we're going to make it a little more
    useful. Instead of rendering `latitude` and `longitude` information as text, we're
    going to render a clickable link. A user will be able to click that link; when
    they receive the location from someone else, it's going to bring them over to
    Google Maps and they'll be able to view exactly where the other user is. This
    is going to be much more useful than spitting out the text `latitude` and `longitude`.
  prefs: []
  type: TYPE_NORMAL
- en: Now in order to get that done we are going to need to tweak how we transmit
    the coordinate data. The way we send the data is still fine over inside `index.js`,
    we are still going to `emit`, `createLocationMessage`. But inside `server.js`
    instead of emitting a new message, we need to `emit` something else entirely.
    We're going to set up a new event called `newLocationMessage`, we're going to
    `emit` that, and then over inside `index.js` we'll write a handler for `newLocationMessage`
    similar to `newMessage` but distinctly different. Instead of rendering some text,
    it's going to help us render a link.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting out the URL structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now in order to get started before we can do any of this we have to figure out
    exactly what sort of URL structure we're going to use to get that data, the `latitude`
    and `longitude` information, showing up correctly in Google Maps. And there's
    actually a pretty uniform way to set up the URL, which is going to make this really
    easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show you exactly what URL we''re going to be using, let''s go ahead and
    open up a new tab. The URL is going to go to `https://www.google.com/maps`. Now
    from here we are going to be providing a query parameter, and the query parameter
    will be specifying; it''s called `q`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b1d69b0-0c11-4dd7-8938-7f9e30e4807b.png)'
  prefs: []
  type: TYPE_IMG
- en: And it is going to expect the `latitude` and `longitude` to be the value separated
    by a comma. Now we actually have that here in the `localhost:3000` tab. Although
    there will be a little space between the comma, either way we can copy that value,
    head back over into the other tab, paste it in, and just remove the space.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place we now have a URL that we can use inside our application.
    Now when I hit *enter*, we are going to view a map at the correct location, but
    you'll notice the URL changes. That's perfectly fine; as long as we send the user
    to this URL, it doesn't really matter what it ends up becoming. I'm going to hit
    *enter*; you can see right away we are getting a Google Map, and as the page loads
    the URL is indeed going to change.
  prefs: []
  type: TYPE_NORMAL
- en: Now we're looking at something completely different from what we typed in, but
    the actual pin, the red pin, it is correct within a couple of houses. Now with
    that knowledge we can generate a URL that follows that same format, spit that
    out inside the website, and we'll have that clickable link where someone can view
    the location of someone else.
  prefs: []
  type: TYPE_NORMAL
- en: Emitting newLoactionMessage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, let''s go ahead and move into Atom into `server.js`, and instead
    of emitting a `newMessage` event we''re going to emit `newLocationMessage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Now we don't have a handler for that over in `index.js`, but that's perfectly
    fine, we'll set that up later in the section. Now we are going to need to change
    the data we send across too. Currently, we're sending the plain text data; what
    we want to do is generate a URL. We're actually going to create a completely separate
    function for generating a location message, and we'll call it `generateLocationMessage`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Now this function is going to take some arguments to generate the data; Just
    like we have for the `generateMessage` function, we're going to start with the
    from name and then move on to the data specific to this function, that's going
    to be the `latitude` and `longitude`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m going to remove our template string and we''re going to pass in the raw
    values. The first value will be `coords.latitude` and the second one will be `coords.longitude`.
    Now it''s the second coordinate value but it is indeed the third argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'With this arguments list set up, we can actually go ahead and define `generateLocation`.
    We''ll be able to export it, require it in this file and then everything is going
    to work as expected. Let''s go ahead and load it in up top before we actually
    add it to the message file. We are going to load `generateLocationMessage` alongside
    `generateMessage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Let's save `server.js` and move into our `message` file.
  prefs: []
  type: TYPE_NORMAL
- en: Adding generateLocationMessage in the message.js file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now the function that we're about to create is going to look really similar
    to this, we're going to take some data in and we're going to return an object.
    The big difference is that we'll be generating that URL as well. Instead of `from`,
    `text`, and `createdAt`, we're going to have `from`, `URL`, and `createdAt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make a new variable, we can call this variable `generateLocationMessage`,
    and we can go ahead and set it equal to a function that takes those three arguments
    `from`, `latitude`, and `longitude`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can finish off the arrow function (`=>`) adding the arrow and our curly
    braces, and inside of here we can get started by returning the empty object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re going to set up those three properties from property, the URL property
    and `createdAt`. Here `from` is going to be easy; just like we do for `generateMessage`,
    we''re simply going to reference the argument. The URL one is going to be a little
    trickier; for now we''ll set that equal to an empty template string, we''ll come
    back to it in a moment. And finally, `createdAt`, we''ve done that before; we''re
    going to set it equal to a timestamp by getting a `new Date` and calling `getTime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the URL we''re going to need to use that exact same format that we
    just typed into the browser, [https://www.google.com/maps](https://www.google.com/maps).
    Then we''ve got to set up our query parameter, adding our question mark and our
    `q` param, setting it equal to the `latitude` followed by a comma, and followed
    by the `longitude`. We''re going to inject the `latitude`, add a comma, and then
    inject the `longitude`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re done! `generateLocationMessage` is going to work as expected, although
    you will be writing a test case a little later on. For now we can simply export
    it. I''m going to export `generateLocationMessage`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the data is going to flow from the client by calling `emit`, passing in
    `generateLocationMessage`. We''re going to get the `latitude` and `longitude`.
    Over inside the `server.js`, we are then going to `emit` the `newLocationMessage`
    event with the object that we just defined over inside `generateLocationMessage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Adding an event listener for newLocationMessage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last piece to the puzzle to really get all this working is to add an event
    listener for the `newLocationMessage` event. In `index.js` we can call `socket.on`
    to do just that. We''re going to pass in our two arguments. First up is the event
    name we want to listen for, `newLocationMessage`, and the second and final argument
    is our `function`. This is going to get called with the `message` information
    once the event occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have this, we can go ahead and start generating the DOM elements
    that we want to spit out to the user, and just like we did above, we're going
    to make a list item and we're going to add our anchor tag, our link inside of
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to make a variable called `list item` and we''re going to make
    a new element using `jQuery`. As that first argument we''re going to pass in our
    string and we are going to go ahead and set it equal to the list item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up we can go ahead and create the second element we''re going to need.
    I''m going to make a variable, call this variable `a` for the anchor tag, and
    set it equal to the return value once again to a call to `jQuery`. This time around
    we''re going to create the anchor tag. Now the anchor tag uses the `a` tag, and
    the contents inside of the tag, that''s the link text; in our case, we''re going
    to go with `My current location`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are going to be specifying one attribute on the anchor tag. This is
    going to be a non-dynamic attribute, meaning it''s not going to come from the
    message object, this one is going to be called `target`, and we''re going to set
    `target` equal to `" _blank"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'When you set target equal to `_blank`, it tells the browser to open up the
    URL in a new tab as opposed to redirecting the current tab. If we redirected the
    current tab, I''d get kicked out of the chatroom. If I clicked one of the links
    with the target set to `blank`, we''ll simply open up a new tab to view the Google
    Maps information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we''re going to go ahead and set some properties on these attributes.
    We''re going to set the text using `li.text`. This is going to let us set the
    person''s name as well as that colon. Right inside template strings, we are going
    to inject the value `message.from`. After that value, we''re going to add a colon
    and a space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we''re going to go ahead and update our anchor tag, `a.attr`. You
    can set and fetch attributes on your jQuery-selected elements using this method.
    If you provide one argument, like `target`, it fetches the value, in which case
    it would return the string `_blank`. If you specify two arguments, it actually
    sets the value. Here, we can set the `href` value equal to our URL, which we have
    under `message.url`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Now you'll notice for all these dynamic values, I'm not simply adding them in
    template strings. Instead, I'm using these safe methods like `li.text` and `a.attribute`.
    This prevents any malicious behavior; if someone tries to inject HTML, they shouldn't
    be injecting using this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in place we can now go ahead and append the anchor tag to the end
    of the list item, which is going to add it after the text we just set using `li.append`,
    and we''re going to append the anchor tag. And now we can go ahead and add all
    of this to the DOM using the exact same statement in case of `newMessage` event
    listener. I''m going to copy and paste it in the `newLocagtionMesaage` event listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: With this in place we are done. Now I'm going to save `index.js` and restart
    things over in the browser. We made quite a few changes so it's alright if you
    had a few typos; as long as you're able to track them down it's no big deal.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m going to refresh both of my tabs over inside Chrome; this is going to
    get the new connections up and running using the latest client-side code, and
    to kick things off I''m going to send a simple message from the second tab to
    the first tab. It''s showing up here in the second tab, and if I go over to the
    first tab we see User: test. Now I can click on Send Location, this is going to
    take about one to three seconds to actually get the location. Then it''s going
    to go through the `Socket.io` chain and what do we get? We get the link My current
    location showing up for user one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5a7b4c9-9e97-44e3-a1c2-421e7aac51f2.png)'
  prefs: []
  type: TYPE_IMG
- en: And for user two as well. Now if I click on that link, it should open up a brand
    new tab with the proper URL, `latitude`, and `longitude` information rendered
    in it.
  prefs: []
  type: TYPE_NORMAL
- en: Right here, we have the location for the user who clicked that Send Location
    button. With this in place, we have a fantastic geolocation feature. All you do
    is you click on the button; it fetches your current location no matter where you
    are, and it renders a clickable link so anyone else can view it inside Google
    Maps. Now before we go, I would like you to add a single test case for that brand
    new `generateLocationMessage` function.
  prefs: []
  type: TYPE_NORMAL
- en: Adding test case for generateLocationMessage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Over inside the Terminal, I can shut down the server and use `clear` to clear
    the output. If I run our test suite using `npm test`, we see that we have our
    one test and it''s passing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da8ce85e-06f6-43db-8b43-970298c45298.png)'
  prefs: []
  type: TYPE_IMG
- en: Your job is going to be to add a second test case over inside of `message.test.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll get started together. Right here, we''re going to add a `describe` block,
    describe the `generateLocationMessage` function, and you''re going to be responsible
    for adding a test case inside of the callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'In here, you''re going to call `it (''should generate correct location object'')`.
    Next up, we can go ahead and add our function, this is going to be a synchronous
    test so there is no need to add the done argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are going to write a test case pretty similar to one for `generateMessage`
    event, although instead of passing in `from` and `text`, you're going to pass
    in `from`, `latitude`, and `longitude`. Then you're going to make some assertions
    about the values you get back. Then we're going to run the test case and make
    sure everything passes over inside the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Adding variables for the test case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started I''m going to make two variables. I''m going to make a `from`
    variable and I''ll set that equal to something like `Deb`. Then we can go ahead
    and create a `latitude` variable, I''m going to set that equal to `15`. And we
    can go ahead and create a variable `longitude` setting that equal to something
    like `19`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Then I can go ahead and finally create a `url` variable. The `url` variable
    is going to be the final result, the URL I would expect to get back. Now that
    URL is going to be inside of quotes [https://www.google.com/maps](https://www.google.com/maps),
    and then we''re going to add the appropriate query parameter given the information
    we''re going to pass in. If the latitude is `15`, we would expect `15` after the
    equal sign, and if the longitude is `19` after the comma, we would expect `19`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have that in place we can actually go ahead and call our function
    storing the response. I''m going to make a variable called `message`, then we''re
    going to go ahead and call `generateLocationMessage`, which currently isn''t required,
    we can do that in just a second. And we''re going to pass in our three arguments
    `from`, `latitude`, and `longitude`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s go ahead and also pull off `generateLocationMessage` along with
    `generateMessage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Now the only thing left to do is make our assertions.
  prefs: []
  type: TYPE_NORMAL
- en: Making assertion for generateLocationMessage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to start much the same way. I''m actually going to copy these
    two lines from `generateMessage` to the `generateLocationMessage` test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re expecting the `message.createdAt` property to be a number which it should
    be, then we''re expecting message to include a `from` property equal to `Deb`,
    and we''re going to expect it to have a `url` property equal to the `url` string
    we defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: If both of these assertions pass then we know the object returned from `generateLocationMessage`
    is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Running the test case for generateLocationMessage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m going to rerun the test suite over inside the Terminal, and everything
    should work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21812fff-2637-4f3a-8b45-0be53bdc281f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And that''s it for this one! We have geolocation all set up, we have our link
    rendered, we are in great shape to continue on. I''m going to go ahead and add
    a `commit` over inside the Terminal. I''m going to run the `clear` command to
    clear the `Terminal` output, then we''ll run `git status` to see all our changed
    files and we can use `git commit` with the `-am` flag to add a message for this
    one, `Add geolocation support via geolocation api`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: I'm going to go ahead and commit this and push it up to GitHub, and we can also
    take a quick moment to deploy this to Heroku as well using `git push heroku master`.
  prefs: []
  type: TYPE_NORMAL
- en: This is going to deploy our latest code which has geolocation stuff built in.
    We'll be able to run this, and this code is going to run on things like the Chrome
    mobile browser because we'll be on HTTPS. Google Chrome's browser on mobile and
    other mobile browsers have pretty strict security guidelines as to when they'll
    send geolocation information. It is going to need to be over an HTTPS connection,
    which is exactly what we have here. I'm going to open up our Heroku app in a few
    tabs. We'll open it up in tab one and we'll also open it up in a second tab. I'm
    going to click on that Send Location button. I do need to approve this since it's
    a different URL, yes I do want them to be able to use my location. It's going
    to grab the location, send it off, and the first tab gets the link. I click on
    the link and hopefully we get the same spot.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we worked on generating text and location messages. We looked
    into generating the `newMessage` object and then writing a test case for it. Then,
    we learned about how to use event acknowledgments. Then we added the message form
    field and rendered an input field and a button to the screen. We also discussed
    the concept of jQuery and used that to select and create incoming message elements.
  prefs: []
  type: TYPE_NORMAL
- en: In the geoloaction section, we gave a new button to the user. This new button
    allow the users to send their location. We set up a `click` listener for that
    Send Location button, which means every time a user clicks it, we do something
    as per their access to geoloaction API. If they do not have access to the geolocation
    API, we simply print a message. If they do have access we try to fetch the location.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look into styling our chat page and make it look
    more like a real web app.
  prefs: []
  type: TYPE_NORMAL
