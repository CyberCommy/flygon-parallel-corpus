- en: Exploiting IoT Mobile Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring IoT mobile applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decompiling Android applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decrypting iOS applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using MobSF for static analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing iOS data storage with idb
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing Android data storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing dynamic analysis testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In consumer, and some commercial, IoT devices, there is an accompanied mobile
    application employed to fulfill a purpose. For instance, a mobile application
    may report analytical data to a server in a fleet management infrastructure, or
    the application may be given delegated control to start a car engine. In each
    case, data is likely stored in the mobile application and can be manipulated to
    perform unintended actions. To start discovering vulnerabilities and reverse engineering
    mobile applications, similar methodologies discussed in [Chapter 3](f0b26a31-570b-4a51-9519-cdfb567cb1cb.xhtml),
    *Analyzing and Exploiting* *FirmwareÂ *can also be applied to the mobile space.
    An application must first be acquired; afterwards, the application can be statically
    analyzed, dynamically analyzed, and can also be repackaged where applicable. This
    chapter will assist with assessing IoT mobile applications in an effort to exploit
    common vulnerabilities discovered in the field.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In mobile application security testing, there is a four-phase methodology which
    can be categorized by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application mapping**: Application mapping pertains to the application''s
    logic and the application''s business function. Think of application mapping as
    gathering information about the application to be used in the next phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client-side attacks**: Client-side attacks pertain to data being stored in
    the application and how that data can be manipulated from the client side.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network attacks**: Network attacks pertain to network layer concerns such
    as SSL/TLS or maybe XMPP protocol data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server attacks**: Server attacks apply to API vulnerabilities and backend
    server misconfigurations brought to light as a result of API testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This methodology may vary if testing is conducted via a white box or black
    box perspective. What is relevant from both the white and black box testing perspective
    is the **Mobile Application Security Verification Standard** (**MASVS**). The
    MASVS aimed to establish a framework of security requirements needed to design,
    develop, and test mobile applications for both iOS and Android ([https://www.owasp.org/images/f/fe/MASVS_v0.9.3.pdf](https://www.owasp.org/images/f/fe/MASVS_v0.9.3.pdf)).
    In addition, trends and patterns of common vulnerabilities that affect both Android
    and iOS applications have been identified and translated into a checklist created
    to accompany the MASVS, which testers as well as developers can follow when assessing
    an application ([https://www.owasp.org/images/1/1b/Mobile_App_Security_Checklist_0.9.3.xlsx](https://www.owasp.org/images/1/1b/Mobile_App_Security_Checklist_0.9.3.xlsx)).
    The checklist also contains links to OWASP''s Mobile Testing Guide, which is still
    in progress but is at a mature stage. The MASVS and the checklist point out many
    potential vulnerabilities and the requirements for mitigation. Some of the most
    common vulnerabilities within the IoT space include:'
  prefs: []
  type: TYPE_NORMAL
- en: Hardcoded sensitive values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verbose logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Session management weaknesses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching of sensitive data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insecure data storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data leakage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These common types of vulnerabilities can occur due to the type of application
    (native or hybrid) but are also introduced via poor coding practices. In this
    chapter, many of the common vulnerabilities listed will be demonstrated on both
    mobile platforms. Applying these methodologies and the checklist is outside of
    the scope of this book, however it is a good idea to use them as a reference when
    attacking IoT mobile applications. For simplicity, we will take the path of statically
    analyzing mobile applications then work towards dynamically analyzing the mobile
    applications during runtime. To get started, we need the target application binaries
    to start the process of testing an IoT mobile app.
  prefs: []
  type: TYPE_NORMAL
- en: While we will put more emphasis on static as well as dynamic testing in this
    chapter, there is also runtime analysis testing, which consists of instrumenting
    and break pointing the target application.
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring IoT mobile applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in assessing an IoT device's mobile application is acquiring
    and installing the app for the target platform. Usually, if an IoT device has
    an Android app, there is also an iOS app available as well. To install an application
    for Android, Google Play Store is used, which also shares basic information about
    the app. For iOS applications, Apple's App Store is used to install an app to
    an iDevice. However, the raw application binaries are not made available and cannot
    be obtained via the Play Store or App Store. The application binaries or packages
    are known as Android packages or APK, and **iOS App Store Package Archive** (**IPA**)
    for iOS. If you happen to be testing an application from a white box perspective,
    these binaries will be given to you without the need of exploring ways to obtain
    the app binaries. If you are testing from a black box perspective for research
    purposes, you may be wondering how we are going to get our hands on the application
    binaries.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next steps, we will discuss methods of acquiring apps for Android and
    iOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android has plenty of third-party app stores that can be used to download APK
    files. However, there are some caveats to consider when using these third-party
    app stores. Sometimes, the app stores do not have an updated version of the app,
    or have an incorrect app altogether. It is important to verify the hash, version,
    and contents of the app prior to installation of the Play Store''s version. Some
    third-party app stores claim to have an app you are looking for but they end up
    being masked as spyware apps that require unnecessary permissions. The cool part
    about downloading Android apps from third-party app stores is the ability to download
    older versions of an application as well as their historical release notes. Select
    a third-party app store, such as [https://apps.evozi.com](https://apps.evozi.com)
    and [https://apkpure.com/](https://apkpure.com/), search for the target Android
    app, and download the APK as seen in the following screenshots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2eb46de1-b127-4060-a5eb-c7ee9b29d7e3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next screenshot shows the Subaru application being downloaded from [https://app.evozi.com](https://app.evozi.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d730a5cd-9ca5-4bdc-b7a5-0c8cacca4bdd.png)'
  prefs: []
  type: TYPE_IMG
- en: For iOS, obtaining an IPA file is a lot more difficult from a black box perspective.
    In contrast to Android, there are no similar third-party app stores to choose
    from. This is due to iOS applications being encrypted by Apple's FairPlay DRM.
    This is a bit of a challenge without the necessary tools. In subsequent recipes,
    a walkthrough of decrypting an iOS application will be given. Feel free to skip
    to the *Decrypting iOS applications* recipe if you're focusing on iOS testing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decompiling Android applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a target IoT app and APK file downloaded, the application can now be decompiled
    to view its contents. For Android apps, this task can be completed in a matter
    of minutes. Later, automation testing techniques for statically analyzing an app
    will be covered in more detail. Decompiling an application is one of the first
    steps in reverse engineering an application to manipulate its functions. Apps
    can also be recompiled and packaged after modification, however this is out of
    scope for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To decompile an Android app, we will make use of Enjarify and JD-GUI. Enjarify
    translates Dalvik bytecode to Java bytecode which will be used to analyze it further
    with JD-GUI. JD-GUI is a Java decompiler used to view Java code. Both tools are
    included in the accompanied virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enjarify can be downloaded via the GitHub repository at: [https://github.com/google/enjarify](https://github.com/google/enjarify).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enjarify does require Python 3 as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'JD-GUI is available via the GitHub repository at: [https://github.com/java-decompiler/jd-gui/releases](https://github.com/java-decompiler/jd-gui/releases).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, enter the Enjarify folder path and point Enjarify to the target APK.
    In this case, the APK is in the same directory as Enjarify:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Open JD-GUI and drag over the JAR file Enjarify created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2a53fc0b-6e22-4dbd-aa77-6655fd55895a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now the Java classes can be read and understood for further analysis. For example,
    instances where `rawQuery` is used to save data to SQLite can be searched in an
    effort to identify SQL injections, as seen in the following screenshot. Other
    keywords, such as `*keys*`, `execSQL`, or `*password*`, are also common search
    terms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c2fd41df-c00f-4543-aee4-9765bc6e1bc5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This technique has been used to locate hardcoded secrets such as the iBeacons
    values embedded within the **Consumer Electronics Show** (**CES**) mobile app,
    used for the scavenger hunt contest ([http://www.ibeacon.com/the-beacons-at-ces-were-hacked/](http://www.ibeacon.com/the-beacons-at-ces-were-hacked/)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f9625703-ddff-4420-9883-8de21bf07271.png)'
  prefs: []
  type: TYPE_IMG
- en: With hardcoded beacons published in CES's mobile app, everyone can play without
    needing to be in Las Vegas. Simple, right? Having Java pseudocode is much easier
    to read than smali/baksmali code. This may not always be the case if forms of
    obfuscation are utilized or the app makes use of C/C++, but that is app-specific.
    Additional understanding of how an application functions will be gained, which
    can be tested and verified via runtime or dynamic analysis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OWASP's Mobile Security Testing Guide provides additional details on reverse
    engineering Android applications and tampering techniques ([https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05b-Basic-Security_Testing.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05b-Basic-Security_Testing.md)
    and [https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05c-Reverse-Engineering-and-Tampering.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05c-Reverse-Engineering-and-Tampering.md)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decrypting iOS applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since iOS apps are encrypted by Apple's FairPlay DRM, unencrypted versions are
    not available for download via third-party app stores. To view the contents of
    an iOS app, it must be first decrypted and extracted. Although encrypted IPA files
    can be downloaded directly from iTunes, it is a manual process to decrypt the
    app manually using tools like otool, lldb, and dd. Thankfully, this process has
    been automated using a tool known as Clutch2.
  prefs: []
  type: TYPE_NORMAL
- en: Dumpdecrypted is another tool that can be used to dump decrypted iOS applications
    to a file, but will not be used in this chapter. Dumpdecrypted can be found via
    the repository atÂ [https://github.com/stefanesser/dumpdecrypted](https://github.com/stefanesser/dumpdecrypted).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, otool will be used, which is included with XCode''s command-line
    tools. Installing XCode command-line tools can be accomplished by executing the
    following command in an OS X terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Clutch2 will be used to decrypt applications. Clutch2 can be downloaded via
    the GitHub repository at [https://github.com/KJCracks/Clutch](https://github.com/KJCracks/Clutch)
    or installed via Cydia on your jailbroken device by adding [http://cydia.iphonecake.com](http://cydia.iphonecake.com)
    as a source and searching for Clutch 2.0, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ace9bd7b-8fdd-442d-baa2-5b1109a7f707.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To find out if an application is encrypted, the IPA must be renamed to a ZIP
    file and the application binary must be located inside of the extracted folder
    that was renamed. For example, run the following commands against the application
    binary itself, not the IPA file, to check whether the app is encrypted. If the
    value for `cryptid` is `1`, this means the application is encrypted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It is now established that the application is encrypted. Decrypting the application
    manually is out of scope, however the application decryption process can be automated
    utilizing `Clutch2`. When running `Clutch2` without any arguments, all installed
    applications are listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, dump the application to be decrypted by using the `-d` flag and selecting
    the number. In this case, the app to be decrypted and dumped is number one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The application is now decrypted. Transfer the decrypted app from the iDevice
    over to the host computer using `scp` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Rename the decrypted IPA file to a ZIP, similar to the steps taken to verify
    if an app is encrypted in the previous exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Change to the `Payload/STARLINK.app` directory where the application binary
    resides:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The application binary''s contents can be disassembled using tools such as
    Hopper for further analysis. Class information can also be dumped with `class-dump`
    and analyzed further with a disassembler. For instance, examining how credentials
    are stored within the application''s `saveCredentialsToKeychain` class can now
    be performed via Hopper as seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dd3a0aad-01a7-418b-bc91-63691a2c4483.png)'
  prefs: []
  type: TYPE_IMG
- en: With additional knowledge of an application's classes and methods, functions
    of the application can be manipulated and tested via dynamic or runtime analysis.
    Dynamic testing will be covered later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OWASP's Mobile Security Testing Guide provides additional details on dumping
    encrypted iOS applications ([https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06b-Basic-Security-Testing.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06b-Basic-Security-Testing.md)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using MobSF for static analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given that the application binaries for Android and iOS have been obtained,
    we can perform further analysis using automated techniques. A great open source
    Python tool that can be leveraged for both Android and iOS is the **Mobile Security
    Framework** (**MobSF**). There are several features and capabilities MobSF can
    automate for us, particularly for Android apps. This recipe will demonstrate MobSF's
    automated static analysis features for both Android and iOS. Static analysis typically
    requires access to source code, however, decompiling Android and iOS applications
    can give us a form of pseudocode close to the original source.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MobSF is included in the accompanied virtual machine with version 0.9.5.2 beta.
    MobSF is constantly being updated and can be downloaded via [https://github.com/MobSF/Mobile-Security-Framework-MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF).
    Ensure all dependencies have been installed as listed in MobSF's documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure target APKs and decrypted iOS IPA applications have been obtained. MobSF
    will not decrypt an iOS application automatically. The decrypted IPA file is required
    for MobSF to analyze the application and not the decrypted binary inside the app's
    Payload when renaming the IPA file to a ZIP, as MobSF performs this step automatically
    (MobSF is open source and can be modified to use the raw binary rather than the
    IPA). Clutch2 can dump the IPA file when using the `-d` flag on the iOS device.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start MobSF, run the following command in your Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The web-UI of MobSF should appear in your browser at the address `127.0.0.1:8000`,
    as seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1b32c84f-ba07-4933-a4f9-43377b2b857d.png)'
  prefs: []
  type: TYPE_IMG
- en: Android static analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start off, we will analyze an Android application. Drag the target APK to
    MobSF's web interface and MobSF will automatically decompile as well as analyze
    the application's content. Within this interface, the core Android components
    (ACTIVITIES, SERVICES, RECEIVERS, and PROVIDERS) are listed along with metadata
    about the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MobSF allows for the flexibility to use different Java decompilers and Dex to
    JAR converters. Have a look at the `MobSF/settings.py` configuration file for
    how to modify these settings.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7888a1a-ae09-4d1c-8b13-26ee0ba6e904.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you scroll down, MobSF analyzes app permissions, Android API usage, browsable
    activities, and many other static analysis features that may be of use. The area
    we will have a look at, and may be the most helpful, is the Code Analysis subsection.
    Here, MobSF has generously flagged poor coding practices as well as potential
    vulnerable pieces of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0437d8b1-95f5-42c3-8f1d-05479667f732.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One of the handiest sections to use and look for isÂ Files may contain hardcoded
    sensitive information like usernames, passwords, keys etc. The following are examples
    of Java classes that MobSF flagged, which may contain hardcoded data in the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/28f49cae-7706-44ac-8f87-3c273e93a0ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In mobile apps, it''s quite common to find hardcoded OAuth `client_secret`
    values and cloud provider API account credentials. A similar example was given
    earlier in the chapter with CES''s hardcoded iBeacons. When selecting one of the
    flagged Java classes, Java pseudocode will appear which demonstrates hardcoded
    values such as those in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In 2016, Samsung fell victim to hardcoding their `client_secret` within their
    SmartThings mobile application, granting attackers bearer tokens to access door
    locks. Additional details pertaining to this incident can be found in the following
    paper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://web.eecs.umich.edu/~earlence/assets/papers/smartthings_sp16.pdf](https://web.eecs.umich.edu/~earlence/assets/papers/smartthings_sp16.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d8def19-06a8-4471-aaf5-3f040d48f0aa.png)'
  prefs: []
  type: TYPE_IMG
- en: With MobSF, testing Android applications is a breeze. iOS apps, on the other
    hand, are not as cut and dry as the Android static analysis MobSF provides.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: iOS static analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MobSF does provide helpful features for the static analysis of iOS applications.
    Like Android, the decrypted iOS IPA can be dragged over to MobSF''s web interface.
    MobSF will then rename the IPA to a ZIP, extract the contents, analyze plist files,
    check permissions that the app requests, and dump class information from the app,
    amongst other things. The following screenshot displays the landing page once
    the decrypted iOS IPA has been dragged over to MobSF. There are three main options
    that MobSF provides, including viewing the `Info.plist`, strings, and class dump:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5eb678a5-2323-450f-89d6-3d801f6ca1a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Ensure you adjust your `class-dump-z` path in MobSF's settings file, located
    in `MobSF/settings.py` and look for `CLASSDUMPZ_BINARY`. In my case, the path
    to `class-dump-z` is `/opt/iOSOpenDev/bin/class-dump-z`, however using the regular
    `class-dump` should work as well asÂ `/opt/iOSOpenDev/bin/class-dump`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first place you will want to have a look at is the `Info.plist` file. The
    `Info.plist` file contains basic information pertaining to the app, such as the
    permissions, IPC URL schemes, and app transport security settings which MobSF
    extracts for us within its interface. The following screenshot presents the `Info.plist`
    file within MobSF:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/08df2252-fa06-40dc-aff0-fc0d95bf9a22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, select the strings button, which displays strings in the binary as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e5fed86c-20d0-4f43-b7b0-90105c8d3fd5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice there is a CONSUMERSECRET as a string, which was also discovered in
    the Android application. Often, if one version of the app contains a hardcoded
    value, the other may, as well. We will validate this in a moment, after we have
    a look at the class information MobSF has dumped for us. Click onÂ View Class Dump
    to list the application''s class details. If you have set up your class dump binary
    settings correctly, a separate tab should open and display classes, as shown in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d494ad51-aa46-4a96-afa4-5b8cdb7cc824.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the class details available, we can pinpoint the functionality within
    the app to analyze. For example, we can search for password strings that are within
    classes to be analyzed in a disassembler like Hopper. The following screenshot
    shows the class `addBasicAuthenticationHeaderWithUsername` being used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cc6d3c21-8cfb-4089-9b3d-4cc3219f1c6c.png)'
  prefs: []
  type: TYPE_IMG
- en: '`addBasicAuthenticationHeaderWithUsername` can be further analyzed in Hopper,
    viewing its pseudocode as follows. Simply search for the class `addBasicAuthenticationHeaderWithUsername`
    in the string tab to view its contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c5317fd1-ab95-4ed5-9b1d-11fc19f824c9.png)'
  prefs: []
  type: TYPE_IMG
- en: Viewing the content of the class in the string tab
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are in Hopper and have located the CONSUMERSECRET in the previous
    steps, we can search for this string to check if it is also hardcoded in the iOS
    application. Following is a screenshot showing the same hardcoded values as the
    Android application. One of the hardcoded secret values ended in c4d5, which is
    highlighted in the screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3ac75df2-1dfb-4481-8853-49a68f5d336c.png)'
  prefs: []
  type: TYPE_IMG
- en: Hardcoded secret values
  prefs: []
  type: TYPE_NORMAL
- en: A common next step of testing when locating these hardcoded values in an application
    is verifying their impact via dynamic analysis. Dynamic analysis testing will
    be covered later in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we covered the static analysis of Android and iOS applications.
    We did not cover runtime analysis testing, which entails hooking application classes
    and functions during app execution. Depending on how much time and effort you
    are willing to spend on testing a mobile app, this may not always be within your
    scope. Runtime analysis is great for validating client-side security controls
    such as bypassing pin code lock screens or brute forcing logins. The OWASP Testing
    Guide provides details on runtime analysis techniques for both Android and iOS.
    Visit the links below for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Android**: [https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05c-Reverse-Engineering-and-Tampering.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05c-Reverse-Engineering-and-Tampering.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iOS**: [https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06c-Reverse-Engineering-and-Tampering.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06c-Reverse-Engineering-and-Tampering.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing iOS data storage with idb
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, iOS developers tend to ignore data storage API controls that
    Apple provides. This leads to data leakage via clear text databases (including
    realm DBs), plist files (property lists), caching, keyboards, and other storage
    locations. Sometimes, the hybrid frameworks that the applications employ encourage
    this behavior for application performance but fail to list the security repercussions.
    Depending on the hybrid framework and custom modules, plugins may be required
    to clear locations such as the cache, which increases complexity for developers.
    This section will assist you with analyzing data storage for IoT iOS applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, an already jailbroken iDevice is needed, as well as a free
    tool known as idb. Idb is a free tool that runs on OS X, and Ubuntu is used for
    simplifying common iOS app security assessment tasks. It is currently installed
    in the accompanied virtual machine but can also be installed manually by visiting
    idb's webpage at [http://www.idbtool.com/](http://www.idbtool.com/). If you are
    using **gem** to manage Ruby, idb can be installed using `gem install idb`.
  prefs: []
  type: TYPE_NORMAL
- en: As of writing this, iOS 10 applications are not supported by idb.
  prefs: []
  type: TYPE_NORMAL
- en: To view SQLite database entries, download and install sqlitebrowser via [http://sqlitebrowser.org](http://sqlitebrowser.org).
    SQLite browser has been included in the VM provided for this book as well.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start idb from the Terminal, simply execute `idb`, and the user interface will
    appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e892dd5c-2e9c-4caf-a668-54d0fea38072.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, select Connect to USB/SSH device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/46387dad-6125-4d60-8c77-2815f950d044.png)'
  prefs: []
  type: TYPE_IMG
- en: If this is your first time using idb, there are several packages that need to
    be installed on your jailbroken device which idb will install itself if it has
    access to the device via USB or SSH. These packages are listed in the following
    screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default username and password for jailbroken iDevices is alpine.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/825424a3-190e-4933-83f0-a090d178671f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If all the required packages are installed, select an app from the App Selection
    menu. In this case, com.skybell.doorbell is selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ed716c17-98c5-4abf-a59c-fe286ec911d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the SkyBell app selected, we can now focus on the app contents and how
    the app stores data. There are several features that can be utilized to automate
    iOS app assessment tasks, however for this demonstration the storage will be analyzed.
    To analyze the app''s data storage, select the Storage tab, select the plists
    tab, and press the Refresh button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/181efd97-80c8-4cd7-8fdf-2c64fa1acea6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are many files that appear, but many are not relevant for our purposes.
    The files to consider analyzing initially are the `Info.plist` file within the
    app bundle directory as well as any preference file that the app creates at runtime.
    The preference file in this case is listed as com.skybell.doorbell.plist. What
    we want to look for in the clear text plist files is any personal or sensitive
    data about either the company itself or the users. If we open the preferences
    file by double-clicking, we will see OAuth `access_tokens` and `refresh_tokens`
    stored in unprotected storage (CVE-2017-6082). These clear text tokens can be
    seen in the following screenshot. Typically, `access_tokens` are long lasting
    to improve user experience so that logging into the app each time the app is opened
    will not be required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e3f324dc-7fc1-46c5-afd7-08fe75d98b68.png)'
  prefs: []
  type: TYPE_IMG
- en: Chances are, data is not being stored securely in multiple areas when session
    tokens are in clear text. A common area to look for sensitive data stored on the
    disk is any type of database or files generated upon application startup in the
    app's `data` directory. Idb has the ability to analyze each of these areas. We
    will have a look at the Cache.db tab and see what we find.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the Cache.dbs tab, select the Refresh button, and open the Cache.db
    entry by double-clicking:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34802275-4b2c-4b57-8d6a-5e5bdee0c3d4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the following screenshot, there are many tables within this SQLite
    database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/db223886-7e3f-4934-bdc7-1b2d3036488a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These tables contain BLOB data which can be viewed as text. As it turns out,
    the application caches all requests and responses which include personal details
    as well as token data (CVE-2017-6084):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f1823557-28d2-4ffe-a4de-b17e369bcf8c.png)'
  prefs: []
  type: TYPE_IMG
- en: Custom SQLite external editors can be utilized by specifying the editors path
    via idb's settings (for example, `~/.idb/settings.yml`).
  prefs: []
  type: TYPE_NORMAL
- en: This data can be stolen by attackers when plugging a victim's phone into iTunes
    with the auto backup setting enabled. The attacker needs to plug in a test iDevice
    and restore it to the victim's backup. Another technique consists of using tools
    such as iFunbox which grants access to a non-jailbroken device's filesystem ([http://www.i-funbox.com/](http://www.i-funbox.com/)).
    At this point, the attacker can transfer the app's `Cache.db`, plists, and SQLite
    databases externally to gain access to session tokens and other personal account
    information. In this case, an attacker can view video feeds from the video doorbell
    and make changes to its configuration by adjusting motion settings or sharing
    the video feed to an external account.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, session management controls and API data can be viewed
    without proxying the connection. Session expiration and randomization testing
    can be analyzed according to the aforementioned Mobile App Security Checklist.
    Data within the `plist` file or the `Cache.db` can be modified and uploaded back
    to the device to observe the application's trust relationship with these files.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Additional data storage locations can be analyzed that were not covered in
    this section. Items such as the keychain, local storage, realm databases, logs,
    BinaryCookies, and many more storage locations were not discussed. Review OWASP''s
    Mobile Security Testing Guide for additional details on techniques for testing
    data storage weaknesses within iOS applications: [https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06d-Testing-Data-Storage.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06d-Testing-Data-Storage.md).'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn more about idb's features, have a look at the documentation idb has
    made available at [http://www.idbtool.com/documentation/](http://www.idbtool.com/documentation/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing Android data storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several methods for testing Android data storage during runtime.
    Free, as well as commercial, Android testing distributions are made available
    to help automate viewing and modifying common data storage file locations. In
    a manual approach, we want to analyze the following common storage locations during
    application runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/data/data/<package_name>/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/data/data/<package_name>/databases`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/data/data/<package_name>/shared_prefs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/data/data<package_name>/files/<dbfilename>.realm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires a Realm Browser ([https://itunes.apple.com/us/app/realm-browser/id1007457278?](https://itunes.apple.com/us/app/realm-browser/id1007457278?))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/data/data/<package name>/app_webview/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sdcard/Android/data/<package_name>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With Android, the file structure for applications does not change, which makes
    manual analysis easier. This recipe will assist you with analyzing data storage
    for IoT Android applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following items are required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: A rooted Android device (with USB debugging enabled) or a rooted Android emulator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android debug bridge** (**ADB**): ADB is available in the accompanied virtual
    machine or can be installed manually via the URL [https://developer.android.com/studio/releases/platform-tools.html](https://developer.android.com/studio/releases/platform-tools.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ensure a test Android device or emulator is attached using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect to the test Android device''s console and switch to the root user with
    the following ADB command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the target app''s directory as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'First, browse to the `shared_prefs` directory, list each file, and view the
    preferences file available as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8f2bec1c-8ba3-4d5c-b0a5-e18fb387ce90.png)'
  prefs: []
  type: TYPE_IMG
- en: There appears to be special encoding; the app is running on strings which may
    pertain to login credentials, but it does reveal the username of the account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will examine the `com.skybell.app.networking.oauth.oauth_shared_preferences_key.xml`
    file as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8b771c3f-4d52-4278-a78f-0f5560af21bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our account OAuth tokens appear to be stored in clear text, similar to what
    we saw in the iOS application. There is a `files` directory available which may
    have Realm database files that can be viewed. Change to the `files` directory
    and list the files, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7773cad1-5c5c-4cd3-a32c-b27ea8c65f40.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There seems to be a Realm database that the application utilizes. Take note
    of the directory where the Realm database resides and pull the file to your host
    computer using the following `adb` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: At the time of writing, Realm databases can only be viewed on an OS X computer
    using the Real Browser available in the App Store. There are unofficial Real Browsers
    for Android and iOS which need to be built from the source. More details on Realm
    databases can be found at [http://news.realm.io/news/realm-browser-tutorial/](http://news.realm.io/news/realm-browser-tutorial/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click the `default.realm` file, which will open the Realm database in
    the Real Browser, as seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3241e3d0-e5dd-4aca-a55f-436d179d16b1.png)'
  prefs: []
  type: TYPE_IMG
- en: The DeviceRecord model states the name of the doorbell and the status, whether
    it is online or not, while the DeviceRecordActivity model lists events, their
    timestamps, and thumbnails of the events. This is a type of data leakage that
    can be taken advantage of by backing up an Android device to a computer and restored
    like iPhones, or pulling the data the same way we would via ADB, if enabled. Unfortunately,
    this application did not flag `[android:allowBackup=false]` in `AndroidManifest.xml`,
    which would have mitigated this specific issue, but it is still bad practice to
    store data that leaves customers at risk or pertains to privacy concerns in this
    case.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Review OWASP's Mobile Security Testing Guide for additional details on techniques
    for testing data storage weaknesses within Android applications:Â [https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing dynamic analysis testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this stage, we have statically analyzed and assessed how data is stored within
    example IoT mobile applications. We have yet to view the API traffic sent between
    the application and server. Viewing and tampering with application communication
    at runtime is known as **dynamic analysis**. Dynamic analysis testing focuses
    on evaluating an app during its execution. Dynamic analysis is conducted both
    on the mobile platform layer as well as against the backend services and APIs
    of mobile applications, where requests and responses can be analyzed. In this
    recipe, we will set up a dynamic analysis testing environment for iOS and walk
    you through some test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, Burp Suite and/or OWASP ZAP will be used to observe application
    communication. Access to both an iDevice and an Android device is also needed
    to perform this recipe. The iDevice and Android device do not have to be jailbroken
    or rooted, which is the nice part of viewing app communications. Although these
    steps apply to both mobile platforms, examples in this recipe will be given only
    for iOS.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like configuring a web application testing environment, ZAP and Burp Suite''s
    CA certificates need to be installed on your jailbroken device to proxy `HTTPS`
    requests. This can be accomplished by adjusting the mobile device''s proxy settings
    for Wi-Fi to point to the IP and port of your Burp Suite listener, as seen in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/364d88e0-e9af-471c-b9e7-1a11bc332c70.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows how to configure proxy settings for iOS devices
    to point to your Burp proxy listener. In this case, my Burp proxy is listening
    on IP address `192.168.2.183` and port `8080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76abc6a0-33f7-419c-8429-80f31bc76dd8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, add the Burp CA certificate to the device by navigating to Burp''s IP,
    and port with `/cert` as the URL path. In this case, Burp''s address is `http://192.168.2.183:8080/cert`
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e04fb789-ca33-4229-b092-722e8a43993e.png)'
  prefs: []
  type: TYPE_IMG
- en: Once executed, iOS will ask whether you want to install a profile for Burp's
    CA certificate as seen in the following image. Select Install and `HTTPS` traffic
    can now be analyzed by Burp Suite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/22528c5a-ea59-4d64-99f0-e5fca8a637a0.png)'
  prefs: []
  type: TYPE_IMG
- en: The following screenshot shows `HTTPS` requests going through our Burp suite
    proxy from our mobile device.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/447e7e83-93aa-4351-b4ca-c5e9fdd5b778.png)'
  prefs: []
  type: TYPE_IMG
- en: HTTPS requests via Burp suite proxy
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar steps can be taken with an Android device. We will demonstrate how
    to set up ZAP''s CA certificate. First, export ZAP''s certificate by navigating
    to Tools | Options | Dynamic SSL Certificates. Save the certificate in a convenient
    location to be transferred over to the Android device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7b4d937b-ea2e-4abf-96cd-cab8cbbd01e9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `ZAPCert` needs to be downloaded onto the Android device. There are several
    methods that can assist with fulfilling this requirement. A trick that is quick
    and handy for file transfer is using Python''s `SimpleHTTPServer`. If you are
    using a Nix-based operating system, run the following command from the directory
    where the certificate resides:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The Python webserver will now be running on port `1111`. On your Android device,
    open a browser and navigate to your listening webserver. In this case, the address
    is `http://192.168.2.186:1111` as seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/765aa81c-0620-4a2a-bee6-86f718f7f53e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Download the certificate to the Android device. On the Android device, navigate
    to Settings | Security | Install from storage and theÂ Download folder should appear,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ab5204a9-abe8-4053-b931-7209b075b804.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select ZAP''s certificate and name the certificate as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7de4d427-54e3-4e62-8a4a-45f609d3182e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Navigate to your Wireless settings and modify the proxy settings to your ZAP
    proxy listener:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/900ce53b-7395-4648-86c5-ab9bfca16c0b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Navigate to the target IoT mobile application and observe `HTTPS` requests
    and responses populate ZAP''s History tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/22118096-fa90-4f4b-9ff3-e8ec2cb7f068.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Both the Android and iDevice are set up to proxy application requests and responses.
    With this access, parameters can be fuzzed for injection flaws (if testing has
    been authorized) and the app can be tested for business logic flaws. For example,
    proxying the request and responses while viewing a video from our target doorbell,
    we notice an `access_token` being sent as a URL parameter in a `GET` request directed
    to an MP4 of the video (CVE-2017-6085). Copying this `GET` request to our clipboard
    and pasting it into a browser allows access to download the MP4 video without
    a username or password, as seen in the following images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/781c9f74-c2e0-4171-bb21-c18aa0b1e266.png)'
  prefs: []
  type: TYPE_IMG
- en: MP4 video download without a username or password
  prefs: []
  type: TYPE_NORMAL
- en: 'The request is then copied to our clipboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4ffcdef1-0033-4793-924c-ecb50e821ebf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Paste the URL copied to a browser and observe the auto download of the video
    doorbell event to your local computer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b7822852-d7b4-43fd-8d40-54cb243ce21d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the copied URL is requested in the browser, the browser should automatically
    ask where to save the downloaded video on your local computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af1ad43b-205a-417a-b162-b10d2d974443.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The video is now downloaded as an `.mp4` and can be viewed as seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c6763e7-c6c6-4fe7-b938-db8e0782430e.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember, we did not input any username or password to download and watch this
    video. This shows that the doorbell manufacturer has access control issues for
    users and may indicate other holes in the product as well. For a video doorbell,
    accessing video feeds without credentials is a risk from a security and privacy
    perspective. Several vulnerabilities can be identified within this finding alone,
    which includes sending session tokens as `GET` requests, lack of token expiration,
    and insufficient access controls. An attacker may acquire the necessary `access_token`
    via social engineering or MITM techniques. Additional access control test cases
    can be performed with external user accounts as a follow-up to this finding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For some Android applications, MobSF has the capability to perform dynamic tests
    inside an emulator, virtual machine, and even a physical device. Dynamic testing
    for Android apps also includes testing intents and activities. There are some
    caveats that are listed in MobSF's wiki ([https://github.com/MobSF/Mobile-Security-Framework-MobSF/wiki/2.-Configure-MobSF-Dynamic-Analysis-Environment-in-your-Android-Device-or-VM](https://github.com/MobSF/Mobile-Security-Framework-MobSF/wiki/2.-Configure-MobSF-Dynamic-Analysis-Environment-in-your-Android-Device-or-VM)).
    If the app you are testing requires access to hardware such as the camera or wireless
    protocol (that is, Bluetooth, ZigBee, or Z-Wave), it is recommended you use a
    physical device and test manually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn more about Android and iOS application security testing, visit OWASP's
    Mobile Security Testing Guide:Â [https://github.com/OWASP/owasp-mstg/](https://github.com/OWASP/owasp-mstg/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
