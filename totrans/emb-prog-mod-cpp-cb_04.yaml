- en: Handling Interrupts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the primary tasks of embedded applications is communicating with external
    hardware peripherals. Sending data to peripherals using the output port is easy
    to understand. When it comes to reading, though, things become more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded developers have to know when data is available to be read. Since the
    peripheral is external to the processor, this can happen at any moment in time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about what interrupts are and how to work with
    them. While using an 8-bit microcontroller, 8051, as a target platform, we will
    learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to implement a basic interrupt handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to generate a signal on the output pin of the **M****icrocontroller Unit** (**MCU**)
    using interrupts from the timer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use interrupts to count events on the external pins of the MCU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use interrupts to communicate over the serial channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will learn about these topics by completing the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an interrupt service routine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a 5 kHz square signal using 8-bit auto-reload mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Timer 1 as an event counter to count a 1 Hz pulse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving and transmitting data serially
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the core concepts of how to handle interrupts will help you implement
    responsive and power-efficient embedded applications.
  prefs: []
  type: TYPE_NORMAL
- en: Before we do this, however, we'll acquire some background knowledge of a few
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Data polling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first approach to waiting for data from an external source is called **polling**.
    An application periodically queries the input port of an external device to check
    if it has new data. It is easy to implement but has significant downsides.
  prefs: []
  type: TYPE_NORMAL
- en: First, it wastes processor resources. Most poll calls report that data is not
    available yet and we need keep waiting. Since these calls do not lead to some
    data processing, it is waste of computing resources. Moreover, the polling interval
    should be short enough that it responds to an external event quickly. Developers
    should look for a compromise between the efficient utilization of processor power
    and reaction time.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, it makes the logic of the program convoluted. If the program should
    poll for events, for example, every 5 milliseconds, none of its subroutines should
    take longer than 5 milliseconds. As a result, developers artificially split the
    code into smaller chunks and organize complex switching between them to allow
    polling.
  prefs: []
  type: TYPE_NORMAL
- en: Interrupt service routines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interrupts are an alternative to polling. Once an external device has new data,
    it triggers an event in a processor called an **interrupt**. As its name suggests,
    it interrupts the normal workflow of executing instructions. The processor saves
    its current state and starts executing instructions from a different address until
    it encounters the return from an interrupt instruction. Then, it reads the saved
    state to continue executing the instruction stream from the moment it was interrupted.
    This alternative sequence of instructions is called an **Interrupt Service Routine** (**ISR**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Each processor defines its own set of instructions and conventions to work
    with interrupts; however, all of them use the same general approach while dealing
    with interrupts:'
  prefs: []
  type: TYPE_NORMAL
- en: Interrupts are identified by numbers, starting with 0\. The numbers are mapped
    to the hardware **interrupt request lines** (**IRQ**) that physically correspond
    to specific processor pins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an IRQ line is activated, the processor uses its number as an offset in
    the interrupt vector array to locate the address of the interrupt service routine.
    The interrupt vector array is stored in memory on a fixed address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers can define or redefine ISRs by updating the entries in the interrupt
    vector arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A processor can be programmed to enable or disable interrupts, either for specific
    IRQ lines or all interrupts at once. When interrupts are disabled, the processor
    does not invoke the corresponding ISRs, although the status of the IRQ lines can
    be read.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IRQ lines can be programmed to trigger interrupts, depending on the signal on
    the physical pin. This can be at the low level of the signal, the high level of
    the signal, or the edge (which is a transition from low to high or high to low).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General considerations for ISRs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This approach does not waste processor resources for polling and provides a
    very short reaction time since interrupt processing is performed at the hardware
    level. However, developers should be aware of its specifics to avoid critical
    or hard-to-detect issues in the future.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, dealing with multiple interrupts at the same time, or responding
    to the same interrupt while still handling the previous interrupt, is hard to
    implement. That is why ISRs are executed with interrupts disabled. This prevents
    the ISR from being interrupted with another interrupt, but it also means that
    the reaction time for the pending interrupt can be longer. Worse, this can lead
    to data or events being lost if interrupts are not re-enabled quickly.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid such situations, all ISRs are written to be short. They only do a minimal
    amount of work to read or acknowledge data from a device. Complex data analysis
    and processing are performed outside of the ISR.
  prefs: []
  type: TYPE_NORMAL
- en: 8051 microcontroller interrupts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The 8051 microcontroller supports six interrupt sources – reset, two hardware
    interrupts, two timer interrupts, and a serial communication interrupt:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interrupt number** | **Description** | **Offset in bytes** |'
  prefs: []
  type: TYPE_TB
- en: '|  | Reset | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | External interrupt INT0 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Timer 0 (TF0) | 11 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | External interrupt INT1 | 19 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Timer 1 (TF1) | 27 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Serial  | 36 |'
  prefs: []
  type: TYPE_TB
- en: The interrupt vector array is located at address 0; each entry except reset
    is 8 bytes in size. Though a minimal ISR can fit into 8 bytes, normally, the entries
    contain code that redirects execution to the actual ISR located elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: The reset entry is special. It is activated by the reset signal and immediately
    jumps to the address where the main program is located.
  prefs: []
  type: TYPE_NORMAL
- en: '8051 defines a special register called **Interrupt Enable** (**EA**), which
    is used to enable and disable interrupts. Its 8-bits are allocated in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit ** | **Name** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | EX0 | External Interrupt 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | ET0 | Timer 0 Interrupt |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | EX1 | External Interrupt 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | ET1 | Timer 1 Interrupt |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | ES | Serial Port Interrupt |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | - | Not used |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | - | Not used |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | EA | Global Interrupt Control |'
  prefs: []
  type: TYPE_TB
- en: Setting these bits to 1 enables corresponding interrupts, to 0 disables them.
    The EA bit enables or disables all interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an interrupt service routine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to define an interrupt service routine for
    the 8051 microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Switch to the build system we set up in [Chapter 2](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml), *Setting
    Up the Environment*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure that the 8051 emulator is installed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Launch `mcu8051ide` and create a new project called `Test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file called `test.c` and put the following code snippet into it.
    This increments an internal `counter` for each timer interrupt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Select Tools | Compile to build the code. The messages window will display
    the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Select the Simulator | Start/Shutdown menu entry to activate a simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Simulator | Animate to run the program in slow mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the C variables panel and scroll down until it shows Counter variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Observe how it increases over time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6bfb07eb-bdc2-4be0-a095-90ce3bda6141.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the Value field for the `Counter` variable is now 74.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our sample applications, we are going to use an emulator for the 8051 microcontroller.
    Several of them are available; however, we will be using MCU8051IDE since it's
    readily available in the Ubuntu repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'We install it as a regular Ubuntu package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is a GUI IDE and requires an X Window system to run. If you use Linux or
    Windows as your working environment, consider installing and running it directly
    from [https://sourceforge.net/projects/mcu8051ide/files/](https://sourceforge.net/projects/mcu8051ide/files/).
  prefs: []
  type: TYPE_NORMAL
- en: The simple program we created defines a global variable called `Counter`, as
    shown here*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is defined as `volatile`, indicating that it can be changed externally
    and that a compiler shouldn't try to optimize the code to eliminate it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define a simple function called `timer0_ISR`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It doesn't accept any parameters and doesn't return any values. The only thing
    it does is increment the `Counter` variable. It is declared with an important
    attribute called `__interrupt(1)` to let the compiler know that it is an interrupt
    handler and that it serves the interrupt number 1\. The compiler generates code
    that updates the corresponding entry of the interrupt vector array automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'After defining the ISR itself, we configure the parameters of the timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we turn on Timer 0, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command enables interrupts from Timer 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code enables all interrupts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, our ISR is being periodically activated by the timer''s interrupt.
    We run an endless loop that does nothing since all the work is done within ISR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When we run the preceding code in the simulator, we will see that the actual
    value of the `counter` variable changes over time, indicating that our ISR is
    being activated by the timer.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a 5 kHz square signal using 8-bit auto-reload mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding recipe, we learned how to create a simple ISR that only does
    a counter increment. Let's make the interrupt routine do something more useful.
    In this recipe, we will learn how to program the 8051 microcontroller so that
    it generates a signal with a given frequency.
  prefs: []
  type: TYPE_NORMAL
- en: The 8051 microcontroller has two timers – Timer 0 and Timer 1 – both of which
    are configured using two special function registers: **Timer Mode** (**TMOD**)
    and **Timer Control** (**TCON**). The timer's values are stored in the TH0 and
    TL0 timer registers for Timer 0 and the TH1 and TL1 timer registers for Timer
    1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The TMOD and TCON bits have special meanings. The bits of the TMOD registers
    are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit** | **Timer** | **Name** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | M0 | Timer mode selector – lower bit. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | M1 | Timer mode selector – upper bit. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 0 | CT | Counter (1) or Timer (0) mode. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 0 | GATE | Enable Timer 1, but only if the external interrupt of INT0
    is high. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 1 | M0 | Timer mode selector – lower bit. |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 1 | M1 | Timer mode selector – upper bit. |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 1 | CT | Counter (1) or Timer (0) mode. |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 1 | GATE | Enable Timer 1, but only if the external interrupt of INT1
    is high. |'
  prefs: []
  type: TYPE_TB
- en: The lower 4 bits are assigned to Timer 0, while the upper 4 bits are assigned
    to Timer 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The M0 and M1 bits allow us to configure the timers in one of four modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mode** | **M0** | **M1** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 13-bit mode. TL0 or TL1 registers contain lower 5 bits, TH0 or
    TH1 registers contain upper 8 bits of the corresponding timer value. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 16-bit mode. TL0 or TL1 registers contain lower 8-bits, TH0 or
    TH1 registers contain upper 8 bits of the corresponding timer value. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 1 | 0 | 8 bits mode with auto-reload. TL0 or TL1 contains the corresponding
    timer value, while TH0 or TL1 contains the reload value. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 1 | 1 | Special 8 bits mode for Timer 0 |'
  prefs: []
  type: TYPE_TB
- en: 'The **Timer** **Control** (**TCON**) registers the control''s timer interrupts.
    Its bits are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit** | **Name** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | IT0 | External interrupt 0 control bit. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | IE0 | External interrupt 0 edge flag. Set to 1 when high-to-low edge
    signal received at INT0. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | IT1 | External interrupt 1 control bit. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | IE1 | External interrupt 1 edge flag. Set to 1 when high-to-low edge
    signal received at INT1. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | TR0 | Run Control for Timer 0\. Set to 1 to start, 0 to halt the timer.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | TF0 | Timer 0 overflow. Set to 1 when the timer reaches its maximal value.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | TR1 | Run Control for Timer 1\. Set to 1 to start, 0 to halt the timer.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | TF1 | Timer 1 overflow. Set to 1 when the timer reaches its maximal value.
    |'
  prefs: []
  type: TYPE_TB
- en: We are going to use the specific mode of 8051 timers called auto-reload. In
    this mode, the TL0 (TL1 for Timer 1) register contains the timer value, while
    TH0 (TH1 for Timer 1) contains a reload value. Once TL0 reaches the maximum value
    of 255, it generates the overflow interrupt and is automatically reset to the
    reload value.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch *mce8051ide* and create a new project called `Test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file called `generator.c` and put the following code snippet into
    it. This will generate a 5 kHz signal on the `P0_0` pin of the MCU:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Select Tools | Compile to build the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Simulator | Start/Shutdown menu entry to activate a simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Simulator | Animate to run the program in slow mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code defines an ISR for Timer 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: On every timer interrupt, we flip the 0 bit of P0's input-output register. This
    will efficiently generate the square wave signal on a P0 output pin.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to figure out how to program the timer to generate interrupts with
    the given frequency. To generate the 5 kHz signal, we need to flip the bit with
    the 10 kHz frequency since each wave consists of one high and one low phase.
  prefs: []
  type: TYPE_NORMAL
- en: The 8051 MCU uses an external oscillator as a clock source. The timer unit divides
    the external frequency by 12\. For the 11.0592 MHz oscillator, which is commonly
    used as a time source for 8051, the timer is activated every 1/11059200*12 = 1.085
    milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Our timer ISR should be activated with 10 kHz frequency, or every 100 milliseconds,
    or after every 100/1.085 = 92 timer ticks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We programmed Timer 0 to run in mode two, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this mode, we store the reset value of the timer in the TH0 register. The
    ISR is activated by the timer overflow, which happens after the timer counter
    reaches the maximum value. Mode two is an 8-bit mode, meaning the maximum value
    is 255\. To activate the ISR every 92 ticks, the auto-reload value should be 255-92
    = 163, or `0xa3` in hexadecimal representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We store the auto-reload value along with the initial timer value in the timer
    registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Timer 0 is activated, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we enable timer interrupts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, all the interrupts are activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'From now on, our ISR is invoked every 100 microseconds, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This flips the `0` bit of the `P0` register, resulting in the 5 kHz square signal
    being produced on the corresponding output pin.
  prefs: []
  type: TYPE_NORMAL
- en: Using Timer 1 as an event counter to count a 1 Hz pulse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 8051 timers have dual functionality. When they are activated by the clock oscillator,
    they act as timers. However, they can also be activated by the signal pulse on
    the external pins, that is, P3.4 (Timer 0) and P3.5 (Timer 1), acting as counters.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to program Timer 1 so that it counts the activations
    of the P3.5 pin of the 8051 processor.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Open mcu8051ide.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new project called `Counters`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file called `generator.c` and put the following code snippet into
    it. This increments a counter variable each time a timer interrupt is triggered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Select Tools | Compile to build the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Virtual HW menu and select the Simple Key... entry. A new window will
    open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Simple Keypad window, assign PORT 3 and BIT 5 to the first key. Then,
    click the ON or OFF button to activate it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5c45f07b-20cb-4009-93d0-312fa4abe748.png)'
  prefs: []
  type: TYPE_IMG
- en: Select the Simulator | Start/Shutdown menu entry to activate the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Simulator | Animate to run the program in the animation mode that displays
    all changes to the special registers in the debugger window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the Simple Keypad window and click the first key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we utilize the capability of 8051 timers so that they act as
    counters. We define an interrupt service routine in exactly the same way as we
    do for ordinary timers. Since we use Timer 1 as a counter, we use interrupt line
    number `3`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The body of the interrupt routine is simple. We only increment the `counter`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s ensure the ISR is activated by the external source rather than
    the clock oscillator. To do so, we configure Timer 1 by setting the C/T bit of
    the `TMOD` special function register to one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The same line configures Timer 1 to run in Mode 2 – 8-bit mode with auto-reload.
    Since our goal is to make the interrupt routine invoked on every external pin
    activation, we set the auto-reload and initial values to the maximum value of
    `254`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we enable Timer 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, all the interrupts from Timer 1 are activated, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can enter the endless loop that does nothing since all the work
    is done in the Interrupt Service Routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we can run the code in the emulator. However, we need to configure
    the external source of events. For this purpose, we utilize one of the virtual
    external hardware components supported by MCU8051IDE – the virtual keypad.
  prefs: []
  type: TYPE_NORMAL
- en: We configure one of its keys to activate pin P3.5 of 8051\. This pin is used
    as a source for Timer 1 when it is used in counting mode.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we run the code. Pressing the virtual key activates the counter. Once the
    timer value overflows, our ISR is triggered, incrementing the `counter` variable.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we used Timer 1 as a counter. The same can be applied to Counter
    0\. In this case, pin P3.4 should be used as an external source.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving and transmitting data serially
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 8051 microcontrollers come with a built-in **Universal Asynchronous Receiver
    Transmitter** (**UART**) port for serial data exchange.
  prefs: []
  type: TYPE_NORMAL
- en: 'The serial port is controlled by a **Special Function Register** (**SFR**)
    called **Serial Control** (**SCON**). Its bits are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit** | **Name** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | **RI** (short for **Receive** **Interrupt**) | Set by UART when a byte
    is received completely |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | **TI** (short for **Transmit** **Interrupt**) | Set by UART when a byte
    is transmitted completely |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | **RB8** (short for **Receive** **Bit** **8**) | Stores the ninth bit
    of the received data in 9-bit mode. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | **TB8** (short for **Transmit Bit 8**) | Stores the ninth bit of data
    to be transmitted in 9-bit mode (see below) |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | **REN** (short for **Receiver Enabled**) | Enables (1) or disables (0)
    the receive operation |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | **SM2** (Enable Multiprocessor) | Enables (1) or disables (0) multiprocessor
    communication for 9-bit mode |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | **SM1** (Serial Mode, high bit) | Defines the serial communication mode
    |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | **SM0** (Serial Mode, low bit) | Defines the serial communication mode
    |'
  prefs: []
  type: TYPE_TB
- en: '8051 UART supports four m of serial communication modes, all of which are defined
    by the SM1 and SM0 bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mode** | **SM0** | **SM1** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | Shift-register, fixed baud rate |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 8-bit UART, baud rate set with Timer 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 1 | 0 | 9-bit UART, fixed baud rate  |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 1 | 1 | 9-bit UART, baud rate set with Timer 1 |'
  prefs: []
  type: TYPE_TB
- en: In this recipe, we will learn how to use interrupts to implement a simple data
    exchange over a serial port using the 8-bit UART mode with a programmable baud
    rate (mode 1).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Open mcu8051ide and create a new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file called `serial.c` and copy the following code snippet into
    it. This code copies the bytes that were received over the serial link to the
    `P0` output register. This is associated with the general-purpose input/output
    pins on the MCU:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Select Tools | Compile to build the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Simulator | Start/Shutdown menu entry to activate the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We define an ISR for interrupt line `4`, which is triggered for serial port
    events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The interrupt routine is invoked as soon as a full byte is received and stored
    in the **Serial buffer register** (**SBUF**). Our implementation of ISR just copies
    the received byte to the input/output port, that is, `P0` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Then, it resets the RI flag to enable the interrupt for the upcoming byte.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the interrupts work as expected, we configure both the serial port
    and the timer. First, the serial port is configured, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: According to the preceding table, this means only the SM1 and REN bits of the **Serial
    Control Register** (**SCON**) are set to 1, resulting in the selection of communication
    mode 1\. This is an 8-bit UARS with a baud rate defined via Timer 1\. Then, it
    enables the receiver.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the baud rate is defined by Timer 1, the next step is to configure the
    timer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code configures Timer 1 to use mode 2, which is the 8-bit auto-reload
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: Loading 0xFD into the TH1 register sets the baud rate to 9600 bps. Then, we
    enable Timer 1, serial interrupts, and all interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data transmission can be implemented in a similar way. If you write data to
    the SBUF special register, the 8051 UART will start transmission. Once completed,
    a serial interrupt will be invoked and the TI flag will be set to 1.
  prefs: []
  type: TYPE_NORMAL
