- en: Working with the Filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is all about interacting with the Unix filesystem. Here, we will
    look at everything from the basic read and write operations to more advanced buffered
    operations, like token scanning and file monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: All of the information for the user or the system is stored as a file in Unix,
    so in order to interact with the system and user data, we must interact with the
    filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see that there are different ways of executing read
    and write operations, and how each one is focused more on simplicity of the code,
    the memory usage of the application and its performance, as well as the speed
    of execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: File path manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other filesystem operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires Go to be installed and your favorite editor to be set
    up. For more information, please refer to [Chapter 3](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml),
    *An Overview of Go*.
  prefs: []
  type: TYPE_NORMAL
- en: Handling paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go offers a series of functions that make it possible to manipulate file paths
    that are platform-independent and that are contained mainly in the `path/filepath` and `os`
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: Working directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each process has a directory associated with it called the **working directory**,
    which is usually inherited from the parent process. This makes it possible to
    specify relative paths – one that doesn't start with the root folder. This will
    be `/` on Unix and macOS and `C:\` (or any other drive letter) on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: An absolute/full path starts with the root directory and it represents the same
    location in a filesystem, that is, `/usr/local`.
  prefs: []
  type: TYPE_NORMAL
- en: A relative path doesn't start with a root, and the path starts with the current
    working directory, that is, `documents`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The operating system interprets these paths as being relative to the current
    directory, so their absolute version is a concatenation of the working directory
    and the relative path. Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, the user is in their home folder, `~`. The user specifies to change directory
    to `documents`, and the `cd` command automatically adds the working directory
    as a prefix to it and moves to `~/documents`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on to the second command, let''s introduce two special files
    that are available in all the directories for all operative systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.`: The dot is a reference to the current directory. If it''s the first element
    of the path, it is the process working directory, otherwise it refers to the path
    element that precedes it (for example, in `~/./documents`, `.` refers to `~`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`..`: The double dot refers to the parent of the current directory if it''s
    the first element of the path, or to the parent of the directory that it precedes
    if not (for example, in `~/images/../documents`, `..` refers to the parent of
    `~/images`, `~`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing this, we can easily infer that the second path is first joined in `~/documents/../videos`,
    the parent element, `..`, gets resolved, and the final path, `~/videos`, is obtained.
  prefs: []
  type: TYPE_NORMAL
- en: Getting and setting the working directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use the `func Getwd() (dir string, err error)` function of the `os` package
    to find out which path represents the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the working directory is done with another function of the same package,
    that is, `func Chdir(dir string) error`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Path manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `filepath` package contains less than 20 functions, which is a small number
    compared to the packages of the standard library, and it''s used to manipulate
    paths. Let''s take a quick look at these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func Abs(path string) (string, error)`: Returns the absolute version of the
    path that''s passed by joining it to the current working directory (if it''s not
    already absolute), and then cleans it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Base(path string) string`: Gives the last element of the path (base).
    For instance, `path/to/some/file` returns the file*.* Note that if the path is
    empty, this function returns a `*.*` (dot) path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Clean(path string) string`: Returns the shortest version of the path
    by applying a series of defined rules. It does operations like replacing `.` and
    `..`, or removing trailing separators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Dir(path string) string`: Gets the path without its last element. This
    usually returns the parent directory of the element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func EvalSymlinks(path string) (string, error)`: Returns the path after evaluating
    symbolic links. The path is relative if the provided path is also relative and
    doesn''t contain symbolic links with absolute paths.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Ext(path string) string`: Gets the file extension of the path, the suffix
    that starts with the final dot of the last element of the path, and it''s an empty
    string if there''s no dot (for example, `docs/file.txt` returns `.txt`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func FromSlash(path string) string`: Replaces all `/` (slashes) found in the
    path with the operative system path separator. This function does nothing if the
    OS is Windows, and it executes a replacement under Unix or macOS .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Glob(pattern string) (matches []string, err error)`: Finds all files
    matching the specified pattern. If there are no matching files, the result is
    `nil`. It doesn''t report eventual errors that occur during path exploration.
    It shares syntax with `Match`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func HasPrefix(p, prefix string) bool`: This function is deprecated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func IsAbs(path string) bool`: Shows if the path is absolute or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Join(elem ...string) string`: Concatenates multiple path elements by
    joining them with the filepath separator. Note that this also calls `Clean` on
    the result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Match(pattern, name string) (matched bool, err error)`: Verifies that
    the given name matches the pattern, allowing the use of the wild `char` characters
    `*` and `?`, and groups or sequences of characters using square brackets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Rel(basepath, targpath string) (string, error)`: Returns the relative
    path from the base to the target path, or an error if this is not possible. This
    function calls `Clean` on the result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Split(path string) (dir, file string)`: Divides the path into two parts
    using the final trailing slash. The result is usually the parent path and the
    file name of the input path. If there is no separator, `dir` will be empty and
    the file will be the path itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func SplitList(path string) []string`: Returns a list of paths, separating
    them with the list separator character, which is `:` in Unix and macOS and `;`
    in Windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func ToSlash(path string) string`: Operates the opposite substitution that
    the `FromSlash` function executes, changing each path separator to a `/`, doing
    nothing on Unix and macOS, and executing the replacement in Windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func VolumeName(path string) string`: This does nothing in platforms that
    aren''t Windows. It returns the path component which refers to the volume. This
    is done for both local paths and network resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Walk(root string, walkFn WalkFunc)` `error`: Starting from the root directory,
    this function travels recursively through the file tree, executing the walk function
    for each entry of the tree. If the walk function returns an error, the walk stops
    and that error is returned. The function is defined as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Before moving on to the next example, let''s introduce an important variable:
    `os.Args`. This variable contains at least one value, which is the path that invoked
    the current process. This can be followed by eventual arguments that are specified
    in the same call.'
  prefs: []
  type: TYPE_NORMAL
- en: We want to realize a small application that lists and counts the number of files
    in a directory. We can use some of the tools we just saw to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the list and count files is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Reading from files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting the contents of a file can be done with an auxiliary function in the
    `io/ioutil` package, as well as with the  `ReadFile` function, which opens, reads,
    and closes the file at once. This uses a small buffer (512 bytes) and loads the
    whole content in memory. This is not a good idea if the file size is very large,
    unknown, or if the content of the file can be processed one part at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a huge file from disk at once means copying all the file's content into
    the primary memory, which is a limited resource. This can cause memory shortages,
    as well as runtime errors. Reading chunks of a file at a time can help read the
    content of big files without causing huge memory usage. This is because the same
    part of the memory will be reused when reading the next chunk.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of reading all the content at once is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Reader interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For all operations that read from a disk, there''s an interface that is paramount:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Its job is really simple – fill the given slice of bytes with the content that's
    been read and return the number of bytes that's been read and an error, if one
    occurs. There is a special error variable that's defined by the `io` package,
    called `EOF` (**End Of File**), which should be returned when there is no more
    input available.
  prefs: []
  type: TYPE_NORMAL
- en: A reader makes it possible to process data in chunks (the size is determined
    by the slice), and if the same slice is reused for the operations that follow,
    the resulting program is consistently more memory efficient because it is using
    the same limited part of the memory that allocates the slice.
  prefs: []
  type: TYPE_NORMAL
- en: The file structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `os.File` type satisfies the reader interface and is the main actor that's
    used to interact with file contents. The most common way to obtain an instance
    for reading purposes is with the `os.Open` function. It's very important to remember
    to close a file when you're done using it – this will not be obvious with short-lived
    programs, but if an application keeps opening files without closing the ones that
    it's done with, the application will reach the limit of open files imposed by
    the operating system and start failing the opening operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shell offers a couple of utilities, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: One to get the limit of open files – `ulimit -n`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another to check how many files are open by a certain process – `lsof -p PID`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The previous example opens a file just to show its contents to standard output,
    which it does by loading all its content in memory. This can be easily optimized
    with the tools we just mentioned. In the following example, we are using a small
    buffer and printing its content before it gets overridden by the next read, using
    a small buffer to keep memory usage at a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of using a byte array as a buffer is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The reading loop, if everything works as expected, will continue executing read
    operations until the file content is over. In that case, the reading loop will
    return an `io.EOF` error, which shows that there is no more content available.
  prefs: []
  type: TYPE_NORMAL
- en: Using buffers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **data buffer**, or just a buffer, is a part of memory that is used to store
    temporary data while it is moved. Byte buffers are implemented in the `bytes`
    package, and they are implemented by an underlying slice that is capable of growing
    every time the amount of data that needs to be stored will not fit.
  prefs: []
  type: TYPE_NORMAL
- en: If new buffers get allocated each time, the old ones will eventually be cleaned
    up by the GC itself, which is not an optimal solution. It's always better to reuse
    buffers instead of allocating new ones. This is because they make it possible
    to reset the slice while keeping the capacity as it is (the array doesn't get
    cleared or collected by the GC).
  prefs: []
  type: TYPE_NORMAL
- en: A buffer also offers two functions to show its underlying length and capacity.
    In the following example, we can see how to reuse a buffer with `Buffer.Reset`
    and how to keep track of its capacity.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of buffer reuse and its underlying capacity is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Peeking content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we fixed a number of bytes in order to store the content
    at every read before printing it. Some functionality is offered by the `bufio`
    package that makes it possible to use an underlying buffer that is not directly
    controlled by the user, and makes it possible to execute a very important operation
    named *peek*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Peeking** is the ability to read content without advancing the reader cursor.
    Here, under the hood, the peeked data is stored in the buffer. Each reading operation
    checks whether there''s data in this buffer and if there is any, that data is
    returned while removing it from the buffer. This works like a queue (first in,
    first out).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The possibilities that this simple operation opens are endless, and they all
    derive from peeking until the desired sequence of data is found, and then the
    interested chunk is actually read. The most common uses of this operation include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The buffers keeps reading from the reader until it finds a newline character
    (read one line at time).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same operation is used until a space is found (read one word at a time).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The structure that allows an application to achieve this behavior is `bufio.Scanner`.
    This makes it possible to define what the splitting function is and has the following
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This function stops when an error is returned, otherwise it returns the number
    of bytes to advance in the content, and eventually a token. The implemented functions
    in the package are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ScanBytes`: Byte tokens'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScanRunes`: Runes tokens'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScanWord`: Words tokens'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScanLines`: Line tokens'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could implement a file reader that counts the number of lines with just a
    reader. The resulting program will try to emulate what the Unix `wc -l` command
    does.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of printing a file and counting lines is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Closer and seeker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two other interfaces that are related to readers: `io.Closer` and
    `io.Seeker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'These are usually combined with `io.Reader`, and the resulting interfaces are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `Close` method ensures that the resource gets released and avoids leaks,
    while the `Seek` method makes it possible to move the cursor of the current object
    (for example, a `Writer`) to the desired offset from the start/end of the file,
    or from its current position.
  prefs: []
  type: TYPE_NORMAL
- en: The `os.File` structure implements this method so that it satisfies all the
    listed interfaces. It is possible to close the file when the operations are concluded,
    or to move the current cursor around, depending on what you are trying to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen for reading, there are different ways to write files, each one
    with its own flaws and strengths. In the `ioutil` package, for instance, we have
    another function called `WriteFile` that allows us to execute the whole operation
    in one line. This includes opening the file, writing its contents, and then closing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of writing all a file''s content at once is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This example writes all the content at once in a single operation. This requires
    that we allocate all the content in memory using a byte slice. If the content
    is too large, memory usage can become a problem for the OS, which could kill the
    process of our application.
  prefs: []
  type: TYPE_NORMAL
- en: If the size of the content isn't very big and the application is short-lived,
    it's not a problem if the content gets loaded in memory and written with a single
    operation. This isn't the best practice for long-lived applications, which are
    executing reads and writes to many different files. They have to allocate all
    the content in memory, and that memory will be released by the GC at some point
    – this operation is not cost-free, which means that is has disadvantages regarding
    memory usage and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Writer interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The same principle that is valid for reading also applies for writing – there''s
    an interface in the `io` package that determines writing behaviors, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `io.Writer` interface defines one method that, given a slice of bytes, returns
    how many of them have been written and/or if there's been any errors. A writer
    makes it possible to write data one chunk at a time without there being a requirement
    to have it all at once. The `os.File` struct also happens to be a writer, and
    can be used in such a fashion.
  prefs: []
  type: TYPE_NORMAL
- en: We can use a slice of bytes as a buffer to write information piece by piece.
    In the following example, we will try to combine reading from the previous section
    with writing, using the `io.Seeker` capabilities to reverse its content before
    writing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of reversing the contents of a file is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After moving to the end of the file and defining a byte buffer, we enter a
    loop that goes a little backwards in the file, then reads a section of it, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we reverse the content and write it to the destination, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Buffers and format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we saw how `bytes.Buffer` can be used to store data
    temporarily and how it handles its own growth by appending the underlying slice.
    The `fmt` package extensively uses buffers to execute its operations; these aren''t
    the ones in the bytes package for dependency reasons. This approach is inherent
    to one of Go''s proverbs:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A little copy is better than a little dependency."'
  prefs: []
  type: TYPE_NORMAL
- en: If you have to import a package to use one function or type, you should consider
    just copying the necessary code into your own package. If a package contains much
    more than what you need, copying allows you to reduce the final size of the binary.
    You can also customize the code and tailor it to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another use of buffers is to compose a message before writing it. Let''s write
    some code so that we can use a buffer to format a list of books:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The buffer is used to compose the book description, where the year is omitted
    if it''s not present. This is very efficient when handling bytes and even better
    if the buffer is reused each time. If the output of this kind of operation should
    be a string, there is a very similar struct in the `strings` package called `Builder` that
    has the same write methods but some differences, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `String()` method uses the `unsafe` package to convert the bytes into a
    string, instead of copying them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not permitted to copy a `strings.Builder` and then write to the copy since
    this causes a `panic`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficient writing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each time the `os.File` method, that is, `Write`, is executed, this translates
    to a system call, which is an operation that comes with some overhead. Generally
    speaking, it's a good idea, to minimize the number of operations by writing more
    data at once, thus reducing the time that's spent on such calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bufio.Writer` struct is a writer that wraps another writer, like `os.File`,
    and executes write operations only when the buffer is full. This makes it possible
    to execute a forced write with the `Flush` method, which is generally reserved
    until the end of the writing process. A good pattern of using a buffer would be
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`defer` statements are executed in reverse order before returning the current
    function, so the first `Flush` ensures that whatever is still on the buffer gets
    written, and then `Close` actually closes the file. If the two operations were
    executed in reverse order, flush would have tried to write a closed file, returning
    an error, and failed to write the last chunk of information.'
  prefs: []
  type: TYPE_NORMAL
- en: File modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw that the `os.OpenFile` function makes it possible to choose how to open
    a file with the file mode, which is a `uint32` where each bit has a meaning (like
    Unix files and folder permissions). The `os` package offers a series of values,
    each one specifying a mode, and the correct way to combine them is with `|` (bitwise
    OR).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the ones that are available, and have been taken directly
    from Go''s source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The first three represent the operation that''s allowed (read, write, or both),
    and the others are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`O_APPEND`: Before each write, the file offset is positioned at the end of
    the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`O_CREATE`: Makes it possible to create the file if it doesn''t exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`O_EXCL`: If this is used with create, it fails if the file already exists
    (exclusive creation).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`O_SYNC`: Executes a read/write operation and verifies its competition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`O_TRUNC`: If the file exists, its size is truncated to `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read and write are not the only operations that can be executed on a file. In
    the following section, we'll look at how to use them using the `os` package.
  prefs: []
  type: TYPE_NORMAL
- en: Create
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to create an empty file, we can call a helper function called `Create`,
    which opens a new file with a `0666` permission and truncates it if it doesn''t
    exist. Alternatively, we can use `OpenFile` with the `O_CREATE|O_TRUNCATE` mode
    to specify custom permissions, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Truncate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To truncate the content of a file under a certain dimension, and leave the
    file untouched if it''s smaller, there is the `os.Truncate` method. Its usage
    is pretty simple, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Delete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to delete a file, there is another simple function, called `os.Remove`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Move
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `os.Rename` function makes it possible to change a file name and/or its
    directory. Note that this operation replaces the destination file if it already
    exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for changing a file''s name or its directory is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Copy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s no unique function that makes it possible to copy a file, but this
    can easily be done with a reader and a writer with the `io.Copy` function. The
    following example shows how to use it to copy from one file to another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Stats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `os` package offers the `FileInfo` interface, which returns the metadata
    of a file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `os.Stat` function returns information about the file with the specified
    path.
  prefs: []
  type: TYPE_NORMAL
- en: Changing properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to interact with the filesystem and change these properties, three
    functions are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func Chmod(name string, mode FileMode) error`: Changes the permissions of
    a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Chown(name string, uid, gid int) error`: Changes the owner and group
    of a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Chtimes(name string, atime time.Time, mtime time.Time) error`: Changes
    the access and modification time of a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The community offers many packages that accomplish all kinds of tasks. We will
    take a quick look at some of these in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Files are a struct in Go, a concrete type, and there's no abstraction around
    them, whereas a file's information is represented by `os.FileInfo`, which is an
    interface. This is slightly inconsistent, and there have been many attempts to
    create a full and consistent abstraction on the filesystem, commonly referred
    to as a *virtual filesystem*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two of the most used packages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vfs`: [github.com/blang/vfs](https://github.com/blang/vfs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`afero`: [github.com/spf13/afero](https://github.com/spf13/afero)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if they are developed separately, they both do the same thing – they define
    an interface with all the methods of `os.File`, and then they define an interface
    that implements the function that's available in the `os` package, like creating,
    opening, and deleting files, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: They offer a version based on `os.File` that's implemented using the standard
    package, but there's also a memory version that uses data structures that emulate
    a filesystem. This can be very useful for building a test for any package.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go has some experimental features in the `golang.org/x/` package that are located
    under Go's GitHub handler ([https://github.com/golang/](https://github.com/golang/)).
    The `golang.org/x/sys` package is part of this list and includes a subpackage
    dedicated to Unix system events. This has been used to build a feature that is
    missing from Go's file functionality and can be really useful – observing a certain
    path for events on files like creation, deletion, and update.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two most famous implementations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`notify`: [github.com/rjeczalik/notify](https://github.com/rjeczalik/notify)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fsnotify`: [github.com/fsnotify/fsnotify](https://github.com/fsnotify/fsnotify)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both packages expose a function that allows the creation of watchers. Watchers
    are structures that contain channels that are in charge of delivering file events.
    They also expose another function that 's responsible for terminating/closing
    the watchers and underlying channels.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at an overview of how to execute file operations
    in Go. In order to locate files, an extensive array of functions are offered by
    the `filepath` package. These can help you execute all kind of operations, from
    composing paths to extracting elements from it.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at how to read an operation using various methods, from the easiest
    and less memory efficient ones that are located in the `io/ioutil` package to
    the ones that require an `io.Writer` implementation to read a fixed chunk of bytes.
    The importance of the ability to peek content, as implemented in the `bufio` package,
    allows for a whole set of operations like read word or read line, which stop the
    reading operation when a token is found. There are other interfaces that are satisfied
    by files that are very useful; for example, `io.Closer` ensures that the resource
    is released, and `io.Seeker` is used to move the reading cursor around without
    the need to actually read the file and discard the output.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a slice of bytes to a file can be achieved in different ways – the `io/ioutil`
    package makes it possible to do so with a function call, while for more complex
    or more memory-efficient operations, there's the `io.Writer` interface. This makes
    it possible to write a slice of bytes at a time, and can be used by the `fmt`
    package to print formatted data. The buffered writing is used to reduce the amount
    of actual writing on the disk. This is done with a buffer that collects the content,
    which then transfers it to a disk every time it gets full.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how to accomplish other file operations on the filesystem (creating,
    deleting, copying/moving, and changing a file's attributes) and took a look at
    some of the filesystem-related third-party packages, that is, virtual filesystem
    abstraction and filesystem events notifications.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be about streams, and will focus on all the instances
    of readers and writers that are not related to the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's the difference between absolute and relative paths?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you obtain or change the current working directory?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages and downfalls of using `ioutil.ReadAll`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are buffers important for reading operations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use `ioutil.WriteFile`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which operations are available when using a buffered reader that allows peeking?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it better to read content using a byte buffer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can buffers be used for writing? What's the advantage of using them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
