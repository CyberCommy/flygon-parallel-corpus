- en: PWM Drivers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Pulse Wide Modulation** (**PWM** ) operates like a switch that constantly
    cycles on and off. It is a hardware feature used to control servomotors, for voltage
    regulation, and so on. The most well-known applications of PWM are:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Motor speed control
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Light dimming
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Voltage regulation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let us introduce PWM with a simple following figure:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00038.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
- en: 'The preceding figure describes a complete PWM cycle, introducing some terms
    we need to clarify prior to getting deeper into the kernel PWM framework:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '`Ton` : This is the duration during which the signal is high.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Toff` : This is the duration during which the signal is low.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Period` : This is the duration of a complete PWM cycle. It represents the
    sum of `Ton` and `Toff` of the PWM signal.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Duty cycle` : It is represented as a percentage of the time signal that remains
    on during the period of the PWM signal.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Different formulas are detailed as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'PWM period: ![](img/Image00039.gif)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Duty cycle: ![](img/Image00040.gif)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find details about PWM at [https://en.wikipedia.org/wiki/Pulse-width_modulation](https://en.wikipedia.org/wiki/Pulse-width_modulation)
    .
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'The Linux PWM framework has two interfaces:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '**Controller interface** : The one that exposes the PWM line. It is the PWM
    chip, that is, the producer.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Consumer interface** : The device consuming PWM lines exposed by the controller.
    Drivers of such devices use helper functions exported by the controller by means
    of a generic PWM framework.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Either the consumer or producer interface depends on the following header file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this chapter, we will deal with:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: PWM driver architecture and data structures, for both controller and consumer,
    along with a dummy driver
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiating PWM devices and controllers in the device tree
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requesting and consuming PWM devices
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using PWM from user space through sysfs interface
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PWM controller driver
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you need `struct gpio_chip` when writing GPIO-controller drivers and `struct
    irq_chip` when writing IRQ-controller drivers, a PWM controller is represented
    in the kernel as an instance of `struct pwm_chip` structure.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00041.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: PWM controller and devices
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is the meaning of each elements in the structure:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '`dev` : This represents the device associated with this chip.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ops` : This is a data structure providing callback functions this chip exposes
    to consumer drivers.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Base` : This is the number of the first PWM controlled by this chip. If `chip->base
    < 0` then, the kernel will dynamically assign a base.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`can_sleep` : This should be set to `true` by the chip driver if `.config()`
    , `.enable()` , or `.disable()` operations of the ops field may sleep.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npwm` : This is the number of PWM channels (devices) this chip provide.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pwms` : This is an array of PWM devices of this chip, allocated by the framework,
    to consumer drivers.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`of_xlate` : This is an optional callback to request a PWM device given a DT
    PWM specifier. If not defined, it will be set to `of_pwm_simple_xlate` by the
    PWM core, which will force `of_pwm_n_cells` to `2` as well.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`of_pwm_n_cells` : This is the number of cells expected in the DT for a PWM
    specifier.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PWM controller/chip adding and removal rely on two basic functions, `pwmchip_add()`
    and `pwmchip_remove()` . Each function should be given a filled in `struct pwm_chip`
    structure as an argument. Their respective prototypes are as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Unlike other framework removal functions that do not have return values, `pwmchip_remove()`
    has a return value. It returns `0` on success, or `-EBUSY` if the chip has a PWM
    line still in use (still requested).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Each PWM driver must implement some hooks through the `struct pwm_ops` field,
    which is used by the PWM core or the consumer interface in order to configure
    and make full use of its PWM channels. Some of them are optional.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let us see what each element in the structure means:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '`request` : This is an optional hook that, if provided, is executed during
    a PWM channel request.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`free` : This is the same as request, ran during PWM freeing.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config` : This is the PMW configuration hook. It configures duty cycles and
    period length for this PWM.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_polarity` : This hook configures the polarity of this PWM.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Enable` : This enables the PWM line, starting output toggling.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Disable` : This disables the PWM line, stopping output toggling.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Apply` : This atomically applies a new PWM config. The state argument should
    be adjusted with the real hardware config.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_state` : This returns the current PWM state. This function is only called
    once per PWM device when the PWM chip is registered.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Owner` : This is the module that owns this chip, usually `THIS_MODULE` .'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `probe` function of the PWM controller driver, it is good practice to
    retrieve DT resources, initialize hardware, fill a `struct pwm_chip` and its `struct
    pwm_ops` , and then, add the PWM chip with the `pwmchip_add` function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Driver example
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let us summarize things by writing a dummy driver for a PWM controller,
    which has three channels:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: PWM controller binding
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While binding the PWM controller from within the DT, the most important property
    is `#pwm-cells` . It represents the number of cells used to represent a PWM device
    of this controller. If you remember, in the `struct pwm_chip` structure, the `of_xlate`
    hook is used to translate a given PWM specifier. If the hook has not been set,
    `pwm-cells` here must be set to 2, else, it should be set with the same value
    as `of_pwm_n_cells` . The following is an example of a PWM controller node in
    the DT, for an i.MX6 SoC.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'On the other hand, the node that corresponds to our fake-pwm driver looks like:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: PWM consumer interface
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A consumer is the device that actually uses PWM channels. A PWM channel is
    represented in the kernel as an instance of `struct pwm_device` structure:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Label` : This is the name of this PWM device'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flags` : This represents the flags associated with the PWM device'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hwpw` : This is a relative index of the PWM device, local to the chip'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pwm` : This is a system global index of the PWM device'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chip` : This is a PWM chip, the controller providing this PWM device'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chip_data` : This is chip-private data associated with this PWM device'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since kernel v4.7, the structure changed into:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`args` : This represents the board-dependent PWM arguments attached to this
    PWM device, which are usually retrieved from the PWM lookup table or device tree.
    PWM arguments represent the initial configuration that users want to use on this
    PWM device rather than the current PWM hardware state.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state` : This represents the current PWM channel state.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Over Linux evolutions, the PWM framework faced several changes. These changes
    concern the way one requests PWM devices from within the consumer side. We can
    split the consumer interface into two parts, or more precisely into two versions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '**The legacy version** , where you use `pwm_request()` and `pwm_free()` in
    order to request a PWM device and free it after usage.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '**The new and recommended API** , using `pwm_get()` and `pwm_put()` functions.
    The former is given the consumer device along with the channel name as arguments
    to request the PWM device, and the second is given the PWM device to be freed
    as a parameter. Managed variants of these functions, `devm_pwm_get()` and `devm_pwm_put()`
    , also exist.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`pwm_request()` /`pwm_get()` and `pwm_free()` /`pwm_put()` cannot be called
    from an atomic context, since the PWM core make use of mutexes, which may sleep.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'After being requested, a PWM has to be configured using:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To start/stop toggling the PWM output, use `pwm_enable()` /`pwm_disable()` .
    Both functions take a pointer to a `struct pwm_device` as a parameter, and are
    all wrappers around hooks exposed by the controller through the `pwm_chip.pwm_ops`
    field.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`pwm_enable()` returns `0` on success, or a negative error code on failure.
    A good example of a PWM consumer driver is `drivers/leds/leds-pwm.c` in the kernel
    source tree. The following is an example of consumer code, driving a PWM led:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: PWM clients binding
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PWM devices can be assigned to the consumer from:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Device tree
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ACPI
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static lookup tables, in board `init` file.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This book will only deal with DT binding, as it is the recommended method. When
    binding a PWM consumer (client) to its driver, you need to provide the phandle
    of the controller to which it is linked.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended you give the name `pwms` to PWM properties; since PWM devices
    are named resources, you can provide an optional property `pwm-names,` containing
    a list of strings to name each of the PWM devices listed in the `pwms` property.
    In case no `pwm-names` property is given, the name of the user node will be used
    as fallback.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Drivers for devices that use more than a single PWM device can use the `pwm-names`
    property to map the name of the PWM device requested by the `pwm_get()` call to
    an index into the list given by the `pwms` property.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example describes a PWM-based backlight device, which is an excerpt
    from the kernel documentation on PWM device binding (see *Documentation/devicetree/bindings/pwm/pwm.txt*
    ):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The PWM-specifier typically encodes the chip-relative PWM number and the PWM
    period in nanoseconds. With the line as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`0` corresponds to the PWM index relative to the controller, and `5000000`
    represents the period in nanoseconds. Note that in the preceding example, specifying
    the `pwm-names` is redundant because the name `backlight` would be used as a fallback
    anyway. Therefore, the driver would have to call:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The PWM-specifier typically encodes the chip-relative PWM number and the PWM
    period in nanoseconds.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Using PWMs with the sysfs interface
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The PWM core `sysfs` root path is `/sys/class/pwm/` . It is the user space
    way to manage PWM device. Each PWM controller/chip added to the system creates
    a `pwmchipN` directory entry under the `sysfs` root path, where `N` is the base
    of the PWM chip. The directory contains the following files:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '`npwm` : This is a reads only file printing the number of PWM channels that
    this chip supports'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Export` : This is a write-only file allowing to export a PWM channel for use
    with `sysfs` (this functionality is equivalent to GPIO sysfs interface)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unexport` : Unexports a PWM channel from `sysfs` (write-only)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The PWM channels are numbered using an index from 0 to `pwm<n-1>` . These numbers
    are local to the chip. Each PWM channel exportation creates a `pwmX` directory
    in the `pwmchipN` , which is the same directory as the one containing the `export`
    file used. **X** is the number of the channel that was exported. Each channel
    directory contains the following files:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '`Period` : This is a readable/writable file to get/set the total period of
    the PWM signal. Value is in nanoseconds.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`duty_cycle` : This is a readable/writable file to get/set the duty cycle of
    the PWM signal. It represents the active time of the PWM signal. Value is in nanoseconds
    and must always be less than the period.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Polarity` : This is a readable/writable file to use only if the chip of this
    PWM device supports polarity inversion. It is better to change the polarity only
    when this PWM is not enabled. Accepted values are string *normal* or *inversed*
    .'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Enable` : This is a readable/writable file, to enable (start toggling)/disable
    (stop toggling) the PWM signal. Accepted values are:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0: disabled'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1: enabled'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of using PWM from user space through the `sysfs`
    interface:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable PWM:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Set PWM period:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Set PWM duty cycle: The value of the duty cycle must be less than the value
    of PWM period:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Disable PWM:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The complete PWM framework API and sysfs description is available in the *Documentation/pwm.txt*
    file, in the kernel source tree.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By the end of this chapter, you are armed for any PWM controller, whether it
    is memory mapped, or externally sitting on a bus. The API described in this chapter
    will be sufficient to write as well as to enhance a controller driver as a consumer
    device driver. If you are not comfortable with the PWM kernel side yet, you can
    fully use the user space sysfs interface. That said, in the next chapter, we will
    discuss about regulators, which sometimes are driven by PWM. So, please hold on,
    we are almost done.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将具备处理任何PWM控制器的能力，无论它是内存映射的还是外部连接在总线上的。本章描述的API将足以编写和增强控制器驱动程序作为消费者设备驱动程序。如果您对PWM内核端还不熟悉，可以完全使用用户空间sysfs接口。话虽如此，在下一章中，我们将讨论有时由PWM驱动的调节器。所以，请稍等，我们快要完成了。
