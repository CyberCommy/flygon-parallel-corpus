- en: 4\. Divide and Conquer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 分治
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章结束时，您将能够:'
- en: Describe the divide-and-conquer design paradigm
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述分治设计范式
- en: Implement standard divide-and-conquer algorithms such as merge sort, quicksort,
    and linear time selection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现标准的分治算法，如归并排序、快速排序和线性时间选择
- en: Solve problems using the MapReduce programming model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MapReduce编程模型解决问题
- en: Learn how to use a multithreaded C++ MapReduce implementation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用多线程的C++ MapReduce实现
- en: In this chapter, we shall study the divide-and-conquer algorithm design paradigm
    and learn how to use it to solve computational problems.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习分治算法设计范式，并学习如何使用它来解决计算问题。
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we studied some commonly used data structures. Data
    structures are organizations of data in different forms, and a data structure
    enables and controls the cost of access to the data stored inside it. However,
    what makes software useful is not just the ability to store and retrieve data
    in various formats, but the ability to make transformations on data in order to
    solve computational problems. For a given problem, the precise definition and
    order of transformations on data is determined by a sequence of instructions called
    an **algorithm**.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了一些常用的数据结构。数据结构是以不同形式组织数据的方式，数据结构使得控制和访问存储在其中的数据的成本成为可能。然而，使软件有用的不仅仅是存储和检索各种格式的数据的能力，而是能够对数据进行转换以解决计算问题的能力。对于给定的问题，对数据的精确定义和转换顺序由一系列称为**算法**的指令确定。
- en: 'An algorithm takes in a set of inputs that define an instance of a problem,
    applies a series of transformations, and outputs a set of results. If these results
    are the correct solutions to the computational problem at hand, our algorithm
    is said to be *correct*. The *goodness* of an algorithm is determined by its efficiency,
    or how few instructions the algorithm needs to perform to produce correct results:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 算法接受一组定义问题实例的输入，应用一系列变换，并输出一组结果。如果这些结果是手头计算问题的正确解决方案，我们称算法是*正确*的。算法的*好坏*由其效率决定，或者说算法需要执行多少指令才能产生正确的结果：
- en: '![Figure 4.1: Scaling of steps taken by an algorithm with respect to the size
    of the input](img/C14498_04_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1：算法所需步骤随输入大小的扩展](img/C14498_04_01.jpg)'
- en: 'Figure 4.1: Scaling of steps taken by an algorithm with respect to the size
    of the input'
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.1：算法所需步骤随输入大小的扩展
- en: The preceding diagram shows the growth in the number of steps required by an
    algorithm as a function of the size of the input. Algorithms that are more complex
    grow more quickly with the size of the input, and with sufficiently large inputs
    they can become infeasible to run, even on modern computer systems. For instance,
    let's assume that we have a computer that can perform a million operations per
    second. For an input of size 50, an algorithm that takes *N log(N)* steps will
    take 283 microseconds to complete; an algorithm that takes *N**2* steps will take
    2.5 milliseconds; and an algorithm that takes *N!* (factorial of *N*) steps would
    take approximately 9,637,644,561,599,544,267,027,654,516,581,964,749,586,575,812,734.82
    **centuries** to run!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 上图显示了算法所需步骤随输入大小的增长情况。复杂度更高的算法随着输入大小的增加而增长更快，对于足够大的输入，它们甚至在现代计算机系统上也可能无法运行。例如，假设我们有一台每秒可以执行一百万次操作的计算机。对于大小为50的输入，需要*N
    log(N)*步的算法将花费283微秒完成；需要*N**2*步的算法将花费2.5毫秒；需要*N!*（*N*的阶乘）步的算法将需要大约9,637,644,561,599,544,267,027,654,516,581,964,749,586,575,812,734.82
    **世纪**来运行！
- en: '*An algorithm is said to be efficient if, for the size of input N, it solves
    the problem in a number of steps that is a polynomial of N.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果对于输入大小N，算法以N的多项式步骤解决问题，则称算法是高效的。*'
- en: 'The problems that express **polynomial-time algorithms** as solutions are also
    said to belong to the class *P* (polynomial) of computational complexity. There
    are several other computational complexities that problems can be divided into,
    a few examples of which are given here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将**多项式时间算法**表达为解决方案的问题也被称为属于计算复杂性的类*P*（多项式）。问题可以分为几种其他计算复杂性，以下是一些示例：
- en: '**NP** (**Non-Deterministic Polynomial Time**) problems have solutions that
    can be verified in polynomial time, but do not have any known polynomial-time
    solutions.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NP**（非确定性多项式时间）问题的解决方案可以在多项式时间内验证，但没有已知的多项式时间解决方案。'
- en: '**EXPTIME** (**Exponential Time**) problems have solutions that run in time
    exponential to the size of the input.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EXPTIME**（指数时间）问题的解决方案运行时间与输入大小呈指数关系。'
- en: '**PSPACE** (**Polynomial Space**) problems require a polynomial amount of space.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PSPACE**（多项式空间）问题需要多项式数量的空间。'
- en: Finding out whether the set of problems in *P* is exactly the same as the set
    of problems in *NP* is the famous *P = NP* problem, which remains unsolved after
    decades of efforts and even carries a $1 million prize for anyone who can solve
    it. We shall take another look at *P* and *NP*-type problems in *Chapter 9*, *Dynamic
    Programming II*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 找出*P*中的问题集是否与*NP*中的问题集完全相同是著名的*P = NP*问题，经过数十年的努力仍未解决，甚至为任何能解决它的人提供了100万美元的奖金。我们将在*第9章*
    *动态规划II*中再次研究*P*和*NP*类型的问题。
- en: Algorithms have been studied as mathematical objects by computer scientists
    for several decades and a set of general approaches (or **paradigms**) to design
    efficient algorithms have been identified that can be used to solve a wide variety
    of problems. One of the most widely applicable algorithm design paradigms is called
    *divide and conquer* and shall be our subject of study in this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家们几十年来一直将算法作为数学对象进行研究，并确定了一组通用的方法（或**范式**）来设计高效的算法，这些方法可以用来解决各种各样的问题。其中最广泛适用的算法设计范式之一被称为*分治*，将是我们在本章的研究对象。
- en: A **divide-and-conquer** type algorithm breaks the given problem into smaller
    parts, tries to solve the problem for each part, and, finally, combines the solution
    for each part into the solution for the whole problem. Several widely used algorithms
    fall into this category, for example, binary search, quicksort, merge sort, matrix
    multiplication, Fast Fourier Transform, and the skyline algorithms. These algorithms
    appear in almost all the major applications that are used today, including databases,
    web browsers, and even language runtimes such as the Java Virtual Machine and
    the V8 JavaScript engine.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will show you what it means to solve problems using divide
    and conquer, and how you can identify whether your problem is amenable to such
    a solution. Next, we will practice thinking recursively and show you the tools
    that the modern C++ Standard Library gives you so that you can solve your problems
    using divide and conquer. We'll end this chapter by looking at MapReduce, including
    a discussion on why and how it scales, and how you can use the same paradigm to
    scale up your programs using both CPU-level and machine-level parallelization.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive into a basic algorithm that uses the divide-and-conquer approach
    – binary search.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Binary Search
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the standard search problem: say we are given a sorted sequence
    of positive integers and are required to find out if a number, *N*, exists in
    the sequence. There are several places where the search problem shows up naturally;
    for example, a receptionist looking for a customer''s file in a set of files that
    are kept ordered by customer IDs or a teacher looking for the marks obtained by
    a student in their register of students. They are both, in effect, solving the
    search problem.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can approach the problem in two different ways. In the first approach,
    we iterate over the entire sequence, checking whether each element is equal to
    *N*. This is called a **linear search** and is shown in the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: One benefit of this approach is that it works for all arrays, sorted or unsorted.
    However, it is inefficient and does not take into account that the given array
    is sorted. In terms of its algorithmic complexity, it is an *O(N)* algorithm.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative solution that exploits the fact that the sequence is sorted
    is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Start with the whole sequence in `range`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compare the middle element of the current `range` with *N*. Let this middle
    element be *M*.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If *M = N*, we have found *N* in the sequence and, therefore, the search stops.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Otherwise, we modify the `range` according to two rules:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: –  If *N < M*, it means that if *N* were to be present in the `range`, it would
    be to the left of *M* and, therefore, we can safely remove all the elements to
    the right of *M* from the `range`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: –  If *N > M*, the algorithm removes all the elements to the left of *M* from
    the `range`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: If more than 1 element remains in the `range`, go to *step 2*.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, *N* does not exist in the sequence and the search stops.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To illustrate this algorithm, we''ll show how binary search works where *S*
    is a sorted sequence of integers from *1* to 9 and *N = 2*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm starts with putting all the elements of *S* in range. The middle
    element in this step is found to be *5*. We compare *N* and *5*:![Figure 4.2:
    Binary search algorithm – step 1](img/C14498_04_02.jpg)'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.2: Binary search algorithm – step 1'
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Since *N < 5*, if *N* was present in the sequence, it would have to be to the
    left of *5*. Therefore, we can safely discard all the elements of the sequence
    lying toward the right of *5* from our search. Our range now has elements only
    between *1* and *5*, and the middle element is now *3*. We can now compare *N*
    and *3*:![Figure 4.3: Binary search algorithm – step 2](img/C14498_04_03.jpg)'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.3: Binary search algorithm – step 2'
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We find that the current middle element, *3*, is still greater than *N*, and
    the range can further be pruned to contain elements only between *1* and *3*.
    The new middle element is now *2*, which is equal to *N*, and the search terminates:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们发现当前的中间元素*3*仍然大于*N*，并且范围可以进一步修剪为仅包含*1*和*3*之间的元素。新的中间元素现在是*2*，它等于*N*，搜索终止：
- en: '![Figure 4.4: Binary search algorithm – step 3](img/C14498_04_04.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4：二分搜索算法-步骤3](img/C14498_04_04.jpg)'
- en: 'Figure 4.4: Binary search algorithm – step 3'
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.4：二分搜索算法-步骤3
- en: In the following exercise, we shall look at the implementation of the binary
    search algorithm.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将看一下二分搜索算法的实现。
- en: 'Exercise 18: Binary Search Benchmarks'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习18：二分搜索基准
- en: 'In this exercise, we will write and benchmark a binary search implementation.
    Follow these steps to complete this exercise:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写并基准测试二分搜索实现。按照以下步骤完成这个练习：
- en: 'Begin by adding the following headers:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先添加以下头文件：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the linear search code like so:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加线性搜索代码如下：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the binary search code shown here:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加此处显示的二分搜索代码：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To evaluate the performance of binary search, we will implement two functions.
    First, write the small test:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了评估二分搜索的性能，我们将实现两个函数。首先，编写小测试：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, add the large test function, as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加大型测试函数，如下所示：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Lastly, add the following driver code, which searches for the number `36543`
    in randomly generated vectors of different sizes:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加以下驱动程序代码，用于在不同大小的随机生成向量中搜索数字`36543`：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Compile the program in x64-Debug mode and run it. The output should look like
    the following:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以x64-Debug模式编译程序并运行。输出应如下所示：
- en: '![Figure 4.5: Binary search with debugging enabled](img/C14498_04_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5：启用调试的二分搜索](img/C14498_04_05.jpg)'
- en: 'Figure 4.5: Binary search with debugging enabled'
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.5：启用调试的二分搜索
- en: Notice that each of the three input arrays are all 10 times bigger than the
    previous arrays, so the third array is a hundred times larger than the first array,
    which itself contains a hundred thousand elements. Still, the time taken to search
    in the arrays using binary search increases only by 10 microseconds.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，三个输入数组的大小都比前一个数组大10倍，因此第三个数组比第一个数组大100倍，它本身包含十万个元素。然而，使用二分搜索在数组中搜索所花费的时间仅增加了10微秒。
- en: 'In the previous test, we did not allow any compiler optimizations and ran with
    the debugger attached to the program. Now, let''s see what happens when our compiler
    is allowed to optimize the C++ code with no debugger attached. Try compiling the
    code in *Exercise 18*, *Binary Search Benchmarks*, in x64-Release mode and run
    it. The output should look as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个测试中，我们没有允许任何编译器优化，并且在运行时附加了调试器。现在，让我们看看当我们的编译器允许优化C++代码而没有附加调试器时会发生什么。尝试以x64-Release模式编译*练习18*中的*二分搜索基准*代码，并运行。输出应如下所示：
- en: '![Figure 4.6: Binary search with compiler optimizations turned on](img/C14498_04_06.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6：打开编译器优化的二分搜索](img/C14498_04_06.jpg)'
- en: 'Figure 4.6: Binary search with compiler optimizations turned on'
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.6：打开编译器优化的二分搜索
- en: The binary search takes approximately equal time in all three cases, even with
    vastly different vector sizes!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 无论向量大小如何，二分搜索在这三种情况下大致需要相同的时间！
- en: Note that our implementation of binary search uses iterators and the C++ Standard
    Library functions such as `std::distance()` and `std::advance()`. This is considered
    good practice in modern C++ since it helps keep our code agnostic of the underlying
    data type and safe from index out-of-bounds errors.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的二分搜索实现使用迭代器和C++标准库函数，如`std::distance()`和`std::advance()`。这在现代C++中被认为是良好的实践，因为它有助于使我们的代码不依赖于基础数据类型，并且可以避免索引越界错误。
- en: 'Now, say we wanted to perform a search on a vector of floating-point numbers.
    How would we modify our functions in the previous exercise? The answer is exceedingly
    simple. We can modify the function signatures as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想在一个浮点数向量上执行搜索。我们如何修改上一个练习中的函数？答案非常简单。我们可以修改函数签名如下：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The rest of the code inside of the search functions can still remain exactly
    the same since it is completely independent of the underlying datatype and depends
    only on the behavior of a container datatype. **This separation of core algorithm
    logic from the underlying datatype on which the algorithm operates is a cornerstone
    of writing reusable code in modern C++.** We shall see several examples of such
    separation in the duration of this book and dive into more functions that the
    Standard Library provides that can help us write reusable and robust code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索函数内部的其余代码仍然可以保持完全相同，因为它完全独立于基础数据类型，仅取决于容器数据类型的行为。**在现代C++中，将核心算法逻辑与算法操作的基础数据类型分离开来，是编写可重用代码的基石。**我们将在本书的过程中看到几个这样的分离示例，并深入研究标准库提供的更多函数，这些函数可以帮助我们编写可重用和健壮的代码。
- en: 'Activity 8: Vaccinations'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动8：疫苗接种
- en: 'Imagine that it is flu season and health department officials are planning
    to visit a school to ensure that all the enrolled children are administered their
    flu shot. However, there is a problem: a few children have already taken their
    flu shots but do not remember if they have been vaccinated against the specific
    category of flu that the health officials plan to vaccinate all the students against.
    Official records are sought out and the department is able to find a list of students
    that have already been administered the vaccine. A small excerpt of the list is
    shown here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，现在是流感季节，卫生部门官员计划访问一所学校，以确保所有入学的孩子都接种了流感疫苗。然而，出现了一个问题：一些孩子已经接种了流感疫苗，但不记得他们是否已经接种了卫生官员计划为所有学生接种的特定类别的流感疫苗。官方记录被寻找出来，部门能够找到已经接种疫苗的学生名单。这里显示了名单的一个小节：
- en: '![Figure 4.7: Excerpt of vaccination records](img/C14498_04_07.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7：疫苗接种记录摘录](img/C14498_04_07.jpg)'
- en: 'Figure 4.7: Excerpt of vaccination records'
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.7：疫苗接种记录摘录
- en: 'Assume that all the names are positive integers and that the given list is
    sorted. Your task is to write a program that can look up the vaccination status
    of a given student in the list and outputs to the officials whether the student
    needs to be vaccinated. Students need to be vaccinated in case of two conditions:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 假设所有名称都是正整数，并且给定列表已排序。您的任务是编写一个程序，可以查找列表中给定学生的接种状况，并向官员输出学生是否需要接种疫苗。学生需要接种疫苗，如果满足以下两个条件：
- en: If they are not present in the list
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它们不在列表中
- en: If they are present in the list but have not been administered a flu shot
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果他们在名单上但尚未接种流感疫苗。
- en: 'Since the list can have a large number of students, your program should be
    as fast and efficient as possible. The final output of your program should look
    as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表中可能有大量学生，您的程序应尽可能快速和高效。程序的最终输出应如下所示：
- en: '![Figure 4.8: Sample output of Activity 8](img/C14498_04_08.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8：活动8的示例输出](img/C14498_04_08.jpg)'
- en: 'Figure 4.8: Sample output of Activity 8'
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.8：活动8的示例输出
- en: '**High-level Steps**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级步骤**'
- en: 'The solution to this activity uses a slightly modified version of the binary
    search algorithm. Let''s get started:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案使用了稍微修改过的二分搜索算法。让我们开始吧：
- en: 'Represent each student as an object of the `Student` class, which can be defined
    as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个学生表示为`Student`类的对象，可以定义如下：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Overload the required operators for the `Student` class so that a vector of
    students can be sorted using the Standard Library's `std::sort()` function.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重载`Student`类的必要运算符，以便可以使用标准库的`std::sort()`函数对学生向量进行排序。
- en: Use a binary search to see if the student is present on the list.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用二分搜索查看学生是否在名单上。
- en: If the student isn't present in the list, your function should return *true*
    since the student needs to be administered the vaccine.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果学生不在列表中，则您的函数应返回*true*，因为学生需要接种疫苗。
- en: Otherwise, if the student is present in the list but has not been administered
    the vaccine, return *true*.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，如果学生在名单上但尚未接种疫苗，则返回*true*。
- en: Else, return *false*.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，返回*false*。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 506.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第506页找到。
- en: Understanding the Divide-and-Conquer Approach
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解分而治之方法
- en: 'At the core of the divide-and-conquer approach is a simple and intuitive idea:
    if you don''t know how to solve a large instance of a problem, find a small part
    of the problem that you can solve, and then solve it. Then, iterate for more such
    parts, and once you have solved all the parts, combine the results into a large
    coherent solution to the original problem. There are three steps to solving a
    problem using the divide-and-conquer approach:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在分而治之方法的核心是一个简单直观的想法：如果您不知道如何解决问题的大实例，请找到一个小部分的问题，您可以解决，然后解决它。然后，迭代更多这样的部分，一旦解决了所有部分，将结果合并成原始问题的大一致解决方案。使用分而治之方法解决问题有三个步骤：
- en: '**Divide**: Take the original problem and divide it into parts so that the
    same problem needs to be solved for each part.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**划分**：将原始问题划分为部分，以便为每个部分解决相同的问题。'
- en: '**Conquer**: Solve the problem for each part.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 征服：解决每个部分的问题。
- en: '**Combine**: Take the solutions for the different parts and combine them into
    a solution for the original problem.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**合并**：将不同部分的解决方案合并成原始问题的解决方案。'
- en: 'In the previous section, we looked at an example of using divide and conquer
    to search within a sequence. At each step, binary search tries to search in only
    a part of the sequence, which is marked as the `range`. The search terminates
    when either the element is found or there is no longer a way to further divide
    the `range` into smaller parts. However, the search problem differs from most
    divide-and-conquer algorithms in the following manner: in the search problem,
    if an element can be found in a smaller `range` of the sequence, then it also
    definitely exists in the complete sequence. In other words, the solution to the
    problem in a smaller part of the sequence gives us the solution to the whole problem.
    Therefore, the solution does not need to implement the combination step of the
    general divide-and-conquer approach. This property, unfortunately, is not exhibited
    by the vast majority of computational problems that can be solved using a divide-and-conquer
    approach. In the following section, we shall dive deeper and look at more examples
    of using the divide-and-conquer approach to solve problems.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看了一个使用分而治之来在序列中搜索的示例。在每一步中，二分搜索尝试仅在标记为`range`的序列的一部分中搜索。当找到元素或不再能将`range`进一步分割为更小的部分时，搜索终止。然而，搜索问题与大多数分而治之算法有所不同：在搜索问题中，如果元素可以在序列的较小`range`中找到，则它也一定存在于完整序列中。换句话说，在序列的较小部分中的问题的解决方案给出了整个问题的解决方案。因此，解决方案不需要实现一般分而治之方法的组合步骤。遗憾的是，这种特性并不适用于绝大多数可以使用分而治之方法解决的计算问题。在接下来的部分中，我们将深入探讨并查看更多使用分而治之方法解决问题的示例。
- en: Sorting Using Divide and Conquer
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用分而治之进行排序
- en: We shall now explore how to implement the divide-and-conquer approach when it
    comes to solving another standard problem – sorting. The importance of having
    an efficient sorting algorithm cannot be overstated. In the early days of computing
    in the 1960s, computer manufacturers estimated that 25% of all CPU cycles in their
    machines were spent sorting elements of arrays. Although the computing landscape
    has changed significantly over the years, sorting is still widely studied today
    and remains a fundamental operation in several applications. For instance, it
    is the key idea behind indexes in databases, which then allow quick access to
    the stored data using a logarithmic time search, which is similar to binary search.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'The general requirements for an implementation of a sorting algorithm are as
    follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The implementation should be able to work with any datatype. It should be able
    to sort integers, floating-point decimals, and even C++ structures or classes
    where an order among different elements can be defined.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sorting algorithm should be able to handle large amounts of data, that is,
    the same algorithm should work with sizes of data even greater than the main memory
    of a computer.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sorting algorithm should be fast, both asymptotically and in practice.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While all three listed goals are desirable, in practice, it is hard to achieve
    the second and third objectives simultaneously. The second objective requires
    external sorting, that is, sorting data that does not reside on the main memory
    of a computer. External sorting algorithms can work while holding only a small
    subset of the whole data in memory at any point during execution.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will introduce two sorting algorithms: merge sort and quicksort.
    Merge sort is an external sorting algorithm and, therefore, achieves our second
    objective, while quicksort, as its name suggests, is one of the fastest known
    sorting algorithms in practice and appears as a part of the C++ Standard Library''s
    `std::sort()` function.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Merge Sort
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Merge sort** is one of the oldest known sorting algorithms and appeared in
    reports in the late 1940s. The computers of that time had a few hundred bytes
    of main memory and were often used for complex mathematical analyses. Therefore,
    it was crucial for sorting algorithms to be able to work, even when all the data
    to be operated upon could not be held in the main memory. Merge sort solved this
    problem by exploiting a simple idea – sorting a large set of elements is the same
    as sorting a small subset of elements, and then merging the sorted subsets so
    that the increasing or decreasing order of elements is maintained:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9: Merge sort](img/C14498_04_09.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Merge sort'
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The preceding diagram shows an example of sorting an array of integers using
    merge sort. First, the algorithm divides the original array into subarrays until
    each subarray only consists of one element (*steps 1* to *4*). In all the subsequent
    steps, the algorithm merges elements into larger arrays, keeping elements in each
    subarray in increasing order.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 19: Merge Sort'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we shall implement the merge sort algorithm. The steps are
    as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the following headers:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The C++ code for the merge operation on two vectors is as follows. Write the
    `merge()` function like so:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The templatized `merge()` function takes in references to two vectors of type
    `T` and returns a new vector containing the elements in input arrays, but sorted
    in increasing order.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use the merge operation to write a recursive merge sort implementation,
    as shown here:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the following function to print the vector:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following function allows us to test our implementation of the merge sort
    algorithm:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Compile and run the program. The output should look like the following:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.10: Sorting by merge sort](img/C14498_04_10.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: Sorting by merge sort'
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Our implementation of merge sort in this exercise continues our theme of not
    tying implementations of algorithms to underlying datatypes and relying only on
    the functions exposed by the containers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Quicksort
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the goal in the case of merge sort was to sort large amounts of data,
    quicksort tries to reduce the average-case running time. The underlying idea in
    quicksort is also the same as merge sort – divide the original input array into
    smaller subarrays, sort the subarrays, and merge the results to get the sorted
    array. However, the fundamental operation that quicksort uses is **partition**
    and not merge.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '**Working of the Partition Operation**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an array and a **pivot element**, *P*, in the array, the **partition
    operation** does two things:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: It divides the original array into two subarrays, *L* and *R*, where *L* contains
    all the elements of the given array that are less than or equal to *P*, and *R*
    contains all elements of the given array that are greater than *P*.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It reorganizes the elements in the array in the order *L*, *P*, *R*.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram shows the result of a partition that was applied to an
    unsorted array, with the first element chosen as the pivot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11: Selecting a pivot and partitioning the vector around it](img/C14498_04_11.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: Selecting a pivot and partitioning the vector around it'
  id: totrans-138
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A useful property of the partition operation is that after it is applied, the
    new position of the pivot, *P*, in the vector becomes the position that *P* would
    have if the vector were sorted. For example, the element *5* appears at the 5th
    position in the array after we apply the partition operation, which is the same
    position that element *5* would have been in if the array was sorted in increasing
    order.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding property is also the core idea behind the quicksort algorithm,
    which works as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: If the input array, *A*, has more than 1 element in it, apply the partition
    operation on *A*. It results in subarrays *L* and *R*.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use *L* as an input to *step 1*.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use *R* as an input to *step 1*.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Steps 2* and *3* are recursive calls to the partition operation on the arrays
    that are generated by the partition operation and applied to the original input
    array. This simple recursive application of the partition operation results in
    sorting elements in increasing order. Since the quicksort recursion trees can
    quickly become deep, the following diagram shows an example of applying quicksort
    on a small array of six elements, *{5, 6, 7, 3, 1, 9}*:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12: Visualization of the quicksort algorithm](img/C14498_04_12.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: Visualization of the quicksort algorithm'
  id: totrans-146
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Each iteration of the algorithm shows the result of the partition operation
    being applied to the subarrays generated in the previous step using the highlighted
    pivots. It should be noted that our choice of the first element of the array as
    the pivot is arbitrary. Any element of the array can be chosen as the pivot without
    affecting the correctness of the quicksort algorithm.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 20: Quicksort'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we shall implement and test our implementation of quicksort.
    Let''s get started:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the following headers:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The C++ code for the partition operation is as follows. Write the `partition()`
    function as shown here:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The implementation shown here takes in only the iterators over an underlying
    container object and returns another iterator that points to the index of the
    partition in the array. This means that all the elements of the vector are greater
    than the pivot in the right partition, and all the elements less than or equal
    to the pivot are in the left partition.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'The quicksort algorithm uses the partition operation recursively, as shown
    in the following code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`print_vector()` is used to print a vector to the console and is implemented
    as follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Adapt the driver code from *Exercise 19*, *Merge Sort*, as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Write a `main()` function that calls `run_quick_sort_test()`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Your final output should look as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的最终输出应如下所示：
- en: '![Figure 4.13: Sorting by quicksort](img/C14498_04_13.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图4.13：快速排序排序](img/C14498_04_13.jpg)'
- en: 'Figure 4.13: Sorting by quicksort'
  id: totrans-165
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.13：快速排序排序
- en: However, the runtime of quicksort does depend on how "good" our choice of pivot
    is. The best case for quicksort is when the pivot at any step is the median element
    of the current array; in such a case, quicksort is able to partition the elements
    into vectors of equal sizes at each step, and, therefore, the depth of the recursion
    tree is exactly *log(n)*. If the medians are not chosen as pivots, it results
    in an imbalance in the partition sizes and, therefore, a deeper recursion tree
    and greater running time.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，快速排序的运行时间取决于我们选择的枢轴有多“好”。快速排序的最佳情况是在任何步骤中，枢轴都是当前数组的中位数元素；在这种情况下，快速排序能够将元素分成每一步相等大小的向量，因此，递归树的深度恰好是*log(n)*。如果不选择中位数作为枢轴，会导致分区大小不平衡，因此递归树更深，运行时间更长。
- en: 'The asymptotic complexity of quicksort and merge sort is shown here:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序和归并排序的渐近复杂度如下所示：
- en: '![Figure 4.14: Asymptotic complexity of quicksort and merge sort](img/C14498_04_14.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图4.14：快速排序和归并排序的渐近复杂度](img/C14498_04_14.jpg)'
- en: 'Figure 4.14: Asymptotic complexity of quicksort and merge sort'
  id: totrans-169
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.14：快速排序和归并排序的渐近复杂度
- en: 'Activity 9: Partial Sorting'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动9：部分排序
- en: In the last two exercises, we have implemented **total sorting** algorithms
    that order all the elements of a vector in an increasing (or decreasing) order.
    However, this can be overkill in several problem instances. For example, imagine
    that you are given a vector containing the ages of all humans on earth and are
    asked to find the median age of the oldest 10% of the population.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两个练习中，我们实现了**总排序**算法，它按照递增（或递减）顺序对向量的所有元素进行排序。然而，在一些问题实例中，这可能是过度的。例如，想象一下，您得到一个包含地球上所有人的年龄的向量，并被要求找到人口最老的10%的人的中位数年龄。
- en: A naïve solution to this problem is to sort the vector of ages, extract the
    ages of the oldest 10% people from the vector, and then find the median of the
    extracted vector. However, this solution is wasteful as it does far more than
    is strictly needed in order to compute the solution, that is, it sorts the entire
    array to ultimately use only 10% of the sorted array for the required solution.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个问题的一个天真的解决方案是对年龄向量进行排序，从向量中提取最老的10%人的年龄，然后找到提取向量的中位数。然而，这种解决方案是浪费的，因为它做的远远超出了计算解决方案所需的，也就是说，它对整个数组进行排序，最终只使用排序数组的10%来计算所需的解决方案。
- en: A better solution to such problems can be derived by specializing the total
    sorting algorithms such as merge sort and quicksort into **partial sorting algorithms**.
    A partial sorting algorithm sorts only a specified number of elements in a given
    vector and leaves the rest of the vector unsorted.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对这类问题的更好解决方案可以通过将归并排序和快速排序等总排序算法专门化为**部分排序算法**来得到。部分排序算法只对给定向量中的指定数量的元素进行排序，而将向量的其余部分保持未排序状态。
- en: 'The partial quicksort is described as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 部分快速排序的描述如下：
- en: Assume that we are given a vector, *V*, and we are required to create a sorted
    subvector of *k* elements.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个向量*V*，我们需要创建一个有序的*k*元素的子向量。
- en: Apply the partition operation on *V*, assuming the first element of *V* as the
    pivot (again, this choice is completely arbitrary). The result of the partition
    operation are two vectors, *L* and *R*, where *L* contains all the elements of
    *V* that are less than the pivot and *R* contains all the elements greater than
    the pivot. Also, the new position of the pivot is the "correct" position of the
    pivot in the sorted array.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*V*上应用分区操作，假设*V*的第一个元素作为枢轴（同样，这个选择完全是任意的）。分区操作的结果是两个向量，*L*和*R*，其中*L*包含所有小于枢轴的*V*的元素，*R*包含所有大于枢轴的元素。此外，枢轴的新位置是排序数组中枢轴的“正确”位置。
- en: Use *L* as input to *step 1*.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*L*作为*步骤1*的输入。
- en: If the new position of pivot in *step 2* is less than *k*, use *R* as input
    to *step 1*.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*步骤2*中枢轴的新位置小于*k*，则使用*R*作为*步骤1*的输入。
- en: 'Your task in this activity is to implement the partial quicksort algorithm
    that uses randomly generated arrays to test the output of the algorithm. The final
    output with a vector of size *100* and *k = 100* should look as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您在本活动中的任务是实现部分快速排序算法，该算法使用随机生成的数组来测试算法的输出。大小为*100*且*k = 100*的向量的最终输出应如下所示：
- en: '![Figure 4.15: Sample output of Activity 9](img/C14498_04_15.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图4.15：活动9的示例输出](img/C14498_04_15.jpg)'
- en: 'Figure 4.15: Sample output of Activity 9'
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.15：活动9的示例输出
- en: Note
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 510.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可在第510页找到。
- en: Linear Time Selection
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线性时间选择
- en: In the previous section, we looked at simple examples of algorithms that use
    the divide-and-conquer paradigm and were introduced to the partition and merge
    operations. So far, our view of divide-and-conquer algorithms has been restricted
    to ones that recursively divide each intermediate step into exactly two subparts.
    However, there are certain problems where dividing each step into more subparts
    can yield substantial benefits. In the following section, we shall study one such
    problem – linear time selection.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看了使用分治范式的简单算法示例，并介绍了分区和合并操作。到目前为止，我们对分治算法的看法局限于那些将每个中间步骤递归地分成两个子部分的算法。然而，有些问题在将每一步分成更多子部分时可以产生实质性的好处。在接下来的部分，我们将研究这样一个问题——线性时间选择。
- en: 'Imagine that you are in charge of organizing a marching band parade for your
    school. To ensure that all the band members look uniform, it is important that
    the heights of students be the same. Moreover, students from all grades are required
    to participate. To solve these problems, you come up with the following solution
    – you will select only the 15th shortest student in every grade to participate
    in the parade. The problem can be formalized as follows: given a randomly ordered
    set of elements, *S*, you are asked to find the *i**th* smallest element in *S*.
    A simple solution could be sorting the input and then selecting the *i**th* element.
    However, the algorithmic complexity of this solution is *O(n log n)*. In this
    section, we will work through a divide-and-conquer solution that solves the problem
    in *O(n)*.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你负责为你的学校组织一场游行队伍。为了确保所有乐队成员看起来一致，学生的身高是相同的很重要。此外，要求所有年级的学生都参加。为了解决这些问题，你提出了以下解决方案——你将选择每个年级第15矮的学生参加游行。问题可以形式化如下：给定一个随机排序的元素集*S*，要求你找到*S*中第*i*小的元素。一个简单的解决方案可能是对输入进行排序，然后选择第*i*个元素。然而，这种解决方案的算法复杂度是*O(n
    log n)*。在本节中，我们将通过分治法解决这个问题，其复杂度为*O(n)*。
- en: 'Our solution hinges on using the partition operation correctly. The partition
    operation we introduced in the previous subsection takes in a vector and a pivot,
    and then divides the vector into two parts, one containing all the elements less
    than the pivot and the other containing all the elements greater than the pivot.
    The final algorithm works as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解决方案依赖于正确使用分区操作。我们在上一小节介绍的分区操作接受一个向量和一个枢轴，然后将向量分成两部分，一部分包含所有小于枢轴的元素，另一部分包含所有大于枢轴的元素。最终算法的工作如下：
- en: Assume that we are given an input vector, *V*, and we need to find the *ith*
    smallest element.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个输入向量*V*，我们需要找到第*i*小的元素。
- en: Divide the input vector, *V*, into vectors *V**1*, *V**2*, *V**3*, *…* , *V**n/5*,
    each containing five elements (the last vector can have less than five elements,
    if necessary).
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输入向量*V*分成向量*V**1*、*V**2*、*V**3*、*…*、*V**n/5*，每个向量包含五个元素（如果需要，最后一个向量可以少于五个元素）。
- en: Next, we sort each *V**i*.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们对每个*V**i*进行排序。
- en: 'For each *V**i*, find the median, *m**i*, and collect all medians into a set,
    *M*, as shown here:![Figure 4.16: Finding the medians of each subvector](img/C14498_04_16.jpg)'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个*V**i*，找到中位数*m**i*，并将所有中位数收集到一个集合*M*中，如下所示：![图4.16：找到每个子向量的中位数](img/C14498_04_16.jpg)
- en: 'Figure 4.16: Finding the medians of each subvector'
  id: totrans-192
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.16：找到每个子向量的中位数
- en: 'Find the median element, *q*, of *M*:![Figure 4.17: Finding the median of a
    set of medians](img/C14498_04_17.jpg)'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到*M*的中位数元素*q*：![图4.17：找到一组中位数的中位数](img/C14498_04_17.jpg)
- en: 'Figure 4.17: Finding the median of a set of medians'
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.17：找到一组中位数的中位数
- en: 'Use the partition operation on *V* using *q* as the pivot to get two vectors,
    *L* and *R*:![Figure 4.18: Partitioning the whole vector](img/C14498_04_18.jpg)'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用分区操作在*V*上使用*q*作为枢轴得到两个向量*L*和*R*：![图4.18：对整个向量进行分区](img/C14498_04_18.jpg)
- en: 'Figure 4.18: Partitioning the whole vector'
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.18：对整个向量进行分区
- en: 'By the definition of the partition operation, *L* contains all the elements
    less than *q* and *R* contains all the elements greater than *q*. Let''s say *L*
    has *(k – 1)* elements:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据分区操作的定义，*L*包含所有小于*q*的元素，*R*包含所有大于*q*的元素。假设*L*有*(k-1)*个元素：
- en: –  If *i = k*, then *q* is the *i**th* element in *V*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '- 如果*i = k*，那么*q*就是*V*中的第*i*个元素。'
- en: –  If *i < k*, set *V = L* and go to *step 1*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '- 如果*i < k*，则设置*V = L*并转到*步骤1*。'
- en: –  If *i > k*, set *V = R* and *i = i – k*, and go to *step 1*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '- 如果*i > k*，则设置*V = R*并*i = i - k*，并转到*步骤1*。'
- en: The following exercise demonstrates the implementation of this algorithm in
    C++.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习演示了在C++中实现此算法。
- en: 'Exercise 21: Linear Time Selection'
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习21：线性时间选择
- en: 'In this exercise, we shall implement the linear time selection algorithm. Let''s
    get started:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现线性时间选择算法。让我们开始吧：
- en: 'Import the following headers:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下头文件：
- en: '[PRE20]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Write the helper function shown here:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写如下所示的辅助函数：
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In *Exercise 20*, *Quicksort*, our partition function assumed that the first
    element in a given vector was always the pivot to be used. We now need a more
    general form of the partition operation that can work with any pivot element:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*练习20*中，*快速排序*，我们的分区函数假设给定向量中的第一个元素始终是要使用的枢轴。现在我们需要一个更一般的分区操作形式，可以与任何枢轴元素一起使用：
- en: '[PRE22]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Use the following code to implement our linear time search algorithm:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码来实现我们的线性时间搜索算法：
- en: '[PRE23]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add the merge sort implementation shown in the following code. We shall use
    the sorting algorithm to demonstrate the correctness of our implementation:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加合并排序实现，如下所示的代码。我们将使用排序算法来证明我们实现的正确性：
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Lastly, add the following driver and test functions:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加以下驱动程序和测试函数：
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Compile and run the code. Your final output should look like this:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行代码。你的最终输出应该如下所示：
- en: '![Figure 4.19: Finding the 3rd, 5th, and 11th elements using linear time selection](img/C14498_04_19.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图4.19：使用线性时间选择找到第3、第5和第11个元素](img/C14498_04_19.jpg)'
- en: 'Figure 4.19: Finding the 3rd, 5th, and 11th elements using linear time selection'
  id: totrans-218
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.19：使用线性时间选择找到第3、第5和第11个元素
- en: While a detailed theoretical analysis of the given algorithm is beyond the scope
    of this chapter, the runtime of the algorithm merits some discussion. The basic
    idea why the preceding algorithm works is that every time `linear_time_select()`
    is called with an input, *V*, a partition operation is applied, and the function
    then recursively calls itself on only one of the partitions. At each recursion
    step, the size of the problem reduces by at least 30%. Since finding a median
    of five elements is a constant time operation, the recurrence equation that's
    obtained by the preceding algorithm can be then solved using induction to see
    that the runtime is indeed *O(n)*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An interesting property of the linear time selection algorithm is that its well-known
    asymptotic complexity (linear) is achieved when *V* is divided into subvectors
    of five elements each. Finding a constant size of subvectors that results in better
    asymptotic complexity remains an open problem.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: C++ Standard Library Tools for Divide and Conquer
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we manually implemented the necessary functions for
    divide-and-conquer algorithms. However, the C++ standard library comes bundled
    with a large set of predefined functions that can save us a lot of work when programming.
    The following table provides a handy list of the most commonly used functions
    that are used while implementing algorithms that use the divide-and-conquer paradigm.
    We are briefly describing these functions for reference, but the detailed implementation
    is left out of the scope of this chapter for brevity. Feel free to explore more
    about these functions; you should be able to understand them based on the concepts
    we''ve covered in this chapter:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20: Some useful STL functions for algorithms](img/C14498_04_20_1.jpg)![](img/C14498_04_20_2.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.20: Some useful STL functions for algorithms'
  id: totrans-225
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Dividing and Conquering at a Higher Abstraction Level – MapReduce
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far in this chapter, we have looked at divide and conquer as an algorithm
    design technique and used it to solve our problems using a predefined set of divide-conquer-merge
    steps. In this section, we'll take a slight detour and see how the same principle
    of dividing a problem into smaller parts and solving each part separately can
    be particularly helpful when we need to scale software beyond the computational
    power of a single machine and use clusters of computers to solve problems.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'The original **MapReduce** paper starts as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '*"MapReduce is a programming model and an associated implementation for processing
    and generating large datasets. Users specify a map function that processes a key-value
    pair to generate a set of intermediate key/value pairs, and a reduce function
    that merges all the intermediate values associated with the same intermediate
    key."*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can refer to the original research paper about the MapReduce model, which
    was published by Jeffrey Dean and Sanjay Ghemawat in 2004, here: [https://static.googleusercontent.com/media/research.google.com/en/us/archive/mapreduce-osdi04.pdf](https://static.googleusercontent.com/media/research.google.com/en/us/archive/mapreduce-osdi04.pdf).'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Since the original paper first appeared, several open source implementations
    of the MapReduce programming model have appeared, the most notable of which is
    Hadoop. Hadoop provides a programming toolkit for the user to write map and reduce
    functions that can be applied to data stored in a distributed filesystem called
    the Hadoop Distributed File System (HDFS). Since HDFS can easily scale up to a
    cluster of several thousand machines connected over a network, MapReduce programs
    are therefore capable of scaling with the size of the cluster.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: In this section, however, we are interested not in Hadoop, but in MapReduce
    as a programming paradigm, and its association with the topic at hand, that is,
    the divide-and-conquer technique. Instead of Hadoop, we will stick to an open
    source single-machine implementation of MapReduce that uses multithreading to
    emulate the original worker model for task parallelization.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The Map and Reduce Abstractions
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The terms *map* and *reduce* have their origins in functional programming languages
    such as Lisp.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '**Map** is an operation that takes in a container, *C*, and applies a given
    function, *f(x)*, to each element of *C*. An example of using *f(x) = x**2* is
    shown in the following diagram:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21: Mapping the values of a container](img/C14498_04_21.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.21: Mapping the values of a container'
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Reduce** is an operation that aggregates values in a container, *C*, by applying
    a given function, *f(acc, x)*, to each element, *x*, of *C*, and returning a single
    value. This is shown in the following diagram:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22: Reducing the values of a container](img/C14498_04_22.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.22: Reducing the values of a container'
  id: totrans-241
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The C++ Standard Library contains map and reduce operations, that is, `std::transform()`
    and `std::accumulate()`, respectively (`std::reduce()` is also available in C++
    17).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`std::accumulate()` is a restricted form of the reduce operation that uses
    only the addition function. The newer compilers also provide `std::reduce()`,
    which is more general and can be parallelized.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The following exercise demonstrates the implementation of MapReduce using the
    C++ Standard Library.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 22: Map and Reduce in the C++ Standard Library'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we shall see how we can use these functions to further understand
    the map and reduce operations. Let''s get started:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the following headers:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Begin by creating an array with random elements:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `transform_test()` function randomly generates a vector of a given size
    and applies a transformation, *f(x) = x**2*, to the vector.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the following driver code:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Compile and run the code. Your output should look as follows:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.23: Mapping and reducing an array](img/C14498_04_23.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.23: Mapping and reducing an array'
  id: totrans-259
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Integrating the Parts – Using a MapReduce Framework
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To write a program using the MapReduce model, we must be able to express our
    desired computation in a series of two stages: **Map** (also referred to as **Partition**),
    where the program reads the input and creates a set of intermediate *<key,value>*
    pairs, and **Reduce**, where the intermediate *<key,value>* pairs are then combined
    in the required manner to generate the final result. The following diagram illustrates
    this idea:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.24: Generalized MapReduce framework](img/C14498_04_24.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.24: Generalized MapReduce framework'
  id: totrans-263
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The main value that frameworks such as Hadoop add to the MapReduce programming
    model is that they make the map and reduce operations distributed and highly scalable
    so that the computation runs on a cluster of machines and the total time taken
    is reduced.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: We shall use the MapReduce framework to execute a sample task in the following
    exercise.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following exercise and activity need the Boost C++ libraries to be installed
    on your system. Follow these links to get the Boost libraries:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows: [https://www.boost.org/doc/libs/1_71_0/more/getting_started/windows.html](https://www.boost.org/doc/libs/1_71_0/more/getting_started/windows.html)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux/macOS: [https://www.boost.org/doc/libs/1_71_0/more/getting_started/unix-variants.html](https://www.boost.org/doc/libs/1_71_0/more/getting_started/unix-variants.html)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 23: Checking Primes Using MapReduce'
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Given a positive integer, *N*, we wish to find out the prime numbers between
    *1* and *N*. In this exercise, we shall see how we can implement this using the
    MapReduce programming model and solve the problem using multiple threads. Let''s
    get started:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by including the required libraries and defining a function to
    check whether a given number is prime using prime factorization:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following class is used to generate a range of numbers with a given difference
    between consecutive numbers (also called the **step size**):'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following function defines the steps to be performed in the map stage:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let''s implement the reduce stage:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding namespace has three functions: first, it defines a function that
    checks whether a given number is prime; second, it defines a function that generates
    a range of numbers within given bounds; third, it defines the map and reduce tasks.
    The map function, as defined earlier, emits *< k, v >* pairs, where both *k* and
    *v* are of the `long` type, where *k* is *1* if *v* is a prime, and *0* if *v*
    is not a prime number. The reduce function then acts as a filter and outputs *<
    k, v >* pairs only where *k = 1*.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'The following driver code then sets the relevant parameters and starts the
    MapReduce computation:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The driver code sets the parameters that are required for the MapReduce framework,
    runs the computation, collects results from the reduce function, and, finally,
    outputs the results.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and run the preceding code. Your output should look as follows:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/C14498_04_25.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.25: Calculating prime numbers using the MapReduce framework'
  id: totrans-286
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The main benefit of programming using the MapReduce model is that it results
    in software that is massively scalable. The MapReduce framework we used in this
    exercise was one that only used multithreading on a single machine to achieve
    parallelization. But had it been able to support distributed systems, the same
    code we wrote here could have run on a large cluster of servers, enabling the
    computation to scale to massive sizes. Porting the preceding code to systems such
    as Hadoop is a trivial exercise in Java, but beyond the scope of this book.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 10: Implementing WordCount in MapReduce'
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we have seen how powerful the idea behind the divide-and-conquer
    technique can be as an exceedingly useful algorithm design technique, as well
    as in providing useful tools to handle large and complex computations. In this
    activity, we shall practice dividing a large problem into smaller parts, solving
    the smaller parts, and merging the subsequent results by using the MapReduce model
    that was presented in the preceding section.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Our problem definition has been taken from the original MapReduce paper, and
    is given as follows: given a set of files containing text, find the frequency
    of each word that appears in the files. For example, let''s say you are given
    two files with the following contents:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'File 1:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'File 2:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Considering the input files, our program should output the following result:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Such problems often arise in indexing workloads, that is, when you are given
    a large corpus of text and are required to index the contents so that subsequent
    searches on the text can be made faster. Search engines such as Google and Bing
    heavily use such indexes.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, you are required to implement the map and reduce stages of
    the word count problem. Since this involves a significant portion of code that
    is specific to our library, boilerplate code has been provided for you in `mapreduce_wordcount_skeleton.cpp`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '**Activity Guidelines:**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Read through and understand the given code in `mapreduce_wordcount_skeleton.cpp`.
    You will notice that we need to import the Boost libraries in the header. Another
    thing to note is that the map stage in the given code creates *< k, v >* pairs,
    where *k* is a string and *v* is set to *1*. For example, say your set of input
    files contained a random combination of words, *w**1*, *w**2*, *w**3*, …, *w**n*.
    If so, the map stage should output *< k, 1>* pairs with *k = {w**1**, w**2**,
    w**3**, …, w**n**}*, as illustrated in the following diagram:![Figure 4.26: Mapping
    stage](img/C14498_04_26.jpg)'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.26: Mapping stage'
  id: totrans-301
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The skeleton code for the map stage looks as follows:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 地图阶段的骨架代码如下：
- en: '[PRE38]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Since the map stage of the problem generated *< k, 1 >* pairs, the reduce task
    of our program should now combine the pairs with matching values of *k*, as shown
    here:![Figure 4.27: Reducing stage](img/C14498_04_27.jpg)'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于问题的地图阶段生成了*< k, 1 >*对，我们的程序的减少任务现在应该组合具有匹配*k*值的对，如下所示：![图4.27：减少阶段](img/C14498_04_27.jpg)
- en: 'Figure 4.27: Reducing stage'
  id: totrans-305
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.27：减少阶段
- en: 'In the given code, the reduce task accepts two iterators, which can be used
    to iterate over the elements with the same key, that is, all the elements between
    `it` and `ite` are guaranteed to have the same key. Your reduce phase should then
    create a new *< k, v >* pair, with *k* set to the key of the input pairs and *v*
    equal to the number of input pairs:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在给定的代码中，减少任务接受两个迭代器，这些迭代器可用于迭代具有相同键的元素，即，`it`和`ite`之间的所有元素都保证具有相同的键。然后，您的减少阶段应创建一个新的*<
    k, v >*对，其中*k*设置为输入对的键，*v*等于输入对的数量：
- en: '[PRE39]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You are given a set of test data in `testdata/`. Compile and run your code.
    The output should look as follows:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将在`testdata/`中获得一组测试数据。编译并运行您的代码。输出应如下所示：
- en: '![Figure 4.28: Getting the frequency of words in the given input files](img/C14498_04_28.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图4.28：获取给定输入文件中单词的频率](img/C14498_04_28.jpg)'
- en: 'Figure 4.28: Getting the frequency of words in the given input files'
  id: totrans-310
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.28：获取给定输入文件中单词的频率
- en: Note
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注
- en: The solution to this activity can be found on page 514.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第514页找到。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we discussed divide and conquer in two different ways: first
    as an algorithm design paradigm, and then its use in designing other tools that
    help us in scaling our software. We covered some standard divide-and-conquer algorithms
    (merge sort and quicksort). We also saw how simple operations such as **partition**
    underlie the solutions to different problems such as partial sorting and linear
    time selection.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们以两种不同的方式讨论了分而治之：首先作为算法设计范式，然后在设计其他帮助我们扩展软件的工具中使用它。我们涵盖了一些标准的分而治之算法（归并排序和快速排序）。我们还看到了简单操作，如**分区**是不同问题的解决方案的基础，例如部分排序和线性时间选择。
- en: An important idea to keep in mind while implementing these algorithms in practice
    is the separation of data structures that hold data from the implementation of
    the algorithm itself. Using C++ templates is often a good way to achieve this
    separation. We saw that the C++ Standard Library comes with a large set of primitives
    that can be used for implementing divide-and-conquer algorithms.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中实施这些算法时要牢记的一个重要思想是将保存数据的数据结构与算法本身的实现分开。使用C++模板通常是实现这种分离的好方法。我们看到，C++标准库配备了一大套原语，可用于实现分而治之算法。
- en: The simplicity of the underlying idea behind divide and conquer makes it an
    incredibly useful tool in solving problems and allows for the creation of parallelization
    frameworks such as MapReduce. We also saw an example of using the MapReduce programming
    model to find prime numbers in a given range.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 分而治之背后的基本思想的简单性使其成为解决问题的非常有用的工具，并允许创建诸如MapReduce之类的并行化框架。我们还看到了使用MapReduce编程模型在给定范围内找到质数的示例。
- en: In the next chapter, we shall cover the greedy algorithm design paradigm, which
    results in solutions such as Dijkstra's algorithm to find the shortest paths in
    graphs.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍贪婪算法设计范式，这将导致诸如Dijkstra算法在图中找到最短路径的解决方案。
