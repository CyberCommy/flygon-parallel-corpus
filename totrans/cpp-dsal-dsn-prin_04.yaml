- en: 4\. Divide and Conquer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Describe the divide-and-conquer design paradigm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement standard divide-and-conquer algorithms such as merge sort, quicksort,
    and linear time selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solve problems using the MapReduce programming model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use a multithreaded C++ MapReduce implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we shall study the divide-and-conquer algorithm design paradigm
    and learn how to use it to solve computational problems.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we studied some commonly used data structures. Data
    structures are organizations of data in different forms, and a data structure
    enables and controls the cost of access to the data stored inside it. However,
    what makes software useful is not just the ability to store and retrieve data
    in various formats, but the ability to make transformations on data in order to
    solve computational problems. For a given problem, the precise definition and
    order of transformations on data is determined by a sequence of instructions called
    an **algorithm**.
  prefs: []
  type: TYPE_NORMAL
- en: 'An algorithm takes in a set of inputs that define an instance of a problem,
    applies a series of transformations, and outputs a set of results. If these results
    are the correct solutions to the computational problem at hand, our algorithm
    is said to be *correct*. The *goodness* of an algorithm is determined by its efficiency,
    or how few instructions the algorithm needs to perform to produce correct results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: Scaling of steps taken by an algorithm with respect to the size
    of the input](img/C14498_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Scaling of steps taken by an algorithm with respect to the size
    of the input'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The preceding diagram shows the growth in the number of steps required by an
    algorithm as a function of the size of the input. Algorithms that are more complex
    grow more quickly with the size of the input, and with sufficiently large inputs
    they can become infeasible to run, even on modern computer systems. For instance,
    let's assume that we have a computer that can perform a million operations per
    second. For an input of size 50, an algorithm that takes *N log(N)* steps will
    take 283 microseconds to complete; an algorithm that takes *N**2* steps will take
    2.5 milliseconds; and an algorithm that takes *N!* (factorial of *N*) steps would
    take approximately 9,637,644,561,599,544,267,027,654,516,581,964,749,586,575,812,734.82
    **centuries** to run!
  prefs: []
  type: TYPE_NORMAL
- en: '*An algorithm is said to be efficient if, for the size of input N, it solves
    the problem in a number of steps that is a polynomial of N.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problems that express **polynomial-time algorithms** as solutions are also
    said to belong to the class *P* (polynomial) of computational complexity. There
    are several other computational complexities that problems can be divided into,
    a few examples of which are given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NP** (**Non-Deterministic Polynomial Time**) problems have solutions that
    can be verified in polynomial time, but do not have any known polynomial-time
    solutions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EXPTIME** (**Exponential Time**) problems have solutions that run in time
    exponential to the size of the input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PSPACE** (**Polynomial Space**) problems require a polynomial amount of space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding out whether the set of problems in *P* is exactly the same as the set
    of problems in *NP* is the famous *P = NP* problem, which remains unsolved after
    decades of efforts and even carries a $1 million prize for anyone who can solve
    it. We shall take another look at *P* and *NP*-type problems in *Chapter 9*, *Dynamic
    Programming II*.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms have been studied as mathematical objects by computer scientists
    for several decades and a set of general approaches (or **paradigms**) to design
    efficient algorithms have been identified that can be used to solve a wide variety
    of problems. One of the most widely applicable algorithm design paradigms is called
    *divide and conquer* and shall be our subject of study in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A **divide-and-conquer** type algorithm breaks the given problem into smaller
    parts, tries to solve the problem for each part, and, finally, combines the solution
    for each part into the solution for the whole problem. Several widely used algorithms
    fall into this category, for example, binary search, quicksort, merge sort, matrix
    multiplication, Fast Fourier Transform, and the skyline algorithms. These algorithms
    appear in almost all the major applications that are used today, including databases,
    web browsers, and even language runtimes such as the Java Virtual Machine and
    the V8 JavaScript engine.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will show you what it means to solve problems using divide
    and conquer, and how you can identify whether your problem is amenable to such
    a solution. Next, we will practice thinking recursively and show you the tools
    that the modern C++ Standard Library gives you so that you can solve your problems
    using divide and conquer. We'll end this chapter by looking at MapReduce, including
    a discussion on why and how it scales, and how you can use the same paradigm to
    scale up your programs using both CPU-level and machine-level parallelization.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive into a basic algorithm that uses the divide-and-conquer approach
    – binary search.
  prefs: []
  type: TYPE_NORMAL
- en: Binary Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the standard search problem: say we are given a sorted sequence
    of positive integers and are required to find out if a number, *N*, exists in
    the sequence. There are several places where the search problem shows up naturally;
    for example, a receptionist looking for a customer''s file in a set of files that
    are kept ordered by customer IDs or a teacher looking for the marks obtained by
    a student in their register of students. They are both, in effect, solving the
    search problem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can approach the problem in two different ways. In the first approach,
    we iterate over the entire sequence, checking whether each element is equal to
    *N*. This is called a **linear search** and is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: One benefit of this approach is that it works for all arrays, sorted or unsorted.
    However, it is inefficient and does not take into account that the given array
    is sorted. In terms of its algorithmic complexity, it is an *O(N)* algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative solution that exploits the fact that the sequence is sorted
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with the whole sequence in `range`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compare the middle element of the current `range` with *N*. Let this middle
    element be *M*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If *M = N*, we have found *N* in the sequence and, therefore, the search stops.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Otherwise, we modify the `range` according to two rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: –  If *N < M*, it means that if *N* were to be present in the `range`, it would
    be to the left of *M* and, therefore, we can safely remove all the elements to
    the right of *M* from the `range`.
  prefs: []
  type: TYPE_NORMAL
- en: –  If *N > M*, the algorithm removes all the elements to the left of *M* from
    the `range`.
  prefs: []
  type: TYPE_NORMAL
- en: If more than 1 element remains in the `range`, go to *step 2*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, *N* does not exist in the sequence and the search stops.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To illustrate this algorithm, we''ll show how binary search works where *S*
    is a sorted sequence of integers from *1* to 9 and *N = 2*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm starts with putting all the elements of *S* in range. The middle
    element in this step is found to be *5*. We compare *N* and *5*:![Figure 4.2:
    Binary search algorithm – step 1](img/C14498_04_02.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.2: Binary search algorithm – step 1'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Since *N < 5*, if *N* was present in the sequence, it would have to be to the
    left of *5*. Therefore, we can safely discard all the elements of the sequence
    lying toward the right of *5* from our search. Our range now has elements only
    between *1* and *5*, and the middle element is now *3*. We can now compare *N*
    and *3*:![Figure 4.3: Binary search algorithm – step 2](img/C14498_04_03.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.3: Binary search algorithm – step 2'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We find that the current middle element, *3*, is still greater than *N*, and
    the range can further be pruned to contain elements only between *1* and *3*.
    The new middle element is now *2*, which is equal to *N*, and the search terminates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.4: Binary search algorithm – step 3](img/C14498_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Binary search algorithm – step 3'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the following exercise, we shall look at the implementation of the binary
    search algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 18: Binary Search Benchmarks'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will write and benchmark a binary search implementation.
    Follow these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by adding the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the linear search code like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the binary search code shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To evaluate the performance of binary search, we will implement two functions.
    First, write the small test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the large test function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, add the following driver code, which searches for the number `36543`
    in randomly generated vectors of different sizes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program in x64-Debug mode and run it. The output should look like
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.5: Binary search with debugging enabled](img/C14498_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Binary search with debugging enabled'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that each of the three input arrays are all 10 times bigger than the
    previous arrays, so the third array is a hundred times larger than the first array,
    which itself contains a hundred thousand elements. Still, the time taken to search
    in the arrays using binary search increases only by 10 microseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous test, we did not allow any compiler optimizations and ran with
    the debugger attached to the program. Now, let''s see what happens when our compiler
    is allowed to optimize the C++ code with no debugger attached. Try compiling the
    code in *Exercise 18*, *Binary Search Benchmarks*, in x64-Release mode and run
    it. The output should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: Binary search with compiler optimizations turned on](img/C14498_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Binary search with compiler optimizations turned on'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The binary search takes approximately equal time in all three cases, even with
    vastly different vector sizes!
  prefs: []
  type: TYPE_NORMAL
- en: Note that our implementation of binary search uses iterators and the C++ Standard
    Library functions such as `std::distance()` and `std::advance()`. This is considered
    good practice in modern C++ since it helps keep our code agnostic of the underlying
    data type and safe from index out-of-bounds errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, say we wanted to perform a search on a vector of floating-point numbers.
    How would we modify our functions in the previous exercise? The answer is exceedingly
    simple. We can modify the function signatures as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the code inside of the search functions can still remain exactly
    the same since it is completely independent of the underlying datatype and depends
    only on the behavior of a container datatype. **This separation of core algorithm
    logic from the underlying datatype on which the algorithm operates is a cornerstone
    of writing reusable code in modern C++.** We shall see several examples of such
    separation in the duration of this book and dive into more functions that the
    Standard Library provides that can help us write reusable and robust code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 8: Vaccinations'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imagine that it is flu season and health department officials are planning
    to visit a school to ensure that all the enrolled children are administered their
    flu shot. However, there is a problem: a few children have already taken their
    flu shots but do not remember if they have been vaccinated against the specific
    category of flu that the health officials plan to vaccinate all the students against.
    Official records are sought out and the department is able to find a list of students
    that have already been administered the vaccine. A small excerpt of the list is
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: Excerpt of vaccination records](img/C14498_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Excerpt of vaccination records'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Assume that all the names are positive integers and that the given list is
    sorted. Your task is to write a program that can look up the vaccination status
    of a given student in the list and outputs to the officials whether the student
    needs to be vaccinated. Students need to be vaccinated in case of two conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: If they are not present in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If they are present in the list but have not been administered a flu shot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since the list can have a large number of students, your program should be
    as fast and efficient as possible. The final output of your program should look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8: Sample output of Activity 8](img/C14498_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Sample output of Activity 8'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**High-level Steps**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity uses a slightly modified version of the binary
    search algorithm. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Represent each student as an object of the `Student` class, which can be defined
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Overload the required operators for the `Student` class so that a vector of
    students can be sorted using the Standard Library's `std::sort()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a binary search to see if the student is present on the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the student isn't present in the list, your function should return *true*
    since the student needs to be administered the vaccine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, if the student is present in the list but has not been administered
    the vaccine, return *true*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Else, return *false*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 506.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Divide-and-Conquer Approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the core of the divide-and-conquer approach is a simple and intuitive idea:
    if you don''t know how to solve a large instance of a problem, find a small part
    of the problem that you can solve, and then solve it. Then, iterate for more such
    parts, and once you have solved all the parts, combine the results into a large
    coherent solution to the original problem. There are three steps to solving a
    problem using the divide-and-conquer approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Divide**: Take the original problem and divide it into parts so that the
    same problem needs to be solved for each part.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Conquer**: Solve the problem for each part.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Combine**: Take the solutions for the different parts and combine them into
    a solution for the original problem.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the previous section, we looked at an example of using divide and conquer
    to search within a sequence. At each step, binary search tries to search in only
    a part of the sequence, which is marked as the `range`. The search terminates
    when either the element is found or there is no longer a way to further divide
    the `range` into smaller parts. However, the search problem differs from most
    divide-and-conquer algorithms in the following manner: in the search problem,
    if an element can be found in a smaller `range` of the sequence, then it also
    definitely exists in the complete sequence. In other words, the solution to the
    problem in a smaller part of the sequence gives us the solution to the whole problem.
    Therefore, the solution does not need to implement the combination step of the
    general divide-and-conquer approach. This property, unfortunately, is not exhibited
    by the vast majority of computational problems that can be solved using a divide-and-conquer
    approach. In the following section, we shall dive deeper and look at more examples
    of using the divide-and-conquer approach to solve problems.'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting Using Divide and Conquer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We shall now explore how to implement the divide-and-conquer approach when it
    comes to solving another standard problem – sorting. The importance of having
    an efficient sorting algorithm cannot be overstated. In the early days of computing
    in the 1960s, computer manufacturers estimated that 25% of all CPU cycles in their
    machines were spent sorting elements of arrays. Although the computing landscape
    has changed significantly over the years, sorting is still widely studied today
    and remains a fundamental operation in several applications. For instance, it
    is the key idea behind indexes in databases, which then allow quick access to
    the stored data using a logarithmic time search, which is similar to binary search.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general requirements for an implementation of a sorting algorithm are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The implementation should be able to work with any datatype. It should be able
    to sort integers, floating-point decimals, and even C++ structures or classes
    where an order among different elements can be defined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sorting algorithm should be able to handle large amounts of data, that is,
    the same algorithm should work with sizes of data even greater than the main memory
    of a computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sorting algorithm should be fast, both asymptotically and in practice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While all three listed goals are desirable, in practice, it is hard to achieve
    the second and third objectives simultaneously. The second objective requires
    external sorting, that is, sorting data that does not reside on the main memory
    of a computer. External sorting algorithms can work while holding only a small
    subset of the whole data in memory at any point during execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will introduce two sorting algorithms: merge sort and quicksort.
    Merge sort is an external sorting algorithm and, therefore, achieves our second
    objective, while quicksort, as its name suggests, is one of the fastest known
    sorting algorithms in practice and appears as a part of the C++ Standard Library''s
    `std::sort()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Merge Sort
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Merge sort** is one of the oldest known sorting algorithms and appeared in
    reports in the late 1940s. The computers of that time had a few hundred bytes
    of main memory and were often used for complex mathematical analyses. Therefore,
    it was crucial for sorting algorithms to be able to work, even when all the data
    to be operated upon could not be held in the main memory. Merge sort solved this
    problem by exploiting a simple idea – sorting a large set of elements is the same
    as sorting a small subset of elements, and then merging the sorted subsets so
    that the increasing or decreasing order of elements is maintained:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9: Merge sort](img/C14498_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Merge sort'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The preceding diagram shows an example of sorting an array of integers using
    merge sort. First, the algorithm divides the original array into subarrays until
    each subarray only consists of one element (*steps 1* to *4*). In all the subsequent
    steps, the algorithm merges elements into larger arrays, keeping elements in each
    subarray in increasing order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 19: Merge Sort'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we shall implement the merge sort algorithm. The steps are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The C++ code for the merge operation on two vectors is as follows. Write the
    `merge()` function like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The templatized `merge()` function takes in references to two vectors of type
    `T` and returns a new vector containing the elements in input arrays, but sorted
    in increasing order.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use the merge operation to write a recursive merge sort implementation,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following function to print the vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function allows us to test our implementation of the merge sort
    algorithm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and run the program. The output should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.10: Sorting by merge sort](img/C14498_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: Sorting by merge sort'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Our implementation of merge sort in this exercise continues our theme of not
    tying implementations of algorithms to underlying datatypes and relying only on
    the functions exposed by the containers.
  prefs: []
  type: TYPE_NORMAL
- en: Quicksort
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the goal in the case of merge sort was to sort large amounts of data,
    quicksort tries to reduce the average-case running time. The underlying idea in
    quicksort is also the same as merge sort – divide the original input array into
    smaller subarrays, sort the subarrays, and merge the results to get the sorted
    array. However, the fundamental operation that quicksort uses is **partition**
    and not merge.
  prefs: []
  type: TYPE_NORMAL
- en: '**Working of the Partition Operation**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an array and a **pivot element**, *P*, in the array, the **partition
    operation** does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: It divides the original array into two subarrays, *L* and *R*, where *L* contains
    all the elements of the given array that are less than or equal to *P*, and *R*
    contains all elements of the given array that are greater than *P*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It reorganizes the elements in the array in the order *L*, *P*, *R*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram shows the result of a partition that was applied to an
    unsorted array, with the first element chosen as the pivot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11: Selecting a pivot and partitioning the vector around it](img/C14498_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: Selecting a pivot and partitioning the vector around it'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A useful property of the partition operation is that after it is applied, the
    new position of the pivot, *P*, in the vector becomes the position that *P* would
    have if the vector were sorted. For example, the element *5* appears at the 5th
    position in the array after we apply the partition operation, which is the same
    position that element *5* would have been in if the array was sorted in increasing
    order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding property is also the core idea behind the quicksort algorithm,
    which works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the input array, *A*, has more than 1 element in it, apply the partition
    operation on *A*. It results in subarrays *L* and *R*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use *L* as an input to *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use *R* as an input to *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Steps 2* and *3* are recursive calls to the partition operation on the arrays
    that are generated by the partition operation and applied to the original input
    array. This simple recursive application of the partition operation results in
    sorting elements in increasing order. Since the quicksort recursion trees can
    quickly become deep, the following diagram shows an example of applying quicksort
    on a small array of six elements, *{5, 6, 7, 3, 1, 9}*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12: Visualization of the quicksort algorithm](img/C14498_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: Visualization of the quicksort algorithm'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Each iteration of the algorithm shows the result of the partition operation
    being applied to the subarrays generated in the previous step using the highlighted
    pivots. It should be noted that our choice of the first element of the array as
    the pivot is arbitrary. Any element of the array can be chosen as the pivot without
    affecting the correctness of the quicksort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 20: Quicksort'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we shall implement and test our implementation of quicksort.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The C++ code for the partition operation is as follows. Write the `partition()`
    function as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The implementation shown here takes in only the iterators over an underlying
    container object and returns another iterator that points to the index of the
    partition in the array. This means that all the elements of the vector are greater
    than the pivot in the right partition, and all the elements less than or equal
    to the pivot are in the left partition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The quicksort algorithm uses the partition operation recursively, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`print_vector()` is used to print a vector to the console and is implemented
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Adapt the driver code from *Exercise 19*, *Merge Sort*, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a `main()` function that calls `run_quick_sort_test()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Your final output should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.13: Sorting by quicksort](img/C14498_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.13: Sorting by quicksort'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: However, the runtime of quicksort does depend on how "good" our choice of pivot
    is. The best case for quicksort is when the pivot at any step is the median element
    of the current array; in such a case, quicksort is able to partition the elements
    into vectors of equal sizes at each step, and, therefore, the depth of the recursion
    tree is exactly *log(n)*. If the medians are not chosen as pivots, it results
    in an imbalance in the partition sizes and, therefore, a deeper recursion tree
    and greater running time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The asymptotic complexity of quicksort and merge sort is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14: Asymptotic complexity of quicksort and merge sort](img/C14498_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.14: Asymptotic complexity of quicksort and merge sort'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Activity 9: Partial Sorting'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the last two exercises, we have implemented **total sorting** algorithms
    that order all the elements of a vector in an increasing (or decreasing) order.
    However, this can be overkill in several problem instances. For example, imagine
    that you are given a vector containing the ages of all humans on earth and are
    asked to find the median age of the oldest 10% of the population.
  prefs: []
  type: TYPE_NORMAL
- en: A naïve solution to this problem is to sort the vector of ages, extract the
    ages of the oldest 10% people from the vector, and then find the median of the
    extracted vector. However, this solution is wasteful as it does far more than
    is strictly needed in order to compute the solution, that is, it sorts the entire
    array to ultimately use only 10% of the sorted array for the required solution.
  prefs: []
  type: TYPE_NORMAL
- en: A better solution to such problems can be derived by specializing the total
    sorting algorithms such as merge sort and quicksort into **partial sorting algorithms**.
    A partial sorting algorithm sorts only a specified number of elements in a given
    vector and leaves the rest of the vector unsorted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The partial quicksort is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Assume that we are given a vector, *V*, and we are required to create a sorted
    subvector of *k* elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the partition operation on *V*, assuming the first element of *V* as the
    pivot (again, this choice is completely arbitrary). The result of the partition
    operation are two vectors, *L* and *R*, where *L* contains all the elements of
    *V* that are less than the pivot and *R* contains all the elements greater than
    the pivot. Also, the new position of the pivot is the "correct" position of the
    pivot in the sorted array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use *L* as input to *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the new position of pivot in *step 2* is less than *k*, use *R* as input
    to *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your task in this activity is to implement the partial quicksort algorithm
    that uses randomly generated arrays to test the output of the algorithm. The final
    output with a vector of size *100* and *k = 100* should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15: Sample output of Activity 9](img/C14498_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.15: Sample output of Activity 9'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 510.
  prefs: []
  type: TYPE_NORMAL
- en: Linear Time Selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we looked at simple examples of algorithms that use
    the divide-and-conquer paradigm and were introduced to the partition and merge
    operations. So far, our view of divide-and-conquer algorithms has been restricted
    to ones that recursively divide each intermediate step into exactly two subparts.
    However, there are certain problems where dividing each step into more subparts
    can yield substantial benefits. In the following section, we shall study one such
    problem – linear time selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you are in charge of organizing a marching band parade for your
    school. To ensure that all the band members look uniform, it is important that
    the heights of students be the same. Moreover, students from all grades are required
    to participate. To solve these problems, you come up with the following solution
    – you will select only the 15th shortest student in every grade to participate
    in the parade. The problem can be formalized as follows: given a randomly ordered
    set of elements, *S*, you are asked to find the *i**th* smallest element in *S*.
    A simple solution could be sorting the input and then selecting the *i**th* element.
    However, the algorithmic complexity of this solution is *O(n log n)*. In this
    section, we will work through a divide-and-conquer solution that solves the problem
    in *O(n)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our solution hinges on using the partition operation correctly. The partition
    operation we introduced in the previous subsection takes in a vector and a pivot,
    and then divides the vector into two parts, one containing all the elements less
    than the pivot and the other containing all the elements greater than the pivot.
    The final algorithm works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Assume that we are given an input vector, *V*, and we need to find the *ith*
    smallest element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Divide the input vector, *V*, into vectors *V**1*, *V**2*, *V**3*, *…* , *V**n/5*,
    each containing five elements (the last vector can have less than five elements,
    if necessary).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we sort each *V**i*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each *V**i*, find the median, *m**i*, and collect all medians into a set,
    *M*, as shown here:![Figure 4.16: Finding the medians of each subvector](img/C14498_04_16.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.16: Finding the medians of each subvector'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Find the median element, *q*, of *M*:![Figure 4.17: Finding the median of a
    set of medians](img/C14498_04_17.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.17: Finding the median of a set of medians'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Use the partition operation on *V* using *q* as the pivot to get two vectors,
    *L* and *R*:![Figure 4.18: Partitioning the whole vector](img/C14498_04_18.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.18: Partitioning the whole vector'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'By the definition of the partition operation, *L* contains all the elements
    less than *q* and *R* contains all the elements greater than *q*. Let''s say *L*
    has *(k – 1)* elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: –  If *i = k*, then *q* is the *i**th* element in *V*.
  prefs: []
  type: TYPE_NORMAL
- en: –  If *i < k*, set *V = L* and go to *step 1*.
  prefs: []
  type: TYPE_NORMAL
- en: –  If *i > k*, set *V = R* and *i = i – k*, and go to *step 1*.
  prefs: []
  type: TYPE_NORMAL
- en: The following exercise demonstrates the implementation of this algorithm in
    C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 21: Linear Time Selection'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we shall implement the linear time selection algorithm. Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the helper function shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In *Exercise 20*, *Quicksort*, our partition function assumed that the first
    element in a given vector was always the pivot to be used. We now need a more
    general form of the partition operation that can work with any pivot element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following code to implement our linear time search algorithm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the merge sort implementation shown in the following code. We shall use
    the sorting algorithm to demonstrate the correctness of our implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, add the following driver and test functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and run the code. Your final output should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.19: Finding the 3rd, 5th, and 11th elements using linear time selection](img/C14498_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.19: Finding the 3rd, 5th, and 11th elements using linear time selection'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While a detailed theoretical analysis of the given algorithm is beyond the scope
    of this chapter, the runtime of the algorithm merits some discussion. The basic
    idea why the preceding algorithm works is that every time `linear_time_select()`
    is called with an input, *V*, a partition operation is applied, and the function
    then recursively calls itself on only one of the partitions. At each recursion
    step, the size of the problem reduces by at least 30%. Since finding a median
    of five elements is a constant time operation, the recurrence equation that's
    obtained by the preceding algorithm can be then solved using induction to see
    that the runtime is indeed *O(n)*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An interesting property of the linear time selection algorithm is that its well-known
    asymptotic complexity (linear) is achieved when *V* is divided into subvectors
    of five elements each. Finding a constant size of subvectors that results in better
    asymptotic complexity remains an open problem.
  prefs: []
  type: TYPE_NORMAL
- en: C++ Standard Library Tools for Divide and Conquer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we manually implemented the necessary functions for
    divide-and-conquer algorithms. However, the C++ standard library comes bundled
    with a large set of predefined functions that can save us a lot of work when programming.
    The following table provides a handy list of the most commonly used functions
    that are used while implementing algorithms that use the divide-and-conquer paradigm.
    We are briefly describing these functions for reference, but the detailed implementation
    is left out of the scope of this chapter for brevity. Feel free to explore more
    about these functions; you should be able to understand them based on the concepts
    we''ve covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20: Some useful STL functions for algorithms](img/C14498_04_20_1.jpg)![](img/C14498_04_20_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.20: Some useful STL functions for algorithms'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Dividing and Conquering at a Higher Abstraction Level – MapReduce
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far in this chapter, we have looked at divide and conquer as an algorithm
    design technique and used it to solve our problems using a predefined set of divide-conquer-merge
    steps. In this section, we'll take a slight detour and see how the same principle
    of dividing a problem into smaller parts and solving each part separately can
    be particularly helpful when we need to scale software beyond the computational
    power of a single machine and use clusters of computers to solve problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original **MapReduce** paper starts as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"MapReduce is a programming model and an associated implementation for processing
    and generating large datasets. Users specify a map function that processes a key-value
    pair to generate a set of intermediate key/value pairs, and a reduce function
    that merges all the intermediate values associated with the same intermediate
    key."*'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can refer to the original research paper about the MapReduce model, which
    was published by Jeffrey Dean and Sanjay Ghemawat in 2004, here: [https://static.googleusercontent.com/media/research.google.com/en/us/archive/mapreduce-osdi04.pdf](https://static.googleusercontent.com/media/research.google.com/en/us/archive/mapreduce-osdi04.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: Since the original paper first appeared, several open source implementations
    of the MapReduce programming model have appeared, the most notable of which is
    Hadoop. Hadoop provides a programming toolkit for the user to write map and reduce
    functions that can be applied to data stored in a distributed filesystem called
    the Hadoop Distributed File System (HDFS). Since HDFS can easily scale up to a
    cluster of several thousand machines connected over a network, MapReduce programs
    are therefore capable of scaling with the size of the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, however, we are interested not in Hadoop, but in MapReduce
    as a programming paradigm, and its association with the topic at hand, that is,
    the divide-and-conquer technique. Instead of Hadoop, we will stick to an open
    source single-machine implementation of MapReduce that uses multithreading to
    emulate the original worker model for task parallelization.
  prefs: []
  type: TYPE_NORMAL
- en: The Map and Reduce Abstractions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The terms *map* and *reduce* have their origins in functional programming languages
    such as Lisp.
  prefs: []
  type: TYPE_NORMAL
- en: '**Map** is an operation that takes in a container, *C*, and applies a given
    function, *f(x)*, to each element of *C*. An example of using *f(x) = x**2* is
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21: Mapping the values of a container](img/C14498_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.21: Mapping the values of a container'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Reduce** is an operation that aggregates values in a container, *C*, by applying
    a given function, *f(acc, x)*, to each element, *x*, of *C*, and returning a single
    value. This is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22: Reducing the values of a container](img/C14498_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.22: Reducing the values of a container'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The C++ Standard Library contains map and reduce operations, that is, `std::transform()`
    and `std::accumulate()`, respectively (`std::reduce()` is also available in C++
    17).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`std::accumulate()` is a restricted form of the reduce operation that uses
    only the addition function. The newer compilers also provide `std::reduce()`,
    which is more general and can be parallelized.'
  prefs: []
  type: TYPE_NORMAL
- en: The following exercise demonstrates the implementation of MapReduce using the
    C++ Standard Library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 22: Map and Reduce in the C++ Standard Library'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we shall see how we can use these functions to further understand
    the map and reduce operations. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Begin by creating an array with random elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `transform_test()` function randomly generates a vector of a given size
    and applies a transformation, *f(x) = x**2*, to the vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following driver code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and run the code. Your output should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.23: Mapping and reducing an array](img/C14498_04_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.23: Mapping and reducing an array'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Integrating the Parts – Using a MapReduce Framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To write a program using the MapReduce model, we must be able to express our
    desired computation in a series of two stages: **Map** (also referred to as **Partition**),
    where the program reads the input and creates a set of intermediate *<key,value>*
    pairs, and **Reduce**, where the intermediate *<key,value>* pairs are then combined
    in the required manner to generate the final result. The following diagram illustrates
    this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.24: Generalized MapReduce framework](img/C14498_04_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.24: Generalized MapReduce framework'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The main value that frameworks such as Hadoop add to the MapReduce programming
    model is that they make the map and reduce operations distributed and highly scalable
    so that the computation runs on a cluster of machines and the total time taken
    is reduced.
  prefs: []
  type: TYPE_NORMAL
- en: We shall use the MapReduce framework to execute a sample task in the following
    exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following exercise and activity need the Boost C++ libraries to be installed
    on your system. Follow these links to get the Boost libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows: [https://www.boost.org/doc/libs/1_71_0/more/getting_started/windows.html](https://www.boost.org/doc/libs/1_71_0/more/getting_started/windows.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux/macOS: [https://www.boost.org/doc/libs/1_71_0/more/getting_started/unix-variants.html](https://www.boost.org/doc/libs/1_71_0/more/getting_started/unix-variants.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 23: Checking Primes Using MapReduce'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Given a positive integer, *N*, we wish to find out the prime numbers between
    *1* and *N*. In this exercise, we shall see how we can implement this using the
    MapReduce programming model and solve the problem using multiple threads. Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by including the required libraries and defining a function to
    check whether a given number is prime using prime factorization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following class is used to generate a range of numbers with a given difference
    between consecutive numbers (also called the **step size**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function defines the steps to be performed in the map stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s implement the reduce stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding namespace has three functions: first, it defines a function that
    checks whether a given number is prime; second, it defines a function that generates
    a range of numbers within given bounds; third, it defines the map and reduce tasks.
    The map function, as defined earlier, emits *< k, v >* pairs, where both *k* and
    *v* are of the `long` type, where *k* is *1* if *v* is a prime, and *0* if *v*
    is not a prime number. The reduce function then acts as a filter and outputs *<
    k, v >* pairs only where *k = 1*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following driver code then sets the relevant parameters and starts the
    MapReduce computation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The driver code sets the parameters that are required for the MapReduce framework,
    runs the computation, collects results from the reduce function, and, finally,
    outputs the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and run the preceding code. Your output should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/C14498_04_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.25: Calculating prime numbers using the MapReduce framework'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The main benefit of programming using the MapReduce model is that it results
    in software that is massively scalable. The MapReduce framework we used in this
    exercise was one that only used multithreading on a single machine to achieve
    parallelization. But had it been able to support distributed systems, the same
    code we wrote here could have run on a large cluster of servers, enabling the
    computation to scale to massive sizes. Porting the preceding code to systems such
    as Hadoop is a trivial exercise in Java, but beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 10: Implementing WordCount in MapReduce'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we have seen how powerful the idea behind the divide-and-conquer
    technique can be as an exceedingly useful algorithm design technique, as well
    as in providing useful tools to handle large and complex computations. In this
    activity, we shall practice dividing a large problem into smaller parts, solving
    the smaller parts, and merging the subsequent results by using the MapReduce model
    that was presented in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our problem definition has been taken from the original MapReduce paper, and
    is given as follows: given a set of files containing text, find the frequency
    of each word that appears in the files. For example, let''s say you are given
    two files with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'File 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Considering the input files, our program should output the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Such problems often arise in indexing workloads, that is, when you are given
    a large corpus of text and are required to index the contents so that subsequent
    searches on the text can be made faster. Search engines such as Google and Bing
    heavily use such indexes.
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, you are required to implement the map and reduce stages of
    the word count problem. Since this involves a significant portion of code that
    is specific to our library, boilerplate code has been provided for you in `mapreduce_wordcount_skeleton.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Activity Guidelines:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Read through and understand the given code in `mapreduce_wordcount_skeleton.cpp`.
    You will notice that we need to import the Boost libraries in the header. Another
    thing to note is that the map stage in the given code creates *< k, v >* pairs,
    where *k* is a string and *v* is set to *1*. For example, say your set of input
    files contained a random combination of words, *w**1*, *w**2*, *w**3*, …, *w**n*.
    If so, the map stage should output *< k, 1>* pairs with *k = {w**1**, w**2**,
    w**3**, …, w**n**}*, as illustrated in the following diagram:![Figure 4.26: Mapping
    stage](img/C14498_04_26.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.26: Mapping stage'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The skeleton code for the map stage looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the map stage of the problem generated *< k, 1 >* pairs, the reduce task
    of our program should now combine the pairs with matching values of *k*, as shown
    here:![Figure 4.27: Reducing stage](img/C14498_04_27.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.27: Reducing stage'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the given code, the reduce task accepts two iterators, which can be used
    to iterate over the elements with the same key, that is, all the elements between
    `it` and `ite` are guaranteed to have the same key. Your reduce phase should then
    create a new *< k, v >* pair, with *k* set to the key of the input pairs and *v*
    equal to the number of input pairs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You are given a set of test data in `testdata/`. Compile and run your code.
    The output should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.28: Getting the frequency of words in the given input files](img/C14498_04_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.28: Getting the frequency of words in the given input files'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 514.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed divide and conquer in two different ways: first
    as an algorithm design paradigm, and then its use in designing other tools that
    help us in scaling our software. We covered some standard divide-and-conquer algorithms
    (merge sort and quicksort). We also saw how simple operations such as **partition**
    underlie the solutions to different problems such as partial sorting and linear
    time selection.'
  prefs: []
  type: TYPE_NORMAL
- en: An important idea to keep in mind while implementing these algorithms in practice
    is the separation of data structures that hold data from the implementation of
    the algorithm itself. Using C++ templates is often a good way to achieve this
    separation. We saw that the C++ Standard Library comes with a large set of primitives
    that can be used for implementing divide-and-conquer algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The simplicity of the underlying idea behind divide and conquer makes it an
    incredibly useful tool in solving problems and allows for the creation of parallelization
    frameworks such as MapReduce. We also saw an example of using the MapReduce programming
    model to find prime numbers in a given range.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we shall cover the greedy algorithm design paradigm, which
    results in solutions such as Dijkstra's algorithm to find the shortest paths in
    graphs.
  prefs: []
  type: TYPE_NORMAL
