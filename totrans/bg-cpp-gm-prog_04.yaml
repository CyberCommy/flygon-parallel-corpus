- en: Chapter 4.  Loops, Arrays, Switch, Enumerations, and Functions – Implementing
    Game Mechanics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter probably has more C++ information than any other chapter in the
    book. It is packed with fundamental concepts that will move our understanding
    on enormously. It will also begin to shed light on some of the murky areas that
    we have been skipping over a little bit, such as functions and game loops.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have explored a whole list of C++ language necessities we will then
    use everything we know to make the main game mechanic, the tree branches, move.
    By the end of this chapter we will be ready for the final phase and the completion
    of Timber!!!.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be looking at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making decisions with switch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and moving the tree branches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In programming, we often need to do the same thing more than once. The obvious
    example that we have seen so far is our game loop. With all the code stripped
    out, our game loop looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There are a few different types of loop and we will look at the most commonly
    used. The correct term for this type of loop is a `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: while loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `while` loop is quite straightforward. Think back to the `if` statements
    and their expressions that evaluated to either `true` or `false`. We can use the
    exact same combination of operators and variables in the conditional expression
    of our `while` loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with `if` statements, if the expression is `true` the code executes. The
    difference in comparison a `while` loop, however, is that the C++ code within
    it will continue to execute until the condition is `false`. Take a look at this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is what is happening in the previous code. Outside of the `while` loop,
    `int numberOfZombies` is declared and initialized to `100`. Then the `while` loop
    begins. Its conditional expression is `numberOfZombies > 0`. Therefore the `while`
    loop will continue looping through the code in its body until the condition evaluates
    to `false`. This means that the code above will execute `100` times.
  prefs: []
  type: TYPE_NORMAL
- en: On the first pass through the loop, `numberOfZombies` equals `100` then 99 then
    98 and so on. But once `numberOfZOmbies` is equal to zero, it is of course, no
    longer greater than zero. Then the code will break out of the `while` loop and
    continue to run, after the closing curly brace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like an `if` statement, it is possible that the `while` loop will not
    execute even once. Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, there is no limit to the complexity of the expression or the amount
    of code that can go in the loop body. Consider this hypothetical variation of
    a game loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The previous `while` loop would continue to execute until either `playerLives`
    or `alienShips` was equal to zero. As soon as one of those conditions occurred,
    the expression would evaluate to `false`, and the program would continue to execute
    from the first line of code after the `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth noticing that, once the body of the loop has been entered, it will
    always complete at least once, even if the expression evaluates to `false`, part
    way through, as it is not tested again until the code tries to start another pass.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous loop body will execute once. We can also set up a `while` loop
    that will run forever, unsurprisingly called an **infinite loop**. Here is an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you find the above loop confusing, just think of it literally. A loop executes
    when its condition is `true`. Well, `true` is always `true` and will therefore
    keep executing.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking out of a while loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We might use an infinite loop so that we can decide when to exit the loop from
    within its body, rather than in the expression. We would do this by using the
    `break` keyword, when we are ready to leave the loop body. Perhaps it would look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You might also have been able to guess that we can combine any of the C++ decision
    making tools such as `if`, `else`, and another we will learn shortly, `switch`,
    within our `while` loops and other loop types as well. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We could go on for a long time looking at the various permutations of C++ `while`
    loops, but at some point we want to get back to making games. So let's move on
    to another type of loop.
  prefs: []
  type: TYPE_NORMAL
- en: for loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `for` loop has a slightly more complicated syntax than a `while` loop,
    because it takes three parts to set one up. Have a look at the code first then
    we will break it apart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here is what all the parts of the `for` loop condition do.
  prefs: []
  type: TYPE_NORMAL
- en: '`for(`declaration and initialization`;` condition`;` change before each iteration`)`'
  prefs: []
  type: TYPE_NORMAL
- en: To clarify further, here is a table to explain all of the three key parts as
    they appear in the previous `for` loop example.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Part** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Declaration and initialization | We create a new `int` variable `i` and initialize
    it to 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Condition | Just like the other loops, it refers to the condition that must
    be `true` for the loop to execute |'
  prefs: []
  type: TYPE_TB
- en: '| Change after each pass through loop | In the example, `x ++` means that 1
    is added/incremented to `x` on each pass |'
  prefs: []
  type: TYPE_TB
- en: 'We can vary `for` loops to do many more things. Here is another simple example
    that counts down from 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `for` loop takes control of initialization, condition evaluation, and the
    control variable upon itself. We will use `for` loops in our game, later this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a variable is a box in which we can store a value of a specific type, like
    `int`, `float`, or `char`, then we can think of an array as a whole row of boxes.
    The row of boxes can be of almost any size and type, including objects of classes.
    However, all the boxes must be of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The limitation of having to use the same type in each box can be circumvented,
    to an extent, once we learn some more advanced C++ in the final project.
  prefs: []
  type: TYPE_NORMAL
- en: 'This array sounds like it could have been useful for our clouds from [Chapter
    2](ch02.html "Chapter 2. Variables, Operators, and Decisions – Animating Sprites"):
    *Variables, Operators, and Decisions - Animating Sprites*. So how do we go about
    creating and using an array?'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can declare an array of `int` type variables like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now we have an array called `someInts` that can store ten `int` values. At the
    moment, however, it is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the elements of an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add values into the elements of an array, we can use the type of syntax
    we are already familiar with, combined with some new syntax, known as **array
    notation**. In this next code, we store the value of `99` into the first element
    of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To store a value of `999` at the second element we write this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can store a value of `3` at the last element as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that the elements of an array always start at zero and go up to the size
    of the array minus 1\. Similarly to ordinary variables, we can manipulate the
    values stored in an array. The only difference is that we would use the array
    notation to do so as, although our array has a name, `someInts`, the individual
    elements do not have names.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this next code we add the first and second elements together and store the
    answer in the third:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrays can also interact seamlessly with regular variables, such as in this
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Quickly initializing the elements of an array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can quickly add values to elements such as this example using a `float`
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now the values `3.14`, `1.63` and `99.0` are stored in the first, second, and
    third positions respectively. Remember that when using array notation to access
    these values we would use [0], [1] and [2].
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other ways to initialize the elements of an array. This slightly
    abstract example shows using a `for` loop to put the values 0 through 9 into the
    `uselessArray` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The code assumes that `uslessArray` had previously been initialized to hold
    at least `10` `int` variables.
  prefs: []
  type: TYPE_NORMAL
- en: So what do these arrays really do for our games?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use arrays anywhere that a regular variable can be used. For example,
    they could be used in an expression such as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Perhaps the biggest benefit of arrays in game code was hinted at the start
    of this section. Arrays can hold objects (instances of classes). Imagine that
    we have a `Zombie` class and we want to store a whole bunch of them. We could
    do so as we do in this hypothetical example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `horde` array now holds a load of instances of the `Zombie` class. Each
    one is a separate, living (kind of), breathing, and self-determining `Zombie`
    object. We could then loop through the `horde` array, each pass through the game
    loop, moving the zombies, checking if their heads have met with an ax, or if they
    have managed to catch the player.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays, had we known about them at the time, would have been perfect for handling
    our clouds. We could have had as many clouds as we wanted and written less code
    than we did for our three measly clouds.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To check out this improved cloud code in full, and in action, look at the enhanced
    version of Timber!!! (the code and the playable game) in the download bundle.
    Or you can try to implement the clouds using arrays yourself before looking at
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to get a feel for all this array stuff is to see it in action.
    And we will, when we implement our tree branches.
  prefs: []
  type: TYPE_NORMAL
- en: For now we will leave our cloud code as it is so that we can get back to adding
    features to the game as soon as possible. But first let's look at a bit more C++
    decision making with `switch`.
  prefs: []
  type: TYPE_NORMAL
- en: Making decisions with switch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen `if`, which allows us to make a decision whether to execute
    a block of code based upon the result of its expression. Sometimes a decision
    in C++ can be better made in other ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we have to make a decision based on a clear list of possible outcomes,
    which doesn''t involve complex combinations or wide ranges of values, then `switch`
    is usually the way to go. We start a `switch` decision as we can see in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, `expression` could be an actual expression or just
    a variable. Then, within the curly braces, we can make decisions based on the
    result of the expression or the value of the variable. We do this with the `case`
    and `break` keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can see in the previous abstract example that, each `case` states a possible
    result and each `break` denotes the end of that `case` and the point at which
    execution leaves the `switch` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also, optionally, use the `default` keyword without a value, to run
    some code in case none of the `case` statements evaluate to `true`. Here is an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As a final and less abstract example for `switch`, consider a retro text adventure
    where the player enters a letter such as `''n''`, `''e''`, `''s''`, or `''w''`
    to move North, East, South, or West. A `switch` block could be used to handle
    each possible input from the player, as we can see in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The best way of understanding everything we have learned about `switch` will
    be when we put it into action along with all the other new concepts we are learning.
  prefs: []
  type: TYPE_NORMAL
- en: Class enumerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An enumeration is a list of all the possible values in a logical collection.
    C++ enumerations are a great way of, well, enumerating things. For example, if
    our game uses variables, which can only be in a specific range of values, and
    if those values could logically form a collection or a set, then enumerations
    are probably appropriate to use. They will make your code clearer and less error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: To declare a class enumeration in C++ we use two keywords, `enum` and `class`,
    together, followed by the name of the enumeration, followed by the values the
    enumeration can contain, enclosed in a pair of curly braces `{...}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, examine this enumeration declaration. Note that it is conventional
    to declare the possible values from the enumeration all in uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Note, at this point, we have not declared any instances of `zombieType`, just
    the type itself. If that sounds odd, think about it like this: SFML created the
    `Sprite`, `RectangleShape`, and `RenderWindow` classes, but to use any of those
    classes we had to declare an object/instance of the class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point we have created a new type called `zombieTypes`, but we have
    no instances of it. So let''s create them now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is a sneak preview of the type of code we will soon be adding to Timber!!!.
    We will want to track which side of the tree a branch or the player is on, so
    we will declare an enumeration called `side`, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We could position the player on the left as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We could make the fourth level (arrays start from zero) of an array of branch
    positions have no branch at all, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use enumerations in expressions as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We will look at one more vital C++ topic and then we will get back to coding
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So what exactly are C++ functions? A function is a collection of variables,
    expressions, and **control flow statements** (loops and branches). In fact, any
    of the code we have learnt about in the book so far can be used in a function.
    The first part of a function that we write is called the **signature**. Here is
    an example function signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: "If you add an opening and closing pair of curly braces `{â\x80¦}` with some\
    \ code that the function actually performs then we have a complete function, a\
    \ definition:"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We could then use our new function in another part of our code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When we use a function we say that we **call** it. At the point where we call
    `bombPlayer`, our program's execution branches to the code contained within that
    function. The function will run until it reaches the end or is told to `return`.
    Then the code will continue running from the first line after the function call.
    We have already been using the functions that SFML provides. What is different
    here is that we will learn to write and call our own functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example of a function, complete with the code to make the function
    return to the code that called it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to use the above function could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, we don't need to write functions to add two variables together, but
    the example helps us see a little further into the workings of functions. First
    we pass in the values `2` and `4`. In the function signature the value `2` is
    assigned to `int a`, and the value `4` is assigned to `int b`.
  prefs: []
  type: TYPE_NORMAL
- en: Within the function body, the variables `a` and `b` are added together and used
    to initialize the new variable `int answer`. The line `return answer;` does just
    that. It returns the value stored in `answer` to the calling code, causing `myAnswer`
    to be initialized with the value `6`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that each of the function signatures in the examples above varies a little.
    The reason for this is that the C++ function signature is quite flexible, allowing
    us to build exactly the functions we require.
  prefs: []
  type: TYPE_NORMAL
- en: Exactly how the function signature defines how the function must be called and
    if/how the function must return a value, deserves further discussion. Let's give
    each part of that signature a name so we can break it into parts and learn about
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a function signature with its parts described by their formal, technical
    terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And here are a few examples we can use for each of those parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Return-type**: `bool`, `float`, `int` and so on, or any C++ type or expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Name of function**: `bombPlayer`, `shootLazers`, `setCoordinates`, `addAToB`
    and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameters**: `(int number, bool hitDetected)`, `(int x, int y)` `(float
    a, float b)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's look at each part in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Function return types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The return type, as the name suggests, is the type of the value that will be
    returned from the function to the calling code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In our slightly dull, but useful, `addAtoB` example previously, the return type
    in the signature is `int`. The function `addAToB` sends back, or returns, to the
    code that called it, a value that will fit in an `int` variable. The return type
    can be any C++ type we have seen so far, or one of the ones we haven't seen yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function does not have to return a value at all however. In this case the
    signature must use the `void` keyword as the return type. When the `void` keyword
    is used, the function body must not attempt to return a value as this will cause
    an error. It can, however, use the `return` keyword without a value. Here are
    some combinations of return type and the use of the `return` keyword that are
    valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Another possibility is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code gives us yet more examples of possible functions. Be sure
    to read the comments as well as the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The last function example above, `detectCollision` is a glimpse into the near
    future of our C++ code, and demonstrates that we can also pass in  user-defined
    types, called **objects**, into functions to perform calculations on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could call each of the functions above, in turn, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry about the odd-looking syntax regarding the `detectCollision` function,
    we will see real code like this, quite soon. Simply, we are using the return value
    (`true` or `false`) as the expression, directly in an `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Function names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The function name, when we design our own function, can be almost anything
    at all. But it is best to use words, usually verbs, to clearly explain what the
    function will do. For example, look at this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The above is perfectly legal, and will work, but these next function names
    are much clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's take a closer look at how we share some values with a function.
  prefs: []
  type: TYPE_NORMAL
- en: Function parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We know that a function can return a result to the calling code. What if we
    need to share some data values from the calling code with the function? **Parameters**
    allow us to share values with the function. We have actually already seen examples
    of parameters while looking at return types. We will look at the same example
    but a little more closely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Above, the parameters are `int a` and `int b`. Notice that, in the first line
    of the function body, we use `a + b` as if they are already declared and initialized
    variables. Well, that's because they are. The parameters in the function signature
    are their declaration and the code that calls the function initializes them.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Important jargon note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we are referring to the variables in the function signature brackets
    `(int a, int b)` as parameters. When we pass values into the function from the
    calling code, these values are called arguments. When the arguments arrive they
    are called parameters and are used to initialize real, usable variables: `int
    returnedAnswer = addAToB(10,5);`'
  prefs: []
  type: TYPE_NORMAL
- en: Also, as we have partly seen in previous examples, we don't have to just use
    `int` in our parameters. We can use any C++ type. We can also use as many parameters
    as necessary to solve our problem, but it is good practice to keep the parameter
    list as short and therefore manageable as possible.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see in future chapters, we have left a few of the cooler uses of
    functions out of this introductory tutorial, so that we can learn about related
    C++ concepts before we take the topic of functions further.
  prefs: []
  type: TYPE_NORMAL
- en: The function body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The body is the part we have been kind of avoiding with comments such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: But actually, we know exactly what to do here already! Any C++ code we have
    learned about so far will work in the body of a function.
  prefs: []
  type: TYPE_NORMAL
- en: Function prototypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how to code a function and we have seen how to call one as well.
    There is one more thing we need to do, however, to make them work. All functions
    must have a **prototype**. A prototype is what makes the compiler aware of our
    function; without a prototype, the entire game will fail to compile. Fortunately,
    prototypes are straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simply repeat the function''s signature, followed by a semicolon. The
    caveat is that the prototype must appear before any attempt to call or define
    the function. So the absolutely simplest example of a fully usable function in
    action is as follows. Look carefully at the comments and where in the code the
    different parts of the function appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'What the previous code demonstrates is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The prototype is before the `main` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The call to use the function is, as we might expect, inside the `main` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The definition is after/outside the `main` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we can omit the function prototype and go straight to the definition
    when the definition occurs before the function is used. As our code becomes longer
    and spreads across multiple files, however, this will almost never happen. We
    will use separate prototypes and definitions all the time.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we can keep our functions organized.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's well worth pointing out that, if we have multiple functions, especially
    if they are fairly long, our `.cpp` file will quickly become unwieldy. This defeats
    part of the objective that functions are intended for. The solution that we will
    see in the next project, is that we can add all of our function prototypes to
    our very own header file (`.hpp` or `.h`). Then we can code all of our functions
    in another  `.cpp` file, and then simply add another `#include...` directive in
    our main `.cpp` file. In this way we can use any number of functions without adding
    any of their code (prototype or definition) to our main code file.
  prefs: []
  type: TYPE_NORMAL
- en: Function gotcha!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another point that we should discuss about functions is **scope**. If we declare
    a variable in a function, either directly or as one of the parameters, then that
    variable is not usable/visible outside the function. Furthermore, any variables
    declared outside the function cannot be seen/used inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: The way we should share values between function code and calling code is through
    the parameters/arguments and the return value.
  prefs: []
  type: TYPE_NORMAL
- en: When a variable is not available, because it is from another function, it is
    said to be out of scope. When it is available and usable, it is said to be in
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Actually, variables declared within any block in C++, are only in scope within
    that block! This includes loops and `if` blocks as well. A variable declared at
    the top of `main` is in scope anywhere in `main`. A variable declared in the game
    loop is only in scope within the game loop, and so on. A variable declared within
    a function or other block is called a **local** variable. The more code we write,
    the more this will make sense. Every time we come across an issue in our code
    regarding scope, I will discuss it to make things clear. There will be one such
    issue coming up in the next section. And there are some more C++ staples that
    blow this issue wide open. They are called **references** and **pointers** and
    we will learn about them in [Chapter 7](ch07.html "Chapter 7. C++ References,
    Sprite Sheets, and Vertex Arrays"): C++ *References, Sprite Sheets, and Vertex
    Arrays*and [Chapter 8](ch08.html "Chapter 8. Pointers, the Standard Template Library,
    and Texture Management"): *Pointers,the Standard Template Library, and Texture
    Management*, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Final word on functions - for now
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a lot more we could learn about functions but we know enough about
    them already to implement the next part of our game. And don't worry if all the
    technical terms such as parameters, signatures and definitions, and so on have
    not completely sunk in. The concepts will become clearer when we start to use
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Absolute final word on functions - for now
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It has probably not escaped your attention that we have been calling functions,
    especially SFML functions, by appending the name of an object, a period before
    the function name, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: And yet, our entire discussion of functions saw us calling functions without
    any objects. We can write functions as part of a class or simply as a standalone
    function. When we write a function as part of a class, we need an object of that
    class to call the function, and when we have a standalone function we don't.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write a standalone function in a minute and we will write classes with
    functions starting in [Chapter 6](ch06.html "Chapter 6.  Object-Oriented Programming,
    Classes, and SFML Views"): *Object-Oriented Programming, Classes, and SFML Views*.
    Everything we know so far about functions is relevant in both cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Growing the branches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, as I have been promising for around the last seventeen pages, we will
    use all the new C++ techniques to draw and move some branches on our tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code outside the `main` function. Just to be absolutely clear, I mean
    before the code `int main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We just achieved quite a few things with that new code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we wrote a function prototype for a function called `updateBranches`.
    We can see that it does not return a value (`void`) and it takes an `int` argument
    called `seed`. We will write the function definition soon and we will then see
    exactly what it does.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we declare a constant `int` called `NUM_BRANCHES` and initialize it to
    `6`. There will be six moving branches on the tree and we will soon see how `NUM_BRANCHES`
    will be useful to us.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following this, we declare an array of `Sprite` objects called `branches` that
    can hold six Sprites.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, we declare a new enumeration called `side` with three possible values,
    `LEFT`, `RIGHT`, and `NONE`. This will be used to describe the position of individual
    branches as well as the player, in a few places throughout our code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, in the previous new code, we initialize an array of `side` types, with
    a size of `NUM_BRANCHES` (6). To be clear about what this achieves; we will have
    an array called `branchPositions` with six values in it. Each of these values
    is of the type `side`, which can be either, `LEFT`, `RIGHT`, or `NONE`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, what you really want to know is why the constant, the two arrays,
    and the enumeration were declared outside the `main` function. By declaring them
    above `main` they now have **global scope**. Or, describing it another way, the
    constant, the two arrays, and the enumeration have scope for the entire game.
    This will mean we can access and use them all anywhere in the `main` function
    and in the `updateBranches` function. Note that it is good practice to make all
    variables as local to where they are actually used as possible. It might seem
    useful to make everything global but this leads to hard-to-read and error-prone
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the branches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we will prepare our six `Sprite` objects and load them into the `branches`
    array. Add the highlighted code just before our game loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The previous code does not use any new concepts. First we declare an SFML `Texture`
    object and load the `branch.png` graphic into it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a `for` loop, which sets `i` to zero and increments `i` by one
    each pass through the loop until `i` is no longer less than `NUM_BRANCHES`. This
    is exactly right because `NUM_BRANCHES` is 6 and the `branches` array has positions
    0 through 5.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `for` loop we set the `Texture` for each `Sprite` in the `branches`
    array with `setTexture` and then hide it off screen with `setPosition`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set the origin (the point which is located when it is drawn), with
    `setOrigin`, to the center of the sprite. Soon, we will be rotating these sprites
    and having the origin in the center means they will spin nicely around, without
    moving the sprite out of position.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the branch sprites each frame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this next code we set the position of all the sprites in the `branches`
    array, based upon their position in the array and the value of `side` in the corresponding
    `branchPositions` array. Add the highlighted code and try to understand it, then
    we can go through it in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The code we just added is one big `for` loop that sets `i` to zero, increments
    `i` by 1 each time through the loop, and keeps going until `i` is no longer less
    than 6.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `for` loop a new `float` variable called `height` is set to `i *
    150`. This means that the first branch will have a height of 0, the second of
    150, and the sixth of 750.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we have a structure of `if` and `else` blocks. Look at the structure with
    the code stripped out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The first `if` uses the `branchPositions` array to see whether the current branch
    should be on the left. If it is, it sets the corresponding `Sprite` from the `branches`
    array to a position on the screen, appropriate for the left (610 pixels) and whatever
    the current `height` is. It then flips the sprite by `180` degrees because the
    `branch.png` graphic hangs to the right by default.
  prefs: []
  type: TYPE_NORMAL
- en: The `else if` only executes if the branch is not on the left. It uses the same
    method to see if it is on the right. If it is then the branch is drawn on the
    right (`1330` pixels). Then the sprite rotation is set to 0 degrees, just in case
    it had previously been at `180` degrees. If the x coordinate seems a little bit
    strange, just remember that we set the origin for the branch sprites to their
    center.
  prefs: []
  type: TYPE_NORMAL
- en: The final `else` assumes, correctly, that the current `branchPosition` must
    be `NONE` and hides the branch off screen at `3000` pixels.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, our branches are in position, ready to be drawn.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the branches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we use another `for` loop, to step through the entire `branches` array
    from 0 to 5 and draw each branch sprite. Add the following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Of course we still haven't written the function that actually moves all the
    branches. Once we have written that function, we will also need to work out when
    and how to call it. Let's solve the first problem and write the function.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the branches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already added the function prototype above the `main` function. Now
    we code the actual definition of the function that will move all the branches
    down by one position each time it is called. We will code this function in two
    parts so we can more easily examine what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the first part of the `updateBranches` function after the closing curly
    brace of the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In this first part of the function, we simply move all the branches down one
    position, one at a time, starting with the sixth branch. This is achieved by making
    the `for` loop count from 5 through to 0\. The code `branchPositions[j] = branchPositions[j
    - 1];` makes the actual move.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing to note, with the previous code, is that, after we have moved
    the branch in position 4 to position 5, then the branch in position 3 to position
    4, and so on, we will need to add a new branch at position 0, which is the top
    of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can spawn a new branch at the top of the tree. Add the highlighted code
    and then we will talk about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In the final part of the `updateBranches` function, we use the integer `seed`
    variable that gets passed in with the function call. We do this to guarantee that
    the random number `seed` is always different and we will see how this value is
    arrived at in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we generate a random number between zero and four and store the result
    in the `int` variable `r`. Now we `switch` using `r` as the expression.
  prefs: []
  type: TYPE_NORMAL
- en: The `case` statements mean that, if `r` is equal to zero then we add a new branch
    on the left-hand side at the top of the tree. If `r` is equal to 1 then the branch
    goes on the right. If `r` is anything else, (2, 3, or 4) then the `default` ensures
    that no branch will be added at the top. This balance of left, right, and none
    makes the tree seem realistic and the game works quite well. You could easily
    change the code to make the branches more frequent or less so.
  prefs: []
  type: TYPE_NORMAL
- en: Even after all this code for our branches, we still can't glimpse a single one
    of them in the game. This is because we have more work to do before we can actually
    call `updateBranches`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you really want see a branch now, you can add some temporary code and call
    the function five times with a unique seed each time, just before the game loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You can now see the branches in their place. But if the branches are to actually
    move we will need to call `updateBranches` on a regular basis.
  prefs: []
  type: TYPE_NORMAL
- en: '![Moving the branches](img/image_04_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget to remove the temporary code before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can turn our attention to the player and call the `updateBranches` function
    for real.
  prefs: []
  type: TYPE_NORMAL
- en: FAQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q) You mentioned there were a few types of C++ loop.
  prefs: []
  type: TYPE_NORMAL
- en: "A) Yes, take a look at this tutorial and explanation for `doâ\x80¦while` loops:"
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.tutorialspoint.com/cplusplus/cpp_do_while_loop.htm](http://www.tutorialspoint.com/cplusplus/cpp_do_while_loop.htm)'
  prefs: []
  type: TYPE_NORMAL
- en: Q) Can I assume I am an expert on arrays?
  prefs: []
  type: TYPE_NORMAL
- en: A) As with many topics in this book there is always more to learn. You know
    enough about arrays to proceed, but if you're hungry for more take a look at this
    fuller array tutorial:[http://www.cplusplus.com/doc/tutorial/arrays/](http://www.cplusplus.com/doc/tutorial/arrays/).
  prefs: []
  type: TYPE_NORMAL
- en: Q) Can I assume I am an expert on functions?
  prefs: []
  type: TYPE_NORMAL
- en: A) As with many topics in this book there is always more to learn. You know
    enough about functions to proceed but if want to know even more, take a look at
    this tutorial:[http://www.cplusplus.com/doc/tutorial/functions/](http://www.cplusplus.com/doc/tutorial/functions/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although this wasn't the longest chapter it was probably the chapter where we
    covered the most C++. We looked at the different types of loop we can use, such
    as `for` and `while` loops. We studied arrays for handling large amounts of variables
    and objects without breaking a sweat. We also learnt about enumerations and `switch`.
    Probably the biggest concept in this chapter, was functions that allow us to organize
    and abstract our game's code. We will be looking more deeply at functions in a
    few more places as the book continues.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a fully working tree, we can finish the game off in the last
    chapter for this project.
  prefs: []
  type: TYPE_NORMAL
