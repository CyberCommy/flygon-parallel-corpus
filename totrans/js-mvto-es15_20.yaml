- en: Chapter 7. Reactive Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I once read a book that suggested that Newton came up with the idea for calculus
    when he was observing the flow of a river around a reed. I've never been able
    to find any other source which supports that assertion. It is, however, a nice
    picture to hold in your mind. Calculus deals with understanding how the state
    of a system changes over time. Most developers will rarely have to deal with calculus
    in their day to day work. They will, however, have to deal with systems changing.
    After all, having a system which doesn't change at all is pretty boring.
  prefs: []
  type: TYPE_NORMAL
- en: Over the last few years a number of different ideas have arisen in the area
    of treating change as a stream of events – just like the stream that Newton supposedly
    observed. Given a starting position and a stream of events it should be possible
    to figure out the state of the system. Indeed, this is the idea behind using an
    event store. Instead of keeping the final state of an aggregate in a database
    we instead keep track of all the events which have been applied to that aggregate.
    By replaying this series of events we can recreate the current state of the aggregate.
    This seems like a roundabout way of storing the state of an object but it is actually
    very useful for a number of situations. For example, a disconnected system, like
    a cell phone application when the phone isn't connected to the network, which
    uses an event store can be merged with other events much more easily than simply
    keeping the end state. It is also stunningly useful for audit scenarios as it
    is possible to pull the system back to the state it was in at any point in time
    by simply halting the replay at a time index. How frequently have you been asked,
    "why is the system in this state?", and you've been unable to reply? With an event
    store the answer should be easy to ascertain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Application state changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merging streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streams for multiplexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application state changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within an application we can think of all the events happening as a similar
    stream of events. The user clicks on a button? Event. The user''s mouse enters
    some region? Event. A clock ticks? Event. In both front and backend applications,
    events are the things which trigger changes in state. You''re likely already using
    events for event listeners. Consider attaching a click handler to a button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this code we have attached a handler to the `click` event. This is fairly
    simple code but think about how rapidly the complexity of this code increases
    when we add conditions like "ignore additional click for 500ms once a click is
    fired to prevent people double-clicking" and "Fire a different event if the *Ctrl*
    key is being held when the button is clicked". Reactive programming or functional
    reactive programming provides a simple solution to these complex interaction scenarios
    through use of streams. Let's explore how your code can benefit from leveraging
    reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest way to think of an event stream is not to think of the streams
    you''ve probably used before in programming, input reader streams, but to think
    of arrays. Let''s say that you have an array with a series of numbers in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you want to filter this array to only show you even numbers. In modern
    JavaScript this is easily done through the use of the `filter` function on the
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A graphical representation can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Streams](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The filtering function here remains the same should we have ten items in the
    array or ten thousand items in the array. Now, what if the source array had new
    items being appended to it all the time? We would like to keep our dependent array
    up-to-date by inserting any new items which are even, into it. To do this we could
    hook into the `add` function on the array using a pattern-like decorator. Using
    a decorator we could call the filter method and, if a match was found, we would
    add it to the filtered array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Streams are, in effect, an observable on a collection of future events. There
    are a number of interesting problems which can be solved using operations on streams.
    Let''s start with a simple problem: handling clicks. This problem is so simple
    that, on the surface, it doesn''t seem like there is any advantage to using streams.
    Don''t worry we''ll make it more difficult as we go along.'
  prefs: []
  type: TYPE_NORMAL
- en: For the most part this module avoids making use of any specific JavaScript libraries.
    The idea is that patterns should be able to be implemented with ease without a
    great deal of ceremony. However, in this case we're actually going to make use
    of a library because streams have a few nuances to their implementation for which
    we'd like some syntactic niceties. If you're looking to see how to implement a
    basic stream, then you can base it on the observer pattern outlined in [Chapter
    5](part0111_split_000.html#39REE1-015e68c68a464f18a9559f448be84435 "Chapter 5. Behavioral
    Patterns"), *Behavioral Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of stream libraries in JavaScript Reactive.js, Bacon.js,
    and RxJS to name a few. Each one has various advantages and disadvantages but
    the specifics are outside the purview of this module. In this module we'll make
    use of Reactive Extensions for JavaScript, the source code for which can be found
    on GitHub at [https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a brief piece of HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To this, let''s add a quick click counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see we''re creating a new stream of events from the `click` event
    on the button. The newly created stream is commonly referred to as a metastream.
    Whenever an event is emitted from the source stream it is automatically manipulated
    and published, as needed, to the metastream. We subscribe to this stream and increment
    a counter. If we wanted to react to only the even numbered events, we could do
    so by subscribing a second function to the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here you can see that we're applying a filter to the stream such that the counter
    is distinct from the function which updates the screen. Keeping a counter outside
    of the streams like this feels dirty, though, doesn't it? Chances are that incrementing
    every other click isn't the goal of this function anyway. It is much more likely
    that we would like to run a function only on double click.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is difficult to do with traditional methods, however these sorts of complex
    interactions are easy to achieve using streams. You can see how we might approach
    the problem in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we take the click stream and buffer the stream using a debounce to generate
    the boundaries of the buffer. Debouncing is a term from the hardware world which
    means that we clean up a noisy signal into a single event. When a physical button
    is pushed, there are often a couple of additional high or low signals instead
    of the single point signal we would like. In effect we eliminate repeated signals
    which occur within a window. In this case we wait `250`ms before firing an event
    to move to a new buffer. The buffer contains all the events fired during the debouncing
    and passes on a list of them to the next function in the chain. The map function
    generates a new stream with the list length as the contents. Next, we filter the
    stream to show only events with a value of 2 or more, that''s two clicks or more.
    The stream of events look like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Streams](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Performing the same logic as this using traditional event listeners and call-backs
    would be quite difficult. One could easily imagine a far more complex workflow
    that would spiral out of control. FRP allows for a more streamlined approach to
    handling events.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the preceding section, it is possible to filter a stream of events
    and, from it produce a new stream of events. You might be familiar with being
    able to filter items in an array. ES5 introduced a number of new operators for
    arrays such as **filter** and **some**. The first of these produces a new array
    containing only elements which match the rule in the filter. `Some` is a similar
    function which simply returns `true` if any element of the array matches. These
    same sorts of functions are also supported on streams as well as functions you
    might be familiar with from functional languages such as First and Last. In addition
    to the functions which would make sense for arrays, there are a number of time
    series based functions which make much more sense when you consider that streams
    exist in time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already seen debounce which is an example of a time based filter. Another
    very simple application of debounce is to prevent the annoying bug of users double-clicking
    a submit button. Consider how much simpler the code for that is using a stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You might also find it that functions like Sample – which generates a set of
    events from a time window. This is a very handy function when we're dealing with
    observables which may produce a large number of events. Consider an example from
    our example world of Westeros.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, Westeros is quite a violent place where people seem to die in
    unpleasant ways. So many people die that we can't possibly keep an eye on each
    one so we'd like to just sample the data and gather a few causes of death.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simulate this incoming stream, we will start with an array, something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can see we're using an array to simulate a stream of events. This can be
    done with any stream and is a remarkably easy way to perform testing on complex
    code. You can build a stream of events in an array and then publish them with
    appropriate delays giving an accurate representation of anything from a stream
    of events from the filesystem to user interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to make our array into a stream of events. Fortunately, there are
    some shortcuts for doing that using the `from` method. This will simply return
    a stream which is immediately executed. What we''d like is to pretend we have
    a regularly distributed stream of events or, in our rather morbid case, deaths.
    This can be done by using two methods from RxJS: `interval` and `zip`. `interval`
    creates a stream of events at a regular interval. `zip` matches up pairs of events
    from two streams. Together these two methods will emit a new stream of events
    at a regular interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this code we zip together the deaths array with an interval stream which
    fires every `500`ms. Because we're not super interested in the interval event
    we simply discard it and project the item from the array onwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can sample this stream by simply taking a sample and then subscribing
    to it. Here we''re sampling every `1500`ms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can have as many subscribers to a stream as you like so if you wanted to
    perform some sampling, as well as perhaps some aggregate functions like simply
    counting the events, you could do so by having several subscribers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Merging streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already seen the `zip` function that merges events one-to-one to create
    a new stream but there are numerous other ways of combining streams. A very simple
    example might be a page which has several code paths which all want to perform
    a similar action. Perhaps we have several actions all of which result in a status
    message being updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see how the various streams are passed into the merge function
    and the resulting merged stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Merging streams](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: While useful, this code doesn't seem to be particularly better than simply calling
    the event handler directly, in fact it is longer than necessary. However, consider
    that there are more sources of status messages than just button pushes. We might
    want to have asynchronous events also write out information. For instance, sending
    a request to the server might also want to add status information. Another fantastic
    application may be with web workers which run in the background and communicate
    with the main thread using messaging. For web based JavaScript applications this
    is how we implement multithreaded applications. Let's see how that would look.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we can create a stream from a worker role. In our example the worker
    simply calculates the fibonacci sequence. We''ve added a fourth button to our
    page and have it trigger the worker process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can subscribe to the merged stream and combine it with all the previous
    streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This all looks really nice but we don''t want to clobber the users with dozens
    of notifications at a time. We can throttle the stream of events so that only
    a single toast shows up at a time by using the same interval zip pattern we saw
    earlier. In this code we''ve replaced our `appendToOutput` method with a call
    to a toast display library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see the code for this functionality is short and easy to understand
    yet it contains a great deal of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Streams for multiplexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One does not rise to a position of power on the King''s council in Westeros
    without being a master at building networks of spies. Often the best spy is one
    who can respond the quickest. Similarly, we may have some code which has the option
    of calling one of many different services which can fulfill the same task. A great
    example would be a credit card processor: it doesn''t really matter which processor
    we use as they''re pretty much all the same.'
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we can kick off a number of HTTP requests to each of the services.
    If we take each of the requests and put them into a stream, we can use it to select
    the fastest to respond processor and then perform the rest of the actions using
    that processor.
  prefs: []
  type: TYPE_NORMAL
- en: 'With RxJS this looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You could even include a timeout in the `amb` call which would be called to
    handle the eventuality that none of the processors responded in time.
  prefs: []
  type: TYPE_NORMAL
- en: Hints and tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a large number of different functions that can be applied to streams.
    If you happen to decide on the RxJS library for your FRP needs in JavaScript,
    many of the most common functions have been implemented for you. More complex
    functions can often be written as a chain of the included functions so try to
    think of a way to create the functionality you want by chaining before writing
    your own functions.
  prefs: []
  type: TYPE_NORMAL
- en: Frequently, asynchronous calls across the network in JavaScript fail. Networks
    are unreliable, mobile networks doubly so. For the most part when the network
    fails, our application fails. Streams provide an easy fix to this by allowing
    you to easily retry failed subscriptions. In RxJS this method is called `Retry`.
    Slotting it into any observable chain makes it more resilient to network failures.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional reactive programming has many uses in different applications both
    on the server and on the client. On the client side it can be used to wrangle
    a large number of events together into a data flow enabling complex interactions.
    It can also be used for the simplest of things such as preventing a user from
    double-clicking a button. There is no huge cost to simply using streams for all
    of your data changes. They are highly testable and have a minimal impact on performance.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the nicest thing about FRP is that it raises the level of abstraction.
    You have to deal with less finicky process flow code and can, instead, focus on
    the logical flow of the application.
  prefs: []
  type: TYPE_NORMAL
