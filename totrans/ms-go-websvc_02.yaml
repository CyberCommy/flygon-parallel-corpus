- en: Chapter 2. RESTful Services in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When people typically design APIs and web services, they're making them as an
    afterthought or at least as the final step in a large-scale application.
  prefs: []
  type: TYPE_NORMAL
- en: There's good logic behind this—the application comes first and catering to developers
    when there's no product on the table doesn't make a lot of sense. So, typically
    when an application or website is created, that's the core product and any additional
    resources for APIs come second to it.
  prefs: []
  type: TYPE_NORMAL
- en: As the Web has changed in recent years, this system has changed a little bit.
    Now, it's not entirely uncommon to write the API or web service first and then
    the application. Most often, this happens with highly responsive, single-page
    applications or mobile applications where the structure and data are more important
    than the presentation layer.
  prefs: []
  type: TYPE_NORMAL
- en: Our overarching project—a social network—will demonstrate the nature of a data-and-architecture-first
    application. We'll have a functional social network that can be traversed and
    manipulated exclusively at API endpoints. However, later in this book, we will
    have some fun with a presentation layer.
  prefs: []
  type: TYPE_NORMAL
- en: While the concept behind this could be viewed as entirely demonstrative, the
    reality is that this method is behind a lot of emerging services and applications
    today. It's extremely common for a new site or service to launch with an API,
    and sometimes with nothing but an API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will examine the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Strategies for designing an API for our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other web service architectures and methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding data and choosing data formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST actions and what they do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating endpoints with Gorilla's mux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Approaches to versioning your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we set out to build our larger social network application, we have a general
    idea about our datasets and relationships. When we extend these to a web service,
    we have to translate not just data types to API endpoints, but relationships and
    actions as well.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we wish to find a user, we'll assume that the data is kept in
    a database called `users` and we'd expect to be able to retrieve that data using
    the `/api/users` endpoint. This is fair enough. But, what if we wish to get a
    specific user? What if we wish to see if two users are connected? What if we wish
    to edit a user's comment on another user's photo?, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: These are the things that we should consider, not just in our application but
    also in the web services that we build around it (or in this case, the other way
    around, as our web services comes first).
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have a relatively simplistic dataset for our application,
    so let's flush it out in such a way that we can create, retrieve, update, and
    delete users as well as create, retrieve, update, and delete relationships between
    the users. We can think of this as *friending* or *following* someone on traditional
    social networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s do a little maintenance on our `users` table. Presently, we have
    a unique index on just the `user_nickname` variable, but let''s create an index
    for `user_email`. This is a pretty common and logical security point, considering
    that, theoretically, one person is bound to any one given e-mail address. Type
    the following into your MySQL console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can now only have one user per e-mail address. This makes sense, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s go ahead and create the basis for user relationships. These will
    encompass not just the friending/following concept but also the ability to block.
    So, let''s create a table for these relationships. Again, type the following code
    into your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What we've done here is created a table for all of our relationships that include
    keys on the various users as well as the timestamp field to tell us when the relationships
    were created.
  prefs: []
  type: TYPE_NORMAL
- en: So, where are we? Well, right now, we have the capability to create, retrieve,
    update, and delete both user information as well relationships between the users.
    Our next step would be to conceptualize some API endpoints that will allow consumers
    of our web service to do this.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we created our first endpoints, `/api/user/create`
    and /`api/user/read`. However, if we want to be able to fully control the data
    we just discussed, we'll need more than that.
  prefs: []
  type: TYPE_NORMAL
- en: Before that though, let's talk a little bit about the most important concepts
    that relate to web services, particularly those utilizing REST.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what is REST exactly, and where did it come from? To start with, REST stands
    for **Representational state transfer**. This is important because the representation
    of data (and its metadata) is the critical part of data transfer.
  prefs: []
  type: TYPE_NORMAL
- en: The **state** aspect of the acronym is slightly misleading because statelessness
    is actually a core component of the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In short, REST presents a simple, stateless mechanism for presenting data over
    HTTP (and some other protocols) that is uniform and includes a control mechanism
    such as caching directives.
  prefs: []
  type: TYPE_NORMAL
- en: The architecture initially arose as part of Roy Fielding's dissertation at UC
    Irvine. Since then, it has become codified and standardized by **World Wide Web
    Consortium** (**W3C**).
  prefs: []
  type: TYPE_NORMAL
- en: A RESTful application or API will require several important components, and
    we'll outline these now.
  prefs: []
  type: TYPE_NORMAL
- en: Making a representation in an API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important component of the API is the data we'll pass along as part
    of our web service. Usually, it's formatted text in the format of JSON, RSS/XML,
    or even binary data.
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of designing a web service, it's a good practice to make sure
    that your format matches your data. For example, if you've created a web service
    for passing image data, it's tempting to jam that sort of data into a text format.
    It's not unusual to see binary data translated into Base64 encoding and sent via
    JSON.
  prefs: []
  type: TYPE_NORMAL
- en: However, an important consideration with APIs is thrift, in terms of data size.
    If we take our earlier example and encode our image data in Base64, we end up
    with an API payload that will be nearly 40 percent larger. By doing this, we will
    increase latency in our service and introduce a potential annoyance. There is
    no reason to do this if we can reliably transfer the data as it exists.
  prefs: []
  type: TYPE_NORMAL
- en: The representation in the model should also serve an important role—to satisfy
    all requirements for the client to update, remove, or retrieve such a particular
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: Self-description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we say self-description, we can also describe this as self-contained to
    encompass two core components of REST—that a response should include everything
    necessary for the client per request and that it should include (either explicitly
    or implicitly) the information on how to handle the information.
  prefs: []
  type: TYPE_NORMAL
- en: The second part refers to cache rules, which we very briefly touched on in [Chapter
    1](ch01.html "Chapter 1. Our First API in Go"), *Our First API in Go*.
  prefs: []
  type: TYPE_NORMAL
- en: It may go without saying but providing valuable caching information about a
    resource contained by an API request is important. It eliminates redundant or
    unnecessary requests down the road.
  prefs: []
  type: TYPE_NORMAL
- en: This also brings in the concept of the stateless nature of REST. By this we
    mean that each request exists on its own. As mentioned earlier, any single request
    should include everything necessary to satisfy that request.
  prefs: []
  type: TYPE_NORMAL
- en: More than anything, this means dropping the idea of a normal web architecture
    where you can set cookies or session variables. This is inherently not RESTful.
    For one, it's unlikely that our clients would support cookies or continuous sessions.
    But more importantly, it reduces the comprehensive and explicit nature of responses
    expected from any given API endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Automated processes and scripts can, of course, handle sessions and they could
    handle them as the initial proposal of REST. This is more a matter of demonstration
    than a reason why REST rejects a persistent state as part of its ethos.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of a URI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For reasons that we''ll touch on later in this chapter, the URI or URL is one
    of the most critical factors in a good API design. There are several reasons for
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: The URI should be informative. We should have information on not just the data
    endpoints but also on what data we might expect to see in return. Some of this
    is idiomatic to programmers. For example, `/api/users` would imply that we're
    looking for a set of users, whereas `/api/users/12345` would indicate that we're
    expecting to get information about a specific user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The URI should not break in the future. Soon, we'll talk about versioning, but
    this is just one place where the expectation of a stable resource endpoint is
    incredibly important. If the consumers of your service find missing or broken
    links in their applications over time without warning, this would result in a
    very poor user experience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No matter how much foresight you have in developing your API or web service,
    things will change. With this in mind, we should react to changes by utilizing
    HTTP status codes to indicate new locations or errors with present URIs rather
    than allowing them to simply break.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HATEOAS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**HATEOAS** stands for **Hypermedia as the Engine of Application State**, and
    it''s a primary constraint of URIs in a REST architecture. The core principles
    behind it require that APIs should not reference fixed resource names or the actual
    hierarchies themselves, but they should rather focus on describing the media requested
    and/or define the application state.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about REST and its requirements as defined by its original
    author by visiting Roy Fielding's blog at [http://roy.gbiv.com/untangled/](http://roy.gbiv.com/untangled/).
  prefs: []
  type: TYPE_NORMAL
- en: Other API architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beyond REST, we'll look at and implement a few other common architectures for
    APIs and web services in this book.
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, we'll focus on REST APIs but we will also go into SOAP protocols
    and APIs for XML ingestion as well as newer asynchronous and web socket based
    services that allow persistence.
  prefs: []
  type: TYPE_NORMAL
- en: RPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Remote procedure calls,** or **RPC,** is a communication method that has
    existed for a long time and makes up the bones of what later became REST. While
    there is some merit for using RPC still—in particular JSON-RPC—we''re not going
    to put much effort into accommodating it in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: If you're unfamiliar with RPC in general, its core difference as compared to
    REST is that there is a single endpoint and the requests themselves define the
    behaviors of the web service.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To read more about JSON-RPC, go to [http://json-rpc.org/](http://json-rpc.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Choosing formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The matter of formats used to be a much trickier subject than it is today. Where
    we once had myriad formats that were specific to individual languages and developers,
    the API world has caused this breadth of formats to shrink a bit.
  prefs: []
  type: TYPE_NORMAL
- en: The rise of Node and JavaScript as a lingua franca among data transmission formats
    has allowed most APIs to think of JSON first. JSON is a relatively tight format
    that has support in almost every major language now, and Go is no exception.
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a quick and simple example of how simply Go can send and receive
    JSON data using the core packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: One thing to note here are the JSON representations of our variables in the
    `User` struct. Anytime you see data within the grave accent ([PRE3]
  prefs: []
  type: TYPE_NORMAL
- en: type User struct {
  prefs: []
  type: TYPE_NORMAL
- en: Name string `xml:"name"`
  prefs: []
  type: TYPE_NORMAL
- en: Email string `xml:"email"`
  prefs: []
  type: TYPE_NORMAL
- en: ID int `xml:"id"`
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: ourUser := User{}
  prefs: []
  type: TYPE_NORMAL
- en: ourUser.Name = "Bill Smith"
  prefs: []
  type: TYPE_NORMAL
- en: ourUser.Email = "bill.smith@example.com"
  prefs: []
  type: TYPE_NORMAL
- en: ourUser.ID = 100
  prefs: []
  type: TYPE_NORMAL
- en: output,_ := xml.Marshal(&ourUser)
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Fprintln(w, string(output))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: '"fmt"'
  prefs: []
  type: TYPE_NORMAL
- en: '"net/http"'
  prefs: []
  type: TYPE_NORMAL
- en: '"launchpad.net/goyaml"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: type User struct {
  prefs: []
  type: TYPE_NORMAL
- en: Name string
  prefs: []
  type: TYPE_NORMAL
- en: Email string
  prefs: []
  type: TYPE_NORMAL
- en: ID int
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func userRouter(w http.ResponseWriter, r *http.Request) {
  prefs: []
  type: TYPE_NORMAL
- en: ourUser := User{}
  prefs: []
  type: TYPE_NORMAL
- en: ourUser.Name = "Bill Smith"
  prefs: []
  type: TYPE_NORMAL
- en: ourUser.Email = "bill.smith@example.com"
  prefs: []
  type: TYPE_NORMAL
- en: ourUser.ID = 100
  prefs: []
  type: TYPE_NORMAL
- en: output,_ := goyaml.Marshal(&ourUser)
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Fprintln(w, string(output))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("Starting YAML server")
  prefs: []
  type: TYPE_NORMAL
- en: http.HandleFunc("/user", userRouter)
  prefs: []
  type: TYPE_NORMAL
- en: http.ListenAndServe(":8080",nil)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: routes := mux.NewRouter()
  prefs: []
  type: TYPE_NORMAL
- en: routes.HandleFunc("/api/users", UserCreate).Methods("POST")
  prefs: []
  type: TYPE_NORMAL
- en: routes.HandleFunc("/api/users", UsersRetrieve).Methods("GET")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import (
  prefs: []
  type: TYPE_NORMAL
- en: '"database/sql"'
  prefs: []
  type: TYPE_NORMAL
- en: '"encoding/json"'
  prefs: []
  type: TYPE_NORMAL
- en: '"fmt"'
  prefs: []
  type: TYPE_NORMAL
- en: _ "github.com/go-sql-driver/mysql"
  prefs: []
  type: TYPE_NORMAL
- en: '"github.com/gorilla/mux"'
  prefs: []
  type: TYPE_NORMAL
- en: '"net/http"'
  prefs: []
  type: TYPE_NORMAL
- en: '"log"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: var database *sql.DB
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: type Users struct {
  prefs: []
  type: TYPE_NORMAL
- en: Users []User `json:"users"`
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: type User struct {
  prefs: []
  type: TYPE_NORMAL
- en: ID int "json:id"
  prefs: []
  type: TYPE_NORMAL
- en: Name  string "json:username"
  prefs: []
  type: TYPE_NORMAL
- en: Email string "json:email"
  prefs: []
  type: TYPE_NORMAL
- en: First string "json:first"
  prefs: []
  type: TYPE_NORMAL
- en: Last  string "json:last"
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func UserCreate(w http.ResponseWriter, r *http.Request) {
  prefs: []
  type: TYPE_NORMAL
- en: NewUser := User{}
  prefs: []
  type: TYPE_NORMAL
- en: NewUser.Name = r.FormValue("user")
  prefs: []
  type: TYPE_NORMAL
- en: NewUser.Email = r.FormValue("email")
  prefs: []
  type: TYPE_NORMAL
- en: NewUser.First = r.FormValue("first")
  prefs: []
  type: TYPE_NORMAL
- en: NewUser.Last = r.FormValue("last")
  prefs: []
  type: TYPE_NORMAL
- en: output, err := json.Marshal(NewUser)
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(string(output))
  prefs: []
  type: TYPE_NORMAL
- en: if err != nil {
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("Something went wrong!")
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: sql := "INSERT INTO users set user_nickname='" + NewUser.Name + "', user_first='"
    + NewUser.First + "', user_last='" + NewUser.Last + "', user_email='" + NewUser.Email
    + "'"
  prefs: []
  type: TYPE_NORMAL
- en: q, err := database.Exec(sql)
  prefs: []
  type: TYPE_NORMAL
- en: if err != nil {
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(err)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(q)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: func UsersRetrieve(w http.ResponseWriter, r *http.Request) {
  prefs: []
  type: TYPE_NORMAL
- en: w.Header().Set("Pragma","no-cache")
  prefs: []
  type: TYPE_NORMAL
- en: rows,_ := database.Query("select * from users LIMIT 10")
  prefs: []
  type: TYPE_NORMAL
- en: "Response \t:= Users{}"
  prefs: []
  type: TYPE_NORMAL
- en: for rows.Next() {
  prefs: []
  type: TYPE_NORMAL
- en: user := User{}
  prefs: []
  type: TYPE_NORMAL
- en: rows.Scan(&user.ID, &user.Name, &user.First, &user.Last, &user.Email )
  prefs: []
  type: TYPE_NORMAL
- en: Response.Users = append(Response.Users, user)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: output,_ := json.Marshal(Response)
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Fprintln(w,string(output))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: db, err := sql.Open("mysql", "root@/social_network")
  prefs: []
  type: TYPE_NORMAL
- en: if err != nil {
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: database = db
  prefs: []
  type: TYPE_NORMAL
- en: routes := mux.NewRouter()
  prefs: []
  type: TYPE_NORMAL
- en: routes.HandleFunc("/api/users", UserCreate).Methods("POST")
  prefs: []
  type: TYPE_NORMAL
- en: routes.HandleFunc("/api/users", UsersRetrieve).Methods("GET")
  prefs: []
  type: TYPE_NORMAL
- en: http.Handle("/", routes)
  prefs: []
  type: TYPE_NORMAL
- en: http.ListenAndServe(":8080", nil)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '{ "payload": [ "item","item 2"], "next": "http://yourdomain.com/api/users?page=2"
    }'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: func UsersRetrieve(w http.ResponseWriter, r *http.Request) {
  prefs: []
  type: TYPE_NORMAL
- en: log.Println("starting retrieval")
  prefs: []
  type: TYPE_NORMAL
- en: start := 0
  prefs: []
  type: TYPE_NORMAL
- en: limit := 10
  prefs: []
  type: TYPE_NORMAL
- en: next := start + limit
  prefs: []
  type: TYPE_NORMAL
- en: w.Header().Set("Pragma","no-cache")
  prefs: []
  type: TYPE_NORMAL
- en: w.Header().Set("Link","<http://localhost:8080/api/users?start="+string(next)+";
    rel=\"next\"")
  prefs: []
  type: TYPE_NORMAL
- en: rows,_ := database.Query("select * from users LIMIT 10")
  prefs: []
  type: TYPE_NORMAL
- en: Response := Users{}
  prefs: []
  type: TYPE_NORMAL
- en: for rows.Next() {
  prefs: []
  type: TYPE_NORMAL
- en: user := User{}
  prefs: []
  type: TYPE_NORMAL
- en: rows.Scan(&user.ID, &user.Name, &user.First, &user.Last, &user.Email )
  prefs: []
  type: TYPE_NORMAL
- en: Response.Users = append(Response.Users, user)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: output,_ := json.Marshal(Response)
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Fprintln(w,string(output))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This tells the client where to go for further pagination. As we modify this
    code further, we'll include forward and backward pagination and respond to user
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you should be well-versed not only with the basic ideas of creating
    an API web service in REST and a few other protocols, but also in the guiding
    principles of the formats and protocols.
  prefs: []
  type: TYPE_NORMAL
- en: We dabbled in a few things in this chapter that we'll explore in more depth
    over the next few chapters, particularly MVC with the various template implementations
    in the Go language itself.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll build the rest of our initial endpoints and explore
    more advanced routing and URL muxing.
  prefs: []
  type: TYPE_NORMAL
