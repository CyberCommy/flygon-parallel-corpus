- en: Chapter 3. Building UI with XAML
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。使用XAML构建UI
- en: User interface and user experience play an important role with Windows 8 Store
    apps. A new design has been created for Store apps, now called modern design style
    (formerly known as Metro), with keywords such as "fast and fluid", "content first",
    and "touch centric". The app UI takes up the entire screen (except when in snap
    view), which makes the UI all the more important. In this chapter (and the next
    one), we'll discuss the way in which UI for Store apps is built, more on the technical
    level than on the actual design. Microsoft makes a lot of resources available
    online for the design part of the UI.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面和用户体验在Windows 8 Store应用程序中扮演着重要的角色。为Store应用程序创建了一种新的设计，现在称为现代设计风格（以前称为Metro），其中关键词包括“快速流畅”、“内容优先”和“触摸为中心”。应用程序UI占据整个屏幕（除了在快照视图中），这使得UI变得更加重要。在本章（和下一章）中，我们将讨论为Store应用程序构建UI的方式，更多地是在技术层面上而不是在实际设计上。微软在线提供了大量设计UI的资源。
- en: XAML
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XAML
- en: C++ Store applications typically use **eXtensible Application Markup Language**
    (**XAML**) as the main language for creating the user interface. The first question
    that comes to mind when XAML is first mentioned, is why? What's wrong with C++,
    or any other existing programming language?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: C++ Store应用程序通常使用**可扩展应用程序标记语言**（**XAML**）作为创建用户界面的主要语言。当首次提到XAML时，首先想到的问题是为什么？C++或任何其他现有的编程语言有什么问题吗？
- en: 'XAML is an XML-based language that describes the what, not the how; it''s declarative
    and neutral. Technically, a complete app can be written without any XAML; there''s
    nothing XAML can do that C++ can''t. Here are some reasons why XAML makes sense
    (or at least may make sense in a little bit):'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: XAML是一种基于XML的语言，描述了“什么”，而不是“如何”；它是声明性的和中立的。从技术上讲，完整的应用程序可以在没有任何XAML的情况下编写；没有XAML可以做的事情是C++做不到的。以下是XAML有意义的一些原因（或者至少可能有意义的一点）：
- en: C++ is very verbose as opposed to XAML. XAML is usually shorter than the equivalent
    C++ code.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与XAML相比，C++非常冗长。XAML通常比等效的C++代码更短。
- en: Since XAML is neutral, design-oriented tools can read and manipulate it. Microsoft
    provides the Expression Blend tool just for this purpose.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于XAML是中立的，面向设计的工具可以读取和操作它。微软专门提供了Expression Blend工具用于此目的。
- en: The declarative nature of XAML makes it easier (most of the time, after users
    get used to it) to build user interfaces, as these have a tree-like structure,
    just like XML.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XAML的声明性使得构建用户界面更容易（大多数情况下，用户习惯后），因为这些界面具有类似XML的树状结构。
- en: 'XAML itself has nothing to do with the user interface in itself. XAML is a
    way to create objects (usually an object tree) and set their properties. This
    works for any type that is "XAML friendly", meaning it should have the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: XAML本身与用户界面本身无关。XAML是一种创建对象（通常是对象树）并设置其属性的方法。这适用于任何“XAML友好”的类型，这意味着它应该具有以下特点：
- en: A default public constructor
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认的公共构造函数
- en: Settable public properties
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可设置的公共属性
- en: The second point is not a strict requirement, but without properties the object
    is pretty dull.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点不是严格要求，但是没有属性，对象就相当无聊。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: XAML was originally created for **Windows Presentation Foundation** (**WPF**),
    the main rich client technology in .NET. It's now leveraged in other technologies,
    mostly in the .NET space, such as Silverlight and **Windows Workflow Foundation**
    (**WF**).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: XAML最初是为**Windows Presentation Foundation**（**WPF**）创建的，这是.NET中的主要丰富客户端技术。现在它被其他技术所利用，主要是在.NET空间中，比如Silverlight和**Windows
    Workflow Foundation**（**WF**）。
- en: The XAML level currently implemented in WinRT is roughly equivalent to Silverlight
    3 XAML. In particular, it's not as powerful as WPF's XAML.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT中当前实现的XAML级别大致相当于Silverlight 3 XAML。特别是，它不像WPF的XAML那样强大。
- en: XAML basics
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XAML基础知识
- en: 'XAML has a few rules. Once we understand those rules, we can read and write
    any XAML. The most fundamental XAML rules are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: XAML有一些规则。一旦我们理解了这些规则，就可以阅读和编写任何XAML。最基本的XAML规则如下：
- en: An XML element means object creation
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML元素意味着对象创建
- en: An XML attribute means setting a property (or an event handler)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML属性意味着设置属性（或事件处理程序）
- en: 'With these two rules, the following markup means creating a `Button` object
    and setting its `Content` property to the string `Click me`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两条规则，下面的标记意味着创建一个`Button`对象，并将其`Content`属性设置为字符串`Click me`：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The equivalent C++ code would be as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 等效的C++代码如下：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When creating a new Blank App project, a `MainPage.xaml` file is created along
    with the header and implementation files. Here''s how that XAML file looks:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的空白应用程序项目时，会创建一个`MainPage.xaml`文件以及头文件和实现文件。以下是该XAML文件的外观：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It's worth going over these lines in detail. In this example, the project name
    is `BasicXaml` . The root element is `Page` and an `x:Class` attribute is set,
    indicating the class that inherits from `Page`, here named `BasicXaml::MainPage`.
    Note that the class name is the full name including namespace, where the separator
    must be a period (not the C++ scope resolution operator `::`). `x:Class` can only
    be placed on the root element.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 详细了解这些行是值得的。在这个例子中，项目名称是`BasicXaml`。根元素是`Page`，并设置了一个`x:Class`属性，指示从`Page`继承的类，这里命名为`BasicXaml::MainPage`。请注意，类名是包括命名空间的完整名称，其中分隔符必须是句点（而不是C++的作用域解析运算符`::`）。`x:Class`只能放在根元素上。
- en: What follows that root element is a bunch of XML namespace declarations. These
    give context to the elements used in the entire XAML of this page. The default
    XML namespace (without a name) indicates to the XAML parser that types such as
    `Page`, `Button`, and `Grid` can be written as they are, without any special prefix.
    This is the most common scenario, because most of the XAML in a page constitutes
    user interface elements.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 跟在根元素后面的是一堆XML命名空间声明。这些为页面整个XAML中使用的元素提供了上下文。默认的XML命名空间（没有名称）告诉XAML解析器，诸如`Page`、`Button`和`Grid`这样的类型可以直接写成它们自己，不需要任何特殊前缀。这是最常见的情况，因为页面中的大部分XAML都是用户界面元素。
- en: The next XML namespace prefix is `x` and it points to special instructions for
    the XAML parser. We have just seen `x:Class` in action. We'll meet other such
    attributes later in this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个XML命名空间前缀是`x`，它指向XAML解析器的特殊指令。我们刚刚看到`x:Class`的作用。我们将在本章的后面遇到其他类似的属性。
- en: 'Next up is a prefix named `local`, which points to the types declared in the
    `BasicXaml` namespace. This allows creating our own objects in XAML; the prefix
    of such types must be `local` so that the XAML parser understands where to look
    for such a type (of course, we can change that to anything we like). For example,
    suppose we create a user control derived type named `MyControl`. To create a `MyControl`
    instance in XAML, we could use the following markup:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个名为`local`的前缀，它指向在`BasicXaml`命名空间中声明的类型。这允许在XAML中创建我们自己的对象；这些类型的前缀必须是`local`，以便XAML解析器知道在哪里查找这样的类型（当然，我们可以将其更改为任何我们喜欢的东西）。例如，假设我们创建了一个名为`MyControl`的用户控件派生类型。要在XAML中创建一个`MyControl`实例，我们可以使用以下标记：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `d` prefix is used for designer-related attributes, mostly useful with Expression
    Blend. The `mc:ignorable` attribute states that the `d` prefix should be ignored
    by the XAML parser (because it's related to the way Blend works with the XAML).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`d`前缀用于与设计相关的属性，主要与Expression Blend一起使用。`mc:ignorable`属性说明`d`前缀应该被XAML解析器忽略（因为它与Blend与XAML的工作方式有关）。'
- en: The `Grid` element is hosted inside the `Page`, where "hosted" will become clear
    in a moment. Its `Background` property is set to `{StaticResource ApplicationPageBackgroundThemeBrush}`.
    This is a markup extension, discussed in a later section in this chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Grid`元素托管在`Page`内，"托管"将在下文中变得清晰。其`Background`属性设置为`{StaticResource ApplicationPageBackgroundThemeBrush}`。这是一个标记扩展，在本章的后面部分讨论。'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: XAML is unable to invoke methods directly; it can just set properties. This
    is understandable, as XAML needs to remain declarative in nature; it's not meant
    as a replacement for C++ or any other programming language.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: XAML无法直接调用方法；它只能设置属性。这是可以理解的，因为XAML需要保持声明性的特性；它并不是作为C++或任何其他编程语言的替代品。
- en: Type converters
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型转换器
- en: 'XML deals with strings. However, it''s clear that many properties are not strings.
    Many can still be specified as strings, and still work correctly thanks to the
    type converters employed by the XAML parser. Here''s an example of a `Rectangle`
    element:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: XML处理字符串。然而，很明显许多属性不是字符串。许多属性仍然可以指定为字符串，并且由于XAML解析器使用的类型转换器，仍然可以正确工作。以下是`Rectangle`元素的一个例子：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Presumably, the `Fill` property is not of a string type. In fact, it's a `Brush`.
    `Red` here really means `ref new SolidColorBrush(Colors::Red)`. The XAML parser
    knows how to translate a string, such as `Red` (and many others) to a `Brush`
    type (in this case the more specific `SolidColorBrush`).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 可以推测，`Fill`属性不是字符串类型。实际上，它是一个`Brush`。这里的`Red`实际上意味着`ref new SolidColorBrush(Colors::Red)`。XAML解析器知道如何将字符串（例如`Red`和许多其他字符串）转换为`Brush`类型（在这种情况下是更具体的`SolidColorBrush`）。
- en: Type converters are just one aspect of XAML that make it more succinct than
    the equivalent C++ code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换器只是XAML的一个方面，使其比等效的C++代码更简洁。
- en: Complex properties
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂属性
- en: 'As we''ve seen, setting properties is done via XML attributes. What about complex
    properties that cannot be expressed as a string and don''t have type converters?
    In this case, an extended syntax (property element syntax) is used to set the
    property. Here''s an example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，设置属性是通过XML属性完成的。那么，对于无法表示为字符串并且没有类型转换器的复杂属性呢？在这种情况下，使用扩展语法（属性元素语法）来设置属性。这里有一个例子：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Setting the `RenderTransform` property cannot be done with a simple string;
    it must be an object that is derived from the `Transform` class (`RotateTransform`
    in this case).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`RenderTransform`属性不能使用简单的字符串；它必须是从`Transform`类派生的对象（在这种情况下是`RotateTransform`）。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The exact meaning of the various example properties (`Fill`, `RenderTransform`,
    and others) will be discussed in [Chapter 4](ch04.html "Chapter 4. Layout, Elements,
    and Controls"), *Layout, Elements, and Controls*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 各种示例属性（`Fill`，`RenderTransform`等）的确切含义将在[第4章](ch04.html "第4章 布局、元素和控件")中讨论，*布局、元素和控件*。
- en: 'The preceding markup is equivalent to the following C++ code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的标记等同于以下C++代码：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Dependency properties and attached properties
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖属性和附加属性
- en: Most properties on various elements and controls are not normal, in the sense
    that they are not simple wrappers around private fields. The significance of dependency
    properties will be discussed in [Chapter 5](ch05.html "Chapter 5. Data Binding"),
    *Data Binding*. For now, it's important to realize that there is no difference
    in XAML between a dependency property and a regular property; the syntax is the
    same. In fact, there is no way to tell if a certain property is a dependency property
    or not, just by looking at its use in XAML.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 各种元素和控件上的大多数属性都不是正常的，它们不是简单的私有字段的包装器。依赖属性的重要性将在[第5章](ch05.html "第5章 数据绑定")中讨论，*数据绑定*。现在，重要的是要意识到在XAML中，依赖属性和常规属性之间没有区别；语法是相同的。实际上，仅仅通过在XAML中使用某个属性，无法判断某个属性是依赖属性还是普通属性。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Dependency properties provide the following features (a detailed explanation
    is provided in [Chapter 6](ch06.html "Chapter 6. Components, Templates, and Custom
    Elements"), *Components, Templates, and Custom Elements*):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖属性提供以下功能（详细解释在[第6章](ch06.html "第6章 组件、模板和自定义元素")中提供，*组件、模板和自定义元素*）：
- en: Change notifications when the property value changes
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当属性值改变时进行更改通知
- en: Visual inheritance for certain properties (mostly the font-related properties)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些属性的视觉继承（主要是与字体相关的属性）
- en: Multiple providers that may affect the final value (one wins out)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能影响最终值的多个提供者（一个获胜）
- en: Memory conservation (value not allocated unless changed)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存保护（值在改变时不分配）
- en: Some WinRT features, such as data binding, styles, and animations are dependent
    on that support.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 某些WinRT功能，如数据绑定、样式和动画，依赖于该支持。
- en: 'Another kind of dependency properties is attached properties. Again, a detailed
    discussion is deferred until [Chapter 5](ch05.html "Chapter 5. Data Binding"),
    *Data Binding*, but essentially an attached property is contextual—it''s defined
    by one type (with a registration mechanism that will be discussed in [Chapter
    6](ch06.html "Chapter 6. Components, Templates, and Custom Elements"), *Components,
    Templates, and Custom Controls*), but can be used by any type that inherits from
    `DependencyObject` (as all elements and controls do). Since this kind of property
    is not defined by the object it''s used on, it merits a special syntax in XAML.
    The following is an example of a `Canvas` panel that holds two elements:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Canvas.Left` and `Canvas.Top` are attached properties. They were defined
    by the `Canvas` class, but they are attached to the `Rectangle` and `Ellipse`
    elements. Attached properties only have meaning in certain scenarios. In this
    case, they indicate the exact position of the elements within the canvas .The
    canvas is the one that looks for these properties in the layout phase (discussed
    in detail in the next chapter). This means that if those same elements were placed
    in, say a `Grid`, those properties would have no effect, because there is no interested
    entity in those properties (there is no harm in having them, however). Attached
    properties can be thought of as dynamic properties that may or may not be set
    on objects.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the resulting UI:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![Dependency properties and attached properties](img/5022_03_04.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: 'Setting an attached property in code is a little verbose. Here''s the equivalent
    C++ code for setting the `Canvas.Left` and `Canvas.Top` properties on an element
    named `_myrect`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The reason why the preceding calls will become apparent will be discussed when
    we will learn how to create attached properties in [Chapter 6](ch06.html "Chapter 6. Components,
    Templates, and Custom Elements"), *Components, Templates, and Custom Elements*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Content properties
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The relationship between a `Page` object and a `Grid` object is not obvious.
    `Grid` seems to be inside the `Page`. But how would that translate to code? The
    `Page`/`Grid` markup can be summed up as follows (ignoring the detailed markup):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is actually a shortcut for the following markup:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This means the `Grid` object is set as the `Content` property of the `Page`
    object; now the relationship is clear. The XAML parser considers certain properties
    (no more than one per type hierarchy) as the default or content properties. It
    doesn''t have to be named `Content`, but it is in the `Page` case. This attribute
    is specified in the control''s metadata using the `Windows::UI::Xaml::Markup::ContentAttribute`
    class attribute. Looking at the Visual Studio object browser for the `Page` class
    shows no such attribute. But `Page` inherits from `UserControl`; navigating to
    `UserControl`, we can see the attribute set:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![Content properties](img/5022_03_01.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Attributes are a way to extend the metadata for a type declaratively. They can
    be inserted in C++/CX by an attribute type name in square brackets before the
    item that attribute is applied to (can be a class, interface, method, property,
    and other code element). An attribute class must derive from `Platform::Metadata::Attribute`
    to be considered as such by the compiler.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the common `ContentProperty` properties in WinRT types are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '`Content` of `ContentControl` (and all derived types)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content` of `UserControl`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Children` of `Panel` (base class for all layout containers)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Items` of `ItemsControl` (base class for collection-based controls)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GradientStops` of `GradientBrush` (base class of `LinearGradientBrush`)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collection properties
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some properties are collections (of type `IVector<T>` or `IMap<K,V>`, for instance).
    Such properties can be filled with objects, and the XAML parser will call the
    `IVector<T>::Append` or `IMap<K,V>::Insert` methods. Here''s an example for a
    `LinearGradientBrush`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Two rules are at work here. The first is the `ContentProperty` of `LinearGradientBrush`
    (`GradientStops`), which need not be specified. It''s of the type `GradientStopCollection`,
    which implements `IVector<GradientStop>`, and thus is eligible for automatic appending.
    This is equivalent to the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两条规则。第一条是`LinearGradientBrush`的`ContentProperty`（`GradientStops`），不需要指定。它是`GradientStopCollection`类型，实现了`IVector<GradientStop>`，因此有资格进行自动追加。这相当于以下代码：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is perhaps the first clear sign of XAML syntax advantage over C++. Here''s
    the rectangle in all its glory:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是XAML语法优势在C++上的第一个明显迹象。以下是矩形的全部荣耀：
- en: '![Collection properties](img/5022_03_02.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![集合属性](img/5022_03_02.jpg)'
- en: In the case of `IMap<K,V>`, an attribute named `x:Key` must be set on each item
    to indicate the key sent to the `IMap<K,V>::Insert` method. We'll see an example
    of such a map later in this chapter, when we will discuss resources.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`IMap<K,V>`，必须在每个项目上设置名为`x:Key`的属性，以指示发送到`IMap<K,V>::Insert`方法的键。在本章后面，我们将讨论资源时，将看到这样一个地图的例子。
- en: Markup extensions
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标记扩展
- en: '**Markup extensions** are special instructions to the XAML parser that provide
    ways of expressing things that are beyond object creation or setting some property.
    These instructions are still declarative in nature, but their code equivalent
    usually entails calling methods, which is not directly possible in XAML.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**标记扩展**是对XAML解析器的特殊指令，提供了表达超出对象创建或设置某些属性的方式。这些指令仍然是声明性的，但它们的代码等效通常涉及调用方法，在XAML中直接不可能。'
- en: Markup extensions are placed inside curly braces as property values. They may
    contain arguments and properties, as we'll see in later chapters. The only markup
    extension used by default in a blank page is `{StaticResource}`, which will be
    discussed later in this chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 标记扩展放置在花括号内作为属性值。它们可以包含参数和属性，我们将在后面的章节中看到。在空白页面中默认使用的唯一标记扩展是`{StaticResource}`，将在本章后面讨论。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: WPF and Silverlight 5 allow developers to create custom markup extensions by
    deriving classes from `MarkupExtension`. This capability is unavailable in the
    current WinRT implementation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: WPF和Silverlight 5允许开发人员通过从`MarkupExtension`派生类来创建自定义标记扩展。当前WinRT实现中不支持此功能。
- en: 'One simple example of a markup extension is `{x:Null}`. This is used in XAML
    whenever the value `nullptr` needs to be specified, as there''s no better way
    to use a string for this. The following example makes a hole in the `Rectangle`
    element:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的标记扩展的例子是`{x:Null}`。每当需要指定值`nullptr`时，在XAML中使用它，因为没有更好的方法来使用字符串。以下示例在`Rectangle`元素中创建了一个空白：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Naming elements
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名元素
- en: 'Objects created through XAML can be named using the `x:Name` XAML attribute.
    Here''s an example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过XAML创建的对象可以使用`x:Name` XAML属性进行命名。以下是一个例子：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The net result is a private member variable (field) that is created by the
    XAML compiler inside `MainPage.g.h` (if working on `MainPage.xaml`):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是一个私有成员变量（字段），由XAML编译器在`MainPage.g.h`中创建（如果在`MainPage.xaml`上工作）：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The reference in itself must be set in the implementation of `MainPage::InitializeComponent`
    with the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 引用本身必须在`MainPage::InitializeComponent`的实现中设置，使用以下代码：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The mentioned file and method are discussed further in the section *XAML compilation
    and execution*. Regardless of how it works, `r1` is now a reference to that particular
    rectangle.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 提到的文件和方法在* XAML编译和执行*部分进一步讨论。无论它是如何工作的，`r1`现在是对该特定矩形的引用。
- en: Connecting events to handlers
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接事件到处理程序
- en: Events can be connected to handlers by using the same syntax as setting properties,
    but in this case the value of the property must be a method in the code behind
    class with the correct delegate signature.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 事件可以通过与设置属性相同的语法连接到处理程序，但在这种情况下，属性的值必须是代码后台类中具有正确委托签名的方法。
- en: Visual Studio helps out by adding a method automatically if *Tab* is pressed
    twice after entering the event name (in the header and implementation files).
    The default name that Visual Studio uses includes the element's name (`x:Name`)
    if it has one, or its type if it doesn't, followed by an underscore and the event
    name, and optionally followed by an underscore and an index if duplication is
    detected. The default name is usually not desirable; a better approach that still
    has Visual Studio creating the correct prototype is to write the handler name
    as we want it, and then right-click on the handler name and select **Navigate
    to Event Handler**. This has the effect of creating the handler (if it does not
    exist) and switching to the method implementation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在输入事件名称后两次按下* Tab*，Visual Studio会自动添加一个方法。Visual Studio使用的默认名称包括元素的名称（`x:Name`）（如果有）或其类型（如果没有），后跟下划线和事件名称，如果检测到重复，则后跟下划线和索引。默认名称通常不理想；一个更好的方法，仍然让Visual
    Studio创建正确的原型，是按照我们想要的方式编写处理程序名称，然后右键单击处理程序名称并选择**导航到事件处理程序**。这将创建处理程序（如果不存在）并切换到方法实现。
- en: 'Here''s an example of an XAML event connection:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是XAML事件连接的示例：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And the handler would be as follows (assuming the XAML is in `MainPage.xaml`):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序如下（假设XAML在`MainPage.xaml`中）：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Visual Studio also writes the namespace name in front of the class name (deleted
    in the preceding code example); this can be deleted safely, since an in-use namespace
    statement exists at the top of the file for the correct namespace. Also, the usage
    of `Platform::Object` instead of just `Object` (and similarly for `RoutedEventArgs`)
    is less readable; the namespace prefixes can be removed, as they are set up at
    the top of the file by default.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio还在类名前面写入命名空间名称（在前面的代码示例中删除了）；这可以安全地删除，因为文件顶部存在正确命名空间的使用命名空间语句。此外，使用`Platform::Object`而不仅仅是`Object`（以及类似于`RoutedEventArgs`）不够可读；命名空间前缀可以被移除，因为它们默认在文件顶部设置。
- en: All events (by convention) use delegates that are similar. The first argument
    is always the sender of the event (in this case a `Button`) and the second parameter
    is the extra information regarding the event. `RoutedEventArgs` is the minimum
    type for events, known as routed events. A detailed discussion of routed events
    is covered in the next chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: XAML rules summary
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a summary of all XAML rules:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: An XAML element means creating an instance.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An XAML attribute sets a property or an event handler. For properties, a type
    converter may execute depending on the property's type.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex properties are set with the `Type.Property` element syntax.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attached properties are set with the `Type.Property` syntax, where `Type` is
    the declaring type of the attached property.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ContentPropertyAttribute` sets a `Content` property that need not be specified.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties that are collections cause the XAML parser to call `Append` or `Insert`,
    as appropriate, automatically.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Markup extensions allow for special (predefined) instructions.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the Blend for Visual Studio 2012 tool
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio 2012 is installed with the Blend for Visual Studio 2012 tool.
    This tool is typically used by UI designers to create or manipulate the user interface
    for XAML-based applications.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The initial release of Blend for Visual Studio 2012 only supported Windows 8
    Store Apps and Windows Phone 8 projects. The support for WPF 4.5 and Silverlight
    was added in Update 2 for Visual Studio 2012.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Blend can be used alongside Visual Studio 2012, as both understand the same
    file types (such as solution `.sln` files). It''s not atypical to switch back
    and forth between the two tools—using each tool for its strengths. Here''s a screenshot
    of Blend with the `CH03.sln` solution file open (the solution that holds all the
    samples for this chapter):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the Blend for Visual Studio 2012 tool](img/5022_03_10.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: 'The preceding screenshot shows a particular XAML file open, with one button
    selected. Several windows comprise Blend, some of which are similar to their Visual
    Studio counterparts, namely **Projects** and **Properties**. Some of the new windows
    include:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '**Assets**: Holds the elements and controls available in WinRT (along with
    some other useful shortcuts)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Objects** and **Timeline**: Include all objects in the visual tree and also
    animations'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resources**: Holds all resources (refer to the next section) within the application'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blend's design surface allows manipulating elements and controls, which is also
    possible to do in Visual Studio. Blend's layout and some special editing features
    make it easier for UI/graphic designers to work with as it mimics other popular
    applications, such as Adobe Photoshop and Illustrator.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Any changes made using the designer are immediately reflected by the changed
    XAML. Switching back to Visual Studio and accepting the reload option synchronizes
    the files; naturally, this can be done both ways.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to work from within Blend entirely. Pressing *F5* builds and launches
    the app in the usual way. Blend, however, is not Visual Studio, and breakpoints
    and other debugging tasks are not supported.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Blend is a non-trivial tool, and is well beyond the scope of this book. Experimentation
    can go a long way, however.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: XAML compilation and execution
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The XAML compiler that runs as part of the normal compilation process, places
    the XAML as an internal resource within the EXE or DLL. In the constructor of
    a XAML root element type (such as `MainPage`), a call is made to `InitializeComponent`
    . This method uses a static helper method `Application::LoadComponent` to load
    the XAML and parse it—creating objects, setting properties, and so on. Here''s
    the implementation created by the compiler for `InitializeComponent` (in `MainPage.g.hpp`,
    with some code cleaning):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Connecting XAML, H, and CPP files to the build process
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From a developer''s perspective, working with a XAML file carries with it two
    other files, the H and CPP. Let''s examine them in a little more detail. Here''s
    the default `MainPage.xaml.h` (comments and namespaces removed):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发人员的角度来看，使用 XAML 文件还需要另外两个文件，即 H 和 CPP。让我们更详细地检查一下它们。这是默认的 `MainPage.xaml.h`（已删除注释和命名空间）：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The code shows a constructor and a virtual method override named `OnNavigatedTo`
    (unimportant for this discussion). One thing that seems to be missing is the `InitializeComponent`
    method declaration mentioned in the previous section. Also the inheritance from
    `Page` that was hinted at earlier is missing. It turns out that the XAML compiler
    generates another header file named `MainPage.g.h` (`g` stands for generated)
    based on the XAML itself (this is evident with the top `#include` declaration).
    This file contains the following (it can be opened easily by selecting the **Project**
    | **Show All Files**, or the equivalent toolbar button, or right clicking on `#include`
    and selecting **Open Document…**):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 代码显示了一个构造函数和一个名为 `OnNavigatedTo` 的虚方法重写（对于本讨论不重要）。似乎缺少的一件事是在前一节中提到的 `InitializeComponent`
    方法声明。还有之前提到的从 `Page` 继承也缺失了。原来 XAML 编译器生成了另一个名为 `MainPage.g.h`（`g` 代表生成）的头文件，基于
    XAML 本身（这可以通过顶部的 `#include` 声明来证明）。这个文件包含以下内容（可以通过选择 **项目** | **显示所有文件**，或等效的工具栏按钮，或右键单击
    `#include` 并选择 **打开文档…** 来轻松打开）：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here we find the missing pieces. Here we find `InitializeComponent`, as well
    as the derivation from `Page`. How can there be more than one header file per
    class? A new C++/CX feature called partial classes allows this. The `MainPage`
    class is marked as `partial`, meaning there are more parts to it. The last part
    should not be marked as `partial`, and should include at least one header so that
    a chain forms, eventually including all the partial headers; all these headers
    must be part of the same compilation unit (a CPP file). This `MainPage.g.h` file
    is generated before any compilation happens; it's generated on the fly while editing
    the XAML file. This is important because named elements are declared in that file,
    providing instance intellisense.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们找到了缺失的部分。在这里我们找到了 `InitializeComponent`，以及从 `Page` 派生。一个类怎么会有多个头文件？一个名为部分类的新
    C++/CX 功能允许这样做。`MainPage` 类被标记为 `partial`，意味着它有更多的部分。最后一个部分不应该被标记为 `partial`，并且应该包含至少一个头文件，以便形成一个链，最终包括所有部分头文件；所有这些头文件必须是同一个编译单元（一个
    CPP 文件）的一部分。`MainPage.g.h` 文件是在任何编译发生之前生成的；它是在编辑 XAML 文件时动态生成的。这很重要，因为命名元素是在那个文件中声明的，提供实例智能感知。
- en: During the compilation process, `MainPage.cpp` is finally compiled, producing
    an object file, `MainPage.obj`. It still has some unresolved functions, such as
    `InitializeComponent`. At this time, `MainPage.obj` (along with other XAML object
    files, if exist) is used to generate the metadata (`.winmd`) file.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译过程中，`MainPage.cpp` 最终被编译，生成一个对象文件 `MainPage.obj`。它仍然有一些未解决的函数，比如 `InitializeComponent`。此时，`MainPage.obj`（以及其他
    XAML 对象文件，如果存在）被用来生成元数据（`.winmd`）文件。
- en: To complete the build process, the compiler generates `MainPage.g.hpp`, which
    is actually an implementation file, created based on the information extracted
    from the metadata file (the `InitializeComponent` implementation is generated
    in this file). This generated file is included just once in a file called `XamlTypeInfo.g.cpp`,
    which is also generated automatically based on the metadata file (its job is related
    to data binding, as discussed in [Chapter 5](ch05.html "Chapter 5. Data Binding"),
    *Data Binding*), but that's good enough so that `MainPage.g.hpp` is finally compiled,
    allowing linking to occur correctly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成构建过程，编译器生成了 `MainPage.g.hpp`，实际上是一个实现文件，根据从元数据文件中提取的信息创建的（`InitializeComponent`
    实现是在这个文件中生成的）。这个生成的文件只包含在一个名为 `XamlTypeInfo.g.cpp` 的文件中，这个文件也是根据元数据文件自动生成的（它的工作与数据绑定有关，如
    [第 5 章](ch05.html "第 5 章. 数据绑定") 中讨论的 *数据绑定*），但这已经足够让 `MainPage.g.hpp` 最终被编译，允许链接正确进行。
- en: 'The entire process can be summarized with the following diagram:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程可以用以下图表总结：
- en: '![Connecting XAML, H, and CPP files to the build process](img/5022_03_03.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![将 XAML、H 和 CPP 文件连接到构建过程](img/5022_03_03.jpg)'
- en: Resources
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源
- en: The term "resources" is highly overloaded. In classic Win32 programming, resources
    refer to read-only chunks of data, used by an application. Typical Win32 resources
    are strings, bitmaps, menus, toolbars, and dialogs, but custom resources can be
    created as well, making Win32 treat those as unknown chunks of binary data.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“资源”有很多含义。在经典的 Win32 编程中，资源指的是应用程序使用的只读数据块。典型的 Win32 资源包括字符串、位图、菜单、工具栏和对话框，但也可以创建自定义资源，使
    Win32 将其视为未知的二进制数据块。
- en: WinRT defines binary, string, and logical resources. The following sections
    discuss binary and logical resources (string resources are useful for localization
    scenarios and will not be discussed in this section).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT 定义了二进制、字符串和逻辑资源。以下部分讨论二进制和逻辑资源（字符串资源对于本节的本地化场景很有用，不在本节讨论范围内）。
- en: Binary resources
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二进制资源
- en: Binary resources refer to chunks of data, provided as part of the application's
    package. These typically include images, fonts, and any other static data needed
    for the application to function correctly.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制资源是指作为应用程序包的一部分提供的数据块。这些通常包括图像、字体和应用程序正常运行所需的任何其他静态数据。
- en: Binary resources can be added to a project by right-clicking on the project
    in Solution Explorer, and selecting **Add Existing Item**. Then, select a file
    that must be in the project's directory or in a subdirectory.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在解决方案资源管理器中右键单击项目，然后选择 **添加现有项** 来将二进制资源添加到项目中。然后，选择必须位于项目目录或子目录中的文件。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Contrary to C# or VB projects, adding an existing item from a location does
    not copy the file to the project's directory. This inconsistency is a bit annoying
    for those familiar with C#/VB projects, and hopefully will be reconciled in a
    future Visual Studio version or service pack.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical Store app project already has some binary resources stored in the
    `Assets` project folder, namely images used by the application:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![Binary resources](img/5022_03_05.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: Using folders is a good way to organize resources by type or usage. Right-clicking
    on the project node and selecting **Add New Filter** creates a logical folder,
    to which items may be dragged.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Again, contrary to C#/VB projects, project folders are not created in the filesystem.
    It's recommended that these are actually created in the filesystem for better
    organization.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'The added binary resource is packaged as part of the application''s package
    and is available in the executable folder or subfolder, keeping its relative location.
    Right-clicking on such a resource and selecting **Properties** yields the following
    dialog:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![Binary resources](img/5022_03_06.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: The **Content** attribute must be set to **Yes** for the resource to be actually
    available (the default). **Item Type** is typically recognized by Visual Studio
    automatically. In case, it doesn't, we can always set it to **Text** and do whatever
    we want with it in code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't set **Item Type** to **Resource**. This is unsupported in WinRT and will
    cause compile errors (this setting is really for WPF/Silverlight).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Binary resources can be accessed in XAML or in code, depending on the need.
    Here''s an example of using an image named `apple.png` stored in a subfolder in
    the application named `Images` under the `Assets` folder by an `Image` element:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note the relative URI. The preceding markup works because of a type converter
    that''s used or the `Image::Source` property (which is of the type `ImageSource`).
    That path is really a shortcut for the following, equivalent, URI:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Other properties may require a slightly different syntax, but all originate
    through the `ms-appx` scheme, indicating the root of the application's package.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Binary resources that are stored in another component referenced by the application
    can be accessed with the following syntax:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The markup assumes that a component DLL named `ResourceLibrary.Dll` is referenced
    by the application and that a binary resource named `jellyfish.jpg` is present
    in its root folder.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Logical resources
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Binary resources are not new or unique to Store apps. They've been around practically
    forever. Logical resources, on the other hand, is a more recent addition. First
    created and used by WPF, followed by the various versions of Silverlight, they
    are used in WinRT as well. So, what are they?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Logical resources can be almost anything. These are objects, not binary chunks
    of data. They are stored in the `ResourceDictionary` objects, and can be easily
    accessed in XAML by using the `StaticResource` markup extension.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of two elements that use an identical brush:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The problem should be self-evident. We''re using the same brush twice. This
    is bad for two reasons:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: If we want to change the brush, we need to do it twice (because of the duplication).
    Naturally, this is more severe if that brush is used by more than two elements.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two different objects are created, although just one shared object is needed.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LinearGradientBrush` can be turned into a logical resource (or simply a resource)
    and referenced by any element that requires it. To do that, the brush must be
    placed in a `ResourceDictionary` object. Fortunately, every element has a `Resources`
    property (of type `ResourceDictionary`) that we can use. This is typically done
    on the root XAML element (typically a `Page`), or (as we''ll see in a moment)
    in the application''s XAML (`App.Xaml`):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Any logical resource must have a key, because it''s in a dictionary. That key
    is specified by the `x:Key` XAML directive. Once placed, a resource can be accessed
    from any element within that `Page` with the `StaticResource` markup extension
    as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 任何逻辑资源必须有一个键，因为它在字典中。该键由“x:Key”XAML指令指定。一旦放置，资源可以通过以下方式使用“StaticResource”标记扩展从“Page”中的任何元素中访问：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `StaticResource` markup extension searches for a resource with the specified
    key starting from the current element. If not found, the search continues on the
    resources with its parent element (say a Grid). If found, the resource is selected
    (it is created the first time it''s requested), and `StaticResource` is done.
    If not found, the parent''s parent is searched and so on. If the resource is not
    found at the top level element (typically a `Page`, but can be a `UserControl`
    or something else), the search continues in the application resources (`App.xaml`).
    If not found, an exception is thrown. The search process can be summarized by
    the following diagram:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: “StaticResource”标记扩展从当前元素开始搜索具有指定键的资源。如果找不到，则在其父元素（例如Grid）的资源上继续搜索。如果找到，则选择资源（在第一次请求时创建），并且“StaticResource”完成。如果找不到，则搜索父级的父级，依此类推。如果在顶级元素（通常是“Page”，但可以是“UserControl”或其他内容）中找不到资源，则在应用程序资源（“App.xaml”）中继续搜索。如果找不到，则抛出异常。搜索过程可以通过以下图表总结：
- en: '![Logical resources](img/5022_03_07.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![逻辑资源](img/5022_03_07.jpg)'
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Why is the markup extension called `StaticResource`? Is there a `DynamicResource`?
    `DynamicResource` exists in WPF only, which allows a resource to be replaced dynamically,
    with all those bound to it noticing the change. This is currently unsupported
    by WinRT.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么标记扩展被称为“StaticResource”？是否有“DynamicResource”？“DynamicResource”仅存在于WPF中，它允许资源动态替换，并且所有绑定到它的对象都能注意到这种变化。这在WinRT中目前不受支持。
- en: There is no single call that is equivalent to `StaticResource`, although it's
    not difficult to create one if needed. The `FrameworkElement::Resources` property
    can be consulted on any required level, navigating to the parent element using
    the `Parent` property. The `Application::Resources` property has special significance,
    since any resources defined within it can be referenced by any page or element
    across the entire application. This is typically used to set various defaults
    for a consistent look and feel.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 没有与“StaticResource”等效的单个调用，尽管如果需要，创建一个并不困难。可以在任何所需的级别上使用“FrameworkElement::Resources”属性进行查询，使用“Parent”属性导航到父元素。
    “Application::Resources”属性具有特殊意义，因为在其中定义的任何资源都可以被整个应用程序中的任何页面或元素引用。这通常用于设置一致外观和感觉的各种默认值。
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It may be tempting to store actual elements as resources (such as buttons).
    This should be avoided because resources are singletons within their usage container;
    this means referencing that button more than once within the same page will cause
    an exception to be thrown on the second reference, because an element can be in
    the visual tree just once.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将实际元素存储为资源可能很诱人（例如按钮）。应该避免这样做，因为资源在其使用容器中是单例；这意味着在同一页面中多次引用该按钮将导致在第二次引用时抛出异常，因为元素只能在可视树中出现一次。
- en: Resources are really intended for sharable objects, such as brushes, animations,
    styles, and templates.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 资源实际上是用于可共享的对象，例如画笔、动画、样式和模板。
- en: Resources can be added dynamically by using the `ResourceDictionary::Insert`
    method (on the relevant `ResourceDictionary`) and removed by calling `ResourceDictionary::Remove`.
    This only has an effect on subsequent `{StaticResource}` invocations; already
    bound resources are unaffected.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用“ResourceDictionary::Insert”方法（在相关的“ResourceDictionary”上）动态添加资源，并通过调用“ResourceDictionary::Remove”来删除资源。这只对后续的{StaticResource}调用产生影响；已绑定的资源不受影响。
- en: Note
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A `StaticResource` markup extension can be used by a resource as well. For this
    to work, any `StaticResource` must reference a resource that was defined earlier
    in the XAML; this is due to the way the XAML parser works. It cannot find resources
    that it has not yet encountered.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 资源也可以使用“StaticResource”标记扩展。为了使其工作，任何“StaticResource”必须引用在XAML中先前定义的资源；这是由于XAML解析器的工作方式。它无法找到尚未遇到的资源。
- en: Managing logical resources
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理逻辑资源
- en: Logical resources may be of various types, such as brushes, geometries, styles,
    templates, and more. Placing all those resources in a single file, such as `App.xaml`,
    hinders maintainability. A better approach would be to separate resources of different
    types (or based on some other criteria) from their own files. Still, they must
    be referenced somehow from within a common file such as `App.xaml` so that they
    are recognized.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑资源可以是各种类型，例如画笔、几何图形、样式、模板等。将所有这些资源放在一个文件中，例如“App.xaml”，会阻碍可维护性。更好的方法是将不同类型的资源（或基于其他标准）从它们自己的文件中分离出来。但是，它们必须以某种方式从一个共同的文件（如“App.xaml”）中引用，以便它们被识别。
- en: '`ResourceDictionary` can incorporate other resource dictionaries using its
    `MergedDictionaries` property (a collection). This means a `ResourceDictionary`
    can reference as many resource dictionaries as desired and can have its own resources
    as well. The `Source` property must point to the location of `ResourceDictionary`.
    The default `App.xaml` created by Visual Studio contains the following (comments
    removed):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: “ResourceDictionary”可以使用其“MergedDictionaries”属性（一个集合）合并其他资源字典。这意味着“ResourceDictionary”可以引用尽可能多的资源字典，并且可以拥有自己的资源。
    “Source”属性必须指向“ResourceDictionary”的位置。由Visual Studio创建的默认“App.xaml”包含以下内容（已删除注释）：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Indeed, we find a file called `StandardStyles.xaml` in the `Common` folder,
    which hosts a bunch of logical resources, with `ResourceDictionary` as its root
    element. For this file to be considered when `StaticResource` is invoked, it must
    be referenced by another `ResourceDictionary`, from a `Page` or the application
    (the application is more common). The `ResourceDictionary::MergedDictionaries`
    property contains other `ResourceDictionary` objects, whose `Source` property
    must point to the required XAML to be included (that XAML must have `ResourceDictionary`
    as its root element).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create our own `ResourceDictionary` XAML by using Visual Studio''s **Add
    New Item** menu option and selecting **Resource Dictionary**:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing logical resources](img/5022_03_08.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: Duplicate keys
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No two objects can have the same key in the same `ResourceDictionary` instance.
    `StaticResource` takes the first resource it finds with the specified key, even
    if that key already exists in a `ResourceDictionary`. What about merged dictionaries?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Merging different resource dictionaries may cause an issue—two or more resources
    with the same key that originate from different merged dictionaries. This is not
    an error and does not throw an exception. Instead, the selected object is the
    one from the last resource dictionary added (which has a resource with that key).
    Furthermore, if a resource in the current resource dictionary has the same key
    as any of the resources in its merged dictionaries, it always wins out. Here''s
    an example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Given this markup, the resource named `brush1` is a blue `SolidColorBrush` because
    it appears in the `ResourceDictionary` itself. This overrides any resources named
    `brush1` in the merged dictionaries. If this blue brush did not exist, `brush1`
    would be looked up in `Brushes1.xaml` first, as this is the last entry in the
    merged dictionaries collection.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: XAML containing a `ResourceDictionary` as its root can be loaded dynamically
    from a string using the static `XamlReader::Load` method and then added as a merged
    dictionary, where appropriate.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Styles
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consistency in user interface is an important trait; there are many facets of
    consistency, one of which is the consistent look and feel of controls. For example,
    all buttons should look roughly the same—similar colors, fonts, sizes, and so
    on. Styles provide a convenient way of grouping a set of properties under a single
    object, and then selectively (or automatically, as we'll see later) apply it to
    elements.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Styles are always defined as resources (usually at the application level, but
    can also be at the `Page` or `UserControl` level). Once defined, they can be applied
    to elements by setting the `FrameworkElement::Style` property.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a style defined as part of the `Resources` section of a `Page`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The style has a key (`style1`), and must have `TargetType`. This is the type
    the style may be applied to (and any derived types). The XAML parser has a type
    converter that converts `TargetType` to a `TypeName` object.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The main ingredient in `Style` is its `Setters` collection (which is also its
    `ContentProperty`). This collection accepts `Setter` objects, which need `Property`
    and `Value`. The property must be a dependency property (not usually a problem,
    as most element properties are dependency properties); these are provided as simple
    strings thanks to type converters used behind the scene.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: The above markup sets up the properties `FontSize`, `Background` (with a complex
    property syntax because of the `LinearGradientBrush`), and `Foreground`—all for
    the `Button` controls.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Once defined, the style can be applied to elements using the usual `StaticResource`
    markup extension in XAML by setting the `FrameworkElement::Style` property, as
    in the following example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Readers familiar with WPF may be wondering if the `TargetType` property can
    be omitted so that a greater control range can be covered. This is unsupported
    in the current version of WinRT.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Setting the style on an incompatible element type (such as a `CheckBox` control
    in this example) causes an exception to be thrown at page load time. If a `CheckBox`
    should also be able to use the same style, the `TargetType` can be changed to
    `ButtonBase` (which covers all button types).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use different styles for different elements, even if a base type seems to cover
    several controls. It's very likely that later some properties may need to be tweaked
    for a particular type, making it difficult to change the style. Build a different
    style for different concrete types. You can also use style inheritance (as described
    later) to shorten some of the markup.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if an element with an applied style sets a property to a different
    value than the one from `Style`? The local value wins out. This means that the
    following button has a font size of `30` and not `40`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Implicit (automatic) styles
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous section showed how to create a style that has a name (`x:Key`)
    and how to apply it to elements. Sometimes, however, we would like a style to
    be applied automatically to all elements of a certain type, to give the application
    a consistent look. For example, we may want all buttons to have a certain font
    size or background, without the need for setting the `Style` property of each
    and every button. This makes creating new buttons easier, as the developer/designer
    doesn't have to know what style to apply (if any, the implicit style in scope
    will be used automatically).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a `Style` that is applied automatically, the `x:Key` attribute must
    be removed:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The key still exists, as the `Style` property is still part of `ResourceDictionary`
    (which implements `IMap<Object, Object>`), but is automatically set to a `TypeName`
    object for the specified `TargetType`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Once the `Style` property is defined and any `Button` element (in this example)
    in scope for `ResourceDictionary` of the `Style` property is in, that style will
    be applied automatically. The element can still override any property it wishes
    by setting a local value.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Automatic styles are applied to the exact type only, not to derived types. This
    means that an automatic style for `ButtonBase` is useless, as it's an abstract
    class.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: An element may wish to revert to its default style and not have an implicit
    style applied automatically. This can be achieved by setting `FrameworkElement::Style`
    to `nullptr` (`x:Null` in XAML).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Style inheritance
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Styles support the notion of inheritance, somewhat similar to the same concept
    in object orientation. This is done using the `BasedOn` property that must point
    to another style to inherit from. The `TargetType` of the derived style must be
    the same as in the base style.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'An inherited style can add `Setter` objects for new properties to set, or it
    can provide a different value for a property that was set by the base style. Here''s
    an example for a base style of a button:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following markup creates three inherited styles:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'These styles are part of a simple integer calculator application. The calculator
    looks like this when running:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![Style inheritance](img/5022_03_09.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: 'Most of the elements comprising the calculator are buttons. Here is the numeric
    button markup:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The operator buttons simply use a different style:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `=` button uses the same style as operators, but changes its background
    by setting a local value:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The complete project is named `StyledCalculator` and can be found as part of
    the downloadable source for this chapter.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Style inheritance may seem very useful, but should be used with caution. It
    suffers from the same issues as object oriented inheritance in a deep inheritance
    hierarchy—a change in a base style up in the hierarchy can affect a lot of styles,
    being somewhat unpredictable, leading to a maintenance nightmare. Thus, a good
    rule of thumb to use is to have no more than two inheritance levels. Any more
    than that may cause things to get out of hand.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Store application styles
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Store app project created by Visual Studio has a default style file named
    `StandardStyles.xaml` in the `Common` folder. The file includes styles for all
    common elements and controls the set up for a common look and feel that is recommended
    as a starting point. It's certainly possible to change these styles or to inherit
    from them if needed.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WinRT styles are similar in concept to CSS used in web development to provide
    styling to HTML pages. The cascading part hints to the multilevel nature of CSS,
    much like the multilevel nature of WinRT styles (application, page, panel, specific
    element, and so on).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was all about XAML, the declarative language used to build user
    interfaces for Windows Store apps. XAML takes some time getting used to it, but
    its declarative nature and markup extensions cannot easily be matched by procedural
    code in C++ (or other languages). Designer-oriented tools, such as Expression
    Blend and even the Visual Studio designer make it relatively easy to manipulate
    XAML without actually writing XAML, but as developers and designers working with
    other XAML-based technologies have already realized, it's sometimes necessary
    to write XAML by hand, making it an important skill to acquire.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll continue to use XAML heavily, while covering elements
    and controls, as well as layout, used in Windows 8 Store applications.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
