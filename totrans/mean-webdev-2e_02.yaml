- en: Chapter 2. Getting Started with Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, you set up your environment and discovered the basic
    development principles of Node.js. This chapter will cover the proper way of building
    your first Node.js web application. You''ll go through the basics of JavaScript
    event-driven nature and how to utilize it to build Node.js applications. You''ll
    also learn about the Node.js module system and how to build your first Node.js
    web application. You''ll then proceed to the Connect module and learn about its
    powerful middleware approach. By the end of this chapter, you''ll know how to
    use Connect and Node.js to build simple yet powerful web applications. In this
    chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript closures and event-driven programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js event-driven web development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CommonJS modules and the Node.js module system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the Connect web framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect's middleware pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At JSConf EU 2009, a developer named Ryan Dahl went onstage to present his project
    named Node.js. Starting in 2008, Dahl looked at the current web trends and discovered
    something odd in the way web applications worked. The introduction of the **Asynchronous
    JavaScript and XML** (**AJAX**) technology a few years earlier transformed static
    websites into dynamic web applications, but the fundamental building block of
    web development didn't follow this trend.
  prefs: []
  type: TYPE_NORMAL
- en: The problem was that web technologies didn't support two-way communication between
    the browser and the server. The test case he used was the Flickr upload file feature,
    where the browser was unable to know when to update the progress bar as the server
    could not inform it of how much of the file was uploaded.
  prefs: []
  type: TYPE_NORMAL
- en: Dahl's idea was to build a web platform that would gracefully support the push
    of data from the server to the browser, but it wasn't that simple. When scaling
    to common web usage, the platform had to support hundreds (and sometimes thousands)
    of ongoing connections between the server and the browser. Most web platforms
    used expensive threads to handle requests, which meant keeping a fair amount of
    idle threads in order to keep the connection alive. So, Dahl used a different
    approach. He understood that using non-blocking sockets could save a lot in terms
    of system resources and went as far as proving that this could be done using C.
    Given that this technique could be implemented in any programming language and
    the fact that Dahl thought working with non-blocking C code was a tedious task,
    he decided to look for a better programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'When Google announced Chrome and its new V8 JavaScript engine in late 2008,
    it was obvious that JavaScript could run faster than before—a lot faster. V8''s
    greatest advantage over other JavaScript engines was the compiling of JavaScript
    code to native machine code before executing it. This and other optimizations
    made JavaScript a viable programming language capable of executing complex tasks.
    Dahl noticed this and decided to try a new idea: non-blocking sockets in JavaScript.
    He took the V8 engine, wrapped it with the already solid C code, and created the
    first version of Node.js.'
  prefs: []
  type: TYPE_NORMAL
- en: After a very warm response from the community, he went on to expand the Node
    core. The V8 engine wasn't built to run in a server environment, so Node.js had
    to extend it in a way that made more sense in a server context. For example, browsers
    don't usually need access to the filesystem, but when running server code, this
    becomes essential. The result was that Node.js wasn't just a JavaScript execution
    engine, but a platform capable of running complex JavaScript applications that
    were simple to code, highly efficient, and easily scalable.
  prefs: []
  type: TYPE_NORMAL
- en: io.js and the Node.js foundation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By the end of 2014, a conflict rose between Joyent, the company that owns the
    Node.js assets, and a group of core contributors to the project. This group of
    developers felt that the governance of the project was lacking, so they requested
    Joyent create a non-profit foundation that will govern the project. In January
    2015, the group decided to fork the Node.js project and call it io.js. The new
    project aimed for faster and more predictable release cycles and was starting
    to gain some traction.
  prefs: []
  type: TYPE_NORMAL
- en: A few months later, the io.js team, backed by companies and community developers,
    was invited to Joyent's offices to discuss the future of the project. Together,
    they agreed on creating a Node foundation led by a Technical Steering Committee,
    merged the projects under the Node.js brand, and based it on the io.js repository.
    This led to a big upgrade in Node's release cycles and a more transparent governance
    of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js ES6 support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although Node.js already implemented partial ES6 support in older versions,
    latest versions have been showing better progress in implementing ES6 features.
    For stability reasons, the Node V8 engine implements ES6 features in three classifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shipping**: All features that are considered stable and are turned on by
    default. This means that they will *not* require any type of runtime flag to be
    activated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Staged**: All features that are almost stable and are not recommended for
    production usage. These features can be activated using the `--es_staging` runtime
    flag or its better-known synonym, the `--harmony` flag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In progress**: All features that are still under work and are not stable.
    These features can be activated using their respective `--harmony` flags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While it is outside of this book's scope, it is recommend that you visit the
    official documentation at [https://nodejs.org/en/docs/es6/](https://nodejs.org/en/docs/es6/)
    to learn more about ES6 implementation in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js LTS support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the Node.js community grew bigger, companies and larger organizations joined
    in, leading to a rising demand for stability and predictable version releases.
    In response to these new needs, the Node.js Foundation decided on a new release
    cycle. Basically, the team releases a new stable version every year in October.
    This version will always have an even version number such as v4 or v6\. These
    stable versions are supported by the LTS plan. It includes security and stability
    updates and can be used in production once they enter the LTS plan in October.
    Every April, a stable version release is cut from the LTS plan. It means that
    there are always two active stable versions that overlap for a maximum period
    of 6 months and that every stable version is covered for 18 months. Odd number
    versions are considered not stable and are mainly used to present the community
    with an implementation of the road map. These versions are cut in October so that
    they can be merged to the new stable version in time.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple roadmap for the following few years'' release cycle is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Node.js LTS support](img/B05071_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: JavaScript event-driven programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js uses the event-driven nature of JavaScript to support non-blocking operations
    in the platform, a feature that enables its excellent efficiency. JavaScript is
    an event-driven language, which means that you register code to specific events,
    and this code will be executed once the event is emitted. This concept allows
    you to seamlessly execute asynchronous code without blocking the rest of the program
    from running.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this better, take a look at the following Java code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the program executes the first and second lines, but any code
    after the second line will not be executed until the user inputs their name. This
    is synchronous programming, where I/O operations block the rest of the program
    from running. However, this is not how JavaScript works.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it was originally written to support browser operations, JavaScript was
    designed around browser events. Even though it has vastly evolved since its early
    days, the idea was to allow the browser to take the HTML user events and delegate
    them to JavaScript code. Let''s have a look at the following HTML example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have a textbox and a button. When the button is
    pressed, it will alert the value inside the textbox. The main function to watch
    here is the `addEventListener()` method. As you can see, it takes two arguments:
    the name of the event and an anonymous function that will run once the event is
    emitted. We usually refer to arguments of the latter kind as a *callback* function.
    Notice that any code after the `addEventListener()` method will execute accordingly,
    regardless of what we write in the callback function.'
  prefs: []
  type: TYPE_NORMAL
- en: As simple as this example is, it illustrates well how JavaScript uses events
    to execute a set of commands. Since the browser is single-threaded, using synchronous
    programming in this example would freeze everything else on the page, which would
    make every web page extremely unresponsive and impair the web experience in general.
    Thankfully, this is not how it works. The browser manages a single thread to run
    the entire JavaScript code using an inner loop, commonly referred to as the event
    loop. The event loop is a single-threaded loop that the browser runs infinitely.
    Every time an event is emitted, the browser adds it to an event queue. The loop
    will then grab the next event from the queue in order to execute the event handlers
    registered to that event.
  prefs: []
  type: TYPE_NORMAL
- en: 'After all the event handlers are executed, the loop grabs the next event, executes
    its handlers, grabs another event, and so on. The event loop cycle is shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JavaScript event-driven programming](img/B05071_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The event loop cycle
  prefs: []
  type: TYPE_NORMAL
- en: While the browser usually deals with user-generated events (such as button clicks),
    Node.js has to deal with various types of event that are generated from different
    sources.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js event-driven programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When developing web server logic, you will probably notice that a lot of your
    system resources are wasted on blocking code. For instance, let''s observe the
    following PHP database interactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our server will try querying the database. The database will then perform the
    `SELECT` statement and return the result to the PHP code, which will eventually
    output the data as a response. The preceding code blocks any other operation until
    it gets the result from the database. This means the process, or more commonly
    the thread, will stay idle, consuming system resources while it waits for other
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this issue, many web platforms have implemented a thread pool system
    that usually issues a single thread per connection. This kind of multithreading
    may seem intuitive at first, but has some significant disadvantages. They are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing threads becomes a complex task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System resources are wasted on idle threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling these kinds of applications cannot be done easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is tolerable while developing one-sided web applications, where the browser
    makes a quick request that ends with a server response. However, what happens
    when you want to build real-time applications that keep a long-living connection
    between the browser and the server? To understand the real-life consequences of
    these design choices, take a look at the following graphs. They present a famous
    performance comparison between Apache, which is a blocking web server, and NGINX,
    which uses a non-blocking event loop. The following screenshot shows concurrent
    request handling in Apache versus NGINX ([http://blog.webfaction.com/2008/12/a-little-holiday-present-10000-reqssec-with-nginx-2/](http://blog.webfaction.com/2008/12/a-little-holiday-present-10000-reqssec-with-nginx-2/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Node.js event-driven programming](img/B05071_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Concurrent connections impact on request handling in Apache vs. NGINX.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, you can see how Apache''s request-handling ability
    is degrading much faster than NGINX''s ability. An even clearer impact can be
    seen in the following diagram, where you can see how NGINX''s event loop architecture
    affects memory consumption:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Node.js event-driven programming](img/B05071_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Concurrent connections impact on memory allocation in Apache vs. NGINX.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the results, using event-driven architecture will help you
    dramatically reduce the load on your server while leveraging JavaScript's asynchronous
    behavior in building your web application. An approach that is easier to implement
    thanks to a simple design pattern called **Closures**.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Closures are functions that refer to variables from their parent environment.
    To understand them better, let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, you can see how the `child()` function has access
    to a constant defined in the `parent()` function. However, this is a simple example,
    so let''s look at a more interesting one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This time, the `parent()` function returned the `child()` function, and the
    `child()` function is called after the `parent()` function has already been executed.
    This is counterintuitive to some developers because usually the `parent()` function's
    local members should only exist while the function is being executed. This is
    what closures are all about! A closure is not only the function, but also the
    environment in which the function was created. In this case, `childFN()` is a
    closure object that consists of the `child()` function and the environment members
    that existed when the closure was created, including the `message` constant.
  prefs: []
  type: TYPE_NORMAL
- en: Closures are very important in asynchronous programming because JavaScript functions
    are first-class objects that can be passed as arguments to other functions. This
    means that you can create a callback function and pass it as an argument to an
    event handler. When the event will be emitted, the function will be invoked, and
    it will be able to manipulate any member that existed when the callback function
    was created, even if its parent function was already executed. This means that
    using the closure pattern will help you utilize event-driven programming without
    the need to pass the scope state to the event handler.
  prefs: []
  type: TYPE_NORMAL
- en: Node modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript has turned out to be a powerful language with some unique features
    that enable efficient yet maintainable programming. Its closure pattern and event-driven
    behavior have proven to be very helpful in real-life scenarios, but like all programming
    languages, it isn't perfect. One of its major design flaws is the sharing of a
    single global namespace.
  prefs: []
  type: TYPE_NORMAL
- en: To understand this problem, we need to go back to JavaScript's browser origins.
    In the browser, when you load a script into your web page, the engine will inject
    its code into an address space that is shared by all the other scripts. This means
    that when you assign a variable in one script, you can accidently overwrite another
    variable already defined in a previous script. While this could work with a small
    code base, it can easily cause conflicts in larger applications, as errors will
    be difficult to trace. It could have been a major threat for Node.js evolution
    as a platform, but luckily, a solution was found in the CommonJS module standard.
  prefs: []
  type: TYPE_NORMAL
- en: CommonJS modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CommonJS is a project started in 2009 to standardize the way of working with
    JavaScript outside the browser. The project has evolved since then to support
    a variety of JavaScript issues, including the global namespace issue, which was
    solved through a simple specification of how to write and include isolated JavaScript
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CommonJS standards specify the following key components when working with
    modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`require()`: A method that is used to load the module into your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exports`: An object that''s contained in each module and allows you to expose
    pieces of your code when the module is loaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module`: An object that was originally used to provide metadata information
    about the module. It also contains the pointer of an `exports` object as a property.
    However, the popular implementation of the `exports` object as a standalone object
    literally changed the use case of the `module` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Node''s CommonJS module implementation, each module is written in a single
    JavaScript file and has an isolated scope that holds its own members. The author
    of the module can expose any functionality through the `exports` object. To understand
    this better, let''s say we created a module file named `hello.js` that contains
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We also created an application file named `server.js`, which contains this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, you have the `hello` module, which contains a constant
    named `message`. The message constant is self-contained within the `hello` module,
    which only exposes the `sayHello()` method by defining it as a property of the
    `exports` object. Then, the application file loads the `hello` module using the
    `require()` method, which allows it to call the `sayHello()` method of the `hello`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'A different approach to creating modules is exposing a single function using
    the `module.exports` pointer. To understand this better, let''s revise the preceding
    example. A modified `hello.js` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the module is loaded in the `server.js` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the application file uses the `hello` module directly
    as a function, instead of using the `sayHello()` method as a property of the `hello`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: The CommonJS module standard allows the endless extension of the Node.js platform,
    while preventing the pollution of Node's core. Without it, the Node.js platform
    would become a mess of conflicts. However, not all modules are the same, and while
    developing a Node application, you will encounter several types of module.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can omit the `.js` extension when you need modules. Node will automatically
    look for a folder with that name, and if it doesn't find one, it will look for
    an applicable `.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js core modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Core modules are modules that were compiled into the Node binary. They come
    pre-bundled with Node and are explained in great detail in its documentation.
    The core modules provide most of the basic functionalities of Node, including
    filesystem access, HTTP and HTTPS interfaces, and much more. To load a core module,
    you just need to use the `require` method in your JavaScript file.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example code, using the `fs` core module to read the content of the environment
    hosts file, would look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When you require the `fs` module, Node will find it in the `core modules` folder.
    You'll then be able to use the `fs.readFile()` method to read the file's content
    and print it in the command-line output.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about Node's core modules, it is recommended you visit the official
    documentation at [http://nodejs.org/api/](http://nodejs.org/api/).
  prefs: []
  type: TYPE_NORMAL
- en: Node.js third-party modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous chapter, you learned how to use npm to install third-party
    modules. As you probably remember, npm installs these modules in a folder named
    `node_modules` under the root folder of your application. To use third-party modules,
    you can just require them as you would normally require a core module. Node will
    first look for the module in the `core modules` folder and then try to load the
    module from the `module` folder inside the `node_modules` folder. For instance,
    to use the `express` module, your code should look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Node will then look for the `express` module in the `node_modules` folder and
    load it into your application file, where you'll be able to use it as a method
    to generate the `express` application object.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js file modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous examples, you saw how Node loads modules directly from files.
    These examples describe a scenario where the files reside in the same folder.
    However, you can also place your modules inside a folder and load them by providing
    the folder path. Let''s say you moved your `hello` module to a `modules` folder.
    The application file would have to change, so Node would look for the module in
    the new relative path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the path can also be an absolute path, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Node will then look for the `hello` module in that path.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js folder modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although this is not common with developers who aren''t writing third-party
    Node modules, Node also supports the loading of folder modules. Requiring folder
    modules is done in the same way as file modules, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if a folder named `hello` exists, Node will go through that folder looking
    for a `package.json` file. If Node finds a `package.json` file, it will try parsing
    it, looking for the main property, with a `package.json` file that looks like
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Node will try to load the `./hello/hello-module.js` file. If the `package.json`
    file doesn't exist or the main property isn't defined, Node will automatically
    try to load the `./hello/index.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js modules have been found to be a great solution to write complex JavaScript
    applications. They have helped developers organize their code better, while npm
    and its third-party module registry helped them find and install one of the many
    third-party modules created by the community. Ryan Dahl's dream of building a
    better web framework ended up as a platform that supports a huge variety of solutions.
    However, the dream was not abandoned; it was just implemented as a third-party
    module named `express`.
  prefs: []
  type: TYPE_NORMAL
- en: Developing Node.js web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js is a platform that supports various types of application, but the most
    popular kind is the development of web applications. Node's style of coding depends
    on the community to extend the platform through third-party modules. These modules
    are then built upon to create new modules, and so on. Companies and single developers
    around the globe are participating in this process by creating modules that wrap
    the basic Node APIs and deliver a better starting point for application development.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many modules to support web application development, but none as
    popular as the Connect module. The Connect module delivers a set of wrappers around
    the Node.js low-level APIs to enable the development of rich web application frameworks.
    To understand what Connect is all about, let''s begin with a basic example of
    a basic Node web server. In your working folder, create a file named `server.js`
    that contains the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To start your web server, use your command-line tool and navigate to your working
    folder. Then, run the Node.js CLI tool and run the `server.js` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, open `http://localhost:3000` in your browser and you'll see the **Hello
    World** response.
  prefs: []
  type: TYPE_NORMAL
- en: So, how does this work? In this example, the `http` module is used to create
    a small web server listening to the `3000` port. You begin by requiring the `http`
    module and then use the `createServer()` method to return a new server object.
    The `listen()` method is then used to listen to the `3000` port. Notice the callback
    function that is passed as an argument to the `createServer()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The callback function gets called whenever there''s an HTTP request sent to
    the web server. The server object will then pass it the `req` and `res` arguments,
    which contain the information and functionality needed to send back an HTTP response.
    The callback function will then follow these two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it will call the `writeHead()` method of the `res` object. This method
    is used to set the response HTTP headers. In this example, it will set the content-type
    header value to `text/plain`. For instance, when responding with HTML, you just
    need to replace `text/plain` with `html/plain`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, it will call the `end()` method of the `res` object. This method is used
    to finalize the response. The `end()` method takes a single-string argument that
    it will use as the HTTP response body. Another common way of writing this is to
    add a `write()` method before the `end()` method and then call the `end()` method
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This simple application illustrates the Node coding style, where low-level APIs
    are used to simply achieve certain functionality. While this is a nice example,
    running a full web application using the low-level APIs will require you to write
    a lot of supplementary code to support common requirements. Fortunately, a company
    called Sencha has already created this scaffolding code for you in the form of
    a Node.js module called Connect.
  prefs: []
  type: TYPE_NORMAL
- en: Meet the Connect module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Connect is a module built to support the interception of requests in a more
    modular approach. In the first web server example, you learned how to build a
    simple web server using the `http` module. If you wish to extend this example,
    you'd have to write code that manages the different HTTP requests sent to your
    server, handles them properly, and provides the correct response to each request.
  prefs: []
  type: TYPE_NORMAL
- en: Connect creates an API exactly for that purpose. It uses a modular component
    called *middleware*, which allows you to simply register your application logic
    to predefined HTTP request scenarios. Connect middlewares are basically callback
    functions, which get executed when an HTTP request occurs. The middleware can
    then perform some logic, return a response, or call the next registered middleware.
  prefs: []
  type: TYPE_NORMAL
- en: While you will mostly write custom middleware to support your application needs,
    Connect also includes some common middleware to support logging, static file serving,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way a Connect application works is using an object called *dispatcher*.
    The dispatcher object handles each HTTP request received by the server and then
    decides the order of middleware execution in a cascading form. To understand Connect
    better, take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Meet the Connect module](img/B05071_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Requests execution using middleware
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram illustrates two calls made to the Connect application:
    the first is handled by a custom middleware and the second is handled by the static
    files middleware. Connect''s dispatcher initiates the process, moving on to the
    next handler using the `next()` method, until it gets to a middleware responding
    with the `res.end()` method, which will end the request handling.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll create your first Express application, but Express
    is based on Connect's approach. So, in order to understand how Express works,
    we'll begin by creating a Connect application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your working folder, create a file named `server.js` that contains the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, your application file is using the `connect` module to create
    a new web server. However, Connect isn''t a core module, so you''ll have to install
    it using npm. As you already know, there are several ways of installing third-party
    modules. The easiest one is to install it directly using the `npm install` command.
    To do so, use your command-line tool, and navigate to your working folder. Then,
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'npm will install the `connect` module inside a `node_modules` folder, which
    will enable you to require it in your application file. To run your Connect web
    server, just use Node''s CLI and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Node will run your application, reporting the server status using the `console.log()`
    method. You can try reaching your application in the browser by visiting `http://localhost:3000`.
    However, you should get a response similar to what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Meet the Connect module](img/B05071_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What this response means is that there isn't any middleware registered to handle
    the GET HTTP request. This means that first, you've successfully managed to install
    and use the Connect module, and second, it's time for you to write your first
    Connect middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Connect middleware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect middleware is basically a JavaScript function with a unique signature.
    Each middleware function is defined with the following three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`req`: This is an object that holds the HTTP request information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res`: This is an object that holds the HTTP response information and allows
    you to set the response properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`next`: This is the next middleware function defined in the ordered set of
    Connect middleware'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you have a middleware defined, you''ll just have to register it with the
    Connect application using the `app.use()` method. Let''s revise the previous example
    to include your first middleware. Change your `server.js` file to look like the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, start your Connect server again by issuing the following command in your
    command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Try visiting `http://localhost:3000` again. You will now get a response similar
    to that in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connect middleware](img/B05071_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you see the Connect application's response as that of the previous screenshot,
    then congratulations! You've just created your first Connect middleware!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s recap. First, you added a middleware function named `helloWorld()`,
    which has three arguments: `req`, `res`, and `next`. Inside your middleware function,
    you used the `res.setHeader()` method to set the response `Content-Type` header
    and the `res.end()` method to set the response text. Finally, you used the `app.use()`
    method to register your middleware with the Connect application.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the order of Connect middleware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of Connect's greatest features is the ability to register as many middleware
    functions as you want. Using the `app.use()` method, you'll be able to set a series
    of middleware functions that will be executed in a row to achieve maximum flexibility
    when writing your application. Connect will then pass the next middleware function
    to the currently executing middleware function, using the `next` argument. In
    each middleware function, you can decide whether to call the next middleware function
    or stop at the current one. Notice that each middleware function will be executed
    in a **First-In-First-Out** (**FIFO**) basis using the next arguments, until there
    are no more middleware functions to execute or the next middleware function is
    not called.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this better, we will go back to the previous example and add
    a logger function that will log all the requests made to the server in the command
    line. To do so, go back to the `server.js` file and update it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, you added another middleware called `logger()`. The
    `logger()` middleware uses the `console.log()` method to simply log the request
    information to the console. Notice how the `logger()` middleware is registered
    before the `helloWorld()` middleware. This is important, as it determines the
    order in which each middleware is executed. Another thing to notice is the `next()`
    call in the `logger()` middleware, which is responsible for calling the `helloWorld()`
    middleware. Removing the `next()` call would stop the execution of middleware
    functions at the `logger()` middleware, which means that the request would hang
    forever as the response is never ended by calling the `res.end()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your changes, start your Connect server again by issuing the following
    command in your command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Then, visit `http://localhost:3000` in your browser and notice the console output
    in your command-line tool.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting Connect middleware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you may have noticed, the middleware you registered responds to any request,
    regardless of the request path. This does not comply with modern web application
    development because responding to different paths is an integral part of all web
    applications. Fortunately, Connect middleware supports a feature called mounting,
    which enables you to determine which request path is required for the middleware
    function to get executed. Mounting is done by adding the path argument to the
    `app.use()` method. To understand this better, let''s revisit our previous example.
    Modify your `server.js` file to look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A few things have been changed in the previous example. First, you mounted the
    `helloWorld()` middleware to respond only to requests made to the `/hello` path.
    Then, you added another (a bit morbid) middleware called `goodbyeWorld()` that
    will respond to requests made to the `/goodbye` path. Notice how, as a `logger`
    should do, we left the `logger()` middleware to respond to all the requests made
    to the server. Another thing you should be aware of is that any requests made
    to the base path will not be responded to by any middleware because we mounted
    the `helloWorld()` middleware to a specific path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect is a great module that supports various features of common web applications.
    Connect middleware is super simple, as it is built with a JavaScript style in
    mind. It allows the endless extension of your application logic without breaking
    the nimble philosophy of the Node platform. While Connect is a great improvement
    over writing your web application infrastructure, it deliberately lacks some basic
    features you''re used to having in other web frameworks. The reason lies in one
    of the basic principles of the Node community: create your modules lean and let
    other developers build their modules on top of the module you created. The community
    is supposed to extend Connect with its own modules and create its own web infrastructures.
    In fact, one very energetic developer named TJ Holowaychuk did it better than
    most when he released a Connect-based web framework known as Express.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how Node.js harnesses JavaScript's event-driven
    behavior to its benefit. You also learned how Node.js uses the CommonJS module
    system to extend its core functionality. Moreover, you learned about the basic
    principles of Node.js web applications and discovered the Connect web module.
    Finally, you created your first Connect application and learned how to use middleware
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll tackle the first piece of the MEAN puzzle, when we
    discuss the Connect-based web framework called Express.
  prefs: []
  type: TYPE_NORMAL
