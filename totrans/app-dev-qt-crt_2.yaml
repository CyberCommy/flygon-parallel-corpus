- en: Chapter 2. Building Applications with Qt Creator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing you're going to want to do with Qt Creator is figure out how
    to add source files and build (or debug) your project. This chapter is all about
    that—we'll go over how to add files to your project, how to create libraries to
    your project, and use the debugger and console logger. At the end of this chapter,
    you'll be driving Qt Creator to develop your console applications like a pro.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started – our sample library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter''s example code has two pieces: a library that defines a public
    function and a console application that calls that function. Libraries are a great
    way to break up your applications, and while this example is trivial, it also
    lets me show you how to create a library and include it in your application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m going to stretch your imagination a bit: let''s pretend that you''re responsible
    for setting up a library of math functions. In this example, we''ll only write
    one function, `factorial`. You should remember the `factorial` function from introductory
    programming; it''s represented by *a!*, and is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: 0! is 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1! is 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n!* is *n × (n-1)!*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a recursive definition, and we can code it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An alternate definition that avoids the cost of function calls is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Why did I pick the recursive definition? Three reasons: I think that it''s
    clearer, function-call performance overhead isn''t a big deal in this example,
    and many readers of this book may be using this book as part of introductory computer
    science courses where recursion is taught and should be reinforced.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by creating the library that implements our `factorial` function.
    To do this:'
  prefs: []
  type: TYPE_NORMAL
- en: In Qt Creator, from the **File** menu, choose **New File or Project…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Libraries** in the left-hand pane of the dialog and **C++ Library**
    from the center pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Qt Creator can create dynamic libraries (DLLs, in Windows parlance), static
    libraries, or plugins that can be shared between applications. We're going to
    create a static library, so in the next screen choose **Statically Linked Library**,
    and name it `MathFunctions`. Choose a reasonable path for the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next step of the wizard, leave the Qt version, **Debug**, and **Release**
    items checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Libraries built by Qt Creator can rely on the Qt libraries themselves. Let's
    allow this library to rely on QtCore, the core data structures for Qt; in the
    **Select Required Modules** window, leave **QtCore** checked and click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next window, you'll name the skeleton files that Qt Creator will add
    to your project. Click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Project Management** window, choose **<None>** for the version control
    choice (we won't use version control for this project) and click on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit `mathfunctions.h` to include a static method declaration for our `factorial`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `mathfunctions.cpp`. You can do this one of two ways, by either double-clicking
    on it in the **Projects** pane, or by right-clicking on the `factorial` function
    and choosing **Switch Header/Source**. Write your `factorial` function; `mathfunctions.cpp`
    should read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Projects** button on the left, and change the output path for
    the **Release** and **Debug** builds to point to the same directory, by editing
    the **Build directory** line under **General**, first for the **Release** and
    then for **Debug** build configurations. To do this, remove the `release` and
    `debug` portions of the directory path from the **Build directory** path. This
    way, when you build your library, Qt Creator will place release and debug builds
    of your library in a single folder instead of folders named `release` and `debug`,
    respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you write the code, note that Qt Creator prompts you at various stages about
    things it can deduce from your header with automatic suggestions (called **autosuggest**).
    For example, once you type `MathFunc`, it offers to autocomplete the class name
    or the C pre-processor guard; you can select either using the mouse, or just hit
    *Enter* to get the class name. Similarly, typing the double colons tells Qt Creator
    you're trying to enter something in the `MathFunctions` class, and prompts you
    with the `MathFunctions` class members; you can use the arrows to select `factorial`
    and hit *Enter*, and it types that. Finally, typing an opening parenthesis cues
    Qt Creator that you're defining a function, and prompts you with the arguments
    to that function you defined in the header file. You'll see this autocompletion
    a lot when you type code; it's a great way to learn Qt, too, because you can type
    a class name or part of a function name and Qt Creator prompts you with helpful
    hints along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Before you continue, be sure you've built your library in both the release and
    debug configurations. The easiest way to do this is to click on the build selector
    on the bottom left and choose either **Release** or **Debug**, and then click
    on the hammer icon to perform a build.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the landscape – the Build menu and .pro files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to build applications by hitting the
    hammer button in the corner of Qt Creator's main window, or by starting the debugger.
    To just build your library—or any application—you can either use the hammer icon
    or various choices in the **Build** menu. The obvious choice is either **Build
    All** or **Rebuild All**; choosing **Build All** recompiles only those files that
    Qt Creator recognizes as those that need to be rebuilt; **Rebuild All** cleans
    the project of all object files and rebuilds the entire project from scratch.
    In most cases, it's sufficient to choose **Build All**, and that's what you want
    to do, because it's faster. Sometimes you really do want to rebuild the whole
    project, when Qt's `make` system can't reconcile all the dependencies (or, you've
    made changes to the dependencies). Choose **Build All** now, and wait for it to
    build while we discuss the other options.
  prefs: []
  type: TYPE_NORMAL
- en: The **Build** menu lets you build a single file—handy, if all you want to do
    is check the syntax of the code you're writing and make sure you're free of errors—or
    the entire project. It also lets you run the project outside of the debugger,
    which you might want to do in some circumstances, like giving a demonstration.
    You can also clean your project (remove all object files and other autogenerated
    products) by choosing **Clean All**. The **Publish** option is available for some
    add-on kits that let you publish compiled applications and libraries to application
    stores and repositories; you can find more details about that in the documentation
    of any Qt Creator add-in, such as the SDKs for Maemo development (an older Linux
    variant from Nokia for handheld devices).
  prefs: []
  type: TYPE_NORMAL
- en: 'Behind every Qt Creator project is a `.pro` file; this serves the same function
    as a `make` file, and, in fact, is processed by a Qt toolkit command called `qmake`.
    (Make files are files processed by the `make` command, which indicate what files
    should be compiled in what order to generate an executable.) These files are declarative,
    in that you declare the relationship between the files that make up your application,
    and `qmake` figures out how to build your application from there. In most cases
    you''ll need to make few or no changes to a `.pro` file, but it doesn''t hurt
    to understand how they work. Double-click on `MathFunctions.pro`, and you''ll
    find:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The basic syntax of a `.pro` file is variable assignments; this file, generated
    by Qt Creator for us, assigns the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: The `QT` variable indicates the Qt modules your project will link against. By
    default, all projects include QtCore and QtGui; there's a plethora of other modules
    available, which include key features such as the WebKit web browsing engine (`QtWebkit`)
    and multimedia libraries (`Phonon`). Our assignment here, indicates that we use
    the default Qt modules, but don't link against `QtGui`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TARGET` variable is the name of the compiled library or executable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TEMPLATE` variable indicates the kind of `qmake` template `qmake` should
    use to generate the binary; in our case, we're saying it should use the template
    to create a `lib` file—a library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CONFIG` variable passes an additional configuration to the template of
    `qmake`; here, we say that we want a statically linked library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SOURCES` and `HEADERS` variables contain lists of the source and header
    files that make up your project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `INSTALLS` variable indicates where the resulting build product should be
    installed. Here, it's set in a scope. Scopes let you specify conditional options
    in `qmake`; the condition for the scope is a variable or expression, which may
    be `true` or `false`, and the code that follows is executed if the variable is
    `true`. The scope at the end of this file says, "If we're building for a `unix`
    variant and the variant isn't `symbian`, set the `target.path` variable to `/opt/usr/lib`
    if the `unix` variant is `maemo`, otherwise set it to `/usr/lib` for other `unix`
    variants, and in either case, set the `INSTALLS` variable to `target`".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the basic variables you'll find in almost any `.pro` file; for a good
    discussion of `qmake` scopes you can use to control conditional compilation, see
    [http://bit.ly/163tAIh](http://bit.ly/163tAIh). Two additional variables you're
    likely to want to know about are `DEFINES` and `LIBS`; `DEFINES` lets you specify
    preprocessor defines that should be set throughout the build process, and `LIBS`
    indicates additional libraries against which Qt Creator should link your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note how variables are managed: you use `=` for assignment, `+=` to add an
    item to a list, and `-=` to remove an item from a list.'
  prefs: []
  type: TYPE_NORMAL
- en: Linking against our sample library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s make an application that depends on our library. Our application
    will call the `factorial` function in the library, statically linking to the library
    to access the `factorial` function. To accomplish this, you need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose **Close All Projects and Editors** from the **File** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **New File or Project…** from the **File** menu, and create a new Qt
    console application called `MathFunctionsTest` using the wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on **MathFunctionsTest**, and choose **Add Library**. You can then
    choose a library in your build tree, one outside your build tree, or an external
    library on your system like the Unix math library, `ffmpeg`, or another library
    you've created. Choose **External Library** and click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse to the library file that was built in the previous section by clicking
    on **Browse** next to the line labeled **Library file**. It'll be in a folder
    named something like `build-MathFunctions-Desktop_Qt_5_0_2_MSVC2012_64bit` in
    your project's folder. Choose the `MathFunctions` library in either the `release`
    or `debug` folders—it doesn't matter which.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse to include files for your library by clicking on **Browse** next to **Include
    path**; this is the directory where you put the headers for your library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose static linking; if you were linking a dynamically linked library, of
    course you'd choose **Dynamic**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the other values set to their defaults, click on **Next** and then on
    **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Qt Creator will work its magic with your .pro file, adding a `LIBS` variable
    that includes the output of your library build and an include path to your library's
    header files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now call our `factorial` function. Edit `main.cpp` to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code first includes our library header file. Note that if you compile the
    application after adding just the `#include` declaration, you'll get autosuggest
    help for every element of the `MathFunctions` library. This code uses `qDebug`
    instead of the C standard library to perform its console output.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `qDebug()` function actually has a stream-savvy implementation too. I could
    have written the `qDebug` line as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: and the code would have generated the same output.
  prefs: []
  type: TYPE_NORMAL
- en: Now, build and run the application in debug mode; you should see a console window
    with the text `6! is 720`. Try building and running the library in release mode;
    wait, why is the debugging output from `qDebug` still there?
  prefs: []
  type: TYPE_NORMAL
- en: '`qDebug` isn''t really a debugging log, it''s an output stream for debugging
    information regardless of build levels. If you want to turn off its output in
    release builds, you''ll need to edit the `.pro` file. Double-click on your `.pro`
    file, and add the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is another scope: it says that if your build configuration is release,
    add the preprocessor definition `QT_NO_DEBUG_OUTPUT` to the list of preprocessor
    definitions for the project.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you rebuild (don't just choose build, but actually choose rebuild, because
    you want a clean build through the entire system) and run in release mode, you
    won't see any output.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Qt actually defines four output streams, one for debugging messages and one
    for bona fide warnings. Use `qDebug` for regular logging and `qWarning` to output
    messages of a higher priority. There''s also `qCritical` and `qFatal` for higher-priority
    log messages that should indicate critical failures, or failures that cause the
    application to terminate. You can also turn off warnings in release builds the
    same way; simply add the following to your `.pro` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'What if you want to add files to your project? You can either do it by manually
    editing the `.pro` file, which can be faster if you''re a good typist, but also
    error prone and result in weird build problems if you mess up, or right-click
    on your project and choose either **Add New…** or **Add Existing Files…**. The
    **Add New…** option opens up a short wizard with choices like these:'
  prefs: []
  type: TYPE_NORMAL
- en: C++ header and source files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt Designer forms that we'll talk about in the next chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt Resource files that we'll talk about in the next chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt Quick Markup (QML) files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript files (which can contain the code implementing the logic of a Qt
    Quick application)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenGL shaders for fragments or vertices in either full OpenGL or OpenGL/ES
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text files (like a `Readme` file for your project) or a scratch file to use
    as a place to stash temporary clipboard items until you're done with an editing
    session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we move on to the important topic of debugging, let''s look at one more
    `.pro` file, the `.pro` file for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Phew! That's pretty dense. Let's see if we can unravel it. It begins by telling
    the build system that we use QtCore, but not QtGui. Next up, is the instruction
    to disable the `qDebug` messages in release builds, which won't happen by default.
    The `TARGET`, `CONFIG`, and `TEMPLATE` options together say that we're building
    a console application with the name `MathFunctionsTest`. The next line indicates
    that we have one source file, `main.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: The next set of scopes indicates the path to our library, and handles the fact
    that our libraries are in different directories on Windows for `release` and `debug`—this
    is different from on Unix systems, where there is only one `build` variant of
    the library. After that, comes the `INCLUDEPATH` and `DEPENDPATH` variables, which
    indicate that there are library headers in the `MathFunctions` directory, and
    that the application depends on those headers. So, if the timestamps on the headers
    change, the binary should rebuild. The final scope specifies the same dependency
    on the output library itself; if the library changes, the application executable
    has to be rebuilt. This is especially important, because that way we can run multiple
    copies of Qt Creator, edit our library and application files separately, building
    the bits we need of either after they change. When we do so that way, all the
    dependencies get figured out and the right bits of the library and application
    get built automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Getting lost and found again – debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt Creator has a state-of-the-art GUI that hooks into either the GNU debugger
    GDB, or Microsoft's command-line debugger CDB, if you use Microsoft tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve installed Qt Creator on Mac OS or Linux, or the MinGW version of
    Qt Creator for Windows, you have everything you need to begin debugging your application.
    If you already had Microsoft Visual Studio installed and installed a version of
    Qt Creator that uses Microsoft''s compiler, you need to also install the Microsoft
    command-line debugger to use Qt Creator''s debugging features. Here''s how to
    install the command-line debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the debugging tools for Windows, at either [http://bit.ly/1dWoqi0](http://bit.ly/1dWoqi0)
    if you are using the 32-bit version of the compiler and Qt Creator, or [http://bit.ly/12kEtGt](http://bit.ly/12kEtGt)
    for the 64-bit version of the compiler and Qt Creator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the debugging symbol server by going to **Options** under the **Tools**
    menu, choosing the **Debugger** item on the left, choosing the **CDB** pane, and
    clicking on **Edit** next to the **Symbol Paths** line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually, the debugger works out of the box with Qt Creator, unless you're using
    the Microsoft toolchain. However, if you encounter problems, consult the Qt documentation
    on setting up the debugger at [http://bit.ly/19jgycQ](http://bit.ly/19jgycQ).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the debugger in action with our test project,
    stopped at a breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting lost and found again – debugging](img/2319OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Qt Creator's Debug view in action
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the screenshot in detail to get oriented:'
  prefs: []
  type: TYPE_NORMAL
- en: On the left is the usual row of buttons to pick a view in Qt Creator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next to the buttons is the view of the project files and the list of open documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the main editor pane, every source line has a clickable indicator to let
    you set and clear breakpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The call stack, indicating how the program got to the line execution is stopped
    at, is shown in the pane below the editor pane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the upper right is the variable inspector, where you can see the values of
    the variables in the current stack frame, along with any global variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Below the variable inspector is a list of pending breakpoints, so you can turn
    on and off breakpoints without needing to hunt through the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To generate the previous screenshot, I clicked on the left of line **7**, placing
    a breakpoint, and then clicked on the **Debug** button on the left after ensuring
    I'd specified a debug build in the build selector. Qt Creator built the application
    in debug mode, started the application, and let it run to the breakpoint on line
    **7**.
  prefs: []
  type: TYPE_NORMAL
- en: Setting breakpoints and stepping through your program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A breakpoint, if you haven't encountered the idea before, is just that—a point
    at which execution breaks and you can examine the program's state. Once stopped
    at a breakpoint, you can step into a function, or step over a line, executing
    your program one line at a time to see how it's behaving. In the **Debug** view,
    clicking on the left of the number line lets you set or clear breakpoints. While
    stopped at a breakpoint, a yellow arrow in the margin of the editor pane indicates
    the line of code that the processor is about to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'While at a breakpoint, several buttons appear above the call stack pane that
    let you control program flow. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: The green continue button, which continues execution at the line indicated by
    the arrow. You can also continue by pressing the *F5* function key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The red stop button, which stops debugging altogether.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The step over button, which executes the current line and advances to the next
    line before stopping again. You can step over one line by pressing *F10*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The step into button, which enters the next function to be called and stops
    again. You can step into a function by pressing *F11*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The step out button, which runs the remainder of the function in the current
    calling context before stopping again. You can step out of the current function
    by pressing *F11*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instruction-wise button (which looks like a little screen), which toggles
    the debugger between working a source line at a time and an assembly line at a
    time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's also a menu of threads, so you can see which thread is running or stopped.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If (in the previous screenshot) from line **7** we step over line **8** (pressing
    *F10*) and then press *F11*, we'll end up inside our `factorial` function, as
    you see in the next screenshot. I've clipped the screenshot so you only see the
    relevant panes of the debugger that have changed, and resized the window a bit,
    so you can see the whole call stack.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting breakpoints and stepping through your program](img/2319OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The debugger about to enter a function
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, if we step one more line (*F10*) again, we''ll see the value
    for **n** change in the right-hand column, and the arrow advance to point at line
    **9** (again, as numbered in the screenshot). From here, we can debug my function
    in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: We can examine the contents of a variable by looking at it in the right-hand
    pane. If it's in a stack frame above the current calling frame, we can change
    call frames and see variables in a different call frame too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can modify a variable by clicking on its value and entering a new value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With some debuggers, we can move the arrow to different lines in the calling
    function to skip one or more lines of code, or rewind the execution to re-run
    a segment of code over again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This last feature—which unfortunately doesn't work with CDB—is especially powerful,
    because we can step through a program, observe an error, modify variables to work
    around the course of the error, and continue testing our code without needing
    to recompile our code and re-run our executable. Or, we can skip a bit of code
    that we know takes a while to run by substituting the new state in the variables
    in question and continuing from a new location in the current call frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also a number of other things we can do, from how we debug the application
    to various ways we can view the state of our application when it''s running. On
    the main **Debug** menu, we can:'
  prefs: []
  type: TYPE_NORMAL
- en: Detach the debugger from a running process by choosing **Detach** from the **Debug**
    menu (handy if the debugger is slowing things down and we know that part of our
    code doesn't need to be debugged).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interrupt program execution, stop execution, and examine the current state by
    choosing **Interrupt** from the **Debug** menu (useful if our application seems
    caught in a long loop we weren't expecting and appears hung).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While stopped, we can run to the line the cursor is on by choosing **Run to
    Line** or press *Ctrl* + *F10*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While stopped, we can skip to the line the cursor is on by choosing **Jump to
    Line**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fine-grained control of breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you right-click in the breakpoint pane, you can add, edit, or delete breakpoints.
    Hitting **Add Breakpoint…** or **Edit Breakpoint…** brings up the Breakpoint Editor,
    a daunting dialog given the humble breakpoint itself. The following screenshot
    shows the Breakpoint Editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fine-grained control of breakpoints](img/2319OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Breakpoint Editor window
  prefs: []
  type: TYPE_NORMAL
- en: 'From the editor, you can fine-tune a breakpoint, setting:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The kind of breakpoint. Most breakpoints are by filename and line number—a
    specific line of the code—but you have several other choices, including:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The entry point of a function by name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a memory address is reached for execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a C++ exception is thrown or caught
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a JavaScript exception occurs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When your main function starts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a new process is forked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a system call occurs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When data is accessed at a fixed location, or an address indicated by an expression
    involving a pointer variable at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The location of the breakpoint (such as the source line number and filename,
    or the function), depending on your choice from the previous list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the breakpoint is enabled or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the breakpoint is one-shot, that is, will be disabled after it fires
    once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditions for the breakpoint, such as an expression in involving program variable
    values, how many times to ignore the breakpoint, and which threads the breakpoint
    applies to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining variables and memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The variables pane shows you the values of all the variables in the current
    stack frame. Structures show the values of their members, so you can walk through
    complex data structures as well. From the variables pane, you can also copy a
    variable name and value to the clipboard, or just a variable value.
  prefs: []
  type: TYPE_NORMAL
- en: From the variables pane, there's a really useful feature called the **Expression
    Evaluator**, which lets you construct algebraic expressions about variables in
    your code and see the results. For example, if I'm stopped at the beginning of
    the `factorial` function, as you see in the *The debugger about to enter a function*
    screenshot, with **n** set to `6`, I can right-click on the variables pane, choose
    **Insert New Expression Evaluator**, and type in a formula `n*(n-1)` in the dialog
    that appears, and a new line appears in the pane showing the expression and the
    value **30**. While this is a pretty contrived example, I can view pointer values
    and pointer dereferences as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can also conditionally break execution when a variable changes; this is called
    a conditional breakpoint or a data breakpoint. For example, let''s put a loop
    in our main function, and break as we execute the loop. To do this, first change
    `main` to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will walk the values stored in the integer array values, and print the
    computed factorial of each value. Start debugging again, and let''s add a data
    breakpoint on `i`. To do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Put a breakpoint on the first line of `main`, the line initializing `QCoreApplication.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on `i` in the left pane and choose **Add Data Breakpoint at Object's
    Address** from the **Add Data Breakpoint** submenu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue by pressing *F5* or the **Continue** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execution will stop at line **11**, the beginning of the `for` loop, when `i`
    is set to `0`. Each time I hit *F5* to continue, the application runs until the
    value of `i` changes as a result of the `i++` statement at the end of the `for`
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: You can also inspect and change individual values of arrays in the variable
    inspector, by clicking on the expansion arrow next to the array name in the variable
    inspector pane.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to viewing and changing variable values, you can also view and
    change individual memory locations. You might want to do that if you''re debugging
    a decoder or encoder for a binary format, for example, where you need to see a
    specific location in memory. From the variables pane, you have several choices:'
  prefs: []
  type: TYPE_NORMAL
- en: You can right-click on a given variable and open a memory window at that variable's
    address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can right-click on a given variable and open a memory window at the value
    that the variable points to (in other words, dereference a pointer to a memory
    location)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can right-click on the variable pane and open up a memory browser at the
    beginning of the current stack frame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can right-click on the variable pane and open up a memory browser at an
    arbitrary location in memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the memory viewer showing the memory that contains
    the values of the array values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining variables and memory](img/2319OS_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Memory Viewer window
  prefs: []
  type: TYPE_NORMAL
- en: 'The window shows the memory addresses down the left, the values of memory at
    sixteen bytes to a line (first in hexadecimal and then in ASCII), and colors the
    actual variable you''ve selected to open the window. You can select a range of
    values and then right-click to perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the values in ASCII or hexadecimal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set a data breakpoint on the memory location you've selected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transfer execution to the address you've clicked (probably not what you want
    to do if you're viewing the data)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining the call stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **call stack** is the hierarchy of function calls in your application execution
    at a point in time. Although the actual flow varies, typically in your code it
    begins in `main`, although what calls `main` differs from platform to platform.
    An obvious use for the call stack is to provide context when you press the **Interrupt**
    button; if your program is just off contemplating its navel in a loop somewhere,
    clicking on **Interrupt** and looking at the call stack can give you a clue as
    to what's going on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember how I defined the `factorial` function in terms of itself? You can
    see this very clearly if you put a breakpoint in `factorial`, call it, and continue
    through the breakpoint a few times before looking at the call stack; you''ll see
    something akin to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining the call stack](img/2319OS_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The call stack of a recursive function in mid-computation
  prefs: []
  type: TYPE_NORMAL
- en: Working from left to right, the fields of the call stack window are the stack
    level (numbering from the top of the stack down), the function being invoked,
    the file the function is defined in, and the line number of the function currently
    being executed. So, this stack frame says that we're on line **9** of `MathFunctions::factorial`
    in `mathfunctions.cpp`, called by line **13** of **MathFunctions::factorial**,
    which is called by line **13** of `MathFunctions::factorial` and so on, until
    it bottoms out in our `main` function, and the system startup code that the operating
    system uses to set up the application process before that.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you right-click on a line of the call stack pane, you can:'
  prefs: []
  type: TYPE_NORMAL
- en: Reload the stack, in case the display appears corrupted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the contents of the call stack to the clipboard; it is great for bug reports.
    If your application throws an exception or crashes in the debugger, you can copy
    the call stack and send it off to the developer responsible for that part of the
    code (or keep it for yourself as a souvenir).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open the memory editor at the address of the instruction at the line of code
    indicated by the function call in the call stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open the disassembler at the address of the instruction at the line of code
    indicated by the function call in the call stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disassemble a region of memory or the current function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show the program counter address in the call stack window while debugging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Projects pane and building your project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've seen how the `.pro` file affects your project's compilation, but there's
    even more to it than that. If you click the **Projects** button on the left of
    Qt Creator, you'll see the project's options, which consist of the **Build & Run**
    options, the **Editor** options, the **Code Style** options, and **Dependencies**,
    each in their own panel.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you won't need to monkey around with any of these settings. But
    you may need to tinker with the **Build & Run** settings, especially if you're
    targeting multiple platforms, such as Windows and Linux with cross-compilers,
    or Android and iOS once Digia finishes support for those platforms. (I write more
    about this exciting development in Qt later in this book.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The final thing you should know about is the build and run kit selector. Qt
    is one of the best cross-platform toolkits available today, and you can easily
    find yourself working on a system supporting multiple platforms, such as Linux
    and Android, or multiple versions of Qt. To support this, Qt has the notion of
    a build kit, which is just the headers, libraries, and associated stuff to support
    a specific platform. You can install multiple build kits, and choose which build
    kit you''re compiling against by choosing **Open Build** and **Run Kit Selector….**.
    By default, if you followed the steps in the previous chapter to install Qt Creator,
    you''ll have one build kit installed; from the Digia site, you can choose others.
    In a later chapter, we''ll build a sample application for Qt on Android. To do
    this, you''d need to download and install the Qt on Android build kit, and then
    tell Qt Creator about the new kit. Adding kits is easy, you just need to install
    the kit using your operating system, and then do the following in Qt Creator:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Projects** on the left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Manage Kits…** on the upper left-hand side of the pane that appears.
    The **Build & Run** options window appears.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Qt may autodetect your new kit, or you may need to add it by clicking on **Add**.
    Once you click on **Add**, you'll need to specify the target platform (such as
    an Android device), the compiler to use, and so forth.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the build settings, there are configuration options for your release and
    debug builds. In the **Build Settings** editor, you can control whether the build
    products are placed in their own directory (the default, a so-called shadow build
    where your build outputs are mixed with the source code), the `qmake` configuration
    for the build (and actually see how Qt Creator will invoke `qmake`), how Qt Creator
    cleans your project, and any environment variables you need to set for the build.
  prefs: []
  type: TYPE_NORMAL
- en: The run settings let you control whether your application runs locally or is
    deployed on a remote host (not always supported, but usually the case for platforms
    such as Android), any command-line arguments you want to pass to your applications,
    and the settings for the performance analyzer tool, which I will talk more about
    in [Chapter 4](ch04.html "Chapter 4. Localizing Your Application with Qt Linguist"),
    *Localizing Your Application with Qt Linguist*.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Editor** panel, you can set specific editor options for this project.
    These override the global Qt Creator defaults, which you can set by choosing **Options**
    from the **Tools** menu and selecting the **Text Editor** option. These options
    include details like whether to use tabs or spaces when formatting your code (I
    strongly suggest you use spaces; it's compatible with editors everywhere), the
    number of spaces per tab stop, whether or not automatic indentation occurs, how
    source files should be encoded, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: The **Code Style** panel is another override to the global settings for Qt Creator
    (this time, it's the C++ and Qt Quick panels of the **Options** dialog available
    from the **Options** menu). Here, you can pick default styles, or edit the styles.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I'd strongly recommend that you pick a style that matches the existing source
    code you're editing; if you're starting from a blank page, the Qt default style
    is quite readable, and is my favorite.
  prefs: []
  type: TYPE_NORMAL
- en: The **Dependencies** panel lets you set the build order if your project file
    contains multiple subprojects, so that things build in the right order. For example,
    we could choose to open both our library project and our test project; if we do,
    we'll see the `MathFunctions` library listed in the dependencies, and we can select
    that project to build before the test application is built.
  prefs: []
  type: TYPE_NORMAL
- en: A review – running and debugging your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ll spend a lot of time editing, compiling, and debugging your code in
    Qt Creator, so, it''s wise to remember the following basics:'
  prefs: []
  type: TYPE_NORMAL
- en: The arrow key runs your application without the debugger; to debug your application,
    choose the arrow key with the bug icon on it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can switch between the editor view and the debug view of your application
    by clicking on the **Edit** or **Debug** view choice on the left; if you debug
    your application, Qt Creator will enter the debug view automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more to breakpoints than just stopping at a line of code! Use data breakpoints
    to help pin down weird bugs that happen only sometimes, or to quickly skip over
    the first bazillion items of a large loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable pane lets you see more than just the contents of variables; you
    can also add expressions composed of several variables and arithmetic, or view
    arbitrary memory locations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Want to hack around a bug during a debugging session? You can change the values
    of variables in the variable pane and continue running, changing the program state
    as you go.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt Creator's integrated development environment contains an editor and tools
    to start the compiler, linker, and debugger to build and debug your applications.
    Using it, you can start and stop your application, place breakpoints while your
    application is stopped, or examine variables or the logical flow of your application.
  prefs: []
  type: TYPE_NORMAL
- en: While Qt Creator manages most of a project for you, sometimes you just have
    to get down and dirty with a `.pro` file. You can use scopes to handle conditional
    compilation (things like when building for a specific platform, or whether a file
    should be included in release or debug mode). The `.pro` file consists of scopes,
    variables, and their values; by setting the variables that the `.pro` file feeds
    `qmake`, `qmake` understands the dependencies in your project and magically creates
    a Make file to build your application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll turn from the mechanics of making a project build
    and look at Qt Creator's UI designer, and give you a brief introduction into the
    worlds of both Qt Widgets and Qt Quick.
  prefs: []
  type: TYPE_NORMAL
