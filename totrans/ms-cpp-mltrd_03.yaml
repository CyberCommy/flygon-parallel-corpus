- en: C++ Multithreading APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While C++ has a native multithreading implementation in the **Standard Template
    Library** (**STL**), OS-level and framework-based multithreading APIs are still
    very common. Examples of these APIs include Windows and **POSIX** (**Portable
    Operating System Interface**) threads, and those provided by the `Qt`, `Boost`,
    and `POCO` libraries.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter takes a detailed look at the features provided by each of these
    APIs, as well as the similarities and differences between each of them. Finally,
    we'll look at common usage scenarios using example code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics covered by this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A comparison of the available multithreading APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of the usage of each of these APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before the **C++ 2011** (**C++11**) standard, many different threading implementations
    were developed, many of which are limited to a specific software platform. Some
    of these are still relevant today, such as Windows threads. Others have been superseded
    by standards, of which **POSIX Threads** (**Pthreads**) has become the de facto
    standard on UNIX-like OSes. This includes Linux-based and BSD-based OS, as well
    as OS X (macOS) and Solaris.
  prefs: []
  type: TYPE_NORMAL
- en: Many libraries were developed to make cross-platform development easier. Although
    Pthreads helps to make UNIX-like OS more or less compatible one of the prerequisites
    to make software portable across all major operating systems, a generic threading
    API is needed. This is why libraries such as Boost, POCO, and Qt were created.
    Applications can use these and rely on the library to handle any differences between
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: POSIX threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pthreads were first defined in the `POSIX.1c` standard (*Threads extensions*,
    IEEE Std 1003.1c-1995) from 1995 as an extension to the POSIX standard. At the
    time, UNIX had been chosen as a manufacturer-neutral interface, with POSIX unifying
    the various APIs among them.
  prefs: []
  type: TYPE_NORMAL
- en: Despite this standardization effort, differences still exist in Pthread implementations
    between OS's which implement it (for example, between Linux and OS X), courtesy
    of non-portable extensions (marked with `_np` in the method name).
  prefs: []
  type: TYPE_NORMAL
- en: For the `pthread_setname_np` method, the Linux implementation takes two parameters,
    allowing one to set the name of a thread other than the current thread. On OS
    X (since 10.6), this method only takes one parameter, allowing one to set the
    name of the current thread only. If portability is a concern, one has to be mindful
    of such differences.
  prefs: []
  type: TYPE_NORMAL
- en: After 1997, the POSIX standard revisions were managed by the Austin Joint Working
    Group. These revisions merge the threads extension into the main standard. The
    current revision is 7, also known as POSIX.1-2008 and IEEE Std 1003.1, 2013 edition--with
    a free copy of the standard available online.
  prefs: []
  type: TYPE_NORMAL
- en: 'OS''s can be certified to conform to the POSIX standard. Currently, these are
    as mentioned in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Developer** | **Since version** | **Architecture(s) (current)**
    | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| AIX | IBM | 5L | POWER | Server OS |'
  prefs: []
  type: TYPE_TB
- en: '| HP-UX | Hewlett-Packard | 11i v3 | PA-RISC, IA-64 (Itanium) | Server OS |'
  prefs: []
  type: TYPE_TB
- en: '| IRIX | Silicon Graphics (SGI) | 6 | MIPS | Discontinued |'
  prefs: []
  type: TYPE_TB
- en: '| Inspur K-UX | Inspur | 2 | X86_64, | Linux based |'
  prefs: []
  type: TYPE_TB
- en: '| Integrity | Green Hills Software | 5 | ARM, XScale, Blackfin, Freescale Coldfire,
    MIPS, PowerPC, x86. | Real-time OS |'
  prefs: []
  type: TYPE_TB
- en: '| OS X/MacOS | Apple | 10.5 (Leopard) | X86_64 | Desktop OS |'
  prefs: []
  type: TYPE_TB
- en: '| QNX Neutrino | BlackBerry | 1 | Intel 8088, x86, MIPS, PowerPC, SH-4, ARM,
    StrongARM, XScale | Real-time, embedded OS |'
  prefs: []
  type: TYPE_TB
- en: '| Solaris | Sun/Oracle | 2.5 | SPARC, IA-32 (<11), x86_64, PowerPC (2.5.1)
    | Server OS |'
  prefs: []
  type: TYPE_TB
- en: '| Tru64 | DEC, HP, IBM, Compaq | 5.1B-4 | Alpha | Discontinued |'
  prefs: []
  type: TYPE_TB
- en: '| UnixWare | Novell, SCO, Xinuos | 7.1.3 | x86 | Server OS |'
  prefs: []
  type: TYPE_TB
- en: 'Other operating systems are mostly compliant. The following are examples of
    the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Platform** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| Android | ARM, x86, MIPS | Linux based. Bionic C-library. |'
  prefs: []
  type: TYPE_TB
- en: '| BeOS (Haiku) | IA-32, ARM, x64_64 | Limited to GCC 2.x for x86. |'
  prefs: []
  type: TYPE_TB
- en: '| Darwin | PowerPC, x86, ARM | Uses the open source components on which macOS
    is based. |'
  prefs: []
  type: TYPE_TB
- en: '| FreeBSD | IA-32, x86_64, sparc64, PowerPC, ARM, MIPS, and so on | Essentially
    POSIX compliant. One can rely on documented POSIX behavior. More strict on compliance
    than Linux, in general. |'
  prefs: []
  type: TYPE_TB
- en: '| Linux | Alpha, ARC, ARM, AVR32, Blackfin, H8/300, Itanium, m68k, Microblaze,
    MIPS, Nios II, OpenRISC, PA-RISC, PowerPC, s390, S+core, SuperH, SPARC, x86, Xtensa,
    and so on | Some Linux distributions (see previous table) are certified as being
    POSIX compliant. This does not imply that every Linux distribution is POSIX compliant.
    Some tools and libraries may differ from the standard.For Pthreads, this may mean
    that the behavior is sometimes different between Linux distributions (different
    scheduler, and so on) as well as compared to other OS''s implementing Pthreads.
    |'
  prefs: []
  type: TYPE_TB
- en: '| MINIX 3 | IA-32, ARM | Conforms to POSIX specification standard 3 (SUSv3,
    2004). |'
  prefs: []
  type: TYPE_TB
- en: '| NetBSD | Alpha, ARM, PA-RISC, 68k, MIPS, PowerPC, SH3, SPARC, RISC-V, VAX,
    x86, and so on | Almost fully compatible with POSX.1 (1990), and mostly compliant
    with POSIX.2 (1992). |'
  prefs: []
  type: TYPE_TB
- en: '| Nuclear RTOS | ARM, MIPS, PowerPC, Nios II, MicroBlaze, SuperH, and so on
    | Proprietary RTOS from Mentor Graphics aimed at embedded applications. |'
  prefs: []
  type: TYPE_TB
- en: '| NuttX | ARM, AVR, AVR32, HCS12, SuperH, Z80, and so on | Light-weight RTOS,
    scalable from 8 to 32-bit systems with strong focus on POSIX compliance. |'
  prefs: []
  type: TYPE_TB
- en: '| OpenBSD | Alpha, x86_64, ARM, PA-RISC, IA-32, MIPS, PowerPC, SPARC, and so
    on | Forked from NetBSD in 1995\. Similar POSIX support. |'
  prefs: []
  type: TYPE_TB
- en: '| OpenSolaris/illumos | IA-32, x86_64, SPARC, ARM | Compliant with the commercial
    Solaris releases being certified compatible. |'
  prefs: []
  type: TYPE_TB
- en: '| VxWorks | ARM, SH-4, x86, x86_64, MIPS, PowerPC | POSIX compliant, with certification
    for user-mode execution environment. |'
  prefs: []
  type: TYPE_TB
- en: From this it should be obvious that it's not a clear matter of following the
    POSIX specification, and being able to count on one's code compiling on each of
    these platforms. Each platform will also have its own set of extensions to the
    standard for features which were omitted in the standard, but are still desirable.
    Pthreads are, however, widely used by Linux, BSD, and similar software.
  prefs: []
  type: TYPE_NORMAL
- en: Windows support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s also possible to use the POSIX APIs in a limited fashion using, for example,
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Compliance** |'
  prefs: []
  type: TYPE_TB
- en: '| Cygwin | Mostly complete. Provides a full runtime environment for a POSIX
    application, which can be distributed as a normal Windows application. |'
  prefs: []
  type: TYPE_TB
- en: '| MinGW | With MinGW-w64 (a redevelopment of MinGW), Pthreads support is fairly
    complete, though some functionality may be absent. |'
  prefs: []
  type: TYPE_TB
- en: '| Windows Subsystem for Linux | WSL is a Windows 10 feature, which allows a
    Ubuntu Linux 14.04 (64-bit) image''s tools and utilities to run natively on top
    of it though not those using GUI features or missing kernel features. Otherwise,
    it offers similar compliance as Linux.This feature currently requires that one
    runs the Windows 10 Anniversary Update and install WSL by hand using instructions
    provided by Microsoft. |'
  prefs: []
  type: TYPE_TB
- en: POSIX on Windows is generally not recommended. Unless there are good reasons
    to use POSIX (large existing code base, for example), it's far easier to use one
    of the cross-platform APIs (covered later in this chapter), which smooth away
    any platform issues.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we'll look at the features offered by the Pthreads
    API.
  prefs: []
  type: TYPE_NORMAL
- en: PThreads thread management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These are all the functions which start with either `pthread_` or `pthread_attr_`.
    These functions all apply to threads themselves and their attribute objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic use of threads with Pthreads looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The main Pthreads header is `pthread.h`. This gives access to everything but
    semaphores (covered later in this section). We also define a constant for the
    number of threads we wish to start here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We define a simple `Worker` function, which we'll pass to the new thread in
    a moment. For demonstration and debugging purposes one could first add a simple
    `cout` or `printf`-based bit of business logic to print out the value sent to
    the new thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define the `main` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We create all of the threads in a loop in the preceding function. Each thread
    instance gets a thread ID assigned (first argument) when created in addition to
    a result code (zero on success) returned by the `pthread_create()` function. The
    thread ID is the handle to reference the thread in future calls.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument to the function is a `pthread_attr_t` structure instance,
    or 0 if none. This allows for configuration characteristics of the new thread,
    such as the initial stack size. When zero is passed, default parameters are used,
    which differ per platform and configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third parameter is a pointer to the function which the new thread will
    start with. This function pointer is defined as a function which returns a pointer
    to void data (that is, custom data), and accepts a pointer to void data. Here,
    the data being passed to the new thread as an argument is the thread ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Next, we wait for each worker thread to finish using the `pthread_join()` function.
    This function takes two parameters, the ID of the thread to wait for, and a buffer
    for the return value of the `Worker` function (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: 'Other functions to manage threads are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void pthread_exit`(`void *value_ptr`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This function terminates the thread calling it, making the provided argument's
    value available to any thread calling `pthread_join()` on it.
  prefs: []
  type: TYPE_NORMAL
- en: '`int pthread_cancel`(`pthread_t` thread):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This function requests that the specified thread will be canceled. Depending
    on the state of the target thread, this will invoke its cancellation handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond this, there are the `pthread_attr_*` functions to manipulate and obtain
    information about a `pthread_attr_t` structure.
  prefs: []
  type: TYPE_NORMAL
- en: Mutexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These are functions prefixed with either `pthread_mutex_` or `pthread_mutexattr_`.
    They apply to mutexes and their attribute objects.
  prefs: []
  type: TYPE_NORMAL
- en: Mutexes in Pthreads can be initialized, destroyed, locked, and unlocked. They
    can also have their behavior customized using a `pthread_mutexattr_t` structure,
    which has its corresponding `pthread_mutexattr_*` functions for initializing and
    destroying an attribute on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic use of a Pthread mutex using static initialization looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this last bit of code, we use the `PTHREAD_MUTEX_INITIALIZER` macro, which
    initializes the mutex for us without having to type out the code for it every
    time. In comparison to other APIs, one has to manually initialize and destroy
    mutexes, though the use of macros helps somewhat.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we lock and unlock the mutex. There's also the `pthread_mutex_trylock()`
    function, which is like the regular lock version, but which will return immediately
    if the referenced mutex is already locked instead of waiting for it to be unlocked.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the mutex is not explicitly destroyed. This is, however, a
    part of normal memory management in a Pthreads-based application.
  prefs: []
  type: TYPE_NORMAL
- en: Condition variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These are functions which are prefixed with either `pthread_cond_` or `pthread_condattr_`.
    They apply to condition variables and their attribute objects.
  prefs: []
  type: TYPE_NORMAL
- en: Condition variables in Pthreads follow the same pattern of having an initialization
    and a `destroy` function in addition to having the same for managing a `pthread_condattr_t`
    attribution structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example covers basic usage of Pthreads condition variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we get the standard headers, and define a count trigger
    and limit, whose purpose will become clear in a moment. We also define a few global
    variables: a count variable, the IDs for the threads we wish to create, as well
    as a mutex and condition variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This preceding function, essentially, just adds to the global counter variable
    after obtaining exclusive access to it with the `count_mutex`. It also checks
    whether the count trigger value has been reached. If it has, it will signal the
    condition variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give the second thread, which also runs this function, a chance to get the
    mutex, we sleep for 1 second in each cycle of the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this second function, we lock the global mutex before checking whether we
    have reached the count limit yet. This is our insurance in case the thread running
    this function does not get called before the count reaches the limit.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, we wait on the condition variable providing the condition variable
    and locked mutex. Once signaled, we unlock the global mutex, and exit the thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'A point to note here is that this example does not account for spurious wake-ups.
    Pthreads condition variables are susceptible to such wake-ups which necessitate
    one to use a loop and check whether some kind of condition has been met:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in the `main` function, we create the three threads, with two running
    the function which adds to the counter, and the third running the function which
    waits to have its condition variable signaled.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, we also initialize the global mutex and condition variable.
    The threads we create further have the "joinable" attribute explicitly set.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we wait for each thread to finish, after which we clean up, destroying
    the attribute structure instance, mutex, and condition variable before exiting.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `pthread_cond_broadcast()` function, it's further possible to signal
    all threads which are waiting for a condition variable instead of merely the first
    one in the queue. This enables one to use condition variables more elegantly with
    some applications, such as where one has a lot of worker threads waiting for new
    dataset to arrive without having to notify every thread individually.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions which implement synchronization are prefixed with `pthread_rwlock_`
    or `pthread_barrier_`. These implement read/write locks and synchronization barriers.
  prefs: []
  type: TYPE_NORMAL
- en: A **read/write lock** (**rwlock**) is very similar to a mutex, except that it
    has the additional feature of allowing infinite threads to read simultaneously,
    while only restricting write access to a singular thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `rwlock` is very similar to using a mutex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last code, we include the same general header, and either use the initialization
    function, or the generic macro. The interesting part is when we lock `rwlock`,
    which can be done for just read-only access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the second variation returns immediately if the lock has been locked
    already. One can also lock it for write access as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: These functions work basically the same, except that only one writer is allowed
    at any given time, whereas multiple readers can obtain a read-only lock.
  prefs: []
  type: TYPE_NORMAL
- en: Barriers are another concept with Pthreads. These are synchronization objects
    which act like a barrier for a number of threads. All of these have to reach the
    barrier before any of them can proceed past it. In the barrier initialization
    function, the thread count is specified. Only once all of these threads have called
    the `barrier` object using the `pthread_barrier_wait()` function will they continue
    executing.
  prefs: []
  type: TYPE_NORMAL
- en: Semaphores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Semaphores were, as mentioned earlier, not part of the original Pthreads extension
    to the POSIX specification. They are declared in the `semaphore.h` header for
    this reason.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, semaphores are simple integers, generally used as a resource count.
    To make them thread-safe, atomic operations (check and lock) are used. POSIX semaphores
    support the initializing, destroying, incrementing and decrementing of a semaphore
    as well as waiting for the semaphore to reach a non-zero value.
  prefs: []
  type: TYPE_NORMAL
- en: Thread local storage (TLC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With Pthreads, TLS is accomplished using keys and methods to set thread-specific
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the worker thread, we allocate a new integer on the heap, and set the global
    key to its own value. After increasing the global variable by 1, its value will
    be 2, regardless of what the other threads do. We can set the global variable
    to 0 once we''re done with it for this thread, and delete the allocated value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A global key is set and used to reference the TLS variable, yet each of the
    threads we create can set its own value for this key.
  prefs: []
  type: TYPE_NORMAL
- en: While a thread can create its own keys, this method of handling TLS is fairly
    involved compared to the other APIs we're looking at in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Windows threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Relative to Pthreads, Windows threads are limited to Windows operating systems
    and similar (for example ReactOS, and other OS's using Wine). This provides a
    fairly consistent implementation, easily defined by the Windows version that the
    support corresponds to.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to Windows Vista, threading support missed features such as condition
    variables, while having features not found in Pthreads. Depending on one's perspective,
    having to use the countless "type def" types defined by the Windows headers can
    be a bother as well.
  prefs: []
  type: TYPE_NORMAL
- en: Thread management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A basic example of using Windows threads, as adapted from the official MSDN
    documentation sample code, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After including a series of Windows-specific headers for the thread functions,
    character strings, and more, we define the number of threads we wish to create
    as well as the size of the message buffer in the `Worker` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also define a struct type (passed by `void pointer: LPVOID`) to contain
    the sample data we pass to each worker thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the `Worker` function, we cast the provided parameter to our custom struct
    type before using it to print its values to a string, which we output on the console.
  prefs: []
  type: TYPE_NORMAL
- en: We also validate that there's an active standard output (console or similar).
    The functions used to print the string are all thread safe.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, an error handler function is defined, which obtains the system error message
    for the last error code. After obtaining the code for the last error, the error
    message to be output is formatted, and shown in a message box. Finally, the allocated
    memory buffers are freed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `main` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the `main` function, we create our threads in a loop, allocate memory for
    thread data, and generate unique data for each thread before starting the thread.
    Each thread instance is passed its own unique parameters.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we wait for the threads to finish and rejoin. This is essentially
    the same as calling the `join` function on singular threads with Pthreads--only
    here, a single function call suffices.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, each thread handle is closed, and we clean up the memory we allocated
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced thread management with Windows threads includes jobs, fibers, and thread
    pools. Jobs essentially allow one to link multiple threads together into a singular
    unit, enabling one to change properties and the status of all these threads in
    one go.
  prefs: []
  type: TYPE_NORMAL
- en: Fibers are light-weight threads, which run within the context of the thread
    which creates them. The creating thread is expected to schedule these fibers itself.
    Fibers also have **Fiber Local Storage** (**FLS**) akin to TLS.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Windows threads API provides a Thread Pool API, allowing one to
    easily use such a thread pool in one's application. Each process is also provided
    with a default thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Windows threads, mutual exclusion and synchronization can be accomplished
    using critical sections, mutexes, semaphores, **slim reader/writer** (**SRW**)
    locks, barriers, and variations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Synchronization objects include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Event | Allows for signaling of events between threads and processes using
    named objects. |'
  prefs: []
  type: TYPE_TB
- en: '| Mutex | Used for inter-thread and process synchronization to coordinate access
    to shared resources. |'
  prefs: []
  type: TYPE_TB
- en: '| Semaphore | Standard semaphore counter object, used for inter-thread and
    process synchronization. |'
  prefs: []
  type: TYPE_TB
- en: '| Waitable timer | Timer object usable by multiple processes with multiple
    usage modes. |'
  prefs: []
  type: TYPE_TB
- en: '| Critical section | Critical sections are essentially mutexes which are limited
    to a single process, which makes them faster than using a mutex due to lack of
    kernel space calls. |'
  prefs: []
  type: TYPE_TB
- en: '| Slim reader/writer lock | SRWs are akin to read/write locks in Pthreads,
    allowing multiple readers or a single writer thread to access a shared resource.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Interlocked variable access | Allows for atomic access to a range of variables
    which are otherwise not guaranteed to be atomic. This enables threads to share
    a variable without having to use mutexes. |'
  prefs: []
  type: TYPE_TB
- en: Condition variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implementation of condition variables with Windows threads is fairly straightforward.
    It uses a critical section (`CRITICAL_SECTION`) and condition variable (`CONDITION_VARIABLE`)
    along with the condition variable functions to wait for a specific condition variable,
    or to signal it.
  prefs: []
  type: TYPE_NORMAL
- en: Thread local storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Thread local storage** (**TLS**) with Windows threads is similar to Pthreads
    in that a central key (TLS index) has to be created first after which individual
    threads can use that global index to store and retrieve local values.'
  prefs: []
  type: TYPE_NORMAL
- en: Like with Pthreads, this involves a similar amount of manual memory management,
    as the TLS value has to be allocated and deleted by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Boost
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boost threads is a relatively small part of the Boost collection of libraries.
    It was, however, used as the basis for what became the multithreading implementation
    in C++11, similar to how other Boost libraries ultimately made it, fully or partially,
    into new C++ standards. Refer to the C++ threads section in this chapter for details
    on the multithreading API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Features missing in the C++11 standard, which are available in Boost threads,
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Thread groups (like Windows jobs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread interruption (cancellation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread join with timeout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional mutual exclusion lock types (improved with C++14)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unless one absolutely needs such features, or if one cannot use a compiler which
    supports the C++11 standard (including STL threads), there is little reason to
    use Boost threads over the C++11 implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Since Boost provides wrappers around native OS features, using native C++ threads
    would likely reduce overhead depending on the quality of the STL implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt is a relatively high-level framework, which also reflects in its multithreading
    API. Another defining feature of Qt is that it wraps its own code (QApplication
    and QMainWindow) along with the use of a meta-compiler (`qmake`) to implement
    its signal-slot architecture and other defining features of the framework.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, Qt's threading support cannot be added into existing code as-is,
    but requires one to adapt one's code to fit the framework.
  prefs: []
  type: TYPE_NORMAL
- en: QThread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `QThread` class in Qt is not a thread, but an extensive wrapper around a
    thread instance, which adds signal-slot communication, runtime support, and other
    features. This is reflected in the basic usage of a QThread, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This preceding code is a basic `Worker` class, which will contain our business
    logic. It derives from the `QObject` class, which also allows us to use signal-slot
    and other intrinsic `QObject` features. Signal-slot architecture at its core is
    simply a way for listeners to register on (connect to) signals declared by QObject-derived
    classes, allowing for cross-module, cross-thread and asynchronous communication.
  prefs: []
  type: TYPE_NORMAL
- en: It has a single, which can be called to start processing, and two signals--one
    to signal completion, and one to signal an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The constructor could be extended to include parameters. Any heap-allocated
    variables (using `malloc` or `new`) must be allocated in the `process()` method,
    and not in the constructor due to the thread context the `Worker` instance will
    be operating in, as we will see in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new QThread, we would use the following setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The basic procedure is to create a new QThread instance on the heap (so it won't
    go out of scope) along with a heap-allocated instance of our `Worker` class. This
    new worker would then be moved to the new thread instance using its `moveToThread()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Next, one will connect the various signals to relevant slots including our own
    `finished()` and `error()` signals. The `started()` signal from the thread instance
    would be connected to the slot on our worker which will start it.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, one has to connect some kind of completion signal from the
    worker to the `quit()` and `deleteLater()` slots on the thread. The `finished()`
    signal from the thread will then be connected to the `deleteLater()` slot on the
    worker. This will ensure that both the thread and worker instances are cleaned
    up when the worker is done.
  prefs: []
  type: TYPE_NORMAL
- en: Thread pools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt offers thread pools. These require one to inherit from the `QRunnable` class,
    and implement the `run()` function. An instance of this custom class is then passed
    to the `start` method of the thread pool (global default pool, or a new one).
    The life cycle of this worker is then handled by the thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Qt offers the following synchronization objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QMutex`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QReadWriteLock`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QSemaphore`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QWaitCondition` (condition variable)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These should be fairly self-explanatory. Another nice feature of Qt's signal-slot
    architecture is that these also allow one to communicate asynchronously between
    threads without having to concern oneself with the low-level implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: QtConcurrent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The QtConcurrent namespace contains high-level API aimed at making writing multithreading
    applications possible without having to concern oneself with the low-level details.
  prefs: []
  type: TYPE_NORMAL
- en: Functions include concurrent filtering and mapping algorithms as well as a method
    to allow running a function in a separate thread. All of these return a `QFuture`
    instance, which contains the result of an asynchronous operation.
  prefs: []
  type: TYPE_NORMAL
- en: Thread local storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Qt offers TLS through its `QThreadStorage` class. Memory management of pointer
    type values is handled by it. Generally, one would set some kind of data structure
    as a TLS value to store more than one value per thread, as described, for example,
    in the `QThreadStorage` class documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: POCO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The POCO library is a fairly lightweight wrapper around operating system functionality.
    It does not require a C++11 compatible compiler or any kind of pre-compiling or
    meta-compiling.
  prefs: []
  type: TYPE_NORMAL
- en: Thread class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Thread` class is a simple wrapper around an OS-level thread. It takes
    `Worker` class instances which inherit from the `Runnable` class. The official
    documentation provides a basic example of this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This preceding code is a very simple "Hello world" example with a worker which
    only outputs a string via the standard output. The thread instance is allocated
    on the stack, and kept within the scope of the entry function waiting for the
    worker to finish using the `join()` function.
  prefs: []
  type: TYPE_NORMAL
- en: With many of its thread functions, POCO is quite reminiscent of Pthreads, though
    it does deviate significantly on points such as configuring a thread and other
    objects. Being a C++ library, it sets properties using class methods rather than
    filling in a struct and passing it as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Thread pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'POCO provides a default thread pool with 16 threads. This number can be changed
    dynamically. Like with regular threads, a thread pool requires one to pass a `Worker`
    class instance which inherits from the `Runnable` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The worker instance is added to the thread pool, which runs it. The thread pool
    cleans up threads which have been idle for a certain time when we add another
    worker instance, change the capacity, or call `joinAll()`. As a result, the single
    worker thread will join, and with no active threads left, the application exits.
  prefs: []
  type: TYPE_NORMAL
- en: Thread local storage (TLS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With POCO, TLS is implemented as a class template, allowing one to use it with
    almost any type.
  prefs: []
  type: TYPE_NORMAL
- en: 'As detailed by the official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this preceding worker example, we create a static TLS variable using the
    `ThreadLocal` class template, and define it to contain an integer.
  prefs: []
  type: TYPE_NORMAL
- en: Because we define it as static, it will only be created once per thread. In
    order to use our TLS variable, we can use either the arrow (`->`) or asterisk
    (`*`) operator to access its value. In this example, we increase the TLS value
    once per cycle of the `for` loop until the limit has been reached.
  prefs: []
  type: TYPE_NORMAL
- en: This example demonstrates that both threads will generate their own series of
    10 integers, counting through the same numbers without affecting each other.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The synchronization primitives offered by POCO are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Mutex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FastMutex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semaphore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RWLock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Noticeable here is the `FastMutex` class. This is generally a non-recursive
    mutex type, except on Windows, where it is recursive. This means one should generally
    assume either type to be recursive in the sense that the same mutex can be locked
    multiple times by the same thread.
  prefs: []
  type: TYPE_NORMAL
- en: One can also use mutexes with the `ScopedLock` class, which ensures that a mutex
    which it encapsulates is released at the end of the current scope.
  prefs: []
  type: TYPE_NORMAL
- en: Events are akin to Windows events, except that they are limited to a single
    process. They form the basis of condition variables in POCO.
  prefs: []
  type: TYPE_NORMAL
- en: POCO condition variables function much in the same way as they do with Pthreads
    and others, except that they are not subject to spurious wake-ups. Normally condition
    variables are subject to these random wake-ups for optimization reasons. By not
    having to deal with explicitly having to check whether its condition was met or
    not upon a condition variable wait returning less burden is placed on the developer.
  prefs: []
  type: TYPE_NORMAL
- en: C++ threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The native multithreading support in C++ is covered extensively in [Chapter
    5](part0090.html#2LQIK0-1ab5991b318547348fc444437bdacb24), *Native C++ Threads
    and Primitives*.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier in the Boost section of this chapter, the C++ multithreading
    support is heavily based on the Boost threads API, using virtually the same headers
    and names. The API itself is again reminiscent of Pthreads, though with significant
    differences when it comes to, for example, condition variables.
  prefs: []
  type: TYPE_NORMAL
- en: Upcoming chapters will use the C++ threading support exclusively for examples.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of the APIs covered in this chapter, only the Qt multithreading API can be considered
    to be truly high level. Although the other APIs (including C++11) have some higher-level
    concepts including thread pools and asynchronous runners which do not require
    one to use threads directly, Qt offers a full-blown signal-slot architecture,
    which makes inter-thread communication exceptionally easy.
  prefs: []
  type: TYPE_NORMAL
- en: As covered in this chapter, this ease also comes with a cost, namely, that of
    having to develop one's application to fit the Qt framework. This may not be acceptable
    depending on the project.
  prefs: []
  type: TYPE_NORMAL
- en: Which of these APIs is the right one depends on one's requirements. It is, however,
    relatively fair to say that using straight Pthreads, Windows threads, and kin
    does not make a lot of sense when one can use APIs such as C++11 threads, POCO,
    and so on, which ease the development process with no significant reduction in
    performance while also gaining extensive portability across platforms.
  prefs: []
  type: TYPE_NORMAL
- en: All the APIs are at least somewhat comparable at their core in what they offer
    in features.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked in some detail at a number of the more popular multithreading
    APIs and frameworks, putting them next to each other to get an idea of their strengths
    and weaknesses. We went through a number of examples showing how to implement
    basic functionality using each of these APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look in detail at how to synchronize threads and
    communicate between them.
  prefs: []
  type: TYPE_NORMAL
