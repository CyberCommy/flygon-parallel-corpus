- en: MySQL 8 Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to use MySQL 8 command-line programs
    and utilities to perform various operations on the MySQL 8 database. It is always
    good to have hold on command-line tools. It provides flexibility to work in non-GUI
    environments. The focus of this chapter is data types. Isn't it fascinating to
    know the type of data the programming language supports or the storage engine
    can store? It is a fundamental feature of any programming language or database.
    At the same time, it is the most ignored topic, as well. The majority of programmers
    don't spend enough time assessing the storage requirements for `variables` used
    in a piece of code. Actually, it is extremely important to understand the basic
    and custom data types that the database supports, which is why this chapter exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of topics to be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of MySQL 8 data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numeric data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date and time data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON data type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage requirements for data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the right data type for columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of MySQL 8 data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All standard SQL data types are supported in MySQL. These data types are classified
    in a few categories, such as numeric types, string types, date and time types,
    and the JSON data type. When we assign a data type to a column, certain conventions
    must be followed. These conventions are necessary for MySQL to allow values to
    be stored in a column:'
  prefs: []
  type: TYPE_NORMAL
- en: '**M** denotes the maximum display width for integer types. For floating point
    and fixed point types, it is the total number of digits that can be stored. For
    string types, it is the maximum length. The maximum value allowed depends on the
    data type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D** is applicable to floating points and fixed point types. It denotes the
    number of digits after the decimal point. The maximum allowed value is 30, but
    must be less than or equal to M-2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**fsp** is applicable to date and time types. It denotes the fractional seconds
    precision, which means the number of digits following the decimal point for the
    fractional part of seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This overview is brief so that the detailed descriptions of the features of
    each data type can be covered in topics to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MySQL 8 numeric data types include integer or exact data types, decimal
    or approximate data types, and bit data types.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `REAL` data type values are stored as `DOUBLE`. If we have set the
    `REAL_AS_FLOAT` flag on MySQL, `REAL` data type values are stored as `FLOAT`.
    `FLOAT` occupies less space compared to `DOUBLE`.
  prefs: []
  type: TYPE_NORMAL
- en: Integer types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All standard SQL integer types are supported by MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a table describing the required storage and range for each
    integer type. Along with standard integer data types, MySQL also supports `TINYINT`,
    `MEDIUMINT`, and `BIGINT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Storage (Bytes)** | **Minimum Value** | **Maximum Value** |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | **Signed / Unsigned** | **Signed / Unsigned** |'
  prefs: []
  type: TYPE_TB
- en: '| `TINYINT` | 1 | -128 | 127 |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | 0 | 255 |'
  prefs: []
  type: TYPE_TB
- en: '| `SMALLINT` | 2 | -32768 | 32767 |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | 0 | 65535 |'
  prefs: []
  type: TYPE_TB
- en: '| `MEDIUMINT` | 3 | -8388608 | 8388607 |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | 0 | 16777215 |'
  prefs: []
  type: TYPE_TB
- en: '| `INT` | 4 | -2147483648 | 2147483647 |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | 0 | 4294967295 |'
  prefs: []
  type: TYPE_TB
- en: '| `BIGINT` | 8 | -9223372036854775808 | 9223372036854775807 |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | 0 | 18446744073709551615 |'
  prefs: []
  type: TYPE_TB
- en: Reference: [https://dev.mysql.com/doc/refman/8.0/en/integer-types.html](https://dev.mysql.com/doc/refman/8.0/en/integer-types.html)
  prefs: []
  type: TYPE_NORMAL
- en: The range of signed numbers includes both -ve and +ve numbers, whereas the range
    of unsigned numbers includes +ve numbers only.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the column declaration for the unsigned integer column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`INT` and `INTEGER` can be used interchangeably. But consider if we declared
    a column as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The maximum value that an `INTEGER` column can store is either 2147483647 (in
    case of a signed `INTEGER`) or 4294967295 (in case of an unsigned `INTEGER`). `255`
    here defines the visible length of a number. On the one handed, it is impractical
    to display a number `255` digits long. On the other hand, `INTEGER` supports 10
    digit numbers as a maximum value. So, it will be converted to `INT(11)` in the
    preceding case. Now, this raises another question: if the number of digits for
    a maximum integer number is 10, then why should it be converted to `INT(11)` and
    not `INT(10)`? The reason is that one digit is kept for storing the sign.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ZEROFILL` is an attribute which indicates that the number value should be
    prefixed with zeros if the length of the number value is smaller than the length
    of the column. The `CREATE` statement demonstrates a way to declare a column with
    the `ZEROFILL` attribute. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We specified the value to be stored as `111`; it will be stored as `00111` if
    we provided the `ZEROFILL` option.
  prefs: []
  type: TYPE_NORMAL
- en: Fixed point types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fixed point types represent numbers with a fixed number of digits after the
    decimal or radix point. MySQL has `DECIMAL` and `NUMERIC` as fixed point, or exact,
    value data types. These values are stored in a binary format. Fixed point data
    types are useful, especially in storing monetary values in multiplication and
    division operations. The value of a fixed point data type is an integer number
    scaled by a specific factor, according to the type. For example, the value of
    1.11 can be represented in fixed point as `111`, with a scaling factor of 1/100\.
    Similarly, 1,110,000 can be represented as `1110`, with a scaling factor of 1000.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block demonstrates the declaration of a `DECIMAL` data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, `3` is the precision and `2` is the scale. An example
    value could be 4.65, where `4` is the precision and `65` is the scale:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Precision**: Denotes the number of significant digits stored for the values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scale**: Represents the number of digits after the decimal point'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Precision and scale define the range of values that can be stored in the column.
    So, in the preceding column declaration, `tax_rate` can store values falling between
    -9.99 and 9.99.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for defining the `DECIMAL` type in standard SQL is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In MySQL, this is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Declaring a column with `DECIMAL` is equivalent to `DECIMAL(M, 0)` in MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: In MySQL, 10 is the default value for `M`, if it's not provided.
  prefs: []
  type: TYPE_NORMAL
- en: The maximum number of digits supported for the `DECIMAL` type is 65, including
    precision and scale. We can limit the number of digits on values which can be
    entered for a column by using precision and scale. If a user enters a value with
    a larger number of digits than permitted in scale, the value will be truncated
    to match the permitted scale.
  prefs: []
  type: TYPE_NORMAL
- en: '`DECIMAL` is often considered to be an alternative to `DOUBLE` or `FLOAT`.
    As mentioned earlier, `DECIMAL` numbers are an exact representation of `REAL`
    numbers in mathematics. The only problem with the `DECIMAL` data type is that
    it occupies much more space, even for small numbers. For example, to store a value
    of 0.000003, the column declaration should have the data type defined as `DECIMAL(7,
    6)`.'
  prefs: []
  type: TYPE_NORMAL
- en: If the scale is `0`, the column values don't have decimal points or fractional
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Floating point types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Floating point numbers represent real numbers in computing. Real numbers are
    useful for measuring continuous values, such as weight, height, or speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL has two floating point data types for storing approximate values: `FLOAT`
    and `DOUBLE`.'
  prefs: []
  type: TYPE_NORMAL
- en: For floating point numbers, precision is an important factor. Precision defines
    the measure of accuracy. MySQL supports single precision and double precision
    floating point numbers. It consumes four bytes to store a single precision floating
    point number with the `FLOAT` data type, whereas it consumes eight bytes to store
    a double precision floating point number with the `DOUBLE` data type.
  prefs: []
  type: TYPE_NORMAL
- en: In MySQL, `REAL` is a synonym for `DOUBLE PRECISION`. As mentioned earlier,
    if `REAL_AS_FLOAT` is enabled, a column defined with the `REAL` data type will
    be treated similarly to `FLOAT`.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding description depicts `FLOAT` or `DOUBLE` as similar to `DECIMAL`.
    No, it is not. There is a huge difference. As described earlier, fixed point data
    types such as `DECIMAL` or `NUMERIC` can store exact values, up to the maximum
    digit after the decimal point, whereas floating point data types, such as `FLOAT`
    or `DOUBLE`, store approximate values. The values stored are detailed enough,
    but not completely accurate. There remains a minor inaccuracy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand this through the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a table containing `FLOAT` and `DECIMAL` type columns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We inserted the same values in two columns, named `float_values` and `decimal_values`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We executed a `select` query to fetch the sum of stored values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Though the same values, the output is different. The sum of `decimal_values`
    looks more precise compared to that of the `float_values`. The sum of `float_values`
    looks less precise. This is because of internal rounding performed by the MySQL
    engine for floating point data types, which results in the approximation stored
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Standard SQL has a provision for specifying precision while defining a `FLOAT`
    column. The precision is in bits specified following the keyword `FLOAT` within
    parenthesis. MySQL also supports specifying precision values for `FLOAT` or `DOUBLE`,
    but the precision is used to determine the size:'
  prefs: []
  type: TYPE_NORMAL
- en: Precision from 0 to 23 results in a 4 byte single precision `FLOAT` column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Precision from 24 to 53 results in an 8 byte double precision `DOUBLE` column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of `FLOAT` column declaration attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the column defined as the following will store a value such as 99.99:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: While storing floating point values, MySQL performs rounding. So, the value
    inserted as 99.09 into a `FLOAT(4, 2)` column may be stored as 99.01 as an approximate
    result.
  prefs: []
  type: TYPE_NORMAL
- en: Though the floating point column definition supports specifying precision, it
    is advisable to use `FLOAT` or `DOUBLE PRECISION` with no precision or number
    of digits, so as to take advantage of maximum flexibility and portability.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with floating point values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described earlier, floating point data types store approximate real numbers.
    Trying to store an exact value and use it in comparison operations considering
    exact values may lead to various problems. Also, floating point values are interpreted
    in a platform and implementation-dependent manner. For example, different CPUs
    or operating systems may evaluate floating point numbers differently. This essentially
    means that the value intended to be stored in the floating point data type column
    may not be the same as the actual value stored or represented internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous point becomes essential when we use floating point numbers in
    comparison. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, it seems that the first two rows in the output have
    similar numbers. It is possible that they might not be, in the case of floating
    point types. If we want to ensure, in the preceding case, that similar-looking
    values are considered, we have to compare the difference against a predefined
    number with precision. For example, in the preceding case, if we modify the `HAVING`
    clause to check the condition `ABS(v1 - v2) > 0.1`, it will return the expected
    output.
  prefs: []
  type: TYPE_NORMAL
- en: As interpretation of floating point numbers is platform dependent, if we try
    to insert a value which is outside of the range of floating point data type supported
    values, it may insert +- inf or +- 0.
  prefs: []
  type: TYPE_NORMAL
- en: Bit value type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever come across a requirement to store binary representations of numbers?
    Can you think of such use cases? One such use case is to store weekly working
    days information for a year. We will touch base on this example later in the section.
  prefs: []
  type: TYPE_NORMAL
- en: The `BIT` data type is used to store binary bits or groups of bit values. It
    is also one of the options to store Boolean, yes/no or `0/1` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BIT` type column can be defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For a `BIT` data type, `m` can vary from `1` to `64`. Supplying `m` is optional.
    The default value for `m` is `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of how a `BIT` column can be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: After the `BIT` data type column declaration, next is storing bit values in
    a column. The bit values are a combination of zeros (0s) and ones (1s). The `b'value'`
    notation is used to specify bit values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the examples of how to store 11 and 55 in a `BIT` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: What happens if the value stored in the `BIT` column is less than the number
    of bits (`m`) specified in the column definition? MySQL will pad the value with
    0s on the left of the number. So, for the preceding example, the values stored
    will be 0001011 and 0110111, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we define a `BIT` column to store `boolean_values`? The following code
    block shows that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Bit value literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To store bit values in a table column, we must understand bit literals. As mentioned
    earlier, bit literals can be written using the `b'val'` notation. There is another
    notation, which is the `0bval` notation.
  prefs: []
  type: TYPE_NORMAL
- en: One important note about `b'val'` or `0bval` notations is that the letter case
    of the leading `b` doesn't matter. We can specify `b` or `B`. A leading `0b` is
    case-sensitive, and can't be replaced with `0B`.
  prefs: []
  type: TYPE_NORMAL
- en: The following is the list of legal and illegal bit value literals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Legal bit value literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '`b''10''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`B''11''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0b10`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Illegal bit value literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '`b''3''` (`1` and `0` are the only binary digits)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0B01` (`0B` is not valid; it should be `0b`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a default, a bit literal is a binary string. We can confirm this with the
    query, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Practical uses of BIT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's continue with the working days per week in a year example. Please refer
    to the `working_days` table schema provided earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we specify that the Monday and Friday in the week `4` in the year `2017`
    are non-working days? The following is the `INSERT` query for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we fetch the `working_days` records using the `SELECT` query, the following
    is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, the days, though being of bit data types, show integer
    values. How can we show bit values in the output?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is the `BIN()` MySQL function. The function converts an integer
    value to its binary representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the leading zeros are removed from the days'' bit value in
    the output. To accomplish the representation in the output, on top of the `BIN`
    function, we can use the `LPAD` MySQL function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Type attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As shown earlier, while defining integer columns, we can also specify an optional
    display width attribute. For example, `INT(5)` indicates an integer number with
    a display width of `5` digits. When this column is used in the `SELECT` query,
    the output will display the number left padded with spaces. So, if the value stored
    in the `INT(5)` column is `123`, then it will be displayed as `__123`. The `_`
    will be a space in the actual output.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the display width doesn''t limit the range of values which can be
    stored in the `INT(5)` column. The question then arises: What if we store a value
    for which the display width is larger than the display width specified? The display
    width doesn''t prevent values wider than the display width of a column from being
    displayed correctly. So, values wider than the column display width are displayed
    in full width, using more than the number of digits specified with the display
    width.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, MySQL column definition provides an optional attribute
    called `ZEROFILL`. This optional attribute, when specified, replaces left padded
    spaces with zeros. For example, for a column defined as the following, a value
    of 82 is retrieved as 00082:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This optional attribute is useful where the proper formatting of numbers is
    important.
  prefs: []
  type: TYPE_NORMAL
- en: The `ZEROFILL` attribute is ignored when the column value is used in expressions
    or in a `UNION` query.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL creates temporary tables when complicated joins are used in a query to
    store intermediate results. In such a case, we may face issues if we specified
    a column with display width. In these cases, MySQL considers that the data values
    fit within the display width.
  prefs: []
  type: TYPE_NORMAL
- en: Another important attribute is `UNSIGNED`. The `UNSIGNED` attribute permits
    only non-negative values to be stored in the column. It is also useful when we
    need support for a larger range of values to be stored with the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: '`UNSIGNED` is also supported by floating point types and fixed point types.'
  prefs: []
  type: TYPE_NORMAL
- en: If we specify a `ZEROFILL` attribute for a column, `UNSIGNED` is automatically
    added to the column.
  prefs: []
  type: TYPE_NORMAL
- en: Another important attribute for integer and floating point columns is `AUTO_INCREMENT`.
    When we insert a `NULL` value in the column defined with the `AUTO_INCREMENT`
    attribute, MySQL stores `value+1` instead of `NULL`. A value of 0 will be treated
    the same as that of a `NULL` value, unless the `NO_AUTO_VALUE_ON_ZERO` mode is
    enabled. Here, the value is the largest value stored in the column. It is extremely
    important that the column is defined as `NOT NULL`. Otherwise, the `NULL` value
    will be stored as `NULL`, even though the `AUTO_INCREMENT` attribute is provided.
  prefs: []
  type: TYPE_NORMAL
- en: Overflow handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When an out-of-range value is stored in the numeric type column in MySQL, the
    value stored depends on the MySQL mode:'
  prefs: []
  type: TYPE_NORMAL
- en: If `strict` mode is enabled, MySQL will not accept the value and throw an error.
    The `insert` operation fails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `restrictive` modes are enabled, the value is clipped by MySQL to an appropriate
    value, and that is what is stored in the column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date and time data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`DATE`, `TIME`, `DATETIME`, `TIMESTAMP`, and `YEAR` form the group of date
    and time data types for storing temporal values. Each of these types has a range
    of permitted values. Apart from the permitted values, a special `zero` value can
    also be used to specify an invalid value which MySQL cannot represent. The zero
    value can be 00-00-0000\. MySQL allows this value to be stored in a `date` column.
    This is sometimes more convenient than storing `NULL` values.'
  prefs: []
  type: TYPE_NORMAL
- en: The following are the general considerations we must take care of while working
    with date and time types.
  prefs: []
  type: TYPE_NORMAL
- en: The way MySQL treats storage and retrieval operations for date or time types
    is different in the context of the format. Basically, for a date or time type
    value stored in the table, MySQL retrieves values in a standard output format.
    In the case of inputting a date or time type value, MySQL attempts to apply different
    formats on the supplied input value. So, it is expected that the supplied value
    is valid, or unexpected results may occur if used values in unsupported formats.
  prefs: []
  type: TYPE_NORMAL
- en: Though MySQL can interpret input values with several different formats, parts
    of the date value must be supplied in a year-month-day format. For example, 2017-10-22
    or 16-02-14.
  prefs: []
  type: TYPE_NORMAL
- en: 'Supplying a two-digit year creates ambiguity for MySQL to interpret the year
    because of the unknown century. The following are the rules that must be followed,
    using which MySQL interprets two-digit year values:'
  prefs: []
  type: TYPE_NORMAL
- en: Year values between 70-99 are converted to 1970-1999
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Year values between 00-69 are converted to 2000-2069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to convert a value from one temporal type to another temporal
    type following certain rules. We will discuss these rules later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If the date or time value is used in a numeric context, MySQL will automatically
    convert the value to a number.
  prefs: []
  type: TYPE_NORMAL
- en: We have one interesting use case. We want to develop an audit log feature where
    we store every user-entered value. Suppose that in one of the date fields, the
    user entered an invalid date, 2017-02-31\. Will this be stored in the audit log
    table? Certainly not. How do we complete the feature, then? MySQL has the `ALLOW_INVALID_DATES`
    mode. If enabled, it will allow invalid dates to be stored. With this mode enabled,
    MySQL verifies that the month is in the range of 1-12 and day is in the range
    of 1-31.
  prefs: []
  type: TYPE_NORMAL
- en: As ODBC cannot handle zero values for date or time, such values used through
    Connector/ODBC are converted to `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following table shows zero values for different data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data Type** | **Zero Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `DATE` | 0000-00-00 |'
  prefs: []
  type: TYPE_TB
- en: '| `TIME` | 00:00:00 |'
  prefs: []
  type: TYPE_TB
- en: '| `DATETIME` | 0000-00-00 00:00:00 |'
  prefs: []
  type: TYPE_TB
- en: '| `TIMESTAMP` | 0000-00-00 00:00:00 |'
  prefs: []
  type: TYPE_TB
- en: '| `YEAR` | 0000 |'
  prefs: []
  type: TYPE_TB
- en: Reference: [https://dev.mysql.com/doc/refman/8.0/en/date-and-time-types.html](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-types.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding table shows `zero` values for different temporal data types.
    These are special values, as these are allowed by MySQL and are very useful in
    certain cases. We can also specify `zero` values using `''0''` or `0`. MySQL has
    an interesting mode configuration: `NO_ZERO_DATE`. If this configuration is enabled,
    MySQL shows a warning if the temporal type has a value with the date as `zero`.'
  prefs: []
  type: TYPE_NORMAL
- en: DATE, DATETIME, and TIMESTAMP types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section describes the most commonly used MySQL date and time data types: `DATE`,
    `DATETIME`, and `TIMESTAMP`. This section explains the similarities and differences
    between these data types.
  prefs: []
  type: TYPE_NORMAL
- en: The `DATE` data type is suitable when the values we wish to store have a date
    part, but the time part is missing. The standard MySQL date format is YYYY-MM-DD.
    The date values are retrieved and displayed in the standard format unless `DATE`
    functions are applied. The MySQL supported range of values is 1000-01-01 to 9999-12-31\.
    Supported, here, means the values may work, but there is no guarantee. The same
    is the case for the `DATETIME` data type.
  prefs: []
  type: TYPE_NORMAL
- en: The `DATETIME` data type is suitable for values containing date and time parts.
    The standard MySQL `DATETIME` format is YYYY-MM-DD HH:MM:SS. The supported range
    of values is 1000-01-01 00:00:00 to 9999-12-31 23:59:59.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to `DATETIME`, the `TIMESTAMP` data type is also suitable for values
    containing date and time parts. However, the range of values supported by the `TIMESTAMP`
    data type is 1970-01-01 00:00:01 UTC to 2038-01-19 03:14:07 UTC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though they look similar, the `DATETIME` and `TIMESTAMP` data types differ
    significantly:'
  prefs: []
  type: TYPE_NORMAL
- en: The `TIMESTAMP` data type requires 4 bytes to store date and time values. The `DATETIME`
    data type requires 5 bytes to store date and time values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TIMESTAMP` can store values till 2038-01-19 03:14:07 UTC. If we wish to store
    values beyond 2038, the `DATETIME` data type should be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TIMESTAMP` considers UTC as the time zone while storing values. `DATETIME`
    stores values without time zone consideration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's use an example to understand the difference between `DATETIME` and `TIMESTAMP`
    within the context of `time_zone`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose the initial `time_zone` value is set to `+00:00`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a table called `datetime_temp`. The table has two columns; one
    is `DATETIME` and another is of the type `TIMESTAMP`. We will store the same date
    and time values in both columns. With the help of the `SELECT` query, we will
    try to understand how the representations differ in output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `NOW()` is the MySQL function which returns the current
    date and time values. Looking at the output, it seems that both the `TIMESTAMP`
    and `DATETIME` representations are same. It is because the `time_zone` value is
    set to UTC. By default, `TIMESTAMP` shows the date time value considering the
    UTC `time_zone`. On the other part, `DATETIME` shows date time without a `time_zone`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the `time_zone` and observe the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the output, it is clear that the `TIMESTAMP` considers the `time_zone`
    value set in MySQL. So, the `TIMESTAMP` value got adjusted when we changed the
    time zone. `DATETIME` isn't impacted, so the output is not changed, even after
    changing the time zone.
  prefs: []
  type: TYPE_NORMAL
- en: If `TIMESTAMP` is used to store date and time values, we must consider it seriously
    when migrating data to a different server located in a different time zone.
  prefs: []
  type: TYPE_NORMAL
- en: If higher precision for the time value is required, `DATETIME` and `TIMESTAMP`
    can include trailing fractional seconds as small as microseconds (six digits).
    So, if we insert a date time value with a microseconds value, it will be stored
    in the database. The format, including the fractional part, is YYYY-MM-DD HH:MM:SS[.fraction],
    and the range is from 1000-01-01 00:00:00.000000 to 9999-12-31 23:59:59.999999\.
    The range for `TIMESTAMP`, including the fraction, is 1970-01-01 00:00:01.000000
    to 2038-01-19 03:14:07.999999.
  prefs: []
  type: TYPE_NORMAL
- en: The fractional part is separated from the time value by a decimal point because
    MySQL doesn't recognize any other delimiter for fractional seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Date and time values stored with the `TIMESTAMP` data type are converted from
    the server's time zone to UTC for storage and from UTC to the server's time zone
    for retrieval. If we stored a `TIMESTAMP` value and then changed the server's
    time zone and retrieved the value, the retrieved value would be different from
    the one we stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the list of properties of date value interpretation in MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL supports a relaxed format for values specified as string. In a relaxed
    format, any punctuation character can be used as the delimiter between date parts
    or time parts. This is a little bit confusing. For example, a value `10:11:12`
    might look like a time value because of the use of `:`, but is interpreted as
    a `2010-11-12` date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only recognized delimiter between the rest of the time part and the fractional
    seconds part is the decimal point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is expected that month and day values are valid. With `strict` mode disabled,
    invalid dates are converted to respective `zero` values and a warning message
    is shown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TIMESTAMP` values that include zero in the day or month column are not a valid
    date. The exception to this rule is the `zero` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If MySQL is run with `MAXDB` mode enabled, `TIMESTAMP` is identical to `DATETIME`.
    If this mode is enabled at the time of table creation, `TIMESTAMP` values are
    converted to `DATETIME`.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL DATETIME functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`NOW()` is the function used to get the current date and time of the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DATE()` function is used to extract date information from the `DATETIME`
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TIME()` function is used to extract time information from a date time
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `DATE()` and `TIME()` functions are very useful when you want to display
    or query a database table based on the date or time value, but the actual value
    stored in the table contains date and time information.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to extract `YEAR`, `MONTH`, `DAY`, `QUARTER`, `WEEK`, `HOUR`, `MINUTE`,
    and `SECOND` information from `DATETIME` or `TIMESTAMP` values, respective functions
    are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: TIME type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL `DATETIME` or `TIMESTAMP` data types are used to represent specific times
    at particular dates. How about storing only the time of the day or the time difference
    between two events? MySQL's `TIME` data type serves the purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The standard MySQL format for storing or displaying `TIME` data type values
    is `HH:MM:SS`. The time value represents the time of the day, which is less than
    24 hours, but the `TIME` data type, as mentioned earlier, can also be used to
    stored elapsed time or time difference between two events. So, the `TIME` column
    can store values greater than 24 hours.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MySQL `TIME` column is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The range of values that can be stored in the `TIME` data type column is -838:59:59
    to 838:59:59.
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL `TIME` column can also store the fractional seconds part up to microseconds
    (six digits), similar to the `DATETIME` column. Considering the fractional second
    precision, the range of values varies from -838:59:59.000000 to 838:59:59.00000.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MySQL `TIME` column can also have an optional value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `TIME` value usually takes 3 bytes for storage. In the case of the `TIME`
    value including fractional second precision, it will require additional bytes,
    based on the number of fractional second precision.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the number of additional bytes required to store
    fractional-second precision:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Fractional Second Precision** | **Storage (bytes)** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1, 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 3, 4 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 5, 6 | 3 |'
  prefs: []
  type: TYPE_TB
- en: 'MySQL supports abbreviated values for the `TIME` column. There are two distinct
    ways for MySQL to interpret abbreviated values:'
  prefs: []
  type: TYPE_NORMAL
- en: If the abbreviated value has a colon(`:`), MySQL interprets it as time of the
    day. For example, 11:12 is interpreted as 11:12:00 and not as 00:11:12.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the abbreviated value doesn't have a colon(`:`), MySQL assumes that the two
    rightmost digits represent seconds. This means the value is interpreted as elapsed
    time, rather than time of the day. For example, '1214' and 1214 are interpreted
    by MySQL as 00:12:14.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The decimal point is the only delimiter accepted by MySQL to separate fractional
    second precision from the rest of the time value parts.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL, by default, clips the values that lie outside of the permitted range
    of values to the closest endpoint of the range. For example, -880:00:00 and 880:00:00
    are stored as -838:59:59 and 838:59:59\. Invalid `TIME` values are converted to
    00:00:00\. As 00:00:00 itself is a valid `TIME` value, it is difficult to know
    if the value 00:00:00 was stored intentionally, or converted from an invalid `TIME`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL accepts string and numeric values as the `TIME` values.
  prefs: []
  type: TYPE_NORMAL
- en: Time functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CURRENT_TIME()` function can be used to find the current time on the server.
    It is also possible to add or subtract time values using the `ADDTIME` and `SUBTIME`
    functions. For example, the following example adds two hours to the server''s
    current time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `UTC_TIME()` function can be used to fetch the UTC time.
  prefs: []
  type: TYPE_NORMAL
- en: YEAR type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the preferred data type for storing manufacturing year? MySQL's answer
    to this is a `YEAR` data type. The `YEAR` data type requires 1 byte to store year
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `YEAR` column can be declared as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: One notable thing is that earlier MySQL versions supported the `YEAR(2)` type
    column declaration. The support for `YEAR(2)` has been discontinued from MySQL
    8\. It is possible that we might want to upgrade the older MySQL database to the
    MySQL 8 database. In a later section, we will explain the migration details from
    `YEAR(2)` to `YEAR(4)`.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL represents `YEAR` values in a YYYY format. The range of values is from
    1901 to 2155 and 0000.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the list of formats supported for inputting `YEAR` values:'
  prefs: []
  type: TYPE_NORMAL
- en: Four digit number from 1901 to 2155.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four digit string from 1901 to 2155.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or two digit number with the range of 0 to 99\. `YEAR` values from 1 to
    69 are converted to 2001 to 2069 and from 70 to 99 are converted to 1970 to 1999.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or two digit string with the range of 0 to 99\. `YEAR` values from 1 to
    69 are converted to 2001 to 2069 and from 70 to 99 are converted to 1970 to 1999.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting a numeric 0 has a display value of 0000 and an internal value of 0000\.
    If we want to insert 0 and want it to be interpreted as 2000, we should specify
    it as a string 0 or 00.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result of a function that returns an acceptable value `YEAR` context, for
    example, `NOW()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL converts invalid `YEAR` values to 0000.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating YEAR(2) to YEAR(4)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, MySQL 8 doesn''t support the `YEAR(2)` type. Trying to
    create a column with `YEAR(2)` as a data type will give an error as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `ALTER TABLE` query, which rebuilds the table, will automatically convert
    `YEAR(2)` to `YEAR(4)`. The `YEAR(2)` column, after upgrading the database to
    the MySQL 8 database, remains as `YEAR(2)`, but the queries give errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple ways to migrate from `YEAR(2)` to `YEAR(4)`:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `ALTER TABLE` query with `FORCE` attribute converts the `YEAR(2)`
    column to `YEAR(4)`. It doesn't convert the values, though. If the `ALTER TABLE`
    query is applied to a replication master, the replication slaves will replicate
    the `ALTER TABLE` statement. So, the change will be available on all the replication
    nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using binary upgrade, without dumping or reloading data, is another way of upgrading
    `YEAR(2)` to `YEAR(4)`. Running `mysql_upgrade` subsequently executes `REPAIR_TABLE` and
    converts `YEAR(2)` to `YEAR(4)` without changing values. Similar to the previous
    alternative, this will be replicated in replication slaves if it is applied to
    a replication master.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An important thing to note is that while upgrading, we must not dump the `YEAR(2)`
    data with `mysqldump` and reload the dump file after upgrading. This method has
    the potential to change the `YEAR(2)` values significantly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before `YEAR(2)` to `YEAR(4)` migration, application code must be reviewed
    for:'
  prefs: []
  type: TYPE_NORMAL
- en: Code that selects the `YEAR` value in two digits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code that doesn't handle numeric `0` insertions. Inserting `0` into `YEAR(2)`
    results in `2000`, whereas inserting `0` into `YEAR(4)` results into `0000`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Which is the most widely required and used data type for representing values?
    String or character data types; it''s easy, right? MySQL supports a wide range
    of string data types to fulfill different storage requirements. String data types
    are categorized into two categories: fixed length and variable length. `CHAR`,
    `VARCHAR`, `BINARY`, `VARBINARY`, `BLOB`, `TEXT`, `ENUM`, and `SET` are the MySQL-supported
    string data types. The storage requirement for each data type is different and
    will be explained later in a separate section.'
  prefs: []
  type: TYPE_NORMAL
- en: CHAR and VARCHAR data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CHAR` data type is a fixed-length string data type in MySQL. The `CHAR`
    data type is often declared with a maximum number of characters that can be stored
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the data column can store string values that are capable
    of storing maximum characters.
  prefs: []
  type: TYPE_NORMAL
- en: '`CHAR` and `VARCHAR` are similar in many ways, with certain differences. The `CHAR`
    data type is preferred if the string values to be stored are of fixed size. It
    will give better performance compared to if `VARCHAR` is used for fixed size strings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The lengths vary from 0 to 255\. The value in the `CHAR` column cannot exceed
    the maximum length declared at the time of table creation. If the length of the
    string is less than the maximum allowed length, MySQL adds padding on the right
    to the length specified. At the time of retrieval, trailing spaces are removed.
    The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As we can observe in the preceding example, the second record was inserted as
    `' a '`, but in the output, the trailing space is removed. So, the length is displayed
    to be `2` instead of `3`.
  prefs: []
  type: TYPE_NORMAL
- en: Most MySQL collations have a pad attribute. It determines how trailing spaces
    are treated for comparison of non-binary strings. There are two types of collations: `PAD
    SPACE` and `NO PAD`. In case of `PAD SPACE` collation, trailing spaces are not
    considered in comparison. Strings are compared without regard to trailing spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of `NO PAD` collation, the trailing spaces are treated as any other
    character. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`LIKE` is a MySQL operator used for comparison in the `WHERE` clause. It is
    specifically used for pattern searching in a string. Trailing spaces are significant
    when comparing string values with the `LIKE` operator.'
  prefs: []
  type: TYPE_NORMAL
- en: If `PAD_CHAR_TO_FULL_LENGTH` mode is enabled, at the time of retrieval, the
    trailing spaces will not be removed.
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL `VARCHAR` data type is a variable length string data type with a maximum
    length of up to 65,535 characters. `VARCHAR` values are stored by MySQL as a one
    or two byte length prefix, along with actual data. The actual maximum length of
    a `VARCHAR` is subject to the maximum row size, which is 65,536 bytes shared among
    all columns.
  prefs: []
  type: TYPE_NORMAL
- en: If the `VARCHAR` value requires less than 255 bytes, one byte is used for determining
    length prefix. If the value requires more than 255 bytes, two bytes are used for
    determining length prefix.
  prefs: []
  type: TYPE_NORMAL
- en: If MySQL strict mode is enabled and a value to be inserted in the `CHAR` or
    `VARCHAR` column value exceeds the maximum length, an error will be generated.
    If strict mode is disabled, the value will be truncated to the maximum allowed
    length with a warning.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike in the `CHAR` data type, values to be stored in `VARCHAR` are not padded.
    Also, trailing spaces are not removed when the values are retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: BINARY and VARBINARY data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another set of MySQL string data types is `BINARY` and `VARBINARY`. These are
    similar to `CHAR` and `VARCHAR` data types. An important difference between `CHAR`/`VARCHAR`
    and `BINARY`/`VARBINARY` is that `BINARY`/`VARBINARY` data types contain binary
    strings than character strings. `BINARY`/`VARBINARY` uses binary character sets
    and collation. `BINARY`/`VARBINARY` are different from `CHAR BINARY` and `VARCHAR
    BINARY` data types. The basic difference lies in the character set and collation
    referred to.
  prefs: []
  type: TYPE_NORMAL
- en: The maximum length for permitted values is similar to that of `CHAR` and `VARCHAR`.
    The only difference is that the length of `BINARY` and `VARBINARY` is in bytes,
    rather than characters.
  prefs: []
  type: TYPE_NORMAL
- en: How would MySQL compare binary values? The answer is that the comparison happens
    based on the numeric values for the bytes in the values.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to `CHAR`/`VARCHAR` data types, the values are truncated if the length
    of the value exceeds the column length, and a warning is generated. This is if `strict`
    mode is not enabled. If `strict` mode is enabled, an error is generated.
  prefs: []
  type: TYPE_NORMAL
- en: '`BINARY` values are right-padded with the pad value 0x00 (zero bytes) to the
    specified column length. The pad value is added on insert, but no trailing bytes
    are removed on retrieval. While comparing `BINARY` values, all bytes are considered
    significant. This applies to `ORDER BY` and `DISTINCT` operators, as well. Zero
    bytes and spaces are different when compared with *0x00 < space*. The following
    is an example of inserting a binary value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `'a '` becomes `'a \0'` on insertion. `'a\0'` is converted to
    `'a\0\0`'. On retrieval, values remain unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '`VARBINARY` is a variable length string data type. Unlike `BINARY`, for `VARBINARY`,
    padding is not added on insertion and bytes are not stripped on retrieval. Similar
    to `BINARY`, all bytes are significant in comparison for `VARBINARY`.'
  prefs: []
  type: TYPE_NORMAL
- en: If the table has a unique index on columns, insertion of values in the column
    differing only in number of trailing pad bytes will give a duplicate-key error.
    For example, if such a column contains `'a '` and we try to insert `'a\0'`, it
    will cause a duplicate-key error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example explains the padding of `BINARY` values in comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the case that it is required to retrieve the same value as specified without
    padding, `VARBINARY` is preferable.
  prefs: []
  type: TYPE_NORMAL
- en: If the value retrieved must be the same as the value specified for storage with
    no padding, it might be preferable to use `VARBINARY` or one of the `BLOB` data
    types instead.
  prefs: []
  type: TYPE_NORMAL
- en: BLOB and TEXT data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In what situation could we be required to store data in a **Binary Large Object** (**BLOB**)
    column? Any idea? Storing a file or image, you said? It is partially true. Before
    we make a decision to store the images or files in a database or file system,
    we need to assess the situation. If the files are stored in a file system and
    migrated over to another operating system, it is possible that file pointers could
    get corrupted. It will require additional efforts to fix the file pointers. In
    such a case, storing files in a database is preferable. However, it might impact
    performance if we store a large clogged file or image data in the database.
  prefs: []
  type: TYPE_NORMAL
- en: '`BLOB` is MySQL''s solution to storing large binary information of variable
    lengths. MySQL has four `BLOB` types: `TINYBLOB`, `BLOB`, `MEDIUMBLOB`, and `LONGBLOB`.
    The only difference among these data types is the maximum length of values we
    can store. The storage requirements for these data types are explained in later
    sections of the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to `BLOB`, `TEXT` data types are `TINYTEXT`, `TEXT`, `MEDIUMTEXT`, and
    `LONGTEXT`. These have maximum lengths and storage requirements similar to that
    of `BLOB` data types.
  prefs: []
  type: TYPE_NORMAL
- en: Like `BINARY` data types, `BLOB` values are stored as byte strings and have
    binary character sets and collation. Comparisons and sorting are done on the numeric
    values of the column values. `TEXT` values are stored as non-binary strings.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `BLOB` or `TEXT` data types, if the value contains excess trailing
    spaces, MySQL truncates with a warning, regardless of the MySQL mode. MySQL doesn't
    pad `BLOB` or `TEXT` column values on insertion and doesn't strip bytes on retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: For a `TEXT` column which is indexed, the index comparisons add trailing spaces
    as padding at the end of the values. So, a duplicate-key error may occur on insertion
    if the only difference between an existing `TEXT` value and the `TEXT` value to
    be inserted is in the trailing spaces. `BLOB` can be regarded as `VARBINARY` and
    `TEXT` can be regarded as `VARCHAR`, with no restriction on the length of the
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the differences between `VARBINARY`, `VARCHAR` and `BLOB`,
    `TEXT`:'
  prefs: []
  type: TYPE_NORMAL
- en: When creating indexes on `BLOB` or `TEXT` columns, we must specify index prefix
    length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BLOB` and `TEXT` cannot have default values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BLOB` or `TEXT` values are represented internally as objects with separate
    allocations, unlike other data types, for which the storage is allocated once
    per column.'
  prefs: []
  type: TYPE_NORMAL
- en: ENUM data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL provides a data type for which lists of permitted values can be predefined
    when the table is created. The data type is `ENUM`. If we want to restrict the
    user from inserting values outside a range of values, we should define the column
    of data type `ENUM`. MySQL encodes the user input string values into numbers for
    `ENUM` data types.
  prefs: []
  type: TYPE_NORMAL
- en: '`ENUM` provides the following mentioned benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Compact data storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readable queries and output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example that showcases when `ENUM` is useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`ENUM` values require one byte of storage. Storing one million such records
    in this table would require one million bytes of storage, opposed to the six million
    bytes required by the `VARCHAR` column.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are important limitations to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ENUM` values are stored internally as numbers. So, if the `ENUM` values look
    like numbers, literal values may mix up with their internal index numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `ENUM` columns in `ORDER BY` clauses requires extra care. `ENUM` values
    are assigned index numbers based on the order of listing. `ENUM` values are sorted
    based on their index numbers. So, it is important to make sure that the `ENUM`
    values list is in alphabetical order. Also, the column should be sorted lexically
    than by index numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ENUM` value must be a quoted string literal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each `ENUM` value has an index beginning with 1\. The index of the empty string
    or error value is 0\. We can find invalid `ENUM` values by querying the table
    with `enum_column_value = 0` in the `WHERE` clause. The index of `NULL` value
    is `NULL`. Index refers to the position of a value within the `ENUM` list of values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL automatically removes trailing spaces from `ENUM` member values when a
    table is created. Upon retrieval, values from an `ENUM` column are displayed in
    the case used in the column definition. If a number is to be stored in the `ENUM`
    column, the number is treated as an index into the possible values. The value
    stored is the `ENUM` value with that index. In the case of a quoted numeric value,
    it is still interpreted as an index if there is no matching string in the list
    of enumerated values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an `ENUM` column is declared to contain `NULL` values, the `NULL` value is
    considered a valid value for the column and `NULL` becomes the default value.
    If `NULL` is not allowed, the first `ENUM` value becomes the default value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If `ENUM` values are used in a numeric context, the index is used. The following
    is an example query to use `ENUM` values in a numeric context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: SET data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL `SET` is a data type which can have zero or more values. A permitted list
    of values is specified at the time of table creation. Each value must be from
    within the list of permitted values. Multiple set members are specified by a comma
    (`,`) separated list of values. A `SET` can have a maximum of 64 distinct members.
    If `strict` mode is enabled, an error is generated if duplicate values are found
    in the column definition.
  prefs: []
  type: TYPE_NORMAL
- en: It must be taken care that `SET` member values do not contain commas; otherwise,
    they are interpreted as `SET` member separators.
  prefs: []
  type: TYPE_NORMAL
- en: 'A column specified as `SET(''yes'', ''no'') NOT NULL` can have any of the following
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''yes''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''no''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''yes,no''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trailing spaces are removed automatically from `SET` member values. Upon retrieval,
    `SET` column values are displayed using the letter case which was used in the
    column definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of inserting values in the `SET` data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SET` values are stored in the MySQL table as a bitmap in which each element
    is represented by one bit. In the preceding case, each element in the `SET` is
    assigned a bit. If the row has a given element, the associated bit will be one.
    Because of this approach, each element has an associated decimal value. Also,
    because of the bitmap, though there are only four values, `SET` will occupy one
    byte. The following is the table explaining this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Element** | **SET value** | **Decimal value** |'
  prefs: []
  type: TYPE_TB
- en: '| Travel | 00000001 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Sports | 00000010 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Fine Dining | 00000100 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| Dancing | 00001000 | 8 |'
  prefs: []
  type: TYPE_TB
- en: Multiple `SET` elements can be represented by adding their decimal values. In
    the preceding case, the decimal value 9 is interpreted as Travel, Dancing.
  prefs: []
  type: TYPE_NORMAL
- en: The `SET` data type is not so commonly used. This is because although it is
    a string data type, it is a bit complex in implementation. The values that can
    be stored are limited to 64 elements. We cannot add commas as part of `SET` values,
    because a comma is a standard `SET` value separator. From a database design point
    of view, using `SET` means the database is not normalized.
  prefs: []
  type: TYPE_NORMAL
- en: JSON data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON stands for JavaScript Object Notation. Suppose that we want to store user
    preferences for a web application in the database. Usually, we may choose to create
    a separate table with `id`, `user_id`, `key`, `value` fields. This may work well
    for a small number of users, but in the case of thousands of users, the cost of
    maintenance is unaffordable compared to the value it adds to the web application.
  prefs: []
  type: TYPE_NORMAL
- en: In MySQL, we can utilize the JSON data type for this requirement. MySQL supports
    the native JSON data type, which enables efficient storage for JSON documents.
    MySQL supports automatic validation of JSON documents stored in the JSON column.
    Trying to store invalid JSON documents produces an error. JSON documents stored
    in JSON columns are converted to an internal format. The format is binary, and
    structured to enable the server to look up `subojbects` or nested values directly,
    by key or array index, without reading other values.
  prefs: []
  type: TYPE_NORMAL
- en: A JSON column cannot have a default value. The JSON data type requires similar
    storage to that of `LONGTEXT` or `LONGBLOB`. JSON columns are not indexed directly,
    unlike other string data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of inserting JSON values in a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have formatted the JSON value. As an alternative,
    we can also use the built-in `JSON_OBJECT` function. The function accepts a list
    of key/value pairs and returns a JSON object. An example follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `INSERT` query will insert the JSON value `{"page_size": 1, "network":
    ["GSM", "CDMA", "WIFI"]}`. We can also use nested `JSON_OBJECT` functions. The `JSON_ARRAY`
    function returns a JSON array when passed a set of values.'
  prefs: []
  type: TYPE_NORMAL
- en: If the same key is specified multiple times, only the first key/value pair will
    be retained. In the case of the JSON data type, the object keys are sorted and
    the trailing space between the key/value pairs is removed. The keys in the JSON
    object must be strings.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a JSON value in a JSON column succeeds only if the JSON document is
    valid. In the case that the JSON document is invalid, MySQL produces an error.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL has one more important and useful function which operates on JSON values.
    The `JSON_MERGE` function takes multiple JSON objects and produces a single, aggregate
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The `JSON_TYPE` function takes a JSON as an argument and tries to parse it into
    a JSON value. It returns the value's JSON type if it is valid and produces an
    error if otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Partial updates of JSON values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What should we do if we want to update a value in a JSON document stored in
    a JSON data type? One of the approaches is to remove the old document and insert
    a new document, with updates. The approach doesn''t seem good, right? MySQL 8.0
    supports partial, in place update of a JSON document stored in a JSON data type
    column. The optimizer requires that an update must meet the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: The column must be of JSON type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of three functions, `JSON_SET()`, `JSON_REPLACE()` or `JSON_REMOVE()`, can
    be used to update the column. MySQL doesn't permit direct assignment of the column
    value as a partial update.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The input column and target column must be the same. For example, a statement
    such as `UPDATE temp SET col1 = JSON_SET(col2, 'one', 10)` cannot be performed
    as a partial update.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The changes only update existing arrays or objects, and no new elements are
    added to the parent object or array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The replacement value must not be larger than the value being replaced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage requirements for data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section explains storage requirements for different data types in MySQL.
    The storage requirements depend on different factors. The storage engines represent
    data types and store raw data differently.
  prefs: []
  type: TYPE_NORMAL
- en: A table has a maximum row size of 65,535 bytes, even if the storage engine is
    capable of supporting larger rows. `BLOB` and `TEXT` data types are excluded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table explains the storage details for numeric data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data Type** | **Storage required** |'
  prefs: []
  type: TYPE_TB
- en: '| `TINYINT` | 1 byte |'
  prefs: []
  type: TYPE_TB
- en: '| `SMALLINT` | 2 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| `MEDIUMINT` | 3 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| `INT`, `INTEGER` | 4 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| `BIGINT` | 8 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| `FLOAT(p)` | 4 bytes if *0<=p<=24*,8 bytes if *25<=p<=53* |'
  prefs: []
  type: TYPE_TB
- en: '| `FLOAT` | 4 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| `DOUBLE [precision]`, `REAL` | 8 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| `DECIMAL(M, D)`, `NUMERIC(M, D)` | Varies |'
  prefs: []
  type: TYPE_TB
- en: '| `BIT(M)` | Approximately *(M+7)/8* bytes |'
  prefs: []
  type: TYPE_TB
- en: Reference: [https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html](https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table explains the storage requirements for `DATE` and `TIME`
    data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data Type** | **Storage Required** |'
  prefs: []
  type: TYPE_TB
- en: '| `YEAR` | 1 byte |'
  prefs: []
  type: TYPE_TB
- en: '| `DATE` | 3 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| `TIME` | 3 bytes + fractional seconds storage |'
  prefs: []
  type: TYPE_TB
- en: '| `DATETIME` | 5 bytes + fractional seconds storage |'
  prefs: []
  type: TYPE_TB
- en: '| `TIMESTAMP` | 4 bytes + fractional seconds storage |'
  prefs: []
  type: TYPE_TB
- en: 'The following table explains the storage required for fractional seconds precision:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Fractional Seconds Precision** | **Storage Required** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| 1, 2 | 1 byte |'
  prefs: []
  type: TYPE_TB
- en: '| 3, 4 | 2 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| 5, 6 | 3 bytes |'
  prefs: []
  type: TYPE_TB
- en: 'The following table explains storage requirements for string data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data Type** | **Storage Required** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `CHAR(M)` | *M* × *w* bytes, *0 <= M <= 255*, where *w* is the number of
    bytes required for the maximum-length character in the character set |'
  prefs: []
  type: TYPE_TB
- en: '| `BINARY(M)` | *M* bytes, *0 <= M <= 255* |'
  prefs: []
  type: TYPE_TB
- en: '| `VARCHAR(M)`, `VARBINARY(M`) | *L* + 1 bytes if the column values require
    0 − 255 bytes, *L* + 2 bytes if the values may require more than 255 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| `TINYBLOB`, `TINYTEXT` | *L* + 1 bytes, where *L* < 28 |'
  prefs: []
  type: TYPE_TB
- en: '| `BLOB`, `TEXT` | *L* + 2 bytes, where *L* < 216 |'
  prefs: []
  type: TYPE_TB
- en: '| `MEDIUMBLOB`, `MEDIUMTEXT` | *L* + 3 bytes, where *L* < 224 |'
  prefs: []
  type: TYPE_TB
- en: '| `LONGBLOB`, `LONGTEXT` | *L* + 4 bytes, where ***L*** < 232 |'
  prefs: []
  type: TYPE_TB
- en: '| ENUM(''value1'',''value2'',...) | 1 or 2 bytes, depending on the number of
    enumeration values (65,535 values maximum) |'
  prefs: []
  type: TYPE_TB
- en: '| `SET(''value1'',''value2'',...)` | 1, 2, 3, 4, or 8 bytes, depending on the
    number of set members (64 members maximum) |'
  prefs: []
  type: TYPE_TB
- en: Reference: [https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html](https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html)
  prefs: []
  type: TYPE_NORMAL
- en: In the case of string data types, variable length strings are stored using the
    length of the value and the length prefix. The length prefix varies from one to
    four bytes, depending on the data type.
  prefs: []
  type: TYPE_NORMAL
- en: Storage requirements for the JSON data type are similar to that of `LONGBLOB`
    and `LONGTEXT`. However, as the JSON documents are stored in binary representations,
    it imposes an overhead in storing JSON documents.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right data type for column
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a general practice, we should use the most precise type for storing data.
    For example, a `CHAR` data type should be used to store a string value that varies
    in length from 1 to 255 characters. Another example is that `MEDIUMINT UNSIGNED`
    should be used to store numbers ranging from 1 to 99999.
  prefs: []
  type: TYPE_NORMAL
- en: Basic operations such as `addition`, `subtraction`, `multiplication`, and division
    with `DECIMAL` data are performed with the precision of 65 decimal digits.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the importance of accuracy or speed, use of `FLOAT` or `DOUBLE` should
    be chosen. Fixed point values stored in `BIGINT` can be used for higher precision.
  prefs: []
  type: TYPE_NORMAL
- en: These are general guidelines, but the decision to use the right data type should
    be made based on the detailed characteristics explained separately for each data
    type in the earlier sections.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It was an interesting chapter with important content to learn, right? In this
    chapter, we understood the significance of data types in MySQL. We saw different
    categories in which MySQL data types are classified. We learned and understood
    the characteristics and specifications of each data type in depth. We also learned
    MySQL data manipulation functions and understood some of the MySQL settings and
    modes. In the later section of the chapter, we learned storage requirements of
    data types. Finally, we learned general guidelines for choosing the right data
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on to next chapter, we will learn MySQL database management. The chapter
    will focus on server administration, understanding the basic building blocks of
    the MySQL server, such as the data dictionary, system database, and so on. The
    chapter will explain how we can run multiple server instances on a single machine
    and MySQL roles and permissions.
  prefs: []
  type: TYPE_NORMAL
