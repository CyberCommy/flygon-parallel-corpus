- en: Using an API Gateway to Monitor and Metricize REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have developed our API, we need to expose it to the outside world. In
    that journey, we deploy them. But is that sufficient? Don't we need to track our
    API? Which clients are connecting? What is the latency of requests, and so on
    and so forth? There are many other post-API development steps that one should
    follow to make their API production grade. They are authentication, logging, rate
    limiting, and so on. The best way to add those features is to use an API gateway.
    In this chapter, we will explore an open-source API gateway called **Kong**. Open-source
    software is preferable to cloud providers because of the reduced risk of vendor
    lock. All the API gateways differ in the implementation but perform the same task.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why is an API gateway needed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Kong, an open-source API gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example illustration in Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding developed API to Kong
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging in Kong
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication and rate limiting in Kong
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important commands from Kong CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can get the code samples for this chapter at [https://github.com/narenaryan/gorestful/tree/master/chapter11](https://github.com/narenaryan/gorestful/tree/master/chapter11).
    The usage of the files in the chapter is explained in the respective sections.
    You can also import the Postman client collection (JSON file) from the repository
    to test the API, which we will walk through in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Why is an API gateway required?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose a company named XYZ developed the API for its internal purpose. There
    are two ways in which it exposes that API for external use:'
  prefs: []
  type: TYPE_NORMAL
- en: Exposes it using authentication from known clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposes it as an API as a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first case, this API is consumed by the other services inside the company.
    Since they are internal, we don't restrict the access. But in the second case,
    since API details are given to the outside world, we need a broker in between
    to check and validate the requests. This broker is the API gateway. An API gateway
    is a broker that sits in between the client and the server and forwards the request
    to the server on passing specific conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, XYZ has an API written in Go and also in Java. There are a few common
    things that apply to any API:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging of requests and responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without an API gateway, we need to write another server that tracks things such
    as requests and authentication of the API. It is hectic to implement and maintain
    when new APIs keep being added to the organization. To take care of these basic
    things, an API gateway is a fine piece of middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, an API getaway does these things:'
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traffic control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transformations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging is the way to track the requests and responses. If we need an organization-level
    logging in contrast to application level-logging in Go kit, we should enable logging
    in an API gateway. Security is how authentication works. It can be basic auth,
    token-based authentication, OAuth2.0, and so on. It is essential to restrict access
    to the API for the valid customers/clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traffic control comes into play when an API is a paid service. When an organization
    sells the data as an API, It needs to limit the operations per client. For example,
    a client can make 10,000 API requests per month. The rate can be set according
    to the plan the client has opted for. This is a very important feature. Transformations
    are like modifying the request before it hits the application server or modifying
    the response before it is sent back to the client. Take a look at the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acf612e1-8b37-48f8-9243-52a71936c46d.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see how we are able to add the preceding features to our web services.
    From the diagram, the API gateway can redirect requests to any given internal
    servers. The client sees all the APIs are under a single entity of the organization.
  prefs: []
  type: TYPE_NORMAL
- en: Kong, an open-source API gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kong is an open-source API gateway and a microservices management layer, delivering
    high performance and reliability. It is a combination of two libraries worth mentioning.
    One is **OpenResty** and another one is **Nginx**. Kong is a wrapper around these
    two main components. OpenResty is a fully-fledged web platform that integrates
    Nginx and Lua. Lua is another programming language similar to Go. Kong is written
    in Lua. We use Kong as a tool for deploying our Go REST services. The main topics
    we cover are:'
  prefs: []
  type: TYPE_NORMAL
- en: Installation of Kong and the Kong database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding our API to Kong
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging in Kong
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate limiting in Kong
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kong needs a database to run. It could be either Cassandra or PostgreSQL. Since
    we are already familiar with PostgreSQL, we chose it. Where to install them? For
    illustration, we can install them on our local machine, but there is a drawback;
    it can screw up our machine. In order to test the setup, we are going to use Docker.
    Docker can create containerized applications and run them in a predictable, isolated
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Kong, we can hide our API under a gateway. We can create consumers (clients)
    for our API. Kong does everything through a REST API. Kong has two kinds of API:'
  prefs: []
  type: TYPE_NORMAL
- en: Application API (runs on port `8000`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Admin API (runs on port `8001`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an application API, we can access our web services. An admin API allows
    us to add/remove APIs under the gateway. We will see these things in more detail
    in upcoming sections. For more details about Kong, visit [https://getkong.org/](https://getkong.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is a virtualization tool that can create operating systems in the form
    of tiny containers. It is like multiple OS on a single host. Developers usually
    complain saying *working in my box* while facing deployment problems. Docker removes
    those situations by defining an OS environment in the form of images. A Docker
    image has all the information about a given OS at a given time. It allows us to
    replicate that environment any number of times.
  prefs: []
  type: TYPE_NORMAL
- en: 'It was available for Linux initially but is now available for macOS X and Windows.
    For downloading and installing Docker, visit [https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/).
    For Windows and Mac, the binaries are available on the Docker website and can
    be easily installed. After installing, verify the Docker installation with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It will give the version number; always choose the latest Docker. Now that Docker
    is ready, let us run a few commands to install Kong. The upcoming section requires
    some knowledge of Docker. Please go through the wonderful articles on the web
    explaining the fundamentals of Docker if not confident enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final goal is to create three containers:'
  prefs: []
  type: TYPE_NORMAL
- en: Kong database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kong application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When these three containers run, it sets the stage for setting up a web service
    behind an API gateway.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a Kong database and Kong
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, install the PostgreSQL DB. One condition is that we need to expose the
    `5432` port. The user and database name should be `kong`, and that should be passed
    as environment variables to the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This command works in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: Get me an image from the Docker repository called `postgres:9.4`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give a name to the image called `kong-database`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set environment variables in the container called `POSTGRES_USER` and `POSTGRES_DB`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This creates a Docker container by pulling a PostgreSQL image, which is hosted
    on the **DockerHub** ([https://hub.docker.com/](https://hub.docker.com/)) repository.
    Now, apply the migrations required by Kong by running one more Docker command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It applies the migrations on the previously created PostgreSQL DB container.
    The command has an option called `--rm`, which says, *remove this container once
    migrations are done*. Before installing the Kong container, let us prepare our
    Go service. It will be a simple project with a health check `GET` API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go to any directory on the host machine and create a project called `kongExample`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a program called `main.go` inside that directory, which fetches the
    health check (date and time) for a `GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This program returns the date and time when requested. Now, we need to Dockerize
    this application. Dockerizing means creating a running container. Add a Dockerfile
    to the current directory (in the same level `kongExample`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We build a container with the help of this Dockerfile. It says to pull the
    `golang` container from DockerHub (installing the Go compiler and setting the `GOPATH`
    is automatically taken care of) and copy this `kongExample` project to the container.
    Install necessary packages for the project (in this case it is Gorilla Mux), then
    compile the binary and start the server. Run this command to create the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `.` after the `docker build` command. The `-t` option is to tag
    the image with the name. It tells Docker to look at the Dockerfile in the current
    directory and create a Docker image with the given instructions. We need to actually
    run this image to create a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It creates a container called `go-server` and starts the Go web server on port
    `3000`.Now install Kong container, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This command is similar to the first one except we are exposing many other ports
    for Kong to function. We are also pulling the `kong:latest` image from DockerHub.
    Others are environment variables that are required by Kong. We are linking `kong-database`
    to a hostname called `kong-database` and `go-server` to `go-server`. A hostname
    is a helpful entity in a Docker environment to identify and reach to one container
    from another. Docker maintains an internal **Domain Name Space** (**DNS**) that
    keeps track of IP addresses of Docker containers to the linked names. This starts
    the Kong container and starts the Kong service with a default file called `kong.conf.default`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we look at the running containers, it lists three container IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Docker containers are nothing but isolated environments for running applications.
    It is a best practice to run microservices in different containers as they are
    loosely coupled and one environment won't interfere with the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'It means we successfully set up the infrastructure for the Kong API gateway.
    Let''s see how to add the API from `go-server` in Kong. In order to check the
    status of Kong, just make a `GET` request to this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns the status of the database and also the stats for Kong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Adding API to Kong
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kong provides an intuitive REST API to add a custom API to the gateway. In order
    to add the aformentioned healthcheck API, we need to make a `POST` request to
    the Kong admin API, which runs on port `8001`. From now on we use the Postman
    REST client to show all API requests. These API requests are also available as
    a JSON file collection in the chapter's repository for readers to download and
    import in their Postman clients respectively. For more information on exporting
    and importing Postman collections, visit [https://www.getpostman.com/docs/postman/collections/data_formats](https://www.getpostman.com/docs/postman/collections/data_formats).
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a `POST` request from Postman to the Kong admin URL `http://localhost:8001/apis`
    with these fields in the JSON body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It adds our health check API to Kong. The Postman screen looks like the following
    screenshot with all the changes. Postman is a wonderful tool that allows Windows,
    macOS X, and Linux users to make/test HTTP API requests. You can download it here [https://www.getpostman.com/](https://www.getpostman.com/).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/432b02ac-7514-4427-8898-e1a466291ffb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we make this, we get the response JSON with details of the API. This new
    `myapi` will be given an ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A  `GET` request to this URL, `http://localhost:8001/apis/myapi` returns the
    metadata of newly added `myapi`.
  prefs: []
  type: TYPE_NORMAL
- en: Coming to the fields that we posted to the `POST` API, the `name` is the unique
    name of the API. We need to use this to identify an API on the gateway. `hosts`
    is the list of hosts from which the gateway can accept and forward requests. Upstream
    URL is the actual address to which Kong forward requests. Since we linked the `go-server`
    container, in the beginning, we can directly refer `http://go-server:3000` from
    the Kong. The `uris` field is intended to specify the path relative to the upstream
    proxy (Go server) to fetch resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the URI is `/api/v1` and the Go server''s API is `/healthcheck`,
    the resulting gateway API will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`preserve_host` is the property that says whether Kong should change the request''s
    host field to the hostname of the upstream server. For more information, see [https://getkong.org/docs/0.10.x/proxy/#the-preserve_host-property](https://getkong.org/docs/0.10.x/proxy/#the-preserve_host-property). Other
    settings such as `upstream_connect_timeout` are straightforward.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We added our API to Kong. Let us verify if it is forwarding our health check
    request to the Go server or not. Don''t forget to add a header called `Host` with
    the value `server1` for all the API requests. This is very important. The API
    call looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '>![](img/82c21b17-e5d8-48b2-b069-649abf0b7fb6.png)'
  prefs: []
  type: TYPE_NORMAL
- en: We received the response successfully. This is the response returned by our
    `HealthcheckHandler` in our `main.go` program.
  prefs: []
  type: TYPE_NORMAL
- en: If you receive a 404 error, please try the procedure from the beginning. The
    problem could be the containers not running or the upstream URL not being accessible
    from the Kong container. Another critical error may arise from not adding host
    in the request headers. This is the host given while adding the API.
  prefs: []
  type: TYPE_NORMAL
- en: This health check API is actually running as a Go service. We made a request
    for the API gateway and it is forwarding that to the Go. It proves that we successfully
    linked our API with an API gateway.
  prefs: []
  type: TYPE_NORMAL
- en: This is the addition of the API, the tip of the iceberg. What about other things?
    We will be going through each and every feature of the API gateway and try to
    implement them for our API.
  prefs: []
  type: TYPE_NORMAL
- en: In Kong, apart from this basic routing, additional things such as logging and
    rate limiting are available. We need to enable them to our API using plugins.
    A Kong plugin is an inbuilt component that allows us to plug any functionality
    easily. There are many types of plugins available. Out of them, we will discuss
    a few interesting ones in the next section. Let us start with the logging plugin.
  prefs: []
  type: TYPE_NORMAL
- en: API logging in Kong
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many plugins are available in Kong to log requests to multiple targets. A target
    is a system that collects the log and persists it somewhere. These are the important
    plugins available for logging:'
  prefs: []
  type: TYPE_NORMAL
- en: File log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syslog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first one is file logging. If we need the Kong server to store the request
    and response logs in the form of JSON to a file, use this plugin. We should call
    on Kong''s admin REST API (`http://localhost:8001/apis/myapi/plugins`) to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a51c3022-a3b1-4a32-8dd7-9f3ffd1241a0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Hit the Send button and the gateway returns the response, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It basically tells Kong that, for the given API called `myapi`, log every request
    to a file called `/tmp/file.log`. Now, make one more request for the health check (`http://localhost:8000/api/v1/healthcheck`)
    to the API gateway. The log for this request will be saved in the given file path.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we watch these logs? Those logs will be saved in the `/tmp` folder of
    the container. Open a new tab of a terminal and enter the Kong container using
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This takes you into the container''s bash shell. Now, inspect the log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And you will see a lengthy JSON written to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: IP addresses logged here are the internal IP assigned by the Docker to the containers.
    This log also has a breakdown of latency information about the Kong proxy, Go
    server, and so on. You can learn more about the format of logged fields at [https://getkong.org/plugins/file-log/](https://getkong.org/plugins/file-log/).
    Kong admin API for enabling the other logging types is similar to the `file-log`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `POST` requests we are making from Postman to the admin API has the header
    of `Content-Type: "application/json"`.'
  prefs: []
  type: TYPE_NORMAL
- en: API authentication in Kong
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned, an API gateway should take care of authentication for the multiple
    APIs running behind the gateway. Many plugins are available to provide authentication
    on the fly in Kong. In the next chapter, we will see the authentication concept
    in detail. For now, using these plugins, we can add authentication for a given
    API by calling the Kong admin API.
  prefs: []
  type: TYPE_NORMAL
- en: 'An API key-based authentication is becoming famous these days. Kong provides
    the following authentication patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: API key-based authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth2 authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JWT authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the sake of simplicity, let us implement API key-based authentication.
    In simple words, key-based authentication allows an external client to consume
    the REST API with a unique token. For that in Kong, enable the key authentication
    plugin first. To enable the plugin, make a `POST` request to the `http://localhost:8001/apis/myapi/plugins`
    URL with two things in the JSON body:'
  prefs: []
  type: TYPE_NORMAL
- en: The `name` is `key-auth`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`config.hide_credentials` is `true`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second option is to strip/hide the credential to get passed to the Go API
    server. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78461538-976d-4ab8-a7db-873035c6b39e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It returns the JSON response with the created `api_id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we try to make a health check API request, we receive a 401 Unauthorized
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Then how can we consume an API? We need to create a consumer and give permissions
    for him to access the API. That permission is an API key. Let us see how to do
    that.
  prefs: []
  type: TYPE_NORMAL
- en: 'For creating a consumer, we need to create a consumer that represents a user
    consuming the API. Make an API call to the Kong admin API for consumers. The URL
    endpoint will be `http://localhost:8001/consumers`. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48f55137-10a1-4148-9b2b-38d3cb7c77e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `POST` body should have the `username` field. The response will be JSON
    with the created consumer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we need to grant the API permission to `johnd`, make a `POST` request
    to the `http://localhost:8001/consumers/johnd/key-auth admin` URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a03b590-0d46-413c-b86d-c4a77d74e258.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This returns the API key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this API key generated in the subsequent API calls. Now, remake
    the health check with `apikey` in header whose value is the key from the preceding
    response, and it successfully returns the date and time with a `200 OK`. Refer
    to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66502aeb-b4ac-4d19-ba66-eee9e0ae483e.png)'
  prefs: []
  type: TYPE_IMG
- en: API rate limiting in Kong
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can limit the rate of an API for a given consumer. For example, GitHub limits
    clients to make 5000 requests per hour. After that, it throws an API rate limit
    exceeded error. We can add similar rate limiting constraints for our API using
    Kong's `rate-limiting` plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can enable it using this API: **`http://localhost:8001/apis/myapi/plugins`**,
    with `POST` `name`, `config.hour`, and `consumer_id` as body parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44aca43e-a1c6-4b9a-ad2b-11f48a2f078c.png)'
  prefs: []
  type: TYPE_IMG
- en: This API call is creating a rate limiting rule. The `consumer_id` is the id
    of the username `johnd`. This JSON response has an `ID`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the consumer (`johnd`) has the rate limit on the API. He will only be
    allowed to make 5000 requests per hour to our health check API. If he exceeds
    it, he receives the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'How should a client know how many requests are remaining as part of rate control?
    Kong sets a few headers on the response when a client makes a request to the API.
    Try to make 10 health check requests and check the response headers; you will
    find the following in the response headers, which proves that rate limiting is
    working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this way, Kong provides many good features to take our API to the next level.
    It doesn't mean that an API gateway is absolutely necessary, but it can give you
    the pleasure of having many cool features without writing a single line of code.
    It is an open-source software developed to avoid rewriting the universally defined
    API gateway functionality within the web service business logic. For more features
    such as load balancing and request transformations, go through the documentation
    of Kong at [https://konghq.com/plugins/](https://konghq.com/plugins/).
  prefs: []
  type: TYPE_NORMAL
- en: Kong CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kong comes with a command-line tool for changing the behavior of Kong. It has
    a set of commands to start, stop, and modify Kong. Kong by default uses a configuration
    file. If we need to modify it, we need to restart Kong for those changes to be
    applied. So, all these housekeeping jobs are already wired into the Kong CLI tool.
    The basic functions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kong start`: For starting the Kong server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kong reload`: For reloading the Kong server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kong stop`: For stopping the Kong server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kong check`: For validating the given Kong configuration file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kong health`: For checking necessary services, such as the database, are running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please go through the documentation of Kong CLI for more commands at [https://getkong.org/docs/0.9.x/cli/](https://getkong.org/docs/0.9.x/cli/).
  prefs: []
  type: TYPE_NORMAL
- en: Other API gateways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many other API gateway providers available in the market. As we mentioned
    earlier, all gateways perform the same kinds of functions. Enterprise gateway
    service providers such as Amazon API Gateway plays nice with EC2 and Lambdas.
    Apigee is another well-known API gateway technology that is a part of Google Cloud.
    The problem with cloud providers is that they can cause vendor lock (cannot easily
    migrate to another platform). Because of that reason, open-source alternatives
    are always good for startup companies.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started with the basics of an API gateway. An API gateway
    tries to do a few things; it acts as a proxy for our API. By being a proxy, it
    forwards requests to the multiple APIs from different domains. In that process
    of forwarding, a gateway can block requests, rate limit them, and also transform
    requests/responses.
  prefs: []
  type: TYPE_NORMAL
- en: Kong is a good open-source API gateway available for the Linux platform. It
    has many features such as authentication, logging, and rate limiting. We saw how
    to install Kong, a Kong database, and our REST service inside the Docker containers.
    We used Docker instead of host machine because containers can be destroyed and
    created at will. It gives less chance for screwing up our host system. After learning
    about the installation, we learned that Kong has two types of REST API. One is
    the admin API, and the other is the app API. The admin API is the one we use to
    add our API to the gateway. The app API is our application's API. We saw how to
    add an API to Kong. Then, we came to know about Kong plugins. Kong plugins are
    the functional pieces that can plug into a Kong. Logging plugins are available.
    Authentication plugins and rate limiting plugins are also available in Kong.
  prefs: []
  type: TYPE_NORMAL
- en: We made requests with the Postman client and saw the sample JSON returned. For
    authentication, we used the `apikey` based consumer. We then simulated GitHub's
    5000 requests per hour with a `key-auth` plugin of Kong.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we introduced the Kong CLI and also inspected other enterprise API
    gateways such as Apigee and Amazon API Gateway.  In the next chapter, we will
    see in more detail how authentication works and try to secure our API when there
    is no API gateway present.
  prefs: []
  type: TYPE_NORMAL
