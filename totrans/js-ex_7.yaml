- en: Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hi! Good work with the blog in the preceding chapter, and welcome to the last
    chapter of the book, which is a sequel to the blog that we built in the preceding
    chapter. In this chapter, we will fix that annoying 3 second loading issue on
    the blog by learning about centralized state management with Redux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as we covered only the basics of React in the preceding chapter, this
    chapter is simple and will cover the basic concepts of Redux, which will change
    building web applications forever. That leaves us with only one simple question:
    What is Redux?'
  prefs: []
  type: TYPE_NORMAL
- en: What is Redux?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the Redux documentation at: [http://redux.js.org/](http://redux.js.org/),
    Redux is "*a predictable state container for JavaScript apps*". To explain redux
    in detail, let's take a look at the story of **flux**, an application architecture
    built by Facebook.
  prefs: []
  type: TYPE_NORMAL
- en: Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React is all well and good for a small application such as the ToDo list or
    the blog we built in the preceding chapter, except for an application such as
    Facebook. Facebook has hundreds of stateful React components that work to render
    the web application. In our blog, each React component has its state, and each
    stateful component makes a network request to fill these states with data.
  prefs: []
  type: TYPE_NORMAL
- en: Once parent components get the data, it will get passed to child components
    as props. However, the child component can have its own states too. Likewise,
    there can be two or more parent components in the same level that require the
    same data for the states. React's one-way data flow has a severe problem here.
    If the data is passed to the child component as props, the child component cannot
    change the props, since it will lead to mutation of the data. Hence, the child
    component will have to call a method in the parent component, which also should
    have passed as a prop to make a simple change. Imagine that you have 10s and 100s
    of parent-child nested components, where the control always has to be passed back
    to the parent and the data flow has to be managed properly between the parent
    and children components.
  prefs: []
  type: TYPE_NORMAL
- en: Facebook needed a simple and maintainable solution for managing data across
    all these components. The ideal solution they came up with was to take the state
    out of the React component and manage it in a separate place called **stores**.
    The plan was simple--we take the state (data) out of the React component and keep
    it in separate stores. All React components will then depend on stores for their
    data. So, you have to pass the required data from stores to all the necessary
    components as props.
  prefs: []
  type: TYPE_NORMAL
- en: Any change in the stores will lead to a change of props in all the dependent
    components, and whenever props change, React will automatically re-render the
    DOM. They came up with special functions called **actions** and **dispatchers**, which
    are the only ones capable of updating stores. So, if any component needs to update
    a store, it will call these functions with the required data, and they will update
    the store. Since the store gets updated, all the components will receive new props,
    and they will get re-rendered with new data.
  prefs: []
  type: TYPE_NORMAL
- en: This explains the architecture of flux. The flux architecture was created not
    only for React, but also for general use by all the JavaScript frameworks. However,
    even though the concept of flux was simple, the implementation was quite complex,
    which was later overcome by a new state management library, that is, Redux. Since
    we focus on Redux in this chapter, we won't be discussing flux; however, if you
    are interested in knowing more about flux, you can visit its official page: [https://facebook.github.io/flux/](https://facebook.github.io/flux/).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main problem faced by developers who are using flux is that the application
    state is not quite predictable. It's probably why Redux introduces itself as a
    predictable state container for JavasScript apps. Redux was created as a `stand-alone`
    library that can be used with any JavaScript applications. To use Redux with React,
    we will need another library called `react-redux`, which is provided by the React
    community, available at: [https://github.com/reactjs/react-redux](https://github.com/reactjs/react-redux).
  prefs: []
  type: TYPE_NORMAL
- en: Redux has one of the best documentations for an open source library. It even
    comes with two free video courses by the creator of the library--*Dan Abramov*--which
    are available on the documentation's home page. Before we start adding Redux to
    our blog application, let's take a look at how Redux works and how it will help
    to improve our React application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the Blog app we created in the preceding chapter. We have an **App
    component** as the parent and all the other components are children of the **App
    component**. In our case, each component has its own state, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we were to use flux, it would have multiple stores, and we could have the
    state of the **Post component** list and **Author component** list as two stores
    and let the entire application share those stores. However, if we use Redux, it
    will maintain a *single store*, which will hold the state for the entire application.
    You application structure will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding image, Redux will create a *single store* that
    holds the state, which can then be supplied to the required components as props.
    Since the entire application has a single state, it becomes easy to maintain and
    the application state becomes more predictable for developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s take a look at how Redux manages its store. The Redux implementation
    has three important parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A store is a centralized state that contains the entire application state. Like
    normal states, the store is also a simple JavaScript object, which contains only plain
    data (a store object should not contain any methods). Also, the state is read-only,
    which means that other parts of the application cannot directly make changes to
    the state. The only way to modify the state is to emit an action.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Actions are functions that are designed to perform a task. Whenever a component
    needs to modify the state, it will have to call an action. Actions are supplied
    to the component as props. The return type of an action function should be a plain
    object. The object returned by an action is supplied to the reducers.
  prefs: []
  type: TYPE_NORMAL
- en: Reducers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reducers are simple methods whose function is to update the store. Since the
    store is a JavaScript object, organized as key-value pairs, each key will have
    its own reducer. The reducer function accepts two arguments, the object returned
    from the action and the current state, and it will return a new state.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Redux in the blog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a good idea of why Redux is being used, let's get started
    with implementing Redux in our Blog application. This chapter uses the same server
    that you used in the preceding chapter, hence, you will have to keep the server
    running while working on this chapter too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The starter files for this chapter are the same as the completed code file
    from the preceding chapter, except the `package.json` file, which has the following
    new libraries included in its dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`redux`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react-redux`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redux-thunk`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redux-persist`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localforage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll see what each of these libraries does while building our application.
    We will use the same `.env` file that we used in the preceding chapter with the
    `REACT_APP_SERVER_URL` environment variable, whose value is the URL of the running
    server. Navigate to the project root folder in your terminal and execute `npm
    install` followed by `npm start` to start the development server of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The folder structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we will need to do before we start with Redux is to define
    a proper folder structure for the Redux components. Currently, this is how our
    `src/` directory looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to create a new directory called `redux`, which will hold our
    `store`, `actions`, and `reducers`. Now, the directory structure will look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `redux` directory, you will need to create four different directories,
    namely `actions`, `actionTypes`, `reducers`, and `store`. Your `redux` directory
    will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You might be wondering about the `actionTypes` directory. In Redux, all the
    actions should be predefined. You don't want an uninformed action to happen. Hence,
    we will create the `actionTypes` folder, which will hold constants for all the
    actions that our application can do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the required folder structure, let's start with creating our
    initial state.
  prefs: []
  type: TYPE_NORMAL
- en: Initial state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We always define the initial state in our React components in the constructor,
    where we create the state variables. Similarly, we will need to create an initial
    state for our Redux too. The only difference is that the Redux state will have
    to hold the state for the entire app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s strategize how the initial state will look:'
  prefs: []
  type: TYPE_NORMAL
- en: The data that is used on the home page of our blog is an array of posts, hence
    we will need a posts array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data used for showing a list of authors is also an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also need to maintain states for the AJAX calls and their success or error
    status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In your `store` directory, create a new file--`initialState.js`--and add the
    following code containing the `initialState` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `initialState` constant contains an empty array for posts
    and authors and an object that has the status information for the three network
    requests (AJAX calls) that we will use in this application.
  prefs: []
  type: TYPE_NORMAL
- en: Once we add Redux, our application will have to make only three network requests--one
    to get all the posts, one to get all the authors, and the third one to add a new
    post. If we want to see a post in the post details page, we can easily use the
    posts array we got in the first network request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `redux` folder should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Action types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have got our initial state ready, let's define all the actions our
    Blog application can do. Actions in our blog are nothing but the network requests
    we make to retrieve data. Each network request will have four actions associated
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the request where we get all the blog posts from the server. The actions
    associated with this network request will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the AJAX call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network request success
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network request failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get posts data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, in your `redux/actionTypes` directory, create an `actionTypes.js` file
    that will hold a constant value for all the actions that will happen in our application.
    In the `actionTypes.js` file, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Your `redux` folder should have the following structure now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have created the `actionTypes`, which we can use throughout the application,
    so let's create the actions that the application should use to update the state.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Actions are dispatched from the React components when they need to modify the
    state of the application. We need two actions for our application, one for the
    posts page and one for the authors page. However, as in the preceding chapter,
    I'll only focus on the posts page; you can work on the authors page once you are
    done with this chapter. The completed code files have the actions completed for
    the authors page too, so you can use it as your reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started. In the `actions` directory, create two files, `authorActions.js`
    and `postActions.js`. Your `redux` folder should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, leave the `authorActions.js` file empty, and we''ll work on the `postActions.js`
    file. This is how a standard action function should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the action returns an object with two properties, namely, `type`
    and `payload`. The type property is used by the *reducers* to identify the type
    of action that happened and the `payload` delivers the result of that action.
    `payload` is optional, since some actions do not produce a direct result, but
    type property should be present in all the objects returned by actions.
  prefs: []
  type: TYPE_NORMAL
- en: This works great for simple actions such as the sum of two numbers that we saw
    in the preceding example code, which is synchronous. However, most of the time,
    actions we do in our application are asynchronous, and we cannot simply return
    a JSON object from those actions.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this problem and do asynchronous actions, Redux has a concept called
    **middleware**. Middleware are libraries that can affect the way Redux works,
    especially for cases such as having asynchronous functions in the actions. The
    middleware that we will use in this application for this purpose is the `redux-thunk`
    library. This library is already included in the `package.json` file of this chapter's
    starter files and would have already been installed when you did `npm install`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here''s how `redux-thunk` works. `redux-thunk` allows actions to dispatch
    other actions instead of returning a plain JavaScript object. This is useful because
    we can call any number of actions we need when the asynchronous event is running.
    The actions that return other actions have the following weird syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding syntax is quite hard to understand at first, but if you look closely,
    the `ajaxRequestAction` will return another function instead of returning an object.
    That function will have `dispatch` as its argument.
  prefs: []
  type: TYPE_NORMAL
- en: Let's call the function returned by `ajaxRequestAction` the *dispatcher* (*just
    for our reference*). Once we are inside the dispatcher, we can do any asynchronous
    actions we need. A dispatcher need not return any values. However, the dispatcher
    has the ability to dispatch other actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the actions for the posts of our blog in the `postActions.js`
    file. In your `postActions.js` file, you will first need to add two import statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first one is the actions object that we created in the `actionTypes` folder.
    This contains all the actions that can be performed in our application. The second
    one is the `apiCall` service, which will make the network request.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of actions that need to be performed on the posts in our
    blog:'
  prefs: []
  type: TYPE_NORMAL
- en: Get all posts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get all posts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Usually, our React component will have to trigger only a single action--`getAllPosts()`--which
    will make the network request and return the post data. This action will be our
    dispatcher. This action will start the network request and dispatch all the other
    actions based on the result of the network request. In your `postActions.js` file,
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note the `export` keyword before the `getAllPosts` function. This is because
    all the actions will be used from inside the React components, hence, we are prefixing
    them with export keywords so that they can be imported later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our dispatcher, `getAllPosts`, will make the network request and dispatch all
    the other normal actions, which will be used by the reducers of our app. Add the
    following code to your `postActions.js` file, which contains the code for all
    the actions dispatched by the `getAllPosts` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The actions for tracking the status of the API calls do not need to return a
    `payload`. Since its status will be a boolean value, it only returns the action's
    type. However, the `getPosts` action, which should return the post details, returns
    a `payload` along with the action type, which is the posts array.
  prefs: []
  type: TYPE_NORMAL
- en: This looks like a lot of code for a simple network request, but, trust me, once
    your application scales up, these are the only actions you'll ever need whenever
    you need to get all the posts.
  prefs: []
  type: TYPE_NORMAL
- en: You should always specify the type of the action using the actions object you
    created in the `actionTypes` file. This way, you can prevent other developers
    in the team from accidentally creating unexpected actions in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new post
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since adding a post is an action related to posts, we will add the actions
    in the same `postActions.js` file. Add the following code for `addNewPost` action,
    which also acts as the dispatcher for adding a new post in your `postActions.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `addNewPost` action is pretty much similar to our preceding `getAllPosts`
    action. However, it requires a `body` argument, which will contain the post details
    needed for adding the post to the server. You should also note that, once the
    success response from the server is received that the post has been added, the
    `addNewPost` action will dispatch the `getAllPosts` action, which will retrieve
    all the posts, including the newly created post. This saves our React component
    the trouble of dispatching multiple actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the remaining actions, which are dispatched by the `addNewPost`
    action, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all for the actions part. We currently have the following three parts
    in our blog application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: However, they are connected with each other at the moment. Our next step is
    to create the reducers, which provide the ability to update the application state.
  prefs: []
  type: TYPE_NORMAL
- en: Reducers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reducers are simple functions that receive the action object returned from
    the actions and then update the state using them. Generally, since our application
    state is represented as an object which is a key-value pair, we will need to create
    a reducer for each key (or property). This is the structure of our application
    state, which we created in the initial state section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We have got three properties in our state, hence, we will need three reducers,
    namely, `postsReducer.js`, `authorsReducer.js`, and `ajaxCallsReducer.js`. These
    reducers will represent our application state in the store. We also need another
    reducer, which will be used to combine these three reducers into a single object
    that will be used as our state.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `redux` directory, create the four files highlighted in the following
    structure; your `redux` folder structure should now look as follows :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the reducer function works:'
  prefs: []
  type: TYPE_NORMAL
- en: The reducer function accepts two parameters; the first one is the old state
    and the second one is the action object returned by an action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will return a new state, which will completely overwrite the old state. This
    is because, just like updating state in React components, updating state in Redux
    should also be immutable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following example. This is how Redux stores states; the value
    of states are the results of the reducers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If an action happens that receives new posts, the reducer will return all the
    new posts, which will update the post's state without mutating it. Remember that
    all reducers will be listening to all the actions. Hence, we will need to properly
    filter the required action inside the reducer, and if none of the actions affect
    the reducer, it should simply return the old state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `postsReducer.js` file, and add the following import statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have added these `import` statements, add the following code for the
    posts reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `postsReducer` function will accept two parameters, as mentioned earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '`state`: It contains the old value of the `posts` state. At first load, however,
    the old state will be null, hence, `initialState.posts` is passed as a default
    parameter for the state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`action`: It is the action object returned by the actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since the reducer gets called for every action, we will simply need to add
    a switch case statement with which we can determine the type of action and whether
    it will affect our state. In our switch case statement, we have added two cases
    for the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: If the action's type is `GET_POSTS`, we know that it contains all the posts,
    hence, we can simply return the posts from the action's `payload`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is not, then the `default` case will be executed, which will simply return
    the old state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `authorsReducer.js` file is for you to try out, but it can''t be left empty.
    In this file, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It will simply return the `initialState` for all the actions. You can work on
    this reducer to try out Redux in the author list page.
  prefs: []
  type: TYPE_NORMAL
- en: For `ajaxCallsReducer.js`, the code is too long to be specified in the book,
    so you should copy the contents of the file from the completed code files. The
    exact code will work fine. The working of `ajaxCallsReducer` is very simple. It
    toggles the value of the `loading` and `hasError` properties to `true` or `false`
    based on the result of the network request. Since the state cannot be mutated,
    it uses the spread operator (`...state`) to perform this operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the case in which `GET_POSTS_AJAX_CALL_START` happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, a new state object is created with the loading property inside the `getAllPosts`
    property set to `true`. This state can be useful for showing the loading indicator
    in the application.
  prefs: []
  type: TYPE_NORMAL
- en: The Root Reducer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last item we have left in the reducers part is the root reducer. In this
    file, all the reducers are combined together to be used as a state for the application.
    Redux provides a method called `combineReducers`, which can be used for this purpose.
    In your `rootReducer.js` file, add the following import statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will import the `combineReducers` function along with other reducers.
    To combine all reducers into a single root reducer, you will simply need to add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will import this reducer to create our store in the next section. At the
    moment, this is how data flows between actions and reducers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last stage of working with the Redux part is to create the store object
    using the root reducer. Inside the `redux/store` directory, create the `configureStore.js`
    file, which will create our store object. We will also need to apply our `redux-thunk`
    middleware in this file, which will allow us to use actions that will dispatch
    other actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Redux provides the `createStore` function to create the store object and the `applyMiddleware`
    function to add middleware. In your `configureStore.js` file, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a store, you will simply need to call the `createReducer` function
    with `rootReducer`, the preceding state, and the `applyMiddleware` method as parameters.
    The first parameter is compulsory, whereas the others are optional. In the `configureStore.js`
    file, add the following code after the `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `configureStore` function will be used to create the store object for our
    React components. The final folder structure of our `redux` directory will look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all for now in the `redux` part. We will now work with the React components
    of our blog and connect Redux with React using the `react-redux` library. Now,
    this is how data flows in the `redux` part:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Connecting Redux with React components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We wrapped the entire `App` component of our blog inside the `BrowserRouter`
    component of React router to implement routing in the `index.js` file. Redux follows
    a similar approach. We need to wrap the `App` component, which is already wrapped
    inside the router within a `Provider` component of the `react-redux` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `src/index.js` file, and add the following import statements after
    the `import` statements that are already present in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This will import the `Provider` component of `react-redux` and the `configureStore`
    function that we created in the preceding section. We will need to create a `store`
    object from the `configureStore` function. After the preceding `import` statements,
    add the following line to create the store object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Currently, this is how your `ReactDOM.render()` method looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to replace it with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We have now wrapped the entire `App` component inside the `Provider`, which
    provides the React components with the ability to connect with Redux. We'll now
    see how to connect an individual component with the state present in the Redux
    store and its actions.
  prefs: []
  type: TYPE_NORMAL
- en: The App component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first component that we will connect with Redux is the `App` component,
    which acts as the parent component to all the other components in our application.
    This means that, regardless of the URL we visit in our application, the `App`
    component will be executed. This makes the `App` Component the best place to do
    actions, such as `getAllPosts`, which will retrieve the posts array.
  prefs: []
  type: TYPE_NORMAL
- en: This section is the most confusing part in Redux, hence, you will have to pay
    close attention to how we pass the Redux store and actions to the React component
    as props. Also, make sure that you refer to the completed code files if you face
    any errors at this stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to add a few `import` statements in your `App.js` file. The first
    thing you will need to import is the `connect` component provided by `react-redux`
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will provide a wrapper to connect your React component with Redux. This
    works in the same way as the `withRouter` component of the React router, which
    supplies history, location, and match props to the React component.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need to import the `bindActionCreators` function of Redux, which
    will convert the action functions into simple objects that can be used by React
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Another important thing we will need to import is the `postActions`, which
    will be used by our `App` component. Since `postActions` contains a lot of functions
    exported individually, we can import all of them together as a single object using
    the following `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have all the required `import` statements in place. Our next step is
    the actual implementation part. Currently, this is how the export statement of
    the `App` component looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Our `App` component is wrapped inside `withRouter`. To connect this with Redux,
    we will need to wrap the `App` component inside the `connect` function we imported
    from `react-redux`, and the result should be inside the `withRouter` component.
  prefs: []
  type: TYPE_NORMAL
- en: However, the connect function itself requires two functions--`mapStateToProps`
    and `mapDispatchToProps`--as parameters. In these two functions, `mapStateToProps`
    will convert the state from the store and `mapDispatchToProps` will convert the
    actions into props, which can be used by React components. Now, pay close attention,
    because we will be seeing another weird syntax soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the export code of your `App` component with the following lines of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the preceding code snippet carefully. If the export statement
    makes no sense to you, no worries, we''ll sort that out. Let''s see what `connect`
    does. The `connect` function will accept two parameters--`mapStateToProps` and
    `mapDispatchToProps`--which are functions, and it will return a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `App` component is wrapped inside the `connectFunction` as `connectFunction(App)`.
    The entire component is then wrapped inside the `withRouter()` function. So, basically,
    this is what the export statement works like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Which is what we have combined together and writing as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `App` component does not use any states, hence, the `mapStateToProps` function
    will return an empty object. The `mapDispatchToProps` function, however, will
    return `postActions` as an object using the `bindActionCreators` function, which
    will then be supplied to the `App` component as a prop.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now have the `App` component make the API call for getting all the
    posts by adding the following line of code in the `componentWillMount()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, since `postActions` is passed as a prop to our `App` component, add the
    following property to the `propType` validation we added in the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the completed code files if you face any problems in including the
    preceding code snippets in the `App.js` file. Once you have completed this step,
    keep the server running from the `Chapter06\Server` directory and open your application
    in Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: You should see the blog running with the same 3 second loading time whenever
    we click on the menu items in the navigation bar icon or on the Read More button
    in the post. We will fix this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Home component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, we used the `App` component to retrieve the data from
    the server and store it in the Redux store. This means that we no longer need
    to make any network requests in our Home component. We will simply need to retrieve
    data from the Redux store.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Home component does not trigger any Redux actions, hence, we only need
    to import the connect component from `react-redux`. In your `Home.js` file, add
    the following `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `export` statement of our `Home.js` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Since the Home component will not do any actions, we can safely ignore the `mapDispatchToProps`
    function in connect. However, we got some work for the `mapStateToProps` function,
    which simply returned an empty object in the preceding chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `mapStateToProps` function has one argument, which is a state that contains
    the entire Redux state of the applications. In the return statement, we will simply
    need to mention which part of the state we need to deliver to the React component
    as props. The best part about connect is that, whenever reducers update the states,
    it will update these props using the `mapStateToProps` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now got some new props for our Home component. So, in your Home component,
    add the following `propType` validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Also, we no longer need any states or API calls in our Home component, hence,
    you can *delete both* the *constructor* and the `componentWillMount` methods.
    Instead, in the JSX of your render method, replace `this.state.posts` with `this.props.posts`.
    Do the same for both the `loading` and `hasError` states. Now our Home component
    depends directly on the Redux store. Refer to the completed code files if you
    face any problems.
  prefs: []
  type: TYPE_NORMAL
- en: Here's the cool part--if you click on any other section in the navigation bar
    and return to Home, you will see that the posts load instantly. This is because
    all the posts are stored and ready for use inside our Redux store. If you click
    on the Read More button in the posts list of the home page, you should see a loading
    indicator again, since it is retrieving post details from the server. Let's also
    connect that component with Redux.
  prefs: []
  type: TYPE_NORMAL
- en: Post component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open your `src/Components/Post.js` file in VSCode. Our first step is to add
    the required `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s strategize how we will connect this component with Redux:'
  prefs: []
  type: TYPE_NORMAL
- en: We will need to get the Post ID, which is present in the URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have the ID, we should find the post with the ID in our store's posts
    array using the `Array.find()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we can send the required post as props
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, replace your `export` statement in `Post.js` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `mapStateToProps` function has a second argument, which is `ownProps`. It
    contains all the props of the Post component. From `ownProps`, we can obtain the
    post ID, which is present in the match object supplied by the `withRouter` component
    of the React router. We will then use the find method to find the post and return
    the required data in the return statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `propType` validation inside the Post component should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You can delete the constructor and the `componentWillMount` methods just as
    we did for our Home component, and then, in your render method, replace `this.state.loading`
    with `this.props.loading` and `this.state.hasError` with `this.props.hasError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, before you replace `this.state.post` with `this.props.post`, we should
    make sure that `this.props.post` has a value, since, during loading, the posts
    array will be empty, and the value of `this.props.post` will be undefined. In
    your render method, replace the three lines where you have used `this.state.post`
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now try reloading the page. It will take three seconds for the first load, but
    once your data is loaded, you will see that navigating to other pages (except
    the author page) will be a breeze. Clicking on the Read More button in the home
    page will take you to the post details page instantly.
  prefs: []
  type: TYPE_NORMAL
- en: It's your turn to try this out in the `AuthorList` and `AuthorPosts` components.
    The last component in which we need to connect Redux is the NewPost component.
  prefs: []
  type: TYPE_NORMAL
- en: The NewPost component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The NewPost component requires both state and actions from Redux. It needs
    the loading and `hasError` data from state and will have to use `postActions`
    to submit a post to the server. So, let''s start by including the required `import`
    statements in the `src/Components/NewPost/NewPost.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, replace your `export` statement in the `NewPost.js` file with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have got props in our `NewPost` component, add the following `propType`
    validation code inside the `NewPost` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the `Home` and `Post` components, the `NewPost` component requires both
    state and props to render the JSX elements. We can delete the loading and `hasError`
    states and replace them with props. You should refer to the completed code files
    (if needed), and replace the loading and `hasError` states inside the JSX of the
    render method with props.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should then replace your entire `apiCall().then().catch()` chain inside
    the submit method with this following single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Your `submit` method will now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `submit` method will now trigger an action--`addNewPost`, which contains
    the required network request. However, we need to show a success message once
    the network request is complete. To detect the completion of a network request,
    since all our updates to the store are immutable, if the status of loading or
    `hasError` properties in the `ajaxCalls` property of the Redux's state changes,
    it will lead to the creation of a new object, which will automatically be delivered
    to the `NewPost` component by `react-redux`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that new props will be received by the `NewPost` React component
    at the end of the network request. In this case, we can use the `componentWillReceiveProps`
    `lifecycle` method of React to show the success message and clear the input fields
    once the post is submitted. Add the following code of `componentWillReceiveProps`
    to the `NewPost` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`componentWillReceiveProps` will have the new props that are supplied to the
    component (in our case, from `react-redux`) as its parameter, which we will call
    `nextProps`. In the `componentWillReceiveProps` method, a simple `this.props !==
    nextProps` check is done to make sure that current props and new props are not
    the same objects. If they both hold the same object, we can skip the operation.
    We then only need to check whether loading is complete and whether there are any
    errors using if else statements, as used in the preceding code snippet.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have included the preceding code snippet, try to add a post (make sure
    that the server is running). It should add the post and display the success message.
    Now, click on the Home menu option. You will see the new post that you added appear
    instantly with no loading time required. The secret to this is that the `addNewPost`
    action will automatically call the `getAllPosts` action, which will update your
    Redux store in the background. With the store updated using the new post, your
    `Home` component can get the updated posts state directly from Redux, which makes
    things appear instantly.
  prefs: []
  type: TYPE_NORMAL
- en: This provides a great user experience for users, as they will find that every
    update happens instantly instead of having to wait for the loading indicator.
  prefs: []
  type: TYPE_NORMAL
- en: The Redux data flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After connecting your Redux code with the React components, you will find that
    Redux follows the same one-way data flow as React. This is the data flow of Redux:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is how data flow happens in a React component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Also, both the state in a React component and the state in a Redux store should
    be immutable. This immutability is essential for React and Redux to work properly.
    However, since JavaScript does not strictly implement any immutable data types
    at the moment, we need to be careful not to mutate the states. In React components,
    we will use the `this.setState()` method, and we use spread operators (`...`)
    inside reducers for Redux to update states without mutating them.
  prefs: []
  type: TYPE_NORMAL
- en: This can prove troublesome for large projects with a huge amount of data. Facebook
    has introduced a library called `Immutable.js`, available at: [https://facebook.github.io/immutable-js/](https://facebook.github.io/immutable-js/),
    which can solve this problem by creating immutable data types in JavaScript. This
    library is out of the scope of this book, but ensure that you give it a try later.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting Redux store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our blog is fast to load since we have integrated Redux into it, however, our
    users still have to wait three seconds for the initial load. What if we could
    persist the Redux store offline and show it to users while the new data is loading?
  prefs: []
  type: TYPE_NORMAL
- en: 'Sounds good, and it''s very simple too! I have already added two libraries
    to the dependencies list for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '`redux-persist`: [https://github.com/rt2zz/redux-persist](https://github.com/rt2zz/redux-persist)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localForage`: [https://github.com/localForage/localForage](https://github.com/localForage/localForage)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redux-persist` provides a simple way to persist your Redux store and rehydrate
    it whenever needed. This makes your store available offline when your users visit
    your page for the second time.'
  prefs: []
  type: TYPE_NORMAL
- en: '`localForage` is a simple storage library that lets you use `indexDB` using
    an API similar to `localStorage`. `redux-persist` works well with `localStorage`,
    but it recommends using `localForage` as its default storage engine for web browsers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, persisting the Redux store isn''t that complicated; you just need to add
    a few lines of code in the Redux store to persist it and make the reducers listen
    for a *rehydration* action to rehydrate data from the persisted store. It''s as
    easy as changing just the following three files:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The first file*: Open your `configureStore.js` file and add the following
    import statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, change the `return` statement inside your `configureStore` method to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now, this adds the `autoRehydrate()` function while creating the store that
    will emit the rehydrate actions.
  prefs: []
  type: TYPE_NORMAL
- en: '*The second file*: Open your `index.js` file and add the following `import`
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This will import the `persistStore()` function that can persist your store
    and the `localForage` library that will be used as the storage engine. Now, you
    will need to add a single line of code after the line where you created your store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '*The third file**: ***Open your `postsReducer.js` file. In this posts reducer,
    we will listen for another action, which is the rehydrate action emitted while
    rehydrating your persisted Redux store. Redux Persist maintains a set of constants,
    which has defined the rehydrate action similar to how we have defined our actions
    in the `actionTypes.js` file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the reducers file, add the following `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This will import the constants from `redux-persist`. You should then add an
    additional case statement inside the `postsReducer` function, which will hydrate
    the Redux store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This case will check whether the rehydrate action has occurred, and then it
    uses an `if` condition to check whether the rehydrate action contains the `posts`
    property in the action's payload. Refer to the completed code files if you face
    any issues with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, once it is complete, open the application in Chrome and try reloading
    the page. You should see that the posts are available even while the data is loading
    from the server, just like in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This allows the users to use the application offline even while the posts are
    loading. We have completely removed the 3 second loading issue from the blog.
  prefs: []
  type: TYPE_NORMAL
- en: Redux is a great library for managing states in a separate state container.
    It's centralized state management with React proved to be very useful and efficient,
    that many libraries were created for centralized state management in other frameworks
    too, such as `@ngrx/store` for Angular and `vuex` for Vue.js. In this chapter,
    we only covered the basics of Redux--refer to the Redux documentation and its
    tutorial videos to learn Redux in-depth. Also, check out **Redux DevTools** at
    [https://github.com/gaearon/redux-devtools](https://github.com/gaearon/redux-devtools),
    which provides cool features, such as hot reloading and time travel debugging
    for your Redux application.
  prefs: []
  type: TYPE_NORMAL
- en: The author page hasn't been connected to Redux yet. So, do give it a try and
    complete the blog.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! You have successfully completed the Redux chapter and also
    completed the book. In this chapter, we covered what Redux is and how we can use
    it to improve state management. We then created a Redux store with the actions
    and reducers needed to manage the store data. We used the `react-redux` library
    to connect our Redux code with the React components and used props instead of
    states to render the JSX elements.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we used `redux-persist` with `localforage` as the storage engine to
    persist our Redux store and make our application work offline. This chapter has
    made the blog faster and more user-friendly for users.
  prefs: []
  type: TYPE_NORMAL
- en: You has now completed your journey through this book, but you have just got
    started with your journey in exploring the world of JavaScript. There's still
    a lot to learn and a lot more to come. So, be prepared to learn and explore, no
    matter what you want to do.
  prefs: []
  type: TYPE_NORMAL
