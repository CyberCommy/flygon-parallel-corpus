- en: Solving Management Problems with Salty Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will discover and discuss why a business needs to have
    a centralized management utility for its infrastructure, including the high level
    of complexity that a heterogeneous environment brings to the table. We will be
    talking about solutions to this and things such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How new technologies bring complexity to our business
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we can centralize system management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How **infrastructure as code** (**IaC**) help us to maintain our system's state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools that leverage IaC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SaltStack platform and its components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin our journey through system management.
  prefs: []
  type: TYPE_NORMAL
- en: Centralizing system management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the reason behind system management can be easily taken for granted.
    We often assume that just because a business has a big IT infrastructure, it needs
    a solution to manage its inventory. While this is obviously true, there is more
    to it than that. Our job as architects consists of listening to our customers'
    problems and understanding what exactly they are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: New technologies and system management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this ever-evolving IT world, changes come fast. New technologies come out
    almost every day. Technologies such as virtualization, IoT, and the cloud are
    shaping and changing the way we use IT by growing our infrastructures exponentially,
    which the bare-metal era never saw.
  prefs: []
  type: TYPE_NORMAL
- en: All these changes and exponential growth means that IT managers have a lot more
    to manage and far less time to train their staff to support these technologies,
    so many businesses can barely keep up with the pace. This can result in them becoming
    reluctant to adopt new technologies. But many have no choice but to adopt them
    for fear of becoming irrelevant and not being able to satisfy the demands of their
    customers. If their competitors have the advantage and deliver a better and faster
    service, they will likely go out of business.
  prefs: []
  type: TYPE_NORMAL
- en: Companies want to adopt these technologies as soon as possible, to gain an edge
    over their competitors, but new technologies often come with big learning curves.
    During this time, IT staff need to learn how to manage and maintain new systems,
    resulting in keeping critical systems and workloads available becoming a challenge.
    Not complying with our SLAs becomes a real threat; imagine a situation where a
    developer needs the operations team to apply a library patch to our dev environment
    systems in order to test a new release, and because our operations staff (or at
    least half of them) are in training, developers are tempted to bypass the standardized
    change-request process and apply the update themselves. Shadow IT in this type
    of situation is really common, and we need to avoid it at all costs. Shadow IT
    can make our company non-compliant with regulatory standards.
  prefs: []
  type: TYPE_NORMAL
- en: While IT leaders push to adopt new technologies, they are often left with very
    small and declining budgets to do this type of transformation. This also directly
    affects our critical systems and workloads because investment in system management
    declines and moves toward innovation. Moving toward innovation is not a bad thing,
    because it will eventually enable us to provide a better service, but it is important
    to understand that it also has consequences regarding the maintenance of our existing
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: With new technology comes new infrastructure; mixed environments become more
    common every day, and it is crucial to understand how to manage these mixed environments
    in the best and most efficient way possible.
  prefs: []
  type: TYPE_NORMAL
- en: Recovering control of our own infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having control of our infrastructure is the main goal of system management.
    But what does it mean to have control? Inventory listing, version control, automated
    patching, and software distribution are all part of system management. All of
    them are part of a bigger picture where IT regains control of its infrastructure
    and can ensure compliance and standardization across their systems no matter what
    Linux distribution they are running.
  prefs: []
  type: TYPE_NORMAL
- en: Often our systems are separated; this separation is because they might differ
    in their characteristics. We can have systems with Red Hat Enterprise Linux-based
    distributions or Debian-based distributions, systems that have different architectures
    such as x86, power servers, or even ARM. All these systems might not even talk
    to one another or serve the same purpose; all of them become silos that IT has
    to maintain and manage.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine performing all the different tasks that systems' management is about
    on each separate silo by hand without a tool to centralize and automate the tasks.
    Human error is the most direct threat to this type of scenario, followed by the
    large complexity, time, and cost that an IT business has to incur to train its
    staff, hire staff, and buy specific administration tools for each different system
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Centralized tools to disperse problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Centralized configuration management can help us to control changes to systems
    in a controlled, consistent, and stable way. It is perfect for systems that are
    running a cluster or configured for high availability, as all the nodes across
    the cluster have to have the exact same configuration. With configuration management,
    we can also understand the reason behind permissions on certain files, a package
    installed on all the systems, or even a line of code in a configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: These changes or configurations that we implement through a configuration management
    tool can also be rolled back, as most tools available in the market come with
    version control, and any typo, human error, or incompatible update can easily
    be rolled back.
  prefs: []
  type: TYPE_NORMAL
- en: As we slowly transition into cloud environments, virtual machines and resources
    become more and more a commodity and a service. Configuration management tools
    that can help us manage, provision, and maintain our cloud infrastructure become
    very valuable assets. With these types of tool, we can treat our infrastructure
    in a more elastic way, and define it in a descriptive way, in the sense that we
    can have templates that deploy the same infrastructure or implement changes based
    on a definition; this is what we call **infrastructure as code** (**IaC**).
  prefs: []
  type: TYPE_NORMAL
- en: Coding for a desired state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The whole idea behind IaC is to have consistency and versioning within our environment.
    IaC seeks a more descriptive and standard way of provisioning resources, by avoiding
    unique and special deployments to prevent the situation in which recreating an
    environment is highly complex because of the uniqueness of each of its components.
  prefs: []
  type: TYPE_NORMAL
- en: 'IaC tools define configurations via a specific language or via existing languages
    such as YAML or JSON; in the following, we can see an example extract from a Terraform
    template that defines virtual machines in Microsoft Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the world of cloud infrastructures, elasticity is key. Now we don't have
    existing resources provisioned on our datacenters waiting to be used. In the cloud,
    we pay for what we use and having VMs or storage sitting there increasing our
    monthly bill is not ideal. With IaC, we can scale up or scale down those environments
    on demand. For example, we know that we have an application that is at its peak
    consumption only during business hours and requires extra instances to support
    the load. But out of business hours, a single instance is enough to support the
    load. With IaC, we can have a script to create extra instances in the morning
    and lower the instances at the end of the day. Each instance is not unique and
    we can take advantage of configuration management tools that use descriptive files
    via IaC to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: There are several tools that can accomplish the afore mentioned example, but
    many tools don't just provision infrastructure in the cloud or in virtualized
    environments. Other configuration management tools do even more than that; they
    can push configuration files, install packages, create users, or even filesystems.
    There are several ways and methods in which these tools perform their configurations.
    Many tools require an agent, but a few others are agentless.
  prefs: []
  type: TYPE_NORMAL
- en: The way in which configuration management tools perform their changes is essentially
    via a **push** or a **pull**. This will depend (but not always) on whether the
    tool uses an agent or is agentless. Most agentless tools push the configuration
    changes you declare in IaC files and send the changes to either an API in the
    cloud or via SSH when you execute the tool via a command line or a script.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a pull is almost always through an agent. The agent is constantly
    consulting the configuration management server for definitions, verifying the
    desired state in case something was changed to pull those changes from the server
    and apply them to its host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pushes and pulls can be applied in two different ways: in a declarative way
    and in an imperative way. The declarative way specifies what the desired state
    is, and the changes are applied as they are defined in the IaC specification file.
    The imperative way consists of running a set of instructions or commands in a
    specific order to tell the system how to reach the desired state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some open source tools available for configuration management via IaC are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Puppet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chef
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Salt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vagrant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be taking an in-depth look at Salt and its components in the [Chapter
    14](70b68225-f724-4ff8-a1bf-84c77ad23a2b.xhtml), *Getting Your Hands Salty*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding NaCl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned about what IaC is, and the difficulties behind systems management.
    But as architects of future solutions, we need to know and understand which tools
    can help our customers face the challenges that configuration management brings
    to the table.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will be talking about how we can use **Salt**, or **The**
    **SaltStack Platform** as it is also known, to help us achieve a centralized,
    agile, and elastic management infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Salt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Salt is an open source project developed in Python and was created by Tomas
    S Hatch, back in 2011. Originally, it wasn't intended to be a configuration management
    tool, but rather a data collection tool and a remote command execution software
    that leveraged the `ZeroMQ` library. Later the same year, configuration management
    functionalities were added via states, which we will review later.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the fact that Salt is written in Python, it is highly extensible and
    modular, and can easily write customized modules to extend its functionality even
    further.
  prefs: []
  type: TYPE_NORMAL
- en: It is crucial to understand that Salt is not just a configuration management
    tool, but in these chapters, we will be focusing on its configuration management
    capabilities due to the nature of the subject at hand. In the *Further reading*
    section, I will be adding several other book recommendations if you want to learn
    more about other Salt functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: The ways you define desired states in Salt, or in other words the languages
    that Salt supports, are varied. The main and default language is YAML with support
    for `Jinja` templating.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a YAML definition to create a new user can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: YAML is a data-render language for Salt; data renders take definitions in the
    file and then transform them into Python data structures for Salt to consume.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some other data-render languages that Salt supports:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dson`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hjson`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`json5`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pydsl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pyobjects`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stateconf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yamlex`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Salt has two types of renders. The first one is the one we just talked about:
    data-renders. The second one is the text render, which is the category `Jinja`
    falls into. This **text renders** instead of returning a Python data structure,
    they return text instead, which is later translated for the data render.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text renders are useful for setting up variables or loops if we need to repeat
    several definitions with different values but the same structure. For example,
    instead of creating a YAML for each user, we could create a `Jinja` template and
    create several users with the same file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example will create three users instead of creating one user by
    file or definition. This way is more efficient because we not only save time and
    work by not typing the same definition over and over again, we can also easily
    add more users if needed in the array, without having to create an entirely new
    file or definition for the extra user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides `Jinja`, Salt text-renders support other templating engines, such as
    the following :'
  prefs: []
  type: TYPE_NORMAL
- en: '`Cheetah`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Genshi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GPG`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Jinja`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mako`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NaCl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pass`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Wempy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be focusing on `Jinja` and YAML for the rest of the chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The SaltStack platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We previously talked about the different methods and approaches that IaC has.
    Salt is perfect for us to understand all of them because Salt uses both push and
    pull methods and also both **declarative** and **imperative** approaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an overview of Salt''s basic functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1d0cc5a-0093-4414-ae5e-e987537af5bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Like any other client/server cluster, Salt consists of two basic types of node:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Master**: This server, or group of servers, is in charge of coordinating
    the minions and where they query for their desired states. Masters are also the
    ones that send the commands to be executed on minions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minion**: Servers managed by the master.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The master server listens from two TCP ports: `4505` and `4506`. Both ports
    have very different roles and very different connection types.'
  prefs: []
  type: TYPE_NORMAL
- en: The `4505` port or **Publisher** is where all minions listen for messages from
    the master. The `4506` port or the **Request Server** is where minions request
    specific files or data directed directly through them through a secure way. Salt's
    network transport utilizes the ZeroMQ messaging queuing system, which uses **Elliptic
    Curve Cryptography** with 4,096-bit RSA keys that are generated in both the master
    and minions, as we will see later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Salt is an agent-based tool and all communication between masters and minions
    is possible through the agent that is installed on the minions. Minions are in
    charge of initiating communications with the masters.
  prefs: []
  type: TYPE_NORMAL
- en: This matters because, in a segmented network that might or might not have the
    internet in between, you will have many security boundaries between your masters
    and minions, and every minion may not have a unique address defined to it. In
    a scenario where the masters initiate the communications, all your minions in
    the stack might have to have a public IP address, or a lot of networking configuration
    and **network address translation** (**NAT**) has to be implemented every time
    you add a minion to be managed.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the way Salt communications work, you can have your masters in a
    DMZ zone with publicly addressable IP addresses, and all your minions connecting
    to those IPs. You will always have fewer masters than minions, and therefore the
    network configuration that needs to be implemented will decrease significantly.
    Salt is a highly scalable platform, where some stacks contain thousands of minions;
    imagine having to configure the network so that three or four masters can reach
    thousands of minions.
  prefs: []
  type: TYPE_NORMAL
- en: Having masters with public IPs can be scary, but remember that as long as you
    verify the RSA key fingerprints, you can be certain that all communications between
    the nodes are secured thanks to ZeroMQ's cryptography mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Salt capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a brief overview of Salt's architecture, it is time to go through its
    different functionalities and capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Remote command execution modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember that we said that Salt uses both push and pull methods alongside declarative
    and imperative approaches. The remote command execution feature is how we leverage
    Salt's push method in an imperative way.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to run a command in multiple minions or specific minions remotely,
    you will be using **execution modules**. Let''s take a look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command pushed an `ls` to the minions that are registered to the
    master. Let''s take a closer look at the commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`salt`: This is Salt''s most basic command to execute commands in parallel
    on remote minions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''*''`: Indicates that we will be running the command on all servers that
    are managed by our masters; you can also define specific targets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd.run`: The execution module to be invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''ls /home''`: The parameters of the execution module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output**: Ordered by the minion''s name followed by the output of that server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution modules are the most basic form in which Salt uses its remote execution
    framework. Do you remember that Salt is written in Python? Well, execution modules
    are actually Python modules with a set of functions that serve a common purpose.
    Salt comes with several prebuilt modules that you can use, and you can even write
    your own modules and add them to your SaltStack platform. All execution modules
    are supposed to be distribution agnostic, but you can run into some that are not
    available in some distributions. Windows-specific modules are mostly defined by
    a starting `win_` at the beginning of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our previous example, we used the `cmd` module with the `run` function.
    The format in which we work with a function from a module involves defining the
    module to import followed by a period and the function. Whenever a function is
    called, Salt proceeds in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: The Publisher port (`4505`) from the master in which the command was executed
    sends the command to the specified targets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The targeted minions evaluate the command and decide whether they have to run
    the command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Minions that ran the command format the output and send it to the master's request
    server port (`4506`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Knowing what execution modules are will not be enough for us to know what we
    have at our disposal. Many predefined modules are the ones most commonly used,
    and it's worth taking a look at them and what their main functions are.
  prefs: []
  type: TYPE_NORMAL
- en: The sys module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module is the equivalent of the `man` command. With `sys`, we can consult,
    list, and even check which argument accepts each function. You will find yourself
    using mostly the following functions of the `sys` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`list_modules`: This function will list the modules available to the target
    minion. It is important to note that execution modules are executed on the minions
    themselves and not in the master from where the command was executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list_functions`: With `list_functions`, you can list the available functions
    for a certain module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`argspec`: Lists available arguments and default values for the desired function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we can run one of the preceding functions of the `sys` module to see a
    real example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The pkg module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have used a `pkg` function as an example for the `sys` module, I
    want to talk about the `pkg` module. This is another of the most common and used
    modules that Salt offers. This module handles all related package tasks, from
    installing and upgrading to deleting packages. As Salt tries to be as distro-agnostic
    as possible, the `pkg` module actually invokes a set of different modules and
    functions under the hood, specific to the distribution in which the module was
    invoked. For example, if a `pkg.install` was targeting Ubuntu-based systems when
    the minions receive the message, in reality the `aptpkg` module is the one that
    is going to be called in the minion. This is why `pkg` is called a **virtual module**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some different modules invoked by `pkg` are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aptpkg`: For Debian distributions with `apt-get` package management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`brew`: For macOS with Homebrew package management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yumpkg`: Red Hat-based distributions with `yum` or `dnf` as package managers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zypper`: For SUSE-based distributions with `zypper` as the package manager.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of installing the `nginx` web server with `pkg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The test module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Last, but not least, I want to talk to you about the **test module**. The test
    module will allow us to test our SaltStack platform. Things such as checking the
    health status of minions, the Salt version that they are running, and even just
    making them send an echo, are possible with the test module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Different functions of the test module can be found with the `sys.list_functions`
    function, but it is worth mentioning some of the most common ones that you might
    use very frequently:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ping**: The ping function tests for a response from the minions; this is
    not an ICMP ping command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**version**: Returns Salt''s version of your minions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**versions_information**: Returns a full list of all of Salt''s dependencies,
    kernel version, distribution version, and Salt version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Salt states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know about the remote execution framework, we can start exploring
    the rest of the systems that Salt has to offer. The remote execution framework
    is the basis of something called the **state system**. The state system is a declarative
    and idempotent way that leverages IaC files to configure a minion''s desired state.
    The state system utilizes state modules that are much like execution modules but
    with the difference that Salt states actually check whether the desired configuration
    is already present in the minion. For example, let''s take a look at the following
    state definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding state will install the `httpd` (Apache) package in targeted servers
    at runtime but only if the package is not present. If the package is not present,
    the state module will invoke the local `pkg.install` execution function and install
    the package in the minion(s).
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the fact that we `cat` that file from a `/srv/salt` directory. This
    directory is the default location of Salt's state directory tree where state definitions
    are placed. This directory is where you will be creating folders containing formulas,
    which are a set of Salt states that contain all the necessary configurations to
    deploy an application. For example, we can not only install `httpd`, we can also
    configure the virtual hosts and download the Git repos containing the actual websites
    that will be running on that Apache web server.
  prefs: []
  type: TYPE_NORMAL
- en: There is a set of rules that the directory tree follows for you to invoke state
    modules and run formulas, but this will be a subject for the [Chapter 14](70b68225-f724-4ff8-a1bf-84c77ad23a2b.xhtml),
    *Getting Your Hands Salty*, where we will delve into configurations and actual
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: Grains of Salt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned that you can run execution modules by defining the minion name
    or via `*` when running on all minions. But running Salt states and execution
    modules on all the minions in the stack, or on individual minions, is less than
    ideal when you have hundreds or even thousands of minions being managed by your
    masters.
  prefs: []
  type: TYPE_NORMAL
- en: Here is where Salt introduces the `grains` interface, which allows us to identify
    minions by specific characteristics or even set our own type of label or role
    to a group of minions that share a same purpose or characteristics, so we can
    perform more targeted configuration management.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can leverage the `grains` interface with the same syntax in which we would
    execute any command in Salt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding command, we list all the different hardware and software
    characteristics of the system that we targeted. In the output, we can see things
    such as the operating system family, the system architecture, and even the hypervisor
    that we are using to run the VM.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will help us to create state definitions targeting specific systems via
    something called a `top` file, which we will discuss in the [Chapter 14](70b68225-f724-4ff8-a1bf-84c77ad23a2b.xhtml),
    *Getting Your Hands Salty*. An example of a Salt state top file definition using
    `grains` and targeting all `Debian` family VMs will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned before, we can also create custom `grains` in our minions to define
    roles and tag our minions with unique value pairs. This is useful for grouping
    minions in specific tasks; for example, all the VMs of the QA team can be tagged
    with a key value pair, `departement: qa`, for example. Another way of grouping
    could be by role, such as `appfoo: frontend`, and so on. There are many ways to
    use grain targeting, and all will depend on how we want to administer or push
    and maintain the desired states.'
  prefs: []
  type: TYPE_NORMAL
- en: Salt pillars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With **grains**, we can target specific minions, but at the end, we defined
    those targeting policies that are in the top files, which form part of a formula.
    Formulas are usually stored in Git repositories and sometimes even in public ones.
    That's why we can't, or rather we shouldn't, declare sensitive information in
    Salt states. The same happens with Dockerfiles as we saw in our previous chapters,
    and Kubernetes solves this with the **Secrets** API object. Salt has its own version
    of secrets and it's called **Pillars**.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike grains, pillars are stored in the masters instead of the minions. Only
    minions that are targeted by the pillar will have access to the information in
    the pillar. This, again, makes it perfect for sensitive information. When storing
    sensitive information, pillars can also be encrypted at rest, and thanks to Salt's
    render system, pillars will be decrypted during pillar compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pillars decreases the surface area of sensitive data by only storing it in
    the master:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c44ef113-4680-4ff0-9da5-1e8e641f4288.png)'
  prefs: []
  type: TYPE_IMG
- en: With Salt pillars, we finish our brief overview of the basic components that
    the SaltStack platform has to offer. We will be discussing them in more depth
    and working with real-life examples in [Chapter 14](70b68225-f724-4ff8-a1bf-84c77ad23a2b.xhtml),
    *Getting Your Hands Salty*, so you can get hands-on and start managing systems
    through Salt.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the different problems that businesses face when
    it comes to maintaining their infrastructures. We went through different technologies
    such as IaC and centralized system management. We went through the different methods
    whereby IaC **pushes** or **pulls** changes into managed systems and learned about
    several applications that leverage IaC.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed what Salt is and its different components that help us achieve
    a centralized managed infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to design a Salt solution and install
    the software.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is systems management?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the challenges behind systems' management?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What applications can help us with system management?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Infrastructure as Code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the different types of method with which we can manage our systems?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Salt?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are Salt's different components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Gartner**: ''**Every budget is an IT budget**'''
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forrester:** [https://www.forrester.com/report/Cloud+Investments+Will+Reconfigure+Future+IT+Budgets/-/E-RES83041#](https://www.forrester.com/report/Cloud+Investments+Will+Reconfigure+Future+IT+Budgets/-/E-RES83041#)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Declarative vs. Imperative Models for Configuration Management**: [https://www.upguard.com/blog/articles/declarative-vs.-imperative-models-for-configuration-management](https://www.upguard.com/blog/articles/declarative-vs.-imperative-models-for-configuration-management)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SALTSTACK**: [https://s.saltstack.com/beyond-configuration-management/](https://s.saltstack.com/beyond-configuration-management/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Salt Configuration Management**: [https://red45.wordpress.com/2011/05/29/salt-configuration-management/](https://red45.wordpress.com/2011/05/29/salt-configuration-management/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Renderers**: [https://docs.saltstack.com/en/latest/ref/renderers/](https://docs.saltstack.com/en/latest/ref/renderers/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote Execution**: [https://docs.saltstack.com/en/getstarted/system/execution.html](https://docs.saltstack.com/en/getstarted/system/execution.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Targeting using grains**: [https://docs.saltstack.com/en/latest/topics/targeting/grains.html](https://docs.saltstack.com/en/latest/topics/targeting/grains.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grains**: [https://docs.saltstack.com/en/latest/topics/grains/](https://docs.saltstack.com/en/latest/topics/grains/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions**: [https://docs.saltstack.com/en/getstarted/config/functions.html](https://docs.saltstack.com/en/getstarted/config/functions.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
