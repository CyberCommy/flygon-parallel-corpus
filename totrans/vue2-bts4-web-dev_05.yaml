- en: Chapter 6. Please Authenticate!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。请进行身份验证！
- en: In the previous chapter, we connected our ProFitOro application to the real-time
    database. Whenever a user updates the Pomodoro timer settings, these are stored
    in the database and immediately propagated between the components that use them.
    Since we had no authentication mechanism, we had to use a fake user in order to
    be able to test our changes. In this chapter, we are going to have real users!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们将ProFitOro应用程序连接到了实时数据库。每当用户更新番茄钟计时器设置时，这些设置都会存储在数据库中，并立即在使用它们的组件之间传播。由于我们没有身份验证机制，我们不得不使用一个虚假用户来测试我们的更改。在本章中，我们将拥有真正的用户！
- en: 'We will use the Firebase authentication API in this regard. So in this chapter,
    we are going to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，我们将使用Firebase身份验证API。因此，在本章中，我们将做以下事情：
- en: Discuss the meaning of AAA and the difference between authentication and authorization
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论AAA的含义以及身份验证和授权之间的区别
- en: Explore the Firebase authentication API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Firebase身份验证API
- en: Create a page for sign-in and login, and connect it with the Firebase authentication
    API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个登录页面，并将其与Firebase身份验证API连接
- en: Connect the user's settings with the user's authentication
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用户的设置与用户的身份验证连接起来
- en: AAA explained
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释AAA
- en: '**Triple-A**, or **AAA**, stands for **Authentication, Authorization, and Accounting**.
    Initially, this term was invented as a term to describe the security network protocol;
    however, it can be easily applied to any system, web resource, or site.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**AAA**代表**身份验证、授权和计费**。最初，这个术语是用来描述安全网络协议的，然而，它可以很容易地应用于任何系统、网络资源或站点。'
- en: So, what does AAA mean and why should we bother?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，AAA是什么意思，为什么我们要关心呢？
- en: '**Authentication** is the process of uniquely identifying the users of a system.
    An authenticated user is a user whose access to a system is granted. Usually,
    the authentication is done via some username and password. When you have to provide
    your username and password to open your Facebook page, you are authenticating
    yourself.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**身份验证**是唯一识别系统用户的过程。经过身份验证的用户是被授予对系统访问权限的用户。通常，身份验证是通过一些用户名和密码来完成的。当您必须提供用户名和密码来打开您的Facebook页面时，您正在进行身份验证。'
- en: Your passport is a way of authenticating yourself at the airport. The passport
    control agent will look at your face and then check your passport. So anything
    that allows you to *pass* is a part of your authentication. It can be a special
    word (password) that is only known by you and the system or it can be something
    that you port (passport) with you that can help the system to uniquely identify
    you.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您的护照是在机场验证自己身份的一种方式。护照控制人员会看着你的脸，然后检查你的护照。因此，任何允许您“通过”的东西都是您身份验证的一部分。它可以是一个只有您和系统知道的特殊词（密码），也可以是您随身携带的可以帮助系统唯一识别您的东西（护照）。
- en: '**Authorization** is a way to control what resources each user has rights (permissions)
    to access. If you are developing Facebook applications, you have access to the
    developer''s page, whereas usual users don''t have access to this page.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**授权**是一种控制每个用户有权（权限）访问哪些资源的方式。如果您正在开发Facebook应用程序，您可以访问开发者页面，而普通用户无法访问此页面。'
- en: '**Accounting** measures resources allocated for each user. If you have a Dropbox
    business standard account, you can use up to 2 TB of storage space, whereas having
    a normal free Dropbox account gives you only 2 GB of space.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**计费**衡量为每个用户分配的资源。如果您拥有Dropbox商业标准帐户，您可以使用高达2TB的存储空间，而拥有普通免费Dropbox帐户只能获得2GB的空间。'
- en: For our application, we should be concerned with the first two As of Triple-A
    – *Authentication* and *Authorization*. In computer science, we often use term
    **auth**, referring rather to authentication or authorization or even to both
    of them at the same time. So we will implement auth, where auth refers to both
    authentication and authorization. What is the difference between these two terms
    in the context of our ProFitOro application? Well, authentication will allow users
    to log in to the system, so this is easy. What about authorization?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember that we decided that only authenticated users will have access
    to the configuration of Pomodoro settings and statistical data? This is authorization.
    Later on, we might go further and implement a special role – fitness trainer.
    The users with this role will have access to the workouts area and be able to
    add new workouts.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use the Firebase authentication mechanism to add the
    possibility of signing in and logging in to our application and to control what
    users have access to.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: How does authentication work with Firebase?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to use the Firebase API to create a
    Firebase application instance and use it through your application. We were able
    to access the database, read it, and store data in it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'The way you work with the Firebase authentication API is very similar. You
    create a Firebase instance, providing a `config` object to it, and you use the
    `firebase.auth()` method to access different methods related with the authentication.
    Check your Firebase console''s **Authentication** tab:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![How does authentication work with Firebase?](../images/00095.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: There are no users yet but we will fix it in a minute!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'The Firebase SDK provides several ways for users to authenticate:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '**Email and password based authentication**: The classic way for authenticating
    users. Firebase provides a way to sign in users with email/password and log them
    in. It also provides methods to reset the user password.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Federated entity provider authentication**: The way of authenticating users
    with an external entity provider, such as Google, Facebook, Twitter, or GitHub.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phone number authentication**: The way of authenticating users by sending
    them an SMS with a code that they will have to input to confirm their identity.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom auth system integration**: The way of integrating an already existing
    auth solution with the Firebase authentication API.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Anonymous user authentication**: The way of providing Firebase features (such
    as access to the Firebase database) without being authenticated. We can, for example,
    use this anonymous account to provide access to the default configuration stored
    in the database.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our application, we will use the first and the last methods, so we will
    allow users to sign in and log in using their email and password combination and
    we will allow anonymous users to use the basic functionality of the application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'You should explicitly activate both methods in your Firebase console. Just
    open the **Authentication** tab of your Firebase project, click on the sign-in
    method link, and enable these two methods:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![How does authentication work with Firebase?](../images/00096.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: Explicitly enable email/password and the anonymous sign-in methods
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'The workflow of using the Firebase authentication API is the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Create all the necessary methods for the sign-in and login.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement all the necessary UI for your authentication.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect changes in the UI to the authentication methods.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Did you spot something nice in step 3? *Connect changes in the UI to the authentication
    methods*. You remember that we are dealing with a reactive data binding framework,
    don't you? So this is going to be fun!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: How to connect the Firebase authentication API to a web application
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to connect your application to the Firebase authentication API, you
    should start by creating a Firebase application instance:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can find the necessary keys and URLs in the popup that opens if you click
    on the **Web Setup** button:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![How to connect the Firebase authentication API to a web application](../images/00097.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: The setup config to use Firebase in a web application
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can use the app instance to access the `auth()` object and its methods.
    Check out the official Firebase documentation regarding the authentication API:
    [https://firebase.google.com/docs/auth/users](https://firebase.google.com/docs/auth/users).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important part of the API for us is the methods to create and sign
    in a user, and the method that listens to the changes in the authentication state:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The method that listens to the changes in the authentication state of the application
    is called `onAuthStateChanged`. You can set the important properties inside of
    this method considering the state your application needs to have depending on
    the user being logged in or not:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That is all! In our application, we just have to provide a visual way to pass
    the username and the password to the API.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating to the ProFitOro application
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us now make signing in and logging in to our ProFitOro application possible!
    First, we have to set up the Firebase instance and figure out where we should
    put all the methods related to authentication. The Firebase application initialization
    has already been done inside the `store/index.js` file. Just add the `apiKey`
    and `authDomain` configuration entries if you still do not have them included
    in the `config`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'I will also export `firebaseApp` within the store''s state property using the
    spread `…` operator:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'I will also add a `user` property to our state so we can reset it on the `onAuthStateChanged`
    listener''s handler:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let us also create a small mutation that will reset the value of the `user`
    object to the given value:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we are totally ready to create the needed actions. I will create four actions
    that are indispensable for our application:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '`createUser`: This action will call the Firebase auth `createUserWithEmailAndPassword`
    with the given email and password'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`authenticate`: This action will call the Firebase auth `signInWithEmailAndPassword`
    method to sign in the user with the given email and password'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logout`: This action will call the Firebase auth `signOut` method'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bindAuth`: This action will just set up the `onAuthStateChanged` callback
    and commit the `setUser` mutation'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To start with, let us implement these actions in a very easy way, without any
    callbacks attached. So they will look like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Great! Now let''s attach the `bindAuth` action to the `created` method of the
    main `App.vue` component:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, once the application is created, the listener to the authentication state
    will be bound immediately. What can we do with it? Right now, the only component
    that the `App.vue` component shows immediately is the main content component.
    However, if the user is not logged in, we should actually show the landing page
    component to offer the possibility to the user to sign in or log in. We can do
    it easily using the `v-if` directive bound to the `user` property. If the user
    is defined, let''s show the main content component; otherwise, let''s show the
    landing page component. How easy is that? Our `App.vue` component''s template
    will look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you open the page now, you will see that the landing page is displayed:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![Authenticating to the ProFitOro application](../images/00098.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: When the application is started, the landing page is displayed because the user
    is not logged in
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: All the relevant code up to this part is in the `chapter6/1/profitoro` folder.
    Pay special attention to the store's files (`index.js, actions.js, mutations.js,
    state.js`) and to the `App.vue` component.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Now we are stuck on the landing page that just displays some placeholder text
    and there is no way to proceed to the application because we cannot log in!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, this is quite easy to solve: let''s create a simple form to sign up and
    log in in the `Authentication.vue` component and connect it with our actions.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'So I will add the component''s data that will hold the email for registering,
    email for login, and the corresponding passwords:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'I will also add a very simple markup that will display the inputs for the corresponding
    data:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s now import the necessary actions (`authenticate` and `createUser`) and
    create methods that will call these actions:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we just have to attach the event binding the `v-on:click` directive to
    the corresponding buttons:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s also add a button to our `HeaderComponent.vue` component. This button
    should allow the user to log out. This is very easy; we don''t even have to create
    any method, we just have to bind the event to the actual action. So the whole
    markup and the needed script will look as simple as this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And…that's it! Open the page and try to register in your application! It works!
    Once you are logged in, not only you will see the Pomodoro timer but you will
    also be able to see the logout button. Click on it and check that you are actually
    thrown out of the application to the landing page. Try to log in again. Everything
    works like a charm.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Do not forget to open your Firebase console and check the **Authentication**
    tab. You should see all your registered users there:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![Authenticating to the ProFitOro application](../images/00099.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: Monitor your registered users through the Firebase console's Authentication
    tab
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You just used the Firebase authentication API to implement
    a full authentication mechanism for your application. You can find the corresponding
    code in the `chapter6/2/profitoro` folder. Pay special attention to the `Authentication.vue`
    and `HeaderComponent.vue` components.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Making the authentication UI great again
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just implemented the authentication mechanism for our ProFitOro application.
    That's great, but the UI of our authentication page looks as if we've used a time
    machine and gone back 20 years to the early days of the internet. Let's fix it
    using our powerful friend – Bootstrap.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: First of all, I would like to make my landing page layout a two-column grid
    layout, so the whole sign-in/login belongs to the left column and the button that
    leads the user to the application without being registered stays on the right
    side. However, I would like these two columns to be stacked on mobile devices.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'This is nothing new for you; I suppose that you remember how to use Bootstrap''s
    grid layout in order to achieve this behavior: [https://v4-alpha.getbootstrap.com/layout/grid/](https://v4-alpha.getbootstrap.com/layout/grid/).
    So, in our `LandingPage` component, I will just wrap the authentication and `go-to-app-link`
    components into the `div` with the `row` class and add the corresponding `col-*`
    classes to these components:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That''s it! Now you have a nice two-column layout, which transforms into the
    single-column layout on small-sized devices:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![Making the authentication UI great again](../images/00100.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: This is how our layout looks on the desktop device
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, on the desktop device, we have a nice two-column layout. If
    you resize your browser to the size of a mobile device, the right column jumps
    behind the left column:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![Making the authentication UI great again](../images/00101.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: This is how our layout looks on the mobile device
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s have a look at our `Authentication.vue` component. In order to make
    it nicer than a 20-year-old web page, let''s apply Bootstrap''s magic to it. To
    do so, we will use the classes of Bootstrap''s forms: [https://v4-alpha.getbootstrap.com/components/forms/](https://v4-alpha.getbootstrap.com/components/forms/).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'We will wrap the whole form into the `<form>` tag and each of the inputs into
    the `div` with the `form-group` class. We will also add the class `form-control`
    to each of the inputs. So the input for email, for example, will look as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As a small exercise, do the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Make it only one form that has a button to switch between the login and sign-up
    forms
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make it only one method that would call one of the actions depending on which
    state the form is in at the moment
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Explore Bootstrap''s utilities classes to remove all the borders except the
    bottom border and to remove the round corners from them: [https://v4-alpha.getbootstrap.com/utilities/borders/](https://v4-alpha.getbootstrap.com/utilities/borders/)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the end, your form should look like the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Making the authentication UI great again](../images/00102.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: This is how both forms should be looking at the end. They should be toggled
    with a bottom button
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Try to achieve it by yourself. To check your work, have a look at the `chapter6/3/profitoro`
    folder. In particular, check the code of the `Authentication.vue` component. It
    is very different!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Managing the anonymous user
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ProFitOro allows unregistered users to use the application as well. The only
    difference is that these unregistered users are not allowed to configure their
    settings as well, as they do not have access to their statistical data. They also
    cannot manage workouts. So, this is where we meet the second A of the triple-A
    definition – *authorization*. How can we manage these users? How can they actually
    enter the application if we only allow our users to sign up and log in? Well,
    for some reason, we have prepared the part that says **Go to App**. Let me remind
    you how it looks in the mockups:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing the anonymous user](../images/00103.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: Start without registration! button in the initial mockups
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily for us, the Firebase authentication API provides a method to sign in
    the anonymous user. The returned user object contains the `isAnonymous` attribute,
    which will allow us to manage the resources that can or can''t be accessible to
    this anonymous user. So let''s add the action called `authenticateAnonymous` and
    call the corresponding Firebase `auth` method within it:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here we are! Now let''s just slightly modify a mutation that sets the user
    and the **isAnonymous** state''s attribute to the corresponding one in the user
    object:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s also modify the binding configuration and statistics actions and execute
    the actual binding only if the user is set and only if the user is not anonymous:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We are done with the backend! Now let''s implement this button! There are only
    three steps to achieve it. Open the `GoToAppLink.vue` component, import the `mapActions`
    helper, add the button, and use the `v-on:click` directive to bind the event listener
    to it that will call the corresponding action:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'How easy is that? Now, as a small exercise, with the help of Bootstrap, try
    to make things look like the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing the anonymous user](../images/00104.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: Use the corresponding Bootstrap classes to make our buttons look like this and
    to align the columns vertically
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Check Bootstrap''s classes for alignment: [https://v4-alpha.getbootstrap.com/layout/grid/#alignment](https://v4-alpha.getbootstrap.com/layout/grid/#alignment).
    Check as well the helper classes to get rid of rounded corners. Check yourself
    by having a look at the code in the `chapter6/4/profitoro` folder. Pay special
    attention to the `GoToAppLink.vue` component and to the store''s components, such
    as `action.js` and `mutations.js`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Personalizing the Pomodoro timer
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, now that we can already sign in new users and log in the existing ones,
    probably we should think about taking advantage of our authentication mechanism
    because right now we are actually not doing anything with it. We just sign up
    and we just log in. Yes, we also can hide or show some content based on the user's
    authentication, but this is not enough. The whole point of all this effort was
    to be able to store and retrieve the user's custom configuration for the Pomodoro
    timer and the user's statistical data.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, we have been using a hardcoded database object with the key `test`
    in order to access the user''s data, but now, since we already have our real users,
    it''s time to populate the database with real users'' data and use it in our application.
    Actually, the only thing we have to do is to replace this hardcoded value with
    the actual user''s ID. So, for example, our code to bind the `config` reference
    was looking like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, the reference `state.configRef` has been defined in the store''s entry
    point `index.js`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we cannot actually instantiate our database references within the store''s
    entry point, because at this point (no pun intended), we still don''t know whether
    or not our user is authenticated. So the best thing to do is to pass this code
    to the actual `bindConfig` function and to replace this `test` with the real user''s
    *uid*:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, my dear attentive user, I know that you are exclaiming "but how the hell
    is the configuration with the user''s *uid* stored?" Very well noticed: it''s
    not. We still have to store it on our user''s first sign-up. We actually have
    to store both configuration and statistics.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'The Firebase database provides a method to write new data to the database that
    is called `set`. So you basically obtain the reference (just like in the case
    of reading data) and set the data you need to write:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will create a new entry with a given user ID in our configuration table
    and set the default state''s `config` data. So we will have to call this method
    on the new user creation. We will still have to bind the database references to
    our state objects. In order to reduce the amount of code, I created a method,
    `bindFirebaseReference`, that receives the reference and the string that represents
    the key of the state to which it should be bound. This method will analyze whether
    or not the entry for the given reference already exists in the database and will
    create it if needed. For that, Firebase provides a nice method that can be applied
    to nearly everything – this method is called `once` and it receives a callback
    with a snapshot to whatever it has been applied to. So, inside this callback,
    we can analyze whether or not this snapshot has a child with a given name, or
    even if it has a value or it''s `null`. If the value is already set, we will bind
    our state to it. If not, we will create a new entry. Check out the official Firebase
    documentation in this regard: [https://firebase.google.com/docs/database/web/read-and-write](https://firebase.google.com/docs/database/web/read-and-write).
    This is what the `once` method and its callback looks like:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![Personalizing the Pomodoro timer](../images/00105.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: How to use the once method to check whether the data exists in the database
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Disregarding the existence or not of data, our binding reference method should
    call the Firebase bindings. So it will look as the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'I also replaced both methods that were binding `config` and `statistics` by
    only one:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This method is being called from the `bindAuth` method. So now we can remove
    the calls to the actions to bind `config` and `statistics` from the `created`
    method of our `App.vue`. We also don't need the instantiation of references in
    the `store/index.js` since both references are instantiated within this new method.
    And we have to add two mutations that will set the references to the state so
    we don't need to change our Pomodoro configuration settings actions since they
    are using both references to update the data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Check what the code looks like in the `chapter6/5/profitoro` folder. Check out
    the slight changes in the `App.vue` component, and check what the store's files
    are looking like now (`index.js`, `mutations.js`, `state.js`, and especially `actions.js`).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Play with your application. Sign up, log in, change the Pomodoro timer configuration,
    log out, and check that it works. Check your Firebase console – the **Realtime
    Database** tab and **Authentication** tab. Check that whatever you change, you
    have your data consistent everywhere – in your database, in your **Authentication**
    tab, and, most importantly, in your application (because the application is what
    your users are going to see, right?):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![Personalizing the Pomodoro timer](../images/00106.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: Check that the data is consistent everywhere
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: So now we can sign up a new user, log in as an existing user, and log in as
    an anonymous user. We provide a nice value to the authenticated users – to be
    able to configure their Pomodoro timer and to check their statistical data. Of
    course, our application is still far from being perfect – we don't validate the
    input, we accept any values in the Pomodoro configuration area, which is not right,
    and we don't display the possibility of changing passwords on the startup page.
    BUT we have our solid skeleton, which enables us to build a solid and nice application
    on its base. So let us move on!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Updating a user's profile
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Wouldn''t it be funny if we could welcome our user by displaying a welcome
    message saying something like **Welcome Olga**? But our users do not have names;
    they only have emails and passwords – two essential authentication components
    that are passed during the sign-up process. So, how can we do that? Well, if you
    have read with some attention the Firebase documentation regarding authentication
    ([https://firebase.google.com/docs/auth/web/manage-users](https://firebase.google.com/docs/auth/web/manage-users)),
    you might have spotted these nice methods:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating a user''s profile](../images/00107.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: Firebase methods for updating a user's profile and email address
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Let's use these methods to update our user's profile and user's profile picture!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: We will define three new actions – one that will update the user's display name
    by calling the Firebase `updateProfile` method, one that will update the user's
    profile picture's URL by calling the same method, and another one that will call
    the `updateEmail` method. Then we will create the necessary markup in the `Settings.vue`
    component that will bind those actions on the corresponding input's update. Sounds
    easy, right? Believe me, it's as easy to implement as it actually sounds.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s define our actions. They will look like the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Great! Now let''s switch to our `Settings.vue` component, which will be responsible
    for rendering the needed data to change the account settings and for updating
    this data by calling the needed actions when needed. So first of all, I will add
    three entries to the data function that will be set to the current user object''s
    corresponding attributes once the component is `created`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now this data can be used within the corresponding actions. So, let''s import
    the needed actions and create the corresponding methods:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we can add the needed markup full of the inputs to which we will bind the
    data using the `v-model` data binding directive! We will also call the corresponding
    methods on each input''s update:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: And…we are done!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'As a small exercise, do the following: add a figure caption behind our image
    that says **Change profile picture**. The input element for the new picture URL
    should only be visible when the user clicks on this figure caption. Once the URL''s
    updating is done, the input should become invisible again.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'The result should look like the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating a user''s profile](../images/00108.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: This is how it looks before the user clicks the Change profile picture caption
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Initially, it contains the default user picture.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'After the user clicks on the caption, the input for changing the picture''s
    URL appears:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating a user''s profile](../images/00109.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: After the user clicks on the figure caption, the input appears
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'After the user changes the profile picture URL, the input is hidden again:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating a user''s profile](../images/00110.jpeg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: After the user changes the URL for the profile picture, the input disappears
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'My advice: add an additional property to the `Settings.vue` component''s data,
    set it to `true` when the user clicks on the caption, and reset it to `false`
    when the value inside the input is changed.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, don''t forget about our initial aim for this section – add a welcoming
    message inside the `Header.vue` component. This welcoming message should contain
    the user''s display name. It should look something like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating a user''s profile](../images/00111.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: Welcoming message mentioning the user's name
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you decide to change your email, you will have to log out and log
    in again; otherwise, you will get some Firebase security errors in your console.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The final code for this chapter can be found in the `chapter6/6/profitoro` folder.
    Note that I split both the account settings and the Pomodoro settings with two
    individual components (`AccountSettings.vue` and `PomodoroTimerSettings.vue`).
    It makes things easier to maintain. Pay attention to the store's components as
    well. Check the `Header.vue` component and how it actually displays the welcoming
    message.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to combine the Firebase real-time database
    and authentication API to update a user's settings. We have built a user interface
    that allows a user to update their profile settings. In just a few minutes, we
    have built the full authentication and authorization part of our application.
    I don't know about you, but I feel totally amazed about it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will finally get rid of this huge page that contains
    all the parts of our application – the Pomodoro timer itself, statistics data,
    and the settings configuration view. We will explore one really nice and important
    feature of Vue – `vue-router`. We will combine it with Bootstrap's navigation
    system in order to achieve a nice and smooth navigation. We will also explore
    such a hot topic as code splitting in order to achieve lazy loading for our application.
    So, let's go!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
