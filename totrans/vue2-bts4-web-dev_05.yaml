- en: Chapter 6. Please Authenticate!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we connected our ProFitOro application to the real-time
    database. Whenever a user updates the Pomodoro timer settings, these are stored
    in the database and immediately propagated between the components that use them.
    Since we had no authentication mechanism, we had to use a fake user in order to
    be able to test our changes. In this chapter, we are going to have real users!
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the Firebase authentication API in this regard. So in this chapter,
    we are going to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Discuss the meaning of AAA and the difference between authentication and authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore the Firebase authentication API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a page for sign-in and login, and connect it with the Firebase authentication
    API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect the user's settings with the user's authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AAA explained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Triple-A**, or **AAA**, stands for **Authentication, Authorization, and Accounting**.
    Initially, this term was invented as a term to describe the security network protocol;
    however, it can be easily applied to any system, web resource, or site.'
  prefs: []
  type: TYPE_NORMAL
- en: So, what does AAA mean and why should we bother?
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication** is the process of uniquely identifying the users of a system.
    An authenticated user is a user whose access to a system is granted. Usually,
    the authentication is done via some username and password. When you have to provide
    your username and password to open your Facebook page, you are authenticating
    yourself.'
  prefs: []
  type: TYPE_NORMAL
- en: Your passport is a way of authenticating yourself at the airport. The passport
    control agent will look at your face and then check your passport. So anything
    that allows you to *pass* is a part of your authentication. It can be a special
    word (password) that is only known by you and the system or it can be something
    that you port (passport) with you that can help the system to uniquely identify
    you.
  prefs: []
  type: TYPE_NORMAL
- en: '**Authorization** is a way to control what resources each user has rights (permissions)
    to access. If you are developing Facebook applications, you have access to the
    developer''s page, whereas usual users don''t have access to this page.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accounting** measures resources allocated for each user. If you have a Dropbox
    business standard account, you can use up to 2 TB of storage space, whereas having
    a normal free Dropbox account gives you only 2 GB of space.'
  prefs: []
  type: TYPE_NORMAL
- en: For our application, we should be concerned with the first two As of Triple-A
    – *Authentication* and *Authorization*. In computer science, we often use term
    **auth**, referring rather to authentication or authorization or even to both
    of them at the same time. So we will implement auth, where auth refers to both
    authentication and authorization. What is the difference between these two terms
    in the context of our ProFitOro application? Well, authentication will allow users
    to log in to the system, so this is easy. What about authorization?
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember that we decided that only authenticated users will have access
    to the configuration of Pomodoro settings and statistical data? This is authorization.
    Later on, we might go further and implement a special role – fitness trainer.
    The users with this role will have access to the workouts area and be able to
    add new workouts.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use the Firebase authentication mechanism to add the
    possibility of signing in and logging in to our application and to control what
    users have access to.
  prefs: []
  type: TYPE_NORMAL
- en: How does authentication work with Firebase?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to use the Firebase API to create a
    Firebase application instance and use it through your application. We were able
    to access the database, read it, and store data in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way you work with the Firebase authentication API is very similar. You
    create a Firebase instance, providing a `config` object to it, and you use the
    `firebase.auth()` method to access different methods related with the authentication.
    Check your Firebase console''s **Authentication** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How does authentication work with Firebase?](../images/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There are no users yet but we will fix it in a minute!
  prefs: []
  type: TYPE_NORMAL
- en: 'The Firebase SDK provides several ways for users to authenticate:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Email and password based authentication**: The classic way for authenticating
    users. Firebase provides a way to sign in users with email/password and log them
    in. It also provides methods to reset the user password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Federated entity provider authentication**: The way of authenticating users
    with an external entity provider, such as Google, Facebook, Twitter, or GitHub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phone number authentication**: The way of authenticating users by sending
    them an SMS with a code that they will have to input to confirm their identity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom auth system integration**: The way of integrating an already existing
    auth solution with the Firebase authentication API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Anonymous user authentication**: The way of providing Firebase features (such
    as access to the Firebase database) without being authenticated. We can, for example,
    use this anonymous account to provide access to the default configuration stored
    in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our application, we will use the first and the last methods, so we will
    allow users to sign in and log in using their email and password combination and
    we will allow anonymous users to use the basic functionality of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should explicitly activate both methods in your Firebase console. Just
    open the **Authentication** tab of your Firebase project, click on the sign-in
    method link, and enable these two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How does authentication work with Firebase?](../images/00096.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Explicitly enable email/password and the anonymous sign-in methods
  prefs: []
  type: TYPE_NORMAL
- en: 'The workflow of using the Firebase authentication API is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create all the necessary methods for the sign-in and login.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement all the necessary UI for your authentication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect changes in the UI to the authentication methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Did you spot something nice in step 3? *Connect changes in the UI to the authentication
    methods*. You remember that we are dealing with a reactive data binding framework,
    don't you? So this is going to be fun!
  prefs: []
  type: TYPE_NORMAL
- en: How to connect the Firebase authentication API to a web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to connect your application to the Firebase authentication API, you
    should start by creating a Firebase application instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find the necessary keys and URLs in the popup that opens if you click
    on the **Web Setup** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to connect the Firebase authentication API to a web application](../images/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The setup config to use Firebase in a web application
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can use the app instance to access the `auth()` object and its methods.
    Check out the official Firebase documentation regarding the authentication API:
    [https://firebase.google.com/docs/auth/users](https://firebase.google.com/docs/auth/users).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important part of the API for us is the methods to create and sign
    in a user, and the method that listens to the changes in the authentication state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The method that listens to the changes in the authentication state of the application
    is called `onAuthStateChanged`. You can set the important properties inside of
    this method considering the state your application needs to have depending on
    the user being logged in or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: That is all! In our application, we just have to provide a visual way to pass
    the username and the password to the API.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating to the ProFitOro application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us now make signing in and logging in to our ProFitOro application possible!
    First, we have to set up the Firebase instance and figure out where we should
    put all the methods related to authentication. The Firebase application initialization
    has already been done inside the `store/index.js` file. Just add the `apiKey`
    and `authDomain` configuration entries if you still do not have them included
    in the `config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'I will also export `firebaseApp` within the store''s state property using the
    spread `…` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'I will also add a `user` property to our state so we can reset it on the `onAuthStateChanged`
    listener''s handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us also create a small mutation that will reset the value of the `user`
    object to the given value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are totally ready to create the needed actions. I will create four actions
    that are indispensable for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`createUser`: This action will call the Firebase auth `createUserWithEmailAndPassword`
    with the given email and password'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`authenticate`: This action will call the Firebase auth `signInWithEmailAndPassword`
    method to sign in the user with the given email and password'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logout`: This action will call the Firebase auth `signOut` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bindAuth`: This action will just set up the `onAuthStateChanged` callback
    and commit the `setUser` mutation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To start with, let us implement these actions in a very easy way, without any
    callbacks attached. So they will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Now let''s attach the `bindAuth` action to the `created` method of the
    main `App.vue` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, once the application is created, the listener to the authentication state
    will be bound immediately. What can we do with it? Right now, the only component
    that the `App.vue` component shows immediately is the main content component.
    However, if the user is not logged in, we should actually show the landing page
    component to offer the possibility to the user to sign in or log in. We can do
    it easily using the `v-if` directive bound to the `user` property. If the user
    is defined, let''s show the main content component; otherwise, let''s show the
    landing page component. How easy is that? Our `App.vue` component''s template
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you open the page now, you will see that the landing page is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Authenticating to the ProFitOro application](../images/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When the application is started, the landing page is displayed because the user
    is not logged in
  prefs: []
  type: TYPE_NORMAL
- en: All the relevant code up to this part is in the `chapter6/1/profitoro` folder.
    Pay special attention to the store's files (`index.js, actions.js, mutations.js,
    state.js`) and to the `App.vue` component.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are stuck on the landing page that just displays some placeholder text
    and there is no way to proceed to the application because we cannot log in!
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, this is quite easy to solve: let''s create a simple form to sign up and
    log in in the `Authentication.vue` component and connect it with our actions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So I will add the component''s data that will hold the email for registering,
    email for login, and the corresponding passwords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'I will also add a very simple markup that will display the inputs for the corresponding
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now import the necessary actions (`authenticate` and `createUser`) and
    create methods that will call these actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we just have to attach the event binding the `v-on:click` directive to
    the corresponding buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also add a button to our `HeaderComponent.vue` component. This button
    should allow the user to log out. This is very easy; we don''t even have to create
    any method, we just have to bind the event to the actual action. So the whole
    markup and the needed script will look as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: And…that's it! Open the page and try to register in your application! It works!
    Once you are logged in, not only you will see the Pomodoro timer but you will
    also be able to see the logout button. Click on it and check that you are actually
    thrown out of the application to the landing page. Try to log in again. Everything
    works like a charm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do not forget to open your Firebase console and check the **Authentication**
    tab. You should see all your registered users there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Authenticating to the ProFitOro application](../images/00099.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Monitor your registered users through the Firebase console's Authentication
    tab
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You just used the Firebase authentication API to implement
    a full authentication mechanism for your application. You can find the corresponding
    code in the `chapter6/2/profitoro` folder. Pay special attention to the `Authentication.vue`
    and `HeaderComponent.vue` components.
  prefs: []
  type: TYPE_NORMAL
- en: Making the authentication UI great again
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just implemented the authentication mechanism for our ProFitOro application.
    That's great, but the UI of our authentication page looks as if we've used a time
    machine and gone back 20 years to the early days of the internet. Let's fix it
    using our powerful friend – Bootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, I would like to make my landing page layout a two-column grid
    layout, so the whole sign-in/login belongs to the left column and the button that
    leads the user to the application without being registered stays on the right
    side. However, I would like these two columns to be stacked on mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is nothing new for you; I suppose that you remember how to use Bootstrap''s
    grid layout in order to achieve this behavior: [https://v4-alpha.getbootstrap.com/layout/grid/](https://v4-alpha.getbootstrap.com/layout/grid/).
    So, in our `LandingPage` component, I will just wrap the authentication and `go-to-app-link`
    components into the `div` with the `row` class and add the corresponding `col-*`
    classes to these components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! Now you have a nice two-column layout, which transforms into the
    single-column layout on small-sized devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making the authentication UI great again](../images/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is how our layout looks on the desktop device
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, on the desktop device, we have a nice two-column layout. If
    you resize your browser to the size of a mobile device, the right column jumps
    behind the left column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making the authentication UI great again](../images/00101.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is how our layout looks on the mobile device
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s have a look at our `Authentication.vue` component. In order to make
    it nicer than a 20-year-old web page, let''s apply Bootstrap''s magic to it. To
    do so, we will use the classes of Bootstrap''s forms: [https://v4-alpha.getbootstrap.com/components/forms/](https://v4-alpha.getbootstrap.com/components/forms/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will wrap the whole form into the `<form>` tag and each of the inputs into
    the `div` with the `form-group` class. We will also add the class `form-control`
    to each of the inputs. So the input for email, for example, will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As a small exercise, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Make it only one form that has a button to switch between the login and sign-up
    forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make it only one method that would call one of the actions depending on which
    state the form is in at the moment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Explore Bootstrap''s utilities classes to remove all the borders except the
    bottom border and to remove the round corners from them: [https://v4-alpha.getbootstrap.com/utilities/borders/](https://v4-alpha.getbootstrap.com/utilities/borders/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the end, your form should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making the authentication UI great again](../images/00102.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is how both forms should be looking at the end. They should be toggled
    with a bottom button
  prefs: []
  type: TYPE_NORMAL
- en: Try to achieve it by yourself. To check your work, have a look at the `chapter6/3/profitoro`
    folder. In particular, check the code of the `Authentication.vue` component. It
    is very different!
  prefs: []
  type: TYPE_NORMAL
- en: Managing the anonymous user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ProFitOro allows unregistered users to use the application as well. The only
    difference is that these unregistered users are not allowed to configure their
    settings as well, as they do not have access to their statistical data. They also
    cannot manage workouts. So, this is where we meet the second A of the triple-A
    definition – *authorization*. How can we manage these users? How can they actually
    enter the application if we only allow our users to sign up and log in? Well,
    for some reason, we have prepared the part that says **Go to App**. Let me remind
    you how it looks in the mockups:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing the anonymous user](../images/00103.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Start without registration! button in the initial mockups
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily for us, the Firebase authentication API provides a method to sign in
    the anonymous user. The returned user object contains the `isAnonymous` attribute,
    which will allow us to manage the resources that can or can''t be accessible to
    this anonymous user. So let''s add the action called `authenticateAnonymous` and
    call the corresponding Firebase `auth` method within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are! Now let''s just slightly modify a mutation that sets the user
    and the **isAnonymous** state''s attribute to the corresponding one in the user
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also modify the binding configuration and statistics actions and execute
    the actual binding only if the user is set and only if the user is not anonymous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We are done with the backend! Now let''s implement this button! There are only
    three steps to achieve it. Open the `GoToAppLink.vue` component, import the `mapActions`
    helper, add the button, and use the `v-on:click` directive to bind the event listener
    to it that will call the corresponding action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'How easy is that? Now, as a small exercise, with the help of Bootstrap, try
    to make things look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing the anonymous user](../images/00104.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Use the corresponding Bootstrap classes to make our buttons look like this and
    to align the columns vertically
  prefs: []
  type: TYPE_NORMAL
- en: 'Check Bootstrap''s classes for alignment: [https://v4-alpha.getbootstrap.com/layout/grid/#alignment](https://v4-alpha.getbootstrap.com/layout/grid/#alignment).
    Check as well the helper classes to get rid of rounded corners. Check yourself
    by having a look at the code in the `chapter6/4/profitoro` folder. Pay special
    attention to the `GoToAppLink.vue` component and to the store''s components, such
    as `action.js` and `mutations.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: Personalizing the Pomodoro timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, now that we can already sign in new users and log in the existing ones,
    probably we should think about taking advantage of our authentication mechanism
    because right now we are actually not doing anything with it. We just sign up
    and we just log in. Yes, we also can hide or show some content based on the user's
    authentication, but this is not enough. The whole point of all this effort was
    to be able to store and retrieve the user's custom configuration for the Pomodoro
    timer and the user's statistical data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, we have been using a hardcoded database object with the key `test`
    in order to access the user''s data, but now, since we already have our real users,
    it''s time to populate the database with real users'' data and use it in our application.
    Actually, the only thing we have to do is to replace this hardcoded value with
    the actual user''s ID. So, for example, our code to bind the `config` reference
    was looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the reference `state.configRef` has been defined in the store''s entry
    point `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we cannot actually instantiate our database references within the store''s
    entry point, because at this point (no pun intended), we still don''t know whether
    or not our user is authenticated. So the best thing to do is to pass this code
    to the actual `bindConfig` function and to replace this `test` with the real user''s
    *uid*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, my dear attentive user, I know that you are exclaiming "but how the hell
    is the configuration with the user''s *uid* stored?" Very well noticed: it''s
    not. We still have to store it on our user''s first sign-up. We actually have
    to store both configuration and statistics.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Firebase database provides a method to write new data to the database that
    is called `set`. So you basically obtain the reference (just like in the case
    of reading data) and set the data you need to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a new entry with a given user ID in our configuration table
    and set the default state''s `config` data. So we will have to call this method
    on the new user creation. We will still have to bind the database references to
    our state objects. In order to reduce the amount of code, I created a method,
    `bindFirebaseReference`, that receives the reference and the string that represents
    the key of the state to which it should be bound. This method will analyze whether
    or not the entry for the given reference already exists in the database and will
    create it if needed. For that, Firebase provides a nice method that can be applied
    to nearly everything – this method is called `once` and it receives a callback
    with a snapshot to whatever it has been applied to. So, inside this callback,
    we can analyze whether or not this snapshot has a child with a given name, or
    even if it has a value or it''s `null`. If the value is already set, we will bind
    our state to it. If not, we will create a new entry. Check out the official Firebase
    documentation in this regard: [https://firebase.google.com/docs/database/web/read-and-write](https://firebase.google.com/docs/database/web/read-and-write).
    This is what the `once` method and its callback looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Personalizing the Pomodoro timer](../images/00105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to use the once method to check whether the data exists in the database
  prefs: []
  type: TYPE_NORMAL
- en: 'Disregarding the existence or not of data, our binding reference method should
    call the Firebase bindings. So it will look as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'I also replaced both methods that were binding `config` and `statistics` by
    only one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This method is being called from the `bindAuth` method. So now we can remove
    the calls to the actions to bind `config` and `statistics` from the `created`
    method of our `App.vue`. We also don't need the instantiation of references in
    the `store/index.js` since both references are instantiated within this new method.
    And we have to add two mutations that will set the references to the state so
    we don't need to change our Pomodoro configuration settings actions since they
    are using both references to update the data.
  prefs: []
  type: TYPE_NORMAL
- en: Check what the code looks like in the `chapter6/5/profitoro` folder. Check out
    the slight changes in the `App.vue` component, and check what the store's files
    are looking like now (`index.js`, `mutations.js`, `state.js`, and especially `actions.js`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Play with your application. Sign up, log in, change the Pomodoro timer configuration,
    log out, and check that it works. Check your Firebase console – the **Realtime
    Database** tab and **Authentication** tab. Check that whatever you change, you
    have your data consistent everywhere – in your database, in your **Authentication**
    tab, and, most importantly, in your application (because the application is what
    your users are going to see, right?):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Personalizing the Pomodoro timer](../images/00106.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Check that the data is consistent everywhere
  prefs: []
  type: TYPE_NORMAL
- en: So now we can sign up a new user, log in as an existing user, and log in as
    an anonymous user. We provide a nice value to the authenticated users – to be
    able to configure their Pomodoro timer and to check their statistical data. Of
    course, our application is still far from being perfect – we don't validate the
    input, we accept any values in the Pomodoro configuration area, which is not right,
    and we don't display the possibility of changing passwords on the startup page.
    BUT we have our solid skeleton, which enables us to build a solid and nice application
    on its base. So let us move on!
  prefs: []
  type: TYPE_NORMAL
- en: Updating a user's profile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Wouldn''t it be funny if we could welcome our user by displaying a welcome
    message saying something like **Welcome Olga**? But our users do not have names;
    they only have emails and passwords – two essential authentication components
    that are passed during the sign-up process. So, how can we do that? Well, if you
    have read with some attention the Firebase documentation regarding authentication
    ([https://firebase.google.com/docs/auth/web/manage-users](https://firebase.google.com/docs/auth/web/manage-users)),
    you might have spotted these nice methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating a user''s profile](../images/00107.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Firebase methods for updating a user's profile and email address
  prefs: []
  type: TYPE_NORMAL
- en: Let's use these methods to update our user's profile and user's profile picture!
  prefs: []
  type: TYPE_NORMAL
- en: We will define three new actions – one that will update the user's display name
    by calling the Firebase `updateProfile` method, one that will update the user's
    profile picture's URL by calling the same method, and another one that will call
    the `updateEmail` method. Then we will create the necessary markup in the `Settings.vue`
    component that will bind those actions on the corresponding input's update. Sounds
    easy, right? Believe me, it's as easy to implement as it actually sounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s define our actions. They will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Now let''s switch to our `Settings.vue` component, which will be responsible
    for rendering the needed data to change the account settings and for updating
    this data by calling the needed actions when needed. So first of all, I will add
    three entries to the data function that will be set to the current user object''s
    corresponding attributes once the component is `created`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now this data can be used within the corresponding actions. So, let''s import
    the needed actions and create the corresponding methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can add the needed markup full of the inputs to which we will bind the
    data using the `v-model` data binding directive! We will also call the corresponding
    methods on each input''s update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: And…we are done!
  prefs: []
  type: TYPE_NORMAL
- en: 'As a small exercise, do the following: add a figure caption behind our image
    that says **Change profile picture**. The input element for the new picture URL
    should only be visible when the user clicks on this figure caption. Once the URL''s
    updating is done, the input should become invisible again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating a user''s profile](../images/00108.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is how it looks before the user clicks the Change profile picture caption
  prefs: []
  type: TYPE_NORMAL
- en: Initially, it contains the default user picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the user clicks on the caption, the input for changing the picture''s
    URL appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating a user''s profile](../images/00109.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After the user clicks on the figure caption, the input appears
  prefs: []
  type: TYPE_NORMAL
- en: 'After the user changes the profile picture URL, the input is hidden again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating a user''s profile](../images/00110.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After the user changes the URL for the profile picture, the input disappears
  prefs: []
  type: TYPE_NORMAL
- en: 'My advice: add an additional property to the `Settings.vue` component''s data,
    set it to `true` when the user clicks on the caption, and reset it to `false`
    when the value inside the input is changed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, don''t forget about our initial aim for this section – add a welcoming
    message inside the `Header.vue` component. This welcoming message should contain
    the user''s display name. It should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating a user''s profile](../images/00111.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Welcoming message mentioning the user's name
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you decide to change your email, you will have to log out and log
    in again; otherwise, you will get some Firebase security errors in your console.
  prefs: []
  type: TYPE_NORMAL
- en: The final code for this chapter can be found in the `chapter6/6/profitoro` folder.
    Note that I split both the account settings and the Pomodoro settings with two
    individual components (`AccountSettings.vue` and `PomodoroTimerSettings.vue`).
    It makes things easier to maintain. Pay attention to the store's components as
    well. Check the `Header.vue` component and how it actually displays the welcoming
    message.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to combine the Firebase real-time database
    and authentication API to update a user's settings. We have built a user interface
    that allows a user to update their profile settings. In just a few minutes, we
    have built the full authentication and authorization part of our application.
    I don't know about you, but I feel totally amazed about it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will finally get rid of this huge page that contains
    all the parts of our application – the Pomodoro timer itself, statistics data,
    and the settings configuration view. We will explore one really nice and important
    feature of Vue – `vue-router`. We will combine it with Bootstrap's navigation
    system in order to achieve a nice and smooth navigation. We will also explore
    such a hot topic as code splitting in order to achieve lazy loading for our application.
    So, let's go!
  prefs: []
  type: TYPE_NORMAL
