- en: Handling Service Transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a substantial amount of interaction potential between system components
    and the data objects that they individually manage. While we've worked out some
    of the mechanisms that determine what transmitting a data change or command message
    looks like, we've not yet started to explore the specifics of those interactions.
    In a nutshell, we still need to address what the data flows (and, thus, message
    transmissions) look like for all of the local CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creation of products by artisans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activation and deactivation of products by artisans and Central Office staff
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making changes to Product data by artisans and Central Office staff
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deletion of products by artisans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creation of artisans by Central Office staff
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making changes to Artisan data by artisans and Central Office staff
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deletion of artisans by Central Office staff
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creation of orders by the Web Storefront, and relaying that information to artisans
    for fulfillment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cancellation of orders from the Web Storefront, and relaying that information
    to artisans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Order-item fulfillment by artisans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remaining stories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since our work in [Chapter 16](9e235ce2-5611-4e7d-a16b-3332561fe85b.xhtml), *The
    Artisan Gateway Service,* only (tentatively) closed three stories, there are still
    several (eleven) that need to be addressed. The implementation of `RabbitMQSender`
    and the RabbitMQ message transmission strategy that was adopted also raised questions
    about how to propagate some of the artifacts needed for those processes—the signing
    key in particular—and there''s also a decision pending about whether the Artisan
    Gateway will use one message queue for inbound traffic from artisans, or one per
    Artisan, and that may add another story:'
  prefs: []
  type: TYPE_NORMAL
- en: As an Artisan, I need a message queue created and assigned to me so that I can
    send my data changes to the Artisan Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The bulk of the stories still pending each represent a data flow process, a
    data transaction tied to a specific action that''s undertaken by a specific user
    in the context of the system. Each process, in turn, is some variation of a CRUD
    operation—generally creating, updating, or deleting one or more data objects,
    as instructed by the relevant message. In reviewing the possibilities of all of
    the various CRUD operations against all of the business objects available to each
    user role in the system, five new stories surfaced:'
  prefs: []
  type: TYPE_NORMAL
- en: As an Artisan, I need to be able to deactivate `Product` objects so that I can
    manage `Product` availability (which may be handled by a general Update operation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an Artisan, I need to be informed when an Order has been placed that includes
    one of my Product offerings so that I can fulfil my part of that Order (ultimately,
    the creation of an Artisan-resident `Order` object, triggered by some activity
    on the Central Office side)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a Customer, I need the relevant parts of my Order to be relayed to the appropriate
    artisans so that they can fulfill their part of my Order (the other half of the
    previous story, but it might add some functional needs to that)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a Customer who's canceled an Order, I need the relevant parts of that cancellation
    to be relayed to the appropriate artisans so that they won't fulfill their part
    of the Order (essentially a deletion of an Artisan-resident `Order`-object, but
    with notification on the Artisan Application side)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an Artisan, I need to be informed when an Order has been canceled that includes
    one of my Product offerings so that I can stop any in-process fulfillment activities
    related to it and update my `Product` status as needed (again, the other half
    of the previous story)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these transactions follow a similar pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: The relevant **message data** of the **O****bject** whose data needs to be sent
    along is used to create a **message** (with `DaemonMessage`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That **message** is sent by a sender (an instance of `RabbitMQSender`) to the
    **Artisan Gateway service**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service reads the **message**, and calls the appropriate `[process-method]`,
    which will probably interact with the **Artisan Gateway data store**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `[process-method]` itself may need to send other messages, either back
    to the **Artisan Gateway service** itself for further local processing, or through
    the service back to an Artisan. The processes for sending subsequent messages
    will be very similar, with the potential for an additional variation—the destination
    of the new message:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/a6e5d401-fe16-451f-9f01-b11ff6370e4c.png)'
  prefs: []
  type: TYPE_IMG
- en: The primary points of variation are, then, in the **message data** itself, and
    those variations should be shaped, in turn, by business rules around what the
    user role is allowed to do to those objects.
  prefs: []
  type: TYPE_NORMAL
- en: A bit of reorganization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before digging into the details of the individual transactions, some minor reorganization
    of recent code seems in order. The `RabbitMQSender` and `DaemonMessage` classes
    were originally written in the `hms_core.daemons` module, because that seemed
    a logical place to keep them—they are still relevant to the daemon, but also have
    relevance to parts of the Artisan Application (and perhaps the Central Office
    application) that don't have any ties to the various daemon classes themselves.
    Since we've also uncovered a need for various objects to be able to generate message
    data structures, and that feels like it should be handled by a different abstraction,
    it feels logical to move those two classes into a new `hms_core` module (`hms_core.messaging`),
    and add the new abstraction there instead—that way, all of the messaging-related
    classes are in one place. Moving the custom exception, `InvalidMessageError`,
    to the new module also feels like a sensible step, since it is also strictly message-related.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those code moves require some trivial changes to the Artisan Gateway service''s
    main module, such as changing the original imports from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Similar changes are also necessary in any of the test scripts that have been
    generated in order for them to still be useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sort of code reorganization is probably inevitable, at least on a long-term
    basis: it''s just a matter of time before something just doesn''t feel right where
    it lives, and needs to be moved to a better location. In general, the earlier
    the need for a reorganization like this is caught, the better, as it will tend
    to be less troublesome or disruptive because there''s less chance of broken interactions
    with code if there''s less code to interact with. It also probably goes without
    saying, but it''s always a good idea to rerun any test code that might have been
    created to assure that nothing is egregiously broken before moving on. In this
    case, the final test script for the daemon (`scratch-space/daemon-artisan-tests.py`)
    revealed some minor issues that had to be resolved—not because of the code-move,
    but because it wasn''t rerun before closing out the code in [Chapter 16](9e235ce2-5611-4e7d-a16b-3332561fe85b.xhtml), *The
    Artisan Gateway Service*. Still, the issue was caught before it became a real
    bug.'
  prefs: []
  type: TYPE_NORMAL
- en: Preparation for object transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding code reorganization gives us a solid, logical place to create
    the new **Abstract Base Class** (**ABC**) that we mentioned earlier. The goal
    of this new ABC is to require derived classes to be able to provide a message-data-ready
    data structure that can be passed to `DaemonMessage` as the data argument in its
    `__init__` method, both streamlining the process of creating a message for any
    given object that needs one, and allowing the code for that process to exist as
    part of the individual data object classes themselves. In keeping with the naming
    convention that's evolved in the code so far, this would probably be best written
    as an instance method named `to_message_data`. Another option considered was `to_message_dict`,
    but that method name already exists elsewhere, and it doesn't relate to the `DaemonMessage`
    argument quite as well.
  prefs: []
  type: TYPE_NORMAL
- en: The `to_message_data` method can be completely abstract, with no concrete implementation
    provided in the abstract method itself—unlike many of the abstract methods defined
    thus far in the `hms_sys` code-base, there really isn't any common functionality
    to fall back on.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that''s it, really. The new ABC doesn''t need anything else that comes
    to mind. It just defines a requirement for the new method. It doesn''t even need
    an `__init__` method, since there''s nothing that would need to be passed as an
    instance property value (though it will still inherit the `__init__` method from
    the object class that all classes ultimately derive from). Its entire definition,
    then, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: An ABC defined with no concrete functionality is about as close as Python code
    can get to the sort of formal interface declaration that other object-oriented
    languages provide. It's still just an Abstract Base Class, just like the other
    ABCs that have been built for the project so far, but all it does is generate
    a set of functional requirements that derived classes have to implement before
    they can be instantiated. In this case, when we apply `HasMessageData` to the
    various data object classes that have already been defined in the `hms_core.co_objects`
    and `hms_artisan.artisan_objects` namespaces (`Artisan` and `Product` classes
    in both, and `Order` in the `hms_artisan` namespace), this immediately establishes
    a requirement that those classes implement `to_message_data`, without caring how
    they get implemented.
  prefs: []
  type: TYPE_NORMAL
- en: In `hms_sys`, since the concrete `Artisan`, `Order`, and `Product` classes all
    derive from ABCs defined in `hms_core`, we could actually attach `HasMessageData`
    to those ABCs, rather than to the concrete classes. The end result would be the
    same—the concrete classes would be required to implement `to_message_data`—and
    there would be (very slightly) less work. The trade-off would be that any future
    classes that derived from `BaseArtisan`, `BaseOrder`, or `BaseProduct` would also
    be required to implement `to_message_data`, even if there was no need for that
    functionality. While that doesn't feel horrible, it does impose some functional
    requirements on future development that may not be warranted. For the time being,
    since we know that the current concrete classes should derive from `HasMessageData`,
    we'll derive them from it directly—if that needs to be changed in the future,
    it's a safer effort to move the requirement deeper into the inheritance tree.
  prefs: []
  type: TYPE_NORMAL
- en: The concrete implementations of `to_message_data` provides a logical hook in
    the code for the implementation of business rule restrictions regarding what each
    object is allowed to send in a message. That is, neither Artisan nor Central Office
    users are allowed to alter or set all state data for all objects—they each have
    specific properties that they control. Even in cases where the user type owns
    the object type (artisans and products), there are properties that the other user
    owns (products and `store_available`, for example). Since `to_message_data` will
    be used to actually generate the message data that will, in turn, be used to make
    changes on the receiving end of each message transaction, the simple expedient
    of limiting the data structure generated by it to the values that the user type
    can create or alter prevents illegal changes to object data by each user. We'll
    dig into that as we work through the specific transactions for each user/object/action
    combination.
  prefs: []
  type: TYPE_NORMAL
- en: Product object transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the set of Product data transactions have the largest number of individual
    transactions (seven), we'll start with those in the hopes that they will expose
    any gaps in the design sooner rather than later. Each transaction ties back to
    one of the original iteration stories, and the specific story that relates to
    the transaction process will be called out. The specific implementation of `to_message_data`
    for the user/object combination will be defined in the first transaction for that
    combination, and refined if/as needed in subsequent transaction details. Any other
    specific needs for that particular combination will also be addressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since all of the varied operations against any objects require the object to
    be identified, the one constant in all `to_message_data` outputs is the `oid`
    property of the object being transmitted. It plays a significant role in each
    of the operations:'
  prefs: []
  type: TYPE_NORMAL
- en: When creating a new object, the `oid` has to be provided in the message so that
    we don't end up with different unique identifiers across different application
    installations or environments. That's already taken care of by the generation
    of the `oid` value, which is inherited from `BaseDataObject`, where the `oid`
    is created if it doesn't exist.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When updating an existing object, the `oid` has to be provided so that the original
    object can be retrieved and altered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When deleting an existing object, the same identification need exists—the `oid`
    has to be provided in order to identify which object is being deleted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although we don't have a use case yet for a response message (more or less equivalent
    to a read in the standard CRUD operations structure), it, too would require an
    `oid` value in order to identify which object should be fetched and returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Artisan – creating a product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The relevant story for an Artisan''s need to create a Product, from the list
    earlier, is:'
  prefs: []
  type: TYPE_NORMAL
- en: As an Artisan, I need to be able to create `Product` objects so that I can manage
    my `Product` offerings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Artisan users own the majority of the data points for a `Product` object. In
    fact, the only property that they really shouldn''t be able to create or alter
    is the `store_available` flag that controls whether a given Product is available
    on the Web Storefront that the Central Office runs. As a result, the output of `to_message_data`
    for `hms_artisan.artisan_objects.Product` looks very much like its `to_data_dict`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `created` and `modified` values are included in this data structure, operating
    under the assumption that they should also be kept in sync across the Artisan
    and Central Office data stores—that might, if nothing else, allow the UI logic
    to more easily detect when something has changed that the UI needs to be aware
    of before displaying instance data, though it would almost certainly require some
    standardization of a common time—one across all application and service instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a new `Product` object (`new_product`) and the signing key for the Artisan
    (`signing_key`), transmission of the `new_product` to the Artisan Gateway service
    becomes very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The Artisan Gateway method that accepts those messages and actually creates
    the new `Product` is `ArtisanGatewayDaemon.create_product`. Since it''s a method
    in a service, and especially since it makes changes to data (creating new data,
    in this case), there''s nearly as much logging of its processes as there is process
    itself, though much of it is debugging logging, and will only be logged if the
    service is configured to log events at that level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the various Gateway methods aren't making any determination about
    whether the incoming message is authorized to make the changes that the method
    is making. We'll examine this later on.
  prefs: []
  type: TYPE_NORMAL
- en: Central Office – approving/listing a product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The relevant Story for Central Office staff being able to activate products,
    from the earlier collection of stories is:'
  prefs: []
  type: TYPE_NORMAL
- en: As a Product Manager, I need to be able to activate `Product` objects so that
    I can manage `Product` availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Central Office owns the `store_available` flag of products, so their version
    of `to_message_dict`, living in `hms_code.co_objects.Product`, is, at least initially,
    much simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The related message transmission, with a `product_to_activate` `Product` object
    and the Central Office `signing_key` is just as easy as the new-Product transmission
    that we looked at prior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The same message structure and transmission process will also address the Central
    Office''s need to be able to deactivate products, another of the original iteration
    stories:'
  prefs: []
  type: TYPE_NORMAL
- en: As a Product Manager, I need to be able to deactivate `Product` objects so that
    I can manage `Product` availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Artisan Gateway method that accepts those messages and updates the relevant
    `Product` is `ArtisanGatewayDaemon.update_product`. Like `create_product`, it
    logs fairly extensively through its execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Central Office – altering product data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The relevant story for a Central Office need to alter Product data, from the
    list earlier, is:'
  prefs: []
  type: TYPE_NORMAL
- en: As a Product Manager, I need to be able to update `Product` objects so that
    I can manage `Product` information that an Artisan can't
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s not unreasonable to assume that the Central Office will want to be able
    to make changes to specific Product properties without having to send them through
    an Artisan—making minor spelling corrections, or similar, simple changes to Product
    content that''s carried over to their Web Storefront. Since there isn''t any solid
    definition of what properties would be involved, let''s assume that those properties
    include the `name`, `description`, and `summary` of a Product. In that case, the
    `to_message_data` that was created for `hms_code.co_objects.Product` needs to
    be altered to include those values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This implementation introduces a potentially unwanted side effect: any update
    operation executed by a Central Office user can update all of these properties
    at once. If that behavior is not desired, then there are options that could be
    pursued:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional methods could be added to `ArtisanGatewayDaemon` to handle more
    specific actions, such as `set_product_availability`, which would only change
    the `store_available` flag value. That would likely require the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The addition of a corresponding allowed `operation` to `DaemonMessage`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To check messages that originate with an Artisan so that they can't accidentally
    or intentionally perform a store availability change that they shouldn't be allowed
    to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Filtering of the outbound message data, to remove any elements from it that
    don''t apply to a specific operation, could be implemented as part of the message
    generation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helper methods could be added to the concrete `Product` classes to perform that
    filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UI could be made responsible for determining what kind of message should
    be sent, and it could perform that filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At present, there doesn't appear to be any real harm in allowing any update
    action to update across multiple logical operations, though, so it can be left
    alone for now.
  prefs: []
  type: TYPE_NORMAL
- en: Alterations by this Central Office role, for now, can be handled by the same
    message construction, transmission and, handling processes in use by the approval/listing
    action—it's just another variant of a data update.
  prefs: []
  type: TYPE_NORMAL
- en: Artisan – updating product data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The relevant story for an Artisan''s need to update Product data, from the
    list earlier, is:'
  prefs: []
  type: TYPE_NORMAL
- en: As an Artisan, I need to be able to update `Product` objects so that I can manage
    my `Product` offerings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The only real difference between Artisan update and create transactions is
    the `operation` associated with the outgoing message—we''ve already included the
    `modified` property in the results of `to_message_data` in Artisan `Product` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Data alterations originating from an Artisan are, from a process standpoint,
    identical to data changes that originate from a Central Office user—they can use
    the same `ArtisanGatewayDaemon.update_product` method to actually execute those
    changes—so there's no new code needed for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since artisans also control a Product availability flag (available), the same
    considerations noted for the Central Office Product approval listing would apply
    at the Artisan level. Those encompass two stories that weren''t part of the original
    iteration story set, but should be included for the sake of completeness:'
  prefs: []
  type: TYPE_NORMAL
- en: As an Artisan, I need to be able to activate `Product` objects so that I can
    manage `Product` availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an Artisan, I need to be able to deactivate `Product` objects so that I can
    manage `Product` availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These, too, can be handled by the same, existing data update process already
    defined, so long as there's no requirement to isolate activation/deactivation
    changes from other changes to the data structure. Even if such a requirement were
    to surface, it would be feasible to handle them at the message origination side
    of the transaction, limiting the content of the message to only the `active` flag
    and the `oid` that identifies the product to be activated or deactivated.
  prefs: []
  type: TYPE_NORMAL
- en: Artisan – deleting a product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The relevant story for an Artisan''s need to delete a Product, from the list
    earlier, is:'
  prefs: []
  type: TYPE_NORMAL
- en: As an Artisan, I need to be able to delete `Product` objects so that I can manage
    my `Product` offerings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As noted earlier, deletion actions really only require the `oid` of the item
    being deleted in order to successfully execute. Any other information would be
    wasted bandwidth, though if that''s not a concern, the code for a deletion really
    only differs in the `operation` sent in the message again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing a more tightly focused message is not difficult—it doesn''t require
    anything more, ultimately, than taking more direct control of the message data,
    limiting it to just the relevant object ID. One approach would be to create the
    message data directly, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding deletion method in the Artisan Gateway (`delete_product`)
    is a lot simpler than those corresponding to the create or update processes for
    the same reason: all that''s really needed is the `oid` of the object whose data
    is to be deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Artisan object transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The processes for sending `Artisan` object messages will not deviate significantly
    from the examples shown previously for `Product` objects. The creation and transmission
    of `create` and `update` messages will typically follow a structure that looks
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Deletion messages, depending on what decision is made regarding sending the
    full object dataset, or just the required `oid` value, will typically follow one
    of these two structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`Artisan` objects, like `Product` objects, are not complicated from the standpoint
    of their CRUD operations methods in the Artisan Gateway service. Indeed, apart
    from the specifics of which objects are being worked on, and the specific expected
    structure of the command messages associated with the various methods involved
    in executing those operations, they are identical to their `Product` object counterparts. For
    example, the `update_artisan` method of the Artisan Gateway service looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Across the board, then, the various `Artisan` operations follow the same patterns
    as those established by/for the `Product` operations.
  prefs: []
  type: TYPE_NORMAL
- en: Central Office – creating an artisan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The relevant Story for Central Office staff being able to create an Artisan,
    from the earlier collection of stories is:'
  prefs: []
  type: TYPE_NORMAL
- en: As an Artisan Manager, I need to be able to create `Artisan` objects so that
    I can manage artisans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Artisan` objects are unusual, in that while they are logically owned by the
    Artisan that they represent, they are created by the Central Office. This implies
    that two radically different message formats will be needed by the Central Office
    code-base: one to create an `Artisan` and one to update it. If we start with a
    complete message structure for creation purposes, we can better evaluate whether
    it presents any risks or complications in the update process later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Since the process for creating an `Artisan` should almost certainly involve
    the creation and storage of the identifier of the message queue that's associated
    with Artisan (`queue_id`) and an initial `signing_key`, those values are included
    in the Central Office's `Artisan.to_message_data` method. We still have to define
    how signing keys and queue identifiers are actually created within the `Artisan`
    objects, but they will have to be sent along to the Artisan Gateway in some fashion
    so that they'll be available for use in sending, receiving, and validating messages
    to and from an Artisan Application instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'These processes are significant from a security perspective: remember that
    the signing key is considered a **secret** data value, one that should be treated
    with caution, and not transmitted needlessly or without some attention to safeguarding
    the data. In many respects, it''s equivalent to a user password—a secret value
    that is associated with one and only one user. If the signing key is a password,
    then the queue identifier could be considered roughly equivalent to a username—data
    that is, perhaps, not quite as secret, but that should still be treated with caution
    because it potentially uniquely identifies a user, and is associated with a true
    secret, together forming a set of user credentials. As the implementation- details
    around `queue_id` and `signing_key` creation and management unfold, it''s quite
    probable that we''ll have to revisit this message structure, so for now, we''ll
    leave it in its current state.'
  prefs: []
  type: TYPE_NORMAL
- en: Central Office – updating artisan data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The relevant Story for Central Office staff being able to update an Artisan''s
    data, from the earlier collection of stories is:'
  prefs: []
  type: TYPE_NORMAL
- en: As an Artisan Manager, I need to be able to update `Artisan` objects so that
    I can manage artisans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once an `Artisan` object has been created, most of its properties are arguably
    owned by the Artisan that the object represents. Certainly, from a common sense
    standpoint, the Artisan user is in the best position to know whether their data
    is current, and it's in their best interests to keep that data current. That said,
    and setting aside the `queue_id` and `signing_key` properties until their processes
    have been fleshed out in more detail, the risks of allowing Central Office users
    to modify Artisan data don't feel significant, provided that changes made are
    propagated to, and can also be changed by the Artisan users themselves. The caveat
    to this scenario is that the `oid` property shouldn't be changeable by anyone—Central
    Office or Artisan users—but that almost goes without saying. It is, after all,
    the unique identifier for the `Artisan` object, and unique identifiers should
    never be changed lightly.
  prefs: []
  type: TYPE_NORMAL
- en: With all of that in mind, no modifications to the Central Office's `Artisan.to_message_data`
    method are needed to fulfil this story yet, though alterations may well surface,
    as with the creation process, as the `queue_id` and `signing_key` management processes
    are defined and implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Central Office – deleting an artisan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The relevant Story for Central Office staff being able to delete an Artisan''s
    data, from the earlier collection of stories is:'
  prefs: []
  type: TYPE_NORMAL
- en: As an Artisan Manager, I need to be able to delete `Artisan` objects so that
    I can manage artisans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the process of deleting an Artisan may have other implications—removal,
    or at least deactivation of all their products, for example—there aren't any that
    come to mind from the perspective of generating deletion command messages. Like
    the deletion process for `Product` objects, the only property value that's really
    needed is the `oid` of the Artisan to be deleted, and whatever decision is made
    about using the full message body or creating a specific one for deletion process
    purposes in that context will probably apply to this context as well.
  prefs: []
  type: TYPE_NORMAL
- en: Artisan – updating Artisan data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The relevant Story for Artisan being able to update an Artisan''s data, from
    the earlier collection of stories is:'
  prefs: []
  type: TYPE_NORMAL
- en: As an Artisan, I need to be able to update my own `Artisan` object so that I
    can manage my information at the HMS Central Office.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No matter what the eventual shape of the processes surrounding the `queue_id`
    and `signing_key` properties of an `Artisan` turns out to be, those values, as
    secrets, should never be sent across the open internet without some protection—encrypting
    them while in motion, at a minimum. Without those values, changes to Artisan data
    by Artisan users can travel unencrypted, so the base message structure for Artisan
    updates is nearly a duplicate of the equivalent in the Central Office''s namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Between the Central Office and Artisan code-bases, we're allowing either user
    type to alter most of an Artisan's data. The majority of it is some variation
    of contact information, none of which has any functional implications, and the
    balance has policies that have already been set down, if not implemented yet (`oid`),
    or is still pending further definition (`queue_id` and `signing_key`). The worst
    risk that seems even remotely likely with both user types having full control
    over these properties is either simultaneous conflicting changes (probably best
    handled at the UI level), or ongoing conflicting changes (one user changing a
    value, the other changing it back, the first changing it again, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Order object transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: orders, and their corresponding objects in the system, haven't been discussed
    much since the definition of the concrete `Order` class in the `artisan_objects`
    module. In part, this is because the other classes (particularly `Artisan` and
    `Product`) are representations of data that originate in the `hms_sys` code-bases.
    Still, the `artisan_objects.Order` class was left in about as complete a state
    as could be expected, with full data persistence and a concrete implementation
    that was expected to deal with all the requirements against it up to that point.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, though, several aspects of orders fell off the radar. The original
    set of stories for this iteration only included one Order-related story—an Artisan's
    need to be able to update an Order as part of a fulfillment process—with nothing
    that provided any path for that Order to get to an Artisan to begin with, let
    alone anything prior to that. There also wasn't any accommodation for the potential
    of an order being canceled before its fulfillment was complete. Accounting for
    the customer-to-gateway and gateway-to-Artisan paths of those items, they adds
    four new stories that will be addressed first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dealing with orders is also complicated somewhat by the fact that the specifics
    of the Web Storefront system have been left intentionally vague. There are dozens
    of options available, if not hundreds, written in most of the popular/mainstream
    languages, and with varying degrees of extensibility. Rather than picking any
    one, a fundamental assumption was made that `hms_sys` integration could be accomplished
    in some fashion, which could include at least the following possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: A brute-force process, executing on a schedule, could acquire new, raw Order
    information from the store's data, and fire off the Artisan Gateway's Order creation
    process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The store system, through some sort of small, custom extension, could fire off
    a create Order message to the Artisan Gateway, either directly or through the
    message queue, executing its Order creation process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the store system were written in Python (there are at least eleven options
    in this field), it might actually be able to import whatever `hms_sys` code is
    needed, perhaps add some configuration, and directly execute the relevant `hms_sys`
    code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a real-world scenario, the cross-system integration would probably have been
    a significant set of very specific requirements—but for the purposes of illustration,
    and to keep focused on the project, those were intentionally left aside.
  prefs: []
  type: TYPE_NORMAL
- en: Customer – relaying order items to artisans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The relevant Story for Customer being able to relay Order items to artisans,
    from the earlier collection of stories is:'
  prefs: []
  type: TYPE_NORMAL
- en: As a Customer, I need the relevant parts of my Order to be relayed to the appropriate
    artisans so that they can fulfill their part of my Order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: orders have a significantly more complex life cycle than any of the other objects
    in `hms_sys`. Unlike `Artisan` objects, or perhaps `Product` objects, they are
    expected to have a short active lifespan; being created, processed once, then
    archived or perhaps even deleted. `Artisan` objects, in contrast, once created,
    are expected to persist for as long as the Central Office/Artisan relationship
    lasts. `Product` objects may or may not persist in an active state for long periods
    of time, but can also last as long as the Central Office/Artisan relationship
    of their owning artisans continues. In both of these cases, though the length
    of their life cycles may vary substantially, they are basically created and persisted
    (with or without modification) indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: 'By contrast, a relatively simple `Order`, moving through a simple subset of
    what `hms_sys` could support, might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1da2c5ed-b34c-4306-bfc4-2fcd0c08a21e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: The initial **Order** (for `Product` objects **P1**, **P2**, and **P3**) is
    created by the **Web Storefront** and is handed off to the **Artisan Gateway**
    for distribution to and handling by the relevant Artisan users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Artisan Gateway** sends **Order** messages to the **Artisan Applications**
    associated with the artisans whose products are in the **Order** (**Artisan #2**,
    in this example, exists, but the Order doesn''t contain any of their products):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One **Order**, for products **P1** and **P3**, is sent to **Artisan #1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One **Order** for Product **P2** is sent to **Artisan #3**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Artisan #1** fulfils the part of the order for Product **P1** (**P1 Fulfilled**),
    which sends an update message for the **Order** back to the **Artisan Gateway**,
    where the fulfillment of that portion is noted and stored'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A similar cycle occurs (**P2 Fulfilled**) for **Artisan #3**, with respect
    to Product **P2** from the original Order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final fulfillment cycle (**P3 Fulfilled**) is executed by **Artisan #1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Order, with all of its fulfillment complete, can be archived, deleted, or
    handled in whatever other way is needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since no concrete `Order` class was ever created that the Artisan Gateway service
    would be able to access, that's the first thing that needs to be done. Without
    knowing precisely how Order data is going to be relayed to the service, but still
    needing to be able to perform round trip testing of the process later, there's
    little more that can be done than to define it as a basic class derived from `HMSMongoDataObject`
    (like the other data object classes in the `co_objects` module) and from `BaseOrder`
    (from the `business_objects` module). Additions or changes to it may surface later,
    but deriving `Order` from those two classes will provide enough functionality
    for it to be testable.
  prefs: []
  type: TYPE_NORMAL
- en: After going through all of the analysis effort with the Artisan Application's
    Order class definition, that feels like a better starting point for the corresponding
    class in the Central Office code (`co_objects`), though it will need some modification/conversion
    in the process. First and foremost, it needs to derive from `HMSMongoDataObject`
    instead of `JSONFileDataObject`—but since both of those, in turn, are derived
    from `BaseDataObject`, a fair portion of the new `Order` class is already implemented
    with that inheritance change.
  prefs: []
  type: TYPE_NORMAL
- en: There's enough common code between the two `Order` classes that it would almost
    certainly be worth spending time moving those common items back down into `BaseOrder`.
    Designing, or even implementing concrete classes, then gathering their common
    functionality into common parent classes is just as valid a design or implementation
    approach as starting from the foundations and building out, though it happened
    accidentally in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond that, we''ll need a mechanism that will allow the Web Storefront system
    to create an `Order`. So far, we don''t have any specifications around that process,
    but that doesn''t stop us from creating a class method that will (hopefully) eventually
    be used in that capacity. For near future testing purposes, it will be set up
    to accept a `BaseCustomer` object that''s derived as a `customer`, and a list
    of Product identifiers, with an eye toward the `customer` being revised at some
    point in the future. To start with, all we''re concerned with is a method that
    can be called to create a complete `Order` with the relevant `Product` objects
    attached to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It feels reasonably safe to assume that the storefront will be able to pass
    Product identifiers and their quantities in the Order along as some sort of `dict` value,
    and that it won''t be keeping track of entire `Product` objects, at least not
    in the same structure that `hms_sys` code uses. Given the list of Product `oid`
    values available in the `keys()` of the `order_items`, retrieving products to
    be added to the `order` instance on creation is simply a matter of filtering all
    available products down into a collection of the specific items in the Order,
    while preserving their associated quantities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The products generated here are dicts, generated by a dictionary comprehension,
    whose keys are `Product` objects, and values are the quantities of those products
    in the Order. Then, we need to acquire the `customer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the new `Order` instance is created, saved (assuring that its data
    is persisted), and returned (in case the calling code needs to reference it immediately
    after it''s been created):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Order` class will also need a `to_message_data` method, just like their
    Product and Artisan counterparts, and with one defined, can use a message transmission
    process that is basically identical to what was established earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This process implies a new story that will probably be needed mostly for UI
    development, but that might have some implications in additional design and implementation
    of the Artisan Applications:'
  prefs: []
  type: TYPE_NORMAL
- en: As an Artisan, I need to be informed when an Order has been placed that includes
    one of my Product offerings so that I can fulfill my part of that Order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since the creation of a new `Order` by the Web Storefront also needs to relay
    new `Order` objects to each Artisan (looking back at the Order flow diagram),
    and since it seems reasonable to expect that only the store-to-Gateway-service
    portion of that flow would be calling `create_order_from_store`, that seems like
    a reasonable place to implement that messaging at first glance, but in doing so,
    there would be no access to the service''s logging facilities, so any failures
    in communication between the two systems would potentially be lost. If, instead,
    the Web Storefront were to issue a create Order message to the Artisan Gateway,
    the Gateway service could in turn call `create_order_from_store` with the applicable
    data, and log events as needed/desired while it executes. For the purposes of
    illustration, this is the approach that is going to be assumed. In this case,
    `create_order_from_store` is complete as it stands, and the Artisan/Order messaging
    happens as part of the Gateway service''s `create_order` method. The first major
    chunk of its code looks very much like the other create processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Since the `create_order_from_store` method already saves the new Order, we don't
    need to save it here—it will already exist in the data store, and can be retrieved
    by other processes as soon as this point in the code has been reached. In order
    to proceed, and send the necessary `Order` messages to the individual artisans
    who need to be aware of them, we need to sort out which products (and in what
    quantities) are associated with each Artisan in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `Artisan` can have a `Product`, but a `Product` doesn't keep track
    of which `Artisan` they belong to (which might be a good thing to add, in retrospect),
    the best option we have right now is to load up the `Artisan`, and search for
    it for each product. This is not optimal, and definitely worth looking at changing,
    but it will work for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `new_order` variable is holding on to an `Order` object that, if expressed
    as a dict, would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Rendering that down into a dict of Artisan/item:quantity values is simple,
    if done in a brute-force manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If an Artisan is found that''s associated with the Product, then one of two
    cases needs to execute: either the `artisan` already exists as a key in the `artisan_orders
    dict`, in which case we just append the item data to the current list of items
    associated with the `artisan`, or they haven''t had a Product match yet, in which
    case we create an entry for the `artisan`, whose value is a list containing the
    item data in question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Although it shouldn''t happen, it''s possible that an Order could come in with
    a Product that has no identifiable `artisan` to associate with it. The specifics
    of how that error case should be handled may be dependent on the web store system.
    Even setting that consideration aside, it should be handled in some fashion that
    hasn''t been defined yet. At a minimum, however, the failure should be logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this sorting has completed, the `artisan_orders` dict will look something
    like this, with each key in `artisan_orders` being an actual `Artisan` object,
    with all of the properties and methods of any such instance, with the Product `oid`
    and quantities associated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Python dict instances can use *almost* anything as a key: any immutable built-in
    type (like `str` and `int` values, and even `tuple` values, but not `list` or
    other `dict` values) can be used as a key in a `dict`. In addition, instances
    of user-defined classes, or even those classes themselves, are viable. Instances
    of built-in classes, or the built-in classes themselves, may not be valid `dict` keys,
    though.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With a complete and well-formed `artisan_orders`, the process of sending Order
    messages to each Artisan is relatively simple—iterating over each Artisan key,
    building the message data in the structure that the Artisan Application''s `Order`
    class expects, creating a `DaemonMessage` to sign the message, and sending it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending a message to a specific Artisan requires another change: the `send_message`
    method of `RabbitMQSender` was not originally built to send messages to a queue
    other than the default it was configured with. It makes sense for each Artisan
    to have their own message queue for several reasons, and in order to use that
    specific queue, it has to be accepted as a `send_message` argument. The Gateway
    side call to send the message reflects that (passing `artisan.queue_id` as an
    argument):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The related changes in `RabbitMQSender.send_message` are not complicated: the
    addition of an optional `queue_name` argument, and a check to see if it has been
    provided, falling back to the configured default queue name is all that was needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Customer – canceling an order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The relevant Story for Customer being able to cancel an Order, from the earlier
    collection of stories is:'
  prefs: []
  type: TYPE_NORMAL
- en: As a Customer who has canceled an Order, I need the relevant parts of that cancellation
    to be relayed to the appropriate artisans so that they won't fulfill their part
    of the Order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Order cancellation has one aspect in common with Order creation: the origin
    point of a cancellation should be with a customer, almost certainly as some functionality
    available through the Web Storefront. Operating under the same assumptions that
    shaped the creation of an Order, so that the Web Storefront will be able to send
    a message to the Artisan Gateway service to indicate that a cancellation has been
    initiated, similarly allows the Gateway to handle it in a single message handler
    method: `delete_order`, in this case.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `delete_order` message handler method is, ultimately, two tasks that it
    must perform:'
  prefs: []
  type: TYPE_NORMAL
- en: Given an Order, identified by an `oid`, it has to track down which artisans
    were involved with the initial Order. That part of the process can be identical
    to the identification of artisans and products in `create_order`. The Product
    identification aspect of that code may not be needed, but it doesn't do any harm
    to include it, and it might even be leveraged later on to prevent the cancellation
    of orders that have been partially fulfilled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It has to generate and send a message to each Artisan Application associated
    with an Artisan who''s associated with the Order: a delete message with the Order''s
    `oid` as the data payload.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Artisan/Product association, yielding `artisan_orders` in the `create_order`
    and `delete_order` code, would probably be worth moving into a common helper method
    in the `ArtisanGatewayDaemon` class: it''s identical to being written in those
    methods as things stand right now. With only two instances of that code present
    right now, and those being close together in the code, it''s not an imperative,
    perhaps, but as long as there are two instances of the same code, any changes
    to one have to be made to the other as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the Order creation process, Order cancellation implies a new story, again
    probably needed mostly for UI development, but that might have some additional
    design and implementation implications for the Artisan Applications:'
  prefs: []
  type: TYPE_NORMAL
- en: As an Artisan, I need to be informed when an Order has been canceled that includes
    one of my Product offerings so that I can stop any in-process fulfillment activities
    related to it and update my Product status as needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The foundation for resolving this story, when it does become active, should
    be mostly–if not entirely–in place as a result of the Order deletion messaging.
  prefs: []
  type: TYPE_NORMAL
- en: Artisan – fulfilling an item in an order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The relevant Story for Artisan being able to fulfil an item in an Order, from
    the earlier collection of stories is:'
  prefs: []
  type: TYPE_NORMAL
- en: As an Artisan, I need to be able to update Order objects so that I can indicate
    to the Central Office when my part of an Order is fulfilled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ultimately, the act of fulfilling all or part of an Order by an Artisan is
    just another update process, at least from a messaging standpoint. So far, though,
    there isn''t a mechanism for keeping track of fulfilled items in any of the `Order`
    classes, and that''s going to be problematic until it''s addressed. Fortunately,
    the model for fulfilled items can be essentially identical to the model for the
    original Order items—a collection (a `dict`, specifically) of Product `oid` keys
    and `int` quantities. Adding that property to `artisan_objects.Order`, using the
    `items` property as a model or guideline, requires the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Including `fulfilled_items`, a `dict`, as an argument in `__init__`, and integrating
    it the same way that the `items` argument/property is integrated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the `getter`, `setter`, and `deleter` methods for it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the `fulfilled_items` property, associated with `_get_fulfilled_items`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making sure that the `to_data_dict` method includes a representation of `fulfilled_items`
    in its output results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making sure that the `from_data_dict` class method doesn't need any special
    handling of an incoming `fulfilled_items` value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since `fulfilled_items` will follow the same constraints as the `items` property
    of an `Order`, direct modification of the members of `fulfilled_items` is prohibited.
    The underlying rationale for that prohibition is similar: we want modifications
    of those members to be tightly controlled in order to prevent bad data changes
    as much as possible. At the same time, we need to allow artisans to fulfill Order
    items (while performing all the relevant checks to make certain that the data
    changes are valid).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To facilitate that, the `artisan_objects.Order` class needs a method that will
    be called to allow an Artisan user to mark items as fulfilled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Order fulfillment data is, for an Artisan, one of the more important datasets,
    so we''re going to check every argument in several different ways before allowing
    the change to be saved. The check processes starts with standard type and value
    checking (stripping the error messaging out to keep the listing short):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re also going to check to make sure that the item being fulfilled is actually
    part of the Order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And we''ll check to make sure that the fulfillment quantity isn''t greater
    than the quantity in the Order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Similar changes, minus the `fulfill_items` method, will also need to be made
    to the Central Office `Order` class (`co_objects.Order`) to handle fulfillment messages.
    For the time being, until we can focus on the round trip message testing in the
    next chapter, these can be accommodated by simply copying the code from `artisan_objects.Order`.
  prefs: []
  type: TYPE_NORMAL
- en: Copying that much code around is another argument for refactoring the `Order`
    classes, re-defining `BaseOrder`, and deriving the concrete classes from it instead.
    Time and space constraints in this book may not allow for much discussion of this
    process, but we'll take at least a brief look at it, either during or after testing.
  prefs: []
  type: TYPE_NORMAL
- en: When do messages get sent?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up until this point, we''ve spent a fair length of time digging in to how the
    relevant messaging will be generated and sent, but very little about when it happens,
    apart from the examination of Order creation and cancellation. Since messages
    correspond directly to various local CRUD operations, it''s tempting to simply
    add the messaging calls into the `_create` and `_update` methods that they already
    have, making sure to account for the `is_dirty` and `is_new` flags that we defined
    in `BaseDataObject`. Before going down that path, though, it would be a good idea
    to take a look at all of the messaging processes, from origination to completion,
    to make sure that they have a clear process termination. The scenario that we
    need to make sure to avoid, using a `Product` update process as an example, looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/86daf41f-7f54-4593-ab2c-11e9ac83b1cc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An **Artisan** makes a change to one of their products:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The local data change is executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Their **Artisan Application** sends a message to the **Artisan Gateway: Update
    Product "X"**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Artisan Gateway** receives the message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The local data change is executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A message is sent to the corresponding **Artisan Application: Update Product
    "X"**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Artisan Application** receives the message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The local data change, which likely doesn't have any updated data, is executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A message is sent to the **Artisan Gateway: Update Product "X"**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the end of the last step, the process would, without some check process
    or exit condition, jump back to the second step, and into an infinite loop of
    update messages that don''t actually do anything. The same scenario could occur
    with any of the update processes where more than one origin point for data changes
    could be in play: the `Artisan` objects can be updated by the artisans they represent
    and by Central Office staff. `Order` objects are currently exempt, but it''s not
    difficult to imagine a future need for a customer to alter an Order after it''s
    been transmitted to the artisans who''d be fulfilling items in it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ultimately, because the `save` methods of the various data object classes have
    no awareness of where the data change they''re executing came from, they cannot
    make any decisions about whether or not it''s appropriate to send a message out
    after the data change has been executed. A possible solution, then, would be to
    allow (or even require) an additional argument in each `save` that provides that
    information, and that could be used to determine whether a message needs to be
    sent or not. The structure of this modification might look something like this
    (for a data object living in the Artisan Application''s code-base):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: It would be feasible to add an additional abstraction layer between `BaseDataObject`
    (where `save` is defined currently) and each of the concrete data objects that
    would override the `BaseDataObject.save` method. This abstraction–an additional
    ABC–would need to be created in the Artisan Application and Artisan Gateway code-bases,
    at a minimum, and another variant might be needed in the Central Office application
    as well, depending on implementation details that haven't been fully explored
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: The trade-off is that all data objects would have to pay attention to where
    their data changes originated from. This feels… messy, complicated, and potentially
    difficult to maintain, at least at first blush.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another possibility would be to alter `DaemonMessage`: if the messages themselves
    contain something, such as data that indicates where they originated from, then
    the handlers for those messages would be able to tell whether or not a message
    needs to be sent after the data change had been dealt with. In that design scenario,
    a `Product` update message that originated with an Artisan, including an `origin`
    specification, might look like this (before being converted to JSON):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The corresponding `update_product` handler method in the `ArtisanGatewayDaemon`
    service class, along with other handler methods, currently expects a `dict` (`properties`)
    to act upon, and is called by `ArtisanGatewayDaemon._handle_message` as the `main`
    loop of the service reads messages to be acted upon. We could change what the
    individual handler methods expect, passing the original `message` (a `DaemonMessage`
    instance) instead, making the handler methods responsible for breaking down the
    incoming `message` into the `properties` and acting upon them as they already
    do, and giving them the responsibility for determining whether a message needs
    to be sent and sending it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a `DaemonMessage` with an `origin`, and a globally accessible value to
    compare that origin with, the decision to send a message or not, and sending it
    if needed, isn''t complex. If it were anywhere in the Gateway service (that is,
    `self` is the service instance), it would look more or less like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The data used to create the `outbound_message` might differ, depending on whether
    the data dictionary or message dictionary of the newly created or recently updated
    object was used instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, when an incoming `message` is acted upon:'
  prefs: []
  type: TYPE_NORMAL
- en: Its `origin` is checked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If that `origin` is local, then a corresponding `outbound_message` is created
    and sent, using the original `operation` of the incoming `message`, the local `origin`
    and `signing_key`, and whatever `data` is appropriate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, that entire branch is skipped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That''s not a lot of code to add—a mere nine lines, assuming that the sender
    isn''t created elsewhere. The changes to `DaemonMessage` are pretty trivial: adding
    the `origin` property and making sure it''s accounted for everywhere (basically,
    anywhere that the `operation` property is already in use). At this point, this
    doesn''t represent a major change to existing code either—we''ve only created
    outbound messages for Order creation and updates so far.'
  prefs: []
  type: TYPE_NORMAL
- en: If there is a sticking point, it's in the need to acquire the `Artisan` instance
    that relates to the operation  so that the outbound message can use the appropriate
    message queue (`artisan.queue_id`). This would be necessary no matter what approach
    we decide to pursue, though, so it's probably a wash in this case (and it would
    complicate the idea of modifying `save`, which we saw previously, even more).
  prefs: []
  type: TYPE_NORMAL
- en: 'Even with that, this feels like a solid approach. The changes to `_handle_message`
    are mostly argument and variable name changes at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The handler methods (using `update_product`, as an example) remain largely
    unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We still need the `properties`; we''re just acquiring them in the individual
    handler methods instead of in `_handle_message`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The code, from that point until the modified object is saved, remains unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we can check to see if an outbound message needs to be sent, acquire
    the relevant `Artisan`, create the `message`, and send it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Since acquiring an `Artisan` from a `Product` is going to be a recurring theme,
    a helper method (`get_artisan_from_product`) was created to streamline that process.
    It also highlights the eventual need for a more direct association between products
    and artisans, but a data object query-based process will suffice for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'A final consideration before ending this chapter: when we started this chunk
    of development, there was still a decision pending with respect to whether message
    queues were going to be implemented as a "one for all artisans" or "one for each
    Artisan." No formal decision was made, but there are other considerations that
    may have arisen as the messaging processes were being thought out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each Artisan needs at least two separate message queues: one for traffic to
    the Artisan, and one for traffic from them. If a single queue for all traffic
    is implemented, then:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code would have to be altered to include both an `origin` (already done)
    and a `destination` in order to assure that, for example, messages dropped in
    a queue by the Gateway weren't also read by the Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even with that in place, a message that hasn't been read and acted upon by the
    appropriate destination would almost certainly block other messages in the queue
    from being read and acted upon, without still more code changes and the attendant
    complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If each Artisan has a distinct message queue for inbound and outbound messages,
    that entire set of complications will simply go away. There is some additional
    work that will be necessary—providing some means of identifying individual inbound
    and outbound queues—but if each queue handles only traffic in one direction, to
    or from one Artisan Application and the Gateway service, this simplifies things
    considerably, and the development cost should be pretty minimal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a side benefit, since each message in a queue would, simply because it came
    from that queue, be immediately associable with the Artisan that the queue belongs
    to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only remaining cost in having multiple message queues is that multiple queues
    would exist—and that, in the main, is a cost that will be borne by the message
    queue server.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The development efforts in this chapter have been scattered all over the system's
    code-base, largely because of some requirement gaps or implementation needs and
    details that surfaced as specific functionality unfolded. Ideally, in a real-world
    effort, much of that would have surfaced considerably earlier, and been expressed
    as specific tasks that were attached to the stories in the iteration, though some
    might still have occurred—we've made some decisions, both in this chapter and
    the one before, that shaped how things needed to work, that might not have been
    captured in an initial story analysis exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, the code at this point is quite probably broken. Perhaps drastically
    broken. Still, there''s been a lot of progress against the iteration''s stories,
    even if none of them can be formally closed yet:'
  prefs: []
  type: TYPE_NORMAL
- en: Fundamental functionality for dealing with all the data flow between system
    components has been defined, with a few concrete implementations that will serve
    as starting points for other concrete implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes needed to accomplish the transmission and receipt of messages have been
    scoped, if not implemented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solid (if basic) understanding of how and when those messages need to be sent
    has been established
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's still work to be done on most of the iteration stories before they can
    be considered complete—even setting aside the UI considerations, we still don't
    have demonstrable, provable message flows in place. Getting those finalized will
    be the focus of the next chapter, and it will take a decidedly test-driven approach,
    even if it's not a formal TDD process.
  prefs: []
  type: TYPE_NORMAL
