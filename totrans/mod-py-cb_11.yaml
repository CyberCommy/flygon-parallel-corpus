- en: Chapter 11. Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using docstrings for testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing functions that raise exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling common doctest issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating separate test modules and packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining unittest and doctest tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing things that involve dates or times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing things that involve randomness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking external resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing is central to creating working software. Here''s the canonical statement
    in the importance of testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Any program feature without an automated test simply doesn''t exist.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This is from Kent Beck''s book, *Extreme Programming Explained: Embrace Change*
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can distinguish several kinds of testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing** : This applies to independent *units* of software: functions,
    classes, or modules. The unit is tested in isolation to confirm that it works
    correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration testing** : This combines units to be sure they integrate properly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System testing** : This tests an entire application or a system of interrelated
    applications to be sure that the aggregated suite of software components works
    properly. This is often used for overall acceptance of software as fit for use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance testing** : This assures that a unit meets performance objectives.
    In some cases, performance testing includes the study of resources such as memory,
    threads, or file descriptors. The goal is to be sure that software makes appropriate
    use of system resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python has two built-in testing frameworks. One examines the docstrings for
    examples that include the `>>>` prompt. This is the `doctest` tool. While this
    is widely used for unit testing, it can also be used for simple integration testing.
  prefs: []
  type: TYPE_NORMAL
- en: The other testing framework uses classes built with definitions from the `unittest`
    module. This module defines a `TestCase` class. This, too, is designed primarily
    for unit testing, but can also be applied to integration and performance testing.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we'll want to combine these tools. Both modules have features to
    allow coexistence. We'll often leverage the test loading protocol from the `unittest`
    package to merge all of our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we might use the tools `nose2` or `py.test` to further automate
    test discovery and add additional features such as test case coverage. These projects
    are often helpful for particularly complex applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s sometimes helpful to summarize a test using the GIVEN-WHEN-THEN style
    of test case naming:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVEN** some initial state or context'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WHEN** a behavior is requested'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**THEN** the component under test has some expected result or state change'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using docstrings for testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good Python includes docstrings inside every module, class, function, and method.
    Many tools can create useful, informative documentation from the docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: One important element of a docstring is an example. The example becomes a kind
    of unit test case. An example often fits the GIVEN-WHEN-THEN model of testing
    because it shows a unit, a request, and a response.
  prefs: []
  type: TYPE_NORMAL
- en: How can we turn examples into proper test cases?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at a simple function definition as well as a simple class definition.
    Each of these will include docstrings that include examples which can be used
    as formal tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple function that computes the binomial coefficient of two numbers.
    It shows the number of combinations of *n* things taken in groups of size *k*
    . For example, how many ways a 52-card deck can be dealt into 5-card hands is
    computed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This defines a small Python function that we can write like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This function does a simple calculation and returns a value. Since it has no
    internal state, it's relatively easy to test. This will be one of the examples
    used for showing the unit testing tools available.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also look at a simple class which has a lazy calculation of mean and
    median. It uses an internal `Counter` object which can be interrogated to determine
    the mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `add()` method changes the state of this object. Because of this state change,
    we'll need to provide more sophisticated examples that show how an instance of
    the `Summary` class behaves.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll show two variations in this recipe. The first is for largely stateless
    operations, such as the computation of the `binom()` function. The second is for
    stateful operations, such as the `Summary` class.
  prefs: []
  type: TYPE_NORMAL
- en: Put examples into the docstrings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the doctest module as a program. This is done in one of two ways:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the command prompt:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If all of the examples pass, there's no output. Using the `-v` option produces
    verbose output summarizing the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'By including a `__name__ == ''__main__''` section. This can import the doctest
    module and execute the `testmod()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If all of the examples pass, there's no output. To see some output, use the
    `verbose=1` parameter for the `testmod()` function to create more verbose output.
  prefs: []
  type: TYPE_NORMAL
- en: Writing examples for stateless functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Start the docstring with a summary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Include the parameter definitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Include the return value definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Mock up an example of using the function at Python''s `>>>` prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Close the long docstring with the appropriate quotation marks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Writing examples for stateful objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Write a class-level docstring with a summary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We've left space to fill in examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the method-level docstring with a summary. Here''s the `add()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the `mean()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A similar string is required for the `median()` method, and any others that
    are written.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extend the class-level docstring concrete examples. In this case, we''ll write
    two. The first example shows that the `add()` method has no return value, but
    changes the state of the object. The `mean()` method reveals this state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We've rounded the result of the mean to avoid displaying a long floating-point
    value that might not have the exact same text representation on all platforms.
    When we run doctest, we'll generally get a silent response because the test passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second example shows a multiline result from the `__str__()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens when something doesn''t work? Imagine that we changed the expected
    output to have a wrong answer. When we run doctest, we''ll see output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This shows where the error is. It shows an expected value from the test example,
    and the actual answer.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `doctest` module includes a main program—as well as several functions—that
    will scan a Python file for `>>>` examples. We can leverage the module scanning
    function, `testmod()` , to scan the current module. We can use this to scan any
    imported module.
  prefs: []
  type: TYPE_NORMAL
- en: The scanning operation looks for blocks of text that have a characteristic pattern
    of a `>>>` line followed by lines that show the response from the command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The doctest parser creates a small test case object from the prompt line and
    the block of response text. There are three common cases:'
  prefs: []
  type: TYPE_NORMAL
- en: 'No expected response text: We saw this pattern when we defined the tests for
    the `add()` method of the `Summary` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Single line of response text: This was exemplified by the `binom()` function
    and the `mean()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiple lines of response: Responses are bounded by either the next `>>>`
    prompt or a blank line. This was exemplified by the `str()` example of the `Summary`
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The doctest module will execute each line of code shown with a `>>>` prompt.
    It compares the actual results with the expected results. The comparison is a
    very simple text matching. Unless special annotations are used, the output must
    precisely match the expectations.
  prefs: []
  type: TYPE_NORMAL
- en: The simplicity of this testing protocol imposes some software design requirements.
    Functions and classes must be designed to work from the `>>>` prompt. Because
    it can become awkward to create very complex objects as part of a docstring example,
    the design must be kept simple enough that it can be demonstrated interactively.
    Keeping software simple enough to demonstrate at the `>>>` prompt is often beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: The simplicity of the comparison of the results can impose some complications
    on the output that's being displayed. Note, for example, that we rounded the value
    of the mean to two decimal places. This is because the display of floating-point
    values may vary slightly from platform to platform.
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.5.1 (on Mac OS X) shows `8.666666666666666` where Python 2.6.9 (also
    on Mac OS X) shows `8.6666666666666661` . The values are equal for 16 of the decimal
    digits. This is about 48 bits of data, which is the practical limit of floating-point
    values.
  prefs: []
  type: TYPE_NORMAL
- en: We'll address the exact comparison issue in detail in the *Handling common doctest
    issues* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the important test considerations is edge cases. An **edge case** generally
    focuses on the limits for which a calculation is designed. There are, for example,
    two edges to the binomial function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can easily add these to the examples to be sure that our implementation
    is sound; this leads to a function that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In some cases, we might need to test values that are outside the valid range
    of values. These cases aren't really ideal for putting into the docstring, because
    they clutter an explanation of what is supposed to happen with an explanation
    of other things that should never normally happen.
  prefs: []
  type: TYPE_NORMAL
- en: We can include additional docstring test cases in a global variable named `__test__`
    . This variable must be a mapping. The keys to the mapping are test case names,
    and the values of the mapping are doctest examples. These will need to be triple-quoted
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: Because the examples are not inside the docstrings, they don't show up when
    using the built-in `help()` function. Nor do they show up when using other tools
    to create documentation from source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might add something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We've written the mapping with the keys with no indent. The values have been
    indented four spaces so that they stand out from the keys and are slightly easier
    to spot.
  prefs: []
  type: TYPE_NORMAL
- en: These test cases are found by the doctest program and included in the overall
    suite of tests. We can use this for tests that are important, but aren't really
    helpful as documentation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Testing functions that raise exceptions* and *Handling common doctest
    issues* recipes, we'll look at two additional doctest techniques. These are important
    because exceptions can often include a traceback which may include object IDs
    that can vary each time the program is run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing functions that raise exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good Python includes docstrings inside every module, class, function, and method.
    Many tools can create useful, informative documentation from these docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: One important element of a docstring is an example. The example becomes a kind
    of unit test case. Doctest does simple, literal matching of the expected output
    against the actual output.
  prefs: []
  type: TYPE_NORMAL
- en: When an example raises an exception, though, the traceback messages from Python
    are not always identical. It may include object ID values that change or module
    line numbers which may vary slightly depending on the context in which the test
    is executed. The literal matching rules for doctest aren't appropriate when exceptions
    are involved.
  prefs: []
  type: TYPE_NORMAL
- en: How can we turn exception processing and the resulting traceback messages into
    proper test cases?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at a simple function definition as well as a simple class definition.
    Each of these will include docstrings that include examples which can be used
    as formal tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple function that computes the binomial coefficient of two numbers.
    It shows the number of combinations of *n* things taken in groups of *k* . For
    example, how many ways a 52-card deck can be dealt into 5-card hands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](Image00056.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This defines a small Python function that we can write like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This function does a simple calculation and returns a value. We'd like to include
    some additional test cases in the `__test__` variable to show what this does when
    given values outside the expected ranges.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a global `__test__` variable in the module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We've left space to insert one or more test cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each test case, provide a name and a placeholder for the example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Include the invocation with a `doctest` directive comment, `IGNORE_EXCEPTION_DETAIL`
    . This replaces the "example goes here":'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The directive starts with `# doctest:` . Directives are enabled with `+` and
    disabled with `-` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Include an actual traceback message. This is part of the *example goes here*
    ; it goes after the `>>>` statement to show the expected response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The three lines that start with `File...` will be ignored. The `ValueError:`
    line will be checked to be sure that the test produces the expected exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The overall statement looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use a command like this to test the entire module''s features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The doctest parser has several directives that can be used to modify the testing
    behavior. The directives are included as special comments with the line of code
    that performs the test action.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two ways to handle tests that include an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `# doctest: +IGNORE_EXCEPTION_DETAIL` and provide a full traceback
    error message. The details of the traceback are ignored, and only the final exception
    line is matched against the expected value. This makes it very easy to copy an
    actual error and paste it into the documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use `# doctest: +ELLIPSIS` and replace parts of the traceback message
    with `...` . This, too, allows an expected output to elide details and focus on
    the last line that has the actual error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this second kind of exception example, we might include a test case like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The test case uses the `+ELLIPSIS` directive. The details of the error traceback
    have had irrelevant material replaced with `...` . The relevant material has been
    left intact so that the actual exception message will match the expected exception
    message precisely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Doctest will ignore everything between the first `Traceback...` line and the
    final `ValueError: ...` line. Generally, the final line is all that matters for
    proper execution of the test. The intermediate text depends on the context in
    which the test was run.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several more comparison directives that can be provided to individual
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: '`+ELLIPSIS` : This allows an expected result to be generalized by replacing
    details with `...` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+IGNORE_EXCEPTION_DETAIL` : This allows an expected value to include a complete
    traceback message. The bulk of the traceback will be ignored, and only the final
    exception line is checked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+NORMALIZE_WHITESPACE` : In some cases, the expected value might be wrapped
    onto multiple lines to make it easier to read. Or, it might have spacing that
    varies slightly from standard Python values. Using this flag allows some flexibility
    in the whitespace for the expected value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+SKIP` : The test is skipped. This is sometimes done for tests that are designed
    for a future release. Tests may be included prior to the feature being completed.
    The test can be left in place for future development work, but skipped in order
    to release a version on time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+DONT_ACCEPT_TRUE_FOR_1` : This covers a special case that was common in Python
    2\. Before `True` and `False` were added to the language, values `1` and `0` were
    used instead. The doctest algorithm for comparing expected results to actual results
    will honor this older scheme by matching `True` and `1` . This directive can be
    provided at the command line using `-o DONT_ACCEPT_TRUE_FOR_1` . This change would
    then be globally true for all tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+DONT_ACCEPT_BLANKLINE` : Normally, a blank line ends an example. In the case
    where the example output includes a blank line, the expected results must use
    the special syntax `<blankline>` . Using this shows where a blank line is expected,
    and the example doesn''t end at this blank line. In very rare cases, the expected
    output will actually include the string `<blankline>` . This directive assures
    that `<blankline>` is not used to mean a blank line but stands for itself. This
    would make sense when writing tests for the doctest module itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These can also be provided as the `optionsflags` parameter when evaluating the
    `testmod()` or `testfile()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Using docstrings for testing* recipe for the basics of doctest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Handling common doctest issues* recipe for other special cases that
    require doctest directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling common doctest issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good Python includes docstrings inside every module, class, function, and method.
    Many tools can create useful, informative documentation from minimally complete
    docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: One important element of a docstring is an example. The example becomes a kind
    of unit test case. Doctest does simple, literal matching of the expected output
    against the actual output. There are some Python objects, however, that are not
    consistent every time they're referred to.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, all object hash values are randomized. This means that the order
    of elements in a set or the order of keys in a dictionary can vary. We have several
    choices for creating test case example output:'
  prefs: []
  type: TYPE_NORMAL
- en: Write tests that can tolerate randomization. Often by converting to a sorted
    structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stipulate a value for the `PYTHONHASHSEED` environment variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Require that Python be run with the `-R` option to disable hash randomization
    entirely.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several other considerations beyond simple variability in the location
    of keys or items in a set. Here are some other concerns:'
  prefs: []
  type: TYPE_NORMAL
- en: The `id()` and `repr()` functions may expose an internal object ID. No guarantees
    can be made about these values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Floating-point values may vary across platforms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current date and time cannot meaningfully be used in a test case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random numbers using the default seed are difficult to predict.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS resources may not exist, or may not be in the proper state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll focus on the first two issues with some doctest techniques in this recipe.
    We'll look at `datetime` and `random` in the *Testing things that involve dates
    or times* and *Testing things that involve randomness*  recipes. We'll look at
    how to work with external resources in the *Mocking external resources* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Doctest examples require an exact match with the text. How can we write doctest
    examples that handle hash randomization or floating-point implementation details
    appropriately?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Reading delimited files with the CSV module* recipe, we looked at how
    the `csv` module will read data, creating a mapping for each row of input. In
    that recipe, we saw a `CSV` file that has some real-time data recorded from the
    log of a sailboat. This is the `waypoints.csv` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DictReader` class produces rows that look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is a doctest nightmare because the hash randomization assures that the
    order of the keys in this dictionary is likely to be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we try to write doctest examples that involve a dictionary, we''ll often
    see problems like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The data in the expected and actual rows clearly matches. However, the string
    displays of the dictionary values aren't exactly identical. The keys are not shown
    in a consistent order.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also look at a small real-valued function so that we can work with floating-point
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This function is the cumulative probability density function for standard z-scores.
    After normalizing a variable, the mean of the Z-score values for that variable
    will be zero, and the standard deviation will be one. See the *Creating a partial
    function* recipe in [Chapter 8](text00088.html#page "Chapter 8. Functional and
    Reactive Programming Features") , *Functional and Reactive Programming Features*
    , for more information on the idea of normalized scores.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function, Φ( *n* ), tells us exactly what fraction of the population is
    below a given z-score. For example, Φ(0) = 0.5: half the population has a z-score
    below zero.'
  prefs: []
  type: TYPE_NORMAL
- en: This function involves some rather complex processing. The unit tests have to
    reflect the floating-point precision issues.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at mapping (and set) ordering in one recipe. We'll look at the floating
    point separately.
  prefs: []
  type: TYPE_NORMAL
- en: Writing doctest examples for mapping or set values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Import the necessary libraries and define the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We've included the example heading in the document string.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can replace actual data files with instances of the `StringIO` class from
    the `io` package. This can be used inside the example to provide fixed sample
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Conceptually, the test case is this. This code will not work properly because
    the keys will be scrambled. However, it can be refactored easily:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve omitted the rest of the output, since it varies each time the test is
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code must be written like this to force the keys into a fixed order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The sorted items are in a consistent order.
  prefs: []
  type: TYPE_NORMAL
- en: Writing doctest examples for floating-point values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Import the necessary libraries and define the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We've left a space for examples in the document string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each example, include an explicit use of `round()` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The float values are rounded so that differences in floating-point implementation
    details don't lead to seemingly incorrect results.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because of hash randomization, the hash keys used for dictionaries are unpredictable.
    This is an important security feature, and defeats a subtle denial-of-service
    attack. For details, see [http://www.ocert.org/advisories/ocert-2011-003.html](http://www.ocert.org/advisories/ocert-2011-003.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two ways to work with dictionary keys that have no defined order:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write test cases that are specific to each key:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can convert to a data structure with a fixed order. The value of `row.items()`
    is an iterable sequence of pairs with each key and value. The order is not set
    in advance, but we can use the following to force an order:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This returns a list with the keys sorted into order. This allows us to create
    a consistent literal value that will always be the same every time the test is
    evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Most floating-point implementations are reasonably consistent. However, there
    are few formal guarantees about the last few bits of any given floating-point
    number. Rather than trust that all 53 bits have exactly the right value, it's
    often much easier to round the value to a value that's a good fit with the problem
    domain.
  prefs: []
  type: TYPE_NORMAL
- en: For most modern processors, floating-point values are often either 32 or 64-bit
    values. A 32-bit value has about seven decimal digits. Rounding the value so that
    there are no more than six digits in the value is generally the simplest approach.
  prefs: []
  type: TYPE_NORMAL
- en: Rounding to six digits does not mean using `round(x, 6)` . The `round()` function
    doesn't preserve a number of digits. This function rounds to a number of digits
    to the right of the decimal point; it doesn't account for digits to the left of
    the decimal point. Rounding a number on the order of 10^(12) to six positions
    to the right of the decimal point leads to 18 digits—too many for a 32-bit value.
    Rounding a number on the order of 10^(-7) to six positions to the right of the
    decimal place leads to zero.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with `set` objects, we must also be careful of the order of the
    items. We can generally use `sorted()` to convert a `set` to a `list` and impose
    a specific order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python `dict` objects show up in a surprising number of places:'
  prefs: []
  type: TYPE_NORMAL
- en: When we write a function that uses the `**` to collect a dictionary of argument
    values. There's no guarantee for the order of the arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we use a function such as `vars()` to create a dictionary from local variables,
    or from the attributes of an object, the dictionary has no guaranteed order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we write programs that rely on introspection of a class definition, the
    methods are defined in a class-level dictionary object. We can't predict their
    order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This becomes apparent when there are unreliable test cases. A test case which
    passes or fails seemingly randomly may have a result which is based on a hash
    randomization. Extract the keys and sort them to overcome this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the tests using this command-line option too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This will turn off hash randomization while running doctest on a specific file,
    `ch11_r03.py` .
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Testing things that involve dates or times* recipe, in particular the `now()`
    method of datetime requires some care.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Testing things that involve randomness* recipe will show how to test processing
    that involves `random` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating separate test modules and packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can do any kind of unit testing in docstring examples. There are some things,
    however, which can become extremely tedious when done this way.
  prefs: []
  type: TYPE_NORMAL
- en: The `unittest` module allows us to step beyond simple examples. These tests
    rely on test case class definitions. A subclass of `TestCase` can be used to write
    very complex and sophisticated tests; these can be simpler than the same test
    done as doctest examples.
  prefs: []
  type: TYPE_NORMAL
- en: The `unittest` module also allows us to package tests outside the docstrings.
    This can be helpful for particularly complex tests of corner cases that aren't
    as helpful when placed in the documentation. Ideally, doctest cases illustrate
    the **happy path –**  the most common use cases. It's common to use `unittest`
    for test cases which are off the happy path.
  prefs: []
  type: TYPE_NORMAL
- en: How can we create more sophisticated tests?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A test can often be summarized by a three-part  *Given-When-Then* story:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVEN** : Some unit in an initial state or context'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WHEN** : A behavior is requested'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**THEN** : The component under test has some expected result or state change'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `TestCase` class doesn''t precisely follow this three-part structure. It
    has two parts; some design choices must be made regarding where the three parts
    of a test are allocated:'
  prefs: []
  type: TYPE_NORMAL
- en: A `setUp()` method that implements the *Given* aspect of the test case. It can
    also handle the *When* aspect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `runTest()` method that must handle the *Then* aspects. This can also handle
    the *When* aspect. The *Then* conditions are confirmed by a series of assertions.
    These generally use the sophisticated assertion methods of the `TestCase` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The choice of where to implement the *When* aspect is tied to the question of
    reuse. In most cases, there are many alternative *When* conditions, each with
    a unique *Then* to confirm correct operation. The *Given* might be common to the
    `setUp()` method, and shared by a number of `TestCase` subclasses. Each subclass
    would have a unique `runTest()` method to implement the *When* and *Then* aspects.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the *When* aspect is split into some common parts and some test-case-specific
    parts. In this case, the *When* aspect may be partly defined in the `setUp()`
    method and partly defined in `runTest()` method.
  prefs: []
  type: TYPE_NORMAL
- en: We'll create some tests for a class that is designed to compute some basic descriptive
    statistics. We'd like to provide sample data that's far larger than anything we'd
    ever enter as doctest examples. We'd like to use thousands of data points rather
    than two or three.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an outline of the class definition that we''d like to test. We''ll
    only provide the methods and some summaries. The bulk of the code was shown in
    the *Using docstrings for testing* recipe. We''ve omitted all of the implementation
    details. This is just an outline of the class, provided as a reminder of what
    the method names are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Because we're not looking at the implementation details, this is a kind of black
    box testing. The code is a black box—the internals are opaque. To emphasize that,
    we omitted the implementation details from the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: We'd like to be sure that when we use thousands of samples, the class performs
    correctly. We'd also like to ensure that it works quickly; we'll use this as part
    of an overall performance test, as well as a unit test.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll include the test code in the same module as the working code. This will
    follow the pattern of doctest that bundles tests and code together. We''ll use
    the `unittest` module for creating test classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We'll also be using `random` to scramble the input data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a subclass of `unittest.TestCase` . Provide this class with a name that
    shows the intent of the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The *GIVEN-WHEN-THEN* names are very long. We'll rely on `unittest` to discover
    all subclasses of `TestCase` so we don't have to type this class name more than
    once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a `setUp()` method in this class which handles the *Given* aspect of
    the test. This creates a context for test processing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We've created a collection of `1,001` samples ranging in value from `0` to `1,000`
    . The mean is 500 exactly, so is the median. We've shuffled the data into a random
    order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a `runTest()` method which handles the *When* aspect of the test. This
    performs the state change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Add assertions to implement the *Then* aspect of the test. This confirms that
    the state changes worked properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it very easy to run, add a main program section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: With this, the test can be run at Command Prompt. It can also be run from the
    command line.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re using several parts of the `unittest` module:'
  prefs: []
  type: TYPE_NORMAL
- en: The `TestCase` class is used to define one test case. This can have a `setUp()`
    method to create the unit and possibly the request . This must have at least a
    `runTest()` to make the request and check the response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can have as many of these class definitions in a file as we need to build
    up an appropriate set of tests. For simple classes, there may be only a few test
    cases. For complex modules, there may be dozens or even hundreds of cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `unittest.main()` function does several things:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It creates an empty `TestSuite` that will contain all the `TestCase` objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses a default loader to examine a module and find all of the `TestCase`
    instances. These are loaded into the `TestSuite` . This process is something that
    we might want to modify or extend.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then runs the `TestSuite` and displays a summary of the results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we run this module, we''ll see output that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As each test is passed, a `.` is displayed. This shows that the test suite is
    making progress. After the line of `-` is a summary of the tests run, and the
    time. If there are failures, or exceptions, the counts will reflect this.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there's a summary of `OK` to show whether all tests passed or any tests
    have failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we change the test slightly to be sure that it fails, we''ll see the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Instead of a `.` for a passing test, a failing test displays an `F` . This is
    followed by the traceback from the assertion which failed. To force the test to
    fail, we changed the expected mean to `501` , which is not the computed mean value
    of `500.0` .
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a final summary of `FAILED` . This includes the reason why the suite
    as a whole is a failure: `(failures=1)` .'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we have two *Then* conditions inside the `runTest()` method.
    If one fails, the test stops as a failure, and the other condition is not exercised.
  prefs: []
  type: TYPE_NORMAL
- en: This is a weakness in the design of this test. If the first test fails, we won't
    get all of the diagnostic information we might want. We should avoid independent
    collections of assertions in the `runTest()` method. In many cases, a test case
    may involve multiple dependent assertions; a single failure provides all the diagnostic
    information that's required. The clustering of assertions is a design trade-off
    between simplicity and diagnostic detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we want more diagnostic details, we have two general choices:'
  prefs: []
  type: TYPE_NORMAL
- en: Use multiple test methods instead of `runTest()` . Write multiple methods with
    names that start with `test_` . Remove any method named `runTest()` . The default
    test loader will execute each `test_` method separately, after rerunning the common
    `setUp()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use multiple subclasses of the `GIVEN_Summary_WHEN_1k_samples_THEN_mean` class,
    each with a separate condition. Since the `setUp()` is common, this can be inherited.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following the first alternative, the test class would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We've refactored the `setUp()` method to include the *Given* and *When* conditions
    of the test. The two independent *Then* conditions are refactored into their own
    separate `test_mean()` and `test_median()` methods. There is no `runTest()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Since each test is run separately, we'll see separate error reports for problems
    with computing mean or computing median.
  prefs: []
  type: TYPE_NORMAL
- en: Some other assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `TestCase` class defines numerous assertions that can be used as part of
    the *Then* condition; here are a few of the most commonly used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assertEqual()` and `assertNotEqual()` compare actual and expected values using
    the default `==` operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertTrue()` and `assertFalse()` require a single boolean expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertIs()` and `assertIsNot()` use the `is` comparison to determine whether
    the two arguments are references to the same object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertIsNone()` and `assertIsNotNone()` use `is` to compare a given value
    with `None` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertIsInstance()` and `assertNotIsInstance()` use the `isinstance()` function
    to determine whether a given value is a member of a given class (or tuple of classes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertAlmostEquals()` and `assertNotAlmostEquals()` round the given values
    to seven decimal places to see whether most of the digits are equal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertRegex()` and `assertNotRegex()` compare a given string using a regular
    expression. This uses the `search()` method of the regular expression to match
    the string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertCountEqual()` compares two sequences to see whether they have the same
    elements, irrespective of order. This can be handy for comparing dictionary keys
    and sets too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are still more assertion methods. A number of them provide ways to detect
    exceptions, warnings, and log messages. Another group provides more type-specific
    comparison capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the mode feature of the `Summary` class produces a list. We can
    use a specific `assertListEqual()` assertion to compare the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: First, we built a collection of 1,000 values. Of those, 97 are copies of the
    number 500\. The remaining 903 elements are copies of numbers between 1 and 42\.
    These numbers have a simple rule—the frequency is the value. This rule makes it
    easier to confirm the results.
  prefs: []
  type: TYPE_NORMAL
- en: The `setUp()` method shuffled the data into a random order. Then the `Summary`
    object is built using the `add()` method.
  prefs: []
  type: TYPE_NORMAL
- en: We've used a `test_mode()` method. This allows for expansion to include other
    *Then* conditions on this test. In this case, we examined the first three values
    from the mode to be sure it had the expected distribution of values. The `assertListEqual()`
    compares two `list` objects; if either argument is not a list, we'll get a more
    specific error message showing that the argument wasn't of the expected type.
  prefs: []
  type: TYPE_NORMAL
- en: Separate tests directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've shown the `TestCase` class definitions in the same module as the code
    being tested. For small classes, this can be helpful. Everything related to the
    class can be found in one module file.
  prefs: []
  type: TYPE_NORMAL
- en: In larger projects, it's common practice to sequester the test files into a
    separate directory. The tests can be (and often are) extremely large. It's not
    unreasonable to have more test code than application code.
  prefs: []
  type: TYPE_NORMAL
- en: When this is done, we can rely on the discovery application that's part of the
    `unittest` framework. This application can search all of the files of a given
    directory for test files. Generally, these will be files with names that match
    the pattern `test*.py` . If we use a simple, consistent name for all test modules,
    then they can be located and run with a simple command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `unittest` loader will search each module in the directory for all classes
    that are derived from the `TestCase` class. This collection of classes within
    the larger collection of modules becomes the complete `TestSuite` . We can do
    this with the `os`  command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This will locate all tests in the `tests` directory of a project.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll combine `unittest` and `doctest` in the *Combining unittest and doctest
     tests*  recipe. We'll look at mocking external objects in the *Mocking external
    resources* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining unittest and doctest tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most cases, we'll have a combination of `unittest` and `doctest` test cases.
    For examples of doctest, see the *Using docstrings for testing* recipe. For examples
    of unittest, see the *Creating separate test modules and packages* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The `doctest` examples are an essential element of the documentation strings
    on modules, classes, methods, and functions. The `unittest` cases will often be
    in a separate `tests` directory in files with names that match the pattern `test_*.py`
    .
  prefs: []
  type: TYPE_NORMAL
- en: How can we combine all of these various tests into one tidy package?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll refer back to the example from the *Using docstrings for testing* recipe.
    This recipe created tests for a class, `Summary` , that does some statistical
    calculations. In that recipe, we included examples in the docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class started like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The methods have been omitted here so that we can focus on the example provided
    in the docstring.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *Creating separate test modules and packages* recipe, we wrote some
    `unittest.TestCase` classes to provide additional tests for this class. We created
    class definitions like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This test creates a `Summary` object; this is the *Given* aspect. It then adds
    a number of values to that `Summary` object. This is the *When* aspect of the
    test. The two `test_` methods implement two *Then* aspects of this test.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s common to see a project folder structure that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We have a top-level folder, `git-project-name` , that matches the project name
    in the source code repository. We've assumed that Git is being used, but other
    tools are possible.
  prefs: []
  type: TYPE_NORMAL
- en: Within the top-level directory, we would have some overheads that are common
    to large Python projects. This would include files such as `README.rst` with a
    description of the project, `requirements.txt` , which can be used with `pip`
    to install extra packages, and perhaps `setup.py` to install the package into
    the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: The directory `statstools` contains a module file, `summary.py` . This has our
    module that provides interesting and useful features. This module has docstring
    comments scattered around the code.
  prefs: []
  type: TYPE_NORMAL
- en: The directory `tests` contains another module file, `test_summary.py` . This
    has the `unittest` test cases in it. We've chosen the names tests and `test_*.py`
    so that they fit well with automated test discovery.
  prefs: []
  type: TYPE_NORMAL
- en: We need to combine all of the tests into a single, comprehensive test suite.
  prefs: []
  type: TYPE_NORMAL
- en: The example we'll show uses `ch11_r01` instead of some cooler name such as `summary`
    . A real project often has clever, meaningful names. The book content is quite
    large, and the names are designed to match the overall chapter and recipe outline.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this example, we'll assume that the unittest test cases are in a file separate
    from the code being tested. We'll have `ch11_r01` and `test_ch11_r01` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To use doctest tests, import the `doctest` module. We''ll be combining doctest
    examples with `TestCase` classes to create a comprehensive test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We'll assume that the `unittest` `TestCase` classes are already in place and
    we're adding more tests to the test suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the module which is being tested. This module will have strings with
    doctests in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the `load_tests` protocol, include the following function in the
    test module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The function must have this name to be found by the test loader.
  prefs: []
  type: TYPE_NORMAL
- en: 'To incorporate doctest tests, an additional loader is required. We''ll use
    the `doctest.DocTestSuite` class to create a suite. These tests will be added
    to the suite of tests provided as the `standard_tests` parameter value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `loader` argument is the test case loader currently being used. The `standard_tests`
    value will be all of the tests loaded by default. Generally, this is the suite
    of all subclasses of `TestCase` . The pattern value was the value provided to
    the loader.
  prefs: []
  type: TYPE_NORMAL
- en: We can now add `TestCase` classes and the overall `unittest.main()` function
    to create a comprehensive test module that includes the unittest `TestCase` plus
    all of the doctest examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done by including the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to run the module and execute the tests.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we evaluate `unittest.main()` inside this module, then the test loader
    process is limited to the current module. The loader will find all classes that
    extend `TestCase` . These are the standard tests that are provided to the `load_tests()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: We will supplement the standard tests with tests created by the `doctest` module.
    Generally, we'll be able to import the module under test and use the `DocTestSuite`
    to build a test suite from the imported module.
  prefs: []
  type: TYPE_NORMAL
- en: The `load_tests()` function is used automatically by the `unittest` module.
    This function can do a variety of things to the test suite that it's given. In
    this example, we've supplemented the test suite with additional tests.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, a module may be quite complex; this can lead to multiple test
    modules. There might be several test modules with names such as `tests/test_module_feature.py`
    or something similar to show that there are multiple tests for separate features
    of a complex module.
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, we might have a test module which has tests for several different
    but closely related modules. A package may be decomposed into multiple modules.
    A single test module, however, may cover all of the modules in the package being
    tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'When combining many smaller modules, there may be multiple suites built in
    the `load_tests()` function. The body might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This will incorporate `doctests` from multiple modules.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For examples of doctest, see the *Using docstrings for testing* recipe. For
    examples of unittest, see the *Creating separate test modules and packages* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](image/614271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing things that involve dates or times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many applications rely on `datetime.datetime.now()` to create a timestamp. When
    we use this with a unit test, the results are essentially impossible to predict.
    We have a dependency injection problem here, our application depends on a class
    that we would like to replace only when we're testing.
  prefs: []
  type: TYPE_NORMAL
- en: One option is to avoid `now()` and `utcnow()` . Instead of using these directly,
    we can create a factory function that emits timestamps. For test purposes, this
    function can be replaced with one that produces known results. It seems awkward
    to avoid using the `now()` method in a complex application.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to avoid direct use of the `datetime` class entirely. This
    requires designing classes and modules that wrap the `datetime` class. A wrapper
    class that produces known values for `now()` can then be used for testing. This,
    too, seems needlessly complex.
  prefs: []
  type: TYPE_NORMAL
- en: How can we work with `datetime` stamps?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll work with a small function that creates a `CSV` file. This file''s name
    will include the date and time. We''ll create files with names that look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This kind of file-naming convention might be used by a long-running server application.
    The name helps match a file and related log events. It can help to trace the work
    being done by the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use a function like this to create these files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This function has a use of `utcnow()` . It is technically possible to redesign
    the function and provide the timestamp as an argument. There are situations where
    this kind of redesign might be helpful. There's also a handy alternative to a
    redesign.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a mock version of the `datetime` module, and patch the test context
    to use mock version instead of the actual version. This test will contain a mock
    class definition for the `datetime` class. Within that class, we'll provide a
    mock `utcnow()` method that will provide the expected response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the function being tested creates a file, we need to think about the
    OS consequences of this. What should happen when a file with the same name already
    exists? Should an exception be raised? Should a suffix be added to the file name?
    Depending on our design decision, we may need to have two additional test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Given a directory empty of conflicts. In this case, a `setUp()` method to remove
    any previous test output. We may also want to create a `tearDown()` method to
    remove the file after a test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given a directory with a conflicting name. In this case, a `setUp()` method
    will create a conflicting file. We may also want to create a `tearDown()` method
    to remove the file after a test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this recipe, we'll assume that duplicate file names don't matter. The new
    file should simply overwrite any previous file with no warning or notice. This
    is easy to implement, and often fits the real-world scenario where there's no
    reason to create multiple files less than 1 second apart in time.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this example, we''ll assume that the `unittest` test cases are the same
    module as the code being tested. Import the `unittest` and `unittest.mock` modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `unittest` module is simply imported. To use the features of this module,
    we'll have to qualify the names with `unittest.` . The various names from `unittest.mock`
    were all imported so the names can be used without any qualifier. We'll use a
    number of features of the mock module, and the long qualifying name is awkward.
  prefs: []
  type: TYPE_NORMAL
- en: Include the code to be tested. This is shown previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the following skeleton for testing. We''ve provided one class definition,
    plus a main script that can be used to execute the tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We didn't define a `load_tests()` function because we don't have any docstring
    tests to include.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setUp()` method will have several parts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The sample data to be processed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'A mock object for the `datetime` module. This object provides precisely the
    features used by the unit under test. The `Mock` module contains a single `Mock`
    class definition for the `datetime` class. Within that class, it provides a single
    mock method, `utcnow()` , which always provides the same response:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the expected file name given the `datetime` object shown above:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Some additional configuration processing is required to establish the *Given*
    condition. We''ll remove any previous edition of the file to be completely sure
    that the test assertions aren''t using a file from a previous test run:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `runTest()` method will have two parts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The *When* processing. This will patch the current module, `__main__` , so
    that a reference to `datetime` will be replaced with the `self.mock_datetime`
    object. It will then execute the request in that patched context:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The *Then* processing. In this case, we''ll open the expected file, load the
    content, and confirm that the result matches the source data. This finishes with
    the necessary assertion. If the file doesn''t exist, this will raise an `IOError`
    exception:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `unittest.mock` module has two valuable components that we're using here—the
    `Mock` object definition and the `patch()` function.
  prefs: []
  type: TYPE_NORMAL
- en: When we create an instance of the `Mock` class, we must provide the methods
    and attributes of the resulting object. When we provide a named argument value,
    this will be saved as an attribute of the resulting object. Simple values become
    attributes of the object. Values which are based on a `Mock` object become method
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we create an instance of `Mock` that provides the `return_value` (or `side_effect`
    ) named argument value, we''re creating a callable object. Here''s an example
    of a mock object that behaves like a very dumb function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We created a mock object, `dumb_function` , that will behave like a callable—a
    function—that only returns the value `12` . For unit testing, this can be very
    handy, since the results are simple and predictable.
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s more important is this feature of the `Mock` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dumb_function()` tracked each call. We can then make assertions about
    these calls. For example, the `assert_called_with()` method checks the last call
    in the history:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: If the last call really was `dumb_function(18)` , then this succeeds silently.
    If the last call doesn't match the assertion, then this raises an `AssertionError`
    exception that the `unittest` module will catch and register as a test failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see more detail like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This assertion checks the entire call history. It uses the `call()` function
    from the `Mock` module to describe the arguments provided in a function call.
  prefs: []
  type: TYPE_NORMAL
- en: The `patch()` function can reach into a module's context and change any reference
    in that context. In this example, we used `patch()` to tweak a definition in the
    `__main__` module—the one currently running. In many cases, we'll import another
    module, and will need to patch that imported module. It's crucial to reach out
    to the context that's in effect for the module under test and patch that reference.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we created a mock for the `datetime` module that had a very
    narrow feature set.
  prefs: []
  type: TYPE_NORMAL
- en: The module had a single element which is an instance of the `Mock` class, named
    `datetime` . For the purposes of unit testing, a mocked class generally behaves
    like a function which returns an object. In this case, the class returned a `Mock`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Mock` object that stands in for the `datetime` class has a single attribute,
    `utcnow()` . We used the special `return_value` keyword when defining this attribute
    so that it would return a fixed `datetime` instance. We can extend this pattern
    and mock more than one attribute to behave like a function. Here''s an example
    that mocks both `utcnow()` and `now()` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The two mocked methods, `utcnow()` and `now()` , each create a different `datetime`
    object. This allows us to distinguish between the values. We can more easily confirm
    the correct operation of a unit test.
  prefs: []
  type: TYPE_NORMAL
- en: Note that all of this `Mock` object construction executes during the `setUp()`
    method. This is long before the patching done by the `patch()` function. During
    `setUp()` , the `datetime` class is available. In the context of the `with` statement,
    the `datetime` class is unavailable, and is replaced by the `Mock` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add the following assertion to confirm that the `utcnow()` function
    was used properly by the unit under test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This will examine the `self.mock_datetime` mock object. It looks inside this
    object at the `datetime` attribute, which we've defined to have a `utcnow` attribute.
    We expect that this is called exactly once with no argument values.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `save_data()` function doesn''t make a proper call to `utcnow()` , this
    assertion will detect that failure. It''s essential to test both sides of the
    interface. This leads to two parts to a test:'
  prefs: []
  type: TYPE_NORMAL
- en: The result of the mocked `datetime` was used properly by the unit being tested
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The unit being tested made appropriate requests to the mocked `datetime` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In some cases, we might need to confirm that an obsolete or deprecated method
    is never called. We might have something like this to confirm that another method
    is not used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This kind of testing is used when refactoring software. In this example, the
    previous version may have used the `now()` method. After the change, the function
    is required to use the `utcnow()` method. We've included a test to be sure that
    the `now()` method is no longer being used.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating separate test modules and packages* recipe has more information
    about basic use of the `unittest` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing things that involve randomness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many applications rely on the `random` module to create random values or put
    values into random order. In many statistical tests, repeated random shuffling
    or random subset calculations are done. When we want to test one of the algorithms,
    the results are essentially impossible to predict.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two choices for trying to make the `random` module predictable enough
    to write meaningful unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Set a known seed value, this is common, and we've made heavy use of this in
    many other recipes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `unittest.mock` to replace the `random` module with something much less
    random.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we unit test algorithms that involve randomness?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given a sample dataset, we can compute a statistical measure such as a mean
    or median. A common next step is to determine the likely values of these statistical
    measures for some overall population. This can done by a technique called **bootstrapping**
    .
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to resample the initial set of data repeatedly. Each of the resamples
    provides a different estimate of the statistical measures. This overall set of
    resample metrics shows the likely variance of the measure for the overall population.
  prefs: []
  type: TYPE_NORMAL
- en: In order to be sure that a resampling algorithm works, it helps to eliminate
    randomness from the processing. We can resample a carefully planned set of data
    with a non-randomized version of the `random.choice()` function. If this works
    properly, then we have reason to believe that a truly random version will also
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our candidate resampling function. We need to validate this to be sure
    that it properly does sampling with replacement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We would normally apply this `resample()` function to populate a `Counter`
    object that tracks each distinct value for a particular measure such as the mean.
    The overall resampling procedure looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This evaluates the `resample()` function `1,000` times. This will lead to a
    number of subsets, each of which may have a distinct value for the mean. These
    values are used to populate the `mean_distribution` object.
  prefs: []
  type: TYPE_NORMAL
- en: The histogram for `mean_distribution` will provide a meaningful estimate for
    population variance. This estimate of the variance will help show the population's
    most likely actual mean value.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define an outline of the overall test class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We've included a main program so that we can simply run the module to test it.
    This is handy when working in tools such as IDLE; we can use the *F5* key to test
    the module after making a change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a mock version of the `random.choice()` function. We''ll provide a mock
    data set, `self.data` , and a mock response to the `choice()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: We've defined the `choice()` function using the `side_effect` attribute. This
    will return values one at a time from the given sequence. We've provided eight
    mock values that are distinct from the source sequence so that we readily identify
    the outputs from the `choice()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the *When* and *Then* aspects of the test. In this case, we''ll patch
    the `__main__` module to replace the reference to the `random` module. The test
    can then establish that the result has the expected set of values and that the
    `choice()` function was called multiple times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we create an instance of the `Mock` class, we must provide the methods
    and attributes of the resulting object. When the `Mock` object includes a named
    argument value, this will be saved as an attribute of the resulting object.
  prefs: []
  type: TYPE_NORMAL
- en: When we create an instance of `Mock` that provides the `side_effect` named argument
    value, we're creating a callable object. The callable object will return a value
    from the `side_effect` list each time the `Mock` object is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a mock object that behaves like a very dumb function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: First, we created a `Mock` object and assigned it to the name `dumb_function`
    . The `side_effect` attribute of this `Mock` object provides a short list of two
    distinct values that will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: The example then evaluates `dumb_function()` two times with two different argument
    values. Each time, the next value is returned from the `side_effect` list. The
    third attempt raises a `StopIteration` exception that becomes a test failure.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior allows us to write a test that detects certain kinds of improper
    uses of a function or a method. If the function is called too many times, an exception
    will be raised. Other improper uses must be detected with the various kinds of
    assertions that can be used for `Mock` objects.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can easily replace other features of the `random` module with mock objects
    that provide appropriate behavior without actually being random. We could, for
    example, replace the `shuffle()` function with a function that provides a known
    order. We might follow the above test design pattern like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: This mock `shuffle()` function returns a distinct set of values that can be
    used to confirm that some process is making proper use of the `random` module.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using set methods and operators* , *Creating dictionaries – inserting and
    updating*  recipes in [Chapter 4](text00048.html#page "Chapter 4. Built-in Data
    Structures – list, set, dict") ,  *Built-in Data Structures – list, set, dict*
    , and the  *Using cmd for creating command-line applications* recipe in [Chapter
    5](text00063.html#page "Chapter 5. User Inputs and Outputs") , *User Inputs and
    Outputs* , show how to seed the random number generator to create a predictable
    sequence of values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects")
    , *Basics of Classes and Objects* , there are several other recipes that show
    the alternative approach, for example, *Using a class to encapsulate data + processing*
    , *Designing classes with lots of processing* , *Optimizing small objects with
    __slots__* , and *Using properties for lazy attributes* .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, in [Chapter 7](text00079.html#page "Chapter 7. More Advanced Class Design")
    , *More Advanced Class Design* , see *Choosing between inheritance and extension –
    the is-a question* , *Separating concerns via multiple inheritance* , *Leveraging
    Python's duck typing* , *Creating a class which has orderable objects* , and *Defining
    an ordered collection* recipes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking external resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Testing things that involve dates or times* and *Testing things that involve
    randomness* recipes show techniques for mocking relatively simple objects. In
    the case of the  *Testing things that involve dates or times* recipe, the object
    being mocked is essentially stateless, and a single return value works nicely.
    In the *Testing things that involve randomness* recipe, the object has a state
    change, but the state change does not depend on any input arguments.
  prefs: []
  type: TYPE_NORMAL
- en: In these simpler cases, a test provides a series of requests to an object. Mock
    objects can be built which are based on a known and carefully planned sequence
    of state changes. The test case follows the object's internal state changes precisely.
    This is sometimes called white box testing because the implementation details
    of the object under test are required to define the test sequence and the mock
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, however, a test scenario may not involve a well-defined sequence
    of state changes. The unit under test may make requests in a difficult-to-predict
    order. This is sometimes a consequence of black box testing where the implementation
    details are not known.
  prefs: []
  type: TYPE_NORMAL
- en: How can we create more sophisticated mock objects that have internal state and
    make their own internal state changes?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at mocking a stateful RESTful web services request. In this case,
    we'll be using a database API for the Elastic database. See [https://www.elastic.co/](https://www.elastic.co/)
    for more information on this database. The database has the advantage of working
    with simple RESTful web services. These can easily be mocked to simple, fast unit
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we'll test a function that uses the RESTful API to create records.
    **Representational State Transfer** ( **REST** ) is a technique for using   **Hypertext
    Transfer Protocol** ( **HTTP** ) to transfer a representation of an object's state
    between processes. To create a database record, for example, a client will transfer
    a representation of an object's state to the database server, using HTTP `POST`
    requests. In many cases, JSON notation is used to represent object state.
  prefs: []
  type: TYPE_NORMAL
- en: Testing this function will involve mocking one part of the `urllib.request`
    module. Replacing the `urlopen()` function will allow a test case to simulate
    database activity. This will allow us to test a function that depends on web services
    without actually making potentially expensive or slow external requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two overall approaches to working with the elastic search API in
    our application software:'
  prefs: []
  type: TYPE_NORMAL
- en: We can install the Elastic database on our laptop or some server to which we
    have access. The installation is a two-part process that starts by installing
    a proper **Java Developer Kit** ( **JDK** ) and then installs the ElasticSearch
    software. We won't go into details here, because we have an alternative which
    seems simpler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The URLs to create and access objects on a local computer will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The requests will use a number of data items in the body of the request. These
    requests don't require any of the HTTP headers for security or authentication
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: We can use a hosting service such as [http://orchestrate.io](http://orchestrate.io)
    . This requires signing up with the service to get an API key instead of installing
    software. An API key grants access to a defined application. Within the application,
    a number of collections can be created. Since we won't have to install additional
    software, this seems like a handy way to proceed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The URLs to work with objects on a remote server will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The requests will also use a number of HTTP headers to provide information to
    the host. Next, We'll look at details of this service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data payload for the document to be created will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This JSON document represents a log entry. This came from the `sample.log` file
    used in earlier examples. This document can be understood as a specific instance
    of the event type that will be saved in the `eventlog` index of the database.
    The object has four attributes with string values.
  prefs: []
  type: TYPE_NORMAL
- en: The *Reading complex formats using regular expressions* recipe in [Chapter 9](text00099.html#page
    "Chapter 9. Input/Output, Physical Format, and Logical Layout") , *Input/Output,
    Physical Format, and Logical Layout* , shows how to parse a complex log file.
    In the *Using multiple contexts for reading and writing files* recipe, the complex
    log records were written to a `CSV` file. In this example, we'll show how the
    log records could be placed into cloud-based storage using a database such as
    Elastic.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an entry document in the entrylog collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We're going to create entry documents in an `entrylog` collection in the database.
    An HTTP `POST` request is used to create new items. The response of `201 Created`
    will indicate that the database created the new event.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `orchestrate.io` database service, each request has a base URL.
    We can define this with a string like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The `https` scheme is used so that the **Secure Socket Layer** ( **SSL** ) is
    used to assure that the data is private between client and server. The host name
    is `api.orchestrate.io` . Each request will have a URL based on this base service
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTTP headers for each request will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The `Accept` header shows what kind of response is expected. The `Content-Type`
    header shows what kind of document representation is being used for the content.
    These two headers direct the database to use JSON representation for object state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Authorization` header is how the API key is sent. The value for this header
    is a rather complex string. It''s easiest to build the encoded API key string
    code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This snippet of code will combine a username and password into a single string
    of characters, and then encode those characters into a stream of bytes using the
    `UTF-8` encoding scheme. The `base64` module creates a second stream of bytes.
    In this output stream, four bytes will contain the bits that comprise three input
    bytes. The bytes are chosen from a simplified alphabet. This value is then converted
    back into Unicode characters along with the keyword `'Basic '` . This value can
    be used with the `Authorization` header.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s easiest to work with a RESTful API by creating a `Request` object. The
    class is defined in the `urllib.request` module. The `Request` object combines
    the data, URL, and headers, and names a specific HTTP method. Here''s the code
    to create a `Request` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The request object includes four elements:'
  prefs: []
  type: TYPE_NORMAL
- en: The value of the `url` parameter is the base service URL plus the collection
    name, `/v0/eventlog` . The `v0` in the path is the version information which must
    be provided with each request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `headers` parameter includes the `Authorization` header which has the API
    Key which authorizes access to the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method of `POST` will create a new object in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `data` parameter is the document to save. We've converted a Python object
    to a string in JSON notation. Then encoded the Unicode characters into bytes using
    `UTF-8` encoding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seeing a typical response
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The processing involves sending the request and receiving a response. The `urlopen()`
    function accepts the `Request` object as an argument; this builds the request
    that''s transmitted to the database server. The response from the database server
    will include three elements:'
  prefs: []
  type: TYPE_NORMAL
- en: A status. This includes both a numeric code and a reason string. When creating
    a document, the expected response code is `201` and the string is `CREATED` .
    For many other requests, the code is `200` and the string is `OK` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The response will also have headers. For a creation request, these will include
    the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The `Content-Type` header tells us that the content is encoded in JSON. The
    `Location` header provides a URL that can be used to retrieve the object which
    is created. It also provides an `ETag` header, which is a hashed summary of the
    current state of the object; this helps to support caching local copies of an
    object. Other headers may be present; we've just shown `...` in the example.
  prefs: []
  type: TYPE_NORMAL
- en: The response may have a body. If present, this will be a JSON-encoded document
    (or documents) retrieved from the database. The body must be read with the `read()`
    method of the response. A body can be quite large; a `Content-Length` header provides
    the exact number of bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client class for database access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll define a simple class for database access. A class can provide context
    and status information for multiple related operations. When working with the
    Elastic database, an access class can create the request headers dictionary just
    once and reuse it in multiple requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the essence of a database client class. We''ll show this in several
    sections. First, the overall class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'This defines a class-level variable, `service` , with the scheme and hostname.
    The initialization method, `__init__()` , can build the headers that are used
    by the various database operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: This method takes the API key and creates a set of headers that relies on HTTP
    basic authorization. The password is not used by the orchestrate service. We've
    included it, however, because the username and password are used for the example
    unit test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: This function can combine a username and a password to create the value for
    the HTTP `Authorization` header. The `orchestrate.io` API uses an assigned API
    key as the username; the password is a zero-length string, `''` . The API key
    is assigned when someone signs up for their service. The free level of service
    allows a reasonable number of transactions and a comfortably small database.
  prefs: []
  type: TYPE_NORMAL
- en: We've included a unit test case in the form of a docstring. This provides evidence
    that the results are correct. The test case comes from the Wikipedia page on HTTP
    basic authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final part is a method to load one data item into the `eventlog` collection
    of the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This function builds a `Request` object with the four required pieces of information—the
    full URL, the HTTP headers, the method string, and the encoded data. In this case,
    the data is encoded as a JSON string, and the JSON string encoded into bytes using
    the `UTF-8` encoding scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating the `urlopen()` function sends the request and retrieves a response
    object. This object is used as a context manager. The `with` statement assures
    that the resources are released properly even if there is an exception raised
    during response processing.
  prefs: []
  type: TYPE_NORMAL
- en: A `POST` method should respond with a status of `201.` Any other status is a
    problem. In this code, the status is checked with an `assert` statement. It might
    be better to provide a message such as `Expected 201 status, got {}.format(response.status)`
    .
  prefs: []
  type: TYPE_NORMAL
- en: The headers are then examined to get the `Location` header. This provides a
    URL fragment for locating the object which was created.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create the database access module. This module will have the `ElasticClient`
    class definition. It will also have any additional definitions that this class
    needs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This recipe will use `unittest` and `doctest` to create a unified suite of
    tests. It will use the `Mock` class from `unittest.mock` , as well as `json` .
    Since this module is separate from the unit under test, it needs to import `ch11_r08_load`
    , which has the class definitions that will be tested:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the overall framework for a test case. We''ll fill in the `setUp()`
    and `runTest()` methods of this test below. The name shows that we''re given an
    instance of `ElasticClient` , when we invoke `load_eventlog()` , then a proper
    RESTful API request was made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The first part of the `setUp()` method is a mock context manager that provides
    responses similar to the `urlopen()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: When `urlopen()` is called, the return value is a response object which behaves
    like a context manager. The best way to mock this is to return a mock context
    manager. The mock context manager's `__enter__()` method does the real work to
    create a response object. In this case, the `side_effect` attribute identifies
    a helper function that will be called to prepare the result from calling the `__enter__()`
    method. The `self.create_response` has not been defined yet. We'll use a function,
    defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of the `setUp()` method is some mock data to be loaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: In a more complex test, we might want to simulate a large, iterable collection
    of documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `create_response()` helper method that builds response-like objects.
    The response objects can be complex, so we''ve defined a function to create them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This method uses `self.mock_urlopen.call_args` to examine the last call to this
    `Mock` object. This call's arguments are a tuple of positional argument values
    and keyword arguments. The first `[0]` index picks the positional argument value
    from the tuple. The second `[0]` index picks the first positional argument value.
    This will be the object to be loaded to the database. The value of the `hex()`
    function is a string that includes a `0x` prefix that we discard.
  prefs: []
  type: TYPE_NORMAL
- en: In a more complex test, it may be necessary for this method to keep a cache
    of objects loaded into the database to make more accurate database-like responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `runTest()` method makes a patch to the module under test. It locates the
    reference from `ch11_r08_load` to `urllib.request` and to the `urlopen()` function.
    This is replaced with the `mock_urlopen` replacement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: This test follows the `ElasticClient` requirements of first creating a client
    object. Instead of using an actual API key, this uses a username and password
    that will create a known value for the `Authorization` header. The result of the
    `load_eventlog()` is a response-like object that can be examined to see whether
    it has the proper values.
  prefs: []
  type: TYPE_NORMAL
- en: All of this interaction will be done through the mock objects. We can use the
    various assertions to confirm that a proper request object was created. The test
    examines four attributes of the request object and also checks to be sure that
    the context was used properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also define a `load_tests()` function to combine this `unittest` suite
    with any test examples found docstrings of `ch11_r08_load` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll provide the overall main program to run the complete suite.
    This makes it easy to run the test module as a standalone script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe combines a number of `unittest` and `doctest` features to create
    a sophisticated test case. The features include:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a context manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the side-effect feature to create a dynamic, stateful test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking a complex object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the load tests protocol to combine doctest and unittest cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at each of these features separately.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a context manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The context manager protocol wraps an object in an additional layer of indirection.
    See the *Reading and writing files with context managers* and *Using multiple
    contexts for reading and writing files* recipes for more information on this.
    The core features that must be mocked are the `__enter__()` and `__exit__()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pattern for mock context managers looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The context manager object has two attributes. The `__exit__()` will be called
    once. A return value of `True` will silence any exception. The return value of
    `None` or `False` will allow exceptions to propagate.
  prefs: []
  type: TYPE_NORMAL
- en: The `__enter__()` method returns the object which is assigned in the `with`
    statement. In this example, we used the `side_effect` attribute and provided a
    function so that a dynamic result can be computed.
  prefs: []
  type: TYPE_NORMAL
- en: A common alternative for the `__enter__()` method is to use a fixed `return_value`
    attribute and provide the same manager object each time. It's also possible to
    provide a sequence with `side_effect` ; in this case, each time the method is
    called, another object from the sequence is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dynamic, stateful test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In many cases, the test can use a static, fixed set of objects. The mock responses
    can be defined in the `setUp()` method. In some cases, however, an object's state
    may need to change during the operations of a complex test. In this case, the
    `side_effect` attribute of a `Mock` object can be used to track a state change.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the `side_effect` attribute used the `create_response()` method
    to build a dynamic response. A function referenced by `side_effect` can do anything;
    this can be used to update dynamic state information that is used to compute complex
    responses.
  prefs: []
  type: TYPE_NORMAL
- en: There's a fine line here. A complex test case can introduce its own bugs. It's
    generally a good idea to keep the test cases as simple as possible to avoid having
    to write `meta tests` to test the test cases.
  prefs: []
  type: TYPE_NORMAL
- en: For non-trivial tests, it's important to be sure that the test can actually
    fail. Some tests involve inadvertent tautologies. It's possible to create a contrived
    test that is as meaningful as `self.assertEqual(4, 2+2)` . To be sure the test
    actually uses the unit under test, it should fail when the code is missing or
    has a bug injected into it.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking a complex object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The response object from `urlopen()` has a large number of attributes and methods.
    For our unit test, we only needed to set a few of these features.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'This created a `Mock` object with two attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `status` attribute had a simple numeric value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getheaders` attribute used a `Mock` object with the `return_value` attribute
    to create a method function. This method function returned the dynamic `response_headers`
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of `response_headers` is a sequence of two-tuples that has *(key,
    value)* pairs. This representation of the response headers can be transformed
    into a dictionary very easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'The object is built like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: This sets three headers: `Location` , `ETag` , and `Content-Type` . Other headers
    may be needed, depending on the test case. It's important not to clutter the test
    case with headers that are not used. This kind of clutter can lead to bugs in
    the test itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The database id and location are based on the following calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: This uses `self.mock_urlopen.call_args` to examine the arguments provided to
    the test case. The value of the `call_args` attribute is a two-tuple with the
    positional and keyword argument values. The positional arguments are a tuple too.
    This means that `call_args[0]` is the positional argument and `call_args[0][0]`
    is the first positional argument. This will be the document that's loaded to the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Many Python objects have hash values. In this case, the object is expected to
    be a string created by the `json.dumps()` function. The hash value for this string
    is a large number. The hex value of that number will be a string with a `0x` prefix.
    We'll use the `[2:]` slice to ignore the prefix. For information on this, see
    the *Rewriting an immutable string* recipe in [Chapter 1](text00014.html#page
    "Chapter 1. Numbers, Strings, and Tuples") , *Numbers, Strings, and Tuples* .
  prefs: []
  type: TYPE_NORMAL
- en: Using the load_tests protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A complex module will include class and function definitions. The module as
    a whole needs a descriptive docstring. Each class and function needs a docstring.
    Each method within a class also needs a docstring. These will provide essential
    information about the module, class, function, and method.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, each docstring can include an example. The examples can be tested
    by the `doctest` module. See the *Using docstrings for testing* recipe for examples.
    We can combine the docstring example tests without more complex unit tests. See
    the *Combining unittest and doctest tests* recipe for more information on how
    to do this.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `unittest` module can be used to construct integration tests too. The idea
    of an integration test is to avoid mocks and actually use the real external service
    in a test mode. This can be slow or expensive; it's common to avoid integration
    testing until after all of the unit tests provide confidence that the software
    is likely to work.
  prefs: []
  type: TYPE_NORMAL
- en: We might, for example, create two applications with `orchestrate.io` —the real
    application and a test application. This will provide us with two API keys. The
    test key would be used so that the database can be reset to its initial state
    without creating problems for actual users of the real data.
  prefs: []
  type: TYPE_NORMAL
- en: We can control this using the `unittest` , `setUpModule()` , and `tearDownModule()`
    functions. The `setUpModule()` function is executed prior to all of the tests
    in a given module file. This is a handy way to set the database to a known state.
  prefs: []
  type: TYPE_NORMAL
- en: We can also remove the database with the `tearDownModule()` function. This can
    be handy for removing unneeded resources created by the test. It's sometimes more
    helpful to leave resources around for debugging purposes. For this reason, the
    `tearDownModule()` function may not be as useful as the `setUpModule()` function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Testing things that involve dates or times* and *Testing things that involve
    randomness* recipes show techniques.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reading complex formats using regular expressions* recipe in [Chapter 9](text00099.html#page
    "Chapter 9. Input/Output, Physical Format, and Logical Layout") , *Input/Output,
    Physical Format, and Logical Layout* , shows how to parse a complex log file.
    In the *Using multiple contexts for reading and writing files* recipe, the complex
    log records were written to a `CSV` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For information on chopping up strings to replace parts, see the *Rewriting
    an immutable string* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elements of this can be tested by the `doctest` module. See the *Using docstrings
    for testing* recipe for examples. It's also important to combine these tests with
    any doctests. See the *Combining unittest and doctest tests* recipe for more information
    on how to do this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
