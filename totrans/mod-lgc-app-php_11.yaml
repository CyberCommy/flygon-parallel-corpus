- en: Chapter 11. Extract Action Logic to Controllers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thus far, we have extracted our model domain logic and our view presentation
    logic. Only two kinds of logic remain in our page scripts:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Dependency logic, which uses the application settings to create objects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Action logic (sometimes called business logic) which uses those objects to perform
    the page actions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will extract a layer of `Controller` classes from our page
    scripts. These will handle the remaining action logic in our legacy application
    separately from our dependency-creation logic.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Embedded action logic
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For an example of embedded action logic mixed with dependency logic, we can
    look at the ending example code from the last chapter in [Appendix G](apg.xhtml
    "Appendix G. Code after Response View File"), *Code after Response View File*.
    Therein, we do a little setup work, then we check some conditions and call different
    parts of our domain `Transactions`, and at the end we put together a `Response`
    object to send our response to the client.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: As was the problem with mixed-in presentation logic, we cannot test the action
    logic separately from rest of the page script. Similarly, we cannot easily change
    the dependency creation logic to make the page script more testable.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: We solve the problem of embedded action logic as we did with embedded presentation
    logic. We must extract the action code to a class of its own to separate the various
    remaining concerns of our page script. This will also allow us to test the action
    logic independently from the rest of the application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The Extraction Process
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extracting the action logic from our page scripts should be a relatively easy
    task for us now. Because the domain layer has been extracted, along with the presentation
    layer, the action logic should be obvious. The work itself still rewards attention
    to detail, in that the main issue will be picking apart the dependency setup portions
    from the action logic itself.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the process is as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Find a page script where action logic is still mixed in with the rest of the
    code.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In that page script, rearrange the code so that all action logic is in its own
    central block. Spot check the rearranged code to make sure it still works properly.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the central block of action logic to a new `Controller` class, and modify
    the page script to use the new `Controller`. Spot check the page script with the
    *Controller* in place.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a unit test for the new `Controller` class and spot check again.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit the new code and tests, push them to the common repository, and notify
    QA.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find another page script with embedded action logic and start again; when all
    page scripts use `Controller` objects, we are done.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for Embedded Action Logic
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, we should be able to find action logic without having to use
    our project-wide search facility. Every page script in our legacy application
    probably has at least a little bit of action logic left in it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Rearrange the Page Script and Spot Check
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we have a candidate page script, we proceed to rearrange the code so that
    all setup and dependency-creation work is at the top, all the action logic is
    in the middle, and the `$response->send()` call is at the bottom. For our starting
    example here, we will use the code from the end of the last chapter as found in
    [Appendix G](apg.xhtml "Appendix G. Code after Response View File"), *Code after
    Response View File*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Identify Code Blocks
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we go to the very top of the script and place a `/* DEPENDENCY */` comment
    on the first line (or perhaps after the inclusion of a setup script). Then we
    go to the very end of the script, to the `$response->send()` line, and place a
    `/* FINISHED */` comment above it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Now we reach a point where we must use our professional judgment. On some line
    after the setup and dependency work in the page script, we will see that the code
    begins to perform some sort of action logic. Our assessment of just where this
    transition occurs may be somewhat arbitrary, since the action logic and setup
    logic are likely to still be intertwined. Even so, we must pick a point at which
    we believe the action logic really gets started, and place a `/* CONTROLLER */`
    comment there.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Move Code to Its Related Block
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we have identified these three blocks in the page script, we begin rearranging
    the code so that only setup and dependency-creation work occurs between `/* DEPENDENCY
    */` and `/* CONTROLLER */`, and only action logic occurs between `/* CONTROLLER
    */` and `/* FINISHED */`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: In general, we should avoid conditions or loops in the dependency block, and
    avoid object creation in the controller block. The code in the dependency block
    should only create objects, and the code in the controller block should only operate
    on objects that have been created in the dependency block.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Given our starting code in [Appendix G](apg.xhtml "Appendix G. Code after Response
    View File"), *Code after Response View File*, we can see the result of an example
    rearrangement in [Appendix H](aph.xhtml "Appendix H. Code after Controller Rearrangement"),
    *Code after Controller Rearrangement*. Of note, we moved the `$user_id` declaration
    down to the controller block, and we moved the `Response` object creation up to
    the dependency block. The original action logic in the central controller block
    remains otherwise unchanged.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Spot Check the Rearranged Code
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, after rearranging the page script, we need to spot check our changes
    to make sure everything still works properly. If we have characterization tests,
    we should run those. Otherwise, we should browse to or otherwise invoke the page
    script. If it does not work correctly, we need to undo and redo our rearrangement
    so that we fix whatever errors we have introduced.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: When our spot check runs are successful, we may wish to commit our changes so
    far. This will give us a known-working state to which we can revert if future
    changes go bad.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Extract a Controller Class
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have a rearranged page script that works properly, we can extract
    the central controller block to a class of its own. This is not difficult, but
    we will do it in several sub-steps to make sure everything goes smoothly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Pick a Class Name
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we can extract to a class, we need to pick a name for the class we will
    extract to.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: With our domain-layer classes, we chose the top-level namespace *Domain*. Because
    this is a controller layer, we will use the top-level namespace *Controller*.
    The namespace we use is not as important as consistently using the same namespace
    for all controllers. Personally, I prefer *Controller* because it is broad enough
    to encompass different kinds of controllers, such as Application Controller.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The class name within that namespace should reflect where the page script is
    in the URL hierarchy, with namespace separators where there are directory separators
    in the path. This approach makes it obvious what the original page script directory
    path was, and keeps the subdirectories organized nicely in the class structure.
    We also suffix the class name with `Page` to indicate it is a Page Controller.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the page script is at `/foo/bar/baz.php`, the class name should
    be `Controller\Foo\Bar\BazPage`. The class file itself would then be placed in
    our central classes directory under `classes/Controller/Foo/Bar/BazPage.php`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Create a Skeleton Class File
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we have a class name, we can create a skeleton class file for it. We add
    two empty methods as placeholders for later: the `__invoke()` method will receive
    the action logic from the page script, and the constructor will eventually receive
    dependencies for the class.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Why __invoke()?**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I enjoy co-opting the `__invoke()` magic method for this purpose,
    but you may wish to use `exec()` or some other appropriate term to indicate we
    are executing or otherwise running the controller. Whatever method name we choose,
    we should use it consistently.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Move the Action Logic and Spot Check
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we are ready to extract the action logic to our new `Controller` class.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: First, we cut the controller block from the page script, and paste it into the
    `__invoke()` method as-is. We add one line to the end of the action logic, `return
    $response`, to send the *Response* object back to the calling code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Next, we go back to the page script. In the place of the extracted action logic,
    we create an instance of our new `Controller` and call its `__invoke()` method,
    getting back a *Response* object.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: We should `always` use the same variable name for the *Controller* object in
    all of our page scripts. All the examples here will use the name `$controller`.
    This is not because the name `$controller` is special, but because this level
    of consistency will be very important in a later chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have successfully decoupled the action logic from the page
    script. However, this decoupling fundamentally breaks the action logic, because
    the *Controller* depends on variables from the page script.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, we begin a spot-check-and-modify cycle. We browse to or otherwise
    invoke the page script and discover that a particular variable is not available
    to the *Controller*. We add it to the `__invoke()` method signature, and spot
    check again. We continue adding variables to the `__invoke()` method until the
    *Controller* has everything it needs and our spot check runs become completely
    successful.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this part of the process, it would be best if we set `error_reporting(E_ALL)`.
    That way we will get a PHP notice for every uninitialized variable in the action
    logic.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Given our rearranged page script in [Appendix H](aph.xhtml "Appendix H. Code
    after Controller Rearrangement"), *Code after Controller Rearrangement*, the result
    of our initial extraction to a *Controller* can be seen in [Appendix I](api.xhtml
    "Appendix I. Code after Controller Extraction"), *Code after Controller Extraction*.
    It turns out that the extracted action logic needed four variables: `$request`,
    `$response`, `$user`, and `$article_transactions`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Convert Controller to Dependency Injection and Spot Check
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have a working block of action logic in the `__invoke()` method, we
    will convert the method parameters into constructor parameters so that the *Controller*
    can use dependency injection.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: First, we cut the `__invoke()` parameters and paste them as a whole into the
    `__construct()` parameters. We then edit the class definition and `__construct()`
    method to retain the parameters as properties.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Next, we modify the `__invoke()` method to use the class properties instead
    of the method parameters. That means prefixing each of the needed variables with
    `$this->`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Then, we go back to the page script. We cut the arguments to the `__invoke()`
    call, and paste them into the *Controller* instantiation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have converted the *Controller* to dependency injection, we need
    to spot check the page script again to make sure everything works properly. If
    it does not, we need to undo and redo our conversion until our tests pass.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can remove the `/* DEPENDENCY */`, `/* CONTROLLER */`, and
    `/* FINISHED */` comments. They have served their purpose and are no longer needed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Given the `__invoke()` usage in [Appendix I](api.xhtml "Appendix I. Code after
    Controller Extraction"), *Code after Controller Extraction*, we can see what converting
    the *Controller* to dependency injection looks like in [Appendix J](apj.xhtml
    "Appendix J. Code after Controller Dependency Injection"), *Code after Controller
    Dependency Injection*. We have moved the *Controller* `__invoke()` parameters
    up to `__construct()`, retained them as properties, used the new properties in
    the `__invoke()` method body, and modified the page script to pass the needed
    variables at `new` time instead of `__invoke()` time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a working page script, we may wish to commit our work yet again
    so that we have a known correct state to which we can revert later, if needed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Write a Controller Test
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though we have tested our page script, we need to write a unit test for
    our extracted *Controller* logic. When we write the test, we will need to inject
    all the needed dependencies into our *Controller*, preferably as test doubles
    like fakes or mocks so we can isolate the *Controller* from the rest of the system.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: When we make assertions, they should probably be against the *Response* object
    returned from the `__invoke()` method. We can use `getView()` to make sure the
    right view file is set, `getVars()` to inspect the variables to be used in the
    view, and `getLastCall()` to see if the final callable (if any) has been set properly.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Commit, Push, Notify QA
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we have a passing unit test, and our tests of the original page script
    also pass, we can commit our new code and tests. Then we push to the common repository
    and notify QA that we are ready for them to review our work.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Do ... While
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we go on to the next page script that has embedded action logic and begin
    the extraction process over again. When all of our page scripts use dependency-injected
    *Controller* objects, we are done.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Common Questions
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Can we pass parameters to the Controller method?
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the examples, we remove all parameters from the `__invoke()` method. However,
    sometimes we will want to pass a parameter to that method as last-minute information
    for the controller logic.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: In general, we should avoid doing so at this point in our modernization process.
    This is not because it is a poor practice, but because we need a very high level
    of consistency in our controller invocations for a later modernization step. The
    most-consistent thing is for there to be no `__invoke()` parameters at all.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: If we need to pass extra information to the *Controller*, we should do so via
    the constructor. This is especially the case when we are passing request values.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, instead of this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We could do this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `__invoke()` method body would then use `$this->request->get['item_id']`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Can a Controller have Multiple actions?
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the examples, our *Controller* objects perform a single action. However,
    it is often the case that a page controller encompasses multiple actions, such
    as both inserting and updating a database record.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Our first pass at extracting action logic from the page script should keep the
    code pretty much intact, making allowances for properties instead of local variables
    and so on. Once the code is in the class, though, it is perfectly reasonable to
    split the logic into separate action methods. Then the `__invoke()` method can
    become little more than a `switch` statement that picks the correct action method.
    If we do so, we should be sure to update our *Controller* tests, and continue
    to spot check the page script to make sure our changes do not break anything.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Note that if we create additional *Controller* action methods, we need to avoid
    calling them from our page script. For the sake of the consistency needed in a
    later modernization step, the `__invoke()` method should be the only *Controller*
    method our page script calls in its controller block.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: What If the Controller contains include Calls?
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately, as we go about rearranging a page script, we are likely to discover
    that we still have several `include` calls in the controller block. (Calls to
    `include` for setup and dependency purposes are not such a big deal, especially
    if they are the same in every page script.)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当我们重新排列页面脚本时，我们可能会发现我们的控制器块中仍然有几个`include`调用。（为设置和依赖目的而进行的`include`调用并不是什么大问题，特别是如果它们在每个页面脚本中都是相同的。）
- en: Having `include` calls in the controller block is an artifact of the include-oriented
    architecture with which our legacy application began. It is a particularly difficult
    problem to solve. We want to encapsulate action logic in classes, not in files
    that execute behavior the moment we `include` them.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器块中使用`include`调用是我们遗留应用开始时采用的基于包含的架构的遗留物。这是一个特别难以解决的问题。我们希望将动作逻辑封装在类中，而不是在我们`include`它们时立即执行行为的文件中。
- en: For now, we must submit ourselves to the idea that `include` calls in the controller
    block of our page scripts are ugly but necessary. We should avert our eyes if
    needed and copy them into the `Controller` class with the rest of the controller
    code from the page script.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们必须接受在页面脚本的控制器块中使用`include`调用是丑陋但必要的想法。如果需要的话，我们应该避开视线，并将它们与页面脚本中的其余控制器代码一起复制到`Controller`类中。
- en: As consolation, we will solve the problem of these embedded `include` calls
    in the next chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 作为安慰，我们将在下一章解决这些嵌入的`include`调用的问题。
- en: Review and next steps
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾和下一步
- en: 'The extraction of the action logic to a layer of *Controllers* completes a
    huge modernization goal for our legacy application. We now have a full Model View
    Controller system in place: a domain layer for models, a presentation layer for
    views, and a controller layer that connects the two.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将动作逻辑提取到*Controllers*层完成了我们遗留应用的一个巨大的现代化目标。现在我们已经建立了一个完整的模型视图控制器系统：模型的领域层，视图的表示层，以及连接两者的控制器层。
- en: We should feel very satisfied about our modernization progress. The code that
    remains in each page script is a shadow of its original self. Most of the logic
    is wiring code that creates a *Controller* with its dependencies. The remaining
    logic is the same across all page scripts; it invokes the *Controller* and sends
    the returned *Response* object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该对我们的现代化进展感到非常满意。每个页面脚本中剩下的代码都是其原始形式的阴影。大部分逻辑是创建带有其依赖关系的*Controller*的连接代码。剩下的逻辑在所有页面脚本中都是相同的；它调用*Controller*并发送返回的*Response*对象。
- en: However, there is a major legacy artifact for us to deal with. To finish a full
    extraction and encapsulation of controller logic, we need to remove any remaining
    `include` calls embedded in our *Controller* classes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要处理一个重要的遗留物件。为了完成对控制器逻辑的完全提取和封装，我们需要移除在我们的*Controller*类中嵌入的任何剩余的`include`调用。
