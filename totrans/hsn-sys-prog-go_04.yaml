- en: An Overview of Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will provide an overview of the Go language and its basic functionality.
    We will provide a short explanation of the language and its features, which we
    will elaborate on in more detail in the following chapters. This will help us
    to understand Go better while we're using all its features and applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Features of the language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages and imports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic types, interfaces, and user-defined types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables and functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From this chapter onward, you will need Go installed on your machine. Follow
    these steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the latest version of Go from [https://golang.org/dl/](https://golang.org/dl/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract it with `tar -C /usr/local -xzf go$VERSION.$OS-$ARCH.tar.gz`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add it to `PATH` with `export PATH=$PATH:/usr/local/go/bin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that Go is installed with `go version`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the export statement in your `.profile` to add it automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also change the `GOPATH` variable (the default one is `~/go`) if you
    want to use a different directory for your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I also recommend installing Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))
    with its vscode-go ([https://github.com/Microsoft/vscode-go](https://github.com/Microsoft/vscode-go))
    extension, which contains a helper that will install all the tools that are needed
    to improve the Go development experience.
  prefs: []
  type: TYPE_NORMAL
- en: Language features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go is a modern server language with great concurrency primitives and a memory
    system that is mostly automated. It is considered by some to be a successor to
    C, and it manages to do so in many scenarios because it's performant, has an extensive
    standard library, and has a great community that provides many third-party libraries
    which cover, extend, and improve its functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: History of Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go was created in 2007 in order to try and address Google's engineering problems,
    and was publicly announced in 2009, reaching version 1.0 in 2012\. The major version
    is still the same (version 1), while the minor version grows (version 1.1, 1.2,
    and so on) together with its functionalities. This is done to keep Go's promise
    of compatibility for all major versions. A draft for two new features (generics
    and error handling), which will probably be included in version 2.0, were presented
    in 2018.
  prefs: []
  type: TYPE_NORMAL
- en: 'The minds behind Go are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Robert Griesemer**: A Google researcher who worked on many projects, including
    V8 JavaScript engine and design, and the implementation of Sawzall.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rob Pike**: A member of the Unix team, the Plan 9 and Inferno OS development
    team, and the Limbo programming language design team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ken Thompson**: A pioneer of computer science, the designer of the original
    Unix, and inventor of B (direct predecessor of C). Ken was also one of the creators
    and early developers of the Plan 9 operating system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strengths and weaknesses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go is a very opinionated language; some people love it while some people hate
    it, mostly due to some of its design choices. Some of the features that have not
    been well received are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Verbose error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lack of generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing dependency and version management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two points will be addressed with the next major version, while the
    latter was addressed by the community first (godep, glide, and govendor) and by
    Google itself with dep for the dependencies, and by gopkg.in ([http://labix.org/gopkg.in](http://labix.org/gopkg.in))) in
    terms of version management.
  prefs: []
  type: TYPE_NORMAL
- en: 'The strengths of the language are countless:'
  prefs: []
  type: TYPE_NORMAL
- en: It's a statically typed language, with all the advantages that this brings,
    like static type checking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not require an **integrated development environment** (**IDE**), even
    if it supports many of them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard library is really impressive, and it could be the only dependency
    of many projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has concurrency primitives (channels and goroutines), which hides the hardest
    parts of writing asynchronous code that are both efficient and safe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It comes with a formatting tool, `gofmt`, that unifies the format of Go code,
    making other people's code look really familiar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It produces binaries, with no dependencies, making deployments fast and easy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's minimalistic and has a few keywords, and the code is really easy to read
    and understand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's duck typed, with implicit interface definition (*if it walks like a duck,
    swims like a duck, and quacks like a duck, then it probably is a duck*). This
    comes in very handy when testing a specific function of a system because it can
    be mocked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is cross platform, meaning that it's able to produce binaries for architecture
    and OS that are different from the hosting ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a huge amount of third-party packages and so it leaves very little
    behind in terms of functionality. Each package that's hosted on a public repository
    is indexed and searchable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s see how Go code is organized. The `GOPATH` environment variable determines
    where the code resides. There are three subdirectories inside this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src` contains all the source code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pkg` contains compiled packages, which are divided into architecture/OS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bin` contains the compiled binaries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The path under the source folder corresponds to the name of the package (`$GOPATH/src/my/package/name`
    would be `my/package/name`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `go get` command makes it possible to fetch and compile packages using
    it. Go get calls to `http://package_name?go-get=1` and if it finds the `go-import` meta
    tag, it uses this to fetch the package. The tag should contain the package name,
    the VCS that was used, and the repository URL, all separated by a space. Let''s
    take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After `go get` downloads a package, it tries to do the same for the other packages
    it can't resolve recursively until all the necessary source code is available.
  prefs: []
  type: TYPE_NORMAL
- en: Each file starts with a package definition, that is, `package package_name`,
    that needs to be the same for all the files in a directory. If the package produces
    a binary, the package is `main`.
  prefs: []
  type: TYPE_NORMAL
- en: Imports and exporting symbols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The package declaration is followed by a series of `import` statements that
    specify the packages that are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Importing packages that are not used (unless they are ignored) is a compilation
    error, which is why the Go formatting tool, `gofmt`, removes unused packages.
    There are experimental or community tools like goimports ([https://godoc.org/golang.org/x/tools/cmd/goimports](https://godoc.org/golang.org/x/tools/cmd/goimports)) or goreturns
    ([https://github.com/sqs/goreturns](https://github.com/sqs/goreturns)) that also
    add missing imports to a Go file. It's important to avoid having circular dependencies
    because they will not compile.
  prefs: []
  type: TYPE_NORMAL
- en: Since circular dependencies are not allowed, the packages need to be designed
    differently to other languages. In order to break the circular dependency, it
    is good practice to export functionalities from a package or replace the dependency
    with an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Go reduces all the symbol visibility to a binary model – exported and not exported –
    unlike many other languages, which have intermediate levels. For each package, all
    the symbols starting with a capital letter are exported, while everything else
    is used only inside the package. The exported values can also be used by other
    packages, while the unexported ones can only be used in the package itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'An exception is made if one of the package path elements is internal (for example, `my/package/internal/pdf`).
    This limits itself and its subpackages to be imported only by the nearby packages
    (for example, `my/package`). This is useful if there are a lot of unexported symbols
    and you want to break them down into subpackages, while preventing other packages
    from using it, making basically private subpackages. Take a look at the following
    list of internal packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`my/package/internal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`my/package/internal/numbers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`my/package/internal/strings`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These can only be used by `my/package`, and cannot be imported by any other
    package, including `my`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The import can have different forms. The standard import form is the complete
    package name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A named import replaces the package name with a custom name, which must be
    used when referencing the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The same package import makes the symbol available with no namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Ignored imports are used to import packages without you having to use them.
    This makes it possible to execute the `init` function of the package without referencing
    the package in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Type system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go type system defines a series of basic types, including bytes, strings
    and buffers, composite types like slices or maps, and custom types that have been
    defined by the application.
  prefs: []
  type: TYPE_NORMAL
- en: Basic types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are Go''s basic types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Category** | **Types** |'
  prefs: []
  type: TYPE_TB
- en: '| String | `string` |'
  prefs: []
  type: TYPE_TB
- en: '| Boolean | `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| Integer | `int`, `int8`, `int16`, `int32`, and `int64` |'
  prefs: []
  type: TYPE_TB
- en: '| Unsigned integer | `uint`,  `uint8`, `uint16`, `uint32`, and `uint64` |'
  prefs: []
  type: TYPE_TB
- en: '| Pointer integer | `uinptr` |'
  prefs: []
  type: TYPE_TB
- en: '| Floating pointer | `float32` and `float64` |'
  prefs: []
  type: TYPE_TB
- en: '| Complex number | `complex64` and `complex128` |'
  prefs: []
  type: TYPE_TB
- en: The number of bits of `int`, `uint`, and `uiptr` depends on the architecture
    (for example, 32 bits for x86, 64 bits for x86_64).
  prefs: []
  type: TYPE_NORMAL
- en: Composite types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Beside the basic types, there are others, which are known as composite types.
    These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| Pointer | The address in the memory of a variable | `*int` |'
  prefs: []
  type: TYPE_TB
- en: '| Array | A container of the element of the same type with a fixed length |
    `[2]int` |'
  prefs: []
  type: TYPE_TB
- en: '| Slice | Contiguous segment of an array | `[]int` |'
  prefs: []
  type: TYPE_TB
- en: '| Map | Dictionary or associative array | `map[int]int` |'
  prefs: []
  type: TYPE_TB
- en: '| Struct | A collection of fields that can have different types | `struct{
    value int }` |'
  prefs: []
  type: TYPE_TB
- en: '| Function | A set of functions with the same parameters and output | `func(int,
    int) int` |'
  prefs: []
  type: TYPE_TB
- en: '| Channel | Type pipes that are used for the communication of elements of the
    same type | `chan int` |'
  prefs: []
  type: TYPE_TB
- en: '| Interface | A specific collection of methods, with an underlying value that
    supports them | `interface{}` |'
  prefs: []
  type: TYPE_TB
- en: The empty interface, `interface{}`, is a generic type that can contain any value.
    Since this interface has no requirements (methods), it can be satisfied by any
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interfaces, pointers, slices, functions, channels, and maps can have a void
    value, which is represented in Go by `nil`:'
  prefs: []
  type: TYPE_NORMAL
- en: Pointers are self-explanatory; they are not referring to any variable address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interface's underlying value can be empty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other pointer types, like slices or channels, can be empty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom-defined types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A package can define its own types by using the `type defined definition` expression,
    where definition is a type that shares a defined memory representation. Custom
    types can be defined by basic types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'They can also be defined by composite types like slices, maps, or pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'They can also be used in combination with other custom types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The main uses of custom types are to define methods and to make the type specific
    for a scope, like defining a `string` type called `Message`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interface definitions work in a different way. They can be defined by specifying
    a series of different methods, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'They can also be a composition of other interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, they can be a combination of the two interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Variables and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've looked at types, we'll take a look at how we can instantiate
    different types in the language. We'll see how variables and constants work first,
    and then we'll talk about functions and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Handling variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables represent mapping to the content of a portion of contiguous memory.
    They have a type that defines how much this memory extends, and a value that specifies
    what's in the memory. Type can be basic, composite, or custom, and its value can
    be initialized with their zero-value by a declaration, or with another value by
    assignment.
  prefs: []
  type: TYPE_NORMAL
- en: Declaration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The zero value declaration for a variable is done using the `var` keyword and
    by specifying the name and type; for example, `var a int`. This could be counter-intuitive
    for a person that comes from another language, like Java, where type and name
    order is inverted, but it's actually more human readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `var a int` example describes a variable (`var`) with a name, `a`, that
    is an integer (`int`). This kind of expression creates a new variable with a zero-value
    for the selected type:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Zero value** |'
  prefs: []
  type: TYPE_TB
- en: '| Numerical types (`int`, `uint`, and `float` types) | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| Strings (`string` types) | `""` |'
  prefs: []
  type: TYPE_TB
- en: '| Booleans | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| Pointers, interfaces, slices, maps, and channels | `nil` |'
  prefs: []
  type: TYPE_TB
- en: 'The other way of initiating a variable is by assignment, which can have an
    inferred or specific type. An inferred type is achieved with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The variable name, followed by the `:=` operator and the value (for example, `a
    := 1`), also called **short declaration**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `var` keyword, followed by the name, the `=` operator, and a value (for
    example, `var a = 1`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that these two methods are almost equivalent, and redundant, but the Go
    team decided to keep them both for the sake of the compatibility promise of Go
    1\. The main difference in terms of the short declaration is that the type cannot
    be specified and it's inferred by the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'An assignment with a specific type is made with a declaration, followed by
    an equals sign and the value. This is very useful if the declared type is an interface,
    or if the type that''s inferred is incorrect. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Some types need to use built-in functions so that they can be initialized correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '`new` makes it possible to create a pointer of a certain type while already
    allocating some space for the underlying variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`make` initializes slices, maps, and channels:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slices need an extra argument for the size, and an optional one for the capacity
    of the underlying array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maps can have one argument for their initial capacity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Channels can also have one argument for its capacity. They are unlike maps,
    which cannot change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The initialization of a type using a built-in function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already saw the assignment operation, which gives a new value to a variable
    using the `=` operator. Let''s take a look at few more operators:'
  prefs: []
  type: TYPE_NORMAL
- en: There are the comparison operators, `==` and `!=`, which compare two values
    and return a Boolean.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some mathematical operations that can be executed on all numerical
    variables of the same types, that is, `+`, `-`, `*`, and `/`. The sum operation
    is also used for concatenating strings. `++` and `--` are shorthand for incrementing
    or decrementing a number by one. `+=`, `-=`, `*=`, and `/=` execute the operation
    before the equals sign between what's before and what's after the operator and
    assigns it to the variable on the left. These four operations produce a value
    of the same type of the variables involved; there are also other comparison operators
    that are specific to numbers: `<`, `<=`, `>`, and `>=`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some operations are exclusive for integers and produce other integers: `%,` , `&`,
    `|`, `^`, `&^`, `<<`, and `>>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Others are just for Booleans and produce another Boolean: `&&`, `||`, and `!`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One operator is channel only, `<-`, and it's used to receive values from or
    send them to a channel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For all non-pointer variables, it is also possible to use `&`, the reference
    operator, to obtain the variable address that can be assigned to a pointer variable.
    The `*` operator makes it possible to execute a dereference operation on a pointer
    and obtain the value of the variable indicated by it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Operator** | **Name** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| `=` | Assignment | Assigns the value to a variable | `a = 10` |'
  prefs: []
  type: TYPE_TB
- en: '| `:=` | Declaration and assignment | Declares a variables and assigns a value
    to it | `a := 0` |'
  prefs: []
  type: TYPE_TB
- en: '| `==` | Equals | Compares two variables, returns a Boolean if they are the
    same | `a == b` |'
  prefs: []
  type: TYPE_TB
- en: '| `!=` | Not equals | Compares two variables, returns a Boolean if they are
    different | `a != b` |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | Plus | Sum between the same numerical type | `a + b` |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | Minus | Difference between the same numerical type | `a - b` |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Times | Multiplication between the same numerical type | `a * b` |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | Divided | Division between the same numerical type | `a / b` |'
  prefs: []
  type: TYPE_TB
- en: '| `%` | Modulo | Remainder after division of the same numerical type | `a %
    b` |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | AND | Bit-wise AND | `a & b` |'
  prefs: []
  type: TYPE_TB
- en: '| `&^` | Bit clear | Bit clear | `a &^ b` |'
  prefs: []
  type: TYPE_TB
- en: '| `<<` | Left shift | Bit shift to the left | `a << b` |'
  prefs: []
  type: TYPE_TB
- en: '| `>>` | Right shift | Bit shift to the right | `a >> b` |'
  prefs: []
  type: TYPE_TB
- en: '| `&&` | AND | Boolean AND | `a && b` |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;&#124;` | OR | Boolean OR | `a &#124;&#124; b` |'
  prefs: []
  type: TYPE_TB
- en: '| `!` | NOT | Boolean NOT | `!a` |'
  prefs: []
  type: TYPE_TB
- en: '| `<-` | Receive | Receive from a channel | `<-a` |'
  prefs: []
  type: TYPE_TB
- en: '| `->` | Send | Send to a channel | `a <- b` |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | Reference | Returns the pointer to a variable | `&a` |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Dereference | Returns the content of a pointer | `*a` |'
  prefs: []
  type: TYPE_TB
- en: Casting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Converting a type into another type is an operation called **casting**, which
    works slightly differently for interfaces and concrete types:'
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces can be casted to a concrete type that implements it. This conversion
    can return a second value (a Boolean) and show whether the conversion was successful
    or not. If the Boolean variable is omitted, the application will panic on a failed
    casting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With concrete types, casting can happen between types that have the same memory
    structure, or it can happen between numerical types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a special type of conditional operator for casting called **type switch**
    which allows an application to attempt multiple casts at once. The following is
    an example of using `interface{}` to check out the underlying value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The variables have a scope or visibility that is also connected to its lifetime.
    This can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Package**: The variable is visible in all the packages; if the variable is
    exported, it is also visible from other packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Function**: The variable is visible inside the function that declares it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Control**: The variable is visible inside the block in which it''s defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The visibility goes down, going from package to block. Since blocks can be nested,
    outer blocks don't have visibility over the variables of inner blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two variables in the same scope cannot have the same name, but a variable of
    an inner scope can reuse an identifier. When this happens, the outer variable
    is not visible in the inner scope – this is called **shadowing**, and it needs
    to be kept in mind in order to avoid issues that are hard to identify, such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go doesn''t have immutability for its variables, but defines another type of
    immutable value called constant. This is defined by the `const` keyword (instead
    of `var`), and they are values that cannot change. These values can be base types
    and custom types, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Numeric (integer, `float`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The value that''s specified doesn''t have a type when it''s assigned to a variable.
    There''s an automatic conversion of both numeric types and string-based types,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Numerical constants are very useful for mathematical operations because they
    are just regular numbers, so they can be used with any numerical variable type.
  prefs: []
  type: TYPE_NORMAL
- en: Functions and methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions in Go are identified by the `func` keyword, followed by an identifier,
    eventual arguments, and return values. Functions in Go can return more than one
    value at a time. The combination of arguments and returned types is referred to
    as a **signature**, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The part between brackets is the function body, and the `return` statement can
    be used inside it for an early interruption of the function. If the function returns
    values, then the return statement must return values of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `return` values can be named in the signature; they are zero value variables
    and if the `return` statement does not specify other values, these values are
    the ones that are returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions are first-class types in Go and they can also be assigned to variables,
    with each signature representing a different type. They can also be anonymous;
    in this case, they are called **closures**. Once a variable is initialized with
    a function, the same variable can be reassigned with another function with the
    same signature. Here''s an example of assigning a closure to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The functions that are declared by an interface are referred to as methods and
    they can be implemented by custom types. The method implementation looks like
    a function, with the exception being that the name is preceded by a single parameter
    of the implementing type. This is just syntactic sugar – the method definition
    creates a function under the hood, which takes an extra parameter, that is, the
    type that implements the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This syntax makes it possible to define the same method for different types,
    each of which will act as a namespace for the function declaration. In this way,
    it is possible to call a method in two different ways, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s important to note that a type and its pointer share the same namespace,
    so the same method can be implemented just for one of them. The same method cannot
    be defined for both the type and for its pointer, since declaring the method twice
    (for a type and its pointer) will produce a compile error (method redeclared). Methods
    cannot be defined for interfaces, only for concrete types, but interfaces can
    be used in composite types, including function parameters and return values, as
    we can see in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The built-in package already defines an interface that is used all over the
    standard library and in all the packages that are available online – the `error` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that whatever type has an `Error() string` method can be used as
    an error, and each package can define its error types according to its needs.
    This can be used to concisely carry information about the error. In this example,
    we are defining `ErrKey`, which is specifying that a `string` key was not found.
    We don''t need anything else besides the key to represent our error, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Values and pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Go, everything is passed by a value, so when a function or method is invoked,
    a copy of the variable is made in the stack. This implies that changes that are
    made to the value are not reflected outside of the called function. Even slices,
    maps, and other reference types are passed by value, but since their internal
    structure contains pointers, they act as if they were passed by reference. If
    a method is defined for a type, it cannot be defined for its pointer and vice
    versa. The following example has been used to check that the value is updated
    only inside the method, and that the change does not reflect the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In order to change the original variable, the argument must be a pointer to
    the variable itself – the pointer will be copied, but it will reference the same
    memory area, making it possible to change its value. Note that assigning another
    value pointer, instead of its content, doesn't change what the original pointer
    refers to because it is a copy.
  prefs: []
  type: TYPE_NORMAL
- en: If we use a method for the type instead of its pointer, we won't see the changes
    being propagated outside the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we are using a value receiver. This makes the `User` value
    in the `Birthday` method a copy of the `User` value in `main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/hnUldHLkFJY](https://play.golang.org/p/hnUldHLkFJY).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the change is applied to the copy, the original value is left intact,
    as we can see from the second print statement. If we want to change the value
    in the original object, we have to use the pointer receiver so that the one that''s
    been copied will be the pointer and the changes will be made to the underlying
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/JvnaQL9R7U5](https://play.golang.org/p/JvnaQL9R7U5).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that using the pointer receiver allows us to change the underlying
    value, and that we can change one field of the `struct` or replace the whole `struct`
    itself, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/3ugBEZqAood](https://play.golang.org/p/3ugBEZqAood).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to change the value of the pointer instead of the underlying one,
    we will edit a new object that is not related to the one that was created in `main`,
    and the changes will not propagate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/m8u2clKTqEU](https://play.golang.org/p/m8u2clKTqEU).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some types in Go are automatically passed by reference. This happens because
    these types are defined internally as structs that contain a pointer. This creates
    a list of the types, along with their internal definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Types** | **Internal definitions** |'
  prefs: []
  type: TYPE_TB
- en: '| `map` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `slice` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `channel` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding flow control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to control the flow of an application, Go offers different tools – some
    statements like `if`/`else`, `switch`, and `for` are used in sequential scenarios,
    whereas others like `go` and `select` are used in concurrent ones.
  prefs: []
  type: TYPE_NORMAL
- en: Condition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `if` statement verifies a binary condition and executes the code inside
    the `if` block when the condition is `true`. When an `else` block is present,
    it''s executed when the condition is `false`. This statement also allows a short
    declaration before the condition, separated by a `;`. This condition can be chained
    with an `else if` statement, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The other condition statement is `switch`. This allows a short declaration,
    like `if`, and this is followed by an expression. The value of such an expression
    can be of any type (not just Boolean), and it's evaluated against a series of
    `case` statements, each one followed by a block of code. The first statement that
    matches the expression, if the `switch` and `case` condition are equal, has its
    block executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a `break` statement is present in the case where the block execution is
    interrupted, but  there''s a `fallthrough`, the code inside the following `case`
    block is executed. A special case called `default` can be used to execute its
    code if no case is satisfied, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Looping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `for` statement is the only looping statement in Go. This requires that
    you specify three expressions, separated by `;`:'
  prefs: []
  type: TYPE_NORMAL
- en: A short declaration or an assignment to an existing variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A condition to verify before each iteration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An operation to execute at the end of the iteration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these statements can be optional, and the absence of a condition means
    that it is always `true`. A `break` statement interrupts the loop''s execution,
    while `continue` skips the current iteration and proceeds with the next one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When a combination of `switch` and `for` are nested, the `continue` and `break`
    statements refer to the inner flow control statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'An outer loop or condition can be labelled using a `name:` expression, whereas
    the name is its identifier, and both `loop` and `continue` can be followed by
    the name in order to specify where to intervene, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Exploring built-in functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already listed some of the built-in functions that are used to initialize
    some variables, that is, `make` and `new`. Now, let''s go over each function and
    check out what they do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func append(slice []Type, elems ...Type) []Type`: This function appends elements
    to the end of a slice. If the underlying array is full, it reallocates the content
    to a bigger slice before appending.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func cap(v Type) int`: Returns the number elements of an array, or of the
    underlying array if the argument is a slice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func close(c chan<- Type)`: Closes a channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func complex(r, i FloatType) ComplexType`: Given two floating points, this
    returns a complex number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func copy(dst, src []Type) int`: Copies elements from a slice to another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func delete(m map[Type]Type1, key Type)`: Removes an entry from a map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func imag(c ComplexType) FloatType`: Returns the imaginary part of a complex
    number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func len(v Type) int`: Returns the length of an array, slice, map, string,
    or channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func make(t Type, size ...IntegerType) Type`: Creates a new slice, map, or
    channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func new(Type) *Type`: Returns a pointer to a variable of the specified type,
    initialized with a zero value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func panic(v interface{})`: Stops the execution of the current goroutine and,
    if it''s not intercepted, the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func print(args ...Type)`: Writes the arguments to the standard error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func println(args ...Type)`: Writes the arguments to the standard error and
    adds a new line at the end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func real(c ComplexType) FloatType`: Returns the real part of a complex number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func recover() interface{}`: Stops a panic sequence and captures the panic
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defer, panic, and recover
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A very important keyword that hides a lot of complexity but makes it possible
    to execute many operations easily is `defer`. This is applied to a function, method,
    or closure execution and makes the function it precedes execute before the function
    returns. A common and very useful usage is closing resources. After opening the
    resource successfully, a deferred close statement will ensure that it is executed
    independently of the exit point, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: During a function's lifetime, all the deferred statements are added to a list
    and before exiting, they are executed in reverse order, from the last to the first `defer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These statements are executed even when there''s a panic, which is why a deferred
    function with a `recover` call can be used to intercept a panic in the respective
    goroutine and avoid the panic that would kill the application otherwise. As well
    as a manual call to the `panic` function, there is a set of operations that will
    cause a panic, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a negative or non-existent array/slice index (index out of range)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dividing an integer by `0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending to a closed channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dereferencing on a `nil` pointer (`nil` pointer*)*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a recursive function call that fills the stack (stack overflow)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Panic should be used for errors that are not recoverable, which is why errors
    are just values in Go. Recovering a panic should be just an attempt to do something
    with that error before exiting the application. If an unexpected problem occurs,
    it's because it hasn't been handled correctly or some checks are missing. This
    represents a serious issue that needs to be dealt with, and the program needs
    to change, which is why it should be intercepted and dismissed.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency is so central to Go that two of its fundamental tools are just keywords
    – `chan` and `go`. This is a very clever way of hiding the complexity of a well-designed
    and implemented concurrency model that is easy to use and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding channels and goroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Channels are made for communicating, which is why Go''s mantra is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Do not communicate by sharing memory, share memory by communicating."'
  prefs: []
  type: TYPE_NORMAL
- en: A channel is made for sharing data, and it usually connects two or more execution
    threads in an application, which makes it possible to send and receive data without
    worrying about data safety. Go has a lightweight implementation of a thread that
    is managed by the runtime instead of the operating system, and the best way to
    make them communicate is through the use of channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a new goroutine is pretty easy – you just need to use the `go` operator,
    followed by a function execution. This includes method calls and closures. If
    the function has any arguments, they will be evaluated before the routine starts.
    Once it starts, there is no guarantee that changes to variables from an outer
    scope will be synchronized if you don''t use channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We already saw how to create a new channel with the `make` function. If a channel
    is unbuffered (`0` capacity), sending to the channel is a blocking operation that
    will wait for another goroutine to receive data from the same channel in order
    to unlock it. The capacity shows how many messages the channel is capable of holding
    before sending the next becomes a blocking operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to send to a channel, we can use the `<-` operator. If the channel
    is on the left of the operator, it is a send operation, and if it''s on the right,
    it is a receive operation. The value that''s received from a channel can be assigned
    to a variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Closing a channel can be done with the `close()` function. This operation means
    that no more values can be sent to the channel. This is why it is usually the
    responsibility of the sender. Sending to a close channel will cause a `panic` anyway,
    which is why it should be done by the receiver. Also, when receiving from a channel,
    a second Boolean variable can be specified in the assignment. This will be true
    if the channel is still open so that the receiver knows when a channel has been
    closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a special control statement called `select` which works exactly like `switch`,
    but with only operations on channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Understanding memory management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go is garbage collected; it manages its own memory with a computational cost.
    Writing an efficient application requires knowledge of its memory model and internals
    in order to reduce the garbage collector's work and increase general performance.
  prefs: []
  type: TYPE_NORMAL
- en: Stack and heap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory is arranged into two main areas – stack and heap. There is a stack for
    the application entry point function (`main`), and additional stacks are created
    with each goroutine, which are stored in the heap. The **stack** is, as its name
    suggests, a memory portion that grows with each function call, and shrinks when
    the function returns. The **heap** is made of a series of regions of memory that
    are dynamically allocated, and their lifetime is not defined a priori as the items
    in the stack; heap space can be allocated and freed at any time.
  prefs: []
  type: TYPE_NORMAL
- en: All the variables that outlive the function where they are defined are stored
    in the heap, such as a returned pointer. The compiler uses a process called **escape
    analysis** to check which variables go on the heap. This can be verified with
    the `go tool compile -m` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables in the stack come and go with the function''s execution. Let''s take
    a look at a practical example of how the stack works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We have the `main` function calling a function called `f1`, which calls another
    function called `f2`. Then, the same function is called directly by `main`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `main` function starts, the stack grows with the variables that are
    being used. In memory, this would look something like the following table, where
    each column represents the pseudo state of the stack, which it represents how
    the stack changes in time, going from left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `main` invoked | `f1` invoked | `f2` invoked | `f2` return | `f1` returns
    | `f2` invoked | `f2` returns | `main` returns |'
  prefs: []
  type: TYPE_TB
- en: '| `main()` | `main()` | `main()` | `main()` | `main()` | `main()` | `main()`
    | // empty |'
  prefs: []
  type: TYPE_TB
- en: '| `a = 0` | `a = 0` | `a = 0` | `a = 0` | `a = 0` | `a = 0` | `a = 0` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `b = 1` | `b = 1` | `b = 1` | `b = 1` | `b = 1` | `b = 1` | `b = 1` |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `f1()` | `f1()` | `f1()` |  | `f2()` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `a = 0` | `a = 0` | `a = 0` |  | `c = 0` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `b = 1` | `b = 1` | `b = 1` |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `c = 1` | `c = 1` | `c = 1` |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `f2()` |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `c = 1` |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: When `f1` gets called, the stack grows again by copying the `a` and `b` variables
    in the new part and adding the new variable, `c`. The same thing happens for `f2`.
    When `f2` returns, the stack shrinks by getting rid of the function and its variables,
    which is what happens when `f1` finishes. When `f2` is called directly, it grows
    again by recycling the same memory part that was used for `f1`.
  prefs: []
  type: TYPE_NORMAL
- en: The garbage collector is responsible for cleaning up the unreferenced values
    in the heap, so avoiding storing data in it is a good way of lowering the work
    of the **garbage collector** (**GC**), which causes a slight decrease in performance
    in the app when the GC is running.
  prefs: []
  type: TYPE_NORMAL
- en: The history of GC in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GC is responsible for freeing the areas of the heap that are not referenced
    in any stack. This was originally written in C and had a *stop the world* behavior.
    The program stopped for a fraction of time, freed the memory, and then resumed
    its flow.
  prefs: []
  type: TYPE_NORMAL
- en: Go 1.4 started the process of converting the runtime, including the garbage
    collector, into Go. Translating these parts in Go lays the foundations for easier
    optimization that already begun with version 1.5, where the GC became much faster
    and could run concurrently with other goroutines.
  prefs: []
  type: TYPE_NORMAL
- en: From that point on, there has been a lot of optimization and improvement of
    the process, which managed to reduce the GC time by several orders of magnitude.
  prefs: []
  type: TYPE_NORMAL
- en: Building and compiling programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have had a quick overview of all the language features and capabilities, we
    can focus on how to run and build our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Install
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Go, there are different commands to build packages and applications. The
    first one is `go install`, followed by a path or a package name, which creates
    a compiled version of the packages in the `pkg` directory inside `$GOPATH`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the compiled packages are organized by the operating system and architecture,
    which are stored in the `$GOOS` and `$GOARCH` environment variables. These settings
    are visible by using the `go env` command, together with other information, like
    compilation flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'For the current architecture and operating system, all the compiled packages
    will be placed in the `$GOOS_$GOARCH` subdirectory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: If the package name is `main` and it contains a `main` function, the command
    will produce an executable binary file, which will be stored in `$GOPATH/bin`. If
    a package is already installed and the source file didn't change, it will not
    be compiled again, which will speed up build time significantly after the first
    compile.
  prefs: []
  type: TYPE_NORMAL
- en: Build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A binary can also be built in a specific location using the `go build` command.
    A specific output file can be defined using the `-o` flag, otherwise it will be
    built in the working directory, using the package name as a binary name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When executing the `go build` command, the argument can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A package as a relative path (like `go build .` for the current package or `go
    build ../name`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A package as an absolute path (`go build some/package`) that will be looked
    up in`$GOPATH`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A specific Go source file (`go build main.go`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latter case allows you to build a file that is outside `$GOPATH` and will
    ignore any other source file in the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: Run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a third command that works similarly to build, but also runs the binary.
    It creates the binary using the `build` command using a temporary directory as
    output, and executes the binary on the fly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Run can be used over build or install when you're making changes to the source
    code. If the code is the same, it is probably better to build it once and execute
    it many times.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at some of the history of Go and its current pros
    and cons. After understanding the namespace by looking at how the package system
    and imports work, we explored its type system with basic, composite, and user-defined
    types.
  prefs: []
  type: TYPE_NORMAL
- en: We focused on variables by looking at how they can be declared and initialized,
    which operations are allowed between types, how to cast variables to other types,
    and how to see what the underlying type of interface is. We saw how scope and
    shadowing work and the difference between constants and variables. After this,
    we jumped into functions, a first-class type, and how each signature represents
    a different type. We then understood how methods are basically functions in disguise
    and attached to a type that allows custom types to satisfy interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we learned how to control the application flow using statements
    like `if`, `for`, and `switch`. We analyzed the differences between the various
    control statements and the looping statement and viewed what each built-in function
    does. Then, we saw how basic concurrency works with channels and goroutines. Finally,
    we got some notion of how Go's internal memory allocation works, some history
    and performance of its garbage collector, and how to build, install, and run Go
    binaries.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to see how to put some of this into practice
    by interacting with the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's the difference between an exported and an unexported symbol?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are custom types important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main limit of a short declaration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is scope and how does it affect variable shadowing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you access a method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain the difference between a series of `if`/`else` and `switch`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a typical use case, who is generally responsible for closing a channel?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is escape analysis?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
