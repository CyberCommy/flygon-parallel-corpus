- en: Chapter 9. Writing Your Own Node Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test-driven module API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a functional module mock-up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring from functional to prototypical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending a module's API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a module to npm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A thriving module ecosystem has been one of the core goals of Node since its
    inception. The framework leans heavily toward modularization. Even the core functionality
    (such as HTTP) is made available through the module system.
  prefs: []
  type: TYPE_NORMAL
- en: It's almost as easy to create our own modules as it is to use core and third-party
    modules. All we need to know is how the module system works and a few best practices.
  prefs: []
  type: TYPE_NORMAL
- en: A great module is one that performs a specific function to a high standard and
    great code is the result of multiple development cycles. In this chapter, we're
    going to develop a module from scratch, beginning with defining its Application
    Programming Interface (API), to creating our module over a series of development
    cycle iterations. We'll finally deploy it to npm for the benefit of all.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test-driven module API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to create our module by loosely following the test-driven development
    (TDD) model (See [http://en.wikipedia.org/wiki/Test-driven_development](http://en.wikipedia.org/wiki/Test-driven_development)
    for more info). JavaScript is asynchronous so code can be executed in multiple
    time streams at once. This can sometimes make for a challenging mental puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: A test suite is a particularly powerful tool when it comes to JavaScript development.
    It provides a quality assurance process and inspires confidence in a module's
    users base when tests are passed.
  prefs: []
  type: TYPE_NORMAL
- en: What's more, we can define our tests up front as a way to map out the intended
    API before we even begin development.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll be doing just that by creating a test suite for a module
    that extracts stats information from MP3 files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a new folder called `mp3dat`, with a file inside called `index.js`.
    Then two subfolders: `lib` and `test`, both containing `index.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll also need MP3 files to test on. For simplicity, our module will only support
    MPEG-1 Layer 3 files with error protection turned off. Other types of MP3 files
    include MPEG-2 and MPEG-2.5\. MPEG-1 (no error protection) would be the most common
    type, but our module could easily be extended later. We can retrieve an MPEG-1
    Layer 3 file from [http://www.paul.sladen.org/pronunciation/torvalds-says-linux.mp3](http://www.paul.sladen.org/pronunciation/torvalds-says-linux.mp3).
    Let's place this file in our new `mp3dat/test` folder and call it `test.mp3`.
  prefs: []
  type: TYPE_NORMAL
- en: The focus of this chapter is to create a fully functioning module, prior knowledge
    of MP3 file structures is not required. Details regarding MP3s in this chapter
    can safely be scanned over while the information pertaining to module creation
    is of key importance. However, we can learn more about MP3 files and their structure
    from [http://en.wikipedia.org/wiki/MP3](http://en.wikipedia.org/wiki/MP3).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s open `test/index.js` and set up some variables as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`assert` is a core Node module specifically for building test suites. The general
    idea is we assert that something should be true (or false), and if the assertion
    is correct the test passes. The `mp3dat` variable requires our primary (currently
    blank) `index.js` file that will in turn load the `lib/index.js` file, which holds
    the actual module code.'
  prefs: []
  type: TYPE_NORMAL
- en: The `testFile` variable points to our `test.mp3` file from the perspective of
    the root of our module (the `mp3dat` folder). This is because we run our tests
    from the root of the module directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll decide our API and write the corresponding tests. Let''s model our
    module after the `fs.stat` method. We''ll retrieve data about the MP3 file using
    an `mp3dat.stat` method, which will take two arguments: a file path and a callback
    function to be invoked once the stats have been gathered.'
  prefs: []
  type: TYPE_NORMAL
- en: The `mp3dat.stat` callback will take two arguments. The first will be the error
    object which should be set to `null` if there is no error, and the second will
    contain our `stats` object.
  prefs: []
  type: TYPE_NORMAL
- en: The `stats` object will contain `duration, bitrate, filesize, timestamp`, and
    `timesig` properties. The `duration` property will in turn contain an object holding
    `hours, minutes, seconds`, and `milliseconds` keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, our `test.mp3` file should return something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've conceptualized our API, we can map it out to assertion tests
    as a means of enforcing that API throughout the modules development.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with `mp3dat` and `mp3dat.stat`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To test the `mp3dat.stat` function we actually have to call it, then we perform
    further tests within its callback.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve established expected `stats` properties, we can go further
    and specify what these properties should look like, still within the callback
    we write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s run our test. From the `mp3dat` folder we say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return text containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Which is exactly right, we haven't written the `stat` method yet.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the tests are run, the `assert` module will throw `AssertionError` to let
    the developer know that their code is not currently lining up with their predefined
    assertions regarding the desired API.
  prefs: []
  type: TYPE_NORMAL
- en: In our unit test file (`test/index.js`), we mainly used the simple `assert`
    function (an alias for `assert.ok). assert` requires that the first argument passed
    to it be truthy. Otherwise it throws `AssertionError` where the second provided
    argument is given for the error message (the opposite of `assert.ok` is `assert.fail`,
    which expects a falsey value).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our test fails at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is because `mp3dat.stat` is `undefined` (a falsey value).
  prefs: []
  type: TYPE_NORMAL
- en: The first argument of `assert` can be an expression. For instance, we use `stats.duration.minutes
    < 60` to set a constraint for the `duration.minutes` property, and use the `match`
    method on `timesig` to verify a correct time pattern of HH:MM:SS.
  prefs: []
  type: TYPE_NORMAL
- en: We also use `assert.equal` and `assert.notStrictEqual. assert.equal` is a test
    that applies equality with type coercion (e.g. equivalent to `==)` and `assert.strictEqual`
    requires that values and types match `assert.notEqual` and `assert.notStrictEqual`
    are the corresponding antipathies.
  prefs: []
  type: TYPE_NORMAL
- en: We use `assert.notStrictEqual` to ensure the existence of the `duration` object's
    sub-properties `(hours, minutes`, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many testing frameworks providing extra descriptive syntax, enhanced
    functionality, asynchronous testing capabilities, and more. Let's sample one.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests with should.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The third-party `should` module sits nicely on top of the core `assert` module,
    adding some syntactic sugar to both simplify and increase the descriptive powers
    of our tests. Let's install it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can rewrite our tests with `should` as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`should` allows us to write more concise and descriptive tests. Its syntax
    is natural and self-explanatory. We can read up on various `should` methods at
    its Github page: [https://www.github.com/visionmedia/should.js.](https://www.github.com/visionmedia/should.js.)'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Writing a functional module mock-up* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Extending the module''s API* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deploying a module to npm* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a functional module mock-up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our tests written (see previous recipe), we are ready to create
    our module (incidentally, from here on we'll be using the `should` version of
    our unit tests as opposed to `assert)`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll write our module in simple functional style to demonstrate
    proof of concept. In the next recipe, we'll refactor our code into a more common
    modular format centered on reusability and extendibility.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's open our main `index.js` and link it to the `lib` directory via `module.exports`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to place the meat of our module code neatly inside the `lib`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll open up `lib/index.js` and begin by requiring the `fs` module, which will
    be used to read an MP3 file, and setting up a `bitrates` map that cross references
    hex-represented values to bitrate values as defined by the MPEG-1 specification.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now we'll define two functions, `findBitRate` to locate and translate the bitrate
    half-byte and `buildStats` to crunch all gathered information into our previously
    determined final `stats` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`buildStats` takes `bitrate, size`, and `cb` arguments. It uses `bitrate` and
    `size` to calculate the amount of seconds in the track and then uses this information
    to generate the `stats` object, which it passes through the `cb` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get `bitrate` into `buildStats`, let''s write the `findBitRate` function
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we expose a `stat` method, which utilizes our functions to produce
    the `stats` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s run our (`should`) tests from the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It should output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `exports` object is a central part of the Node platform. It''s the other
    half of `require`. When we require a module, any properties added to `exports`
    are exposed through `require`. So when we do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can access `exports.stat` through `mp3dat.stat`, or even through `require('mp3dat').stat`
    (assuming we have `mp3dat` installed as a module, see *Deploying a module to npm)*.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to expose one function for the entire module, we use `module.exports`,
    as in our top `index.js` file which we set up in the *Getting ready* section of
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Our `stat` method first calls `fs.stat` with the user-supplied filename (f).
    We use the supplied `fstats` object to retrieve the size of our file, which we
    pass to `buildStats`. That is, after we have called `findBitRate` to retrieve
    the MP3's `bitrate`, which we also pass to `buildStats`.
  prefs: []
  type: TYPE_NORMAL
- en: The `buildStats` callback is passed straight up through to our `stat` method's
    callback, the execution of the user callback originates within `buildStats`.
  prefs: []
  type: TYPE_NORMAL
- en: '`findBitRate` creates a `readStream` of the user-supplied file (f) and loops
    through each emitted `data` chunk two bytes at a time, thus halving the search
    time. We can do this because we''re looking for a two-byte sync word, which will
    always be at a position divisible by two. In hex the sync word is `FFFB` , as
    a 16-byte little-endian unsigned integer it''s `64511` (this is true only for
    MPEG-1 MP3 files without error protection).'
  prefs: []
  type: TYPE_NORMAL
- en: The next four bits (half-byte) following the MP3 sync word contain the bitrate
    value. So we pass this through the `Buffer.toString` method, requiring hex output
    which we match against our `bitrates` object map. In the case of our `test.mp3`
    file, the half-byte hex value is `9` representing a bitrate of `128000` bits per
    second.
  prefs: []
  type: TYPE_NORMAL
- en: Once we find our bitrate, we execute the callback and invoke `this.destroy`,
    which abruptly terminates our `readStream`, preventing the `end` event from ever
    being triggered. The `end` event will only occur when a bitrate has not been discovered,
    in which case we send an error back through the callback.
  prefs: []
  type: TYPE_NORMAL
- en: '`buildStats` receives `bitrate` and divides it by `8` giving us the bytes per
    second (8 bits to a byte). Dividing the total bytes of the MP3 by the bytes per
    second renders the amount of seconds. We then further divide it by 3,600 to get
    the `hours` variable, which is then passed into the embedded `timeProcessor` function.
    `timeProcessor` simply recurses through the `magnitudes` array (hours, `minutes,
    seconds, milliseconds)` until `seconds` have been accurately converted and apportioned
    to each magnitude, which gives us our `duration` object. Again, we use the calculated
    duration (in whatever form) to construct our `timestamp` and `timesig` properties.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Examples of how to use a module can be a great resource for end users. Let's
    write an example for our new module.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a module use case example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll create an `examples` folder within the `mp3dat` folder, and create a
    file called `basic.js` (for a basic usage example) writing the following into
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This should cause the console to output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating a test-driven module API* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Refactoring from functional to prototypical* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deploying a module to npm* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring from functional to prototypical
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functional mock-up created in the previous recipe can be useful for gaining
    mental traction with a concept (that is, getting our head around it), and may
    be perfectly adequate for small, simple modules with narrow scope.
  prefs: []
  type: TYPE_NORMAL
- en: However, the prototype pattern (among others) is commonly used by module creators,
    often used in Node's core modules and is fundamental to native JavaScript methods
    and objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Prototypical inheritance** is marginally more memory efficient. Methods sitting
    on a prototype are not instantiated until called, and they''re reused instead
    of recreated on each invocation.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, it can be slightly slower than our previous recipe's procedural
    style because the JavaScript engine has the added overhead of traversing prototype
    chains. Nevertheless, it's (arguably) more appropriate to think of and implement
    modules as entities in their own right, which a user can create instances of (for
    example, a prototype-oriented approach). For one, it makes them easier to programmatically
    extend through cloning and prototype modifications. This leads to great flexibility
    being afforded to the end user while the core integrity of the module's code stays
    intact.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll rewrite our code from the previous task according to the
    prototype pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start editing `index.js` in `mp3dat/lib`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To begin, we'll need to create a constructor function (a function called using
    `new)`, which we'll name `Mp3dat:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We've also required the `fs` module as in the previous task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some objects and methods to our constructor''s prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Three of our new `Mp3dat` properties (`_magnitudes, _pad`, and `_timesig)` were
    contained in the `buildStats` function in some form. We've prefixed their names
    with the underscore (_) to signify that they are private. This is merely a convention,
    JavaScript doesn't actually privatize them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll reincarnate the previous recipe''s `findBitRate` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The only differences here are that we load the filename from the object (`self.f`)
    instead of via the first parameter, and we load `bitrate` onto the object instead
    of sending it through the second parameter of `cb`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to convert `buildStats` into the prototype pattern, we write the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Our `_buildStats` prototype method is significantly smaller than its `buildStats`
    cousin from the previous task. Not only have we pulled its internal `magnitudes`
    array, `pad` utility function, and time signature functionality (wrapping it into
    its own `_timesig` method), we've also outsourced the internal recursive `timeProcessor`
    function to a prototype method equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we write the `stat` method (with no underscore prefix since it's intended
    for public use), and export the `Mp3dat` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can ensure all is present and correct by running the tests we built in the
    first recipe. On the command line from the `mp3dat` folder we say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Which should output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous recipe, we had an `exports.stat` function which called the `findBitRate`
    and `buildStats` functions to get the `stats` object. In our refactored module,
    we add the `stat` method onto the prototype and export the entire `Mp3dat` constructor
    function via `module.exports.`
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t have to pass `Mp3dat` to `module.exports` using `new`. Our function
    generates the new instance when invoked directly, with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is really a failsafe strategy. It's more efficient (though marginally)
    to initialize the constructor with `new`.
  prefs: []
  type: TYPE_NORMAL
- en: The `stat` method in our refactored code differs from the `exports.stat` function
    in the prior task. Instead of passing the filename and size of the specified MP3
    as parameters to `findBitRate` and `buildStats` respectively, it assigns them
    to the parent object via `this` (which is assigned to `self` to avoid new callbacks
    scopes reassignment of `this)`.
  prefs: []
  type: TYPE_NORMAL
- en: It then invokes the `_findBitRate` and `_buildStats` methods to ultimately generate
    the `stats` object and pass it back to the users callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running `mp3dat.stats` on our `test.mp3` file, our refactored `mp3dat`
    module object will hold the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the former recipe however, the returned object would simply be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The functional style reveals the API. Our refactored code allows the user to
    interact with the information in multiple ways (through the `stats` and `mp3dat`
    objects). We can also extend our module and populate `mp3dat` with other properties
    later on, outside of the `stats` object.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can structure our module to make it even easier to use.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the stat function to the initialized mp3dat object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we want to expose our `stat` function directly to the `mp3dat` object, thus
    allowing us to view the API directly (for example, with `console.log)`, we can
    add it by removing `Mp3dat.prototype.stat` and altering `Mp3dat` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then our final object becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if we''re not concerned about pushing the `stats` object and
    other `Mp3dat` properties through to the module user, we can leave everything
    as it is, except change the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses the `call` method to apply the `Mp3dat` scope to the `stat` method
    (allowing us to piggyback off of the `stat` method) and will return an object
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Just as in the first write of our module, except we still have the prototype
    pattern in place. This second approach is ever so slightly more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing for multiple instances
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our module is a singleton since returns the already initialized `Mp3dat` object.
    This means no matter how many times we require it and assign it to variables,
    a module user will always be referring to the same object, even if `Mp3dat` is
    required in different submodules loaded by a parent script.
  prefs: []
  type: TYPE_NORMAL
- en: This means bad things will happen if we try to run two `mp3dat.stat` methods
    at the same time. In a situation where our module is required multiple times,
    two variables holding the same object could end up overwriting each other's properties,
    resulting in unpredictable (and frustrating) code. The most likely upshot is that
    `readStreams` will clash.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to overcome this is to alter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And then load two instances with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to provide both singletons and multiple instances, we could add
    a `spawnInstance` method to our constructor''s prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Which then allows us to do something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `mp3dat` and `mp3dat2` would be separate `Mp3dat` instances, whereas in
    the following case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Both would be the same instance.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Writing a functional module mock-up* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Extending the module''s API* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deploying a module to npm* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the module's API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways we can extend our module, for example, we could make it
    support more MP3 types, but this is merely leg work. It just takes finding out
    the different sync words and bitrates for different types of MP3, and then adding
    these to the relevant places.
  prefs: []
  type: TYPE_NORMAL
- en: For a more interesting venture, we could extend the API, creating more options
    for our module users.
  prefs: []
  type: TYPE_NORMAL
- en: Since we use a stream to read our MP3 file, we could allow the user to pass
    in either a filename or a stream of MP3 data, offering both ease (with a simple
    filename) and flexibility (with streams). This way we could start a download stream,
    STDIN stream, or in fact any stream of MP3 data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll pick up our module from where we left it at the end of *Allowing for multiple
    instances* in the *There's more..*. section of the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we'll add some more tests for our new API. In `tests/index.js`, we'll
    pull out the callback function from the `mp3dat.stat` call into the global scope,
    and we'll call it `cb:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll call `stat` along with a method which we''re going to write and
    name: `statStream:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Notice we're using two `Mp3dat` instances `(mp3dat` and `mp3dat2)`. So we can
    run `stat` and `statStream` tests side by side. Since we're creating a `readStream`,
    we require `fs` at the top of our `[tests/index.js]` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also put a few top-level `should` tests in for the `statStream` method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now to live up to our tests expectations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within `lib/index.js`, we add a new method to the prototype of `Mp3dat`. Instead
    of taking a filename for the first parameter, it will accept an object (which
    we''ll call `opts)` that must contain `stream` and `size` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Finally, just a few modifications to `_findBitRate` and we're done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We conditionally hook onto either a passed in stream, or we create a stream
    from a given filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run our tests (from the `mp3dat` folder):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: One for `stat`, one for `statStream`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We were already using a stream to retrieve our data. We simply expose this interface
    to the user by modifying `_findBitRate` so it either generates its own stream
    from a filename, or if a stream is present in the parent constructors properties
    (`self.stream`), it simply plugs that stream into the process that was already
    in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then make this functionality available to the module user by defining a
    new API method: `statStream`. We conceptualize this first by making tests for
    it, then define it through `Mp3dat.prototype`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `statStream` method is similar to the `stat` method (in fact, we could
    merge them, see *There''s more...)*. Aside from checking the validity of the input,
    it simply adds one more property to an `Mp3dat` instance: the `stream` property,
    which is taken from `opts.stream`. For convenience, we cross reference `opts.stream.path`
    with `self.f` (this may or may not be available depending on the type of stream).
    This is essentially redundant but may be useful for debugging purposes on the
    users part.'
  prefs: []
  type: TYPE_NORMAL
- en: At the top of `statStream` we have the `validOpts` variable, which has a series
    of expressions connected by`&&` conditionals. This is shorthand for a bunch of
    `if` statements. If any of these expression tests fail, the `opts` object is not
    valid. One expression of interest is`'pause'` in `opts.stream`, which tests whether
    `opts.stream` is definitely a stream or inherited from a stream (all streams have
    a `pause` method, and `in` checks for the property throughout the entire prototype
    chain). Another noteworthy expression among the `validOpts` tests is `!isNaN(+opts.size)`,
    which checks whether `opts.size` is a valid number. The `+` which precedes it
    converts it to a `Number` type and `!isNaN` checks that it isn't`"not a number"`
    (there is no `isNumber` in JavaScript so we use `!isNaN)`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we have this new method. Let's write some more examples. We'll also see
    how we can merge `statStream` and `stat` together, and further enhance our module
    by causing it to emit events.
  prefs: []
  type: TYPE_NORMAL
- en: Making the STDIN stream example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To demonstrate usage with other streams we might write an example using the
    `process.stdin` stream as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We've included comments in the example to ensure our users understand how to
    use it. All we do here is receive the `process.stdin` stream and the file size,
    then pass them to our `statStream` method.
  prefs: []
  type: TYPE_NORMAL
- en: Making the PUT upload stream example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the *Handling file uploads recipe* of[Chapter 2](ch02.html "Chapter 2. Exploring
    the HTTP Object"), *Exploring the HTTP Object*, we created a PUT upload implementation
    in the *There's more..*. section of that recipe.
  prefs: []
  type: TYPE_NORMAL
- en: We'll take the `put_upload_form.html` file from that recipe, and create a new
    file called `HTTP_PUT_stream.js` in our `mp3dat/examples` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a server that serves the `put_upload_form.html` file. The HTML
    file allows us to specify a file to upload (which must be a valid MP3 file), and
    then sends it to the server.
  prefs: []
  type: TYPE_NORMAL
- en: In our server, we pass `req` (which is a stream) to the `stream` property and
    `req.headers['content-length']` which gives us the size of MP3 in bytes as specified
    by the browser via the `Content-Length` header.
  prefs: []
  type: TYPE_NORMAL
- en: We then finish by logging `stats` to the console (we could also extend this
    example by sending `stats` back to the browser in JSON form).
  prefs: []
  type: TYPE_NORMAL
- en: Merging stat and statStream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There's a lot of similar code between `stat` and `statStream`. With a bit of
    restructuring, we can merge them into one method, allowing the user to pass either
    a string containing a filename or an object containing stream and size properties
    straight into the `stat` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''d need to update our tests and examples. In `test/index.js`, we
    should remove the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''re merging `statStream` into `stat`, our two calls to `stat` and
    `statStream` should become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `statStream` line in `examples/stdin_stream.js` should become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In `HTTP_PUT_stream.js` it should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In `lib/index.js`, we trash the `streamStat` method, inserting a `_compile`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we modify our `Mp3dat.prototype.stat` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The code that actually generates the `stats` has been placed into the `_compile`
    method. If the first argument is an object, we assume a stream and `stats` take
    on the role of the former `statStream`, calling `_compile` and returning from
    the function early. If not, we assume a filename and invoke `_compile` within
    the `fs.stat` callback with JavaScript's `call` method, ensuring our `this` /
    `self` variable carries through the `_compile` method.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the EventEmitter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Throughout this book, we have generally received data from modules via callback
    parameters or through listening for events. We can extend our `modules` interface
    further, allowing users to listen for events by causing Node's `EventEmitter`
    to adopt our `Mp3dat` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: We need to require the `events` and `util` modules, then hook up `Mp3dat` with
    `EventEmitter` by assigning the `this` object of `Mp3dat` to it, and then give
    it the super powers of `Mp3dat EventEmitter` by using `util.inherits:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'All we do now is go through the existing methods of `Mp3dat` and insert the
    `emit` events in relevant places. We can `emit` the `bitrate` once it''s found
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Where we would callback with an error, we can also emit that error as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Then there''s the time signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'And of course, the `stats` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We've also added `if (cb)` to `_buildStats`, since a callback may no longer
    be necessary if the user opts to listen for events instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a module user is dynamically generating the `Mp3dat` instances, they may
    wish to have a way to hook into a spawned instance event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to allow chaining, we can also return the `Mp3dat` instance from the
    `stat` function from two places. First within the `isOptsObj` block as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Then right at the end of the function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This is because we return early from the function depending on the detected
    input (filename or stream), so we have to return `self` from two places.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can write an example for our new user interface. Let's make a new file
    in `mp3dat/examples` called `event_emissions.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating a test-driven module API* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Handling file uploads* discussed In [Chapter 2](ch02.html "Chapter 2. Exploring
    the HTTP Object"),Exploring the HTTP Object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deploying a module to npm* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a module to npm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve created a module, we can share it with the rest of the world
    using the same integrated tool that we retrieve modules with: `npm`.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can deploy to npm we need to make a `package.json` file, so let''s
    do that for our module. In `mp3dat`, we''ll create `package.json` and add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We can of course insert our own name and the name of the package. Another way
    to create a `package.json` file is to use `npm init` which asks a series of questions
    via the command line, then generates the `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: We can specify a repository in `package.json`. It's a good idea to use an online
    repository such as GitHub to manage version control, share code, and allow others
    to work on your code. See [http://help.github.com/](http://help.github.com/) to
    get started.
  prefs: []
  type: TYPE_NORMAL
- en: The `main` property is important. It defines the entry point to our module,
    which in our case is `./lib/index.js` (although we could have specified `./index.js`
    which loads `./lib/index.js)`. By defining `scripts.test` as `node test`, we can
    now run `npm test` (or `npm mp3dat test` once `mp3dat` is installed via `npm)`
    to execute our unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be deploying our module to npm as we left it in the previous recipe, where
    `stat` and `statStream` were both merged into `stat`, and we have integrated with
    `EventEmitter`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To deploy to `npm`, we must have a developer account. We do this by executing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: And filling in our desired username, password, and contact email. That's it,
    we are now registered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we go ahead and publish our module, we''ll want to test that `npm` will
    install it on our system without a hitch. Inside `mp3dat` we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Then if we run `node` from the command line, we should be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Without getting an error message. If it worked, we can go ahead and publish
    our module! Within `mp3dat` we say the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we go to a completely different folder (say our home folder) and type
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '`npm` should install our package from its repository.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can double check if it''s there with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Or, if that's taking too long, we can go to [http://search.npmjs.org/](http://search.npmjs.org/)
    in our browser. Our module will probably be on the home page (which contains the
    most recently published modules). Or we can hit [http://search.npmjs.org/#/mp3dat](http://search.npmjs.org/#/mp3dat)
    to head to our module's npm registry page directly.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`npm` is a command-line script written in Node which provides some excellent
    tools for developing and publishing modules. The tools really do what they say
    on the tin, `adduser` adds a user, `install` installs, and `publish` publishes.
    It''s really very elegant.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the server side, the `npm` registry is backed by a CouchDB database that
    holds all the JSON-like data for each package. There''s even a CouchDB `_changes`
    field we could hook into. On the command line, we could do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'And watch modules as they are added and modified in real time. If nothing is
    happening, we could always open another terminal and type the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Which will cause the CouchDB changes feed to update.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`npm` has some really nice features, let''s take a look at some.'
  prefs: []
  type: TYPE_NORMAL
- en: npm link
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `npm link` command can be useful for module authors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout development, if we wanted to require `mp3dat` as a global module,
    for example as `require(''mp3dat'')`, each time we make changes we could update
    the global package by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `npm link` provides an easier solution, when we run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Within our `mp3dat` folder, a symlink is created from our global `node_modules`
    folder to our working directory. This causes Node to treat `mp3dat` as an installed
    global module, but any changes we make to our development copy will be reflected
    globally. When we are finished developing, and want to freeze the module on our
    system, we simply unlink as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: .npmignore and npm version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our `example` files may be handy on GitHub, but we may decide they''re of little
    benefit within `npm`. We can use an `.npmignore` file to keep certain files out
    of published `npm` packages. Let''s create `.npmignore` in the `mp3dat` folder,
    and put:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we re-publish to the `npm` registry, our new package will be minus
    the `examples` folder. Before we can publish though, we either have to unpublish,
    or change the version of our package (or we could use the `--force` argument).
    Let''s change the version, then publish again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Changing the version will also alter our `package.json` file to the new version
    number.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Writing a functional module mock-up* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Refactoring from functional to prototypical* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Extending the module''s API* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Accessing CouchDB changes stream with Cradle* discussed In [Chapter 4](ch04.html
    "Chapter 4. Interfacing with Databases"),Interfacing with Databases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
