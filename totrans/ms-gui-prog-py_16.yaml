- en: Creating 3D Graphics with QtOpenGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From games to data visualizations to engineering simulations, 3D graphics and
    animations are at the heart of many important software applications. For several
    decades, the de facto standard **Application Programming Interface** (**API**)
  prefs: []
  type: TYPE_NORMAL
- en: for cross-platform 3D graphics has been OpenGL. Although many Python and C implementations
    of the API exist, Qt offers one that is directly integrated into its widgets,
    giving us the capability to embed interactive OpenGL graphics and animations in
    our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll take a look at those capabilities in the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of OpenGL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding OpenGL drawings with `QOpenGLWidget`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating and controlling OpenGL drawings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you'll need a basic Python 3 and PyQt5 setup, as we've been
    using throughout the book, and you might like to download the example code from
    [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter13](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter13).
    You will also need to make sure that your graphics hardware and drivers support
    OpenGL 2.0 or higher, although this is almost certainly true if you are using
    a conventional desktop or laptop computer made within the last ten years.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [http://bit.ly/2M5xApP](http://bit.ly/2M5xApP)
  prefs: []
  type: TYPE_NORMAL
- en: The basics of OpenGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenGL is not simply a library; it is a **specification** for an API to interact
    with your graphics hardware. The implementation of this specification is shared
    between your graphics hardware, the drivers for that hardware, and the OpenGL
    software library you choose to use. As a result, the exact behavior of your OpenGL-based
    code might be slightly different depending on any of those factors, just as, for
    example, the same HTML code might be slightly differently rendered in different
    web browsers.
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL is also a **versioned** specification, meaning that the available features
    and recommended usage of OpenGL changes depending on which version of the specification
    you're targeting. As new features are introduced and old features deprecated,
    the best practices and recommendations also evolve, so that code written for OpenGL
    2.x systems may look nothing at all like a code written for OpenGL 4.x.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenGL specification is managed by the Khronos Group, an industry consortium
    that maintains several graphics-related standards. The latest specification at
    the time of writing is 4.6, released in February 2019, which can be found at [https://www.khronos.org/registry/OpenGL/index_gl.php](https://www.khronos.org/registry/OpenGL/index_gl.php).
    However, it's not always a good idea to follow the latest specification. A computer's
    ability to run an OpenGL code of a given version is limited by hardware, driver,
    and platform considerations, so if you want your code to be run by the widest
    possible array of users, it's better to target an older and more established version.
    Many common embedded graphics chips from Intel only support OpenGL 3.x or lower,
    and some low-end devices, such as the Raspberry Pi (which we'll look at in [Chapter
    15](77583d1b-8a70-4118-8210-b0a5f09c9603.xhtml), *PyQt on the Raspberry Pi*) only
    support 2.x.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll limit our code to OpenGL 2.1, since it is well supported
    by PyQt and most modern computers should be able to run it. However, since we're
    going to be sticking to the basics, everything we'll learn applies equally well
    to the 4.x version.
  prefs: []
  type: TYPE_NORMAL
- en: The rendering pipeline and drawing basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Turning code and data into pixels on a screen requires a multi-stage process;
    in OpenGL, this process is known as the **rendering pipeline.** Some stages in
    this pipeline are programmable, while others are fixed-function, meaning that
    their behavior is predetermined by the OpenGL implementation and cannot be altered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s walk through the major stages of this pipeline from start to finish:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertex specification**: In the first stage, the **vertices** of the drawing
    are determined by your application. A **vertex** is essentially a point in a 3D space
    that can be used to draw a shape. The vertex may also contain metadata about the
    point, such as its color.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Vertex processing**: This user-definable stage processes each vertex in various
    ways to calculate the final position of each vertex; for example, in this step
    you might rotate or move the basic shape defined in the vertex specification.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Vertex post-processing**: This fixed-function stage does some additional
    processing on the vertices, such as clipping sections that fall outside the viewing
    space.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Primitive assembly**: In this stage, vertices are composed into primitives. A
    primitive is a 2D shape, such as a triangle or rectangle, from which more complex
    3D shapes are built.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Rasterization**: This stage transforms the primitives into a series of individual
    pixel points, called fragments, by interpolating between the vertices.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Fragment shading**: The main job of this user-defined stage is to determine
    the depth and color value for each fragment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Per-sample operations**: This final stage performs a series of tests on each
    fragment to determine its final visibility and color.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As programmers using OpenGL, we are mostly concerned with just three stages
    of this operation – the vertex specification, the vertex processing, and the fragment
    shading. For the vertex specification, we will simply define some points in Python
    code to describe a shape for OpenGL to draw; for the other two stages, we will
    need to learn about creating OpenGL programs and shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Programs and shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite the name, a **shader** has nothing to do with shadows or shading; it
    is simply the name for a unit of code that runs on your GPU. In the previous section,
    we talked about some stages of the rendering pipeline being user-definable; in
    fact, some of them *must* be defined, as most OpenGL implementations do not provide
    default behavior for certain stages. To define those stages, we need to write
    a shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a minimum, we need to define two shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The** **vertex shader:** This shader is the first step of the vertex processing
    stage. Its main job is to determine the spatial coordinates of each vertex.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The** **fragment shader:** This is the second-to-last stage of the pipeline,
    and its only required job is to determine the color of an individual fragment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we have a collection of shaders that comprise a complete render pipeline,
    this is called a program.
  prefs: []
  type: TYPE_NORMAL
- en: Shaders cannot be written in Python. They must be written in a language called
    **GL Shader Language** (**GLSL**), a C-like language that is part of the OpenGL
    specification. It's impossible to create serious OpenGL drawings without some
    knowledge of GLSL, but fortunately, it is simple enough to write a fairly rudimentary
    set of shaders good enough for a basic example.
  prefs: []
  type: TYPE_NORMAL
- en: A simple vertex shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to compose a simple GLSL vertex shader that we can use for our
    demo; create a file called `vertex_shader.glsl`, and copy in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We've begun with a comment indicating the version of GLSL we are using. This
    is important, as each version of OpenGL is only compatible with a particular version
    of GLSL, and the GLSL compiler will use this comment to check whether we've mismatched
    those versions.
  prefs: []
  type: TYPE_NORMAL
- en: A chart showing compatibility between versions of GLSL and OpenGL can be found
    at [https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)](https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need to make some **variable declarations**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In C-like languages, variable declarations are used to create the variable,
    define various attributes about it, and allocate space for it in memory. Each
    of our declarations has four tokens; let''s go through these in order:'
  prefs: []
  type: TYPE_NORMAL
- en: The first token is one of `attribute`, `uniform`, or `varying`. This indicates
    whether the variable will be distinct for each vertex (`attribute`), each primitive
    (`uniform`), or each fragment (`varying`). So, our first variable will be different
    for each vertex, but our second one will be the same for each vertex within the
    same primitive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second token indicates the basic data type that the variable contains. In
    this case, it's either `highp` (a high-precision number), `mediump` (a medium-precision
    number), or `lowp` (a low-precision number). We could have used `float` or `double`
    here, but these aliases are helpful in making our code cross-platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third term defines each of these variables as pointing to either a **vector**
    or a matrix. You can think of a vector like a Python `list` object, and a matrix
    like a `list` object where each item is a `list` object of the same length. The
    number at the end indicates the size, so `vec4` is a list of four values, and
    `mat4` is a 4x4 matrix of values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last token is the variable name. These names will be used through the entire
    program so we can use them in shaders further down the pipeline to access data
    from earlier shaders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These variables can be used to insert data into the program or pass data to
    other shaders in the program. We'll see how to do that later in this chapter,
    but for now, understand that, in our shader, `vertex`, `matrix`, and `color_attr`
    represent data that will be received by the vertex shader from our PyQt application.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the variable declarations, we will create a function called `main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The primary purpose of the `vertex` shader is to set a variable called `gl_Position`
    with the coordinates of the `vertex`. In this case, we're setting it to our `vertex`
    value passed into the shader multiplied by the `matrix` value. As you'll see later,
    this arrangement will allow us to manipulate our drawing in space.
  prefs: []
  type: TYPE_NORMAL
- en: Matrices and vectors are critical mathematical concepts to understand when creating
    3D graphics. While we will remain mostly abstracted from the details of this math
    in this chapter, it's a good idea to brush up on these concepts if you want to
    dive deeper into OpenGL programming.
  prefs: []
  type: TYPE_NORMAL
- en: The last line of code in our shader may seem somewhat pointless, but it allows
    us to specify a color for each vertex in the vertex specification stage and have
    that color passed along to other shaders later in the pipeline. Variables in a
    shader are either input or output variables, meaning that they expect to receive
    data from the previous stage of the pipeline or pass data along to the next stages.
    Within the vertex shader, declaring a variable with the `attribute` or `uniform`
    qualifiers implicitly marks a variable as an input variable, while declaring it
    with the `varying` qualifier implicitly marks it as an output variable. Thus,
    we are copying the value of our `attribute`-type `color_attr` variable to the
    `varying`-type `color` variable in order to pass the value to shaders further
    down the pipeline; specifically, we want to pass it to the `fragment` shader.
  prefs: []
  type: TYPE_NORMAL
- en: A simple fragment shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second shader we need to create is the `fragment` shader. Remember that
    this shader's primary job is to determine the color of each point (or *fragment*)
    on a primitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `fragment_shader.glsl` and add in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Just as with our `vertex` shader, we begin with a comment specifying the version
    of GLSL we're targeting. Then, we will declare a variable called `color`.
  prefs: []
  type: TYPE_NORMAL
- en: Because this is the `fragment` shader, specifying a variable as `varying` makes
    it an input variable. Using the name `color`, which was an output variable from
    our shader, means that we will receive from that shader the color value it assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Within `main()`, we then assign that color to the built-in `gl_FragColor` variable.
    What this shader effectively does is tell OpenGL to use the color value passed
    in with the `vertex` shader to determine the color of an individual fragment.
  prefs: []
  type: TYPE_NORMAL
- en: This is about as simple a `fragment` shader as we can get. A more complex `fragment`
    shader, such as one that you would find in a game or simulation, might implement
    textures, lighting effects, or other color manipulations; but this one should
    suffice for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our required shaders, we can create a PyQt application to use
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding OpenGL drawings with QOpenGLWidget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To see how OpenGL works with PyQt, we're going to use our shaders to make a
    simple OpenGL image, which we will be able to control through a PyQt interface.
    Create a copy of your Qt application template from [Chapter 4](61ff4931-02af-474a-996c-5da827e0684f.xhtml),
    *Building Applications with QMainWindow*, and call it `wedge_animation.py`. Put
    this in the same directory as your `shader` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, start by adding this code in `MainWindow.__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code creates our central widget and adds a `GlWidget` object to it. The
    `GlWidget` class is what we'll be creating to display our OpenGL drawing. To create
    it, we'll need to subclass a widget that can display OpenGL content.
  prefs: []
  type: TYPE_NORMAL
- en: First steps with OpenGLWidget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two Qt classes that we can use to display OpenGL content: `QtWidgets.QOpenGLWidget`
    and `QtGui.QOpenGLWindow`. In practice, they behave almost exactly the same, but
    `OpenGLWindow` offers slightly better performance and may be a better choice if
    you don''t want to use any other Qt widgets (that is, if your application is just
    full-screen OpenGL content). In our case, we''re going to be combining our OpenGL
    drawing with other widgets, so we''ll use `QOpenGLWidget` as the base for our
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To create OpenGL content on our widget, we need to override two `QOpenGLWidget`
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`initializeGL()`, which is run once to set up our OpenGL drawing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paintGL()`, which is called whenever our widget needs to paint itself (for
    example, in response to an `update()` call)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll start with `initializeGL()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first thing that we need to do is get access to our OpenGL API. The API
    is made up of a set of functions, variables, and constants; in an object-oriented
    platform, such as PyQt, we will be creating a special OpenGL functions object
    that contains those functions as methods and the variables and constants as properties.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we first retrieve an OpenGL **context** from the `QOpenGLWidget` method.
    The context represents our interface to the OpenGL surface on which we're currently
    drawing. From the context, we can retrieve the object that contains our API.
  prefs: []
  type: TYPE_NORMAL
- en: Because we need access to a specific version of the API (2.1), we will first
    need to create a `QOpenGLVersionProfile` object with its `version` property set
    to `(2, 1)`. This can be passed to the context's `versionFunctions()` method,
    which will return a `QOpenGLFunctions_2_1` object. This is the object that contains
    our OpenGL 2.1 API.
  prefs: []
  type: TYPE_NORMAL
- en: Qt defines OpenGL function objects for other versions of OpenGL as well, but
    be aware that, depending on your platform, your hardware, and how you acquired
    Qt, a particular version may or may not be supported.
  prefs: []
  type: TYPE_NORMAL
- en: We're saving the `functions` object as `self.gl`; all of our API calls will
    be done on this object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have access to the API, let''s start configuring OpenGL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Much like Qt, OpenGL uses defined constants to represent various settings and
    states. Configuring OpenGL is mostly a matter of passing these constants to various
    API functions that toggle various settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we''re performing three settings:'
  prefs: []
  type: TYPE_NORMAL
- en: Passing `GL_DEPTH_TEST` to `glEnable()` activates **depth testing,** which means
    that OpenGL will try to figure out which of the points its drawings are in the
    foreground and which are in the background.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glDepthFunc()` sets the function that will determine whether or not a depth-tested
    pixel will be drawn. In this case, the `GL_LESS` constant indicates that the pixel
    with the lowest depth (that is, the one closest to us) will be drawn. Generally,
    this is the setting you want, and it''s also the default setting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing `GL_CULL_FACE` to `glEnable()` activates **face culling**. This simply
    means that OpenGL will not bother drawing the sides of the object that the viewer
    can't actually see. It makes sense to enable this as well, as it saves on resources
    that would otherwise be wasted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three optimizations should help to reduce the resources used by our animation;
    in most cases, you'll want to use them. There are many more options that can be
    enabled and configured; for a complete list, see [https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEnable.xml](https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEnable.xml).
    Be aware that some options only apply to the older fixed-function method of using
    OpenGL.
  prefs: []
  type: TYPE_NORMAL
- en: If you see OpenGL code that uses `glBegin()` and `glEnd()`, it is using the
    very old OpenGL 1.x fixed-function drawing API. This approach was easier, but
    much more limited, so this shouldn't be used for modern OpenGL programming.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next step in implementing an OpenGL drawing is to create our program. You
    may remember that an OpenGL program is a collection of shaders that form a complete
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Qt, the process to create a program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `QOpenGLShaderProgram` object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add your shader code to the program
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Link the code into a complete program
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code will implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Shaders can be added from files, as we've done here using `addShaderFromSourceFile()`,
    or from strings using `addShaderFromSourceCode()`. We're using relative file paths
    here, but the best approach would be to use Qt resource files (see the *Using
    Qt Resource Files* section in [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml),
    *Styling Qt Applications*). As the files are added, Qt compiles the shader code
    and outputs any compilation errors to the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: In the production code, you'll want to check the Boolean output of `addShaderFromSourceFile()`
    to see whether your shader compiled successfully before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the first argument to `addShaderFromSourceFile()` specifies what kind
    of shader we're adding. This is important, as vertex shaders and fragment shaders
    have very different requirements and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the shaders are loaded, we call `link()` to link all the compiled code
    into a ready-to-execute program.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing our variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our shader programs contained some variables that we need to be able to access
    and put values into, so we need to retrieve a handle for those variables. The
    `QOpenGLProgram` object has two methods, `attributeLocation()` and `uniformLocation()`,
    which can be used to retrieve a handle for attribute and uniform variables, respectively
    (there is no such function for the `varying` types).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s grab some handles for our `vertex` shader variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The values returned from these methods are actually just integers; internally,
    OpenGL just uses sequential integers to track and reference objects. However,
    that doesn't matter to us. We can treat this as if they were object handles and
    pass them into OpenGL calls to access these variables, as you'll see soon.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a projection matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In OpenGL, the **projection matrix** defines how our 3D model is projected to
    a 2D screen. This is represented by a 4x4 matrix of numbers that can be used to
    calculate vertex positions. Before we can do any drawing, we need to define this
    matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Qt, we can use the `QMatrix4x4` object to represent it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A `QMatrix4x4` object is very simply a table of numbers arranged in four rows
    and four columns. However, it has several methods that allow us to manipulate
    those numbers in such a way that they represent 3D transformations, such as our
    projection.
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL can use two kinds of projections—**orthographic**, meaning that points
    at all depths are rendered the same, or **perspective**, meaning that the field
    of view expands as we move away from the viewer. For realistic 3D drawings, you'll
    want to use perspective projection. This kind of projection is represented by
    a **frustum**.
  prefs: []
  type: TYPE_NORMAL
- en: A frustum is a section of a regular geometric solid between two parallel planes,
    and it's a useful shape for describing a field of vision. To understand this,
    place your hands on either side of your head. Now, move them forward, keeping
    them just outside your field of vision. Notice that you must move them outward
    (to the left and right) in order to do this. Try this again with your hands above
    and below your head. Once again, you must move them outward vertically to keep
    them from your field of visions.
  prefs: []
  type: TYPE_NORMAL
- en: The shape that you've just made with your hands is like a pyramid, extending
    from your eyes, whose point has been sliced off parallel to the base—in other
    words, a frustum.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a matrix that represents a perspective frustum, we can use the `matrix`
    object''s `perspective()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `perspective()` method takes four arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The angle, in degrees, at which the frustum expands from the near plane to the
    far plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The aspect ratio of the near and far planes (which are identical)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The depth into the screen of the near plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The depth into the screen of the far plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without digging into the complicated math, this matrix effectively represents
    our field of view relative to our drawing. As we'll see when we start drawing,
    all we need to do to move our object is to manipulate the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we should probably back up a bit from where we''re going to be
    drawing so that it''s not happening right up in the front of the field of view.
    This movement can be accomplished by the `translate()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`translate` takes three arguments—an x amount, a y amount, and a z amount.
    Here, we''ve specified a z translation of `-5`, which pushes the object deeper
    into the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: This may all seem a bit confusing now, but, once we start drawing our shape,
    things will become clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing our first shape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our OpenGL environment is initialized, we can move on to the `paintGL()`
    method. This method will contain all the code for drawing our 3D object and will
    be called whenever the widget needs to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we''ll do when painting is clear the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`glClearColor()` is used to fill the background of the drawing with a solid
    color, as specified by our arguments. Colors in OpenGL are specified using three
    or four values. In the case of three values, they represent red, green, and blue.
    A fourth value, when used, represents the **alpha**, or opacity, of the color.
    Unlike Qt, where RGB values are integers ranging from `0` to `255`, OpenGL color
    values are floating-point numbers ranging from `0` to `1`. Our values in the preceding
    describe a deep purple-blue color; feel free to experiment with other values.'
  prefs: []
  type: TYPE_NORMAL
- en: You should redraw the background with `glClearColor` on every repaint; if you
    don't, the previous paint operations will still be visible. This is a problem
    if you animate or resize your drawing.
  prefs: []
  type: TYPE_NORMAL
- en: The `glClear()` function is used to clean out various memory buffers on the
    GPU, which we'd like to reset between redraws. In this case, we're specifying
    some constants that cause OpenGL to clear the color buffer and the depth buffer.
    This helps to maximize performance.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we `bind()` the program object. Since an OpenGL application can have
    multiple programs, we call `bind()` to tell OpenGL that the commands we're about
    to issue apply to this particular program.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can draw our shape.
  prefs: []
  type: TYPE_NORMAL
- en: Shapes in OpenGL are described using vertices. You may recall that a vertex
    is essentially a point in 3D space described by *X*, *Y*, and *Z* coordinates,
    and defines one corner or end of a primitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a list of vertices to describe a triangle that will be the front
    of a wedge shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Our vertex data doesn't have to be grouped into distinct objects of any kind,
    but, for convenience and readability, we've used the `QVector3D` object to hold
    the coordinates for each of the vertices in our triangle.
  prefs: []
  type: TYPE_NORMAL
- en: The numbers used here represent points on a grid, where `(0, 0, 0)` is the center
    of our OpenGL viewport at the forward-most point. The x axis goes from `-1` at
    the left-hand side of the screen to `1` at the right-hand side, and the y axis
    goes from `1` at the top of the screen to `-1` at the bottom. The z axis is a
    bit different; if you imagine the field of vision (the frustum we described earlier)
    as a shape expanding out of the back of your monitor, a negative z value pushes
    deeper into that field of vision. A positive z value would move out of the screen
    toward (and eventually behind) the viewer. So, generally, we will be operating
    with negative or zero z values to stay within the visible range.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, OpenGL will draw in black, but it would be far more interesting
    to have some colors. So, we''ll define a `tuple` object containing some colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We've defined three colors here, one for each vertex of the triangle. These
    are `QColor` objects, though; remember that OpenGL needs colors as vectors of
    values between `0` and `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To address this, we''ll create a little method to convert a `QColor` to an
    OpenGL-friendly vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This code is fairly self-explanatory, it will create another `QVector3D` object
    with the converted RGB values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `paintGL()`, we can use a list comprehension to convert our colors
    to something usable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we've defined some vertex and color data, but we've sent nothing
    to OpenGL yet; these are just data values in our Python script. To pass these
    to OpenGL, we'll need those variable handles we grabbed in `initializeGL()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first variable we''ll pass to our shaders is the `matrix` variable. We''re
    going to use our `view_matrix` object that we defined in `initializeGL()` for
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`setUniformValue()` can be used to set the value of a `uniform` variable; we
    can simply pass it the handle of the `GLSL` variable that we retrieved using `uniformLocation()`
    and the `matrix` object we created to define our projection and field of vision.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use `setAttributeValue()` to set the value of `attribute` variables.
    For instance, if we wanted all our vertices to be red, we could add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: But let's not do that; it will look much better if each vertex has its own color.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we need to create some **attribute arrays.** An attribute array
    is an array of data that will be passed into an attribute-type variable. Remember
    that variables marked as attributes in GLSL apply a distinct value to each vertex.
    So effectively we're telling OpenGL, *here are some arrays of data where each
    item applies to one vertex*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The first step is to enable an array on the `GLSL` variable by calling `enableAttributeArray()`
    with the handle for the variable that we want to set the array on. Then, we pass
    in the data using `setAttributeArray()`. This effectively means that our `vertex`
    shader is going to be run on each of the items in the `front_vertices` array.
    Each time that shader runs, it will also grab the next item from the `gl_colors`
    list and will apply that to the `color_attr` variable.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using multiple attribute arrays like this, you need to make sure
    that there are enough items in the arrays to cover all the vertices. If we only
    had two colors defined, the third vertex would pull garbage data for `color_attr`,
    resulting in an undefined output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve queued up all the data for our first primitive, let''s draw
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`glDrawArrays()` will send all the arrays we''ve defined into the pipeline.
    The `GL_TRIANGLES` argument tells OpenGL that it will be drawing triangle primitives,
    and the next two arguments tell it to start at array item `0` and draw three items.'
  prefs: []
  type: TYPE_NORMAL
- en: If you run the program at this point, you should see that we've drawn a red
    and yellow triangle. Nice! Now, let's make it 3D.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a 3D object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make a 3D object, we need to draw the back and sides of our wedge object.
    We''ll start by calculating the coordinates for the back of the wedge using a
    list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To create the back face, we only need to copy each of the front face coordinates
    and move the z axis back a bit. So, we're using the `QVector3D` object's `toVector2D()`
    method to produce a new vector with only the x and y axes, then passing that to
    the constructor of a new `QVector3D` object along with a second argument specifying
    the new z coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll pass this set of vertices to OpenGL and draw as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: By writing these to `vertex_location`, we've overwritten the vertices for the
    front face (which are already drawn) and replaced them with the back face vertices.
    Then, we make the same call to `glDrawArrays()` and the new set of vertices will
    be drawn, along with the corresponding colors.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that we will reverse the order of the vertices before drawing.
    When OpenGL displays a primitive, it only shows one side of that primitive, since
    it's assumed that the primitive is part of some 3D object whose insides would
    not need to be drawn. OpenGL determines which side of the primitive should be
    drawn depending on whether its points are drawn clockwise or counterclockwise.
    By default, the near face of a primitive drawn counter-clockwise is shown, so
    we will reverse the order of the back face vertices so that it is drawn clockwise
    and its far face is shown (which will be the outside of the wedge).
  prefs: []
  type: TYPE_NORMAL
- en: Let's finish our shape by drawing its sides. Unlike the front and back, which
    are triangles, our sides are rectangles and so will need four vertices each to
    describe them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll calculate those vertices from our other two lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `sides` list contains indexes for the `front_vertices` and `back_vertices`
    lists, which define the sides of each triangle. We iterate this list, and, for
    each one, define a list of four vertices describing one side of the wedge.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that those four vertices are drawn in counter-clockwise order, just like
    the front (you may need to sketch this out on paper to see it).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also define a new list of colors since we now need more than three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Our list of side vertices contains a total of 12 vertices (4 for each of the
    3 sides), so we need a list of 12 colors to match it. We can do this by just specifying
    4 colors and then multiplying the Python `list` object by 3 to produce a repeating
    list with 12 items in total.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll pass these arrays to OpenGL and draw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This time, instead of `GL_TRIANGLES`, we're using `GL_QUADS` as the first argument
    to indicate that we're drawing quadrilaterals.
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL can draw several different primitive types, including lines, points,
    and polygons. Most of the time, you should use triangles, because this is the
    fastest primitive on most graphics hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that all our points are drawn, we''ll clean up a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: These calls aren't strictly necessary in our simple little demonstration, but,
    in a more complex program, they would likely save you some headaches. OpenGL operates
    as a state machine, where the result of an operation depends on the current state
    of the system. When we bind or enable a particular object, OpenGL is then pointed
    *to* that object and certain operations (such as setting array data) will be automatically
    directed to it. When we've finished a drawing operation, we don't want to leave
    OpenGL pointed at our object, so it's good practice to release and disable objects
    when we're finished with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the application now, you should see your amazing 3D shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/67c57d27-65dc-43bf-ada2-e4e1549f0e6d.png)'
  prefs: []
  type: TYPE_IMG
- en: Oops, not so 3D, is it? In fact, we *have* drawn a 3Dshape, but you can't see
    that, because we're looking directly at it. In the next section, we'll create
    some code to animate this shape and get a full appreciation of all its dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: Animating and controlling OpenGL drawings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get a sense of the 3D aspects of our drawing, we're going to build some controls
    into our GUI that allow us to rotate and zoom around the drawing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by adding some buttons in `MainWindow.__init__()` that we can
    use as controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We've created two sets of buttons here; the first set will be a set of radio-style
    buttons (so only one can be down at a time) that will select the rotation direction
    of the object – none (no rotation), left, right, up, or down. Each button will
    call a corresponding method on the `GlWidget` object when activated.
  prefs: []
  type: TYPE_NORMAL
- en: The second set comprises a zoom-in and zoom-out buttons, which calls a `zoom_in()`
    or `zoom_out()` method on the `GlWidget` respectively. With these buttons added
    to our GUI, let's hop over to `GlWidget` and implement the callback methods.
  prefs: []
  type: TYPE_NORMAL
- en: Animating in OpenGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Animating our wedge is purely a matter of manipulating the `view` matrix and
    redrawing our image. We''ll start in `GlWidget.initializeGL()` by creating an
    instance variable to hold rotation values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The first value in this list represents an angle of rotation; the remaining
    values are the *X*, *Y*, and *Z* coordinates of the point around which the `view`
    matrix will rotate.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of `paintGL()`, we can pass these values into the `matrix` object''s
    `rotate()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Right now, this will do nothing, because our rotation values are all `0`. To
    cause rotation, we will have to change `self.rotation` and trigger a repaint of
    the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our rotation callbacks will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Each method simply changes the value of our rotation vector. The angle is shifted
    one degree forward (`1`) or backward (`1`) around an appropriate point to produce
    the rotation desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just need to kick off animation by triggering repeated repaints. At
    the end of `paintGL()`, add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`update()` schedules a repaint on the `event` loop, which means that this method
    will be called again and again. Each time, our `view` matrix will be rotated by
    the amount set in `self.rotation`.'
  prefs: []
  type: TYPE_NORMAL
- en: Zooming in and out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We also want to implement zooming. Each time we click the zoom-in or zoom-out
    buttons, we want the image to get a tiny bit closer or further away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those callbacks look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `scale()` method of `QMatrix4x4` causes the matrix to multiply each vertex
    point by the given amounts. Thus, we can cause our object to shrink or grow, giving
    the illusion that it is nearer or further away.
  prefs: []
  type: TYPE_NORMAL
- en: We could use `translate()` here, but translating in conjunction with rotation
    can cause some confusing results and we can lose sight of our object quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when you run the application, you should be able to spin your wedge and
    see it in all its 3D glory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/58b84077-1876-4e42-81a2-61c883b69a2d.png)'
  prefs: []
  type: TYPE_IMG
- en: This demonstration is only the beginning of what can be done with OpenGL. While
    this chapter may not have made you an OpenGL expert, you'll hopefully feel more
    comfortable digging deeper with the resources at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned about creating 3D animations with OpenGL,
    and how to integrate them into your PyQt application. We explored the basic principles
    of OpenGL, such as the render pipeline, shaders, and GLSL. We learned how to use
    Qt widgets as an OpenGL context to draw and animate a simple 3D object.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn to visualize data interactively using the `QtCharts`
    module. We'll create basic charts and graphs and learn how to build charts using
    a model-view architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try these questions to test your knowledge from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Which steps of the OpenGL render pipeline are user-definable? Which steps *must*
    be defined in order to render anything? You may need to reference the documentation
    at [https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview](https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You're writing a shader for an OpenGL 2.1 program. Does the following look correct?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Is the following a `vertex` or `fragment` shader? How can you tell?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Given the following `vertex` shader, what code do you need to write to assign
    simple values to the two variables?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You enable face culling to save some processing power, but find that several
    of the visible primitives in your drawing are now not rendering. What could the
    problem be?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code do to our OpenGL image?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Experiment with the demo and see whether you can add any of the following features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A more interesting shape (a pyramid, cube, and so on)
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: More controls for moving the object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shadows and lighting effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animated shape changes in the object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For further information, please refer the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A complete tutorial on modern OpenGL programming can be found at [https://paroj.github.io/gltut](https://paroj.github.io/gltut)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packt Publications' *Learn OpenGL*, available at [https://www.packtpub.com/game-development/learn-opengl](https://www.packtpub.com/game-development/learn-opengl),
    is a good resource for learning the basics of OpenGL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A free tutorial on matrix mathematics for 3D graphics is available from Central
    Connecticut State University at [https://chortle.ccsu.edu/VectorLessons/vectorIndex.html](https://chortle.ccsu.edu/VectorLessons/vectorIndex.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
