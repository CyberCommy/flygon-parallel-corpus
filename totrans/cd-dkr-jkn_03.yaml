- en: Configuring Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen how to configure and use Docker. In this chapter, we will present
    Jenkins, which can be used separately or together with Docker. We will show that
    the combination of these two tools outcomes in the surprisingly good results:
    automated configuration and flexible scalability.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Jenkins and its advantages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and starting Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the first pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling Jenkins with agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Docker-based agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building custom master and slave Docker images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring strategies for the security and backup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Jenkins?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jenkins is an open source automation server written in Java. With the very active
    community-based support and a huge number of plugins, it is the most popular tool
    to implement the Continuous Integration and Continuous Delivery processes. Formerly
    known as Hudson, it was renamed after Oracle bought Hudson and decided to develop
    it as the proprietary software. Jenkins remained under the MIT license and is
    highly valued for its simplicity, flexibility, and versatility.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins outstands other Continuous Integration tools and is the most widely
    used software of its kind. That is all possible because of its features and capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Let's walk through the most interesting parts of the Jenkins' characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: '**Language agnostic**: Jenkins has a lot of plugins, which support most of
    the programming languages and frameworks. Moreover, since it can use any shell
    command and any software installed, it is suitable for every automation process
    that can be imagined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensible by plugins**: Jenkins has a great community and a lot of plugins
    available (1000 plus). It also allows you to write your own plugins in order to
    customize Jenkins for your needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portable**: Jenkins is written in Java, so it can be run on any operating
    system. For convenience, it is also delivered in a lot of versions: web application
    archive (WAR), Docker image, Windows binary, Mac binary, and Linux binaries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supports most SCM**: Jenkins integrates with virtually every source code
    management or build tool that exists. Again, because of its wide community and
    plugins, there is no other continuous integration tool that supports so many external
    systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distributed**: Jenkins has a built-in mechanism for the master/slave mode,
    which distributes its executions across multiple nodes located on multiple machines.
    It can also use heterogeneous environment, for example, different nodes can have
    different operating system installed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity**: The installation and configuration process is simple. There
    is no need to configure any additional software, nor the database. It can be configured
    completely via GUI, XML, or Groovy scripts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code-oriented**: Jenkins pipelines are defined as code. Also, the Jenkins
    itself can be configured using XML files or Groovy scripts. That allows keeping
    the configuration in the source code repository and helps in the automation of
    the Jenkins configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Jenkins installation process is quick and simple. There are different methods
    to do it, but since we're already familiar with the Docker tool and the benefits
    it gives, we will start from the Docker-based solution. This is also the easiest,
    the most predictable, and the smartest way to go. However, let's mention the installation
    requirements first.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements for installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The minimal system requirements are relatively low:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 256MB free memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 GB+ free disk space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, it's essential to understand that the requirements strictly depend
    on what you plan to do with Jenkins. If Jenkins is used to serve the whole team
    as the Continuous Integration server, then even in case of a small team, it's
    advised to have 1 GB plus free memory and 50 GB plus free disk space. Needless
    to say, Jenkins also performs some computations and transfers a lot of data across
    the network, so CPU and bandwidth are crucial.
  prefs: []
  type: TYPE_NORMAL
- en: To get a feeling what could be the requirements in case of a big company, the
    Netflix example is presented in the *Jenkins architecture* section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing on Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s see the step-by-step procedure to install Jenkins using Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Jenkins image is available in the official Docker Hub registry, so in order
    to install it we should execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We need to specify the first `host_port` parameter—the port under which Jenkins
    is visible outside of the container. The second parameter, `host_volume`, specifies
    the directory where the Jenkins home is mapped. It needs to be specified as volume,
    and therefore persisted permanently, because it contains the configuration, pipeline
    builds, and logs.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let's see what the installation steps would look like in case
    of the Docker host on Linux/Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: '**Prepare the volume directory**: We need a separate directory with the admin
    ownership to keep the Jenkins home. Let''s prepare one with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Run the Jenkins container**: Let''s run the container as a daemon and give
    it a proper name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '** Check if Jenkins is running**: After a moment, we can check whether Jenkins
    has started correctly by printing the logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the production environment, you may also want to set up the reverse proxy
    in order to hide the Jenkins infrastructure behind the proxy server. The short
    description how to do it using the Nginx server can be found at [https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins+with+Docker](https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins+with+Docker).
  prefs: []
  type: TYPE_NORMAL
- en: 'After performing these few steps, Jenkins is ready to use. The Docker-based
    installation has two major advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Failure recovery**: If Jenkins crashes, then it''s enough to run a new container
    with the same volume specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom images**: You can configure Jenkins as per your needs and store it
    as the Jenkins image. Then it can be shared within your organization or team,
    and there is no need to repeat the same configuration steps all the time, many
    times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everywhere in this book, we use Jenkins in version 2.60.1.
  prefs: []
  type: TYPE_NORMAL
- en: Installing without Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the reasons mentioned earlier, the Docker installation is recommended.
    However, if it''s not an option or there are other reasons to proceed otherwise,
    then the installation process is just as simple. As an example, in case of Ubuntu,
    it''s enough to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: All installation guides (Ubuntu, Mac, Windows, and others) can be found on the
    official Jenkins page [https://jenkins.io/doc/book/getting-started/installing/](https://jenkins.io/doc/book/getting-started/installing/).
  prefs: []
  type: TYPE_NORMAL
- en: Initial configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'No matter which installation you choose, the first start of Jenkins requires
    a few configuration steps. Let''s walk through them step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Jenkins in the browser: `http://localhost:49001` (for binary installations,
    the default port is `8080`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Jenkins should ask for the administrator password. It can be found in the Jenkins
    logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After accepting the initial password, Jenkins asks whether to install the suggested
    plugins, which are adjusted to the most common use cases. Your answer depends,
    of course, on your needs. However, as the first Jenkins installation, it's reasonable
    to let Jenkins install all the recommended plugins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the plugin installation, Jenkins asks to set up username, password, and
    other basic information. If you skip it, the token from step 2 will be used as
    the admin password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The installation is complete and you should see the Jenkins dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5823b433-89cb-43d1-a878-8f7995171901.png)'
  prefs: []
  type: TYPE_IMG
- en: We are ready to use Jenkins and create the first pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins hello world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything in the entire IT world starts from the Hello World example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s follow this rule and see the steps to create the first Jenkins pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on New Item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `hello world` as the item name, choose Pipeline, and click on OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are a lot of options. We will skip them for now and go directly to the
    Pipeline section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There, in the Script textbox, we can enter the pipeline script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Click on Save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Build Now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We should see #1 under the Build History. If we click on it, and then on Console
    Output, we will see the log from the Pipeline build.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/28b3c9dd-cd74-4912-a9af-b7b3a7724347.png)'
  prefs: []
  type: TYPE_IMG
- en: We have just seen the first example and its successful output means that Jenkins
    is installed correctly. Now, let's move to slightly more advanced Jenkins configuration.
  prefs: []
  type: TYPE_NORMAL
- en: We will describe more on the pipeline syntax in [Chapter 4](a07d252d-3812-45ad-a567-1c70dae74d9d.xhtml),
    *Continuous Integration Pipeline*.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The hello world job executed in almost no time at all. However, the pipelines
    are usually more complex and spend time on tasks such as downloading files from
    the internet, compiling the source code, or running tests. One build can take
    from minutes to hours.
  prefs: []
  type: TYPE_NORMAL
- en: In common scenarios, there are also many concurrent pipelines. Usually, the
    whole team, or even the whole organization, uses the same Jenkins instance. How
    to ensure that the builds will run quickly and smoothly?
  prefs: []
  type: TYPE_NORMAL
- en: Master and slaves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jenkins becomes overloaded sooner than it seems. Even in case of a small (micro)
    service, the build can take a few minutes. That means that one team committing
    frequently can easily kill the Jenkins instance.
  prefs: []
  type: TYPE_NORMAL
- en: For that reason, unless the project is really small, Jenkins should not execute
    builds at all, but delegate them to the slave (agent) instances. To be precise,
    the Jenkins we're currently running is called the Jenkins master and it can delegate
    to the Jenkins agents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the diagram presenting the master-slave interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1d28685d-ac8c-474b-9052-ed0f1e340e33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In a distributed builds environment, the Jenkins master is responsible for:'
  prefs: []
  type: TYPE_NORMAL
- en: Receiving build triggers (for example, after a commit to GitHub)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending notifications (for example, email or HipChat message sent after the
    build failure)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling HTTP requests (interaction with clients)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the build environment (orchestrating the job executions on slaves)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The build agent is a machine that take care of everything that happens after
    the build is started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the responsibilities of the master and the slaves are different, they
    have different environmental requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Master**: This is usually (unless the project is really small) a dedicated
    machine with RAM ranging from 200 MB for small projects to 70GB plus for huge
    single-master projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slave**: There are no general requirements (other than the fact that it should
    be capable of executing a single build, for example, if the project is a huge
    monolith that requires 100 GB of RAM, then the slave machine needs to satisfy
    these needs).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Agents should also be as generic as possible. For instance, if we have different
    projects: one in Java, one in Python, and one in Ruby, then it would be perfect
    if each agent could build any of these projects. In such a case, the agents can
    be interchanged, which helps to optimize the usage of resources.'
  prefs: []
  type: TYPE_NORMAL
- en: If agents cannot be generic enough to match all projects, then it's possible
    to label (tag) agents and projects, so that the given build would be executed
    on a given type of agent.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use Jenkins slaves to balance the load and scale up the Jenkins infrastructure.
    Such a process is called the horizontal scaling. The other possibility would be
    to use only one master node and increase resources of its machine. That process
    is called the vertical scaling. Let's look closer at these two concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Vertical scaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vertical scaling means that, when the master''s load grows, then more resources
    are applied to the master''s machine. So, when new projects appear in our organization,
    we buy more RAM, add CPU cores, and extend the HDD drives. This may sound like
    a no-go solution; however, it''s often used, even by well-known organizations.
    Having a single Jenkins master set on the ultra-efficient hardware has one very
    strong advantage: maintenance. Any upgrades, scripts, security settings, roles
    assignment, or plugin installations have to be done in one place only.'
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal scaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Horizontal scaling means that, when an organization grows, then more master
    instances are launched. This requires a smart allocation of instances to teams
    and, in the extreme case, each team can have its own Jenkins master. In that case,
    it might even happen that no slaves are needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The drawbacks are that it may be difficult to automate cross-project integrations
    and that a part of the team''s development time is spent on the Jenkins maintenance.
    However, the horizontal scaling has some significant advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Master machines don't need to be special in terms of hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different teams can have different Jenkins settings (for example, different
    set of plugins)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teams usually feel better and work with Jenkins more efficiently if the instance
    is their own
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If one master instance is down, it does not impact the whole organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The infrastructure can be segregated into standard and mission-critical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some maintenance aspects can be simplified, for example, the team of five could
    reuse the same Jenkins password, so we may skip the roles and security settings
    (surely that is possible only if the corporate network is well firewalled)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test and production instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from the scaling approach, there is one more issue: how to test the Jenkins
    upgrades, new plugins, or pipeline definitions? Jenkins is critical to the whole
    company. It guarantees the quality of the software and (in case of Continuous
    Delivery) deploys to the production servers. That is why it needs to be highly
    available, so it is definitely not for the purpose of testing. It means there
    should always be two instances of the same Jenkins infrastructure: test and production.'
  prefs: []
  type: TYPE_NORMAL
- en: Test environment should always be as similar as possible to the production,
    so it also requires the similar number of agents attached.
  prefs: []
  type: TYPE_NORMAL
- en: Sample architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know that there should be slaves, (possibly multiple) master(s),
    and that everything should be duplicated into the test and production environments.
    However, what would the complete picture look like?
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, there are a lot of companies that published how they used Jenkins and
    what kind of architectures they created. It would be difficult to measure if more
    of them preferred vertical or horizontal scaling, but it ranged from having only
    one master instance to having one master for each team.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the example of Netflix to have a complete picture of the Jenkins
    infrastructure (they shared it as the **planned infrastructure** at Jenkins User
    Conference San Francisco 2012):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/df2ac293-dafb-433e-8d17-f0f7ff006e6a.png)'
  prefs: []
  type: TYPE_IMG
- en: They have test and production master instances, each of them owning a poll of
    slaves and additional ad hoc slaves. Altogether, it serves around 2000 builds
    per day. Note also that a part of their infrastructure is hosted on AWS and a
    part is on their own servers.
  prefs: []
  type: TYPE_NORMAL
- en: We should already have at least a rough idea of what the Jenkins infrastructure
    can look like depending on the type of the organization.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now focus on the practical aspects of setting the agents.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen what the agents are and when they can be used. However, how to set
    up an agent and let it communicate with the master? Let's start with the second
    part of the question and describe the communication protocols between the master
    and the agent.
  prefs: []
  type: TYPE_NORMAL
- en: Communication protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order for the master and the agent to communicate, the bi-directional connection
    has to be established.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different options how it can be initiated:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SSH**: Master connects to slave using the standard SSH protocol. Jenkins
    has an SSH-client built-in, so the only requirement is the SSHD server configured
    on slaves. This is the most convenient and stable method because it uses standard
    Unix mechanisms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java Web Start**: Java application is started on each agent machine and the
    TCP connection is established between the Jenkins slave application and the master
    Java application. This method is often used if the agents are inside the firewalled
    network and the master cannot initiate the connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows service**: The master registers an agent on the remote machine as
    a Windows service. This method is discouraged since the setup is tricky and there
    are limitations on the graphical interfaces usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we know the communication protocols, let's see how we can use them to set
    the agents.
  prefs: []
  type: TYPE_NORMAL
- en: Setting agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the low level, agents communicate with the Jenkins master always using one
    of the protocols described above. However, at the higher level, we can attach
    slaves to the master in various ways. The differences concern two aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**static versus dynamic**: The simplest option is to add slaves permanently
    in the Jenkins master. The drawback of such solution is that we always need to
    manually change something if we need more (or less) slave nodes. A better option
    is to dynamically provision slaves as they are needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**specific versus general-purpose**: Agents can be specific (for example, different
    agents for the projects based on Java 7 and different agents for Java 8) or general-purpose
    (an agent acts as a Docker host and a pipeline is built inside a Docker container).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These differences resulted in four common strategies how agents are configured:'
  prefs: []
  type: TYPE_NORMAL
- en: Permanent agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permanent Docker agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins Swarm agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically provisioned Docker agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's examine each of the solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Permanent agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We start from the simplest option which is to permanently add specific agent
    nodes. It can be done entirely via the Jenkins web interface.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring permanent agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Jenkins master, when we open Manage Jenkins and then Manage Nodes, we
    can view all the attached agents. Then, by clicking on New Node, giving it a name,
    and confirming with the OK button, we should finally see the agent''s setup page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8cc335f3-a054-4fe9-851d-a08de74aa7cc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s walk through the parameters we need to fill:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: This is the unique name of the agent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: This is any human-readable description of the agent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**# of executors**: This is the number of concurrent builds that can be run
    on the slave'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote root directory**: This is the dedicated directory on the slave machine
    that the agent can use to run build jobs (for example, `/var/jenkins`); the most
    important data is transferred back to the master, so the directory is not critical'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Labels**: This includes the tags to match only the specific builds (tagged
    the same), for example, only projects based on Java 8'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usage**: This is the option to decide whether the agent should be used only
    for matched labels (for example, only for Acceptance Testing builds) or for any
    builds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Launch method**: This includes the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Launch agent via Java Web Star**t: Here, the connection will be established
    by the agent; it is possible to download the JAR file and the instructions on
    how to run it on the slave machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Launch agent via execution of command on the master**: This is the custom
    command run on the master to start the slave; in most cases it will send the Java
    Web Start JAR application and start it on the slave (for example, `ssh <slave_hostname>
    java -jar ~/bin/slave.jar`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Launch slave agents via SSH:** Here, the master will connect to the slave
    using the SSH protocol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Let Jenkins control this Windows slave as a Windows service**: Here, the
    master will start a remote management facility built into Windows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Availability**: This is the option to decide whether the agent should be
    up all the time or the master should turn it offline under certain conditions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the agents are set up correctly, it's possible to switch the master node
    offline, so that no builds would be executed on it and it would serve only as
    the Jenkins UI and the builds' coordinator.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding permanent agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As already mentioned, the drawback of such a solution is that we need to maintain
    multiple slave types (labels) for different project types. Such a situation is
    presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/43523171-6bcf-41c4-bed4-3658b0e1437c.png)'
  prefs: []
  type: TYPE_IMG
- en: In our example, if we have three types of projects (**java7**, **java8**, and
    **ruby**), then we need to maintain three separately labeled (sets of) slaves.
    That is the same issue we had while maintaining multiple production server types,
    as described in [Chapter 2](aa58c16d-41c0-4364-9eae-26b60a05c510.xhtml), *Introducing
    Docker*. We addressed the issue by having the Docker Engine installed on the production
    servers. Let's try to do the same with Jenkins slaves.
  prefs: []
  type: TYPE_NORMAL
- en: Permanent Docker agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea behind this solution is to permanently add general-purpose slaves.
    Each slave is identically configured (Docker Engine installed) and each build
    is defined together with the Docker image inside which the build is run.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring permanent Docker agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The configuration is static, so it's done exactly the same way as we did for
    the permanent agents. The only difference is that we need to install Docker on
    each machine that will be used as a slave. Then, we usually don't need labels
    because all slaves can be the same. After the slaves are configured, we define
    the Docker image in each pipeline script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When the build is started, the Jenkins slave starts a container from the Docker
    image `openjdk:8-jdk-alpine` and then executes all pipeline steps inside that
    container. This way, we always know the execution environment and don't have to
    configure each slave separately depending on the particular project type.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding permanent Docker agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Looking at the same scenario we took for the permanent agents, the diagram
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/243f8a95-9de6-4851-bc72-5ec31765a752.png)'
  prefs: []
  type: TYPE_IMG
- en: Each slave is exactly the same and if we would like to build a project that
    depends on Java 8, then we define the appropriate Docker image in the pipeline
    script (instead of specifying the slave label).
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins Swarm agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we always had to permanently define each of the agents in the Jenkins
    master. Such a solution, even though good enough in many cases, can be a burden
    if we need to frequently scale the number of slave machines. Jenkins Swarm allows
    you to dynamically add slaves without the need to configure them in the Jenkins
    master.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Jenkins Swarm agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step to use Jenkins Swarm is to install the **Self-Organizing Swarm
    Plug-in Modules** plugin in Jenkins. We can do it via the Jenkins web UI under
    Manage Jenkins and Manage Plugins. After this step, the Jenkins master is prepared
    for Jenkins slaves to be dynamically attached.
  prefs: []
  type: TYPE_NORMAL
- en: The second step is to run the Jenkins Swarm slave application on every machine
    that would act as a Jenkins slave. We can do it using the `swarm-client.jar` application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `swarm-client.jar` application can be downloaded from the Jenkins Swarm
    plugin page: [https://wiki.jenkins-ci.org/display/JENKINS/Swarm+Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Swarm+Plugin).
    On that page, you can also find all the possible options of its execution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to attach the Jenkins Swarm slave node, it''s enough to run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: By the time of writing this book, there was an open bug that `client-slave.jar`
    didn't work via the secured HTTPS protocol, so it was necessary to add the `-disableSslVerification` option
    to the command execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the successful execution, we should notice that a new slave appeared
    on the Jenkins master as presented on the screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/644e56d6-3e6e-4509-878c-b9fed436136b.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, when we run a build, it will be started on this agent.
  prefs: []
  type: TYPE_NORMAL
- en: The other possibility to add the Jenkins Swarm agent is to use the Docker image
    built from the `swarm-client.jar` tool. There are a few of them available on the
    Docker Hub. We can use the `csanchez/jenkins-swarm-slave` image.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Jenkins Swarm agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jenkins Swarm allows to dynamically add agents, but it says nothing about whether
    to use specific or Docker-based slaves, so we can use it for both. At first glance,
    Jenkins Swarm may not seem very useful. After all, we moved setting agents from
    master to slave, but still have to do it manually. However, as we will see later
    in [Chapter 8](05fbbfd9-ff58-4ee8-be5d-90cb291f6320.xhtml), *Clustering with Docker
    Swarm*, Jenkins Swarm enables dynamic scaling of slaves on a cluster of servers.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically provisioned Docker agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another option is to set up Jenkins to dynamically create a new agent each time
    a build is started. Such a solution is obviously the most flexible one since the
    number of slaves dynamically adjust to the number of builds. Let's have a look
    at how to configure Jenkins this way.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring dynamically provisioned Docker agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to first install the Docker plugin. As always with Jenkins plugins,
    we can do in Manage Jenkins and Manage Plugins. After the plugin is installed,
    we can start the following configuration steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Manage Jenkins page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Configure System link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the bottom of the page, there is the Cloud section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Add a new cloud and choose Docker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill the Docker agent details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/98d44429-9c8f-451e-9744-68fe5b895396.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Most parameters do not need to be changed; however, we need to set two of them
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Docker URL**: The address of the Docker host machine where agents will be
    run'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Credentials**: The credentials in case the Docker host requires authentication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you plan to use the same Docker host where the master is running, then the
    Docker daemon needs to listen on the `docker0` network interface. You can do it
    in a similar way as described in the *Installing on a server* section ofts of)
    slaves. That is the same issue we had while maintaining multiple production server
    types, as described in [Chapter 2](aa58c16d-41c0-4364-9eae-26b60a05c510.xhtml), *Introducing
    Docker*, by changing one line in the `/lib/systemd/system/docker.service` file
    to `ExecStart=/usr/bin/dockerd -H 0.0.0.0:2375 -H fd://`
  prefs: []
  type: TYPE_NORMAL
- en: Click on Add Docker Template and select Docker Template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fill the details about the Docker slave image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f56c7001-d4c7-466c-b687-ad946d915267.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can use the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Image**: The most popular slave image from the Jenkins community is
    `evarga/jenkins-slave`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Credentials**: The credentials to the `evarga/jenkins-slave` image are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'username: `jenkins`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'password: `jenkins`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instance capacity**: This defines the maximum number of agents running at
    the same time; for the beginning, it can be set to 10'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of `evarga/jenkins-slave`, it's possible to build and use your own slave
    images. This is necessary when there are specific environment requirements, for
    example, the Python interpreter installed. In all examples for this book we used `leszko/jenkins-docker-slave`.
  prefs: []
  type: TYPE_NORMAL
- en: After saving, everything is set up. We could run the pipeline to observe that
    the execution really takes place on the Docker agent, but first let's dig a little
    deeper to understand how the Docker agents work.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding dynamically provisioned Docker agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamically provisioned Docker agents can be treated as a layer over the standard
    agent mechanism. It changes neither the communication protocol nor how the agent
    is created. So, what does Jenkins do with the Docker agent configuration we provided?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram presents the Docker master-slave architecture we''ve
    configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cba2207e-e746-428b-950c-da8e766e7886.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s describe step by step how the Docker agent mechanism is used:'
  prefs: []
  type: TYPE_NORMAL
- en: When the Jenkins job is started, the master runs a new container from the `jenkins-slave`
    image on the slave Docker host.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The jenkins-slave container is, actually, the ubuntu image with the SSHD server
    installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Jenkins master automatically adds the created agent to the agent list (same
    as what we did manually in the *Setting agents* section).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The agent is accessed using the SSH communication protocol to perform the build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the build, the master stops and removes the slave container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running Jenkins master as a Docker container is independent from running Jenkins
    agents as Docker containers. It's reasonable to do both, but any of them will
    work separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is somehow similar to the permanent Docker agents solution, because
    in result, we run the build inside a Docker container. The difference is, however,
    in the slave node configuration. Here, the whole slave is dockerized, not only
    the build environment. Therefore, it has two great advantages as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automatic agent lifecycle**: The process of creating, adding, and removing
    the agent is automated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Actually, the slave Docker host could be not a single machine,
    but a cluster composed of multiple machines (we''ll cover clustering using Docker
    Swarm in [Chapter 8](05fbbfd9-ff58-4ee8-be5d-90cb291f6320.xhtml), *Clustering
    with Docker Swarm*). In that case, adding more resources is as simple as adding
    a new machine to the cluster and does not require any changes in Jenkins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins build usually needs to download a lot of project dependencies (for example,
    Gradle/Maven dependencies), which may take a lot of time. If Docker slaves are
    automatically provisioned for each build, then it may be worth to set up a Docker
    volume for them to enable caching between the builds.
  prefs: []
  type: TYPE_NORMAL
- en: Testing agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No matter which agent configuration you chose, we should now check if it works
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the hello world pipeline. Usually, the builds last longer
    than the hello-world example, so we can simulate it by adding sleeping to the
    pipeline script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After clicking on Build Now and going to the Jenkins main page, we should see
    that the build is executed on an agent. Now, if we click on build many times,
    then different agents should be executing different builds (as shown in the following
    screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b1e20218-bee3-4352-a90f-5e613c98d421.png)To prevent job executions
    on master, remember about turning the master node offline or setting **# of executors** to
    `0` in the Manage Nodes configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: Having seen that the agents are executing our builds, we've confirmed that they
    are configured correctly. Now, let's see how and for what reason we could create
    our own Jenkins images.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Jenkins images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have used the Jenkins images pulled from the internet. We used `jenkins`
    for the master container and `evarga/jenkins-slave` for the slave container. However,
    we may want to build our own images to satisfy the specific build environment
    requirements. In this section, we cover how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Building Jenkins slave
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start from the slave image, because it's more often customized. The build
    execution is performed on the agent, so it's the agent that needs to have the
    environment adjusted to the project we would like to build. For example, it may
    require the Python interpreter if our project is written in Python. The same is
    applied to any library, tool, testing framework, or anything that is needed by
    the project.
  prefs: []
  type: TYPE_NORMAL
- en: You can check what is already installed inside the `evarga/jenkins-slave` image
    by looking at its Dockerfile at [https://github.com/evarga/docker-images](https://github.com/evarga/docker-images).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three steps to build and use the custom image:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Dockerfile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the agent configuration on master.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As an example, let''s create a slave that serves the Python project. We can
    build it on top of the `evarga/jenkins-slave` image for the sake of simplicity.
    Let''s do it using the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dockerfile**:Let''s create a new directory inside the Dockerfile with the
    following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The base Docker image `evarga/jenkins-slave` is suitable for the dynamically
    provisioned Docker agents solution. In case of permanent Docker agents, it's enough
    to use `alpine`, `ubuntu`, or any other image, since it's not the slave that is
    dockerized, but only the build execution environment.
  prefs: []
  type: TYPE_NORMAL
- en: '**Build the image**: We can build the image by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Configure the master**: The last step, of course, is to set `jenkins-slave-python`
    instead of `evarga/jenkins-slave` in the Jenkins master''s configuration (as described
    in the *Setting Docker agent* section).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The slave Dockerfile should be kept in the source code repository and the image
    build can be performed automatically by Jenkins. There is nothing wrong with building
    the new Jenkins slave image using the old Jenkins slave.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we need Jenkins to build two different kinds of projects, for example,
    one based on Python and another based on Ruby? In that case, we could prepare
    an agent, which is generic enough to support both: Python and Ruby. However, in
    case of Docker, it''s recommended to create the second slave image (`jenkins-slave-ruby`
    by analogy). Then, in the Jenkins configuration we need to create two Docker templates
    and label them accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: Building Jenkins master
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already have a custom slave image. Why would we also want to build our own
    master image? One of the reasons might be that we don't want to use slaves at
    all, and, since the execution would be done on master, its environment has to
    be adjusted to the project's needs. That is, however, a very rare case. More often,
    we will want to configure the master itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine the following scenario, your organization scales Jenkins horizontally
    and each team has its own instance. There is, however, some common configuration,
    for example: a set of base plugins, backup strategies, or the company logo. Then,
    repeating the same configuration for each of the teams is a waste of time. So,
    we can prepare the shared master image and let the teams use it.'
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins is configured using XML files and it provides the Groovy-based DSL language
    to manipulate over them. That is why we can add the Groovy script to the Dockerfile
    in order to manipulate the Jenkins configuration. What is more, there are special
    scripts to help with the Jenkins configuration if it requires something more than
    XML changes, for instance, plugin installation.
  prefs: []
  type: TYPE_NORMAL
- en: All possibilities of the Dockerfile instructions are well described on the GitHub
    page [https://github.com/jenkinsci/docker](https://github.com/jenkinsci/docker).
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s create a master image with the docker-plugin already
    installed and a number of executors set to 5\. In order to do it, we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the Groovy script to manipulate on `config.xml` and set the number of
    executors to `5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the Dockerfile to install docker-plugin and execute the Groovy script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's use the three steps mentioned and build the Jenkins master image.
  prefs: []
  type: TYPE_NORMAL
- en: '** Groovy script**: Let''s create a new directory inside the `executors.groovy` file
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The complete Jenkins API can be found on the official page [http://javadoc.jenkins.io/](http://javadoc.jenkins.io/).
  prefs: []
  type: TYPE_NORMAL
- en: '** Dockerfile**: In the same directory, let''s create the Dockerfile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '** Build the image**: We can finally build the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After the image is created, each team in the organization can use it to launch
    their own Jenkins instance.
  prefs: []
  type: TYPE_NORMAL
- en: Having our own master and slave images lets us provide the configuration and
    the build environment for the teams in our organization. In the next section,
    we'll see what else is worth being configured in Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration and management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already covered the most crucial part of the Jenkins configuration:
    agents provisioning. Since Jenkins is highly configurable, you can expect much
    more possibilities to adjust it to your needs. The good news is that the configuration
    is intuitive and accessible via the web interface, so it does not require any
    detailed description. Everything can be changed under the Manage Jenkins subpage.
    In this section, we will focus only on a few aspects that are most likely to be
    changed: plugins, security, and backup.'
  prefs: []
  type: TYPE_NORMAL
- en: Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jenkins is highly plugin-oriented, which means that a lot of features are delivered
    by the use of plugins. They can extend Jenkins almost in the unlimited way, which,
    taking into consideration the large community, is one of the reasons why Jenkins
    is such a successful tool. With Jenkins' openness, comes the risk and it's better
    to download plugins only from the reliable source or check their source code.
  prefs: []
  type: TYPE_NORMAL
- en: There are literally tons of plugins to choose from. Some of them were already
    installed automatically during the initial configuration. Another one (Docker
    plugin) was installed while setting the Docker agents. There are plugins for cloud
    integration, source control tools, code coverage, and much more. You can also
    write your own plugin, but it's better to check first if the one you need is not
    already written.
  prefs: []
  type: TYPE_NORMAL
- en: There is an official Jenkins page to browse plugins from [https://plugins.jenkins.io/](https://plugins.jenkins.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way you should approach the Jenkins security depends on the Jenkins architecture
    you have chosen within your organization. If you have a Jenkins master for every
    small team, then you may not need it at all (under the assumption that the corporate
    network is firewalled). However, if you have a single Jenkins master instance
    for the whole organization, then you'd better be sure you secured it well.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins comes with its own user database-we have already created a user during
    the initial configuration process. You can create, delete, and modify users by
    opening the Manage Users setting page. The built-in database can be a solution
    in case of small organizations; however, for the large group of users, you will
    probably want to use LDAP instead. You can choose it on the Configure Global Security page.
    There, you can also assign roles, groups, and users. By default, the Logged-in
    users can do anything option is set, but in a large-scale organization you should
    probably think of more detailed granularity.
  prefs: []
  type: TYPE_NORMAL
- en: Backup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the old saying goes: <q>There are two types of people: those who backup,
    and those who will backup</q>. Believe it or not, the backup is something you
    probably want to configure. What files to back up and from which machines? Luckily,
    agents automatically send all the relevant data back to the master, so we don''t
    need to bother about them. If you run Jenkins in the container, then the container
    itself is also not interesting, since it does not hold any persistent state. The
    only place we are interested in is the Jenkins home directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can either install a Jenkins plugin (which will help us to set periodic
    backups) or simply set a cron job to archive the directory into a safe place.
    To reduce the size, we can exclude the subfolders which are not interesting (that
    will depend on your needs; however, almost certainly, you don''t need to copy:
    "war", "cache", "tools", and "workspace").'
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few plugins, which can help with the backup process; the most
    common one is called **Backup Plugin**.
  prefs: []
  type: TYPE_NORMAL
- en: Blue Ocean UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first version of Hudson (former Jenkins) was released in 2005\. It's been
    on the market for more than 10 years now. However, its look and feel hasn't changed
    much. We've already used it for a while and it's hard to deny that it looks outdated.
    Blue Ocean is the plugin, which redefines the user experience of Jenkins. If Jenkins
    is aesthetically displeasing to you, then it's definitely worth giving a try.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more on the Blue Ocean page at [https://jenkins.io/projects/blueocean/](https://jenkins.io/projects/blueocean/).![](assets/8bc21c85-2ef8-4974-8bdf-24d022228c4f.png)
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned a lot about Jenkins configuration throughout this chapter. To
    consolidate the knowledge, we recommend two exercises on preparing the Jenkins
    images and testing the Jenkins environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create Jenkins master and slave Docker images and use them to run the Jenkins
    infrastructure capable of building the Ruby projects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the master Dockerfile, which automatically installs the Docker plugin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build the master image and run the Jenkins instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the slave Dockerfile (suitable for the dynamic slave provisioning), which
    installs the Ruby interpreter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build the slave image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the configuration in the Jenkins instance to use the slave image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a pipeline, which runs a Ruby script printing `Hello World from Ruby`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the following shell command to create the `hello.rb` script on the fly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sh "echo "puts ''Hello World from Ruby''" > hello.rb"`'
  prefs: []
  type: TYPE_NORMAL
- en: Add the command to run `hello.rb` using the Ruby interpreter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the build and observe the console output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have covered the Jenkins environment and its configuration.
    The knowledge gained is sufficient to set up the complete Docker-based Jenkins
    infrastructure. The key takeaway from the chapter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins is a general-purpose automation tool that can be used with any language
    or framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins is highly extensible by plugins, which can be written or found on the
    internet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins is written in Java, so it can be installed on any operating system.
    It's also officially delivered as a Docker image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins can be scaled using the master-slave architecture. The master instances
    can be scaled horizontally or vertically depending on the organization's needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins' agents can be implemented with the use of Docker, which helps in automatic
    configuration and dynamic slaves allocation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Custom Docker images can be created for both: Jenkins master and Jenkins slave.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jenkins is highly configurable and the aspects that should always be considered
    are: security and backups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on the part that we've already touched with
    the "hello world" example, pipelines. We will describe the idea and the method
    to build a complete Continuous Integration pipeline.
  prefs: []
  type: TYPE_NORMAL
