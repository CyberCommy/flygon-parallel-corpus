- en: Chapter 3. Communicating Between Nodes via SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSH is one of the most important tools for a Linux network administrator. It
    allows you to connect to servers and other workstations remotely, and work on
    them from within your favorite terminal emulator—all from the comfort of your
    desk. While SSH might not be the perfect tool for every situation, it's one of
    those that you won't be able to imagine life without, once you start using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we explore SSH and cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using OpenSSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and configuring OpenSSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to network hosts via openssh-client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OpenSSH config file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and utilizing `scp`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transferring files to another node via `scp`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tunneling traffic via SSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating public keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping SSH connections alive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring an alternative to SSH – utilizing Mosh (mobile shell)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using OpenSSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SSH**, or **Secure Shell**, is a very handy utility. SSH is not an absolute
    requirement for performing tasks in your server room, but it is one of those things
    that will make your life a lot easier. With SSH, you are able to execute commands
    on a different Linux machine as though you were sitting right there in front of
    it. Sure, you could always walk into your server room, grab the keyboard, and
    start working, but nowadays remote administration is the name of the game. This
    is especially true if it''s your turn to be on call and an issue comes up at the
    office. Depending on the nature of the issue, SSH may allow you to fix the problem
    from home (or even on your smart phone) without having to make the trek all the
    way to your company''s server room. That''s not all; SSH also allows you to copy
    files from one machine to another and set up an actual storage mount to a directory
    on a server, which can be treated, on your workstation, like the directory were
    a local part of your filesystem.'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of connecting to a remote host and opening a command shell is not
    new, and SSH is not the first to do it. Other solutions, such as telnet or rlogin,
    have existed for quite a while. What makes SSH desirable is that it is more secure
    than earlier technologies, as communication is encrypted. There are two protocols
    for SSH, protocol 1 and protocol 2\. Protocol 1 should not be used under any circumstances,
    as it is no longer secure. Traffic sent between two hosts utilizing protocol 1
    could be intercepted by an attacker. We will discuss this aspect of SSH in [Chapter
    9](ch09.html "Chapter 9. Securing Your Network"), *Securing Your Network*, but
    for now I want to make sure that you understand that you shouldn't use an SSH
    connection with protocol 1\. You should not offer protocol 1 to any of your hosts.
    Nowadays, protocol 2 is the default.
  prefs: []
  type: TYPE_NORMAL
- en: By default, SSH uses port 22 to communicate. If this port is blocked by a firewall,
    you will not be able to connect. This is extremely common in Windows-centric businesses,
    since SSH is more common in the Linux/UNIX world. By changing the configuration
    of the SSH server, you can configure it to listen on any port you like. While
    we won't get into how to configure this just yet (we'll discuss this in [Chapter
    9](ch09.html "Chapter 9. Securing Your Network"), *Securing Your Network*), it's
    mentioned here because it's important to note that you may run into a situation
    where you aren't able to connect to an SSH server, for example, when the port
    is either closed or has been changed to a different one.
  prefs: []
  type: TYPE_NORMAL
- en: Although I mentioned that learning SSH isn't actually required to perform tasks
    on a server or workstation, it is highly recommended that you spend time to learn
    it. Not only do companies that utilize Linux servers expect you to know it, you
    won't want to miss out on its advantages. Thankfully, as useful as SSH is, it's
    by no means difficult to learn. You could easily learn the most basic functionality
    in five minutes, or advanced usage within a week.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring OpenSSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenSSH comes in two pieces, the client application and the server application.
    It's likely that the client application is installed by default in your distribution.
    The client allows you to connect to other nodes via SSH, but having the client
    alone doesn't allow others to connect to you. If you want to access a machine
    via SSH, that machine must also have the SSH server application installed. Your
    chosen distribution may have the server application installed by default, but
    most don't. This is due to security—unless you absolutely need to have an application
    running and listening for connections, it should be absent. The fewer applications,
    the smaller the attack surface someone could use against you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Debian, SSH server is an option during the installation process. If selected,
    the server application of SSH will be present and will start by default. To check
    whether the SSH server package is installed on a Debian system, execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output, if the first character is `i`, then the package is installed.
    You can check whether the **sshd** service is running with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If the service isn''t running, you can start it by executing the following
    command on Debian:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'On Debian, you can check the status of the SSH service by executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If it''s running, the output should include `active (running)`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If your system doesn''t have the SSH server package installed, you can install
    it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After you''ve installed the package, check the status of the service with the
    following command to see if it''s enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, it won't start automatically the next time you boot the machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'In CentOS, you also use the `systemctl` command in order to check the status
    of the SSH service, though the daemon is named a bit differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous command in Debian, the service was named `ssh.service`. In
    CentOS, it''s named `sshd.service`. In CentOS, both the client and server packages
    for SSH are installed by default, so you should already have them as soon as your
    CentOS system finishes installation. If you don''t have the package installed
    for some reason, you can install it via `yum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After installation, ensure that the service is enabled by checking the status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If the SSH service is not in an enabled state (start on boot), execute the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that SSH is installed on your machines, we're ready to start using it.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to network hosts via openssh-client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this experiment, you'll need at least one Linux installation with the SSH
    server active, and another with at least the SSH client installed. For the client,
    you'll need to either install the `openssh-clients` package in CentOS, or the
    `openssh-client` package in Debian. The client package for SSH is installed by
    default on both, so you shouldn't need to install it unless the package was removed.
    For this activity, it doesn't matter which distribution is on the server or the
    client end of the connection. Feel free to mix it up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, all we need is to record the IP addresses of the node we wish to connect
    to. Regardless of the distribution, you should be able to discover the IP address
    by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To connect to that machine via SSH, execute the `ssh` command against the IP
    address of the host. For example, if the host you want to connect to has an IP
    address `192.168.1.201`, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as your username is the same on both sides, that command should ask
    for your password and then let you in. If your username is different on the host
    you''re attempting to connect to, add the appropriate username to the command
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With SSH, you can connect to another Linux installation using any username that
    exists there, as long as you know the password for it. In fact, depending on how
    the distribution was configured by the vendor, you may even be able to log in
    directly as root. In CentOS, root login is enabled by default. In Debian, root
    login via SSH is not allowed unless you're using an RSA key (we'll discuss this
    in [Chapter 9](ch09.html "Chapter 9. Securing Your Network"), *Securing Your Network*).
    Although we'll discuss more about security (including how to allow/disallow users)
    in that chapter, for now it's important to understand that allowing root access
    to a system via SSH is a very bad idea; I hope that you'll keep this disabled
    on production servers and workstations. If you wish to disable root access now,
    go to the relevant section of [Chapter 9](ch09.html "Chapter 9. Securing Your
    Network"), *Securing Your Network*, and then come back here.
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH also allows you to specify a host name rather than an IP address. In fact,
    host names are the preferred method since it''s difficult to memorize IP addresses
    if you have a great number of machines in your network. SSH itself doesn''t resolve
    host names; it relies on DNS for that. If the DNS server on your network has an
    A (address) record for the machine you wish to connect to, you should be able
    to use the host name instead of the IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the machine doesn't have a DNS entry in your network, or if you have yet
    to set up a DNS server, don't worry. We'll discuss setting up our very own DNS
    (bind) server in [Chapter 6](ch06.html "Chapter 6. Configuring Network Services"),
    *Configuring Network Services*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important aspect of connecting to a host is specifying a port. As mentioned
    earlier, the default port is 22\. If you don''t specify a port, then port 22 is
    assumed. If you need to specify a different port, you can do so with the `-p`
    flag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After a successful connection, you should have a command prompt to a shell on
    the target machine. From here, you can install packages, manage users, configure
    the network, or do anything else that you'd be able to do if you were able to
    log in to the machine in person. Your only limit is whatever permissions your
    user has to the system. If it's a machine that belongs to you, or one that you
    set up yourself and you know the root password for, you can literally do anything
    you want. If the machine belongs to someone else, you might have permission to
    modify your local home folder only. Either way, you successfully connected to
    a machine using SSH. The remaining sections of this chapter, as well as [Chapter
    9](ch09.html "Chapter 9. Securing Your Network"), *Securing Your Network*, will
    expand on this basic knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenSSH config file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When utilizing SSH for the first time, the `.ssh` directory will be created
    in your home directory. This directory contains useful files for your SSH client,
    which include `known_hosts`, `id_rsa`, and `id_rsa.pub` once you generate your
    keys (which we will do later). While we will discuss those files later on in this
    chapter, there is another file that the SSH client recognizes: `config`. This
    file is not created by default. If you create it yourself (following the proper
    syntax), then SSH will recognize it. So, what does this `config` file do? If you
    have one or more hosts that you connect to frequently, you can fill this file
    with the specifics for each host without having to enter the details each time.
    Let''s look at an example `~/.ssh/config` file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For this file, SSH will recognize three hosts straight away: `Icarus`, `Daedalus`,
    and `dragon`. This is regardless of whether or not these machines are listed in
    DNS. If we were to type `ssh icarus` and the previous `config` file was used,
    SSH would know not only how to get to it (the IP address is given in the file)
    but SSH would also know which user and port to use. Even if our username is not
    `jdoe`, it will be used for this connection (since it''s listed in the file)—unless
    we give the `ssh` command a different user in the command string.'
  prefs: []
  type: TYPE_NORMAL
- en: In the second entry in our sample file (`daedalus`), you'll notice that it is
    a bit different from the others. First, the port is different. For all the other
    hosts in this file, the default of 22 is used. But with `daedalus`, we issue a
    different port. If we connect to `daedalus` via SSH, it will automatically try
    the referenced port. Next, you'll also notice that the username is different for
    this host. Even if our local user was `jdoe` and we didn't supply a different
    username, user `duser` would be automatically used instead. We can override this
    by providing `user@` before the host name, if we wished to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this file doesn''t exist by default, all we need to do is create it using
    any text editor and save it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As long as we typed it out correctly, SSH should see the file and allow us to
    use it. Then, we can create our own list of hosts in this file to easily provide
    the required parameters for each, and allow easier access. Go ahead and give it
    a try in your lab.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and utilizing scp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSH actually has several uses; it's not just for connecting one machine to another,
    though that is the most popular use case. SSH also allows you to transfer files
    to another machine, or even transfer files from a remote machine to your local
    one. The utility that allows you to do this is the `scp` (**secure copy**) command,
    which is part of the SSH suite of utilities. Of course, you can also transfer
    files via network shares, but the beauty of `scp` is that it offers an on-the-fly
    file transfer, with no share configuration being necessary. The `scp` command
    is simple and fast. You can transfer a file from your machine to anywhere on the
    filesystem of a target machine that you have permission to access.
  prefs: []
  type: TYPE_NORMAL
- en: The `scp` utility is primarily meant for those who need a quick transfer of
    a file, as it is not a long-term solution for file access and storage. In a situation
    where you need to create a storage repository that others need to access, you
    would typically set up an **NFS** or **Samba** share to accomplish the goal. However,
    `scp` is a great utility that will prove very useful to you, whenever you want
    to simply send a file to another machine without configuring anything.
  prefs: []
  type: TYPE_NORMAL
- en: Transferring files to another node via scp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s give `scp` a try. As with our previous SSH activity, you''ll need at
    least two machines: one with the SSH server installed and running, and another
    with at least the client. In this case, the distribution shouldn''t matter as
    long as you meet this simple requirements. In addition, we''ll need a file to
    test with. The file can be something small (such as a text file or image) or large
    (such as an ISO file for a Linux distribution). The goal is to transfer this file
    to another machine using `scp`. Let''s see how to do this.'
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of this tutorial, I'll outline the procedure for a machine named
    foo to transfer a file to a machine named bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at a simple example of `scp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In that example, we've executed the `scp` command against a file named `my-image.jpg`.
    Next, we outline the target. In this case, a machine with the IP address of `192.168.1.200`.
    Then, we type a colon and the path where we'd like the file to be stored. In this
    case, we are going to copy the file into the home directory for `jdoe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we know the name of the target machine (`bar`), we could use the name
    of the machine instead of the IP address, assuming that it is recognized by the
    DNS server. It was configured in `~/.ssh/config`, or is an entry on foo''s `/etc/hosts`
    file. The command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We simplified the command a bit, since we know the name of the machine. Additionally,
    we don''t have to type out the name of the directory if we''re intending to copy
    to a user''s home directory. We could have simplified the command to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example, instead of typing out `/home/jdoe`, we replaced the path with
    a period. This works because the home directory is assumed, unless you give the
    command a separate path. We''d also get the same result if we used a tilde (`~`)
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'What if the data we wish to copy is an entire directory, instead of just a
    single file? If we try to use the `scp` command against a directory, it will fail.
    In order to copy an entire directory, we need to add the `-r` flag that performs
    a recursive copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `my_dir` directory and its contents will be transferred over. Another
    useful flag when copying files is `-p`, which preserves the modification times
    when the file is copied. If we combine that with the previous command, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'However, each of these commands will fail if the user name is different on
    the two machines. For example, if the logged-on user on foo is `dlong` and the
    user doesn''t exist on `bar`, the command would fail because the sending computer
    would default to using `dlong`, the currently logged-on user. In this case, the
    other computer would ask you for the password three times, and then give you a
    message that access is denied. This is because you would essentially be typing
    a password for a user that doesn''t exist. If we need to specify the username
    for the target, the command would become similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With the new version of the command, you'll be prompted for the `jdoe` password
    and then the file would be copied to `/home/jdoe` on the receiving end.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously in this chapter, the default port for SSH (port 22)
    may not be open on the target, as perhaps it is listening on a different port.
    With `scp`, we can specify a different port. To do so, use the `-P` flag. Note
    that this is an uppercase `P`, unlike the `ssh` command that uses a lowercase
    `-p` for specifying the port (this can be somewhat confusing at first when switching
    between `ssh` and `scp`). For example, this flag is appended to the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Go ahead and give it a try in your lab. Find a file of any type and attempt
    to transfer it to another Linux machine. If you do this a few times, you should
    be able to get the hang of it fairly quickly. Another point of interest in regards
    to `scp` is that you can use it to copy a file or directory from a remote machine
    to your local one, if you already know the path of the file you wish to download.
    In the last example of this section, I''m copying `myimage.jpg` from remote host
    `bar` to my current working directory (which I designate with a period):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Tunneling traffic via SSH
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most useful features of SSH is creating an **SSH tunnel**. An SSH
    tunnel allows you to access services locally that originate from another computer
    or server. This allows you to do such things as bypass local DNS filtering, or
    even access an IRC server that is segregated within your company, from home.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be very careful when utilizing SSH tunnels. If you aren't able to access a resource
    while at work, or a work resource is blocked from being accessible from outside
    the network, chances are the network administrator (if that person is not you)
    set it up this way for a reason. When bypassing restrictions or accessing work
    resources from outside the network, always ensure you have permission to do so.
  prefs: []
  type: TYPE_NORMAL
- en: In order for an SSH tunnel to be effective, you first need to be able to access
    SSH where the service you'd like to access is hosted. If you're able to initiate
    a normal SSH connection to a network containing the service, chances are that
    you'll have no problem creating a tunnel.
  prefs: []
  type: TYPE_NORMAL
- en: While utilizing SSH to create a tunnel, the command changes a bit. Instead of
    just executing the `ssh` command against a host name or IP address, there are
    a few more flags added. First, we add the `-L` flag. This sets up what is known
    as a bind address, which basically means we are taking a local port and forwarding
    it to a specific port on the other end.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for such a command string would be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Basically, we execute SSH with the `-L` flag and use `localhost` since we intend
    to forward a local service to a remote one. However, we sandwich the command with
    a port and a colon on either side. The port on the left-hand side is our local
    port and on the right-hand side of the IP address, we have a colon and then the
    remote port. We then finish off the command with our usual syntax, that is, we
    type our user name and then the IP address of the gateway we will use for the
    connection.
  prefs: []
  type: TYPE_NORMAL
- en: Confused yet? Let's break this down further and use an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, VNC (a graphical remote access program) utilizes ports 5900-5902\.
    If you wanted to access a desktop environment on a remote host with an IP address
    of `10.10.10.101`, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re forwarding port `5900` on our local machine to port `5901` on
    `10.10.10.101`. As soon as the session connects and is established, we can then
    use the following in our VNC viewing application on our local machine to connect
    to the VNC service on the remote end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Anytime `localhost:5900` is used, we''ll be forwarded to our remote machine.
    To end the session, exit from the SSH connection. For VNC, we need to specify
    which VNC session to use. In order to use the VNC Viewer application to open a
    VNC session to `10.10.10.101`, we would execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: However, what if the machine or service we wish to connect to is behind a different
    gateway? The previous example only works if the IP address, `10.10.10.101`, is
    routable through the Internet, or we are actually on the same network as the resource
    we wish to connect to. This is not always the case, and generally useful services
    are not exposed directly to the Internet. For example, if you're at home and you
    wish to connect to the remote desktop protocol on a computer in your work network,
    the previous example wouldn't work.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, at the office, we have a computer with a remote desktop exposed
    with an IP address `10.10.10.60`. We can't get to this machine directly from home,
    because it is not routable through the Internet. However, we just so happen to
    have a server at work that actually, is exposed to the Internet with an outside
    IP address `66.238.170.50`. We are able to SSH directly into that machine from
    home, but host `10.10.10.60` is further within that network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can utilize host `66.238.170.50` to facilitate our connection to `10.10.10.60`
    inside our work network. Let''s look at a command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `jdoe` has a user account on host `66.238.170.50` and wishes
    to connect to host `10.10.10.60`, which is inside her company network. In this
    example, `jdoe` is forwarding local port `3388` on `localhost` to port `3389`
    on host `10.10.10.60`, but establishing the connection through host `66.238.170.50`.
    Now, user `jdoe` is able to open a remote desktop client and use the following
    command for the connection address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As long as the SSH connection remains open, `jdoe` will then be able to utilize
    a remote desktop on the server from her local computer. If the shell is closed,
    then the connection will terminate.
  prefs: []
  type: TYPE_NORMAL
- en: Using SSH tunnels can be very useful. Feel free to give it a try and see which
    services you can forward through your network.
  prefs: []
  type: TYPE_NORMAL
- en: Generating public keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSH also supports **public key authentication**, in addition to traditional
    passwords, which is more secure. While the encryption that SSH employs using protocol
    2 is strong, the greatest encryption in the world won't save you if your password
    is leaked or brute-forced. This is especially catastrophic on a mission-critical
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing public key authentication allows you to connect to a host using a
    private and public key relationship, instead of using a password. By default,
    SSH will allow a user to log in via either the username/password combination or
    a username / key pair combination. The first method is only as secure as the password.
    By utilizing public key authentication, you can bypass the need for a password
    completely, and connect to a server without being prompted. But if a server still
    accepts your password as a means of authentication, then public key authentication
    is not at its strongest point.
  prefs: []
  type: TYPE_NORMAL
- en: On the server end of the SSH connection, it is possible to configure it to accept
    authentication only from a public key, rather than password. If password authentication
    is disabled, then no one would be able to brute force the password and get into
    the server, since the password would be ignored. If the attacker doesn't have
    access to the private key, then he or she would not be able to connect.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a key pair is simple using the `ssh-keygen` command, which will guide
    you through the process of setting up your keys. During this process, you will
    be asked to create a passphrase. You could, if you wanted to, disregard this prompt
    and simply press *Enter* to create a key without a passphrase. Doing so, however,
    drastically lowers the security of that key. While it is certainly much more convenient
    to not have to type anything at all when connecting to a host via SSH, it's definitely
    recommended to use a passphrase and benefit from the added security.
  prefs: []
  type: TYPE_NORMAL
- en: 'With public key authentication, two files are created in the user''s home directory:
    `id_rsa` and `id_rsa.pub`. These files are created when you run through the process
    while executing `ssh-keygen`, mentioned earlier. After the command completes,
    these two files should be located in the `.ssh` directory of your home directory.
    The `id_rsa` file is your private key. You should keep it local and not transmit
    it or share it in a public place. The `id_rsa.pub` file is your public key, which
    you can safely copy to other hosts that you connect to. From that point forward,
    you will be able to use public key authentication to connect to another host.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's summarize the entire process. First, while logged in to your local or
    main machine, execute `ssh-keygen` and walk through the steps. Make sure to create
    a passphrase for added security.
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating public keys](img/B03919_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a key pair for SSH using ssh-keygen
  prefs: []
  type: TYPE_NORMAL
- en: Next, utilize the `ssh-copy-id` command in order to copy your key to the remote
    server you wish to connect to. The command syntax is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This command will copy your public key into the `authorized_keys` file under
    your `~/.ssh` folder on the target machine. This file stores all the keys that
    the machine knows about. If you were to check before and after running through
    the `ssh-copy-id` process, you'd notice that the `authorized_keys` file on the
    target either didn't exist, or didn't include your key until after you executed
    the command.
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating public keys](img/B03919_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Copying a public key to a remote host using ssh-copy-id
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, it is possible to configure your computer or server to
    disallow authentication via password, only allowing public key authentication
    instead. This portion will be discussed further in [Chapter 9](ch09.html "Chapter 9. Securing
    Your Network"), *Securing Your Network*. For now, it's important to get in the
    habit of generating, copying, and using keys. Feel free to create a key pair on
    your local machine and copy the public key to a server that you frequently connect
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping SSH connections alive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on how your SSH server or internal firewalls are configured, your
    SSH session may automatically disconnect after some time. It's possible to configure
    SSH to send a special packet every certain number of seconds, to keep the connection
    from idling and becoming a candidate for disconnection. This is useful if you
    have a service that utilizes SSH, that you do not want to be disconnected. To
    employ this tweak, we must configure the `ServerAliveInterval` setting.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways of configuring this, one that affects your user account and
    another that will deploy the setting system wide. First, let's explore how to
    configure this for your user account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember the `~/.ssh/config` file that we configured earlier in this chapter?
    Open it up again in your text editor. Here''s a sample of this file for your convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, we have three systems. If we wish to configure a host, for example
    `icarus`, to send an alive packet once every 60 seconds, we can add the following
    setting to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wish to set the `ServerAliveInterval` setting for all hosts we connect
    to, we could add this option as a wildcard instead by adding the following to
    the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, the setting takes effect for all systems we initiate a connection
    to. Although we haven''t discussed them (yet), there are two system-wide (global)
    configuration files for SSH. We''ll discuss these files later in this book, but
    the subject of this section is an opportunity to give you a quick introduction:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/etc/ssh/ssh_config`: This file will impact all users whom make outbound connections.
    Think of this as the client configuration file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/ssh/sshd_config`: This is the global config file for the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Anything you configure in one of these two files will impact anyone. The `ssh_config`
    file impacts all outbound connections, and the `sshd_config` impacts all the incoming
    connections. For this section, the file we''re interested in is the `ssh_config`
    file, since we can set the `ServerAliveInterval` setting for all users by including
    it there. In fact, regardless of whether we''re configuring `/etc/ssh/ssh_config`
    or the local `~/.ssh/config` file, the option is the same. Simply add it to the
    end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we'll explore configuring these options further later on in this
    book. For now, just remember the purpose of these two files and where they're
    located.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring an alternative to SSH – utilizing Mosh (mobile shell)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While starting out with SSH, you might notice one quirk right away: if your
    network connection drops, it can be difficult to regain control of what you were
    doing on the machine you were connected to. This is especially common with laptops,
    as your connection state on such a device will change depending on where you are
    or what network you''re connected to. While running commands within a terminal
    multiplexer such as tmux or screen, can keep your workflow alive even after disconnecting,
    there is an alternative to SSH that may work for you. **Mosh** (**mobile shell**)
    is an alternative to SSH that will keep your remote session alive, even if you
    disconnect from the network where the resource resides. When you reconnect to
    the network, Mosh will allow you to pick up where you left off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing Mosh in Debian is extremely easy. Simply install the `mosh` package,
    as it is available from within the default repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In CentOS, Mosh is not available from that distribution''s default repositories,
    so you''ll first need to add an additional repository in order to make it available.
    First, enable the EPEL repository with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you should be able to install the `mosh` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In order for Mosh to be effective, you will need to install it not only on
    your local machine, but also any machines you wish to connect to. The syntax is
    similar to SSH:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Like SSH, we can supply the `-p` flag to specify a different port to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In fact, Mosh actually utilizes SSH to initiate the connection, and then the
    mosh program takes over from there. After you connect, you can simulate a disconnect
    by removing your network cable or disconnecting from your wireless access point.
    You will notice that the next time you connect using mosh, your session should
    be just as you left it. To see the magic in all its glory, consider starting a
    process (such as running the `top` command) before disconnecting.
  prefs: []
  type: TYPE_NORMAL
- en: While there are many ways to keep processes running on a remote server even
    when your session is disconnected, Mosh is one of the newer and more unique solutions.
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed SSH in all its glory. We started off with a discussion
    of what SSH is and why it's useful, and then we ensured it was installed on our
    systems. Using SSH, we were able to connect to other Linux machines and execute
    commands. We also took a look at configuring hosts in the `~/.ssh/config` file
    and transferring files from one host to another using `scp`. In addition, SSH
    tunneling was discussed, as well as an introduction to public key authentication.
    We finished the chapter with a look at Mosh, which is a neat alternative to SSH.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll tackle file sharing by setting up our very own file
    server. We'll set up file shares via Samba as well as NFS, as well as the individual
    quirks of each solution. See you there!
  prefs: []
  type: TYPE_NORMAL
