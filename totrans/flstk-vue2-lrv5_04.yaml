- en: Building a Web Service with Laravel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we got the Homestead development environment up and running,
    and began serving the main Vuebnb project. In this chapter, we will create a simple
    web service that will make Vuebnb's room listing data ready for display in the
    frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Laravel to create a web service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing database migrations and seed files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating API endpoints to make data publicly accessible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving images from Laravel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vuebnb room listings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](b381aa06-e15c-4cb9-9b8b-4b9421ed73db.xhtml), *Prototyping Vuebnb,
    Your First Vue.js Project*, we built a prototype of the listing page of the frontend
    app. Soon we'll be removing the hardcoded data on this page and turning it into
    a template that can display any room listing.
  prefs: []
  type: TYPE_NORMAL
- en: We won't be adding functionality for a user to create their own room listing
    in this book. Instead, we'll use a package of mock data comprising 30 different
    listings, each with their own unique titles, descriptions, and images. We will
    seed the database with these listings and configure Laravel to serve them to the
    frontend as required.
  prefs: []
  type: TYPE_NORMAL
- en: Web service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **web service** is an application that runs on a server and allows a client
    (such as a browser) to remotely write/retrieve data to/from the server over HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface of a web service will be one or more API endpoints, sometimes
    protected with authentication, that will return data in an XML or JSON payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4f1dd567-4848-4363-aeab-85ec53a9ac04.png)Figure 4.1\. Vuebnb web
    service'
  prefs: []
  type: TYPE_NORMAL
- en: 'Web services are a speciality of Laravel, so it won''t be hard to create one
    for Vuebnb. We''ll use routes for our API endpoints and represent the listings
    with Eloquent models that Laravel will seamlessly synchronize with the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a0baa328-978a-4528-abc3-8ee6465f45a1.png)Figure 4.2\. Web service
    architecture'
  prefs: []
  type: TYPE_NORMAL
- en: Laravel also has inbuilt features to add API architectures such as REST, though
    we won't need this for our simple use case.
  prefs: []
  type: TYPE_NORMAL
- en: Mock data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mock listing data is in the file `database/data.json`. This file includes
    a JSON-encoded array of 30 objects, with each object representing a different
    listing. Having built the listing page prototype, you'll no doubt recognize a
    lot of the same properties on these objects, including the title, address, and
    description.
  prefs: []
  type: TYPE_NORMAL
- en: '`database/data.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Each mock listing includes several images of the room as well. Images aren't
    really part of a web service, but they will be stored in a public folder in our
    app to be served as needed.
  prefs: []
  type: TYPE_NORMAL
- en: The image files are not in the project code, but are in the code base we downloaded
    from GitHub. We'll copy them into our project folder later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our web service will require a database table for storing the mock listing data.
    To set this up we'll need to create a schema and migration. We'll then create
    a seeder that will load and parse our mock data file and insert it into the database,
    ready for use in the app.
  prefs: []
  type: TYPE_NORMAL
- en: Migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `migration`is a special class that contains a set of actions to run against
    the database, such as creating or modifying a database table. Migrations ensure
    your database gets set up identically every time you create a new instance of
    your app, for example, installing in production or on a teammate's machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new migration, use the `make:migration` Artisan CLI command. The
    argument of the command should be a snake-cased description of what the migration
    will do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You'll now see your new migration in the `database/migrations` directory. You'll
    notice the filename has a prefixed timestamp, such as `2017_06_20_133317_create_listings_table.php`.
    The timestamp allows Laravel to determine the proper order of the migrations,
    in case it needs to run more than one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Your new migration declares a class that extends `Migration`. It overrides two
    methods: `up`, which is used to add new tables, columns, or indexes to your database;
    and `down`, which is used to delete them. We'll implement these methods shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '`2017_06_20_133317_create_listings_table.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **schema **is a blueprint for the structure of a database. For a relational
    database such as MySQL, the schema will organize data into tables and columns.
    In Laravel, schemas are declared by using the `Schema` facade's `create` method.
  prefs: []
  type: TYPE_NORMAL
- en: We'll now make a schema for a table to hold Vuebnb listings. The columns of
    the table will match the structure of our mock listing data. Note that we set
    a default `false` value for the amenities and allow the prices to have a `NULL`
    value. All other columns require a value.
  prefs: []
  type: TYPE_NORMAL
- en: The schema will go inside our migration's `up` method. We'll also fill out the `down` with
    a call to `Schema::drop`.
  prefs: []
  type: TYPE_NORMAL
- en: '`2017_06_20_133317_create_listings_table.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A **facade **is an object-oriented design pattern for creating a static proxy
    to an underlying class in the service container. The facade is not meant to provide
    any new functionality; its only purpose is to provide a more memorable and easily
    readable way of performing a common action. Think of it as an object-oriented
    helper function.
  prefs: []
  type: TYPE_NORMAL
- en: Execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve set up our new migration, let''s run it with this Artisan command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an output like this in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To confirm the migration worked, let's use Tinker to show the new table structure.
    If you've never used Tinker, it's a REPL tool that allows you to interact with
    a Laravel app on the command line. When you enter a command into Tinker it will
    be evaluated as if it were a line in your app code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, open the Tinker shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now enter a PHP statement for evaluation. Let''s use the `DB` facade''s `select` method
    to run an SQL `DESCRIBE` query to show the table structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The output is quite verbose so I won't reproduce it here, but you should see
    an object with all your table details, confirming the migration worked.
  prefs: []
  type: TYPE_NORMAL
- en: Seeding mock listings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a database table for our listings, let''s seed it with the
    mock data. To do so we''re going to have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the `database/data.json` file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the data into the listings table
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a seeder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Laravel includes a seeder class that we can extend called `Seeder`. Use this
    Artisan command to implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When we run the seeder, any code in the `run` method is executed.
  prefs: []
  type: TYPE_NORMAL
- en: '`database/ListingsTableSeeder.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Loading the mock data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Laravel provides a `File` facade that allows us to open files from disk as simply
    as `File::get($path)`. To get the full path to our mock data file we can use the `base_path()` helper
    function, which returns the path to the root of our application directory as a
    string.
  prefs: []
  type: TYPE_NORMAL
- en: It's then trivial to convert this JSON file to a PHP array using the built-in `json_decode` method.
    Once the data is an array, it can be directly inserted into the database given
    that the column names of the table are the same as the array keys.
  prefs: []
  type: TYPE_NORMAL
- en: '`database/ListingsTableSeeder.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Inserting the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to insert the data, we'll use the `DB` facade again. This time we'll
    call the `table` method, which returns an instance of `Builder`. The `Builder` class
    is a fluent query builder that allows us to query the database by chaining constraints,
    for example, `DB::table(...)->where(...)->join(...)` and so on. Let's use the `insert` method
    of the builder, which accepts an array of column names and values.
  prefs: []
  type: TYPE_NORMAL
- en: '`database/seeds/ListingsTableSeeder.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Executing the seeder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To execute the seeder we must call it from the `DatabaseSeeder.php`file, which
    is in the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: '`database/seeds/DatabaseSeeder.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With that done, we can use the Artisan CLI to execute the seeder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll again use Tinker to check our work. There are 30 listings in the mock
    data, so to confirm the seed was successful, let''s check for 30 rows in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s inspect the first row of the table just to be sure its content
    is what we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If yours looks like that you're ready to move on!
  prefs: []
  type: TYPE_NORMAL
- en: Listing model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've now successfully created a database table for our listings and seeded
    it with mock listing data. How do we access this data now from the Laravel app?
  prefs: []
  type: TYPE_NORMAL
- en: We saw how the `DB` facade lets us execute queries on our database directly.
    But Laravel provides a more powerful way to access data via the **Eloquent ORM**.
  prefs: []
  type: TYPE_NORMAL
- en: Eloquent ORM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Object-Relational Mapping** (**ORM**) is a technique for converting data
    between incompatible systems in object-oriented programming languages. Relational
    databases such as MySQL can only store scalar values such as integers and strings,
    organized within tables. We want to make use of rich objects in our app, though,
    so we need a means of robust conversion.'
  prefs: []
  type: TYPE_NORMAL
- en: Eloquent is the ORM implementation used in Laravel. It uses the **active record** design
    pattern, where a model is tied to a single database table, and an instance of
    the model is tied to a single row.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a model in Laravel using Eloquent ORM, simply extend the `Illuminate\Database\Eloquent\Model` class using
    Artisan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This generates a new file.
  prefs: []
  type: TYPE_NORMAL
- en: '`app/Listing.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How do we tell the ORM what table to map to, and what columns to include? By
    default, the `Model` class uses the class name (`Listing`) in lowercase (`listing`)
    as the table name to use. And, by default, it uses all the fields from the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, any time we want to load our listings we can use code such as this, anywhere
    in our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Casting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data types in a MySQL database don't completely match up to those in PHP.
    For example, how does an ORM know if a database value of 0 is meant to be the
    number 0, or the Boolean value of `false`?
  prefs: []
  type: TYPE_NORMAL
- en: An Eloquent model can be given a `$casts` property to declare the data type
    of any specific attribute. `$casts` is an array of key/values where the key is
    the name of the attribute being cast, and the value is the data type we want to
    cast to.
  prefs: []
  type: TYPE_NORMAL
- en: For the listings table, we will cast the amenities attributes as Booleans.
  prefs: []
  type: TYPE_NORMAL
- en: '`app/Listing.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now these attributes will have the correct type, making our model more robust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Public interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final piece of our web service is the public interface that will allow a
    client app to request the listing data. Since the Vuebnb listing page is designed
    to display one listing at a time, we'll at least need an endpoint to retrieve
    a single listing.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now create a route that will match any incoming GET requests to the URI `/api/listing/{listing}` where `{listing}` is
    an ID. We'll put this in the `routes/api.php` file, where routes are automatically
    given the `/api/` prefix and have middleware optimized for use in a web service
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use a `closure` function to handle the route. The function will have a `$listing` argument, which
    we'll type hint as an instance of the `Listing` class, that is, our model. Laravel's
    service container will resolve this as an instance with the ID matching `{listing}`.
  prefs: []
  type: TYPE_NORMAL
- en: We can then encode the model as JSON and return it as a response.
  prefs: []
  type: TYPE_NORMAL
- en: '`routes/api.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test this works by using the `curl` command from the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The response will be the listing with ID 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9e447b42-228b-44ff-b6dc-a8e5d91f02bc.png)Figure 4.3\. JSON response
    from Vuebnb web service'
  prefs: []
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll be adding more routes to retrieve the listing data as the project progresses.
    It''s a best practice to use a `controller` class for this functionality to keep
    a separation of concerns. Let''s create one with Artisan CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We'll then move the functionality from the route into a new method, `get_listing_api`.
  prefs: []
  type: TYPE_NORMAL
- en: '`app/Http/Controllers/ListingController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For the `Route::get` method we can pass a string as the second argument instead
    of a `closure` function. The string should be in the form `[controller]@[method]`, for
    example, `ListingController@get_listing_web`. Laravel will correctly resolve this
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '`routes/api.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated at the beginning of the chapter, each mock listing comes with several
    images of the room. These images are not in the project code and must be copied
    from a parallel directory in the code base called `images`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the contents of this directory into the `public/images` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve copied these files, `public/images` will have 30 sub-folders,
    one for each mock listing. Each of these folders will contain exactly four main
    images and a thumbnail image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1321f4d1-eb59-49c2-b034-d5766ad72788.png)Figure 4.4\. Image files
    in the public folder'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Files in the `public`directory can be directly requested by appending their
    relative path to the site URL. For example, the default CSS file, `public/css/app.css`, can
    be requested at `http://vuebnb.test/css/app.css`.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using the `public` folder, and the reason we've put our images
    there, is to avoid having to create any logic for accessing them. A frontend app
    can then directly call the images in an `img` tag.
  prefs: []
  type: TYPE_NORMAL
- en: You may think it's inefficient for our web server to serve images like this,
    and you'd be right. Later in the book, we'll serve the images from a CDN when
    in production mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to open one of the mock listing images in our browser to test this
    thesis: `http://vuebnb.test/images/1/Image_1.jpg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/18bb9373-46c0-4abe-bf95-b1f3b1139b7e.png)Figure 4.5\. Mock listing
    image displayed in browser'
  prefs: []
  type: TYPE_NORMAL
- en: Image links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The payload for each listing in the web service should include links to these
    new images so a client app knows where to find them. Let''s add the image paths
    to our listing API payload so it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The thumbnail image won't be used until later in the project.
  prefs: []
  type: TYPE_NORMAL
- en: To implement this, we'll use our model's `toArray` method to make an array representation
    of the model. We'll then easily be able to add new fields. Each mock listing has
    exactly four images, numbered 1 to 4, so we can use a `for` loop and the `asset` helper
    to generate fully-qualified URLs to files in the public folder.
  prefs: []
  type: TYPE_NORMAL
- en: We finish by creating an instance of the `Response` class by calling the `response` helper.
    We use the `json`; method and pass in our array of fields, returning the result.
  prefs: []
  type: TYPE_NORMAL
- en: '`app/Http/Controllers/ListingController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `/api/listing/{listing}` endpoint is now ready for consumption by a client
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built a web service with Laravel to make the Vuebnb listing
    data publicly accessible.
  prefs: []
  type: TYPE_NORMAL
- en: This involved setting up a database table using a migration and schema, then
    seeding the database with mock listing data. We then created a public interface
    for the web service using routes. This returned the mock data as a JSON payload,
    including links to our mock images.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll introduce Webpack and the Laravel Mix build tool
    to set up a full-stack development environment. We'll migrate the Vuebnb prototype
    into the project, and refactor it to fit the new workflow.
  prefs: []
  type: TYPE_NORMAL
