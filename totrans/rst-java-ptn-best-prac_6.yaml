- en: Chapter 6. Emerging Standards and the Future of REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers the emerging and evolving technologies that will augment
    the functionality of RESTful services and provide some perspective on the future
    of REST as well as other real-time API supporters. We will cover some of the real-time
    APIs and see how they can help with respect to older ways such as polling. Given
    the ubiquitous popularity of platforms such as Twitter, Facebook, and Stripe,
    it is no surprise that they have adopted a paradigm shift and thus provide real-time
    APIs to give information to the client as and when an event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Real-time APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebHooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebSockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additional real-time API supporters, which include the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PubSubHubbub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server-sent events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XMPP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BOSH over XMPP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case studies on companies using WebHooks and WebSockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison between WebHooks and WebSockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST and Micro Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start with defining what a real-time API refers to, and then, we will
    cover polling and its disadvantages. Next, we will walk through the different
    models that are widely used for asynchronous real-time communication. Finally,
    we will elaborate the pragmatic approaches to WebHooks and WebSockets in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Real-time APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our context, a real-time API helps the API consumer receive the events that
    they are interested in, as they occur. An example of a real-time update is when
    someone posts a link on Facebook or someone you follow on Twitter tweets about
    a topic. Another example of a real-time API is to receive the feed of stock price
    changes as they occur.
  prefs: []
  type: TYPE_NORMAL
- en: Polling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Polling is the most traditional way to get data from a data source that produces
    the stream of events and updates. The client makes requests periodically, and
    the server sends data if there is a response. In case there is no data to be sent
    by the server, an empty response is returned. The following diagram shows how
    continuous polling works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Polling](img/7963OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Polling comes with multiple drawbacks such as empty responses for requests made
    when there is no update on the server; this results in waste of bandwidth and
    processing time. Polling with lower frequencies will result in the client missing
    the updates close to the time the updates happen, and polling too frequently results
    in waste of resources as well as facing the rate limitation imposed by the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To eliminate these drawbacks of polling, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The PuSH model—PubSubHubbub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The streaming model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PuSH model – PubSubHubbub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PuSH is a simple topic based on the publish/subscribe protocol, which is based
    on ATOM/RSS. Its goal is to convert atom feeds to real-time data and eliminate
    the polling that affects the consumers of the feeds. The subscribers register
    their interests in a topic, and the original publisher tells the interested subscribers
    that there is something new that interests them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To distribute the tasks of publishing and content distributing, there is a
    notion of the **Hub**, which can be delegated to send the content to the subscribers.
    The following diagram depicts the PubSubHubbub model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The PuSH model – PubSubHubbub](img/7963OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at how this model works:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Subscriber** discovers the **Hub** by fetching the feed from the **Publisher**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the **Hub** is discovered, the **Subscriber** subscribes to the **Hub**
    with the feed URI it is interested in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, when the **Publisher** has updates to send, it will let the **Hub** get
    the updates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Hub** then sends the updates to all the publishers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The advantage of this model is that the publisher does not have to be concerned
    with sending updates to all the subscribers. Also, on the other end, the subscribers
    have an advantage as they get the updates from the hub as and when they occur,
    without continuously polling the publisher.
  prefs: []
  type: TYPE_NORMAL
- en: The **WebHooks** paradigm, discussed in the subsequent sections, uses this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The streaming model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The streaming model for asynchronous communication involves keeping a channel
    open and sending the data as it occurs. In this case, a socket connection needs
    to be kept open.
  prefs: []
  type: TYPE_NORMAL
- en: Server-sent events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Server-sent events** (**SSE**) is a technology based on the streaming model,
    where a browser gets automatic updates from a server via an HTTP connection. The
    W3C has standardized the Server-Sent Events EventSource API as part of HTML5.'
  prefs: []
  type: TYPE_NORMAL
- en: With SSEs, the client initiates a request to the server using the `"text/eventstream"`
    MimeType. Once the initial handshake has taken place, the server can keep sending
    events to the client as and when they occur. The events are plain text messages
    sent from the server to the clients. They can be data that can be consumed in
    the client side by the event listener, and the event listener can interpret and
    react to the received event.
  prefs: []
  type: TYPE_NORMAL
- en: 'SSEs define a message format for the events that are sent from the server to
    the clients. The message format is composed of plain text line separated by a
    stream of characters. Lines that carry the message body or data start with `data:`
    and end with `\n\n`, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Lines that carry some **Quality of Service** (**QoS**) directives (for example,
    `retry` and `id`) start with the QoS attribute name, followed by `:`, and then
    the QoS attribute's value. The standard format makes it possible to develop generic
    libraries around SSE to make software development easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how SSEs work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Server-sent events](img/7963OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the diagram, the client subscribes to an event source. The server
    keeps sending updates as and when they occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the server can associate and send IDs along with the whole message,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet shows how multiline messages with event IDs and data can
    be sent, with the last line that terminates with two `\n\n` characters.
  prefs: []
  type: TYPE_NORMAL
- en: Setting an ID lets the client keep track of the last event fired so that if
    the connection to the server is dropped, a special HTTP header (`Last-Event-ID`)
    is set with the new request sent by the client.
  prefs: []
  type: TYPE_NORMAL
- en: The upcoming sections cover how to associate IDs with SSEs, how SSE works with
    connection loss and retries, and how to associate event names with SSEs.
  prefs: []
  type: TYPE_NORMAL
- en: Associating an ID with an event
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each SSE message can have a message identifier, which can be used for a variety
    of purposes, for example, to keep track of the messages that the client has received
    and also to keep a checkpoint for it. When the message ID is used in SSE, the
    client can supply the last message ID as one of the connection parameters to instruct
    the server to resume from a specific message onwards. Of course, the server-side
    code should implement a proper procedure to resume a communication from the message
    ID as requested by the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the SSE message with the ID is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Retrying in case of connection failures
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Firefox, Chrome, Opera, and Safari support server-sent events. In case there
    is a connection loss between the browser and server, the browser can try reconnecting
    to the server. There is a retry directive, which can be configured by the server
    to enable the retries from a client. The default value for the retry interval
    is 3 seconds. To increase the retry interval to 5 seconds, the server can send
    a retry event as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Associating event names with events
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another SSE directive is the event name. Each event source can generate more
    than one type of event, and a client can decide how to consume each event type
    based on what event type it subscribes for. The following code snippet shows how
    the `name` event directive incorporates into the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Server-sent events and JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The API that is considered the foundation of SSE in the client side for JavaScript
    developers is the `EventSource` interface. The `EventSource` interface contains
    a fair number of functions and attributes, but the most important ones are listed
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `addEventListener` | This function adds an event listener to handle the incoming
    events based on the event type. |'
  prefs: []
  type: TYPE_TB
- en: '| `removeEventListener` | This function removes an already registered listener.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `onmessage` | This function is invoked on message arrival. There is no custom
    event handling available when using the `onmessage` method. Listeners manage the
    custom event handling. |'
  prefs: []
  type: TYPE_TB
- en: '| `onerror` | This function is invoked when something goes wrong with the connection.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `onopen` | This function is invoked when a connection is opened. |'
  prefs: []
  type: TYPE_TB
- en: '| `onclose` | This function is invoked when a connection is closed. |'
  prefs: []
  type: TYPE_TB
- en: The following snippet shows how to subscribe for different event types omitted
    by one source. The snippet assumes that the incoming messages are JSON-formatted
    messages. For example, there is an application that can stream updates to users
    as and when new books are available in some storage. The `'bookavailable'` listener
    uses a simple JSON parser to parse the incoming JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Then, it will use this to update the GUI, while the `'newbookadded'` listener
    uses the reviver function to filter out and selectively process the JSON pairs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Server-sent events and Jersey
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SSEs are not part of the standard JAX-RS specification. However, they are supported
    in the Jersey implementation of JAX-RS. For more details, check out [https://jersey.java.net/documentation/latest/sse.html](https://jersey.java.net/documentation/latest/sse.html).
  prefs: []
  type: TYPE_NORMAL
- en: WebHooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**WebHooks** are a form of user-defined custom HTTP callbacks. With the WebHook
    model, a client provides the event producer with an endpoint to which the event
    producer can *post* the events. When an event is posted to the endpoint, the client
    application that is interested in such events can take appropriate actions. An
    example of WebHooks is triggering an event such as a Hudson job using a GIT post-receive
    hook.'
  prefs: []
  type: TYPE_NORMAL
- en: To acknowledge that the subscriber received the WebHook without any problem,
    the subscriber's endpoint should return a `200 OK HTTP` status code. The event
    producer will ignore the request body and any other request header, other than
    the status. Any response code outside the 200 ranges, including 3xx codes, will
    indicate that they did not receive the WebHook, and the API might retry sending
    the HTTP `POST` request.
  prefs: []
  type: TYPE_NORMAL
- en: WebHooks events generated by GitHub deliver a payload of information about activity
    in a repository. WebHooks can trigger across several different actions. For example,
    a consumer might request for a payload of information any time a commit is made,
    a repository is forked, or an issue is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts how WebHooks work with GitHub or GitLab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![WebHooks](img/7963OS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at how WebHooks work:'
  prefs: []
  type: TYPE_NORMAL
- en: The user makes a **Git** push.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is a custom WebHook URL to post the event object registered by the consumer
    with GitHub. When an event occurs, for example, when a commit is made, the GitHub
    service will send the payload of information regarding the commit, using a **POST**
    message to the endpoint provided by the consumer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The consumer application can then store data in the **dB** or take some other
    action such as triggering a continuous integration build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Some of the popular WebHooks case studies**'
  prefs: []
  type: TYPE_NORMAL
- en: Twilio uses WebHooks to send SMS messages. GitHub uses WebHooks to send repository
    change notification and, optionally, some payloads.
  prefs: []
  type: TYPE_NORMAL
- en: PayPal uses **Instant Payment Notification** (**IPN**), a message service that
    automatically notifies merchants of events related to PayPal transactions, and
    it is based on WebHooks.
  prefs: []
  type: TYPE_NORMAL
- en: Facebook's real-time API uses WebHooks and is based on **PubSubHubbub** (**PuSH**).
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, if an API does not offer a form of WebHooks for notification,
    its consumers will have to keep polling for data, which is not only inefficient
    but also not real time.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The WebSocket protocol is a protocol that provides full-duplex communication
    channels over a single TCP connection.
  prefs: []
  type: TYPE_NORMAL
- en: The WebSocket protocol is an independent TCP-based protocol, and its only relationship
    to HTTP is that the handshake to switch over to WebSockets is interpreted by HTTP
    servers as an `Upgrade` request.
  prefs: []
  type: TYPE_NORMAL
- en: It provides the option to have full-duplex, real-time communication between
    clients (for example, a web browser) and an endpoint without the constant cost
    of establishing a connection or polling resource intensively. WebSockets are extensively
    used in social feeds, multiplayer games, collaborative editing, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show a WebSocket Protocol handshake, which starts with
    an `Upgrade` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows an example of a handshake with the `HTTP/1.1 Upgrade`
    request and `HTPP/1.1 Switching Protocols` response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![WebSockets](img/7963OS_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once the connection has been established between the client and the server with
    the `Upgrade` request and `HTTP/1.1` response, WebSocket data frames, binary or
    text, can be sent back and forth between the client and server from both directions.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets data is minimally framed between 2 bytes; this dramatically reduces
    the overhead compared to what HTTP headers would transfer.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very basic example of using the JavaScript WebSockets API is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table will describe the WebSockets functionality and various
    functions in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `send` | This function can be used to send a message to the server''s specified
    URL. |'
  prefs: []
  type: TYPE_TB
- en: '| `onopen` | This function is invoked when the connection is created. The `onopen`
    function handles the `open` event type. |'
  prefs: []
  type: TYPE_TB
- en: '| `onmessage` | When a new message arrives, the `onmessage` function is invoked
    to handle the `message` event. |'
  prefs: []
  type: TYPE_TB
- en: '| `onclose` | This function is invoked when the connection is being closed.
    The `onclose` method handles the `close` event type. |'
  prefs: []
  type: TYPE_TB
- en: '| `onerror` | This function is invoked to handle the `error` event when an
    error occurs in the communication channel. |'
  prefs: []
  type: TYPE_TB
- en: '| `close` | This function is used to close the communication socket and end
    the interaction between the client and server. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Popular WebSockets Case Studies**'
  prefs: []
  type: TYPE_NORMAL
- en: Zynga Poker is one of the first games to utilize WebSockets connections on a
    massive scale. Using WebSockets in Zynga Poker HTML5 delivers a smooth, high-speed
    gameplay that allows for a synchronous experience on the mobile web. It varies
    based on connections, but the game loads and refreshes almost immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Additional real-time API supporters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some more commonly used real-time or near real-time communication
    protocols and APIs that are mostly used outside of the browser. Some of these
    protocols and APIs are described in the subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: XMPP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The XMPP protocol was developed to address the requirements of text messaging
    and Internet-chat-oriented solutions. XMPP's basic model of communication is client
    to server, server to server, server to client. In support of this, it defines
    a client to server protocol and a server to server protocol based on XML messages
    encoded and transmitted directly over TCP.
  prefs: []
  type: TYPE_NORMAL
- en: XMPP is a mature protocol with many implementations in different languages and
    platforms. The main drawback associated with XMPP is the long polling and open
    sockets to handle the inbound and outbound communications.
  prefs: []
  type: TYPE_NORMAL
- en: BOSH over XMPP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Bidirectional streams Over Synchronous HTTP** (**BOSH**) specified in XEP-0124
    is the standardized way to do XMPP over HTTP. For the client-initiated protocol,
    the client simply sends XMPP packets on HTTP, and for the server-initiated protocol,
    the server uses long polling with the connection open for a prespecified period
    of time.'
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of BOSH is the possibility that it provides to use a web
    browser as an XMPP client by taking advantage of any of the JavaScript implementations
    of BOSH. Emite, JSJaC, and xmpp4js are some of the libraries that support BOSH.
  prefs: []
  type: TYPE_NORMAL
- en: Comparisons between WebHooks, WebSockets, and server-sent events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSEs are sent over HTTP unlike WebSockets. SSEs offer only one-way communication
    of events from the server to the client and do not support a full-duplex communication
    as WebSockets do. SSEs have the ability to automatically retry a connection; they
    also have event IDs that can be associated with messages to provide **Quality
    of Service** (**QoS**) features. The WebSockets specification does not support
    these features.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, WebSockets support full-duplex communication, and reduce
    the latency and help improve throughput, as there is an initial handshake over
    HTTP, but then, the messages are transferred between endpoints over TCP.
  prefs: []
  type: TYPE_NORMAL
- en: In comparison to the two protocols mentioned earlier, WebHooks has a lower barrier
    to entry and offers an easy way for applications and services to integrate with
    one another. This enables the capability of having an interconnected and interchangeable
    set of loosely coupled cloud services talking to each other via HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table compares and contrasts WebHooks, WebSockets, and SSEs in
    different areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Criteria | WebHooks | WebSockets | Server-sent events |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Asynchronous real-time communication support | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Callback URL registered | Yes | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| Long-lived open connection | No | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Bidirectional | No | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Error handling | No | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Easy to support and implement | Yes | Needs browsers and proxy server support
    | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Needs fallback to polling | No | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: The next section will cover how highly available cloud applications are moving
    toward the Micro Services-based architecture.
  prefs: []
  type: TYPE_NORMAL
- en: REST and Micro Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The dream of SOA has become a reality with the emergence of Micro Services architecture,
    which comprises breaking a monolithic application into sets of fine-grained services.
    We will now look at the different advantages of Micro Services as compared to
    monolithic services.
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of using the more complicated traditional enterprise, many developers
    are ﬁnding that building the same application using lightweight API services proves
    to be more resilient, scalable, and maintainable. This style is the Micro Services-based
    architecture. This is in contrast with approaches such as the legacy RPC approaches
    of CORBA and RMI, or the bulky Web Services protocols such as SOAP.
  prefs: []
  type: TYPE_NORMAL
- en: Isolation of problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the monolithic applications, all the components of a service are loaded in
    a single application artifact (a WAR, EAR, or JAR file), which is deployed on
    a single JVM. This implies that if the application or the application server goes
    down, it would mean a failure of all the services.
  prefs: []
  type: TYPE_NORMAL
- en: However, with the Micro Services architecture, the services can be independent
    WAR/EAR files. The services can communicate with one another with REST and JSON,
    or XML. Another way to communicate between services in the Micro Services architecture
    is to use a messaging protocol such as AMQP/Rabbit MQ.
  prefs: []
  type: TYPE_NORMAL
- en: Scale up and scale down
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With monolithic services, not all services in the deployed application's file
    might need to be scaled, but they all are forced to follow the same scale-up and
    scale-down rules laid down at deployment level.
  prefs: []
  type: TYPE_NORMAL
- en: With the Micro Services architecture, applications can be built by smaller services
    that can be deployed and scaled independently. This results in an architecture
    that is resilient to failures, scalable and agile, for developing, building, and
    deploying services quickly from the feature definition phase to production phase.
  prefs: []
  type: TYPE_NORMAL
- en: Clear separation of capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the Micro Services architecture, these services can be organized based on
    business capabilities. For example, an inventory service can be separated from
    a billing service, which can be separate from a shipping service. In case one
    of the services fails, the others can still continue serving requests as mentioned
    in the *Isolation of Problems* section.
  prefs: []
  type: TYPE_NORMAL
- en: Language independence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another advantage of the Micro Services architecture is that the services are
    built with a simple and easy-to-consume REST/JSON-based API that can be easily
    consumed by other languages or frameworks such as PHP, Ruby-On-Rails, Python,
    and node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon and Netflix are some of the pioneers in the Micro Services architecture.
    eBay has open sourced Turmeric, a comprehensive, policy-driven SOA platform that
    can be used to develop, deploy, secure, run, and monitor SOA services and consumers.
  prefs: []
  type: TYPE_NORMAL
- en: Recommended reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the links to additional resources that interested readers
    can take a look at to get a more complete picture of use cases mentioned in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://stripe.com/docs/webhooks](https://stripe.com/docs/webhooks): WebHooks
    support'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/sockjs](https://github.com/sockjs): GitHub SockJs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.github.com/webhooks/testing/](https://developer.github.com/webhooks/testing/):
    GitHub WebHooks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.twilio.com/platform/webhooks](http://www.twilio.com/platform/webhooks):
    Twilio WebHooks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://xmpp4js.sourceforge.net/](http://xmpp4js.sourceforge.net/): XMPP4JS
    BOSH library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://code.google.com/p/emite/](https://code.google.com/p/emite/): Emite
    BOSH library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we covered advanced topics such as WebHooks, SSEs, WebSockets,
    and where and how they are being used in this chapter. One of the primary takeaways
    from this chapter was to understand how important it is to provide real-time APIs
    to avoid inefficiencies related to repeated polling. We saw case studies of companies
    using both WebHooks and WebSockets in their solutions. We saw different best practices
    and design principles sprinkled throughout the various chapters in the book; this
    chapter, as a finale, provided a substantial introduction to the future of REST
    and asynchronous communication. The proliferation of social data has the potential
    to be a great catalyst for the development of a semantic web that will enable
    agents to make nontrivial actions on our behalf and get real-time updates using
    the various patterns we discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we saw how highly available cloud applications tend to move to a networked
    component model where applications are decomposed into *micro* services, which
    can be deployed and scaled independently using the Micro Services architecture.
    For more detailed information on building RESTful services, check out the book
    *Developing RESTful Services with JAX-RS2.0, WebSockets, and JSON*, *Bhakti Mehta
    and Masoud Kalali*, *Packt Publishing*.
  prefs: []
  type: TYPE_NORMAL
