- en: Functions as First-Class Citizens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how Kotlin features relate to OOP. This chapter
    will introduce advanced functional programming features that were previously not
    present in standard Android development. Some of them were introduced in Java
    8 (in Android through the Retrolambda plugin), but Kotlin introduces many more
    functional programming features.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is about high-level functions and functions as first-class citizens.
    Most of the concepts are going to be familiar to readers who have used functional
    languages in the past.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Function types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anonymous functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit name of a single parameter in a lambda expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last lambda in argument convention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java **Single Abstract Method** (**SAM** ) lambda interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java methods with Java Single Abstract Method on parameters usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named parameters in function types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin supports functional programming, and functions are first-class citizens
    in Kotlin. A first-class citizen, in a given programming language, is a term that
    describes an entity that supports all the operations generally available to other
    entities. These operations typically include being passed as an argument, returned
    from a function, and assigned to a variable. The sentence "*a function is a first-class
    citizen in Kotlin* " should then be understood as: *it is possible in Kotlin to
    pass functions as an argument, return them from functions, and assign them to
    variables* . While Kotlin is a statically typed language, there needs to be a
    function type defined to allow these operations. In Kotlin, the notation used
    to define a function type is following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(Int)->Int` : A function that takes `Int` as an argument and returns `Int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`()->Int` : A function that takes no arguments and returns `Int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(Int)->Unit` : A function that takes `Int` and does not return anything (only
    `Unit` , which does not need to be returned)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples of properties that can hold functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The term *function type* is most often defined as the type of a variable or
    parameter to which a function can be assigned, or the argument or result type
    of a higher-order function taking or returning a function. In Kotlin, the function
    type can be treated like an interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see later in this chapter that Kotlin functions can take other functions
    in arguments, or even return them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function can take or return a function, then the function type also needs
    to be able to define functions that take a function as an argument, or return
    a function. This is done by simply placing a function type notation as a parameter
    or a return type. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(String)->(Int)->Int` : A function that takes `String` and returns a function
    that takes `Int` type and returns `Int` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(()->Int)->String` : A function that takes another function as an argument,
    and returns `String` type. Function in argument takes no arguments and returns
    `Int` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each property with a function type can be called like a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions can not only be stored in variables, they can also be used as a generic.
    For example, we can keep the functions in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding list can store functions with the `() -> Unit` signature.
  prefs: []
  type: TYPE_NORMAL
- en: What is function type under the hood?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Under the hood, function types are just a syntactic sugar for generic interfaces.
    Let''s look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The `()->Unit` signature is an interface for `Function0<Unit>` . The expression
    is `Function0` , because it has zero parameters, and `Unit` because it is the
    return type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `(Int)->Unit` signature is interface for `Function1<Int, Unit>` . The expression
    is `Function1` because it has one parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `()->(Int, Int)->String` signature is an interface for `Function0<Function2<Int,
    Int, String>>` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these interfaces have only one method, `invoke` , which is an operator.
    It allows an object to be used like a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: These two statements have the same meaning
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Function interfaces are not present in a standard library. They are synthetic
    compiler-generated types (they are generated during compilation). Because of this,
    there is no artificial limit in number of function type arguments, and the standard
    library size is not increased.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One way of defining a function as an object is by using **anonymous functions**
    . They work the same way as normal functions, but they have no name between the
    `fun` keyword and the parameters declaration, so by default they are treated as
    objects. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is an anonymous single expression function. Note that like in a normal
    single expression function, the return type does not need to be specified when
    it is inferred from the expression return type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consider the following usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous examples, function types were defined explicitly, but while
    Kotlin has a good type inference system, the function type can also be inferred
    from types defined by an anonymous default function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It also works in the opposite way. When we define the type of a property, then
    we don''t need to set parameter types in anonymous functions explicitly, because
    they are inferred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we check out the methods of function types, then we will see that there
    is only the `invoke` method inside. The `invoke` method is an operator function,
    and it can be used in the same way as function invocation. This is why the same
    result can be achieved by using the `invoke` call inside brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This knowledge can be helpful, for example, when we are keeping function in
    a nullable variable. We can, for example, use the `invoke` method by using the
    safe call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Variable `a` is nullable, we are using invoke by a safe call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s look at an Android example. We often want to define a single error handler
    that will include multiple logging methods and pass it to different objects as
    an argument. Here is how we can implement it using anonymous functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Anonymous functions are simple and useful. They are a simple way of defining
    functions that can be used and passed as objects. But there is a simpler way of
    achieving similar behavior, and it is called lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest way to define anonymous functions in Kotlin is by using a feature
    called lambda expressions. They are similar to Java 8 lambda expressions, but
    the biggest difference is that Kotlin lambdas are actually closures, so they allow
    us to change variables from the creation context. This is not allowed in Java
    8 lambdas. We will discuss this difference later in this section. Let''s start
    with some simple examples. Lambda expressions in Kotlin have the following notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of return, result of the last expression is returned. Here are some
    simple lambda expression examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{ 1 }` : A lambda expression that takes no arguments and returns 1\. Its type
    is `()->Int` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{ s: String -> println(s) }` : A lambda expression that takes one argument
    of type `String` , and prints it. It returns `Unit` . Its type is `(String)->Unit`
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{ a: Int, b: Int -> a + b }` : A lambda expression that takes two `Int` arguments
    and returns the sum of them. Its type is `(Int, Int)->Int` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Functions we defined in the previous chapter can be defined using lambda expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'While the returned value is taken from the last statement in lambda expressions,
    return is not allowed unless it has a `return` statement qualified by a label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Lambda expressions can be multiline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is the last statement, so the result of this expression will be a returned
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Multiple statements can also be defined in a single line when they are separated
    by semicolons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A lambda expression does not need to only operate on values provided by arguments.
    Lambda expressions in Kotlin can use all properties and functions from the context
    where they are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the biggest difference between Kotlin and Java 8 lambda usage. Both
    Java anonymous objects and Java 8 lambda expressions allow us to use fields from
    the context, but Java does not allow us to assign different values to these variables
    (Java variables used in lambda must be final):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Kotlin has gone a step ahead by allowing lambda expressions and anonymous functions
    to modify these variables. Lambda expressions that enclose local variables and
    allow us to change them inside the function body are called **closures** . Kotlin
    fully supports closure definition. To avoid confusion between lambdas and closures,
    in this book, we will always call both of them lambdas. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Lambda expressions can use and modify variables from the local context. Here
    is an example of counter, where the value is kept in a local variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here is how View `onClickListener` can be set in Kotlin using a lambda expression.
    This will be described in the *Java SAM support in Kotlin* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Thanks to this feature, it is simpler to use lambda expressions. Note that,
    in the preceding example, the `showValue` type was not specified. This is because
    in Kotlin lambdas, typing arguments is optional when the compiler can infer it
    from the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The inferred type of `i` is `Int` , because the function type defines an `Int`
    parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The inferred type of `s` is `String` , because the function type defines a `String`
    parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we can see in the following example, we don''t need to specify the type
    of parameter because it is inferred from the type of the property. Type inference
    also works in the another way--we can define the type of a lambda expression''s
    parameter to infer the property type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The inferred type is `()->Int` , because `4` is `Int` and there is no parameter
    type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The inferred type is `(String)->Unit` , because the parameter is typed as `String`
    , and the return type of the `println` method is `Unit` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The inferred type is `(Int)->Int` , because `i` is typed as `Int` , and the
    return type of the times operation from `Int` is also `Int` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This inference simplifies lambda expression definition. Often, when we are defining
    lambda expressions as function parameters, we don't need to specify parameter
    types each time. But there is also another benefit--while the parameter type can
    be inferred, a simpler notation for single parameter lambda expressions can be
    used. Let's discuss this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit name of a single parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can omit lambda parameter definitions and access parameters using the `it`
    keyword when two conditions are met:'
  prefs: []
  type: TYPE_NORMAL
- en: There is only one parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameter type can be inferred from the context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, let''s define the properties `a` and `c` again, but this time
    using the implicit name of a single parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Same as `{ i -> i * 2 }` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Same as `{ s -> println(s) }` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This notation is really popular in Kotlin, mostly because it is shorter and
    it allows us to avoid parameter type specification. It also improves the readability
    of processing defined in LINQ style. This style needs components that have not
    yet been introduced, but just to show the idea, let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Supposing that strings is `List<String>` , this expression filters strings with
    a length equal to `5` and converts them to uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the body of lambda expressions, we can use methods of the `String`
    class. This is because function type (such as `(String)->Boolean` for the `filter`
    ) is interred from the method definition, which infers `String` from the iterable
    type (`List<String>` ). Also, the type of the returned list (`List<String>` )
    depends on what is returned by the lambda (`String` ).
  prefs: []
  type: TYPE_NORMAL
- en: LINQ style is popular in functional languages because it makes the syntax of
    collections or String processing really simple and concise. It will be discussed
    in much more detail in [Chapter 7](text00171.html) , *Extension Functions and
    Properties* .
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A higher-order function is a function that takes at least one function as an
    argument, or returns a function as its result. It is fully supported in Kotlin,
    as functions are first-class citizens. Let''s see it in an example. Let''s suppose
    that we need two functions: a function that will add all `BigDecimal` numbers
    from list, and a function that will get the product (the result of multiplication
    between all the elements in this list) of all these numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'These are readable functions, but also these functions are nearly the same.
    The only difference is name, accumulator (`BigDecimal.ZERO` or `BigDecimal.ONE`
    ), and operation. If we use the **DRY** (**Don''t Repeat Yourself** ) rule then
    we shouldn''t leave two parts of similar code in the project. While it is easy
    to define a function that will have similar behavior and just differ in the objects
    used, it is harder to define a function that will differ in the operation performed
    (here, functions differ by the operation used to accumulate). Solution comes with
    the function type, because we can pass the operation as an argument. In this example,
    it is possible to extract the common method this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fold` function iterates through numbers and updates `acc` using each element.
    Note that the function parameter is defined like any other type, and it can be
    used like any other function. For example, we can have the vararg function type
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In `longOperation` , `for` is used to iterate over all the observers and invokes
    them one after another. This function allows multiple functions to be provided
    as arguments. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions in Kotlin can also return functions. For example, we can define a
    function that will create custom error handlers with the same error logging but
    different tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The three most common cases when functions in arguments are used are:'
  prefs: []
  type: TYPE_NORMAL
- en: Providing operations to functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The observer (listener) pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callback after a threaded operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Providing operations to functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw in the previous section, sometimes we want to extract common functionality
    from functions, but they differ in an operation they use. In such situations,
    we can still extract this functionality, but we need to provide an argument with
    operation that distinguishes them. This way, any common pattern can be extracted
    and reused. For example, we often only need elements of the list that match some
    predicate, such as when we only want to show elements that are active. Classically,
    this would be implemented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'While it is a common operation, we can extract the functionality of only filtering
    some elements according to the predicate to separate the function and use it more
    easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This way of using higher-order functions is very important and it will be described
    often throughout the book, but this is not the only way that higher-order functions
    are often used.
  prefs: []
  type: TYPE_NORMAL
- en: Observer (Listener) pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use the Observer (Listener) pattern when we want to perform operations when
    an event occurs. In Android development, observers are often set to view elements.
    Common examples are on-click listeners, on-touch listeners, or text watchers.
    In Kotlin, we can set listeners with no boilerplate. For example, setting listener
    on button click looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `setOnClickListener` is a Java method from the Android library.
    Later, we will see in detail why we can use it with lambda expression. The creation
    of listeners is very simple. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create an empty list to hold all listeners.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can simply add a listener to the listeners list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can iterate through the listeners and invoke them one after another.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is hard to imagine a simpler implementation of this pattern. There is another
    common use case where parameters with function types are commonly used--callback
    after a threaded operation.
  prefs: []
  type: TYPE_NORMAL
- en: Callback after a threaded operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we need to do a long operation, and we don''t want to make the user wait
    for it, then we have to start it in another thread. To be able to use callback
    after long operation called in separate thread, we need to pass it as an argument.
    Here''s an example function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create `Thread` . We also pass a lambda expression that we would like
    to execute on the constructor argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we are executing a long operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we start the callback operation provided in the argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`start` is a method that starts the defined thread.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is printed after one second delay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is printed immediately .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Actually, there are some popular alternatives to using callbacks, such as RxJava.
    Still, classic callbacks are in common use, and in Kotlin they can be implemented
    with no boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: These are the most common use cases where higher-order functions are used. All
    of them allow us to extract common behavior and decrease boilerplate. Kotlin allows
    a few more improvements regarding higher-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: Combination of named arguments and lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using default named arguments and lambda expressions can be really useful in
    Android. Let''s look at some other practical Android examples. Let''s suppose
    we have a function that downloads elements and shows them to user. We will add
    a few parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onStart` : This will be called before the network operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onFinish` : This will be called after the network operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can show and hide loading spinner in `onStart` and `onFinish` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If we start it from `swipeRefresh` , then we just need to hide it when it finishes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to make a quiet refresh, then we just call this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Named argument syntax and lambda expressions are a perfect match for multi-purpose
    functions. This connects both the ability to choose the arguments we want to implement
    and the operations that should be implemented. If a function contains more than
    one function type parameter, then in most cases, it should be used by named argument
    syntax. This is because lambda expressions are rarely self-explanatory when more
    than one is used as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Last lambda in argument convention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Kotlin, higher-order functions are really important, and so it is also important
    to make their usage as comfortable as possible. This is why Kotlin introduced
    a special convention that makes higher-order functions more simple and clear.
    It works this way: if the last parameter is a function, then we can define a lambda
    expression outside of the brackets. Let''s see how it looks if we use it with
    the `longOperationAsync` function, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The function type is in the last position in the arguments. This is why we
    can execute it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the last lambda in argument convention, we can locate the lambda after
    the brackets. It looks as if it is outside the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s see how the invocation of code in another thread can
    be done in Kotlin. The standard way of starting a new thread in Kotlin is by using
    the `thread` function from Kotlin standard library. Its definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the `block` parameter, which takes operations that should be
    invoked asynchronously, is in the last position. All other parameters have a default
    argument defined. That is why we can use the `thread` function in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `thread` definition has lots of other arguments, and we can set them either
    by using named argument syntax or just by providing them one after another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lambda in argument convention is syntactic sugar, but it makes it
    much easier to use higher-order functions. These are the two most common cases
    where this convention really makes a difference:'
  prefs: []
  type: TYPE_NORMAL
- en: Named code surrounding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing data structures using LINQ-style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at them closely.
  prefs: []
  type: TYPE_NORMAL
- en: Named code surrounding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes we need to mark some part of the code to be executed in different
    way. The `thread` function is this kind of situation. We need some code to be
    executed asynchronously, so we surround it with bracket starting from the `thread`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'From the outside, it looks as if it is a part of code that is surrounded by
    a block named `thread` . Let''s look at another example. Let''s suppose that we
    want to log the execution time of a certain code block. As a helper, we will define
    the `addLogs` function, which will print logs together with the execution time.
    We will define it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the usage of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example of its execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'On executing the preceding code, the following output is presented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The exact number of printed milliseconds may differ a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern is really useful in Kotlin projects because some patterns are
    connected to blocks of code. For example, it is common to check whether the version
    of the API is after Android 5.x Lollipop before the execution of features that
    need at least this version to work. To check it, we used the following condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'But in Kotlin, we can just extract the function in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not only comfortable, but also it is lowering redundancy in the code.
    This is often referred as very good practice. Also note that this convention allows
    us to define control structures that work in a similar way to standard ones. We
    can, for example, define a simple control structure that is running as long as
    the statement in the body does not return an error. Here is the definition and
    usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: An additional advantage is that our custom data structure can return a value.
    The impressive part is that is doesn't need any extra language support, and we
    can define nearly any control structure we want.
  prefs: []
  type: TYPE_NORMAL
- en: Processing data structures using LINQ style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already mentioned that Kotlin allows LINQ-style processing. The last
    lambda in argument convention is another component that aids its readability.
    For example, look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'It is more readable than notation that does not use the last lambda in argument
    convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Again, this processing will be discussed in detail later, in [Chapter 7](text00171.html)
    , *Extension Functions and Properties* , but for now we have learned about two
    features that improve its readability (the last lambda in argument convention
    and the implicit name of a single parameter).
  prefs: []
  type: TYPE_NORMAL
- en: The last lambda in argument convention is one of the Kotlin features that was
    introduced to improve the use of lambda expressions. There are more such improvements,
    and how they work together is important to make the use of higher-order functions
    simple, readable, and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Java SAM support in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is really easy to use higher-order functions in Kotlin. The problem is that
    we often need to interoperate with Java, which natively doesn''t support it. It
    achieves substitution by using interfaces with only one method. This kind of interface
    is called a **Single Abstract Method** (**SAM** ) or functional interface. The
    best example of situation in which we need to set up a function this way, is when
    we are using `setOnClickListener` on a `View` element. In Java (until 8) there
    was no simpler way than by using an anonymous inner class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the `OnClickListener` method is the SAM, because
    it contains only a single method, `onClick` . While SAMs are really often used
    as a replacement for function definitions, Kotlin also generates a constructor
    for them that contains the function type as a parameter. It is called a SAM constructor.
    A SAM constructor allows us to create an instance of a Java SAM interface just
    by calling its name and passing a *function literal* . Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'A *function literal* is an expression that defines unnamed function. In Kotlin,
    there are two kinds of *function literal* :'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Anonymous functions
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Lambda expressions
  prefs: []
  type: TYPE_NORMAL
- en: 'Both Kotlin *function literal* have already been described:'
  prefs: []
  type: TYPE_NORMAL
- en: '`val a = fun() {} // Anonymous function`'
  prefs: []
  type: TYPE_NORMAL
- en: '`val b = {} // Lambda expression`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even better, for each Java method that takes a SAM, the Kotlin compiler is
    generating a version that instead takes a function as an argument. This is why
    we can set `OnClickListener` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that the Kotlin compiler is generating SAM constructors and function
    methods only for Java SAMs. It is not generating SAM constructors for Kotlin interfaces
    with a single method. It is because the Kotlin community is pushing to use function
    types and not SAMs in Kotlin code. When a function is written in Kotlin and includes
    a SAM, then we cannot use it as Java methods with SAM on parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This does not work because the `setOnClick` function is written in Kotlin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Kotlin, interfaces shouldn''t be used this way. The preferred way is to
    use function types instead of SAMs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The Kotlin compiler generates a SAM constructor for every SAM interface defined
    in Java. This interface only includes the function type that can substitute a
    SAM. Look at the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use it in Kotlin this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can provide it as function argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are more examples of the Java SAM lambda interface and methods from Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s some examples from RxJava:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's look at how a Kotlin alternative to SAM definition can be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Named Kotlin function types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin does not support SAM conversions of types defined in Kotlin, because
    the preferred way is to use function types instead. But SAM has some advantages
    over classic function types: named and named parameters. It is good to have the
    function type named when its definition is long or it is passed multiple times
    as an argument. It is good to have named parameters when it is not clear what
    each parameter means just by its type.'
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we are going to see that it is possible to name both
    the parameters and the whole definition of a function type. It can be done with
    type aliases and named parameters in the function type. This way, it is possible
    to have all the advantages of SAM while sticking with function types.
  prefs: []
  type: TYPE_NORMAL
- en: Named parameters in function type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now, we''ve only seen definitions of function types where only the types
    were specified, but not parameter names. Parameter names have been specified in
    *function literals* :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem comes when the parameters are not self-explanatory, and the developer
    does not know what the parameters mean. With SAMs there were suggestions, while
    in the function type defined in the previous example, they are not really helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The solution is to define function type with named parameters. Here is what
    it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The benefit of this notation is that the IDE suggests these names as the names
    of the parameters in the *function literal* . Because of this, programmer can
    avoid any confusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The problem occurs when the same function type is used multiple times, then
    it is not easy to define those parameters for each definition. In that situation,
    a different Kotlin feature is used - the one we describe in next section--*type
    alias* .
  prefs: []
  type: TYPE_NORMAL
- en: Type alias
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From version 1.1, Kotlin has had a feature called **type alias** , which allows
    us to provide alternative names for existing types. Here is an example of a type
    alias definition where we have made a list of `Users` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, we can add more meaningful names to existing data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Type aliases must be declared at the top level. A visibility modifier can be
    applied to a type alias to adjust its scope, but they are public by default. This
    means that the type aliases defined previously can be used without any limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep in mind that aliases are used to improve code readability, and the original
    types can still be used interchangably:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Another application of `typealias` is to shorten long generic types and give
    them more meaningful names. This improves code readability and consistency when
    the same type is used in multiple places in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Type aliases are often used to name function types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use them together with function type parameter names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we get parameter suggestions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at an example of how function types named by type alias can be
    implemented by class. Parameter names from function types are also suggested as
    method parameters names in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the main reasons why we are using named function types:'
  prefs: []
  type: TYPE_NORMAL
- en: Names are often shorter and easier than whole function type definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we are passing functions, after changing their definitions, we don't have
    to change it everywhere if we are using type aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easier to have defined parameter names when we use type aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two features (named parameter in function types and type aliases) combined
    are the reasons why there is no need to define SAMs in Kotlin--all the advantages
    of SAMs over function types (name and named parameters) can be achieved with named
    parameters in function type definitions and type aliases. This is another example
    of how Kotlin supports functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Underscore for unused variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some cases, we are defining a lambda expression that does not use all its
    parameters. When we leave them named, then they might be destructing a programmer
    who is reading this lambda expression and trying to understand its purpose. Let''s
    look at the function that is filtering every second element. The second parameter
    is the element value, and it is unused in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'To prevent misunderstanding, there are some conventions used, such as the ignoring
    the parameter names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Because these conventions were unclear and problematic, Kotlin introduced underscore
    notation, which is used as a replacement for the names of parameters that are
    not used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This notation is suggested, and there is a warning displayed when a lambda
    expression parameter is unused:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Destructuring in lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 4](text00088.html) , *Classes and Objects* , we''ve seen how objects
    can be destructured into multiple properties using destructuring declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Since version 1.1, Kotlin can use destructuring declarations syntax for lambda
    parameters. To use them, you should use parentheses that include all the parameters
    that we want to destructure into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin''s destructing declaration is position-based, as opposed to the property
    name-based destructuring declaration that can be found, for example, in TypeScript.
    In position-based destructing declarations, the order of properties decides which
    property is assigned to which variable. In property name-based destructuring,
    it is determined by the names of variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`//TypeScript`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const obj = { first: ''Jane'', last: ''Doe'' };`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const { last, first } = obj;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.log(first); // Prints: Jane`'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.log(last); // Prints: Doe`'
  prefs: []
  type: TYPE_NORMAL
- en: Both solutions have its pros and cons. Position-based destructing declarations
    are secured for renaming a property, but they are not safe for property reordering.
    Name-based destructuring declarations are safe for property reordering but are
    vulnerable for property renaming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Destructuring declarations can be used multiple times in a single lambda expression,
    and it can be used together with normal parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Deconstruction of `Pair`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deconstruction of `Pair` and other element
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiple deconstructions in single lambda expression
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that we can destructure a class into less than all components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Underscore notation is allowed in destructuring declarations. It is most often
    used to get to the further components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to specify the type of the destructured parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The type is inferred from the lambda expression
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, parameters defined by destructuring declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The type is inferred from the lambda expression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The type cannot be inferred because there is not enough information about types
    inside the lambda expression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This all makes destructuring in lambdas a really useful feature. Let''s look
    at some most common use cases in Android where deconstruction in lambdas is used.
    It is used to process the elements of `Map` because they are of type `Map.Entry`
    , which can be destructed to the `key` and `value` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, lists of pairs can be destructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Destructuring declarations are also used when we want to simplify data objects
    processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'This is especially useful in libraries that are used to asynchronously process
    elements (such as RxJava). Their functions are designed to process single elements,
    and if we want multiple elements to be processed, then we need to pack them in
    `Pair` , `Triple` , or some other data class and use a destructuring declaration
    on each step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Inline functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Higher-order functions are very helpful and they can really improve the reusability
    of code. However, one of the biggest concerns about using them is efficiency.
    Lambda expression are compiled to classes (often anonymous classes), and object
    creation in Java is a heavy operation. We can still use higher-order functions
    in an effective way while keeping all the benefits by making functions inline.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of inline functions is pretty old, and it is mostly related to
    C++ or C. When a function is marked as inline, during code compilation the compiler
    will replace all the function calls with the actual body of the function. Also,
    lambda expressions provided as arguments are replaced with their actual body.
    They will not be treated as functions, but as actual code. This is makes bytecode
    longer, but runtime execution is much more efficient. Later, we will see that
    nearly all higher-order functions from standard library are marked as inline.
    Let''s look at the example. Suppose we marked the `printExecutionTime` function
    with the `inline` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'When we compile and decompile `measureOperation` , we are going to find out
    that the function call is replaced with its actual body, and the parameter function
    call is replaced by the lambda expression''s body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Code from `printExecutionTime` was added to `measureOperation` function body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code located inside the lambda was located on its call. If the function used
    it multiple times, then the code would replace each call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The body of `printExecutionTime` can still be found in the code. It was skipped
    to make the example more readable. It is kept in the code because it might be
    used after compilation, for example, if this code is added to a project as a library.
    What is more, this function will still work as inline when used by Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: 'While there is no need to create classes for lambda expressions, inline functions
    can speed up the execution of functions with function parameters. This difference
    is so important that it is recommended to use the inline modifier for all short
    functions with at least one function parameter. Unfortunately, using the inline
    modifier also has its bad sides. The first, we''ve already mentioned--the produced
    bytecode is longer. This is because function calls are replaced by function bodies
    and because lambda calls inside this body are replaced with the body of the *function
    literal* . Also, inline functions cannot be recursive and they cannot use functions
    or classes that have more restrictive visibility modifier than this lambda expression.
    For example, public inline functions cannot use private functions. The reason
    is that it could lead to the injection of code into functions that cannot use
    them. This would lead to a compilation error. To prevent it, Kotlin does not permit
    the use of elements with less restrictive modifiers than the lambda expression
    in which they are placed. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, it is possible in Kotlin to use elements with more restrictive visibility
    in `inline` functions if we suppress this warning, but this is bad practice and
    it should never be used this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Tester1.kt`'
  prefs: []
  type: TYPE_NORMAL
- en: '`fun main(args: Array<String>) { a() }`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Tester2.kt`'
  prefs: []
  type: TYPE_NORMAL
- en: '`inline fun a() { b() }`'
  prefs: []
  type: TYPE_NORMAL
- en: '`private fun b() { print("B") }` How is it possible? For the internal modifier
    it is simpler, because the internal modifier is public under the hood. For private
    functions, there is an additional `access$b` function created that has `public`
    visibility and that is only invoking the `b` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public static final void access$b() { b(); }`'
  prefs: []
  type: TYPE_NORMAL
- en: This behavior is presented here just to explain why less restrictive modifiers
    can sometimes be used inside `inline` functions (these situations can be found
    in Kotlin standard library in Kotlin 1.1). In the projects, we should design elements
    in such a way that there is no need to use such suppressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another problem is less intuitive. While no lambda has been created, we cannot
    pass parameters that are of the function type to another function. Here is an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: When function is `inline` , then its function arguments cannot be passed to
    function that are not inline.
  prefs: []
  type: TYPE_NORMAL
- en: This doesn't work because no `f` parameter has been created. It has just been
    defined to be replaced by the *function literal* body. This is why it cannot be
    passed to another function as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to deal with it is by making the `boo` function inline as
    well. Then it will be OK. In most cases, we cannot make too many functions inline.
    Here are a few reasons why:'
  prefs: []
  type: TYPE_NORMAL
- en: The `inline` functions should be used for smaller functions. If we are making
    `inline` functions that are using other `inline` functions, then it can lead to
    a large structure being generated after compilation. This is a problem both because
    of compilation time and because of the resulting code's size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While `inline` functions cannot use element with visibility modifiers more strict
    than the one they have, it would be a problem if we would like to use them in
    libraries where as many functions as possible should be private to protect the
    API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The simplest way to deal with this problem is by making function parameters
    that we do want to pass to another function `noinline` .
  prefs: []
  type: TYPE_NORMAL
- en: The noinline modifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `noinline` is a modifier for function type parameters. It makes a specific
    argument treated as normal function type parameter (its calls are not replaced
    with the *function literal* body). Let''s look at a `noinline` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The `noinline` annotation modifier before parameter `f` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The before function will be replaced by the body of the lambda expression used
    as an argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`f` is `noinline` so it can be passed to the boo function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Two main reasons to use `noinline` modifier are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When we need to pass a specific lambda to some other function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we are calling the lambda intensively and we don't want to swell the code
    too much
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that when we make all function parameters `noinline,` then there will be
    nearly no performance improvement from making the functions inline. While it is
    unlikely that using `inline` will be beneficial, the compiler will show a warning.
    This is why, in most cases, `noinline` is only used when there are multiple function
    parameters and we only apply it to some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Non-local returns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions with function parameters might act similarly to native structures
    (such as loops). We''ve already seen the `ifSupportsLolipop` function and the
    `repeatUntilError` function. An even more common example is the `forEach` modifier.
    It is an alternative to the `for` control structure, and it calls a parameter
    function with each element one after another. This is how it could be implemented
    (there is a `forEach` modifier in Kotlin standard library, but we will see it
    later because it includes elements that have not yet been presented):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The big problem is that inside the `forEach` function defined this way we cannot
    return from outer function. For example, this is how we could implement the `maxBounded`
    function using a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to treat `forEach` as an alternative to a `for` loop, then similar
    possibility should be allowed there. The problem is that the same code, but with
    `forEach` used instead of `for` loop, would not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The reason is related to how the code is compiled. We have already discussed
    that lambda expressions are compiled to class of anonymous objects with a method
    that includes the defined code, and over there we cannot return from the `maxBounded`
    function because we are in a different context.
  prefs: []
  type: TYPE_NORMAL
- en: 'We encounter a situation when the `forEach` function is marked as inline. As
    we have already mentioned, the body of this function replaces its calls during
    compilation, and all of the functions from the parameters are replaced with their
    body. So, there is no problem with using the `return` modifier there. Then, if
    we make `forEach` inline, we can use return inside the lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the `maxBounded` function has compiled in Kotlin, and the code
    looks like this (after some clean-up and simplification) when it is decompiled
    to Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `return` is important--it was defined in the lambda expression,
    and it is returning from the `maxBounded` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `return` modifier used inside the lambda expression of the `inline` function
    is called a non-local return.
  prefs: []
  type: TYPE_NORMAL
- en: Labeled return in lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a case in which we need to return from a lambda expression and
    not from a function. We can do this using labels. Here is an example of a return
    from a lambda expression using labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This is generic implementation of `forEach` function, where list with any type
    can be processed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define label for lambda expression inside `forEach` argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We return from lambda expression specified by label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another Kotlin feature is that lambda expressions that are defined as function
    arguments have a default label whose name is the same as the function in which
    they are defined. This label is called an **implicit label** . When we want to
    return from a lambda expression defined in a `forEach` function, we can do it
    just by using `return@forEach` . Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Implicit label name is taken from function name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that while the `forEach` function is inline, we can also use a non-local
    return to return from the `processMessageButNotError` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s move onto a more complex example of using non-local return labels. Let''s
    suppose that we have two `forEach` loops, one inside another. When we use an implicit
    label, it will return from the deeper loop. In our example, we can use it to skip
    the processing of the specific message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: This will return from the lambda defined in the `forEach` function that also
    takes messages as an argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We cannot return from another lambda expression in the same context using implicit
    label, because it is shadowed by a deeper implicit label.
  prefs: []
  type: TYPE_NORMAL
- en: 'In these situations, we need to use a non-local implicit label return. It is
    only permissible with inline function parameters. In our example, while `forEach`
    is inline, we can return from a *function literal* this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This will return from the lambda defined in `forEach` called on conversations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can also just use a non-local return (a return without any labels) to finish
    the processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: This will return from the `processMessageButNotError` function and finish the
    processing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Crossinline modifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes we need to use function type parameters from inline functions not
    directly in the function body, but in another execution context, such as a local
    object or a nested function. But standard function type parameters of inline functions
    are not allowed to be used this way, because they are allowing non-local returns,
    and it should not be allowed if this function could be used inside another execution
    context. To inform the compiler that non-local returns are not allowed, this parameter
    must be annotated as `crossinline` . Then it will act like a substitution that
    we are expecting in an `inline` function, even when it is used inside another
    lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be compiled as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'While no property has been created with the function, it is not possible to
    pass the crossinline parameter to another function as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00042.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at a practical example. In Android, we don''t need `Context` to
    execute an operation on the main thread of the application because we can get
    a main loop using the `getMainLooper` static function from the `Looper` class.
    Therefore, we can write a top-level function that will allow a simple thread change
    into the main thread. To optimize it, we are first checking if the current thread
    is not the main thread. When it is, then the action is just invoked. When it is
    not, then we create a handler that operates on the main thread and a post operation
    to invoke it from there. To make the execution of this function faster, we are
    going to make the `runOnUiThread` function inline, but then to allow the action
    invocation from another thread, we need to make it crossinline. Here is an implementation
    of this described function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: We can run `action` inside a lambda expression thanks to the `crossinline` modifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `crossinline` annotation is useful because it allows to use function types
    in the context of lambda expressions or local functions while maintaining the
    advantages of making the function `inline` (there's no need for lambda creation
    in this context).
  prefs: []
  type: TYPE_NORMAL
- en: Inline properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since Kotlin 1.1, the `inline` modifier can be used on properties that do not
    have a backing field. It can be either applied to separate accessors, which will
    result in their body replacing usage, or it can be used for whole property, which
    will have the same result as making both accessors inline. Let''s make an inline
    property that will be used to check and change an element''s visibility. Here
    is an implementation where both accessors are inline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'We can achieve the same result if we annotate the whole property as inline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code be compiled as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: This way, we have omitted the setter and getter function calls, and we should
    expect a performance improvement with the cost of increased compiled code size.
    Still, for most properties, it should be profitable to use the `inline` modifier.
  prefs: []
  type: TYPE_NORMAL
- en: Function References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, functions that we want to pass as an argument are already defined
    as a separate function. Then we can just define the lambda with its call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'But Kotlin also allows us to pass a function as a value. To be able to use
    a top-level function as a value, we need to use a function reference, which is
    used as a double colon and the function name (`::functionName` ). Here is an example
    how it can be used to provide a predicate to `filter` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Function reference is example of reflection, and this is why the object returned
    by this operation also contains information about the referred function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'But this object also implements the function type, and it can be used this
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to reference to methods. To do it, we need to write the
    type name, two colons, and the method name (`Type::functionName` ). Here is an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'As in the preceding example, when we are referencing a non-static method, there
    needs to be a provided instance of the class as an argument. The `isEmpty` function
    is a `String` method that takes no arguments. The reference to `isEmpty` has a
    `String` parameter that will be used as an object on which the function is invoked.
    The reference to the object is always located as the first parameter. Here is
    another example, where the method has the property `food` already defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a different situation when we are referencing a Java static method,
    because it does not need instance of the class on which it is defined. This is
    similar to methods of *objects* or *companion objects* , where the object is known
    in advance and does not need to be provided. In these situations, there is a function
    created with the same parameters as the referenced function and the same return
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'In function reference usage, there are common use cases where we want to use
    function references to provide method from a class we have reference to. Common
    example is when we want to extract some operations as method of the same class,
    or when we want to reference to functions from reference member function from
    class we have reference to. A simple example is when we define what should be
    done after a network operation. It is defined in a Presenter (such as `MainPresenter`
    ), but it is referencing all the View operations, that are defined by the `view`
    property (which is, for example, of type `MainView` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '`showProgress` , `displayError` , and `hideProgress` are defined in `MainView`
    .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`onUsersLoaded` is method defined in `MainPresenter` .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To help in this kind of situation, Kotlin introduced in version 1.1 feature
    called **bound references** , which provide references that are bound to a specific
    object. Thanks to that, this object does not need to be provided by an argument.
    Using this notation, we can replace the previous definition this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Another function that we might want to reference is a constructor. An example
    use case is when we need to map from a **data transfer object** (**DTO** ) to
    a class that is part of a model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Here, `User` needs to have a constructor that defines how it is constructed
    from `UserDto` .
  prefs: []
  type: TYPE_NORMAL
- en: A DTO is an object that carries data between processes. It is used because classes
    used during communications between a system (in an API) are different than actual
    classes used inside the system (a model).
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kotlin, constructors are used and treated similarly to functions. We can
    also reference to them with a double colon and a class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, we can replace the lambda with a constructor call with a constructor
    reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Using function references instead of lambda expressions gives us shorter and
    often more readable notation. It is also especially useful when we are passing
    multiple functions as parameters, or functions that are long and need to be extracted.
    In other cases, there is the useful bounded reference, which provides a reference
    that is bound to a specific object.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ve discussed using functions as first-class citizens.
    We''ve seen how function types are used. We have seen how to define *function
    literals* (anonymous functions and lambda expressions), and that any function
    can be used as an object thanks to function references. We''ve also discussed
    higher-order functions and different Kotlin features that support them: the implicit
    name of a single parameter, the last lambda in argument convention, Java SAM support,
    using an underscore for unused variables, and destructuring declarations in lambda
    expressions. This features provide great support for higher-order functions, and
    they make functions even more than first-class citizens.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to see how generics work in Kotlin. This will
    allow us to define much more powerful classes and functions. We will also see
    how well they can be used when connected to higher-order functions.
  prefs: []
  type: TYPE_NORMAL
