- en: Chapter 4. Implementing Functional Programming Techniques in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hold on to your hats because we're really going to get into the functional mind-set
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Put all the core concepts together into a cohesive paradigm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore the beauty that functional programming has to offer when we fully commit
    to the style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step through the logical progression of functional patterns as they build upon
    each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the while, we will build up a simple application that does some pretty cool
    stuff
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may have noticed a few concepts that were brought up in the last chapter
    when dealing with functional libraries for JavaScript, but not in [Chapter 2](part0019_split_000.html#page
    "Chapter 2. Fundamentals of Functional Programming"), *Fundamentals of Functional
    Programming*. Well, that was for a reason! Compositions, currying, partial application,
    and more. Let's explore why and how these libraries implemented those concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functional programming can come in a variety of flavors and patterns. This
    chapter will cover many different styles of functional programming:'
  prefs: []
  type: TYPE_NORMAL
- en: Data generic programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mostly functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional reactive programming and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter, however, will be as style-unbiased as possible. Without leaning
    too hard on one style of functional programming over another, the overall goal
    is to show that there are better ways to write code than what is often accepted
    as the correct and only way. Once you free your mind about the preconceptions
    of what is the right way and what is not the right way to write code, you can
    do whatever you want. When you just write code with childlike abandon for no reason
    other than the fact that you like it and when you're not concerned about conforming
    to the traditional way of doing things, then the possibilities are endless.
  prefs: []
  type: TYPE_NORMAL
- en: Partial function application and currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many languages support optional arguments, but not in JavaScript. JavaScript
    uses a different pattern entirely that allows for any number of arguments to be
    passed to a function. This leaves the door open for some very interesting and
    unusual design patterns. Functions can be applied in part or in whole.
  prefs: []
  type: TYPE_NORMAL
- en: Partial application in JavaScript is the process of binding values to one or
    more arguments of a function that returns another function that accepts the remaining,
    unbound arguments. Similarly, currying is the process of transforming a function
    with many arguments into a function with one argument that returns another function
    that takes more arguments as needed.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the two may not be clear now, but it will be obvious
    in the end.
  prefs: []
  type: TYPE_NORMAL
- en: Function manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Actually, before we go any further and explain just how to implement partial
    application and currying, we need a review. If we're going to tear JavaScript's
    thick veneer of C-like syntax right off and expose it's functional underbelly,
    then we're going to need to understand how primitives, functions, and prototypes
    in JavaScript work; we would never need to consider these if we just wanted to
    set some cookies or validate some form fields.
  prefs: []
  type: TYPE_NORMAL
- en: Apply, call, and the this keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In pure functional languages, functions are not invoked; they're applied. JavaScript
    works the same way and even provides utilities for manually calling and applying
    functions. And it's all about the `this` keyword, which, of course, is the object
    that the function is a member of.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `call()` function lets you define the `this` keyword as the first argument.
    It works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `call()` function can be used, for example, to invoke anonymous functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `apply()` function is very similar to the `call()` function, but a little
    more useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The fundamental difference is that, while the `call()` function accepts a list
    of arguments, the `apply()` function accepts an array of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The `call()` and `apply()` functions allow you to write a function once and
    then inherit it in other objects without writing the function over again. And
    they are both members themselves of the `Function` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is bonus material, but when you use the `call()` function on itself, some
    really cool things can happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Binding arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `bind()` function allows you to apply a method to one object with the `this`
    keyword assigned to another. Internally, it's the same as the `call()` function,
    but it's chained to the method and returns a new bounded function.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s especially useful for callbacks, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This solves a lot of problems in object-oriented frameworks, such as Dojo, specifically
    the problems of maintaining the state when using classes that define their own
    handler functions. But we can use the `bind()` function for functional programming
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `bind()` function actually does partial application on its own, though in
    a very limited way.
  prefs: []
  type: TYPE_NORMAL
- en: Function factories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember our section on closures in [Chapter 2](part0019_split_000.html#page
    "Chapter 2. Fundamentals of Functional Programming"), *Fundamentals of Functional
    Programming*? Closures are the constructs that makes it possible to create a useful
    JavaScript programming pattern known as function factories. They allow us to *manually
    bind* arguments to functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll need a function that binds an argument to another function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can use this to create more generic functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And it can work on the other argument too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The ability to create generic functions is very important in functional programming.
    But there''s a clever trick to making this process even more generalized. The
    `bindFirstArg()` function itself takes two arguments, the first being a function.
    If we pass the `bindFirstArg` function as a function to itself, we can create
    *bindable* functions. This can be best described with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is why they're called function factories.
  prefs: []
  type: TYPE_NORMAL
- en: Partial application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notice that our function factory example's `bindFirstArg()` and `bindSecondArg()`
    functions only work for functions that have exactly two arguments. We could write
    new ones that work for different numbers of arguments, but that would work away
    from our model of generalization.
  prefs: []
  type: TYPE_NORMAL
- en: What we need is partial application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Partial application is the process of binding values to one or more arguments
    of a function that returns a partially-applied function that accepts the remaining,
    unbound arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the `bind()` function and other built-in methods of the `Function` object,
    we'll have to create our own functions for partial application and currying. There
    are two distinct ways to do this.
  prefs: []
  type: TYPE_NORMAL
- en: As a stand-alone function, that is, `var partial = function(func){...`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a *polyfill*, that is, `Function.prototype.partial = function(){...`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Polyfills are used to augment prototypes with new functions and will allow
    us to call our new functions as methods of the function that we want to partially
    apply. Just like this: `myfunction.partial(arg1, arg2, …);`'
  prefs: []
  type: TYPE_NORMAL
- en: Partial application from the left
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s where JavaScript''s `apply()` and `call()` utilities become useful
    for us. Let''s look at a possible polyfill for the Function object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it works by slicing the `arguments` special variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every function has a special local variable called `arguments` that is an array-like
    object of the arguments passed to it. It's technically not an array. Therefore
    it does not have any of the Array methods such as `slice` and `forEach`. That's
    why we need to use Array's `slice.call` method to slice the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: And now let's see what happens when we use it in an example. This time, let's
    get away from the math and go for something a little more useful. We'll create
    a little application that converts numbers to hexadecimal values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This example shows that we can partially apply arguments to a generic function
    and get a new function in return. *This first example is left-to-right*, which
    means that we can only partially apply the first, left-most arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Partial application from the right
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to apply arguments from the right, we can define another polyfill.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Partial application has allowed us to take a very generic function and extract
    more specific functions out of it. But the biggest flaw in this method is that
    the way in which the arguments are passed, as in how many and in what order, can
    be ambiguous. And ambiguity is never a good thing in programming. There''s a better
    way to do this: currying.'
  prefs: []
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currying is the process of transforming a function with many arguments into
    a function with one argument that returns another function that takes more arguments
    as needed. Formally, a function with N arguments can be transformed into a function
    *chain* of N functions, each with only one argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common question is: what is the difference between partial application and
    currying? While it''s true that partial application returns a value right away
    and currying only returns another curried function that takes the next argument,
    the fundamental difference is that currying allows for much better control of
    how arguments are passed to the function. We''ll see just how that''s true, but
    first we need to create function to perform the currying.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our polyfill for adding currying to the Function prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `numArgs` argument lets us optionally specify the number of arguments the
    function being curried needs if it's not explicitly defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to use it within our hexadecimal application. We''ll write
    a function that converts RGB values to a hexadecimal string that is appropriate
    for HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It will return the curried function until all needed arguments are passed in.
    And they're passed in the same left-to-right order as defined by the function
    being curried.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can step it up a notch and define the more specific functions that we
    need as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So that's a nice way to use currying. But if we just want to curry our `nums2hex()`
    function directly, we run into a little bit of trouble. And that's because the
    function doesn't define any arguments, it just lets you pass as many arguments
    in as you want. So we have to define the number of arguments. We do that with
    the optional parameter to the curry function that allows us to set the number
    of arguments of the function being curried.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Therefore currying does not work well with functions that accept variable numbers
    of arguments. For something like that, partial application is preferred.
  prefs: []
  type: TYPE_NORMAL
- en: All of this isn't just for the benefit of function factories and code reuse.
    Currying and partial application play into a bigger pattern known as composition.
  prefs: []
  type: TYPE_NORMAL
- en: Function composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we have arrived at function composition.
  prefs: []
  type: TYPE_NORMAL
- en: In functional programming, we want everything to be a function. We especially
    want unary functions if possible. If we can convert all functions to unary functions,
    then magical things can happen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Unary** functions are functions that take only a single input. Functions
    with multiple inputs are **polyadic**, but we usually say *binary* for functions
    that accept two inputs and **ternary** for three inputs. Some functions don''t
    accept a specific number of inputs; we call those **variadic**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Manipulating functions and their acceptable number of inputs can be extremely
    expressive. In this section, we will explore how to compose new functions from
    smaller functions: little units of logic that combine into whole programs that
    are greater than the sum of the functions on their own.'
  prefs: []
  type: TYPE_NORMAL
- en: Compose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Composing functions allows us to build complex functions from many simple, generic
    functions. By treating functions as building blocks for other functions, we can
    build truly modular applications with excellent readability and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we define the `compose()` polyfill, you can see how it all works with
    these following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In math, the composition of the `f` and `g` variables is defined as `f(g(x))`.
    In JavaScript, this can be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: But if we left it at that, we would lose track of the `this` keyword, among
    other problems. The solution is to use the `apply()` and `call()` utilities. Compared
    to curry, the `compose()` polyfill is quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To show how it''s used, let''s build a completely contrived example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Did you notice that the `function3` parameter was applied first? This is very
    important. Functions are applied from right to left.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence – compose in reverse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because many people like to read things from the left to the right, it might
    make sense to apply the functions in that order too. We'll call this a sequence
    instead of a composition.
  prefs: []
  type: TYPE_NORMAL
- en: To reverse the order, all we need to do is swap the `nextFunc` and `prevFunc`
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to now call the functions in a more natural order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Compositions versus chains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are five different implementations of the same `floorSqrt()` functional
    composition. They seem to be identical, but they deserve scrutiny.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'But there are a few key differences we should go over:'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously the first method is verbose and inefficient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second method is a nice one-liner, but this approach becomes very unreadable
    after only a few functions are applied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To say that less code is better is missing the point. Code is more maintainable
    when the effective instructions are more concise. If you reduce the number of
    characters on the screen without changing the effective instructions carried out,
    this has the complete opposite effect—code becomes harder to understand, and decidedly
    less maintainable; for example, when we use nested ternary operators, or we chain
    several commands together on a single line. These approaches reduce the amount
    of 'code on the screen', but they don't reduce the number of steps actually being
    specified by that code. So the effect is to obfuscate and make the code harder
    to understand. The kind of conciseness that makes code easier to maintain is that
    which effectively reduces the specified instructions (for example, by using a
    simpler algorithm that accomplishes the same result with fewer and/or simpler
    steps), or when we simply replace code with a message, for instance, invoking
    a third-party library with a well-documented API.
  prefs: []
  type: TYPE_NORMAL
- en: The third approach is a chain of array functions, notably the `map` function.
    This works fairly well, but it is not mathematically correct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here's our `compose()` function in action. All methods are forced to be unary,
    pure functions that encourage the use of better, simpler, and smaller functions
    that do one thing and do it well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last approach uses the `compose()` function in reverse sequence, which is
    just as valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming with compose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most important aspect of compose is that, aside from the first function
    that is applied, it works best with pure, *unary* functions: functions that take
    only one argument.'
  prefs: []
  type: TYPE_NORMAL
- en: The output of the first function that is applied is sent to the next function.
    This means that the function must accept what the previous function passed to
    it. This is the main influence behind *type signatures*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Type Signatures are used to explicitly declare what types of input the function
    accepts and what type it outputs. They were first used by Haskell, which actually
    used them in the function definitions to be used by the compiler. But, in JavaScript,
    we just put them in a code comment. They look something like this: `foo :: arg1
    -> argN -> output`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In order to truly reap the benefits of compose, any application will need a
    hefty collection of unary, pure functions. These are the building blocks that
    are composed into larger functions that, in turn, are used to make applications
    that are very modular, reliable, and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through an example. First we''ll need many building-block functions.
    Some of them build upon the others as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now let's compose some of them together.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can even use `compose()` and `curry()` functions together. In fact, they
    work very well together. Let's forge together the curry example with our compose
    example. First we'll need our helper functions from before.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: First we need to make the curried and partial-applied functions, then we can
    compose them to our other composed functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There we have it! The functions read really well and make a lot of sense. We
    were forced to begin with little functions that just did one thing. Then we were
    able to put together functions with more utility.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at one last example. Here's a function that lightens an RBG value
    by a variable amount. Then we can use composition to create new functions from
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the same way, we could easily create more functions for creating lighter
    and darker blues, greens, grays, purples, anything you want. *This is a really
    great way to construct an API*.
  prefs: []
  type: TYPE_NORMAL
- en: We just barely scratched the surface of what function composition can do. What
    compose does is take control away from JavaScript. Normally JavaScript will evaluate
    left to right, but now the interpreter is saying "OK, something else is going
    to take care of this, I'll just move on to the next." And now the `compose()`
    function has control over the evaluation sequence!
  prefs: []
  type: TYPE_NORMAL
- en: This is how `Lazy.js`, `Bacon.js` and others have been able to implement things
    such as lazy evaluation and infinite sequences. Up next, we'll look into how those
    libraries are used.
  prefs: []
  type: TYPE_NORMAL
- en: Mostly functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a program without side effects? A program that does nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complementing our code with functional code with unavoidable side-effects can
    be called "mostly functional programming." Using multiple paradigms in the same
    codebase and applying them where they are most optimal is the best approach. Mostly
    functional programming is how even the pure, traditional functional programs are
    modelled: keep most of the logic in pure functions and interface with imperative
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: And this is how we're going to write a little application of our own.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we have a boss that tells us that we need a web application
    for our company that tracks the status of the employees'' availability. All the
    employees at this fictional company only have one job: using our website. Staff
    will sign in when they get to work and sign out when they leave. But that''s not
    enough, it also needs to automatically update the content as it changes, so our
    boss doesn''t have to keep refreshing the pages.'
  prefs: []
  type: TYPE_NORMAL
- en: '*We''re going to use* `Lazy.js` *as our functional library*. And we''re also
    going to be lazy: instead of worrying about handling all the users logging in
    and out, WebSockets, databases, and more, we''ll just pretend there''s a generic
    application object that does this for us and just happens to have the perfect
    API.'
  prefs: []
  type: TYPE_NORMAL
- en: So for now, let's just get the ugly parts out of the way, the parts that interface
    and create side-effects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This would be sufficient for just displaying a list of availabilities, but we
    want it to be reactive, which brings us to our first obstacle.
  prefs: []
  type: TYPE_NORMAL
- en: By using the `Lazy.js` library to store the objects in a sequence, which won't
    actually compute anything until the `toArray()` method is called, we can take
    advantage of its laziness to provide a sort of functional reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Because the `Receptor.render()` method returns new HTML instead of modifying
    the current HTML, all we have to do is set the `innerHTML` parameter to its output.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also have to trust that our generic application for user management will
    provide callback methods for us to use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This way, any time a user logs in or out, the `lazyReceptors` parameter will
    be computed again and the availability list will be printed with the most recent
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Handling events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: But what if the application doesn't provide callbacks for when the user logs
    in and out? Callbacks are messy and can quickly turn a program into spaghetti
    code. Instead, we can determine it ourselves by observing the user directly. If
    the user has the webpage in focus, then he/she must be active and available. We
    can use JavaScript's `focus` and `blur` events for this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Wait a second, aren't events reactive too? Can they be lazily computed as well?
    They can in the `Lazy.js` library, where there's even a handy method for this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Easy as pie.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By using the `Lazy.js` library to handle events, we can create an infinite sequence
    of events. Each time the event is fired, the `Lazy.each()` function is able to
    iterate one more time.
  prefs: []
  type: TYPE_NORMAL
- en: Our boss likes the application so far, but she points out that if an employee
    never logs out before leaving for the day without closing the page, then the application
    says the employee is still available.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out if an employee is active on the website, we can monitor the keyboard
    and mouse events. Let's say they're considered to be unavailable after 30 minutes
    of no activity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `Lazy.js` library has made it very easy for us to handle events as an infinite
    stream that we can map over. It makes this possible because it uses function composition
    to take control of the order of execution.
  prefs: []
  type: TYPE_NORMAL
- en: But there's a little problem with all of this. What if there are no user input
    events that we can latch onto? What if, instead, there is a property value that
    changes all the time? In the next section, we'll investigate exactly this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Functional reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's build another kind of application that works in much the same way; one
    that uses functional programming to react to changes in state. But, this time,
    the application won't be able to rely on event listeners.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine for a moment that you work for a news media company and your boss tells
    you to create a web application that tracks government election results on Election
    Day. Data is continuously flowing in as local precincts turn in their results,
    so the results to display on the page are very reactive. But we also need to track
    the results by each region, so there will be multiple objects to track.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than creating a big object-oriented hierarchy to model the interface,
    we can describe it declaratively as immutable data. We can transform it with chains
    of pure and semi-pure functions whose only ultimate side effects are updating
    whatever bits of state absolutely must be held onto (ideally, not many).
  prefs: []
  type: TYPE_NORMAL
- en: And we'll use the `Bacon.js` library, which will allow us to quickly develop
    **Functional Reactive Programming** (**FRP**) applications. The application will
    only be used one day out of the year (Election Day), and our boss thinks it should
    take a proportional amount of time. With functional programming and a library
    such as `Bacon.js`, we'll get it done in half the time.
  prefs: []
  type: TYPE_NORMAL
- en: But first, we're going to need some objects to represent the voting regions,
    such as states, provinces, districts, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: While the above would be sufficient for just displaying a static list of election
    results, we need a way to update the regions dynamically. It's time to cook up
    some Bacon and FRP.
  prefs: []
  type: TYPE_NORMAL
- en: Reactivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bacon has a function, `Bacon.fromPoll()`, that lets us create an event stream,
    where the event is just a function that is called on the given interval. And the
    `stream.subscribe()` function lets us *subscribe* a handler function to the stream.
    Because it's lazy, the stream will not actually do anything without a subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: By essentially putting it in a loop that runs every 10 seconds, we could get
    the job done. But this method would hammer-ping the network and is incredibly
    inefficient. That would not be very functional. Instead, let's dig a little deeper
    into the `Bacon.js` library.
  prefs: []
  type: TYPE_NORMAL
- en: In Bacon, there are EventStreams and Properties parameters. Properties can be
    thought of as "magic" variables that change over time in response to events. They're
    not really magic because they still rely on a stream of events. The Property changes
    over time in relation to its EventStream.
  prefs: []
  type: TYPE_NORMAL
- en: The `Bacon.js` library has another trick up its sleeve. The `Bacon.fromPromise()`
    function is a way to emit events into a stream by using *promises*. And as of
    jQuery version 1.5.0, jQuery AJAX implements the promises interface. So all we
    need to do is write an AJAX search function that emits events when the asynchronous
    call is complete. Every time the promise is resolved, it calls the EvenStream's
    subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: A promise can be thought of as an *eventual value*; with the `Bacon.js` library,
    we can lazily wait on the eventual values.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the reactivity covered, we can finally play with some code.
  prefs: []
  type: TYPE_NORMAL
- en: We can modify the subscriber with chains of pure functions to do things such
    as adding up a total and filtering out unwanted results, and we do it all within
    `onclick()` handler functions for buttons that we create.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The beauty of this is that, when users click between the buttons, the event
    stream doesn't change but the subscriber does, which makes it all work smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is a beautiful language.
  prefs: []
  type: TYPE_NORMAL
- en: Its inner beauty really shines with functional programming. It's what empowers
    its excellent extendibility. Just the fact that it allows first-class functions
    that can do so many things is what opens the functional flood gates. Concepts
    build on top of each other, stacking up higher and higher.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we dove head-first into the functional paradigm in JavaScript.
    We covered function factories, currying, function composition and everything required
    to make it work. We built an extremely modular application that used these concepts.
    And then we showed how to use some functional libraries that use these same concepts
    themselves, namely function composition, to manipulate the order of execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout the chapter, we covered several styles of functional programming:
    data generic programming, mostly-functional programming, and functional reactive
    programming. They''re all not that different from each other, they''re just different
    patterns for applying functional programing in different situations.'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, something called Category Theory was briefly mentioned.
    In the next chapter, we're going to learn a lot more about what it is and how
    to use it.
  prefs: []
  type: TYPE_NORMAL
