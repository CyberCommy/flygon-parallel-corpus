- en: Behavior-Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief overview of behavior-driven development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD versus BDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ BDD frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Gherkin language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing `cucumber-cpp` in Ubuntu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spoken languages supported by Gherkin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recommended `cucumber-cpp` project folder structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing our first Cucumber test case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dry running our Cucumber test cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BDD--a test-first development approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, let's look into each topic with easy-to-digest and
    interesting code samples in a practical fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior-driven development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Behavior-driven development** (**BDD**) is an outside-in development technique.
    BDD encourages capturing the requirements as a set of scenarios or use cases that
    describe how the end user will use the feature. The scenario will precisely express
    what will be the input supplied and what is the expected response from the feature.
    The best part of BDD is that it uses a **domain-specific language** (**DSL**)
    called **Gherkin** to describe the BDD scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: Gherkin is an English-like language that is used by all the BDD test frameworks.
    Gherkin is a business-readable DSL that helps you describe the test case scenarios,
    keeping out the implementation details. The Gherkin language keywords are a bunch
    of English words; hence the scenarios can be understood by both technical and
    non-technical members involved in a software product or a project team.
  prefs: []
  type: TYPE_NORMAL
- en: Did I tell you that the BDD scenarios written in Gherkin languages serve as
    both documentation and test cases? As the Gherkin language is easy to understand
    and uses English-like keywords, the product requirements can be directly captured
    as BDD scenarios, as opposed to boring Word or PDF documents. Based on my consulting
    and industry experience, I have observed that a majority of the companies never
    update the requirement documents when the design gets refactored in the due course
    of time. This leads to stale and non-updated documents, which the development
    team will not trust for their reference purposes. Hence, the effort that has gone
    towards preparing the requirements, high-level design documents, and low-level
    design documents goes to waste in the long run, whereas Cucumber test cases will
    stay updated and relevant at all times.
  prefs: []
  type: TYPE_NORMAL
- en: TDD versus BDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TDD is an inside-out development technique whereas BDD is an outside-in development
    technique. TDD mainly focuses on unit testing and integration test case automation.
  prefs: []
  type: TYPE_NORMAL
- en: BDD focuses on end-to-end functional test cases and user acceptance test cases.
    However, BDD could also be used for unit testing, smoke testing, and, literally,
    every type of testing.
  prefs: []
  type: TYPE_NORMAL
- en: BDD is an extension of the TDD approach; hence, BDD also strongly encourages
    test-first development. It is quite natural to use both BDD and TDD in the same
    product; hence, BDD isn't a replacement for TDD. BDD can be thought of as a high-level
    design document, while TDD is the low-level design document.
  prefs: []
  type: TYPE_NORMAL
- en: C++ BDD frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++, TDD test cases are written using testing frameworks such as CppUnit,
    gtest, and so on, which require a technical background to understand them and
    hence, are generally used only by developers.
  prefs: []
  type: TYPE_NORMAL
- en: In C++, BDD test cases are written using a popular test framework called cucumber-cpp.
    The cucumber-cpp framework expects that the test cases are written in the Gherkin
    language, while the actual test case implementations can be done with any test
    framework, such as gtest or CppUnit.
  prefs: []
  type: TYPE_NORMAL
- en: However, in this book, we will be using cucumber-cpp with the gtest framework.
  prefs: []
  type: TYPE_NORMAL
- en: The Gherkin language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gherkin is the universal language used by every BDD framework for various programming
    languages that enjoy BDD support.
  prefs: []
  type: TYPE_NORMAL
- en: Gherkin is a line-oriented language, similar to YAML or Python. Gherkin will
    interpret the structure of the test case based on indentations.
  prefs: []
  type: TYPE_NORMAL
- en: The `#` character is used for a single line of comment in Gherkin. At the time
    of writing this book, Gherkin support about 60 keywords.
  prefs: []
  type: TYPE_NORMAL
- en: Gherkin is a DSL used by the Cucumber framework.
  prefs: []
  type: TYPE_NORMAL
- en: Installing cucumber-cpp in Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing the cucumber-cpp framework is quite straightforward in Linux. All
    you need to do is either download or clone the latest copy of cucumber-cpp.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command can be used to clone the cucumber-cpp framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The cucumber-cpp framework is supported in Linux, Windows, and Macintosh. It
    can be integrated with Visual Studio on Windows or Xcode on macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot demonstrates the Git clone procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44792cbe-0fbe-454a-822b-81a7268eabfa.png)'
  prefs: []
  type: TYPE_IMG
- en: As cucumber-cpp depends on a wire protocol to allow the writing of BDD test
    case step definitions in the C++ language, we need to install Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the cucumber-cpp framework prerequisite software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following command helps you install Ruby on your Ubuntu system. This is
    one of the prerequisite software that is required for the cucumber-cpp framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot demonstrates the Ruby installation procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccdbd258-280e-42e7-b495-160a375b101d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the installation is complete, please ensure that Ruby is installed properly
    by checking its version. The following command should print the version of Ruby
    installed on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to complete the Ruby installation, we need to install the `ruby-dev`
    packages, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to ensure that the bundler tool is installed so that the Ruby
    dependencies are installed by the bundler tool seamlessly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If it all went smooth, you can go ahead and check if the correct version of
    Cucumber, Ruby, and Ruby''s tools are installed properly. The `bundle install`
    command will ensure that Cucumber and other Ruby dependencies are installed. Make
    sure you don''t install `bundle install` as a sudo user; this will prevent non-root
    from accessing the Ruby gem packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86f1faea-f971-483b-93ff-01328d10c942.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are almost done, but we are not there yet. We need to build the cucumber-cpp
    project; as part of that, let''s get the latest test suite for the cucumber-cpp
    framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We go on to install the ninja and boost libraries before we can initiate the
    build. Though we aren''t going to use the boost test framework in this chapter,
    the `travis.sh` script file looks for the boost library. Hence, I would suggest
    installing the boost library in general, as part of Cucumber:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Building and executing the test cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it''s time to build the cucumber-cpp framework. Let''s create the `build`
    folder. In the `cucumber-cpp` folder, there will be a shell script by the name, `travis.sh`.
    You got to execute the script to build and execute the test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Though the previous approach works, my personal preference and recommendation
    would be the following approach. The reason behind recommending the following
    approach is that the `build` folder is supposed to be created as a non-root user,
    as anyone should be able to perform the build once the `cucumber-cpp` setup is
    complete. You should be able to find the instructions in the `README.md` file
    under the `cucumber-cpp` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you were able to complete all the previous installation steps exactly as
    explained, you are all set to start playing with `cucumber-cpp`. Congrats!!!
  prefs: []
  type: TYPE_NORMAL
- en: Feature file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every product feature will have a dedicated feature file. The feature file is
    a text file with the `.feature` extension. A feature file can contain any number
    of scenarios, and each scenario is equivalent to a test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple feature file example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Cool, it appears like plain English, right? But trust me, this is how Cucumber
    test cases are written! I understand your doubt--it looks easy and cool but how
    does this verify the functionality, and where is the code that verifies the functionality?
     The `cucumber-cpp` framework is a cool framework, but it doesn't natively support
    any testing functionalities; hence `cucumber-cpp` depends on the gtest, `CppUnit`,
    other test frameworks. The test case implementation is written in a `Steps` file,
    which can be written in C++ using the gtest framework in our case. However, any
    test framework will work.
  prefs: []
  type: TYPE_NORMAL
- en: Every feature file will start with the `Feature` keyword followed by one or
    more lines of description that describe the feature briefly. In the feature file,
    the words `Feature`, `Scenario`, `Given`, `And`, `When`, and `Then` are all Gherkin
    keywords.
  prefs: []
  type: TYPE_NORMAL
- en: 'A feature file may contain any number of scenarios (test cases) for a feature.
    For instance, in our case, login is the feature, and there could be multiple login
    scenarios as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Success Login`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unsuccessful Login`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Invalid password`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Invalid username`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`The user attempted to login without supplying credentials. `'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every line following the scenario will translate into one function in the `Steps_definition.cpp`
    source file. Basically, the `cucumber-cpp` framework maps the feature file steps
    with a corresponding function in the `Steps_definition.cpp` file using regular
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Spoken languages supported by Gherkin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Gherkin supports over 60 spoken languages. As a best practice, the first line
    of a feature file will indicate to the Cucumber framework that we would like to
    use English:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will list all the spoken languages supported by the `cucumber-cpp` framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The list is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab2575a0-7bf2-4fd8-81d9-4a03555c703c.png)'
  prefs: []
  type: TYPE_IMG
- en: The recommended cucumber-cpp project folder structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like TDD, the Cucumber framework too recommends a project folder structure.
    The recommended `cucumber-cpp` project folder structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1c21629-0171-4bca-8cc3-63963eb2caf5.png)'
  prefs: []
  type: TYPE_IMG
- en: The `src` folder will contain the production code, that is, all your project
    files will be maintained under the `src` directory. The BDD feature files will
    be maintained under the `features` folder and its respective `Steps` file, which
    has either boost test cases or gtest cases. In this chapter, we will be using
    the gtest framework with `cucumber-cpp`. The `wire` file has wire protocol-related
    connection details such as the port and others. The `CMakeLists.txt` is the build
    script that has the instructions to build your project along with its dependency
    details, just like `Makefile` used by the `MakeBuild` utility.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our first Cucumber test case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's write our very first Cucumber test case! As this is our first exercise,
    I would like to keep it short and simple. First, let's create the folder structure
    for our `HelloBDD` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the Cucumber project folder structure, we can use the `cucumber`
    utility, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will ensure that the `features` and `steps_definitions` folders are created
    as per Cucumber best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a13d682-cc0b-4693-9625-3930377a6d0d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the basic folder structure is created, let''s manually create the rest
    of the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the folder structure and empty files are created, the project folder structure
    should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16fd5026-ee0d-4f10-bd13-b3ecb098f211.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s time to start applying our Gherkin knowledge in action; hence, let''s
    first start with the feature file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the `cucumber.wire` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As Cucumber is implemented in Ruby, the Cucumber steps implementation has to
    be written in Ruby. This approach discourages using the cucumber-cpp framework
    for projects that are implemented in platforms other than Ruby. The wire protocol
    is the solution offered by the cucumber-cpp framework to extend cucumber support
    for non-Ruby platforms. Basically, whenever the cucumber-cpp framework executes
    the test cases, it looks for steps definitions, but if Cucumber finds a `.wire`
    file, it will instead connect to that IP address and port, in order to query the
    server if the process has definitions for the steps described in the `.feature`
    file. This helps Cucumber support many platforms apart from Ruby. However, Java
    and .NET have native Cucumber implementations: Cucumber-JVM and Specflow, respectively.
    Hence, in order to allow the test cases to be written in C++, the wire protocol
    is used by cucumber-cpp.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see how to write the steps file using the gtest Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to Google! The Google Test Framework (gtest) includes **Google Mock Framework**
    (**gmock**). For C/C++, the gtest framework is one of the best frameworks I have
    come across, as this is pretty close to the JUnit and Mockito/PowerMock offerings
    for Java. For a relatively modern language like Java compared to C++, it should
    be much easier to support mocking with the help of reflection, but from a C/C++
    point of view, without the reflection feature from C++, gtest/gmock is nothing
    short of JUnit/TestNG/Mockito/PowerMock.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can observe the written steps files using gtest in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a31fcf5-f280-48e0-89fe-75149f3d6da9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following header files ensure that the gtest header and Cucumber headers
    necessary for writing Cucumber steps are included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s proceed with writing the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `HelloCtx` struct is a user-defined test context that holds the object instance
    under test and its test response. The cucumber-cpp framework offers a smart `ScenarioScope`
    class that allows us to access the object under test and its output, across all
    the steps in a Cucumber test scenario.
  prefs: []
  type: TYPE_NORMAL
- en: For every `Given`, `When`, and `Then` statement that we wrote in the feature
    file, there is a corresponding function in the steps file. The appropriate cpp
    functions that correspond to `Given`, `When`, and `Then` are mapped with the help
    of regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider the following `Given` line in the feature file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This corresponds to the following cpp function that gets mapped with the help
    of regex. The `^` character in the regex implies that the pattern starts with
    `an`, and the `$` character implies that the pattern ends with `created`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As the `GIVEN` step says that, at this point, we must ensure that an instance
    of the `Hello` object is created; the corresponding C++ code is written in this
    function to instantiate an object of the `Hello` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a similar note, the following `When` step and its corresponding cpp functions
    are mapped by cucumber-cpp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important that the regex matches exactly; otherwise, the cucumber-cpp
    framework will report that it can''t find the steps function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s look at the `Hello.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the respective source file, that is, `Hello.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As an industry best practice, the only header file that should be included in
    the source file is its corresponding header file. The rest of the headers required
    should go into the header files corresponding to the source file. This helps the
    development team to locate the headers quite easily. BDD is not just about test
    automation; the expected end result is clean, defectless, and maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s write `CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef2b70b1-69fc-48fb-963f-c82048fd4033.png)'
  prefs: []
  type: TYPE_IMG
- en: The first line implies the name of the project. The third line ensures that
    the Cucumber header directories and our project's `include_directories` are in
    the `INCLUDE` path. The fifth line basically instructs the `cmake` utility to
    create a library out of the files present under the `src` folder, that is, `Hello.cpp`,
    and its `Hello.h` file. The seventh line detects whether the gtest framework is
    installed on our system, and the eighth line ensures that the `HelloBDDSteps.cpp`
    file is compiled. Finally, in the ninth line, the final executable is created,
    linking all the `HelloBDD` libraries that have our production code, the `HelloBDDSteps`
    object file, and the respective Cucumber and gtest library files.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating our project in cucumber-cpp CMakeLists.txt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one last configuration that we need to do before we start building
    our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11cb338b-8dd9-454c-8fe8-8fcf8f4656b3.png)'
  prefs: []
  type: TYPE_IMG
- en: Basically, I have commented the `examples` subdirectories and added our `HelloBDD`
    project in `CMakeLists.txt` present under the `cucumber-cpp` folder, as shown
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have created the project as per cucumber-cpp best practices, let''s navigate
    to the `HelloBDD` project home and issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It isn't mandatory to comment `add_subdirectory(examples)`. But commenting definitely
    helps us focus on our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the build procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2fd5c28-0741-42e5-a36e-7be6224392d3.png)'
  prefs: []
  type: TYPE_IMG
- en: Executing our test case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s execute the test case. This involves two steps, as we are using
    the wire protocol. Let''s first launch the test case executable in background
    mode and then Cucumber, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Redirecting to `/dev/null` isn''t really mandatory. The main purpose of redirecting
    to a null device is to avoid distractions from the print statement that an application
    may spit in the terminal output. Hence, it is a personal preference. In case you
    prefer to see the debug or general print statements from your application, feel
    free to issue the command without redirection:'
  prefs: []
  type: TYPE_NORMAL
- en: '`build/HelloBDD/HelloBDDSteps &`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot demonstrates the build and test execution procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b5747c9-e37d-4824-b435-e371f541c7f8.png)'
  prefs: []
  type: TYPE_IMG
- en: Congrats! our very first cucumber-cpp test case has passed. Each scenario represents
    a test case and the test case includes three steps; as all the steps passed, the
    scenario is reported as passed.
  prefs: []
  type: TYPE_NORMAL
- en: Dry running your cucumber test cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do you want to quickly check whether the feature files and steps files are
    written correctly, without really executing them? Cucumber has a quick and cool
    feature to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This command will execute our test application in the background mode. `/dev/null`
    is a null device in Linux OS, and we are redirecting all the unwanted print statements
    from the `HelloBDDSteps` executable to the null device to ensure it doesn't distract
    us while we execute our Cucumber test cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next command will allow us to dry run the Cucumber test scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the test execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad9a3248-7110-4f7b-9454-bd86cd2adb99.png)'
  prefs: []
  type: TYPE_IMG
- en: BDD - a test-first development approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like TDD, BDD also insists on following a test-first development approach.
    Hence, in this section, let's explore how we could write an end-to-end feature
    following a test-first development approach the BDD way!
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a simple example that helps us understand the BDD style of coding.
    We will write an `RPNCalculator` application that does addition, subtraction,
    multiplication, division, and complex math expressions that involve many math
    operations in the same input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our project folder structure as per Cucumber standards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot demonstrates the procedure visually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52e05cb2-735a-49af-bb39-60fc77c00062.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Great! The folder structure is now created. Now, let''s create empty files
    with a touch utility to help us visualize our final project folder structure along
    with the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the dummy files are created, the final project folder structure will look
    like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01f93061-d737-4f41-ab79-da695906ecd6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As usual, the Cucumber wire file is going to look as follows. In fact, throughout
    this chapter, this file will look same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s start with the `rpncalculator.feature` file, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de514764-6471-451d-a9d1-02e241e79940.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the feature description can be pretty elaborate. Did you notice?
    I have used `Scenario Outline` in the place of scenario. The interesting part
    of `Scenario Outline` is that it allows describing the set of inputs and the corresponding
    output in the form of a table under the `Examples` Cucumber section.
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with SCRUM, does the Cucumber scenario look pretty close
    to the user story? Yes, that's the idea. Ideally, the SCRUM user stories or use
    cases can be written as Cucumber scenarios. The Cucumber feature file is a live
    document that can be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add our project in the `CMakeLists.txt` file at the `cucumber-cpp`
    home directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83131b52-2a35-4802-89ca-ac24f2281d2d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Ensure that `CMakeLists.txt` under the `RPNCalculator` folder looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f124e52a-f425-4ed1-8b42-f6b49911915f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s build our project with the following command from the `cucumber-cpp`
    home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s execute our brand new `RPNCalculator` Cucumber test cases with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1258ac56-5dde-4d97-9bf4-4e690dafd7fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, there are two suggestions for every `Given`, `When`,
    and `Then` statements we wrote in the feature file. The first version is meant
    for Ruby and the second is meant for C++; hence, we can safely ignore the step
    suggestions, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are yet to implement the `RPNCalculatorSteps.cpp` file, the Cucumber
    framework is suggesting us to supply implementations for the previous steps. Let''s
    copy and paste them in the `RPNCalculatorSteps.cpp` file and complete the steps
    implementations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d80aadf-0ee1-46b1-8b38-333ada3142fa.png)`REGEX_PARAM` is a macro supported
    by the cucumber-cpp BDD framework, which comes in handy to extract the input arguments
    from the regular expression and pass them to the Cucumber step functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to build our project again with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The build log looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2d2fbda-5f01-4421-a630-1a62e29427a9.png)'
  prefs: []
  type: TYPE_IMG
- en: The secret formula behind every successful developer or consultant is that they
    have strong debugging and problem-solving skills. Analyzing build reports, especially
    build failures, is a key quality one should acquire to successfully apply BDD.
    Every build error teaches us something!
  prefs: []
  type: TYPE_NORMAL
- en: 'The build error is obvious, as we are yet to implement `RPNCalculator`, as
    the file is empty. Let''s write minimal code such that the code compiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5db9d01e-f57a-4b84-a2a9-38811137b7ea.png)'
  prefs: []
  type: TYPE_IMG
- en: BDD leads to incremental design and development, unlike the waterfall model.
    The waterfall model encourages upfront design. Typically, in a waterfall model,
    the design is done initially, and it consumes 30-40% of the overall project effort.
    The main issue with upfront design is that we will have less knowledge about the
    feature initially; often, we will have a vague feature knowledge, but it will
    improve over time. So, it isn't a good idea to put in more effort in the design
    activity upfront; rather, be open to refactoring the design and code as and when
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, BDD is a natural choice for complex projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this minimal implementation, let''s try to build and run the test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0008282d-1fb7-4272-ab09-69fdfccc54eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Cool! Since the code compiles without errors, let''s execute the test case
    now and observe what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cd59695-53df-4fa4-88e4-0fa739fef82d.png)'
  prefs: []
  type: TYPE_IMG
- en: The errors are highlighted in red color as shown in the preceding screenshot
    by the cucumber-cpp framework. This is expected; the test case is failing as the
    `RPNCalculator::evaluate` method is hardcoded to return `0.0`.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we had to write only minimal code to make this pass, but I took the
    liberty of fast forwarding the steps, with the assumption that you have already
    read Chapter 7, *Test Driven Development* before reading the current chapter.
    In that chapter, I have demonstrated every step in detail, including the refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go ahead and implement the code to make this test case pass.  The
    modified `RPNCalculator` header file looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05b52244-cfb4-4113-8e89-e59f2728ec1e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The respective `RPNCalculator` source file looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d72012f-fe40-41d6-ac8d-5e8f5548cc03.png)'
  prefs: []
  type: TYPE_IMG
- en: As per BDD practice, note that we have only implemented code that is necessary
    for supporting the addition operation alone, as per our current Cucumber scenario
    requirements. Like TDD, in BDD, we are supposed to write only the required amount
    of code to satisfy the current scenario; this way, we can ensure that every line
    of code is covered by effective test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Let's build and run our BDD test case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now build and test. The following commands can be used to build, launch
    the steps in the background, and run the Cucumber test cases with a wire protocol,
    respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot demonstrates the procedure of building and executing
    the Cucumber test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4611a50e-cbd4-4cb1-9500-6707a0e89dab.png)'
  prefs: []
  type: TYPE_IMG
- en: Great! Our test scenario is all green now! Let's move on to our next test scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a scenario in the feature file to test the subtraction operation,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9b67b1b-8e43-4b7d-8ba4-ad597fd846c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The test output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6cf5f4e3-316e-40c4-956c-db644ed5c0bd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We had seen this before, hadn''t we?  I''m sure you guessed it right; the expected
    result is `85` whereas the actual result is `0`, as we haven''t added any support
    for subtraction yet. Now, let''s add the necessary code to add the subtraction
    logic in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7045406-3d9a-45a0-b0ed-0562bf79d1b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With this code change, let''s rerun the test case and see what the test outcome
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35d24547-fd06-47f6-8384-eaee8a0a4cf4.png)'
  prefs: []
  type: TYPE_IMG
- en: Cool, the test report is back to green!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on and add a scenario in the feature file to test the multiplication
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/765099b4-27ac-4b4a-8c55-7be7a57a1fec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It is time to the run the test case, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5903dd18-20bc-45c6-bee0-25cf55d8ba12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You got it right; yes, we need to add support for multiplication in our production
    code. Okay, let''s do it right away, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e072d1ba-6e59-4bb7-9649-760b480051e4.png)'
  prefs: []
  type: TYPE_IMG
- en: It's testing time!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following commands help you build, launch the steps applications, and run
    the Cucumber test cases, respectively. To be precise, the first command builds
    the test cases, while the second command launches the Cucumber steps test executable
    in the background mode. The third command executes the Cucumber test case that
    we wrote for the `RPNCalculator` project.  The `RPNCalculatorSteps` executable
    will work as a server that Cucumber can talk to via the wire protocol. The Cucumber
    framework will get the connection details of the server from the `cucumber.wire`
    file kept under the `step_definitions` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot demonstrates the Cucumber test case execution procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f4d7e88-af2a-48ef-b649-1687b2e017b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I''m sure you''ve got the hang of BDD! Yes, BDD is pretty simple and straightforward.
    Now let''s add a scenario for the division operation as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f77ad014-4354-40bb-8e70-f7fd5110cb37.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s quickly run the test case and observe the test outcome, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3155a50-6a77-4a2c-901f-6f7695d25a1a.png)'
  prefs: []
  type: TYPE_IMG
- en: Yes, I heard you saying you know the reason for the failure. Let's quickly add
    support for division and rerun the test cases to see it turn all green! BDD makes
    coding really fun.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add the following code snippet in `RPNCalculator.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'With this code change, let''s check the test output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot demonstrates the procedure visually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc5f4e23-0029-4026-8926-91863733fcff.png)'
  prefs: []
  type: TYPE_IMG
- en: So far so good. All the scenarios we tested so far have passed, which is a good
    sign. But let's try a complex expression that involves many math operations. For
    instance, let's try *10.0 5.0 * 1.0 + 100.0 2.0 / -*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Did you know?**'
  prefs: []
  type: TYPE_NORMAL
- en: Reverse Polish Notation (postfix notation) is used by pretty much every compiler
    to evaluate mathematical expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot demonstrates the integration of the complex expression
    test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad54e5c0-6b9c-47b3-80c0-211c8f5153e4.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's run the test scenarios one more time, as this would be a real test for
    the entire code implemented so far, as this expression involves all the operations
    our simple application supports.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command can be used to launch the application in the background
    mode and to execute the Cucumber test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot demonstrates the procedure visually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54895e2a-e85b-4bc7-8f95-c82b8baef724.png)'
  prefs: []
  type: TYPE_IMG
- en: Great! If you have come this far, I'm sure you would have understood cucumber-cpp
    and the BDD style of coding.
  prefs: []
  type: TYPE_NORMAL
- en: '**Refactoring and Removing Code Smells**'
  prefs: []
  type: TYPE_NORMAL
- en: The `RPNCalculator.cpp` code has too much branching, which is a code smell;
    hence, the code could be refactored. The good news is that `RPNCalculator.cpp`
    can be refactored to remove the code smells and has the scope to use the Factory
    Method, Strategy, and Null Object Design Patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the following
  prefs: []
  type: TYPE_NORMAL
- en: Behavior-driven development in short is referred as BDD.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BDD is a top-down development approach and uses Gherkin language as Domain Specific
    Language (DSL).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a project, BDD and TDD can be used side by side as they complement each other
    and not replace one another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cucumber-cpp BDD Framework makes use of wire protocol to support non-ruby
    platforms to write test cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You learned BDD in a practical fashion by implementing an RPNCalculator with
    test-first development approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BDD similar to TDD, it encourages developing clean code by refactoring the code
    in short-intervals in an incremental fashion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You learned writing BDD test cases with Gherkin and the steps definition using
    Google test framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you will be learning about C++ debugging techniques.
  prefs: []
  type: TYPE_NORMAL
