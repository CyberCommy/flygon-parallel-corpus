- en: Optimizing Spring Messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned different advanced ways of accessing databases
    using **object-relational mapping** (**ORM**) frameworks such as Hibernate. We
    also learned how to improve database access in an optimal way when using ORM.
    We looked into Spring Data to remove boilerplate code for implementing the **Data
    Access Object** (**DAO**) interface. At the end of the chapter, we saw the Hibernate
    best practices.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about Spring's support for messaging. Messaging
    is a very powerful technique that helps to scale the applications and also encourages
    us to decouple the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Framework provides an extensive support to integrate the messaging system
    into our application with the simplified use of the **Java Message Service** (**JMS**)
    API to receive messages asynchronously. Messaging solutions can be used to send
    messages from one point in an application to a known point, and one point from
    an application to many other unknown points. It is equivalent to sharing something
    face to face and sharing something on a loudspeaker to a group of people, respectively.
    If we want messages to be sent to an unknown set of clients, then we can use a
    queue to broadcast the messages to the people who are listening.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topics that we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is messaging?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is AMQP?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we need AMQP?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RabbitMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring messaging configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is messaging?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Messaging is a mode of interaction between software components or applications,
    where clients can send messages to, and receive messages from, any other client.
  prefs: []
  type: TYPE_NORMAL
- en: 'This message exchange can be done using a component called **broker**. The
    broker provides all the necessary support and services to exchange messages along
    with the capability of interacting with other interfaces. These interfaces are
    known as **Message Oriented Middleware** (**MOM**). The following diagram depicts
    a MOM-based messaging system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68019515-1a5a-4dcd-95fa-0b68d6dfd438.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Messaging systems reduce the complexity of developing distributed applications
    using the AMQP, STOMP, and XMPP protocols. Let''s discuss them in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AMQP**: AMQP is an open, standard layer application protocol for asynchronous
    messaging systems. In AMQP, messages should be transmitted in binary format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**STOMP**: **STOMP** stands for **Simple Text Oriented Messaging Protocol**.
    STOMP provides a compatible medium that allows systems to communicate with almost
    all the available message brokers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XMPP**: **XMPP** stands for **Extensible Messaging and Presence Protocol**.
    It is an XML-based, open standard communications protocol for MOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is AMQP?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Advanced Messaging Queuing Protocol** (**AMQP**) is an open standard application
    layer protocol. Each byte of the transmitted message is specified, which allows
    it to be used in many other languages and OS architectures. Hence, this makes
    it a cross-platform-compatible protocol. AMQP is supported by multiple message
    brokers, such as RabbitMQ, ActiveMQ, Qpid, and Solace. Spring provides AMQP-based
    messaging implementation solutions. Spring provides a template for sending and
    receiving messages through the message broker.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with the JMS API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JMS API is used to send and receive messages in Java platforms. Spring underpins
    a simple method to utilize the JMS API by providing an additional layer around
    the JMS layer. This layer improves the way toward sending and receiving messages
    and also deals with the creation and release of the connection object.
  prefs: []
  type: TYPE_NORMAL
- en: For creating Java-based messaging systems, the JMS API is widely utilized by
    the developers. The principal disadvantage of using the JMS API is the platform
    contradiction, which implies we can use the JMS API to develop messaging systems
    that will work with Java-based applications. The JMS API does not support other
    programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need AMQP?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AMQP is the solution for this JMS API problem. The fundamental advantage of
    using AMQP is that it underpins the exchange of messages, paying little mind to
    the platform's compatibility and message brokers. We can develop messaging systems
    using any programming language and still we can communicate with each system using
    AMQP-based message brokers.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between AMQP and the JMS API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are some of the important differences between AMQP and the JMS API:'
  prefs: []
  type: TYPE_NORMAL
- en: Platform compatibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messaging models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message data type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Workflow strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are explained in more detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Platform compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JMS applications can work with any operating systems, but they only support
    the Java platform. If we want to develop a messaging system to communicate with
    more than one system, then all those systems should be developed using Java programming
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: While using AMQP, we can develop a messaging system that can communicate with
    any system with different technologies. So it is not required for a destination
    system to be developed in the same technology.
  prefs: []
  type: TYPE_NORMAL
- en: Messaging models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JMS API provides two sorts of messaging models, point-to-point, and publish-subscribe,
    for asynchronous messaging between different platform systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'AMQP provides support for the following exchange types: direct, topic, fanout,
    and headers.'
  prefs: []
  type: TYPE_NORMAL
- en: Message data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The JMS API supports five standard messaging types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StreamMessage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MapMessage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextMessage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ObjectMessage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BytesMessage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AMQP supports only one type of message—binary messages; messages must be transmitted
    in binary format only.
  prefs: []
  type: TYPE_NORMAL
- en: Message structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The JMS API message has an essential structure that comprises three parts:
    headers, properties, and body. It characterizes a standard form that ought to
    be portable across all JMS providers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The AMQP message comprises four parts: headers, properties, body, and footers.'
  prefs: []
  type: TYPE_NORMAL
- en: Message routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For message routing, AMQP can likewise be utilized for complex routing schemes,
    which is conceivable through the routing key and depends on the destination matching
    criteria.
  prefs: []
  type: TYPE_NORMAL
- en: The JMS API is based on more complicated routing schemes that are based on hierarchic
    topics and client-message selection filters.
  prefs: []
  type: TYPE_NORMAL
- en: Workflow strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In AMQP, producers first need to send the message to the exchange, and then
    it will be transferred to the queue, whereas in JMS, there is no need to exchange
    since messages can be sent directly to the queue or topic.
  prefs: []
  type: TYPE_NORMAL
- en: What are exchanges, queues, and bindings?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AMQP deals with Publishers and Consumers. The **Publisher** sends the message
    and the **Consumer** receives it. A message broker takes care of this mechanism
    to ensure that messages from Publishers go to the right Consumers. Two key elements
    used by message brokers are exchanges and queues. The following diagram illustrates
    how a Publisher connects to a Consumer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/181f17de-7122-4001-86b0-ee9ba0b1ec8d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's understand the exchange, queue, and binding terminologies.
  prefs: []
  type: TYPE_NORMAL
- en: Exchange
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An exchange is responsible for taking a message and routing it into zero or
    more queues. Each exchange of a broker has a unique name, as well as a few other
    properties within a virtual host. The message-routing algorithm used depends on
    the exchange type and bindings. As we mentioned earlier, there are four different
    types of exchanges: direct, topic, fanout, and headers.'
  prefs: []
  type: TYPE_NORMAL
- en: Queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A queue is a component from which a message consumer receives messages. A queue
    has a unique name so that systems can reference them. The queue name can be defined
    by the application or generated by the broker when requested. We cannot use a
    queue name beginning with `amq.`, since it is reserved by the broker for internal
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The binding is used to connect queues to exchanges. There are certain standard
    headers called **routing key** headers, and they are used by the broker to match
    messages to queues. Each queue has a specific binding key and if that key matches
    the value of the routing key header, the queue receives the message.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing RabbitMQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RabbitMQ is AMQP-based and one of the most widely used lightweight, reliable,
    scalable, portable, and robust message brokers that is written in Erlang. The
    important reason behind the popularity of RabbitMQ is that it is easy to set up
    and fit for the cloud scale. RabbitMQ is open source and supported by most of
    the operating systems and platforms. The applications that use RabbitMQ can communicate
    with other systems via a platform neutral, wire-level protocol—the AMQP. Now,
    let's go through how to configure RabbitMQ.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the RabbitMQ server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before developing a messaging system, we need to set up a message broker that
    will handle sending and receiving the messages. RabbitMQ is the AMQP server, which
    is freely available at [http://www.rabbitmq.com/download.html](http://www.rabbitmq.com/download.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you install the RabbitMQ server, depending on your installation path,
    you will have to set the following system variable with `RABBITMQ_HOME`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After setting up everything, you can access the RabbitMQ console by using `http://localhost:15672/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the default login screen, where you need to enter guest as the
    default Username `guest` and `guest` as the Password:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb1ca8ba-d204-4e14-a689-9a788a0d0cd1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After logging in, you will see the RabbitMQ server home page, where you can
    manage the Queues, Exchanges, and Bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cab357f7-c683-4cbb-9d07-2ac6fb4df032.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we will go through an example to learn about the messaging configuration
    in the Spring application.
  prefs: []
  type: TYPE_NORMAL
- en: Spring messaging configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start with the example, we need to understand the basic setup requirements
    to configure a messaging application. We will create a RabbitMQ messaging application
    and go through the different parts of the configuration. The following steps are
    involved in setting up messaging in Spring application:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure a Maven dependency for RabbitMQ
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure RabbitMQ
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a component to send and receive messages
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring a Maven dependency for RabbitMQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with adding a dependency for RabbitMQ to `pom.xml`. The following
    code shows the dependency to be configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have added the dependency for RabbitMQ. Now, let's create a class to configure
    the queue, exchange, and binding between them.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring RabbitMQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will go through the configuration parts to get a clear understanding
    of the configuration of `ConnectionFactory`, `RabbitTemplate`, `Queue`, `Exchange`,
    `Binding`, message listener container, and message converter.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring ConnectionFactory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the `ConnectionFactory` interface, there is a concrete implementation `CachingConnectionFactory`
    which, by default, creates a single connection proxy that can be shared by the
    whole application. The code used to create `CachingConnectionFactory` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can also configure cached connections using `CachingConnectionFactory` as
    well as just channels. We need to set the `cacheMode` property to `CacheMode.CONNECTION`
    using `setCacheMode()`. We can also limit the total number of connections allowed
    using the `connectionLimit` property through the use of `setConnectionLimit()`. When
    this property is set and the limit is exceeded, the `channelCheckoutTimeLimit`
    is used to wait for a connection to become idle.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will configure a queue using the `Queue` class. The following code
    creates a queue with a specific name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `queue()` method creates an AMQP queue with a specific name declared
    using the `RABBIT_MESSAGE_QUEUE` constant. We can also set the durability using
    the `durable` flag. We need to pass it along with the second constructor argument
    as a Boolean type.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring an exchange
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we need to create an AMQP exchange, to which a message producer will send
    a message. The `Exchange` interface represents an AMQP exchange. There are four
    implementations of the `Exchange` interface type: `DirectExchange`, `TopicExchange`,
    `FanoutExchange`, and `HeadersExchange`. We can use any exchange type based on
    our requirements. We will use `DirectExchange` using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `exchange()` method creates `DirectExchange` with a specific name defined
    under `RABBIT_MESSAGE_EXCHANGE`. We can also set the durability using the durable
    flag. We need to pass it along with the second constructor argument as a Boolean
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we need to create a binding using the `BindingBuilder` class to connect `queue`
    to `Exchange`. The following code is used to create a binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `exchangeBinding()` method creates a binding of `queue` and `Exchange` with
    the `ROUTING_KEY` routing key value.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring RabbitAdmin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`RabbitAdmin` is used to declare the exchanges, queues, and binding that needs
    to be ready on startup. `RabbitAdmin` does the automatic declaration of the queues,
    exchanges, and binding. The main benefit of this auto-declaration is that if the
    connection is disconnected for some reason, they will be applied automatically
    when the connection is re-established. The following code configures `RabbitAdmin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`rabbitAdmin()` will declare the `Queue`, `Exchange`, and `Binding`. The `RabbitAdmin`
    constructor creates an instance using the `connectionFactory()` bean and it must
    not be `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`RabbitAdmin` performs automatic declaration only when the `CachingConnectionFactory`
    cache mode is `CHANNEL` (it is by default). The reason for this limitation is
    because it may be the case that exclusive and autodelete queues may be bound to
    the connection.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a message converter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the precise time a message is received by the listener, two change steps
    happen. In the initial step, the incoming AMQP message is changed over to a Spring
    messaging `Message` using `MessageConverter`. In the second step, when the target
    method is executed, the payload of the message is changed over to the parameter
    type if necessary. By default, in the initial step, `MessageConverter` is utilized
    as Spring AMQP `SimpleMessageConverter` that handles the transformation to String
    and `java.io.Serializable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second step, by default, `GenericMessageConverter` is used for conversion.
    We have used `Jackson2JsonMessageConverter` in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will use this message converter as a property to change the default message
    converter while configuring a `RabbitTemplate` in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a RabbitTemplate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring AMQP’s `RabbitTemplate` provides everything for the basic AMQP operations.
    The following code creates an instance of `RabbitTemplate` using `connectionFactory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`RabbitTemplate` acts as a helper class for the producer to send, and the consumer
    to receive, the messages.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a listener container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To receive the message asynchronously, the easiest way is to use an annotated
    listener endpoint. We will use the `@RabbitListener` annotation as a message `listener`
    endpoint. To create this `listener` endpoint, we have to configure a message `listener`
    container using the `SimpleRabbitListenerContainerFactory` class, which is an
    implementation of the `RabbitListenerContainerFactory` interface. The following
    code is used to configure `SimpleRabbitListenerContainerFactory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `listenerContainer()` method will instantiate `SimpleRabbitListenerContainerFactory`.
    You can set the maximum number of consumers with the `maxConcurrentConsumers`
    property using the `setMaxConcurrentConsumers()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the class that contains all the previously discussed configuration
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Creating a message receiver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will create a `Consumer` listener class with the `@RabbitListener` annotated
    method, which will receive the message from RabbitMQ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is the message `listenerContainer` class. Whenever, producer sends a message
    to the `queue`, this class will receive it and only the method with the `@RabbitListener(containerFactory
    = "listenerContainer", queues = RabbitMqConfiguration.RABBIT_MESSAGE_QUEUE)` annotation
    will receive the message. In this annotation, we mentioned the `containerFactory`
    attribute, which points to the message listener factory defined in the `listenerContainer`
    bean.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a message producer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run this application, we will use the `RabbitTemplate.convertAndSend()` method
    to send the message. This method also converts custom Java objects to AMQP messages
    and is sent to direct exchange. The following `BankAccount` class is created as
    a custom class to populate the message properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following class, we will initialize the preceding class with some proper
    values and send it to the exchange using `RabbitTemplate.convertAndSend()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the preceding code, the producer will send two objects of `BankAccount`
    using the `convertAndSend()` method and the following output will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Maximizing throughput with RabbitMQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the configuration options for optimal performance in relation
    to maximum message passing throughput:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep your queues short
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid the use of lazy queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid persistent messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create multiple queues and consumers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Divide queues into different cores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable acknowledgment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable unnecessary plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance and scalability with RabbitMQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many important points that we should consider for achieving optimal
    performance with RabbitMQ:'
  prefs: []
  type: TYPE_NORMAL
- en: Payload message size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exchange management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure prefetch properly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RabbitMQ HiPE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clustering of nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable RabbitMQ statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the RabbitMQ libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the concept of messaging. We also went through
    the advantages of using messaging systems. We learned about AMQP. We went through
    the needs of AMQP by understanding the JMS API problem. We also saw the differences
    between AMQP and the JMS API. We learned about the exchanges, queues, and binding
    related to AMQP. We also went through the setup aspect of RabbitMQ and different
    configurations related to the Spring application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the cover core concept of Java threads
    and then we will move to the advanced thread support provided by the `java.util.concurrent`
    package. We will also go through the various classes and interfaces of `java.util.concurrent`.
    We will learn how we can use Java thread pool to improve performance. We will
    walk through useful functionality provided by the Spring framework, such as task
    executing, scheduling, and running as asynchronous. Finally, we will look into
    Spring transaction management with threads and various best programming practices
    for threads.
  prefs: []
  type: TYPE_NORMAL
