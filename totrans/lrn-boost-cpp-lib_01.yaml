- en: Chapter 1. Introducing Boost
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Welcome to learning about the richest collection of C++ libraries around, that
    is, Boost. In this introductory chapter, we will take a look at:'
  prefs: []
  type: TYPE_NORMAL
- en: The history and evolution of Boost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Boost?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Boost libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like all the chapters in the book, this is a hands-on chapter that will require
    you to type in commands, write and test your code. Therefore, you should have
    access to a computer with a reasonably modern C++ compiler and an internet connection
    to download free software, including Boost libraries.
  prefs: []
  type: TYPE_NORMAL
- en: How it all started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometime around 1997-98, when the draft of the first C++ Standard was being
    finalized for publication as an ISO/IEC Standard, Robert Klarer from the IBM Labs
    conceived the idea of a programming language that would be called BOOSE (pronounced
    "booz"), and which would compete with Java in the area of high-performance embedded
    software development, which the latter had been aimed at. In a 1998 article for
    the now defunct *C++ Report* magazine, C++ guru Herb Sutter wrote a tongue-in-cheek
    spoof on this new language, whose name ostensibly expanded to Bjarne's Object
    Oriented Software Environment. In this article, he claimed that portability and
    *potability* were, among other things, key advantages of this language, which
    also supposedly promoted extraordinary camaraderie in team environments and made
    developers excessively happy, communicative, and passionate.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this was an April Fools'' Day article in 1998, the fact remained that
    the first C++ Standard was going to have a fairly basic standard library consisting
    of a memory allocation subsystem, type-generic containers and algorithms, a string
    class, basic abstractions for input and output devices, and sundry utilities.
    Now around the same time, a few folks from the C++ Standards Committee formed
    a group that worked on producing a collection of high-quality, peer-reviewed,
    free, and open source libraries in C++ that would have wide applicability and
    complement the features in standard C++. Inspired by BOOSE, perhaps for its stated
    competition with Java, which was a newer language but with a much richer library,
    they named this initiative Boost, a working title that stuck (source: FAQ on the
    Boost website, [http://www.boost.org](http://www.boost.org)).'
  prefs: []
  type: TYPE_NORMAL
- en: What is Boost?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boost is a collection of free, peer-reviewed, portable, open source libraries
    in C++. Over the last decade and a half, there have been, as of this writing,
    57 releases of the Boost libraries. In this span, Boost has released libraries
    of compelling usefulness that promote correct, portable, efficient, and readable
    C++ code. A number of prominent Standards Committee members are also the most
    active participants in Boost and subsequent directions of C++ standardization
    have been heavily influenced by the work done at Boost. Boost has provided the
    Standards Committee with the laboratory they need to perfect their ideas for the
    best new features that C++ should have. Several Boost libraries were included
    in the *Technical Report 1* of the C++ Standards Committee, which considerably
    enhanced the functionality defined in the C++ 2003 revised standard; these included
    both language and library features. Most of these libraries made it to the C++11
    Standard published in 2011\. A couple more library features that originated in
    Boost have been added to the latest revision of the C++ Standard known as C++14
    (published in 2014).
  prefs: []
  type: TYPE_NORMAL
- en: 'Over the years, Boost has added libraries for string and text processing, including
    regular expression handling, generic containers compatible with the Standard Library,
    smart pointers for efficient exception-safe memory management, concurrent programming,
    network programming, interprocess communication, filesystem handling, template
    metaprogramming, and many others. The following table lists some of the prominent
    Boost libraries grouped by category. This is by no means exhaustive:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Category | Libraries |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Memory management | Smart Ptr, Align, Pool |'
  prefs: []
  type: TYPE_TB
- en: '| Data structures | Container, Array, Multi-Index, Bimap, Pointer Container,
    Optional, Variant, Any, Tuple, Assign |'
  prefs: []
  type: TYPE_TB
- en: '| Algorithms | Algorithm, Range |'
  prefs: []
  type: TYPE_TB
- en: '| String and text | Conversion, String Algo, Regex, Tokenizer, Spirit, Xpressive
    |'
  prefs: []
  type: TYPE_TB
- en: '| Systems programming | System, Filesystem, Chrono, Date Time, Thread, Asio,
    Interprocess |'
  prefs: []
  type: TYPE_TB
- en: '| I/O | IOStreams, Locale, Serialization, Format |'
  prefs: []
  type: TYPE_TB
- en: '| Higher-order programming | Function, Bind, Phoenix, Signals2 |'
  prefs: []
  type: TYPE_TB
- en: '| Generic programming | Enable If, Type Traits, MPL, Fusion, Proto |'
  prefs: []
  type: TYPE_TB
- en: '| Language features emulation | Foreach, Move, Exception, Parameter |'
  prefs: []
  type: TYPE_TB
- en: '| Correctness and testing | Test, Static Assert |'
  prefs: []
  type: TYPE_TB
- en: '| Miscellaneous | Utility, Log, Uuid, Program Options, CRC |'
  prefs: []
  type: TYPE_TB
- en: Boost libraries have found varied use in the industry because of some very high-performance
    libraries (such as Boost.Asio and Boost.Intrusive), and because of a very permissive
    and uncomplicated Boost license, which allows source redistribution, distribution
    of derivative work, and distribution in a binary form for noncommercial as well
    as commercial purposes with minimal constraints. In the next section, we will
    set up a development environment that enables us to use any Boost library in our
    C++ code using consistent conventions. This should serve us well for the rest
    of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Boost libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We shall now set up a development sandbox for you to write code using the Boost
    libraries. We can either install a binary distribution of the Boost libraries,
    or build them from source. If we build them from source, we have a whole range
    of concerns to take care of from choosing a suitable naming convention for the
    library files and building the libraries, to making sure that we are linking them
    to the correct versions of the library. There are platform-specific differences
    too that need to be handled; we shall take a look at both the Linux and Windows
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: Necessary software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On Linux, we will only consider the C++ compiler (g++) version 4.8.1 or later,
    distributed with the **GNU Compiler Collection** (**GCC**). On Windows, we will
    use Visual Studio 2013\. You can get more elaborate software support matrices
    for each Boost release on the Boost website.
  prefs: []
  type: TYPE_NORMAL
- en: Linux toolchain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should be able to build Boost on most major Linux distributions. I use a
    Lubuntu 14.04 32-bit installation with GCC 4.8.1 and Clang 3.4\. You can possibly
    build on much older distributions, as the Boost website lists GCC 3.3 as the minimum
    supported version. If you also want good C++11 support, use GCC 4.8 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: '| Required software | Minimum version | Recommended version | Ubuntu package
    | Fedora/CentOS package |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| GNU C++ compiler | 4.8.x | 4.8.4 | g++ | gcc-c++ |'
  prefs: []
  type: TYPE_TB
- en: '| GNU Standard C++ Library | 4.8.x | 4.8.4 | libstdc++-dev | libstdc++-devel
    |'
  prefs: []
  type: TYPE_TB
- en: '| GNU Standard C++ runtime | 4.8.x | 4.8.4 | libstdc++ | libstdc++ |'
  prefs: []
  type: TYPE_TB
- en: 'If you want to use Clang instead of GCC, the recommended version is 3.4 or
    higher. Here are the required packages on Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Required software | Minimum version | Recommended version | Ubuntu package
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| LLVM compiler toolchain | 3.2 | 3.4 | llvm |'
  prefs: []
  type: TYPE_TB
- en: '| LLVM C, C++, and Objective-C compiler | 3.2 | 3.4 | clang |'
  prefs: []
  type: TYPE_TB
- en: '| LLVM C++ Standard Library | 3.2 | 3.4 | libc++-dev |'
  prefs: []
  type: TYPE_TB
- en: Windows toolchain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You should be able to build Boost on Visual Studio 7.1 upwards. I use Visual
    Studio 2013 on a Windows 7 64-bit installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Requiredsoftware | Minimum version | Recommended version |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Visual Studio with Visual C++ | 7.1 | 12 (2013) |'
  prefs: []
  type: TYPE_TB
- en: I would also recommend installing 7-Zip on Windows to extract Boost sources
    from the `.7z` or `.tar.bz2` archives, which offer much better compression than
    the `.zip` archives.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining and building Boost libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can build the Boost libraries from source or install them as an operating
    system package on platforms where such as package is available. All examples in
    this book use Boost version 1.57\. You may choose to download a more recent version
    of the sources and most of the discussion here should still hold. However, few
    details may change from one release to the next, so you should be prepared to
    dig into the online documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Planning your Boost sandbox
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As part of our day-to-day development work using Boost, we would need access
    to Boost's header files and Boost's libraries. A vast number of Boost libraries
    are *header-only*, which means that you just need to include the appropriate headers
    and build your sources. Some others have to be built into binary libraries that
    can be *linked statically or dynamically* to your application.
  prefs: []
  type: TYPE_NORMAL
- en: If we build from source, we will first identify a directory on our development
    machine, where we would like to install these files. The choice is arbitrary,
    but we can follow conventions if they exist. So on Linux, we can choose to install
    the library headers and binaries under `/opt/boost`. On Windows, this could be
    `f:\code\libraries\Boost`. You are free to choose different paths, just avoid
    spaces within them for less hassle.
  prefs: []
  type: TYPE_NORMAL
- en: Library naming conventions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Boost library binaries can have names that are difficult to decipher at first.
    So, we shall learn about what goes into naming the libraries. Library names have
    different layouts. Depending on the layout, different components are added to
    the base name in order to identify different facets of the library's binary compatibility
    and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Library name components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each library, whether static or shared, is named according to a well-defined
    scheme. The name of a library can be split into several components, not all of
    which are mandatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prefix**: Libraries may have a prefix, typically `lib`. On Windows, only
    static libraries have this prefix while on Unix, all libraries have this prefix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Toolset identifier**: Library names may be tagged with the string, identifying
    the toolset with which it was built. Roughly speaking, a toolset or toolchain
    is the set of system utilities, including compiler, linker, archiver, and so on,
    that are used to build libraries and programs. For example, `vc120` identifies
    the Microsoft Visual C++ 12.0 toolchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Threading model**: If a library is thread-safe, that is, it can be used in
    multithreaded programs without additional synchronization, then its name may be
    tagged with `mt`, which stands for multithreaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ABI**: ABI stands for **application binary interface**. This component captures
    details, such as whether the library is a debug library (`d`) or not, whether
    it is linked to a debug version of the runtime (`g`) or not, and whether the link
    to the runtime is static (`s`) or not. Thus, a debug library that is statically
    linked to a release version of the runtime would be marked with only `sd`, while
    one that is dynamically linked to a debug version would be marked with `gd`. A
    release version of the library dynamically linked to a release version of the
    runtime will have a blank ABI marker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version**: This is the version string of the Boost library. For example,
    `1_57` would be the version marker for the Boost 1.57 libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extension**: Library extensions identify the file types. On Windows, dynamic
    libraries have the extension `.dll`, while static libraries and import libraries
    have the extension `.lib`. On Linux and some other Unix systems, dynamic libraries
    have the extension `.so`, while static libraries or archives have the extension
    `.a`. Dynamic library extensions often have a version suffix, for example, `.so.1.57.0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Library name layouts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'How a library name is made up of its components determines its name layout.
    There are three kinds of name layouts supported by Boost: versioned, system, and
    tagged.'
  prefs: []
  type: TYPE_NORMAL
- en: Versioned layout
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It is the most elaborate layout and is the default layout on Windows. The general
    structure of the versioned layout name is `libboost_<name>-<toolset>-<threading>-<ABI>-<version>.<ext>`.
    For example, here is the `Boost.Filesystem` library debug DLL for Windows: `boost_filesystem-vc100-mt-gd-1_57.dll`.
    The tokens in the filename tell the complete story. This DLL was built using Visual
    C++ 10.0 compiler (`-vc100`), is thread-safe (`-mt`), and is a debug DLL (`d`)
    linked dynamically to the debug version of the runtime (`g`). The version of Boost
    is 1.57 (`1_57`).'
  prefs: []
  type: TYPE_NORMAL
- en: System layout
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The default layout on Unix is the system layout that removes all the name decorations.
    The general structure of library names in this layout is `libboost_<name>.<ext>`.
    For example, here is the `Boost.System` shared library on Linux: `libboost_filesystem.so.1.57.0`.
    Looking at it, there is no way to tell whether it supports multithreading, whether
    it is a debug library, or any other detail that you could wean from a filename
    in the versioned layout. The `1.57.0` suffix of the extension indicates the version
    of the shared library. This is the Unix convention for versioning shared libraries
    and is not affected by the Boost name layout.'
  prefs: []
  type: TYPE_NORMAL
- en: Tagged layout
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There is a third layout called the tagged layout, which is midway between the
    versioned and system layouts in terms of detail. It removes all the version information
    but retains other information. Its general structure is `libboost_<name>-<threading>-<ABI>.<ext>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `Boost.Exception` static library from Windows built using the non-default
    tagged layout: `libboost_filesystem-mt.lib`. This is a static library as indicated
    by its `lib-` prefix. Also, `-mt` indicates that this library is thread-safe,
    and the lack of an ABI indicator means that this is not a debug library (`d`),
    nor does it link to the static runtime (`s`). Also, it does not link to the debug
    version of the runtime (`g`).'
  prefs: []
  type: TYPE_NORMAL
- en: The versioned layout is a bit unwieldy. On systems where you need to manually
    specify names of libraries to link against, moving from one version of Boost to
    the next would require some effort to fix the build scripts. The system layout
    is a bit minimalistic and is great for environments where you need only one variant
    of a given library. However, you cannot have both debug and release versions of
    the library, or thread-safe and thread-unsafe ones side by side, with system layout.
    For this reason, in the rest of this book, we will only use tagged layout for
    the libraries. We will also only build thread-safe libraries (`-mt`) and shared
    libraries (`.dll` or `.so`). Some libraries can only be built as static libraries
    and, as such, would be automatically created by the Boost build system. So now,
    we finally get to the point where we have enough information to start creating
    our Boost sandbox.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a Boost binary distribution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On Microsoft Windows and several distributions of Linux, you can install a
    binary distribution of the Boost libraries. The following table lists the methods
    of installing Boost on some of the popular operating systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operating system | Package name | Install method |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Microsoft Windows | `boost_1_57_0-msvc-12.0-64.exe` (64-bit)`boost_1_57_0-msvc-12.0-32.exe`
    (32-bit) | Download executable from [http://sourceforge.net/projects/boost/files/boost-binaries/](http://sourceforge.net/projects/boost/files/boost-binaries/)
    and install it by running the executable |'
  prefs: []
  type: TYPE_TB
- en: '| Ubuntu | `libboost-all-dev` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Fedora/CentOS | `boost-devel` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Installing a binary distribution is convenient because it is the fastest way
    to be up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Installing on Windows
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Starting with Boost 1.54, you can download a binary distribution of the Boost
    libraries, built using Microsoft Visual Studio, from SourceForge. The download
    is available as a 64-bit or 32-bit installable executable that contains header
    files, libraries, sources, documentation, and tools. There are separate distributions
    for different versions of Visual Studio, from version 12 (VS 2013) backward through
    version 8 (VS 2005). The name of the executable is of the form `boost_ver-msvc-vcver-W.exe`,
    where `ver` is the Boost version (for example, 1_57_0), `vcver` is the version
    of Visual C++ (for example, 12.0 for Visual Studio 2013), and `W` is the native
    word size of your operating system (for example, 64 or 32).
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of the installation, you can choose the directory where you want to
    install the Boost libraries. Let us consider that you choose to install it under
    `boost-dir`. Then, the following directories contain the necessary headers and
    libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Directory | Files |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `boost-dir` | This is the base directory of the Boost installation. All the
    header files are present in a hierarchy under the `boost` subdirectory. |'
  prefs: []
  type: TYPE_TB
- en: '| `boost-dir/libW-msvc-vcver` | This directory contains all variants of the
    Boost libraries, static and shared (DLLs), debug and release. The library filenames
    follow the versioned layout.W: 32 or 64 depending on whether you installed a 32-bit
    version or 64-bit version.vcver: Visual Studio version. |'
  prefs: []
  type: TYPE_TB
- en: '| `boost-dir/doc` | This directory contains the library documentation in the
    HTML format and contains scripts to build PDF docs. |'
  prefs: []
  type: TYPE_TB
- en: Installing on Linux
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On Ubuntu, you need to install the `libboost-all-dev` package. You need to
    perform the installation using superuser privileges, so run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This installs the necessary headers and libraries in the following directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Directory | Files |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `/usr/include` | This contains all the header files present in a hierarchy
    under the `boost` subdirectory. |'
  prefs: []
  type: TYPE_TB
- en: '| `/usr/lib/arch-linux-gnu` | This contains all the Boost libraries, static
    and shared (DSOs). The library filenames follow the system layout.Replace arch
    with `x86_64` for 64-bit operating systems and with `i386` for 32-bit operating
    systems. |'
  prefs: []
  type: TYPE_TB
- en: 'On CentOS/Fedora, you need to install the `boost-devel` package. You need to
    perform the installation using superuser privileges, so this is the command to
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This installs the necessary headers and libraries in the following directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Directory | Files |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `/usr/include` | This contains all the header files present in a hierarchy
    under the boost directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `/usr/lib` | This contains all the Boost libraries, static and shared (DSOs).
    The library filenames follow the system layout. |'
  prefs: []
  type: TYPE_TB
- en: Building and installing the Boost libraries from source
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Building the Boost libraries from source offers more flexibility, as it is easy
    to customize the build, use alternative compilers/toolchains, and change the default
    name layout like we plan to. We shall build the Boost libraries from a source
    archive downloaded from the Boost website [http://www.boost.org](http://www.boost.org)
    or [http://sourceforge.net/projects/boost](http://sourceforge.net/projects/boost).
    I prefer the 7-Zip or the bzip2 archives, as they have the best compression ratios.
    We will use Boost libraries Version 1.57, and we will look at building them only
    on Linux and Windows operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Optional packages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are several *optional* packages that are used to provide additional functionality
    by certain Boost libraries when present. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: The `zlib` and `bzip2` development libraries, used by `Boost.IOStream` to read
    and write compressed archives in `gzip` and `bzip2` formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ICU i18n` development libraries, which are heavily used by `Boost.Locale`
    and also by `Boost.Regex` to support Unicode regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `expat` XML parser library, used by the `Boost.Graph` library to support
    the GraphML XML vocabulary for describing graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of these libraries may be made available through your native package management
    systems, particularly on Linux. When installed from such packages, the Boost build
    system may find these libraries automatically and link them by default. If you
    chose to build these libraries from source and installed them at non-standard
    locations instead, then you should use specific environment variables to point
    to the installation directory of these libraries or to the `include` and `library`
    directories. The following table summarizes these optional libraries, their source
    websites, Ubuntu package names, and the environment variables needed by Boost
    to identify them when installed from source:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Library | Details |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Zlib library ([http://www.zlib.net](http://www.zlib.net)) | Environment variable:
    `ZLIB_SOURCE` (extracted source directory)Ubuntu packages: `zlib1g`, `zlib1g-dev`,
    and `zlib1c` |'
  prefs: []
  type: TYPE_TB
- en: '| Bzip2 library ([http://www.bzip.org/downloads.html](http://www.bzip.org/downloads.html))
    | Environment variable: `BZIP2_SOURCE` (extracted source directory)Ubuntu packages:
    `libbz2` and `libbz2-dev` |'
  prefs: []
  type: TYPE_TB
- en: '| ICU library ([http://www.icu-project.org/download](http://www.icu-project.org/download))
    | Environment variables:`HAVE_ICU=1``ICU_PATH` (installation root)Ubuntu package:
    `libicu-dev` |'
  prefs: []
  type: TYPE_TB
- en: '| Expat library ([http://sourceforge.net/projects/expat](http://sourceforge.net/projects/expat))
    | Environment variables: `EXPAT_INCLUDE` (expat include dir) and `EXPAT_LIBPATH`
    (expat library dir)Ubuntu packages: `libexpat1` and `libexpat1-dev` |'
  prefs: []
  type: TYPE_TB
- en: We will be using the `gzip` and `bzip2` libraries in [Chapter 9](ch09.html "Chapter 9. Files,
    Directories, and IOStreams"), *Files, Directories, and IOStreams*, to compress
    data, while we will not be using the ICU and Expat libraries for the code examples
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Boost libraries on Linux
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you choose not to install a binary distribution of Boost or if such a distribution
    is not available for your platform, then you must build the Boost libraries from
    source. Download the source archives for the Boost libraries, `zlib` and `bzip2`.
    Assuming that you want to install Boost in the`/opt/boost` directory, perform
    the following steps from a shell command prompt to build Boost with the GNU toolchain:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory and extract the Boost source archive in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate the Boost build system for your toolset. The following should work
    if you are building with **g++**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using Clang instead, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Extract the `bzip2` and `zlib` source archives and make a note of the directories
    they have been extracted to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Build the libraries and install them. For GCC, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For Clang, run the following command instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The last step should build all the Boost libraries and install them under the
    `/opt/boost` directory, as identified by the `--prefix` option. All the libraries
    will be installed under `/opt/boost/lib` and all include files under `/opt/boost/include`.
    In addition to the Boost libraries, you should also see `libboost_zlib-mt.so`
    and `libboost_bzip2-mt.so`—the dynamic shared objects for `zlib` and `bzip2`,
    which `libboost_iostreams-mt.so` depends on.
  prefs: []
  type: TYPE_NORMAL
- en: The `--build-dir` option would identify the directory in which the intermediate
    products of the build are created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--layout=tagged` option chooses the tagged layout for library names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will build only thread-safe (`threading=multi`) shared libraries (`link=shared`)
    if possible, linked them to the dynamic runtime (`runtime-link=shared`). We would
    need both debug and release versions of the library (`variant=debug,release`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-sZLIB_SOURCE=<zlib-source-dir>` option is used to point the build to the
    directory under which the `zlib` sources were extracted in step 3; likewise, for
    the `bzip2` source directory, using `-sBZIP2_SOURCE=<bzip2-source-dir>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to build Boost libraries using support for C++11, then you should
    use the `cxxflags="-std=c++11"` option. Throughout the rest of the book, many
    of the code examples use features from C++11\. Enabling a C++11 build of Boost
    at this point might be a good idea. Make sure that your compiler has good support
    for C++11\. For g++, it would be version 4.8.1 or later. Also, make sure that
    you compile all your own code using the Boost libraries with C++11 as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the examples in this book use C++11 features, and so you should keep
    the C++11 option on while compiling Boost. Appendix provides a short introduction
    to the important C++11 features used in this book, and also describes how you
    can emulate them in C++03 using Boost if you are still using an older compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Boost libraries on Windows
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once you have downloaded the Boost source archive, from a Windows Explorer
    session, create a directory called `boost-src` and extract the source archive
    inside this directory. Assuming that you want to install Boost in the `boost-dir`
    directory and `boost-build` is the directory in which the intermediate products
    of the build are kept, perform the following steps from a command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the 32-bit Visual C++ build environment to build the Boost build
    system (even if you want to build 64-bit):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'On a 64-bit system with a 32-bit Visual Studio installation, Visual Studio
    is typically installed under `C:\Program Files (x86)`, so you will have to run
    this command instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate the Boost build system for your toolset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to build 64-bit Boost libraries, initialize the 64-bit Visual C++
    build environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'On a 64-bit system with 32-bit Visual Studio installation, you will have to
    run this command instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Extract the `bzip2` and `zlib` source archives, and make a note of the directories
    they have been extracted to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Build the libraries and install them. If you want to build 32-bit libraries,
    use the following command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to build 64-bit libraries, use the following command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This last step builds and installs the necessary headers and libraries in the
    following directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Directory | Files |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `boost-dir/include` | All header files present in a hierarchy under the `boost`
    directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `boost-dir/libs` | All 32-bit Boost libraries, static and shared libraries
    (DLLs), debug and release. |'
  prefs: []
  type: TYPE_TB
- en: '| `boost-dir/libs64` | All 64-bit Boost libraries, static and shared libraries
    (DLLs), debug and release |'
  prefs: []
  type: TYPE_TB
- en: In addition to the Boost libraries, you should also see `boost_zlib-mt.dll`
    and `boost_bzip2-mt.dll`—the DLLs for `zlib` and `bzip2`, which `boost_iostreams-mt.dll`
    depends on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at the various options we have used in the preceding commands:'
  prefs: []
  type: TYPE_NORMAL
- en: The `--build-dir` option will identify the directory in which the intermediate
    products of the build are created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--layout=tagged` option chooses the tagged layout for the library names,
    as explained earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will build only the shared libraries (`link=shared`). If possible, link them
    to the dynamic runtime (`runtime-link=shared`), and create thread-safe libraries
    (`threading=multi`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will want both debug and release versions of the library (`variant=debug,release`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 32- and 64-bit builds will take place in separate intermediate directories
    identified by the `--build-dir` option and will be copied to separate library
    directories identified by the `--libdir` option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `address-model=64` option would trigger the 64-bit build.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under Visual Studio 2013, C++11 support is automatically enabled, and you do
    not need to use any specific switches for the purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Using Boost libraries in your projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We shall now write our first small C++ program that uses the Boost Filesystem
    library to check for the existence of a file whose name is passed to on the command
    line and then build on Linux and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the listing for `chkfile.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Linking against Boost libraries on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you have installed Boost in a nonstandard location (which is typically the
    case if you have not installed it from a native package), then you will need to
    make sure that your preprocessor can find the Boost header files you have included
    using the `–I` option in the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This step will create an object file called `chkfile.o`, which we will link
    to the binary. You can specify which library to link to using the `-l` option.
    In case of a nonstandard installation, you will need to ensure that the linker
    can find the path to the library you want to link against using the `-L` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the `-std=c++11` option only if you built your Boost libraries using C++11.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding command line will work for either a static or a shared library.
    However, if both types of library are found, it will use the shared version. You
    can override this with appropriate linker options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding case, the `filesystem` library is linked statically while others
    are linked dynamically. The `-Wl` switch is used to pass its arguments to the
    linker. In this case, it passes the `-Bstatic` and `-Bdynamic` switches.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it is a shared library that you link against, then at runtime the dynamic
    linker needs to locate the shared library and load it too. The way to ensure this
    varies from one version of Unix to the other. One way to ensure this is to embed
    a search path in your executable using the `rpath` linker directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: On the target system, where the binary `mytest` is run, the dynamic linker would
    look for the `filesystem` and `system` shared libraries under `/opt/boost/lib`
    and `/usr/lib/boost`.
  prefs: []
  type: TYPE_NORMAL
- en: Other ways besides using the `rpath` mechanism also exist. Linux uses a utility
    called `ldconfig` to locate shared libraries and update search paths. For more
    details, look at the man pages for `ldconfig (8)`. On Solaris, the `crle` utility
    performs a similar action.
  prefs: []
  type: TYPE_NORMAL
- en: Linking against Boost libraries on Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the Visual Studio IDE, we will have to tweak certain project settings
    in order to link against the Boost libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, ensure that your compiler is able to find the necessary header files:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your C++ project in Visual Studio. From the menu, select **Project** |
    **Project Properties**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Property Pages** dialog that comes up, expand **Configuration Properties**
    and select **C/C++**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the value of **Additional Include Directories** by adding the path to your
    Boost, include directories. Separate it from other entries in the field using
    a semicolon:![Linking against Boost libraries on Windows](img/1217OT_01_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, ensure that your linker is able to find the shared or static libraries.
    In the **Project Properties** dialog, under **Configuration Properties**, choose
    **Linker**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the **Additional Library Directories** field to add the path to the Boost
    libraries, separated by a semicolon from any other entries:![Linking against Boost
    libraries on Windows](img/1217OT_01_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you can leverage Boost's *auto-linking* feature on Windows to automatically
    link to the correct libraries. To enable this, you have to define the `BOOST_ALL_DYN_LINK`
    preprocessor symbol. To do this, in the **Project Properties** dialog, navigate
    to **Configuration Properties** | **C/C++** | **Preprocessor**, and add `BOOST_ALL_DYN_LINK`
    to the **Preprocessor Definitions** field, separating it from other entries with
    a semicolon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you built your Boost libraries on Windows with the default layout (versioned),
    this is all you will need to do for linking correctly. If we use the tagged layout,
    we must also define a second preprocessor symbol `BOOST_AUTO_LINK_TAGGED`. If
    we use system layout for naming, we will need to define `BOOST_AUTO_LINK_NOMANGLE`
    instead. You will get a linker error without these definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking against Boost libraries on Windows](img/1217OT_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You should now be able to build your project from your IDE without any problems.
    In order to run your program, the dynamic linker must be able to locate the dynamic
    library. To take care of this, on Windows, you can add the path of your Boost
    libraries to the PATH environment variable. For running your programs from within
    the IDE, you can add the path of your Boost libraries to the PATH variable by
    navigating to **Debugging** | **Environment**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking against Boost libraries on Windows](img/1217OT_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building the code listings in this book
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each chapter in this book includes the example source code, which is also available
    for download from the Packt website ([http://www.packtpub.com](http://www.packtpub.com)).
    You should download and build these examples on your development machines.
  prefs: []
  type: TYPE_NORMAL
- en: CMake
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to build the examples, you need to install CMake, which is one of the
    most popular cross-platform build tools for C++ programs. With CMake, you can
    easily generate a build system of your choice on an operating system of your choice,
    using a single set of CMake specifications.
  prefs: []
  type: TYPE_NORMAL
- en: You can download a binary package for CMake from [www.cmake.org](http://www.cmake.org),
    or download a source archive and build it on a platform of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Minimum version required**: CMake 2.8.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows**: A 32-bit exe-installer is available for Windows that works for
    both 32-bit and 64-bit builds.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux**: CMake is usually bundled with all major Linux distributions and
    is available as an optional package. Consult your distribution''s package repository.'
  prefs: []
  type: TYPE_NORMAL
- en: Code examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Download the source code archive and extract it to a directory on your development
    machine. The layout of the extracted directory would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code examples](img/1217OT_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The source code archive available for download contains separate directories
    for each chapter. Within each chapter directory, you will find the complete source
    code for each example. The source code files are named based on the listing identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'A listing identifier is a unique tag used for examples in this book, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code examples](img/1217OT_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, the listing identifier is **Listing 11.18** and indicates that this is
    the eighteenth example in [Chapter 11](ch11.html "Chapter 11. Network Programming
    Using Boost Asio"), *Network Programming Using Boost Asio*. Therefore, in the
    `ch11` folder, you will find `listing11_18.cpp`, which contains the asynchronous
    UDP server example that appears in [Chapter 11](ch11.html "Chapter 11. Network
    Programming Using Boost Asio"), *Network Programming Using Boost Asio*. In some
    cases, a big example is broken down into multiple listings in the text, but they
    all form part of the same source file. In such cases the listings are tagged with
    letters; for example, listing 7.22a, 7.22b, 7.22c, and so on. You can still expect
    a file called `listing7_22.cpp`, which combines the code from these listings.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to build all the examples in this book, you need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that CMake 2.8 or higher is installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the source archive for the book to a directory, say `srcdir`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change to the `cmake_bin` directory under the source directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Export the `BOOST_DIR` environment variable to point to the Boost installation
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, if it is `/opt/boost` on Linux, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you have installed Boost from a standard package in the package repository
    of your distribution, then you can skip this step.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows, if you have installed it under `f:\boost`, you can run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If the Boost include directory and the Boost library directory do not share
    a common parent, as may be the case if you installed a binary distribution of
    Boost, then you should skip setting `BOOST_DIR` and instead set the following
    two environment variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`BOOST_INCDIR` should be set to the directory that contains the Boost header
    files, for example, `/usr/include` on Ubuntu.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BOOST_LIBDIR` should be set to the directory that contains the Boost library
    files, for example, `/usr/lib/x86_64-linux-gnu` on Ubuntu.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate the build system of your choice using CMake.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On Linux, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates a Makefile-based build system using GNU g++. If you want to
    use clang++ instead, export the environment variables CC and CXX, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This generates a Visual C++ 2013 solution file and project files. The string
    passed with the `-G` option is called the generator string and identifies the
    toolchain for which you want to generate the build system. The CMake documentation
    lists all the supported generator strings. For our purposes, we will use **Visual
    Studio 12** or **Visual Studio 12 Win64**.
  prefs: []
  type: TYPE_NORMAL
- en: Build the sources using the generated build system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On Linux, you can build it by simply running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: On Windows, it is best to build by opening the generated solution file in Visual
    C++ IDE and then building all the sources or a single source at a time. You can
    run the examples by running the executables formed under `srcdir/lbcpp-src/bin`.
  prefs: []
  type: TYPE_NORMAL
- en: We do not cover CMake in this book. It is worth exploring CMake further on your
    own, and a great place to get started is the CMake Wiki ([http://www.cmake.org/Wiki/CMake](http://www.cmake.org/Wiki/CMake)).
  prefs: []
  type: TYPE_NORMAL
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the different types of name layouts supported by Boost libraries?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Tagged, native, and mangled
  prefs: []
  type: TYPE_NORMAL
- en: b. Tagged, mangled, and versioned
  prefs: []
  type: TYPE_NORMAL
- en: c. Tagged, versioned, and system
  prefs: []
  type: TYPE_NORMAL
- en: d. Versioned, systems, and decorated
  prefs: []
  type: TYPE_NORMAL
- en: Boost allows you to automatically link to necessary Boost libraries on Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. True
  prefs: []
  type: TYPE_NORMAL
- en: b. False
  prefs: []
  type: TYPE_NORMAL
- en: What does the following filename tell you about the library?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`boost_date_time-vc100-mt-gd-1_57.dll`'
  prefs: []
  type: TYPE_NORMAL
- en: Tick all that apply.
  prefs: []
  type: TYPE_NORMAL
- en: a. It is the DateTime library.
  prefs: []
  type: TYPE_NORMAL
- en: b. It is a thread-safe library.
  prefs: []
  type: TYPE_NORMAL
- en: c. It was built using g++.
  prefs: []
  type: TYPE_NORMAL
- en: d. It is not a debug library.
  prefs: []
  type: TYPE_NORMAL
- en: What is the name layout of the following library?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`libboost_exception-mt-gd.lib`'
  prefs: []
  type: TYPE_NORMAL
- en: a. Tagged
  prefs: []
  type: TYPE_NORMAL
- en: b. System
  prefs: []
  type: TYPE_NORMAL
- en: c. Versioned
  prefs: []
  type: TYPE_NORMAL
- en: d. Default
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got an overview of the Boost C++ libraries and set up a
    development environment for us, which should help us to easily build and run C++
    programs, using Boost libraries that we will learn in the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn a variety of techniques using different Boost
    libraries, which simplify some common day-to-day programming tasks and set us
    up for the heavy lifting to be done in the later chapters.
  prefs: []
  type: TYPE_NORMAL
