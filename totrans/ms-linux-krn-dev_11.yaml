- en: Module Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kernel modules (also referred as LKMs) have accentuated the development of kernel
    services owing to their ease of use. Our focus through this chapter will be to
    understand how the kernel seamlessly facilitates this entire process, making loading
    and unloading of modules dynamic and easy, as we look through all core concepts,
    functions and important data structures involved in module management. We assume
    readers are familiar with the basic usage of modules.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Key elements of a kernel module
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module layout
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module load and unload interfaces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key data structures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel modules
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kernel module is an easy and effective mechanism to extend the functionality
    of a running system without the baggage of rebuilding the whole kernel, they have
    been vital in ushering dynamism and scalability to the Linux operating system.
    Kernel modules not only satiate the extendable nature of the kernel but also usher
    the following functionalities:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Allowing kernel the ability to only keep features which are necessary, in-turn
    boosting capacity utilization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing proprietary/non-GPL compliant services to load and unload
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bottom-line feature of extensibility of the kernel
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elements of an LKM
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each module object comprises of the *init(constructor)* and *exit(destructor)*
    routines. The *init* routine is invoked when a module is deployed into kernel
    address space, and the *exit* routine is called while the module is being removed.
    As the name innately suggests, the *init* routine is usually programmed to carry
    out operations and actions which are essential to set up the module body: such
    as registering with a specific kernel subsystem or allocating resources that are
    essential for the functionality being loaded. However, specific operations programmed
    within the *init* and *exit* routines depend on what the module is designed for
    and the functionality it brings to the kernel. The following code excerpt shows
    template of the *init* and *exit* routines:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice that the *init* routine returns an integer—a zero is returned if the
    module is committed to the kernel address space and a negative number is returned
    if it fails. This additionally provides flexibility for programmers to commit
    a module only when it succeeds in registering with the required subsystem.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'The default names for the init and exit routines are `init_module()` and `cleanup_module()`,
    respectively. Modules can optionally change names for the *init* and *exit* routines
    to improve code readability. However, they will have to declare them using the
    `module_init` and `module_exit` macros:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Comment macros form another key element of a module code. These macros are
    used to provide usage, licence, and author information of the module. This is
    important as modules are sourced from various vendors:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '`MODULE_DESCRIPTION()`: This macro is used to specify the general description
    of the module'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MODULE_AUTHOR()`: This is used to provide author information'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MODULE_LICENSE()`: This is used to specify legal licence for the code in the
    module'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the information specified through these macros is retained into the module
    binary and can be accessed by users through a utility called *modinfo*. `MODULE_LICENSE()`
    is the only mandatory macro that a module must mention. This serves a very handy
    purpose, as it informs users about proprietary code in a module, which is susceptible
    to debugging and support issues (kernel community in all probability ignores issues
    arising out of proprietary modules).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Another useful feature available for modules is of dynamic initialization of
    module data variables using module parameters. This allows data variables declared
    in a module to be initialized either during module deployment or when module is
    *live* in memory (through the sysfs interface). This can be achieved by setting
    up selected variables as module parameters through the appropriate `module_param()`
    family of macros (found in kernel header `<linux/moduleparam.h>`). Values passed
    to module parameters during deployment of the module are initialized before the
    *init* function is invoked.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Code in modules can access global kernel functions and data as needed. This
    enables the code of the module to make use of existing kernel functionality. It
    is through such function calls a module can perform required operations such as
    printing messages into kernel log buffer, allocation and de-allocation of memory,
    acquiring and releasing of exclusion locks, and registering and unregistering
    module code with appropriate subsystem.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, a module can also export its symbols into the global symbol table
    of the kernel, which can then be accessed from code in other modules. This facilitates
    granular design and implementation of kernel services by organizing them across
    a set of modules, instead of having the whole service implemented as a single
    LKM. Such stacking up of related services leads to module dependency, for instance:
    if module A is using the symbols of module B, then A has dependency on B, in that
    case, module B must be loaded before module A and and module B cannot be unloaded
    until module A is unloaded.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Binary layout of a LKM
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modules are built using kbuild makefiles; once the build process completes,
    an ELF binary file with a *.ko* (kernel object) extension is generated. Module
    ELF binaries are appropriately tweaked to add new sections, to differentiate them
    from other ELF binaries, and to store module-related metadata. The following are
    the sections in a kernel module:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '| `.gnu.linkonce.this_module` | Module structure |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
- en: '| `.modinfo` | Information about the module (Licenses and so on) |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
- en: '| `__versions` | Expected versions of symbols that the module depends on during
    compile time |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
- en: '| `__ksymtab*` | The table of symbols exported by this module |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
- en: '| `__kcrctab*` | The table of versions of symbols exported by this module |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '| `.init` | Sections used when initializing |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| `.text, .data etc.` | Code and data sections |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: Load and unload operations
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modules can be deployed through special tools that are part of an application
    package called *modutils,* of which *insmod* and *rmmod* are widely used. *insmod*
    is used to deploy the module into kernel address space and *rmmod* is used for
    unloading a live module. These tools initiate load/unload operations by invoking
    appropriate system calls:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, `finit_module()` is invoked (by `insmod`) with the file descriptor of
    the specified module binary file (.ko) and other relevant arguments. This function
    steps into kernel mode by invoking the underlying system call:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, `may_init_module()` is called to verify the `CAP_SYS_MODULE` privilege
    of the calling context; this function returns a negative number on failure and
    zero on success. If the caller has the required privilege, a specified module
    image is accessed through *fd* using the `kernel_read_file_from_fd()` routine
    that returns address of the module image, which is populated into an instance
    of `struct load_info`. Finally, the `load_module()` core kernel routine is invoked
    with address to instance of `load_info` and other user arguments passed down from
    the `finit_module()` call:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, `load_module()` is a core kernel routine that attempts to link module
    image into kernel address space. This function initiates a series of sanity checks,
    and finally commits the module by initializing module parameters to values provided
    by the caller, and invokes the *init* function of the module. The following steps
    detail these operations with names of the relevant helper functions invoked:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Checking for the signature (`module_sig_check()`)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for the ELF header (`elf_header_check()`)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the module layout and allocate the necessary memory (`layout_and_allocate()`)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Appending the module to the modules list (`add_unformed_module()`)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocate per-cpu areas used in the module (`percpu_modalloc()`)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As module is in final location, finding the optional sections (`find_module_sections()`)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for module license and versions (`check_module_license_and_versions()`)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolving the symbols (`simplify_symbols()`)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the module parameters as per values passed in the args list
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for duplication of symbols (`complete_formation()`)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the sysfs (`mod_sysfs_setup()`)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Freeing the copy in the *load_info* structure (`free_copy()`)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling to the *init* function of the module (`do_init_module()`)
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The unloading process is quite similar to the loading process; the only thing
    different is that there are certain sanity checks to ensure the safe removal of
    the module from kernel without affecting the system stability. A module''s unloading
    is initialized with the call to the *rmmod* utility, which calls the `delete_module()`
    routine, which steps into the underlying system call:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'On invocation, the system call checks whether the caller has the requisite
    permissions, then it checks for any module dependencies. If there are none, the
    module is good to be removed (else, an error is returned). After this, the module
    state is verified (*live)*. Finally, the exit routine of the module is called
    and at last the `free_module()` routine is called:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This call removes the module from the various lists where it was placed during
    loading (sysfs, module list, and so on) to initiate the cleanup. An architecture-specific
    cleanup routine is invoked (can be found in `</linux/arch/<arch>/kernel/module.c>`*)*.
    All dependent modules are iterated and the module is removed from their lists.
    As soon as the cleanup is over, all resources and the memory that was allocated
    to the module are freed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Module data structures
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every module that is deployed in the kernel is as usual represented through
    a descriptor, called `struct module`. Kernel maintains a list of module instances,
    with each representing a specific module in memory:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s now look at some of the key fields of this structure:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '`list`: This is the double linked list that contains all the loaded modules
    in the kernel.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: This specifies the name of the module. This must be an unique name
    as the module is referenced with this name.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state`: This indicates the current state of the module. A module can be in
    either of the states specified in `enum module_state` under *<linux/module.h>*:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: While loading or removing a module, it's important to know its current state;
    for instance, we need not insert an existing module if its state specifies that
    it is already present.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '`syms, crc and num_syms`: These are used to manage symbols that are exported
    by the module code.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '`init`: This is the pointer to a function which is called when the module is
    initialized.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '`arch`: This represents the architecture specific structure which shall be
    populated with architecture-specific data, needed for the modules to run. However,
    this structure mostly remains empty as most architectures do not need any additional
    information.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '`taints`: This is used if the module is tainting the kernel. It could mean
    that the kernel suspects a module to do something harmful or a non-GPL complaint
    code.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '`percpu`: This points to per-CPU data belonging to the module. It is initialized
    at the module load time.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '`source_list and target_list`: This carries details on module dependencies.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`source_list和target_list`：这包含了模块依赖的详细信息。'
- en: '`exit`: This simply is the opposite of init. It points to the function that
    is called to perform the cleanup process of the module. It releases memory held
    by the module and does other cleanup specific tasks.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`exit`：这只是init的相反。它指向调用模块清理过程的函数。它释放模块持有的内存并执行其他清理特定任务。'
- en: Memory layout
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存布局
- en: 'A module''s memory layout is shown through an object, `struct module_layout`,
    defined in *<linux/module.h>*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的内存布局通过*<linux/module.h>*中定义的`struct module_layout`对象显示。
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Summary
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we briefly covered all the core elements of modules, its implications,
    and management details. Our attempt has remained to give you a quick and comprehensive
    view of how kernel facilitates its extensibility through modules. You also understood
    the core data structures that facilitate module management. Kernel's attempt at
    remaining safe and steady in this dynamic environment is also a notable feature.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们简要介绍了模块的所有核心元素，其含义和管理细节。我们的目标是为您提供一个快速和全面的视角，了解内核如何通过模块实现其可扩展性。您还了解了促进模块管理的核心数据结构。内核在这个动态环境中保持安全和稳定的努力也是一个显著的特点。
- en: I really hope this book serves as a means for you to go out there and experiment
    more with Linux kernel!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我真诚地希望这本书能成为您去实验Linux内核的手段！
