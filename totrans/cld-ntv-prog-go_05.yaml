- en: Building a Frontend with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you have built multiple microservices with Go and
    integrated them using both REST web services and asynchronous message queues.
    However, even the most scalable cloud application is only half as useful without
    an interface that your users can easily interact with (unless, of course, offering
    a REST API to your users is your actual product). In order to make the APIs built
    in the previous chapters more tangible, we will now add a web-based frontend to
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: For this, we will leave the world of Go programming for a while and take a short
    side trip to the JavaScript programming world. More precisely, we will take a
    look at the React framework and will use it to build a frontend application for
    the (now almost complete) MyEvents backend.
  prefs: []
  type: TYPE_NORMAL
- en: While building the frontend application, we will also get in touch with many
    components of the incredibly diverse JavaScript ecosystem. For example, we will
    work with the TypeScript compiler in order to be able to program in a type-safe
    way. Also, we will use the Webpack module bundler to easily deploy our JavaScript
    application for easy consumption in all modern web browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Node.js/TypeScript/React development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrapping a new project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Webpack module bundler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a React application with a RESTful backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we will take a short step outside of the Go ecosystem. For
    working with React, you will need a development environment offering Node.js,
    npm, and a TypeScript compiler, which we will set up in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Node.js and TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is a dynamically typed language. Although (like Go) it does have
    a notion of data types, a JavaScript variable can (unlike Go) basically have any
    type at any time. Since we do not want you to start missing the Go compiler and
    Go's type safety during our brief excursion into the JavaScript world, we will
    use TypeScript in this example. TypeScript is a type-safe superset of JavaScript
    that adds static typing and class-based OOP to JavaScript. You can compile TypeScript
    to JavaScript using the TypeScript compiler (or short, *tsc*).
  prefs: []
  type: TYPE_NORMAL
- en: First of all, in addition to your Go runtime, you will need a working Node.js
    runtime set up on your development machine. Take a look at [https://nodejs.org/en/download](https://nodejs.org/en/download)
    to learn how to set up Node.js on your machine. If you are running Linux (or macOS
    using a package manager such as Homebrew), take a look at [https://nodejs.org/en/download/package-manager](https://nodejs.org/en/download/package-manager).
  prefs: []
  type: TYPE_NORMAL
- en: 'After having installed Node.js, continue by installing the TypeScript compiler
    using the **Node Package Manager** (**npm**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will download and install the TypeScript compiler into your system's `PATH`.
    After running the preceding command, you should be able to call tsc on your command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, we will also use the Webpack module bundler. A module bundler
    takes Node.js modules and generates static JavaScript files that can be used in
    a browser environment. You can install Webpack just as you did for the TypeScript
    compiler via npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Initializing the React project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start by creating a new directory for your React frontend application. Next,
    initialize the directory as a new `npm` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `npm init` command will prompt you for a few (more or less), important
    information about your project. In the end, it should generate a `package.json`
    file, which should look roughly like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, our application will have the following directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: Our TypeScript source files will be placed in the `src/` directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compiled JavaScript files will be placed in the `dist/` directory. Since
    we will be using Webpack as a module bundler, our `dist/` directory will most
    likely contain just one file containing the entire compiled source code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The libraries that we will be installing as dependencies via npm will be installed
    into the `node_modules/` directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can now use npm to add dependencies to our project. Let''s start by installing
    the React and ReactDOM packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `@types` packages are needed for the TypeScript compiler. Since React is
    a JavaScript (not TypeScript) library, the TypeScript compiler will need additional
    information about the classes defined by the react library and their method signatures.
    For example, these **typings** might contain information on which parameter types
    are needed for certain functions provided by React and their return types.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need a few development dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: These libraries will be needed by the Webpack module bundler to compile our
    source files to JavaScript files. However, we will need these dependencies only
    for *building* the application, not for actually *running* it. For this reason,
    we declared them as development dependencies using the `--save-dev` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need to configure the TypeScript compiler. For this, create a
    new `tsconfig.json` file in the project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note how we are configuring the TypeScript compiler to load its source files
    from the `src/` directory using the `include` attribute and to save the compiled
    output files to `dist/` using the `outDir` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we will also need to configure the Webpack module bundler by creating
    a `webpack.config.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This file configures Webpack to use the TypeScript loader on all `.ts` and `.tsx`
    files, compile them, and bundle all modules into the `dist/bundle.js` file. Before
    you can actually do that, though, you will need to add some source files to compile.
  prefs: []
  type: TYPE_NORMAL
- en: Before doing that, let's take a look at how React actually works.
  prefs: []
  type: TYPE_NORMAL
- en: Basic React principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A React application is built from **Components**. A component is a JavaScript
    class that accepts a set of values (called properties, or in short, *props*) and
    returns a tree of DOM elements that can be rendered by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following easy example. We will start with the plain JavaScript
    implementation and show you how to add static typing using TypeScript later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if you are used to JavaScript, the syntax will probably seem new to you.
    Technically, the preceding code example is not plain JavaScript (any browser would
    refuse to actually run this code), but **JSX**. JSX is a special syntax extension
    to JavaScript that allows you to directly define DOM elements using their respective
    HTML representation. This makes defining React components much easier. Without
    using JSX, the preceding code example will need to be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Of course, for actually running the JSX source code in the browser, it needs
    to be transformed to plain old JavaScript first. This will be done by the Webpack
    module bundler when actually building the application.
  prefs: []
  type: TYPE_NORMAL
- en: There's also a TypeScript variant of JSX, called **TSX**. It works exactly the
    same way, but with static typing. When building a React component with TypeScript,
    you also have the possibility to define an interface for the component props.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is actually a Go book, it is important to note that TypeScript interfaces
    are a very different thing compared to Go interfaces. While a Go interface describes
    a set of methods that a struct needs to implement, a TypeScript interface defines
    properties and/or methods that an object needs to have.
  prefs: []
  type: TYPE_NORMAL
- en: 'To associate a React component with a props interface, the `React.Component`
    class has a type parameter that you can specify when extending the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Components can be nested into each other. For example, you can now reuse the
    `HelloWorld` component from earlier in another component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: One advantage of using TypeScript is that when you are using a component whose
    props are defined via an interface, the TypeScript compiler checks whether you
    are actually providing the component with the correct props. For example, omitting
    the `name` prop in the preceding example (or passing it another value than a string)
    will trigger a compile error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The props passed to a React component are treated as immutable. This means
    that the component will not re-render when one of the prop''s values is changed.
    However, each React component may have an internal state, which can be updated.
    Every time a component''s state is changed, it will be re-rendered. Consider the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now update this state whenever we want using the component''s `setState()`
    method. For example, we can have a timer increment the counter every second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Changing the component's state will cause it to be re-rendered. In the preceding
    example, this would cause the counter to visibly increment by 1 every second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we can also combine props and state. One common use case is to use
    the props that are passed into a component to initialize that component''s state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Armed with the knowledge about React components, we can now start building the
    frontend for our MyEvents platform.
  prefs: []
  type: TYPE_NORMAL
- en: Kick-starting the MyEvents frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start by building a simple React application that gets the list of available
    events from the server and displays it as a simple list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before getting started, we will need to bootstrap our React application. For
    this, we will need to build an `index.html` file that can serve as the entry point
    of our application. Typically, this file will not be long, since most of its logic
    will be living in the form of React components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a more detailed look at this HTML file. The `DIV` with the `myevents-app`
    ID will later be the location at which our React application will be rendered.
    Most of the file then consists of loading the React libraries from the respective
    npm packages and loading our actual application bundle (which will be built by
    Webpack).
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our application a bit nicer to look at, we will also add the Twitter
    Bootstrap framework to our frontend. As usual, you can use `npm` to install Bootstrap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing Bootstrap, you can include the respective CSS file in the header
    section of your `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To get started, let''s now add a new React component. For this, create the `src/components/hello.tsx`
    file in your project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual entry point of our React application will be placed in the `src/index.tsx` file.
    You may remember that this was also the file that we have specified as the entry
    point for the Webpack module bundler in the `webpack.config.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at the `className` attribute in the preceding code example. When
    working with plain HTML elements in JSX or TSX, you will need to use `className`
    instead of `class`. This is because `class` is a reserved keyword in both JavaScript
    and TypeScript, so using just `class` would seriously confuse the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'After having created all these files, you can now run the Webpack bundler to
    create your `bundle.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'While in development, you can also have the Webpack bundler running continuously,
    updating your `bundle.js` file whenever one of the source files changes. Just
    leave the started process running in a shell window in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now open the `index.html` file in your browser. However, directly opening
    local files in your browser will cause issues later when making HTTP requests
    to our backend services. You can use the `http-server` npm''s package to quickly
    set up an HTTP server that can serve these local files. Simply install it via
    `npm` and then run it in your project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The Node.js HTTP server will listen at the TCP port `8080` by default, so you
    can access it by navigating to `http://localhost:8080` in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66fc2cd7-4f3f-41fe-9c4e-9b06844fbc75.png)'
  prefs: []
  type: TYPE_IMG
- en: output (http://localhost:8080)
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have just built your first React application. Of course,
    for the MyEvents platform, we will need a bit more than Hello World! One of our
    first tasks will be loading the available events from the backend service and
    displaying them in an aesthetically pleasing manner.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the event list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To display a list of available events, we will need a solution for loading these
    events from the backend service, more precisely, the event service's REST API
    that you have built in [Chapter 2](def2621c-74c4-4f60-a37a-b0b2f86c6339.xhtml),
    *Building Microservices Using Rest APIs*, and [Chapter 3](9c1db13f-619b-43a7-96a1-c6fc65e13b67.xhtml),
    *Securing Microservices*.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing your own client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React is a modular Framework. Unlike other JavaScript frontend frameworks such
    as Angular, React does not ship its own library for REST calls, but instead expects
    you to bring your own. To load data from the server, we will use the fetch API.
    The fetch API is a newer JavaScript API for doing AJAX calls to backend services
    that are implemented in many modern browsers (primarily, Firefox and Chrome).
    For older browsers that do not yet implement the fetch API, there is a `polyfill`
    library that you can add to your application via `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to include these two `polyfill` libraries in your `index.html`
    file alongside the other JavaScript libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The fetch `polyfill` library will use the browser's fetch API when it is available,
    and provide its own implementation when it's not available. In a few years, when
    more browsers support the fetch API, you will be safely able to remove the `polyfill`.
  prefs: []
  type: TYPE_NORMAL
- en: Building the event list components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now think about which React components we will need for our event list.
    The following diagram shows an overview of the components that we will be building:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f475ad6-376b-4108-8f95-131ae2ba5c34.png)'
  prefs: []
  type: TYPE_IMG
- en: An overview of the components that the event list will be built of
  prefs: []
  type: TYPE_NORMAL
- en: 'These components will have the following responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: The `EventListContainer` component will be responsible for loading the event
    list from the backend service and managing the event list in its own state. It
    will then pass the current set of events down to the props of the `EventList`
    component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `EventList` component will be responsible for rendering the container in
    which the event list will be presented. For starters, we will choose a simple
    table view. This table will then be filled with a set of `EventListItem`, one
    for each event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `EventListItem` component will render a single Event item in the event list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technically, we could make the `EventList` component do both—load the events
    from the backend service and manage the event list presentation. However, this
    would violate the **single-responsibility principle**; that's why we have two
    components—one that loads events and passes them to another, and one that presents
    them to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by telling the TypeScript compiler how an Event actually looks
    like. To do this, we will define a TypeScript interface that describes the JSON
    responses that are delivered by the backend service when `GET` is used for getting
    the URL `/events`. Create a new `./src/models/event.ts` file with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note how closely this interface definition corresponds with the `persistence.Event`
    struct that was defined in the event service's code. In order for frontend and
    backend to work well together, these two definitions will need to be kept in sync
    when they change.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now continue to build the React components. We will start bottom-up
    by implementing the `EventListItem`. For this, create a new `src/components/event_list_item.tsx` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define the `EventList` component in the `src/components/event_list.tsx` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note how the `EventList` component uses JavaScript's native `map` function to
    convert an array of Event objects to a list of `EventListItem` (with that event
    passed as a prop) very easily. The list of `EventListItem` is then inserted into
    the body of the table created by the `EventList` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, we can build the `EventListContainer` component. Within
    this component, we will use the fetch API to load the events from the server.
    First, let''s implement the definitions for the `EventListContainer` props and
    state in the `src/components/event_list_container.tsx` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can implement the actual component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, we will first initialize the component's state. Here, it
    is important to remember that HTTP operations in JavaScript are usually asynchronous.
    Although we are calling the `fetch` function in the constructor, the JavaScript
    runtime will execute this HTTP request asynchronously and the component will be
    created even when no data has been loaded (yet). For this reason, our component
    state includes a boolean property named `loading` that indicates whether the data
    is still loading. Later, the component can adjust its presentation based on this
    state attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The `fetch` method returns a promise. A promise is a placeholder for a value
    that is not yet available. You can use the `then(...)` function on a promise instance
    to run code as soon as the promised value becomes available. You can also chain
    promise; in this case, the `fetch` function returns a promise for an HTTP response
    (that is, an instance of the `Response` class). This class in itself has a `json()`
    function that itself returns another promise for the JSON-decoded value. When
    a function passed to a `then(...)` call returns another promise, the returned
    promise will replace the original promise. This means that we can add another
    `then()` call to the chain that will be called when the HTTP response is available
    and was successfully JSON-decoded. When that happens, we will update the component's
    state, indicating that the component is no longer loading, and the `events` property
    containing the actual event list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, finish the `EventListContainer` component by adding a `render()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to actually display the event list on our page, you can now use the
    `EventListContainer` in the `index.tsx` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, it is also considered a good practice to build a root component
    that can serve as a single point of entry into the application. We can extract
    the DOM elements from the `ReactDOM.render` call into its own component and then
    use that in the `ReactDOM.render` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Enabling CORS in the backend services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before testing the frontend application, you will need to make sure that the
    backend services (more precisely, both the event service and the booking service)
    support **Cross-Origin Resource Sharing** (**CORS**). Otherwise, your browser
    will not execute HTTP requests to any of your backend services, when the frontend
    is served on `http://localhost:8080` and the backend services run on other TCP
    ports.
  prefs: []
  type: TYPE_NORMAL
- en: 'In principle, CORS consists of nothing more than a few additional headers that
    need to be present in the HTTP response. For example, to allow AJAX requests from
    another domain, the HTTP response needs to contain an `Access-Control-Allow-Origin`
    header. An HTTP response with such a header might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are using the Gorilla toolkit in both the event and booking service,
    adding the CORS functionality is easy. First, we will need to go get the `github.com/gorilla/handlers`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can use the `handlers.CORS` function to add the CORS functionality
    to an existing HTTP server. This allows us to adjust the event service''s `rest.go`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Adjust the booking service the same way. After that, you will be able to talk
    to both services from the frontend application without any issues.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the event list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to test your application, make sure that you have an instance of the
    event service running locally and listening on TCP port `8181`. Also, ensure that
    you have already created one or two events using the event service''s REST API.
    Then, start the Node.js `http-server` in your frontend application directory and
    navigate to `http://localhost:8080` in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df05a321-6a76-4287-a1a8-57f641e80d96.png)'
  prefs: []
  type: TYPE_IMG
- en: output (http://localhost:8080)
  prefs: []
  type: TYPE_NORMAL
- en: Adding routing and navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we add more functionalities to our frontend application, let's take the
    time to add a robust navigation and routing layer. This will allow our application
    to stay easily maintainable when more features are added.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for our application to support multiple application views, we will
    first add the `react-router-dom` package to our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `react-router-dom` package adds a few new components to our application.
    We can use these in our root component to easily implement routing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note how the `<Route>` component is used within the container; at this point,
    we can later add multiple `Route` components and the React router will render
    these components depending on the current URL. This allows our application to
    lead the user from one view to another using plain, old links.
  prefs: []
  type: TYPE_NORMAL
- en: Note the `eventList` constant that is being declared in the preceding `render()`
    method. This is because the `Route` component accepts a `component` prop, which
    refers to a component or a function that will be called whenever this `Route`
    is matched. However, we cannot specify props that should be passed to the respective
    component. This is why we are declaring a function that initializes the `EventListContainer`
    component with default props, allowing it to be used in the `Route` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a working routing layer; let''s make sure that our users will
    always find their way back to the event list. For this, we will add a new navigation
    bar component that we can use in our root component. Create a new `src/components/navigation.tsx`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add a `render()` method to the new component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note how our `Navigation` component uses the `Link` component to create links
    to other React routes, which is admittedly not that complicated yet, given that
    we only have the `/` route for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually use our new navigation component, add it to the root component''s
    `render` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the booking process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a working routing and navigation in place, we can implement
    the next piece of functionality—the booking process. For the purpose of this book,
    we will keep the booking process simple. Each line in the events list that we
    implemented earlier should get a button that takes the user to the booking form.
    In this form, they will be prompted for the number of tickets they want to book
    and can then submit the form. On submitting, the frontend application will perform
    an HTTP request to the booking service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we will implement the booking form as a React component. Just as
    before, we will keep responsibilities separated and build separate components
    to handle the backend communication and frontend presentation. The `EventBookingFormContainer`
    will be responsible for loading the event record from the event service and saving
    the actual booking back to the booking service. The `EventBookingForm` will then
    be responsible for the actual frontend presentation of the form. In order to make
    the form presentation easier, we will also introduce a `FormRow` component. The
    following diagram gives an overview of these components and how they relate to
    each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da695a1f-2970-4f7b-99de-cf52a8f9de57.png)'
  prefs: []
  type: TYPE_IMG
- en: Relation between components
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FormRow` component will be a purely presentational component to make the
    Bootstrap framework''s form CSS classes easier to use. As before, we will implement
    these components bottom-up, starting with the innermost component. For this, create
    the `src/components/form_row.tsx` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we are using the special prop `children`. Although we did not
    explicitly define this prop in the `FormRowProps` interface, we can use the `children`
    prop in any React component. It will contain any DOM elements that were passed
    as child elements into the current component. This will allow you to use the `FormRow`
    component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can use the `FormRow` component to build the `EventBookingForm` component.
    For this, create a new file, called `src/components/event_booking_form.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `EventBookingForm` component has both input props and an internal state.
    The input properties contain the actual event, for which the booking form should
    be rendered, and a callback method. We will later configure the booking form to
    call this callback method whenever the form is submitted. The form's internal
    state contains a variable for the number of tickets that should be booked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add a `render()` method to the `EventBookingForm` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This will generate a small form in which the user will be able to review which
    event they are booking tickets for, select the desired amount of tickets, and
    then submit the order. Note how the `onSubmit` prop is called on the button's
    `onClick` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that the select field''s `onChange` event calls a `this.handleNewAmount` method,
    which we have not defined yet. Let''s do this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Last but not least, we can now implement the `EventBookingFormContainer` component.
    This component will be responsible for handling the AJAX communication to the
    respective backend services (since we are working with event bookings, we will
    also have to communicate with the booking service that we built in [Chapter 4](0a806398-0654-46f9-8e6f-02af9334821b.xhtml),
    *Asynchronous Microservice Architectures Using Message Queues*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining the component''s props and state. For this, create
    a new `src/components/event_booking_form_container.tsx` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `EventBookingFormContainer` will need to make AJAX calls to both the event
    service and the booking service. When a new instance of this component is created,
    it will be passed an event ID via its properties, and then use that ID to load
    the respective event's data from the event service into the component's state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading the event data is something that we can do in the component''s constructor
    function that we will define next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add a `render` method to this component that presents the actual
    booking form as soon as the event has been loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This `render()` method basically covers all possible variants of the component's
    state and then prints the respective status messages. When an event has successfully
    been loaded, the actual `EventBookingForm` is presented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will need to implement the `handleSubmit` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This concludes our work on the booking form. Up until now, we have missed just
    one little thing—there is no way to access this form yet. Let's now amend this
    oversight.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding a new route to the `index.tsx` file, more precisely, in the
    `App` component''s `render` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In this code example, you can see multiple things. First, we are declaring a
    new local component `eventBooking`, which basically returns an `EventBookingFormContainer`
    component with some default parameters. This component will be passed a prop object
    with a `match` attribute (the curly brackets in the parameter declaration are
    a so-called **destructuring assignment**). This match object contains the route
    parameters from the `/events/:id/book` route that was declared in the previous
    example. This allows us to include an event ID as a route parameter (so, for example,
    `localhost:8080/#/events/58d543209cdd4128c06e59db/book`).
  prefs: []
  type: TYPE_NORMAL
- en: Also, for this code to work, we are assuming that you have an instance of the
    booking service from [Chapter 4](0a806398-0654-46f9-8e6f-02af9334821b.xhtml),
    *Asynchronous Microservice Architectures Using Message Queues*, running and listening
    on localhost TCP port `8282`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we need to add a button that allows the user to actually reach this
    route. For this, we will modify the `EventListItem` component in the `src/component/event_list_item.tsx`
    file that you have created in an earlier section of this chapter. We will use
    the `Link` component from the `react-router-dom` package that you have worked
    with before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In your frontend application, you will now see an additional button labeled
    Book now!:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4be3b4b9-3be5-412e-a5c8-484e30221a82.png)'
  prefs: []
  type: TYPE_IMG
- en: Book now! button
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EventistItem` components in the event list now contain a link to each
    event''s booking form. Upon clicking one of these buttons, the application will
    link you to the respective event''s actual booking form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd606b09-37e8-4d93-958e-f6eb9d91e2a1.png)'
  prefs: []
  type: TYPE_IMG
- en: The EventBookingForm in action
  prefs: []
  type: TYPE_NORMAL
- en: Note the URL containing the event ID. Since we have built `EventBookingFormContainer`
    to load the event data from the event service when it is constructed, we can now
    even use this URL and open it directly in a browser. The React router will open
    the booking form immediately and then load the event's data from the event service.
    This allows you to open subroutes in React applications directly and even share
    or bookmark these URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have given you a glimpse into frontend development with
    React. Of course, we have only scratched the surface of what is possible with
    the React framework. In an actual real-world application, we would still need
    to add quite a lot of features for the frontend application to be actually complete
    (for example, we would need to add some trivial things, such as a user sign-up
    and a more sophisticated checkout process).
  prefs: []
  type: TYPE_NORMAL
- en: Up until now, we have spent most of our time doing actual programming, both
    in the backend with Go and in the frontend with TypeScript. However, there is
    more to do with software development than just programming. Over the next few
    chapters, we will concern ourselves with the deployment of our application. This
    will include both the backend services (such as the Event and booking services
    built in previous chapters), but also persistence and messaging services (such
    as databases or message queues). For this, we will take a look at modern container
    technologies and how to deploy these to the cloud. Stay tuned.
  prefs: []
  type: TYPE_NORMAL
