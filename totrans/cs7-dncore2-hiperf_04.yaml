- en: Data Structures and Writing Optimized Code in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data structures are a particular way of storing data in software engineering.
    They play a vital role in storing data in a computer so that it can be accessed
    and modified efficiently, and they provide different storing mechanisms for storing
    different types of data. There are many types of data structure, and each one
    is designed to store a definite type of data. In this chapter, we will cover data
    structures in detail and learn which data structures should be used for particular
    scenarios in order to improve the performance of the system as regards data storage
    and retrieval. We will also learn how we can write optimized code in C# and what
    primary factors can affect performance, which is sometimes overlooked by developers
    when coding programs. We will learn some best practices that can be used to optimize
    code that is performance effective.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What data structures are and their characteristics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the right data structure for performance optimizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the use of Big O notation to measure the performance and complexity
    of a program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices when writing code in .NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are data structures?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A data structure is a way of storing and unifying data in such a way that operations
    on that data can be performed in an efficient manner. The data can be stored in
    several ways. For example, we can have a `Person` object that contains a few properties,
    such as `PersonID` and `PersonName`, where `PersonID` is of the integer type and
    `PersonName` is of the *string *type. This `Person` object stores the data in
    memory, and can be further used to save that record in the database. Another example
    is an array called `Countries` of the `string` type that contains a list of countries.
    We can use the `Countries` array to retrieve a country name and use it in a program.
    Therefore, any type of object that stores data is called a data structure. All
    primitive types, such as integers, strings, chars, and Booleans, are different
    types of data structure, whereas other collection types, such as `LinkedList`,
    `ArrayList`, `SortedList`, and others, are also types of data structure that can
    store information in exclusive ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the types of data structures and their relationship
    to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are two types of data structure: *primitive* and *nonprimitive* types.
    Primitive types are value types that include s*igned integral*, *unsigned integral*,
    *unicode characters*, *IEEE floating point*, *high-precision decimal*, *Boolean*,
    *enum*, *struct* and *nullable* value types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of the primitive data types available in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Primitive types** |'
  prefs: []
  type: TYPE_TB
- en: '| Signed integral | `sbyte`, `short`, `int`, `long` |'
  prefs: []
  type: TYPE_TB
- en: '| Unsigned integral | `byte`, `ushort`, `uint`, `ulong` |'
  prefs: []
  type: TYPE_TB
- en: '| Unicode characters | `Char` |'
  prefs: []
  type: TYPE_TB
- en: '| IEEE floating point | `float`, `double` |'
  prefs: []
  type: TYPE_TB
- en: '| High-precision decimal | `Decimal` |'
  prefs: []
  type: TYPE_TB
- en: '| Boolean | `Bool` |'
  prefs: []
  type: TYPE_TB
- en: '| String | `String` |'
  prefs: []
  type: TYPE_TB
- en: '| Object | `System.Object` |'
  prefs: []
  type: TYPE_TB
- en: Nonprimitive types are user-defined types, and further categorized as linear
    or nonlinear types. In a linear data structure, the elements are organized in
    a sequence, such as in *Array*, *Linked List*, and other related types, whereas
    in a nonlinear data structure, the elements are stored without any sequence, such
    as in *trees* and *graphs.*
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the types of linear and nonlinear classes available
    in .NET Core:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Nonprimitive types - linear data structures** |'
  prefs: []
  type: TYPE_TB
- en: '| Array | `ArrayList`, `String[]`, `primitive typed arrays`, `List`, `Dictionary`,
    `Hashtable`, `BitArray` |'
  prefs: []
  type: TYPE_TB
- en: '| Stack | `Stack<T>`, `SortedSet<T>`, `SynchronizedCollection<T>` |'
  prefs: []
  type: TYPE_TB
- en: '| Queue | `Queue<T>` |'
  prefs: []
  type: TYPE_TB
- en: '| Linked list | `LinkedList<T>` |'
  prefs: []
  type: TYPE_TB
- en: .NET Core does not provide any nonprimitive, nonlinear types to represent data
    in tree or graph formats. However, we can develop custom classes to support these
    kinds of types.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is the code to write a custom tree that stores data in the
    tree format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can write a program to populate a tree view on the console window
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the preceding program, it generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00046.gif)'
  prefs: []
  type: TYPE_IMG
- en: Understanding the use of Big O notation to measure the performance and complexity
    of an algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Big O notation is used to define the complexity and performance of an algorithm
    with respect to time or space consumed during execution. It is an essential technique
    to express the performance of an algorithm and determine the worst-case complexity
    of the program.
  prefs: []
  type: TYPE_NORMAL
- en: To understand it in detail, let's go through some code examples and use Big
    O notation to calculate their performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we calculate the complexity of the following program, the Big O notation
    will be equal to *O(1)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is because, however the parameter is specified, it is just adding and returning
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider another program that loops through the list. The Big O notation
    will be determined as *O(N)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the program is looping through the item list and comparing
    the value passed as a parameter with each item in the list. If the item is found,
    the program returns `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The complexity is determined as *O(N)* because the worst-case scenario could
    be a loop towards *N* items where *N* could be either a first index or any index
    until it reaches the last index, which is *N*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at an example of the *selection sort*, which is defined as
    *O(N2)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have two loops that are nested. The first loop
    traverses from `0` to the last index, whereas the second loop traverses from the
    next item to the penultimate item and swaps the values to sort the array in ascending
    order. The number of nested loops is directly proportional to the power of *N*,
    hence the Big O notation is defined as *O(N2)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s consider a recursive function where the Big O notation is defined
    as *O(2N),* where *2N* determines the time taken, which doubles with each additional
    element in the input dataset that runs for an exponential period of time. Here
    is an example of a `Fibonacci_Recursive` method that recursively calls the method
    until the counter becomes equal to the maximum number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Logarithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A logarithm operation is the complete opposite of an exponential operation.
    The logarithm is a  quantity representing the power to which a base number must
    be raised to produce a given number.
  prefs: []
  type: TYPE_NORMAL
- en: For example, *2x = 32*, where *x=5*, can be represented as *log2 32 =5*.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the logarithm of above expression is 5 that represents the power
    of a fixed number 2 which is raised to produce a given number 32.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a binary search algorithm that works more effectively by splitting
    the list of an item into two datasets and uses a specific dataset based on the
    number. For example, say that I have a list of different numbers sorted in ascending
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '*{1, 5, 6, 10, 15, 17, 20, 42, 55, 60, 67, 80, 100}*'
  prefs: []
  type: TYPE_NORMAL
- en: Say that we want to find number *55*. One way to do this is to loop through
    each index and check each item one by one. The more effective way is to split
    the list into two sets and check whether the number I am looking for is greater
    than the last item of the first dataset or to use the second dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a binary search whose Big O notation will be determined
    as *O(LogN)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Choosing the right data structure for performance optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A data structure is a precise way of organizing data in a computer program.
    If data is not efficiently stored in the right data structure, it may lead to
    some performance issues that impact the overall experience of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will learn the advantages and disadvantages of the different
    collection types available in .NET Core and which ones are the better types for
    particular scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays and lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stacks and queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LinkedLists (single, double, and circular)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionaries, hashtables, and hashsets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An array is a collection that holds similar types of elements. Arrays of both
    value types and reference types can be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are few circumstances where arrays are useful:'
  prefs: []
  type: TYPE_NORMAL
- en: If the data is of a fixed, set length, using an array is a better option as
    it is faster than other collections, such as `arraylists` and generic lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays are good to represent data in a multidimensional way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They take less memory compared to other collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With arrays, we can iterate through elements sequentially
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table shows the Big O notation for each operation that can be
    performed in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operations** | **Big O notation** |'
  prefs: []
  type: TYPE_TB
- en: '| Access by Index | *O(1)* |'
  prefs: []
  type: TYPE_TB
- en: '| Search | *O(n)* |'
  prefs: []
  type: TYPE_TB
- en: '| Insert at the end | *O(n)* |'
  prefs: []
  type: TYPE_TB
- en: '| Remove at the end | *O(n)* |'
  prefs: []
  type: TYPE_TB
- en: '| Insert at a position before the last element | *O(n)* |'
  prefs: []
  type: TYPE_TB
- en: '| Remove an element at an index | *O(1)* |'
  prefs: []
  type: TYPE_TB
- en: As shown in the preceding table, the search for and insertion of an item in
    a specific position degrades performance, whereas accessing any item in an index
    or removing it from any position has a lower impact on performance.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lists are extensively used by .NET developers. Although it is preferable to
    use it in many scenarios, there are some performance limitations, too.
  prefs: []
  type: TYPE_NORMAL
- en: Using lists is mostly advisable when you want to access the item using its index.
    Unlike a linked list, where you have to iterate over each node using an enumerator
    to search for the item, with a list, we can easily access it using an index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are few recommendations where lists are useful:'
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that you use list when the collection size is not known. Resizing
    arrays is an expensive operation, and with lists we can easily grow the size of
    the collection by just adding to it as needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike arrays, lists do not reserve the total memory address space for the number
    of items when it is created. This is because, with lists, specifying the size
    of the collection is not needed. On the other hand, arrays depend on the type
    and the size at which it is initialized, and reserve the address space during
    initialization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With lists, we can use lambda expressions to filter out records, sort items
    in descending order, and execute other operations. Arrays do not provide sorting,
    filtering, or other such operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists represent a single dimension collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table shows the Big O notation for each operation that can be
    performed on lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operations** | **Big O notation** |'
  prefs: []
  type: TYPE_TB
- en: '| Access by index | *O(1)* |'
  prefs: []
  type: TYPE_TB
- en: '| Search | *O(n)* |'
  prefs: []
  type: TYPE_TB
- en: '| Insert at the end | *O(1)* |'
  prefs: []
  type: TYPE_TB
- en: '| Remove from the end | *O(1)* |'
  prefs: []
  type: TYPE_TB
- en: '| Insert at a position before the last element | *O(n)* |'
  prefs: []
  type: TYPE_TB
- en: '| Remove an element at an index | *O(n)* |'
  prefs: []
  type: TYPE_TB
- en: Stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Stacks maintain a collection of items in **Last In First Out** (**LIFO**) order.
    The last item to be inserted is retrieved first. Only two operations are allowed
    on stacks, namely `push` and `pop`. The real application of a stack is an `undo`
    operation that inserts the changes into the stack and, on undoing, removes the
    last action that was performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram illustrates how the items are added to the stack. The
    last inserted item pops out first, and to access the first item that was inserted,
    we have to pop out each element until it reaches the first one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few of the circumstance where stacks are useful:'
  prefs: []
  type: TYPE_NORMAL
- en: Scenarios where the item should be removed when its value is accessed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where an `undo` operation needs to be implemented in a program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To maintain navigation history on a web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursive operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table shows the Big O notation for each operation that can be
    performed on stacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operations** | **Big O notation** |'
  prefs: []
  type: TYPE_TB
- en: '| Access to the first object | *O(1)* |'
  prefs: []
  type: TYPE_TB
- en: '| Search | *O(n)* |'
  prefs: []
  type: TYPE_TB
- en: '| Push item | *O(1)* |'
  prefs: []
  type: TYPE_TB
- en: '| Pop item | *O(1)* |'
  prefs: []
  type: TYPE_TB
- en: Queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Queues maintain a collection of items in a **First In First Out** (**FIFO**)
    order. The item inserted into the queue first is retrieved first from the queue.
    Only three operations are allowed in queues, namely `Enqueue`, `Dequeue`, and
    `Peek`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Enqueue` adds an element to the end of the queue, whereas `Dequeue` removes
    the element from the start of the queue. `Peek` returns the oldest elements in
    the queue but does not remove them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00048.gif)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram illustrates how items are added to the queue. The item
    inserted first will be removed first from the queue and the pointer moves to the
    next item in the queue. `Peek` always returns the first item that was inserted or
    the item to which the pointer is set, based on whether the first item is removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the circumstances where queues are useful:'
  prefs: []
  type: TYPE_NORMAL
- en: To process items in a sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To serve an order based on a first-come-first-served basis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table shows the Big O notation for each operation that can be
    performed on queues:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operations** | **Big O notation** |'
  prefs: []
  type: TYPE_TB
- en: '| Access to the first object inserted | *O(1)* |'
  prefs: []
  type: TYPE_TB
- en: '| Search | *O(n)* |'
  prefs: []
  type: TYPE_TB
- en: '| Queue item | *O(1)* |'
  prefs: []
  type: TYPE_TB
- en: '| Enqueue item | *O(1)* |'
  prefs: []
  type: TYPE_TB
- en: '| Peek item | *O(1)* |'
  prefs: []
  type: TYPE_TB
- en: Linked lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The linked list is a linear data structure where each node in the list contains
    the reference pointer to the next node, and the last node has a reference to null.
    The first node is known as the head. There are three types of linked list, known
    as *singly*, *doubly*, and *circular* linked lists.
  prefs: []
  type: TYPE_NORMAL
- en: Singly linked lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Singly linked lists contain only the reference to the next node. The following
    diagram represents the singly linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00049.gif)'
  prefs: []
  type: TYPE_IMG
- en: Doubly linked lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In doubly linked lists, the nodes contain the references of both the next node
    and the previous node. The user can iterate forward and backward using reference
    pointers. The following image is a representation of a doubly linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00050.gif)'
  prefs: []
  type: TYPE_IMG
- en: Circular linked lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In circular linked lists, the last node points back to the first node. Here
    is a representation of a circular linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00051.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are a few circumstances where a linked list is useful:'
  prefs: []
  type: TYPE_NORMAL
- en: To provide access to an item in a sequential manner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insert an item in any position of the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove any item at any point or node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you need to consume less memory, as there is no array copy in the linked
    list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table shows the Big O notation value for each operation that
    can be performed on linked lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operations** | **Big O notation** |'
  prefs: []
  type: TYPE_TB
- en: '| Access the item | *O(1)* |'
  prefs: []
  type: TYPE_TB
- en: '| Search for the item | *O(n)* |'
  prefs: []
  type: TYPE_TB
- en: '| Insert item | *O(1)* |'
  prefs: []
  type: TYPE_TB
- en: '| Delete item | *O(1)* |'
  prefs: []
  type: TYPE_TB
- en: Dictionaries, hashtables, and hashsets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dictionary, hashtable, and hashset objects store items in key—value format.
    However, hashsets and dictionaries are good for scenarios where performance is
    key. Here are a few circumstances where these types are useful:'
  prefs: []
  type: TYPE_NORMAL
- en: To store an item in key–value format that can be retrieved based on a particular
    key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To store unique values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table shows the Big O notation value for each operation that
    can be performed on these objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operations** | **Big O notation** |'
  prefs: []
  type: TYPE_TB
- en: '| Access | *O(n)* |'
  prefs: []
  type: TYPE_TB
- en: '| Search for the value if the key is not known | *O(n)* |'
  prefs: []
  type: TYPE_TB
- en: '| Insert item | *O(n)* |'
  prefs: []
  type: TYPE_TB
- en: '| Delete item | *O(n)* |'
  prefs: []
  type: TYPE_TB
- en: Generic lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The generic list is a strongly typed list of elements that is accessed using
    an index. In contrast to arrays, generic lists are expandable, and the list can
    grow dynamically; for this reason, they are known as dynamics arrays or vectors.
    Unlike arrays, generic lists are one dimensional, and are one of the best options
    for manipulating an in-memory collection of elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a generic list as shown in the following code example. The code
    phrase `lstNumbers` allows only integer values to be stored, the phrase `lstNames`
    stores the `only` string, `personLst` stores `Person` objects, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table shows the Big O notation value for each operation that
    can be performed on these objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operations** | **Big O notation**                                     
        |'
  prefs: []
  type: TYPE_TB
- en: '| Access by index | *O(1)* |'
  prefs: []
  type: TYPE_TB
- en: '| Search | *O(n)* |'
  prefs: []
  type: TYPE_TB
- en: '| Insert at the end | *O(1)* |'
  prefs: []
  type: TYPE_TB
- en: '| Remove from the end | *O(1)* |'
  prefs: []
  type: TYPE_TB
- en: '| Insert at a position before the last element | *O(n)* |'
  prefs: []
  type: TYPE_TB
- en: '| Remove an element at an index | *O(n)* |'
  prefs: []
  type: TYPE_TB
- en: Best practices in writing optimized code in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many factors that negatively impact the performance of a .NET Core
    application. Sometimes these are minor things that were not considered earlier
    at the time of writing the code, and are not addressed by the accepted best practices.
    As a result, to solve these problems, programmers often resort to ad hoc solutions.
    However, when bad practices are combined together, they produce performance issues.
    It is always better to know the best practices that help developers write cleaner
    code and make the application performant.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will learn, the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Boxing and unboxing overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String concatenation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for` versus `foreach`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delegates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boxing and unboxing overhead
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The boxing and unboxing methods are not always good to use and they negatively
    impact the performance of mission-critical applications. Boxing is a method of
    converting a value type to an object type, and is done implicitly, whereas unboxing
    is a method of converting an object type back to a value type and requires explicit
    casting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through an example where we have two methods executing a loop of
    10 million records, and in each iteration, they are incrementing the counter by
    1\. The `AvoidBoxingUnboxing` method is using a primitive integer to initialize
    and increment it on each iteration, whereas the `BoxingUnboxing` method is boxing
    by assigning the numeric value to the object type first and then unboxing it on
    each iteration to convert it back to the integer type, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run both methods, we will clearly see the differences in performance.
    The `BoxingUnboxing` is executed seven times slower than the `AvoidBoxingUnboxing`
    method, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00052.gif)'
  prefs: []
  type: TYPE_IMG
- en: For mission-critical applications, it's always better to avoid boxing and unboxing.
    However, in .NET Core, we have many other types that internally use objects and
    perform boxing and unboxing. Most of the types under `System.Collections` and
    `System.Collections.Specialized` use objects and object arrays for internal storage,
    and when we store primitive types in these collections, they perform boxing and
    convert each primitive value to an object type, adding extra overhead and negatively
    impacting the performance of the application. Other types of `System.Data`, namely
    `DateSet`, `DataTable`, and `DataRow`, also use object arrays under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Types under the `System.Collections.Generic` namespace or typed arrays are the
    best approaches to use when performance is the primary concern. For example, `HashSet<T>`,
    `LinkedList<T>`, and `List<T>` are all types of generic collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is a program that stores the integer value in `ArrayList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write another program that uses a generic list of the integer type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When running both programs, the differences are pretty noticeable. The code
    with the generic list `List<int>` is over 10 times faster than the code with `ArrayList`.
    The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00053.gif)'
  prefs: []
  type: TYPE_IMG
- en: String concatenation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In .NET, strings are immutable objects. Two strings refer to the same memory
    on the heap until the string value is changed. If any of the string is changed,
    a new string is created on the heap and is allocated a new memory space. Immutable
    objects are generally thread safe and eliminate the race conditions between multiple
    threads. Any change in the string value creates and allocates a new object in
    memory and avoids producing conflicting scenarios with multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s initialize the string and assign the `Hello World` value to
    the  `a` string variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s assign the  `a` string variable to another variable, `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `a` and `b` point to the same value on the heap, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, suppose we change the value of `b` to `Hope this helps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create another object on the heap, where `a` points to the same and
    `b` refers to the new memory space that contains the new text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.gif)'
  prefs: []
  type: TYPE_IMG
- en: With each change in the string, the object allocates a new memory space. In
    some cases, it may be an overkill scenario, where the frequency of string modification
    is higher and each modification is allocated a separate memory space, creates
    work for the garbage collector in collecting the unused objects and freeing up
    space. In such a scenario, it is highly recommended that you use the `StringBuilder`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Improper handling of exceptions also decreases the performance of an application.
    The following list contains some of the best practices in dealing with exceptions
    in .NET Core:'
  prefs: []
  type: TYPE_NORMAL
- en: Always use a specific exception type or a type that can catch the exception
    for the code you have written in the method. Using the `Exception` type for all
    cases is not a good practice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is always a good practice to use `try`, `catch`, and finally `block` where
    the code can throw exceptions. The final block is usually used to clean up the
    resources, and returns a proper response that the calling code is expecting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In deeply nested code, don't use `try catch` block and handle it to the calling
    method or main method. Catching exceptions on multiple stacks slows down performance
    and is not recommended.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always use exceptions for fatal conditions that terminate the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using exceptions for noncritical conditions, such as converting the value to
    an integer or reading the value from an empty array, is not recommended and should
    be handled through custom logic. For example, converting a string value to the
    integer type can be done by using the `Int32.Parse` method rather than by using
    the `Convert.ToInt32` method and then failing at a point when the string is not
    represented as a digit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While throwing an exception, add a meaningful message so that the user knows
    where that exception has actually occurred rather than going through the stack
    trace. For example, the following code shows a way of throwing an exception and
    adding a custom message based on the method and class being called:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Throw exceptions rather than returning the custom messages or error codes and
    handle it in the main calling method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When logging exceptions, always check the inner exception and read the exception
    message or stack trace. It is helpful, and gives the actual point in the code
    where the error is thrown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For and foreach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For and foreach are two of the alternative ways of iterating over a list of
    items. Each of them operates in a different way. The for loop actually loads all
    the items of the list in memory first and then uses an indexer to iterate over
    each element, whereas foreach uses an enumerator and iterates until it reaches
    the end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the types of collections that are good to use for
    `for` and `foreach`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **For/Foreach** |'
  prefs: []
  type: TYPE_TB
- en: '| Typed array | Good for both |'
  prefs: []
  type: TYPE_TB
- en: '| Array list | Better with for |'
  prefs: []
  type: TYPE_TB
- en: '| Generic collections | Better with for  |'
  prefs: []
  type: TYPE_TB
- en: Delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Delegates are a type in .NET which hold the reference to the method. The type
    is equivalent to the function pointer in C or C++. When defining a delegate, we
    can specify both the parameters that the method can take and its return type.
    This way, the reference methods will have the same signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple delegate that takes a string and returns an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose we have a `LogToConsole` method that has the same signature as
    the one shown in the following code. This method takes the string and writes it
    to the console window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can initialize and use this delegate like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we have another method called `LogToDatabase` that writes the information
    in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the initialization of the new `logDelegate` instance that references
    the `LogToDatabase` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding delegate is the representation of unicast delegates, as each
    instance refers to a single method. On the other hand, we can also create multicast
    delegates by assigning  `LogToDatabase` to the same `LogDelegate` instance, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code seems pretty straightforward and optimized, but under the
    hood, it has a huge performance overhead. In .NET, delegates are implemented by
    a `MutlicastDelegate` class that is optimized to run unicast delegates. It stores
    the reference of the method to the target property and calls the method directly.
    For multicast delegates, it uses the invocation list, which is a generic list,
    and holds the references to each method that is added. With multicast delegates,
    each target property holds the reference to the generic list that contains the
    method and executes in sequence. However, this adds an overhead for multicast
    delegates and takes more time to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned the core concepts about data structures, the
    types of data structures, as well as their advantages and disadvantages, followed
    by the best possible scenarios in which each can be used. We also learned about
    the Big O notation, which is one of the core topics to consider when writing code
    and helps developers to identify code performance. Finally, we looked into some
    best practices and covered topics such as boxing and unboxing, string concatenation,
    exception handling, `for` and `foreach` loops, and delegates.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn some guidelines and best practices that could
    be helpful when designing .NET Core applications.
  prefs: []
  type: TYPE_NORMAL
