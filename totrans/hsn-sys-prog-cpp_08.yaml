- en: Learning to Program File Input/Output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File **input**/**output** (**I/O**) is an essential part of most system-level
    programs. It can be used for debugging, saving program states, handling user-specific
    data, and even interfacing with physical devices (thanks to POSIX block and character
    devices).
  prefs: []
  type: TYPE_NORMAL
- en: Prior to C++17, working with file I/O was difficult, as filesystem management
    had to be handled using non-C++ APIs, which are often unsafe, platform-specific,
    or even incomplete.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will provide a hands-on review of how to open, read, and
    write to files, and work with paths, directories, and the filesystem. We will
    conclude by providing three different examples that demonstrate how to log to
    a file, tail an existing file, and benchmark the C++ file input/output APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Ways to open a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing to a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to compile and execute the examples in this chapter, the reader must
    have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Linux-based system capable of compiling and executing C++17 (for example,
    Ubuntu 17.10+)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GCC 7+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake 3.6+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To download all the code in this chapter, including the examples, and code snippets,
    see the following link: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Opening a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to open a file. We will discuss some of these in the following
    sections, and how to accomplish this using the `std::fstream` C++ APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Different ways to open a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Opening a file in C++ is as simple as providing a `std::fstream` object with
    the filename and path of the object you wish to open. This is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we open a file named `test.txt`, which we previously created
    using the POSIX `touch` command. This file is opened with read/write permissions
    (as that is the default mode).
  prefs: []
  type: TYPE_NORMAL
- en: The file is stored in a variable named `file`, and it is checked to ensure it
    was properly opened using the bool operator overload that `std::fstream` provides.
    If this file is successfully opened, we output `success` to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example leverages the fact that a `std::fstream` object has an
    overloaded `bool` operator that returns true when the file is successfully opened.
    Another way to more explicitly perform this action is to use the `is_open()` function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this preceding example, instead of relying on the `bool` operator overload,
    we leverage C++17 to check whether the file is open using `is_open()` in the `if`
    statement. The preceding examples were further simplified by the use of the constructor
    to initialize the `std::fstream`, instead of explicitly calling `open()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `std::fstream` object is created with the default constructor,
    meaning no file has yet to be opened, allowing us to postpone opening the file
    until we are ready to do so. We then open the file using the `open()` function,
    and then, similar to the preceding example, we leverage C++17 to check to see
    if the file opened prior to outputting `success` to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: In all of the preceding examples, there was no need to call `close()` on the
    file. This is because, like other C++ classes such as `std::unique_ptr` that leverage
    RAII, `std::fstream` objects close the file automatically for you on destruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible, however, to close the file explicitly if so desired, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we open a text file and use `is_open()` to check whether the
    file is open. The first use of `is_open()` returns true, since the file was successfully
    opened. We then close the file explicitly using `close()`, and then check whether
    the file is open again using `is_open()`, which now returns false.
  prefs: []
  type: TYPE_NORMAL
- en: Modes for opening a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up until now, we have opened the file using the default mode. There are two
    modes that may be used to open a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::ios::in`: Opens the file for reading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::ios::out`: Opens the file for writing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, there are several other modes that may be used in conjunction
    with these two, to modify how a file is opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::ios::binary`: Opens the file for binary use. By default, `std::fstream`
    is in text mode, which applies specific rules about how a file is formatted using
    newline characters, and which types of character may be read/written to a file.
    These rules are usually appropriate for text files, but cause problems when you
    attempt to read/write binary data to a file. In this case, `std::ios::binary`
    should be added to your mode specifier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::ios::app`: When this mode is used with `std::ios::out`, all writes to
    the file append to the end of the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::ios::ate`: When this mode is used with either `std::ios::in` or `std::ios::out`,
    the file is positioned at the end of the file once it has been successfully opened.
    That is, reads and writes to the file occur at the end of the file, even right
    after the file is opened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::ios::trunc`: When this mode is used with either `std::ios::in` or `std::ios::out`,
    the contents of the files are deleted prior to opening the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To demonstrate these modes, the first example opens a file for reading in binary
    mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the modes are constant values, and for this reason, in the preceding
    example, `constexpr` is used to create a new constant called `mode` that represents
    opening a file in read-only, binary mode. To open a file for read-only in text
    mode instead of binary mode, simply remove the `std::ios::binary` mode, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we open the file in read-only, text mode. The same
    logic may also be used for write-only, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we open the file in write-only, binary mode. To open a file in write-only,
    test mode, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once again, since `std::ios::binary` has been left out, this code opens the
    file in write-only, text mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'To open a file in write-only, binary mode at the end of the file (instead of
    the beginning of the file, which is the default), use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we open the file in write-only, binary mode at the end of the
    file by adding `std::ios::ate` to the mode variable. This moves the output pointer
    in the file to the end of the file, but allows writing to occur at any place within
    the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that the file is always appended to the end of the file, open the
    file using `std::ios::app` instead of `std::ios::ate`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, writes and additions to the file are always appended
    to the file as the file was opened using `std::ios::app`.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that in all of the previous examples that used `std::ios::out`,
    the file was opened using `std::ios::trunc`. This is due to the fact that truncate
    mode is the default when using `std::ios::out`, unless `std::ios::ate` or `std::ios::app`
    is used. The problem with this is that there is no way to open a file for write-only
    at the beginning of the file without truncating the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this issue, the following may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we open the file in write-only, binary mode at the end of the
    file, and then we use `seekp()` (a function that will be explained later) to move
    the output position in the file to the beginning of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although `std::ios::trunc` is the default when `std::ios::out` is used, if
    `std::ios::in` is also used (that is, read/write mode), you must explicitly add
    `std::ios::trunc` if you wish to clear the contents of the file prior to opening
    the file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, the file is opened in read/write mode, and the contents of the file are
    deleted prior to opening the file.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing to a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following sections will help you to understand how to read and write to
    a file using the `std::fstream` C++ APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ provides several different methods for reading a file, including by field,
    by line, and by number of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Reading by field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most type-safe method for reading from a file is by field, the code which
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we open a file for reading and writing (since that is the default
    mode). If the file is successfully opened, we read in two strings into two variables—`hello`
    and `world` respectively. To read the two strings, we use `>> operator()`, which
    behaves just like `std::cin` as discussed in [Chapter 6](b7b0e871-3833-4c12-984d-fd6f86b7ea84.xhtml),
    *Learning to Program Console Input/Output*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a string, the stream reads characters until the first whitespace or newline
    is discovered. As with `std::cin`, numeric variables can also be read, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we read in an integer instead of a string, and, just like
    a string, the stream reads in bytes until a whitespace or newline is discovered,
    and then interprets the input as a number. Of course, if the field being read
    is not a number, `0` is read, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It should be noted that an error flag is set when this occurs, which we will
    discuss later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with other C++ streams, `std::fstream` can be overloaded to provide support
    for user-defined types, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a user-defined type called `myclass`. In the `main()`
    function, we open a file, and if the file is successfully opened, we create a
    `myclass{}` object, read the file into the `myclass{}` object, and then output
    the results of the `myclass{}` object to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: To read the file into the `myclass{}` object, we overload `>> operator()` for
    `std::fstream{}` which reads in two strings, and stores the results in the `myclass{}`
    object. To output the `myclass{}` object to `stdout`, we build upon what we learned
    in [Chapter 6](b7b0e871-3833-4c12-984d-fd6f86b7ea84.xhtml), *Learning to Program
    Console Input/Output*, with respect to user-defined overloads of `std::ostream`,
    and provide a user-defined overload for our `myclass{}` object.
  prefs: []
  type: TYPE_NORMAL
- en: The result is that `Hello World` is read from the file and output to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: Reading bytes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to reading fields from a file, C++ provides support for reading
    bytes directly from the file. To read a single byte from the stream, use the `get()`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading more than one byte in C++17 is still an unsafe operation, as there
    is no ability to read *x* number of bytes directly into a `std::string`. This
    means that a standard C-style buffer must be used instead, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we create a standard C-style character buffer called
    `buf`, and then read 11 bytes from the file into this character buffer. Finally,
    we output the results to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: We need to ensure that the total number of bytes being read does not exceed
    the total size of the buffer itself—an operation that often leads to a coding
    error, generating hard-to-debug buffer overflows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simple solution to this problem is to use a wrapper around the `read()`
    function that checks to make sure the requested number of bytes does not exceed
    the total size of the buffer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a template function called `myread()` that encodes
    the total size of the buffer into the function itself during compilation. Before
    a read occurs, the size of the buffer can be checked to ensure a buffer overflow
    will not occur.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that this works well for arrays, but is problematic for dynamically-allocated
    arrays, as the total size of the buffer must also be passed to our wrapper function,
    potentially leading to hard-to-debug logic bugs (that is, not providing the proper
    size of the buffer, swapping the total number of bytes to read with the buffer
    size, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: To overcome these types of issues, `gsl::span` should be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'When reading bytes instead of fields, it can be helpful to know from where
    in the file you are currently reading. As you read from a file stream, both a
    read and a write pointer are maintained internally within the stream. To get the
    current read position, use the `tellg()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we open a file as usual and output the current read pointer, which as
    expected is `0`. We then read a single character from the file, and output the
    read pointer again. This time, the pointer is `1`, indicating we have successfully
    read a single byte.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another method for reading a single byte is to use the `peek` function, which
    functions similarly to `get()`, except that the internal read pointer is not incremented,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This example is the same as the previous one, except that `peek()` is used instead
    of `get()`. As shown, the read pointer is `0` both before and after `peek()` is
    used to read a byte from the buffer, demonstrating that `peek()` doesn't increment
    the read pointer within the stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reverse is also provided by C++. Instead of reading a byte from the file
    without moving the read pointer, it is also possible to move the read pointer
    without reading bytes from the stream using the `ignore()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we move the read pointer in our file stream by a single byte,
    and use `tellg()` to verify that the read pointer has in fact been moved. The
    `ignore()` function increments the read pointer relative to the current read pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ also provides the `seekg()` function, which sets the read pointer to an
    absolute position, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `seekg()` function is used to set the read pointer
    to 1 byte into the file after reading, effectively rewinding, allowing us to read
    the file again.
  prefs: []
  type: TYPE_NORMAL
- en: Reading by line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, the last type of file read is by line, meaning that you read each
    line from the file, one at a time, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a standard C character buffer, read a line from the
    file, and output the line to `stdout`. Unlike the `read()` function, `getline()`
    keeps reading until either the size of the buffer is reached (the second argument),
    or a delimiter is seen.
  prefs: []
  type: TYPE_NORMAL
- en: Since a line is defined differently depending on the OS you're using (although
    in this case, we will stick to Unix), the `getline()` function takes a delimiter
    argument, allowing you to define what the end of a line is.
  prefs: []
  type: TYPE_NORMAL
- en: Like the `read()`, function, this operation is unsafe as it requires the user
    to ensure that the total buffer size given to `getline()` is, in fact, the total
    size of the buffer—providing a convenient mechanism to introduce hard-to-debug
    buffer overflows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the `read()` function, C++ provides a non-member version of `getline()`
    that accepts any stream type (including `std::cin`), and `std::string` instead
    of a standard C-style string, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, instead of calling `file.getline()`, we instead call
    `std::getline()`, and provide the function with `std::string`, which can dynamically
    change its size depending on the number of bytes that need to be read—preventing
    possible buffer overflows.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that in order to achieve this, the `std::string` will perform
    a `new()` / `delete()` automatically for you—which (especially with respect to
    system programming) might introduce inefficiencies that are unacceptable. In this
    case, the `file.getline()` version should be used, with a wrapper class, similar
    to what we did with the `read()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if changes are made to a file that has already been opened, the following
    will sync the current stream with these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, the `sync()` function may be used to resync
    an already open file with changes to the file.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Symmetrically like `std::cin` and file reading, a file writing is also provided
    that behaves similarly to `std::cout`. Unlike reading, there are only two different
    modes of file writing—by field and by byte.
  prefs: []
  type: TYPE_NORMAL
- en: Writing by field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To write to a file by field, use `<< operator()`, similar to `std::cout`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we open a file as usual and then create two `std::string`
    objects with `hello` and `world` added to the strings respectively. Finally, these
    strings are written to the file. Note that there is no need to close or flush
    the file, as this is done for us on destruction of the file stream object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `std::cout`, C++ natively supports standard C character buffers and numeric
    types, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we write a standard C character buffer and an integer
    directly to the file. User-defined types are also supported with respect to writing,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we open a file and write a `myclass{}` object to the file.
    The `myclass{}` object is a struct that contains two member variables initialized
    with `Hello` and `World`. A user-defined `<< operator()` overload is then provided
    that writes to a provided file stream the contents of the `myclass{}` object,
    resulting in `Hello World` being written to the file.
  prefs: []
  type: TYPE_NORMAL
- en: Writing bytes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to writing by field, writing a stream of bytes is also supported.
    In the following example, we write a single byte to the file (in addition to a
    newline) using the `put()` function, which is similar to `get()` but used for
    writing instead of reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple bytes can also be written using the `write()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we write `12` bytes to the file (11 characters for
    the string `Hello World`, and one additional string for the newline).
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the `read()` function, the `write()` function is unsafe and should be
    wrapped to ensure that the total number of bytes written to the file does not
    exceed the total size of the buffer (otherwise a buffer overflow would occur).
    To demonstrate how even standard C-style `const` character buffers are unsafe,
    see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As shown in this example, attempting to write 100 bytes from a standard C `const`
    character buffer that is only `13` bytes in size (11 for `Hello World`, `1` for
    the new line, and `1` for the `\0` null termination), results in a buffer overflow.
    In this case, the buffer overflow results in corrupted bytes being written to
    the file, which, at best, leaks parts of the program, but could also generate
    instability, including hard-to-debug segmentation faults.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this, a wrapper should be used whenever using these types of unsafe
    functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we create a wrapper around the `write()` function,
    similar to the `read()` function wrapper that we created previously. When we attempt
    to write more bytes than the total size of the standard C `const` character buffer,
    we generate an exception that can be used to trace the error to our attempt to
    write 100 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be noted that this wrapper only works with standard C `const` character
    buffers that are generated by the compiler. It is possible to declare this type
    of buffer manually where this type of function will fail, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create two standard C `const` character buffers. The first
    buffer consists of the word `Hello` with a newline, and the second buffer consists
    of the word `World` with a newline. We then write `Hello` to the file, but instead
    of writing `6` characters, we write `12`. Finally, we write `World` to the file,
    and we provide the correct number of bytes, which is `6`.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting output is `Hello World`, with `World` being written to the file
    twice. The reason for this is a carefully crafted buffer overflow. The first write
    to the file writes `Hello` to the buffer, but provides the `write()` function
    with `12` bytes instead of `6`. Our wrapper in this case is looking for a null
    terminator, which does not exist (as we have defined our standard C `const` character
    buffers manually, removing the null terminator).
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the `mywrite()` function doesn't detect the overflow, and write
    both buffers.
  prefs: []
  type: TYPE_NORMAL
- en: There is no safe way to overcome this type of problem (the `read()` function
    has similar issues) without the use of the guideline support library, diligence,
    and a static analyzer capable of detecting the use of a these types of buffers
    unsafely being used (which is not a trivial thing for a static analyzer to do).
    As a result, in general, functions such as `read()` and `write()` should be avoided
    in favor of by-field and by-line alternatives when possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to `tellg()`, the write stream also has the ability to get the current
    write pointer position using the `tellp()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `Hello World` is written to the file, and the `tellp()`
    function is used to output the write pointer position, which results in `0`, `5`,
    `6`, `11`, and `12`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to move the write pointer to an absolute position within
    the file using the `seekp()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we write `Hello World` to the file, and then move the write
    pointer within the stream back to the beginning of the file. We then write `The
    answer is: 42` to the file. Along the way, we use `tellp()` to output the location
    of the write pointer, showing how the write pointer moves as we perform these
    actions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, the file consists of `The answer is: 42`, instead of `Hello World`,
    as `Hello World` is overwritten.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, as with the `sync()` function, the writes to a file can be flushed
    to the filesystem when desired using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: It should be noted that although you can flush the file manually (for example,
    if you know a change must hit the filesystem), the file will be closed and flushed
    to the filesystem automatically when the `std::fstream` object loses scope and
    is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When reading and writing, it''s possible that different types of errors could
    occur. `std::fstream` provides four different functions for determining the state
    of the stream, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`good()`: If this function returns `true`, no errors have occurred, and the
    stream has not reached the end of the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eof()`: If this function returns `true`, the end of the file has been reached.
    Internal errors do not affect the result of this function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fail()`: If this function returns `true`, an internal error has occurred,
    but the stream is still functional, for example, if a numerical conversion error
    occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bad()`: If this function returns `true`, an error has occurred, and the stream
    is no longer functional, for example, if the stream fails to open a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When normal file operations occur, `good()` should return `true`, while the
    other three status functions should return `false`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `Hello World` is written to a file successfully, resulting
    in `good()` returning `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to using the `good()` function, `! operator()` can be used to detect
    whether an error has occurred, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Hello World` is successfully written to the file, and as a result, the
    `good()` function returns `true`, which means `! operator()` returns `false`,
    resulting in the `failed` string never being output to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the `bool` operator can be used, which returns the same result as
    `good()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `Hello World` is successfully written to the file, resulting
    in the `bool` operator returning `true`; this means that the `good()` function
    would also return `true`, since they return the same result.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an error occurs, the error status remains triggered until the stream is
    closed, or until the `clear()` function is used, telling the stream that you have
    dealt with the error, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, a string is written to a text file. This test file
    is opened for reading, and an integer is read. The problem is that the value written
    to the file is not actually a number, causing the file stream to report an error.
  prefs: []
  type: TYPE_NORMAL
- en: The `clear` function is then used to clear the error, after which the `good()`
    function continues to report `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding file utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the C++ APIs described in this chapter thus far were added prior to C++17\.
    Although C++ provided the ability to read and write a file, it didn't provide
    all of the other file operations that are needed to manage a filesystem, including
    file paths, directory management, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This section will focus on the `std::filesystem` additions in C++17 that address
    most of these shortcomings.
  prefs: []
  type: TYPE_NORMAL
- en: Paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A path is nothing more than a string that represents a node in a filesystem.
    On UNIX systems, this is usually a string consisting of a series of directory
    names, `/`, and a filename, usually with an extension. The purpose of a path is
    to represent the name and location of a file, which can then be used to perform
    an action on the file such as opening the file for reading and writing, changing
    the file's permissions, or even removing the file from the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be noted that a path can represent many different types of nodes
    in a filesystem, including files, directories, links, devices, and so on. A more
    complete list will be presented later in this chapter. Consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a path that refers to a directory named `user`, located in a root directory
    named `home`. Now consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This refers to a file named `test.txt` in this same directory. The file's stem
    is `test`, while the file's extension is `.txt`. In addition, the file's root
    is `/` (which is the case on most UNIX systems).
  prefs: []
  type: TYPE_NORMAL
- en: 'On UNIX systems, paths can take on different forms, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Block devices**: The path refers to a POSIX-style block device such as `/dev/sda`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Character devices**: The path refers to a POSIX-style character device such
    as `/dev/random`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Directories**: The path refers to a regular directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fifo**: The path refers to a pipe or other form of IPC'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Socket**: The path refers to a POSIX socket'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Symlink**: The path refers to a POSIX symlink'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Files**: The path refers to a regular file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To determine what type a path is, C++17 provides the following test functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, `/dev/sda` is a block device, `/dev/random`
    is a character device, `/dev` is a directory that is not empty, and the `scratchpad.cpp`
    file that is used to compile all the examples in this chapter is a regular file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine if a path exists, C++17 provides the `exists()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here the directory `/dev` exists, and so do the character device `/dev/random`
    and the regular file `scratchpad.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every program that executes must execute from a given directory. To determine
    this directory, C++17 provides the `current_path()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `current_path()` is used to get the current directory that
    `a.out` is executing from. The path that was provided by `current_path()` is an
    absolute path. To turn an absolute path into a relative path, use the `relative()`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As shown in this example, the relative path for the current path is simply (`.`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, to turn a relative path into an absolute path, C++17 provides the
    `canonical()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use the `canonical()` function to convert a relative path
    to an absolute path. It should be noted that getting the absolute path of `.`
    is another way to return the same result of `current_path()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that the `canonical()` function returns the absolute path with all
    references to `../` and `./` resolved, reducing the absolute path to its minimal
    form. If this type of path is not desired, the `absolute()` function may be used
    instead, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As shown in this example, the `../` is not removed by the `absolute()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since there are different ways to represent the same path (that is, relative,
    canonical, and absolute), C++17 provides the `equivalent()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: All the paths referenced in this example refer to the same directory, regardless
    of whether they are relative, canonical, or absolute.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to determine if two paths are lexically equal (containing the same
    exact characters), use `== operator()` instead, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The code here is the same as the preceding code, apart from the use of `== operator()`
    instead of the `equivalent()` function. The previous example returned `true` for
    all of the paths since they all refer to the same path, while the preceding example
    returns `false` because the same paths are not lexically equal, even though they
    are technically the same path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the use of `/ operator()` in these examples. C++17 provides different
    concatenation functions for paths that conveniently provide a clean, readable
    way of adding to an existing path: `/`, `/=`, and `+=`. `/ operator()` (and the
    self-modifying version `/= operator()`) concatenates two paths while adding a
    `/` for you, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `scratchpad.cpp` is added to the path using `/= operator()`,
    and a `/` is added for us. If you wish to add the `/` yourself, or you do not
    wish for a `/` to be added at all, you can use `+= operator()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The result here is the same as in the previous example, with the difference
    being that `+= operator()` is used instead of `/= operator()`, and so the `/`
    needs to be added manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to concatenation, C++17 provides some additional path modifiers.
    One such function is `remove_filename()`, which removes the filename from a path,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As shown, the `remove_filename()` function removes the filename from the path.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to replace the filename with something else, instead of
    removing it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As shown, the filename `scratchpad.cpp` was replaced with `test.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As well as replacing the filename, it is also possible to replace the extension,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As shown, the extension for `scratchpad.cpp` was changed to `.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if you need to, it''s possible to clear a path using the `clear()`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, the `clear()` function deletes the contents
    of the path (as if it were default constructed).
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated, a path consists of different parts including a root name, directory,
    stem, and extension. To dissect a path into these different components, C++17
    provides some helper functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we dissect the path of the `scratchpad.cpp` file into its different
    parts. The parent path is `/home/user/Hands-On-System-Programming-with-CPP/Chapter08`,
    the filename is `scratchpad.cpp`, the stem is `scratchpad`, and the extension
    is `.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: Not all paths contain all the parts that a path could potentially contain. This
    can occur when a path points to a directory, or when it is ill-formed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To figure out which parts a path contains, use the following helpers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As shown here, you can determine whether a path has a root path, root name,
    root directory, relative path, parent path, filename, stem, and extension. You
    can also determine whether the path is an absolute path or a relative path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, C++17 provides different mechanisms for managing paths on a filesystem,
    depending on the type of path you''re using. For example, if you wish to create
    a directory or delete a path (regardless of its type), use the `create_directory()`
    and `remove()` functions respectively, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we use the `create_directory()` function to create
    a directory, and then we use the `remove()` function to delete it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also rename a path using the `rename()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a directory using the `create_directory()` function.
    We rename the directory using the `rename()` function, and then delete both the
    old directory path and the new one. As shown, the attempt to delete the directory
    that has been renamed fails, as that path no longer exists, while attempting to
    delete the new directory succeeds, as that path does exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `remove()` function will remove any path (assuming the program has the
    proper permissions), unless the path points to a directory that is not empty,
    in which case it will fail. To remove a directory that is not empty, use the `remove_all()`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown here, we create a directory and add some files to the directory using
    `std::fstream`. We then delete the newly created directory using `remove_all()`
    instead of `remove()`. If we used the `remove()` function, the program would throw
    an exception, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common operation to perform on a filesystem is to iterate over all
    of the files in a directory. To do this, C++17 provides a directory iterator,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we create a directory using the `create_directory()`
    function, add some files to the directory, and then use a directory iterator to
    iterate over all the files.
  prefs: []
  type: TYPE_NORMAL
- en: The directory iterator functions like any other iterator in C++, which means,
    as shown in the preceding example, that we can leverage the ranged for syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, C++17 provides a convenient function for determining the path to the
    temporary directory, which can be used to create temporary directories as needed
    for your program, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: It should be noted that on POSIX systems, the temporary directory is usually
    `/tmp`, as shown here. However, it's still prudent to use the `temp_directory_path()`
    instead of hard-coding this path.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the logger example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will extend the debugging example in [Chapter 6](b7b0e871-3833-4c12-984d-fd6f86b7ea84.xhtml), *Learning
    to Program Console Input/Output*, to include a rudimentary logger. The goal of
    this logger is to redirect additions to the `std::clog` stream to a log file in
    addition to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Just like the debugging functions in [Chapter 6](https://cdp.packtpub.com/hands_on_system_programming_with_c___/wp-admin/post.php?post=31&action=edit#post_29), *Learning
    to Program Console Input/Output*, we would like the logging functions to be compiled
    out if the debugging level is not sufficient, or if debugging has been disabled.
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this, please see the following code: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/example1.cpp](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/example1.cpp).
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we will need to create two constant expressions—one for the debug
    level, and one to enable or disable debugging outright, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will need to create a global variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The global variable is the log file stream. This will be used to write additions
    to the `std::clog` stream to a log file. Since this is a log file, we open it
    as write-only, append, meaning we can only write to the log, and all writes must
    append to the end of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will need to define the `log` function itself. This function needs
    to be able to output to both `std::clog` and to our log file stream without executing
    the debug logic more than once (as this could result in unexpected behavior).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following implements the `log` function with this goal in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Like the debug functions in [Chapter 6](b7b0e871-3833-4c12-984d-fd6f86b7ea84.xhtml), *Learning
    to Program Console Input/Output*, this `log` function starts by wrapping the business
    logic of the function in a `constexpr` `if` statement (a feature new to C++17),
    providing the compiler with a means to compile out the code if debugging is disabled,
    or if the provided debug level is greater than the current debug level.
  prefs: []
  type: TYPE_NORMAL
- en: If debugging should take place, the first step is to create a string stream,
    which behaves just like `std::clog` and the log file stream, but saves the results
    of any additions to the stream to a `std::string`.
  prefs: []
  type: TYPE_NORMAL
- en: The read buffer for `std::clog` is then saved, and the read buffer of the string
    stream is provided to `std::clog`. Any additions to the `std::clog` stream will
    be redirected to our string stream instead of `stderr`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we execute the user-provided `debug` function, collecting the debug string
    and storing it in the string stream. Finally, the `read()` buffer for `std::clog`
    is restored to `stderr`, and we output the string stream to both `std::clog` and
    the log file stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to create our `protected_main ()` function that logs `Hello
    World`. Note that, for demonstration, we also add `Hello World` to `std::clog`
    manually, without the `log` function, to demonstrate that `std::clog` functions
    as normal and only logs to our log file when the `log` function is used. This
    is shown with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/CMakeLists.txt).
  prefs: []
  type: TYPE_NORMAL
- en: 'With this code in place, we can compile and execute this code using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Notice how both the `debug` statements are output to `stderr` (both the statement
    in the `log` function, and the statement manually executed without the `log` function).
    Yet, the log file only has a single statement in it, demonstrating the `log` function
    is responsible for redirecting additions to `std::clog` to both the log file and
    `stderr`, while leaving `std::clog` intact for future uses.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the tail file example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will create a simple program to tail a file. The goal of
    this example is to mimic the behavior of `tail -f -n0`, which outputs new additions
    to a file. The `-f` argument tells the tail to follow the file and `-n0` tells
    tail to only output to `stdout` new additions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to define the mode we plan to use when opening the file we
    are tailing, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we will open the file as read-only, and move the read pointer
    to the end of the file on open.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create a `tail` function that watches for changes to a
    file and outputs the changes to `stdout`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This `tail` function starts by telling the compiler that this function does
    not return, as the function is wrapped in a `while(true)` loop that never ends.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the function checks whether the end of the file has been reached by first
    peeking the file, and then checking the end-of-file bit using `eof()`. If it has,
    the program sleeps for a second, clears all status bits, resyncs with the filesystem
    to see if any new changes have been made, and then loops again.
  prefs: []
  type: TYPE_NORMAL
- en: If the read pointer is not at the end of the file, its current position is read
    in case its position in the file needs to be restored. The next line in the file
    is read and stored in a buffer.
  prefs: []
  type: TYPE_NORMAL
- en: It's possible that attempting to read the next line using `getline` will fail
    (for example, when the last character in a file is not a newline). If this occurs,
    the contents of the buffer should be ignored (as it is not a complete line), and
    the read pointer needs to be restored to its original position.
  prefs: []
  type: TYPE_NORMAL
- en: If the next line is successfully read, it is output to `stdout`, and we loop
    again to see if more lines need to be read.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last function in this example must parse the arguments provided to our
    program to get the file name to tail, open the file, and then call the `tail`
    function with the newly opened file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: As with previous examples, we parse the arguments using a `gsl::span` to ensure
    safety and remain compliant with C++ Core Guidelines. If no arguments are provided
    to the program, we wait for the user to provide the program with the filename
    to tail.
  prefs: []
  type: TYPE_NORMAL
- en: If a filename is provided, we open the file and call `tail()`. If the file cannot
    be opened, we throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/CMakeLists.txt).
  prefs: []
  type: TYPE_NORMAL
- en: 'With this code in place, we can compile and execute this code using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'From another terminal, we can make changes to the file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This would result in the example program outputting the following to `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure the program is ignoring incomplete lines, we can add an incomplete
    line to the file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This results in no output from the example program.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing C++ versus mmap benchmark
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will benchmark the difference between reading the contents
    of a file using `std::fstream` and reading them using `mmap()`.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that the `mmap()` function leverages a system call to directly
    map a file into the program, and we expect `mmap()` to be faster than the C++
    APIs highlighted in this chapter. This is because the C++ APIs have to perform
    an additional memory copy, which is obviously slower.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start this example by defining the size of the file we plan to read,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we must define a `benchmark` function to record how long it takes to
    perform an action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding function, we leverage a high-resolution timer to record how
    long it takes to execute a user-provided function. It should be noted that this
    benchmark program is relatively generic, and can be used for a lot of non-trivial
    functions (as trivial functions are often difficult to benchmark, even with high-resolution
    timers).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to create a file read, and then we need to read the file using
    `std::fstream` and `mmap()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step in the `protected_main()` function is to create the file we
    plan to read, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: To do this, we open the file we plan to read using write-only, which also opens
    the file using `std::ios::trunc` by default, erasing the contents of the file
    for us just in case. Finally, we write `size` number of zeros to the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to read the file using `std::fstream`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Before we read the file using `std::fstream`, we open the file using read-only,
    which opens the file at the beginning of the file. Our file read is then encapsulated
    in our benchmark function. The results of the benchmark are output to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the last step is to do the same for `mmap()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: As with `std::fstream`, the file is opened first, and then the use of `mmap()`
    is encapsulated in our benchmark function.
  prefs: []
  type: TYPE_NORMAL
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/CMakeLists.txt).
  prefs: []
  type: TYPE_NORMAL
- en: 'With this code in place, we can compile and execute this code using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: As shown, `mmap()` executes faster than `std::fstream`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to open a file in different ways, depending
    on how we plan to use the file itself. Once opened, we learned how to read and
    write to the file using the `std::fstream` C++ APIs.
  prefs: []
  type: TYPE_NORMAL
- en: We learned the difference between fields and bytes, and the advantages and disadvantages
    of both methods of reading and writing, as well as common unsafe practices. In
    addition, we learned about support functions that provide the ability to move
    pointers within the `std::fstream` APIs to manipulate how a file is read and written.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, in this chapter, we gave an extensive overview of the new filesystem
    APIs added to C++17, including paths and their support functions for manipulating
    files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: We concluded this chapter with three examples. In the first we wrote a logger
    to redirect the output of `std::clog` to a log file and `stdout`. The second example
    demonstrated how to rewrite the tail POSIX command using C++.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the third example, we wrote some benchmarking code to compare the
    difference in performance of POSIX, C and C++. In the next chapter, we will cover
    C++ allocators including how to create stateful allocators such as a memory pool
    that can be used when system programming to improve memory performance and efficiency
    when applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the name of the function used to see whether a file was successfully
    opened?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the default mode for opening a file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if you attempt to read a non-numeric value into a numeric variable
    from a file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What types of error could occur if you unsafely use the `read()` or `write()`
    functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does `/= operator()` add a `/` to your path for you automatically?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the stem of the following path—`/home/user/test.txt`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the parent directory of the following path—`/home/user/test.txt`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
