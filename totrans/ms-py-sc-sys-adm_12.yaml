- en: Remote Monitoring of Hosts Over Telnet and SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to carry out basic configurations on a
    server with Telnet and SSH configured. We will begin by using the Telnet module,
    after which we will implement the same configurations using the preferred method:
    SSH using different modules in Python. You will also learn about how `telnetlib`,
    `subprocess`, `fabric`, `Netmiko`, and `paramiko` modules work. For this chapter,
    you must have a basic knowledge of networking.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The `telnetlib()` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `subprocess.Popen()` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSH using fabric module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSH using Paramiko library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSH using Netmiko library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The telnetlib() module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn about the Telnet protocol and then we
    will do Telnet operations using the `telnetlib` module over a remote server.
  prefs: []
  type: TYPE_NORMAL
- en: Telnet is a network protocol that allows a user to communicate with remote servers.
    It is mostly used by network administrators to remotely access and manage devices.
    To access the device, run the Telnet command with the IP address or hostname of
    a remote server in your Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Telnet uses TCP on the default port number `23`. To use Telnet, make sure it
    is installed on your system. If not, run the following command to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To run Telnet using the simple Terminal, you just have to enter the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Python has the `telnetlib` module to perform Telnet functions through Python
    scripts. Before telnetting your remote device or router, make sure they are configured
    properly and, if not, you can do basic configuration by using the following command
    in the router''s Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see the example of Telnetting a remote device. For that, create
    a `telnet_example.py` script and write following content in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script and you will get the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we accessed and configured a Cisco router using the
    `telnetlib` module. In this script, first, we took the username and password from
    the user to initialize the Telnet connection with a remote device. When the connection
    was established, we did further configuration on the remote device. After telnetting,
    we will be able to access a remote server or device. But there is one very important
    disadvantage of this Telnet protocol, and that is all the data, including usernames
    and passwords is sent over a network in a text manner, which may cause a security
    risk. Because of that, nowadays Telnet is rarely used and has been replaced by
    a very secure protocol named Secure Shell, known as SSH.
  prefs: []
  type: TYPE_NORMAL
- en: SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSH is a network protocol and is used to manage a device or servers through
    remote access. SSH uses public key encryption for security purposes. The important
    difference between Telnet and SSH is that SSH uses encryption, which means that
    all data transmitted over a network is protected from unauthorized real-time interception.
  prefs: []
  type: TYPE_NORMAL
- en: 'User who accesses a remote server or device must install an SSH client. Install
    SSH by running the following command in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Also, on a remote server where the user wants to communicate, an SSH server
    must be installed and running. SSH uses the TCP protocol and works on port number
    `22` by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the `ssh` command through the Terminal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, you will learn to do SSH by using different modules in Python, such as
    subprocess, fabric, Netmiko, and Paramiko. Now, we will see those modules one
    by one.
  prefs: []
  type: TYPE_NORMAL
- en: The subprocess.Popen() module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Popen` class handles the process creation and management. By using this
    module, developers can handle less common cases. The child program execution will
    be done in a new process. To execute a child program on Unix/Linux, the class
    will use the `os.execvp()` function. To execute a child program in Windows, the
    class will use the `CreateProcess()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see some useful arguments of `subprocess.Popen()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at each argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '`args`:It can be a sequence of program arguments or a single string. If `args`
    is a sequence, the first item in args is executed. If args is a string, it recommends
    to pass args as a sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shell`: The shell argument is by default set to `False` and it specifies whether
    to use shell for execution of the program. If shell is `True`, it recommends to
    pass args as a string. In Linux, if `shell=True`, the shell defaults to `/bin/sh`.
    If `args` is a string, the string specifies the command to execute through the
    shell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bufsize`: If `bufsize` is `0` (by default, it is `0`), it means unbuffered
    and if `bufsize` is `1`, it means line buffered. If `bufsize` is any other positive
    value, use a buffer of the given size. If `bufsize` is any other negative value,
    it means fully buffered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`executable`: It specifies that the replacement program to be executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stdin`, `stdout`, and `stderr`: These arguments define the standard input,
    standard output, and standard error respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`preexec_fn`:This is set to a callable object and will be called just before
    the child is executed in the child process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`close_fds`:In Linux, if `close_fds` is true, all file descriptors except `0`,
    `1`, and `2` will be closed before the child process is executed. In Windows,
    if `close_fds` is `true` then the child process will inherit no handles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`env`:If the value is not `None`, then mapping will define environment variables
    for new process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`universal_newlines`:If the value is `True` then `stdout` and `stderr` will
    be opened as text files in newlines mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we are going to see an example of `subprocess.Popen()`. For that, create
    a `ssh_using_sub.py`  script and write the following content in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script and you will get the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, first, we imported the subprocess module, then we
    defined the host address where you want to establish the SSH connection. After
    that, we gave one simple command that executed over the remote device. After all
    this was set up, we put this information in the `subprocess.Popen()` function.
    This function executed the arguments defined inside that function to create a
    connection with the remote device. After the SSH connection was established, our
    defined command was executed and provided the result. Then we printed the result
    of SSH on the Terminal, as shown in the output.
  prefs: []
  type: TYPE_NORMAL
- en: SSH using fabric module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fabric is a Python library as well as a command-line tool for the use of SSH.
    It is used for system administration and application deployment over the network.
    We can also execute shell commands over SSH.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use fabric module, first you have to install it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will see an example. Create a `fabfile.py` script and write the following
    content in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script and you will get the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, first, we imported the `fabric.api` module, then we
    set the hostname and password to get connected with the host network. After that,
    we set different task to perform over SSH. Therefore, to execute our program instead
    of the Python3 `fabfile.py`, we used the `fab` utility (`fab dir`), and after
    that we stated that the required tasks should be performed from our `fabfile.py`. 
    In our case, we performed the `dir` task, which creates a directory with the name
    `'fabric'` on your remote network. You can add your specific task in your Python
    file. It can be executed using the `fab` utility of the fabric module.
  prefs: []
  type: TYPE_NORMAL
- en: SSH using the Paramiko library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Paramiko is a library that implements the SSHv2 protocol for secure connections
    to remote devices. Paramiko is a pure Python interface around SSH.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before using Paramiko, make sure you have installed it properly on your system.
    If it is not installed, you can install it by running the following command in
    your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will see an example of using `paramiko`. For this `paramiko` connection,
    we are using a Cisco device. Paramiko supports both password-based and  key-pair
    based authentication for a secure connection with the server. In our script, we
    are using password-based authentication, which means we check for a password and,
    if available, authentication is attempted using plain username/password authentication. Before
    we are going to do SSH to your remote device or multi-layer router, make sure
    they are configured properly and, if not, you can do basic configuration by using
    the following command in a multi-layer router Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a `pmiko.py` script and write the following content in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script and you will get the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, first, we imported the `paramiko` module, then we
    defined the SSH credentials required to connect the remote device. After providing
    credentials, we created an instance `'c'` of `paramiko.SSHclient()`, which is
    the primary client used to establish connections with the remote device and execute
    commands or operations. The creation of an `SSHClient` object allows us to establish
    remote connections using the `.connect()` function. Then, we set the policy `paramiko`
    connection because, by default, `paramiko.SSHclient` sets the SSH policy in reject
    policy state. That causes the policy to reject any SSH connection without any
    validation. In our script, we are neglecting this possibility of SSH connection
    drop by using the `AutoAddPolicy()` function that automatically adds the server's
    host key without prompting it. We can use this policy for testing purposes only,
    but this is not a good option in a production environment because of security
    purpose.
  prefs: []
  type: TYPE_NORMAL
- en: When an SSH connection is established, you can do any configuration or operation
    that you want on your device. Here, we created a few virtual LANs on a remote
    device. After creating VLANs, we just closed the connection.
  prefs: []
  type: TYPE_NORMAL
- en: SSH using the Netmiko library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about Netmiko. The Netmiko library is an advanced
    version of Paramiko. It is a `multi_vendor` library that is based on Paramiko.
    Netmiko simplifies SSH connection to a network device and takes particular operation
    on the device. Before going doing SSH to your remote device or multi-layer router,
    make sure they are configured properly and, if not, you can do basic configuration
    by command mentioned in the Paramiko section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see an example. Create a `nmiko.py` script and write the following
    code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script and you will get the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we use Netmiko library to do SSH, instead of Paramiko.
    In this script, first, we imported `ConnectHandler` from the Netmiko library,
    which we used to establish an SSH connection to the remote network devices by
    passing in the device dictionary. In our case, that dictionary is `remote_device`.
    After the connection is established, we executed configuration commands to create
    a number of virtual LANs using the `send_config_set()` function.
  prefs: []
  type: TYPE_NORMAL
- en: When we use this type (`.send_config_set()`) of function to pass commands on
    a remote device, it automatically sets our device in configuration mode. After
    sending configuration commands, we also passed a simple command to get the information
    about the configured device.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about Telnet and SSH. You also learned the different
    Python modules such as telnetlib, subprocess, fabric, Netmiko, and Paramiko, using
    which we perform Telnet and SSH. SSH uses the public key encryption for security
    purposes and is more secure than Telnet.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use various Python libraries, with which you can
    make graphical user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is client-server architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you run operating-specific commands in Python code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between LAN and VLAN?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What will the output of the following code be?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a Python program to display a calendar (hint: use the `calendar` module).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a Python program to count the number of lines in a text file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Paramiko documentation: [https://github.com/paramiko/paramiko](https://github.com/paramiko/paramiko)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fabric documentation: [http://www.fabfile.org/](http://www.fabfile.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
