- en: Services and Daemons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Determining running services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing installed services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting and stopping services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing which services start and stop at boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common services you might expect to see
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding service unit files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing systemd unit files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing running services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a basic unit file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with systemd timers (and cron)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other `init` systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: systemd (stylized lowercase) is a hydra.
  prefs: []
  type: TYPE_NORMAL
- en: In the old world, we had one piece of software for each little thing we wanted
    to do on a system. Time was handled by NTP, devices were handled by `udev`, and
    init was generally handled by `SysV Init`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the new world, we have systemd:'
  prefs: []
  type: TYPE_NORMAL
- en: System clock management can be handled by `systemd-timesyncd`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`udev` was merged into the systemd code base, forming `systemd-udevd`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process initialization is handled by the core of systemd itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list goes on.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, systemd has been adopting other projects, or writing the same functionality
    into implementations of their own (such as systemd-timesyncd which is an NTP replacement.) However,
    the systemd suite is also modular, meaning that distributions can broadly choose
    which bits to adopt and use.
  prefs: []
  type: TYPE_NORMAL
- en: For us, the important job that systemd does is replace the traditional init
    system on distributions (CentOS, Debian, and Ubuntu all use systemd now). This
    means that first and foremost, systemd manages services and daemons on your box.
  prefs: []
  type: TYPE_NORMAL
- en: systemd is the first process, meaning it will often be assigned the first **process
    ID** (**PID**). All other processes have systemd as a parent.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to work with the init component of systemd, learn
    about unit files, and determining the running state of our system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, this chapter could have been much longer. Prior to systemd dominating
    each and every mainstream distribution, fragmentation existed. Canonical wrote
    something called Upstart for Ubuntu (which was temporarily adopted by Red Hat),
    and more traditional distributions had a hard time letting go of the `SysV` init
    style of daemon management. Even today, you''ll find systems that use older implementations
    in the wild:'
  prefs: []
  type: TYPE_NORMAL
- en: CentOS adopted systemd with version 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubuntu adopted systemd with 15.04
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debian adopted systemd with Jessie (8)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Canonical wrote Upstart, you might be wondering why they went with systemd
    in the end. This was mainly due to Debian adopting systemd, after something of
    a civil war internally, and Ubuntu conceding that they would have an easier time
    of it if they remained aligned with their upstream distribution. The war was not
    without bitter battles on both sides and some ripples can still be felt.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, a different `Vagrantfile` is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feel free to use the following example if required—be sure to `destroy` any
    previous boxes to free up resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Determining running services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you get to a box, especially one you're unsure of (that's been tucked
    in the back of a cupboard somewhere blinking to itself), it's a good idea to find
    out what software is running on it.
  prefs: []
  type: TYPE_NORMAL
- en: On modern systems (2013-ish plus), this is accomplished with the `systemctl`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: '`systemctl` is the main control mechanism for any systemd system—literally
    "system control". Think of it as the human frontend to your initialization software
    (the first software to run on your box, which manages all others), allowing you
    to modify and investigate the running state of your computer.'
  prefs: []
  type: TYPE_NORMAL
- en: Not only that, in the Unix/Linux world everything is a file; your network connections
    are a file, your programs are a file, your devices are a file, and because of
    this you can control everything, just by modifying files.
  prefs: []
  type: TYPE_NORMAL
- en: But that gets tedious fast.
  prefs: []
  type: TYPE_NORMAL
- en: '`systemctl` saves you the headache of manually shuffling files around your
    system by wrapping functionality in simple commands and printing the results in
    a human-readable way.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the command line, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be dropped into a list of systemd units; this is a good initial
    overview of every unit systemd is aware of, but it''s very noisy (as seen in the
    following screenshot) and what we specifically want to see are daemons (because
    of our gothic streak):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73ec54ca-a25c-4b4e-bc26-fc98b7eb631b.png)'
  prefs: []
  type: TYPE_IMG
- en: Services and daemons are somewhat interchangeable in Linux land; for example,
    systemd refers to daemons as `service` files. This doesn't stop some people from
    getting passionately angry about "proper usage".
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You should be given a list of services and their statuses.
  prefs: []
  type: TYPE_NORMAL
- en: 'This view is better, but it also shows failed and exited services, for example,
    on our Vagrant instance, we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62d80a21-c36c-4f42-8e65-4f13f3ec1c1f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If I want to exclude these, I can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we get a much more condensed list, with 17 items in total:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can get rid of the helpful-but-noisy header and footer notes with the `--no-legend`
    option to `systemctl`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're using the `systemctl` command to query systemd.
  prefs: []
  type: TYPE_NORMAL
- en: We'll get gradually more granular with our requests, until we've eventually
    built a query that shows us only what we want to see, that being services that
    are running right-this-second.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s an argument to be made for using `pipes` and `grep` to accomplish
    what you want and, depending on your preference, you may find one of these two
    commands neater than the other, though they accomplish roughly the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the previous, we're first printing the default "all" list from `systemctl`,
    then we're passing it through `grep` a couple of times to filter what we want,
    and finally we're displaying it in a mostly-readable fashion with a column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're using one command to get a slightly prettier output than the previous,
    and we're only using one command to do it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with services that''re loaded and running, you may be interested in services
    that have loaded, done whatever job they were intended for, and then exited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Or perhaps you''re interested in services that have failed? Try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, systemd will use a pager by default to display results, which while
    human-friendly, isn't great for scripts. To simply print the output of your command
    to `stdout`, add `--no-pager` to your command.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, querying the init system is the best way to determine what services
    are running on a box, though if you're running something outside of init, such
    as a background task started by `cron`, you might have better look with `ps` or
    `top`, which we'll cover later.
  prefs: []
  type: TYPE_NORMAL
- en: Listing installed services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to look at how to list services that are installed,
    but will never run on your host, generally because they're not enabled to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connect to your `centos1` VM.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the following as your user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: By default, you'll be dropped into a typically long list of services. A lot
    of these will be listed as `static`, some will be `enabled`, and others will be
    `disabled`.
  prefs: []
  type: TYPE_NORMAL
- en: As far as systemd is concerned, this is a list of all services it knows about
    on your system.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are again querying systemd using `systemctl`, only this time instead of printing
    running services, we're getting everything that the init system is aware of.
  prefs: []
  type: TYPE_NORMAL
- en: Service files, and indeed all other types of unit file, generally exist in `/usr/lib/systemd/system`.
    From this location, files are symlinked into the `runlevel` directories at `/etc/systemd/system/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the following, we''re going to `ls` this directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note we have a few `targets`, which are basically the different runlevels of
    a system; most of the day-to-day services you'll interact with live in `multi-user.target.wants`,
    which are basically the services required for a multi-user session (the typical
    mode of operation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `ls` again in this sub-directory reveals the symlinks mentioned earlier
    and their location on disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These services are all `enabled` to start in a multi-user session.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of `enabled` and `disabled` is relatively easy to understand, those
    states being that the service will either try to run or it won't.
  prefs: []
  type: TYPE_NORMAL
- en: '`static` is something different; this is the terminology used when a unit file
    exists, isn''t enabled, but has no ability to become enabled, owing to a missing
    `[Install]` section of its unit file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can list these services with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Taking a service at random (`sshd-keygen`), we can have a look at its service
    file like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using systemctl's `cat` option is great, as it also shows you the location of
    the unit file in question.
  prefs: []
  type: TYPE_NORMAL
- en: 'We get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: From this file, we can see it has a `PartOf` definition, suggesting it's run
    as part of the `sshd` service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking a look at that service (again using systemctl `cat`) reveals the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can see the `Wants` section here, suggesting `sshd-keygen` is run when `sshd`
    starts.
  prefs: []
  type: TYPE_NORMAL
- en: This explains why it doesn't have to be enabled on its own.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with most components on a Linux system, the `systemctl` command has a man
    page.
  prefs: []
  type: TYPE_NORMAL
- en: In this man page, you'll find a table titled `is-enabled output` where you can
    learn more about the different terminology printed with your status commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one service of the `indirect` state, which the table lists as having
    the following meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The unit file itself is not enabled, but it has a non-empty Also= setting
    in the [Install] unit file section, listing other unit files that might be enabled,
    or it has an alias under a different name through a symlink that is not specified
    in Also=. For template unit file, an instance different than the one specified
    in DefaultInstance= is enabled."'
  prefs: []
  type: TYPE_NORMAL
- en: Starting and stopping services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to look at the trivial-but-important aspect of
    starting and stopping services.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a world without the ability to automatically start daemons when a box
    boots; you'd have to manually go in and start your services with every reboot,
    being careful to ensure you start your services in the appropriate way each time.
  prefs: []
  type: TYPE_NORMAL
- en: That world, like one dominated by the Stargate Replicators, isn't one in which
    I'd want to live.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to use `postfix` in this example, as it's a service that won't be
    doing much of anything on our VM.
  prefs: []
  type: TYPE_NORMAL
- en: '`postfix` is a **Mail Transport Agent** (**MTA**) typically installed on CentOS
    boxes. Even if your box isn''t handling email, processes might use it to email
    you warning about failures and things of that ilk.'
  prefs: []
  type: TYPE_NORMAL
- en: Stopping our service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the following (using `sudo`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note the distinct lack of output confirming or denying what you've typed has
    worked.
  prefs: []
  type: TYPE_NORMAL
- en: Starting our service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with stopping our service, starting it again is trivial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note again the confusing silence.
  prefs: []
  type: TYPE_NORMAL
- en: Silence upon command completion isn't unique to systemd, and it's actually something
    of a philosophy in the Unix and Unix-like world. If a command has done what it's
    supposed to, the user doesn't need to be told.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you instruct systemd to start or stop a unit, what you're actually doing
    is running the `ExecStart` or `ExecStop` portions of its unit file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking `postfix` as our example, its unit file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here we can see that, when we issue a `systemctl start postfix` command, it's
    literally running the `postfix` binary with the `start` option. The opposite is
    true for `stop`.
  prefs: []
  type: TYPE_NORMAL
- en: We also have some `ExecStartPre` lines, which are commands executed before the
    main `ExecStart` command is run.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Without `sudo`, you may be prompted to authenticate as `root`; in order that
    the command might be run as `root`, I typically see this dialogue when I forget
    to `sudo` first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also confirm whether a service is started or stopped quickly with the
    `status` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more on the `ExecStart` and `ExecStop` options of the unit file you're reading,
    check out the specific `systemd.service` man page on the subject.
  prefs: []
  type: TYPE_NORMAL
- en: There's also various other options that aren't `start` and `stop`, including
    `reload-or-try-restart` just to confuse matters. See the `systemctl` command for
    these options.
  prefs: []
  type: TYPE_NORMAL
- en: Changing which services start and stop at boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the CentOS world, installing a new service doesn't immediately start and
    enable it, though it does in the Debian world (a default that, again, has its
    advocates and disparagers).
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we're going to enable a new service and reboot our VM, checking
    what happens when it comes up.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Connect to your `centos1` VM. Install `httpd` (Apache) for these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s see if we actually have a unit file for `httpd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We have one, and now we need to see what state it''s currently in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Our output lists the service as `inactive` and `disabled`.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling our service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we just want to start our service, we could run the command listed in the
    previous section, but this wouldn't enable the service at boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable our service, we run `enable`, surprisingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that, for some reason, we do get output while enabling services.
  prefs: []
  type: TYPE_NORMAL
- en: Reboot your box and see whether `httpd` started on boot by using the `systemctl
    status` command.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling our service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we''ve got `httpd` enabled, we''re going to disable it again, because that''s
    just the sort of people we are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Seen in the output when we're disabling and enabling our services, what we're
    actually doing is creating a `symlink` from the default location of our `httpd`
    unit file, to the `multi-user.target.wants` directory, mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: On boot, systemd will check this directory at the appropriate time and start
    the services it finds there.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting and enabling services at the same time is perfectly possible and is
    definitely preferable to rebooting a box to change a service's state.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done easily by inserting `--now` to our `enable` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Effectively, we''ve run the following on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The systemd concept of `targets` is similar in nature to the old-school `runlevel`
    that you may or may not be familiar with. It's not a direct comparison, as systemd
    can activate multiple targets at the same time, whereas runlevels were singular.
    The `multi-user.target` is roughly equivalent to runlevels 2, 3, and 4.
  prefs: []
  type: TYPE_NORMAL
- en: See the `systemd.target` man page for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Common services you might expect to see
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to run down a list of common services you might
    expect to see on a given box. This list won't be comprehensive, as what services
    are there by default can change, even between distribution releases.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'List out the services on our system, even those that are static and disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Scroll through the list, searching with `/` if you're using the default pager
    (less).
  prefs: []
  type: TYPE_NORMAL
- en: auditd.service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting at the top, we have `auditd.service`, "the Linux audit daemon". Used
    to write the audit records of your system, you'll find the fruit of its work in
    the `/var/log/audit/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: chronyd.service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed when we talked about time on our system, `chronyd` is responsible
    for keeping your system clock correct. I would expect to see this, or `ntpd`,
    running on most servers in the wild.
  prefs: []
  type: TYPE_NORMAL
- en: crond.service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not to be confused with `chronyd`, `crond` is the daemon responsible for making
    sure that scheduled commands are run when they're supposed to be.
  prefs: []
  type: TYPE_NORMAL
- en: lvm2-*.service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The collection of `lvm2` service files are used to maintain and monitor **Logical
    Volume Manager** (**LVM**) setups. Most servers you'll come across will probably
    be using LVM for their filesystem and volume management needs.
  prefs: []
  type: TYPE_NORMAL
- en: NetworkManager.service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered networks to death, but it's useful to know that the `NetworkManager.service`
    file is one of the annoying few with uppercase letters.
  prefs: []
  type: TYPE_NORMAL
- en: This fact has caught me out on more than one occasion.
  prefs: []
  type: TYPE_NORMAL
- en: nfs.service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically installed, the `nfs` suite of services are for management of **Network
    File System** (**NFS**) devices.
  prefs: []
  type: TYPE_NORMAL
- en: NFS is still in wide use and is very well maintained by distribution producers,
    meaning even if you don't use it, it'll probably be there.
  prefs: []
  type: TYPE_NORMAL
- en: postfix.service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A typical MTA, `postfix` is the default you'll see on Red Hat, CentOS, and Fedora
    systems. On others, it might be the Exim mail server. We'll be going over these
    briefly later.
  prefs: []
  type: TYPE_NORMAL
- en: rsyslog.service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Either `rsyslog` or `syslog-ng` will probably be installed on your server, at
    least for the foreseeable future. These are the system log daemons, responsible
    for writing logs to text files in `/var/log` (usually). They've got a competitor
    in `binary-log-loving journald`, which we'll come to later.
  prefs: []
  type: TYPE_NORMAL
- en: sshd.service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I should hope to see `sshd.service` running on any system I'm connected to,
    otherwise I have no idea what baffling method I've used to connect.
  prefs: []
  type: TYPE_NORMAL
- en: systemd-journald.service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The competitor to `syslog` mentioned previously, `journald` is the logging daemon
    managed by systemd, and which can be queried using an array of syntactical soup
    on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: systemd-logind.service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another from `systemd` Borg, `logind` manages user logins to the systems of
    which you're an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These services, and any others you might be running on your machine, make up
    what is effectively the OS you're running.
  prefs: []
  type: TYPE_NORMAL
- en: If you're like me, you may find yourself playing around with this list in your
    spare time, trying to figure out which bits you can disable, and still have a
    functioning system at the end.
  prefs: []
  type: TYPE_NORMAL
- en: My advice would generally be to leave the defaults as they are, because you
    never know what random job is cleaning a temporary directory for you without you
    even realizing it.
  prefs: []
  type: TYPE_NORMAL
- en: Default services are frequently disabled as part of **hardening** tasks; if
    you ever find yourself having to harden a system, the usual rules apply. Look
    into what the current best practices are, and see if your vendor has a ready-made
    guide.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use handy tools such as `systemd-analyze` to see how long our system
    took to boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 8 seconds isn't bad, excluding the time it takes VirtualBox to initialize our
    VM and the time it takes the kernel to start (5 seconds on the Grub boot menu).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even run this command with `blame` tacked on the end, to see what process
    is taking your precious seconds from you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check out other systems for what services they start by default. For example,
    Ubuntu on the desktop might not start `auditd`, but it will probably have `gdm`
    to ensure a Gnome login window when you boot your machine.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding service unit files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a good idea of where to find service unit files, as well as how
    to enable and disable services.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we touched on a couple of the entries within a unit file, though
    we haven't gone into much depth on these options or where to find more information
    and alternative entries you might want to use.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to use `sshd.service` as an example here, not just because it's
    a service file you might see a lot, but because it has a good mixture of default
    entries.
  prefs: []
  type: TYPE_NORMAL
- en: '`cat` our chosen service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: To understand this file, we have to break it down into its component parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sort of the `Main` section of the unit file, `[Unit]` is the area for generic
    entries, not specific to the `Service` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'For the description, we have a short and snappy entry that can be understood
    at a glance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have a handy line, detailing the appropriate URI location to peruse
    if you get stuck. Here we have `man:` as the URI, but it could be `https://` or
    even `info::`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`info:` refers to information pages, like man pages, but more widely ridiculed. `After=` (and `Before=`)
    is a space-separated list of unit names, which stipulates the services that need
    to start after (or before) this one. Here the network needs to be started, and `ssh-keygen` needs
    to run prior to `sshd` starting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We dissected `Wants=` earlier, but to flesh it out a bit, you''ll commonly
    see `Wants=` in unit files, listing services which it would be nice to trigger,
    prior to this service starting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`Wants=` is a less-mandated version of `Requires=`. If a `Wants=` service fails
    to start, the parent service will still give it a try, if a `Requires=` service
    fails, the parent doesn''t either.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specific to unit files of the `service` type, the `[Service]` block is specific
    to service options, perhaps obviously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The process start up type, `notify` here means systemd expects the daemon to
    send a notification message once it''s finished starting up. Only when this notification
    is received will systemd continue starting services that depend on this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Used to point the service to the file that contains its environment variables,
    for `sshd` this contains one option on our box, `OPTIONS="-u0"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The crux of what''s run when the service is started, `ExecStart` gives us the
    command that''s run. Note also the `$OPTIONS` value, read from the file stipulated
    on the `EnvironmentFile` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This section tells systemd what should be run if the `systemctl reload sshd` command
    is run. Specifically, we''re sending the `HUP` (hangup) signal to the `sshd` PID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This directive specifies how processes of the unit''s own creation are to be
    killed. `process` here means only the main process itself is killed by systemd:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, `KillMode` is being used, but `ExecStop` isn't. This is because `ExecStop`
    is optional, and generally only used if the init daemon has a specific cleanup
    job to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Restart` option tells systemd how the process is to be restarted. `on-failure` used
    here means `sshd` will be restarted on an unclean exit code, an unclean signal,
    a timeout, or if the watchdog timeout for a service is breached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`RestartSec` is the specified time to take before restarting the `sshd` service,
    following the `Restart=` criteria being met. I''d imagine it''s `42` seconds here
    because the author of the unit file is a fan of Douglas Adams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Install is another generic section, such as `[Unit]`. This section holds the
    installation information for the unit file, meaning it''s read by the enable and
    disable directives when run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The only directive here is that this service is `WantedBy` the multi-user target,
    meaning that, in multi-user mode, `sshd` will be started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a service file is interacted with by systemd, the section of the file it
    reads determines its actions.
  prefs: []
  type: TYPE_NORMAL
- en: If starting a service, `ExecStart` would be read—if stopping, `ExecStop`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several options are available to the writer of a unit file and more are being
    added with every systemd release. There's a good chance that the operation you
    want to accomplish can be achieved with a unit file entry.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the overwhelming array of options available to unit file authors, you
    still get people who insist on writing a bash script to do everything, and simply
    referring to this in a four-line unit file. It's possible, but it's not neat.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a free afternoon, give the `systemd.service` and `systemd.unit`
    manual pages a read; they're both lengthy and a good sedative in lieu of sleeping
    tablets.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing systemd unit files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to look at ways we can modify systemd unit files.
  prefs: []
  type: TYPE_NORMAL
- en: There's an important note to make here, which is that, while you can absolutely
    modify configuration files as they're delivered, there's no guarantee that your
    changes will be persistent across updates of your system. Package managers might
    take offence to your mangling of their service files, and simply replace them
    without warning.
  prefs: []
  type: TYPE_NORMAL
- en: The correct way to modify the actions of systemd unit files is to write a whole
    other file with your changes included.
  prefs: []
  type: TYPE_NORMAL
- en: systemd's method for doing this is called a snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: systemd has a built-in way of generating the required override file we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the directory and file for the `sshd.service` unit using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You will be placed in an empty file, but one that exists within a new directory,
    namely `/etc/systemd/system/sshd.service.d/override.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the following into our empty file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: When we save and exit the file, an implicit `systemctl daemon-reload` is run,
    meaning that when we run a `systemctl restart sshd`, our new settings are enabled.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We said our `edit` command created a new directory and file, in which override
    commands can be placed; you can now visit this by changing to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Within our override file, our new entries are stored. These entries generally
    complement those in the primary configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Breaking our new configuration down, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here we've added a short description of what the file is, showing it's slightly
    modified. There's a fake manual page entry, which we've suggested might be a good
    place for documentation when we get around to writing it. We also changed the
    service so that it now requires `sshd-keygen`, instead of just wanting it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we change the service section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here we're adding our `Environment` directive, instead of using an `EnvironmentFile`
    (which we've blanked).
  prefs: []
  type: TYPE_NORMAL
- en: We're blanking `ExecStart` too, and passing in our own (which we've added `-4`)
    to.
  prefs: []
  type: TYPE_NORMAL
- en: And because we're boring, we've decided we want `sshd` to restart in 10 seconds,
    instead of `42`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's not always obvious which values can be stacked atop one another, and which
    have to be blanked out first.
  prefs: []
  type: TYPE_NORMAL
- en: To test whether your configuration is being loaded correctly, use `systemctl
    show sshd` to read the running configuration of your service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the output, I find the following line (`Documentation` can stack, so
    our new entry just gets added to the end.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`Description` is overwritten, as you can only have one entry, so ours takes
    precedence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s no `EnvironmentFile` option, and the only entry is our `Environment` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s only one `ExecStart` line, and it''s ours as we blanked the original:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's another method to making your own unit file changes, but it's messier.
    Effectively, you write a complete unit file, changing the options you want, and
    you place your new file in `/etc/systemd/system/` before re-enabling the service.
    The reason this works is because `/etc/systemd/system/` has a higher precedence
    than `/usr/lib/systemd/system/` though you've now burdened yourself with management
    of the whole service definition, instead of just the bits you want to change.
  prefs: []
  type: TYPE_NORMAL
- en: Testing running services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to look at three ways we can see whether a service
    is actually running, once we've issued a `start` command.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with the built-in systemd way (`systemctl`) before moving to a generic
    way (`ps`) and finally a simple way (`telnet`).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connect to your `centos1` VM. Install and start `httpd` if it's not already
    started.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also install `telnet` for some basic port checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With systemd''s built-in tool, we can check the status with the `status` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a good indication that things are fine, because systemd believes them
    to be. We can also use the `ps` tool to try and determine whether our process
    has started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Here I use the `aux` option, partly this is because I can reliably do the same
    thing on my BSD systems, and partly it's because the person I first watched use `ps`
    used those flags, so it stuck with me.
  prefs: []
  type: TYPE_NORMAL
- en: We can see `httpd` running with a few processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we could try connecting to the port locally with `telnet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Though if your web server isn't running on localhost, or `80`, this test is
    somewhat pointless and will fail.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered three ways of checking whether a service is running. The first,
    and arguably most robust, is to see whether the init system believes the service
    is up.
  prefs: []
  type: TYPE_NORMAL
- en: Our `systemctl` command reported an active, running state and gave us a time
    that the service had started.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we queried the system's process list to see whether we could find our
    server; this works well as it could be the case that a misconfigured service file
    starts your service, but isn't then aware of its state, hence believing it to
    be dead.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we used `telnet` to try and connect to the port we thought the service
    might be running on; this is the least intelligent way to check whether a service
    is running locally, as it requires you to know specifics and `telnet` is rarely
    installed by default.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get information about open sockets on a system, you would use `ss`; see the
    earlier section on `ss` for details on what commands you might use to determine
    used ports.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a basic unit file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to put together a unit file of our own. We're also
    going to choose a location to save it and we're going to reboot our system to
    check if it works.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to again use Python's built-in web server, starting an instance
    using a small unit file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create the directory in which we''re going to store our unit file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''re going to echo the following into a file called `pythonWebServer.service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This unit file is for demonstration purposes only, and should **absolutely not**
    be used in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can enable and start it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Check it''s running with the `status` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All we've done here is create a local unit file for systemd to read and load.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand our path choice, try running the following on your system,
    and see what''s returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: One of the options should be `/usr/local/lib/systemd/system`, which doesn't
    exist at first, but does when we create it.
  prefs: []
  type: TYPE_NORMAL
- en: It's a good idea to use a path like this because, not only is there a good chance
    it's empty, meaning you can logically separate your unit files from others, it's
    also uncluttered (unlike the `/etc/systemd/system/` directory).
  prefs: []
  type: TYPE_NORMAL
- en: We then placed a small example unit file in this directory, featuring the bare
    minimum to make a functioning service file.
  prefs: []
  type: TYPE_NORMAL
- en: Once written, it's a simple case of enabling and starting our service.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There're a couple of problems with what we've done here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is that we''ve created a very static service file, which we can only
    change by manipulating it directly. The second issue is that we''ve made a web
    server that, by default, will list the contents of the root of our server, which
    I highly doubt you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Let's address both of these issues, using what we've learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your new systemd unit file for editing, in your editor of choice, and
    populate it with a few more options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Note some we've used previously, and some new ones such as `WorkingDIrectory=`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, populate `/var/www/html/index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'And add an entry to our environment file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Reload systemd''s configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'And test with `curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are so many different configuration options for systemd unit files; we've
    not really scratched the surface here, and it could absolutely constitute a book
    in itself.
  prefs: []
  type: TYPE_NORMAL
- en: Read the relevant man pages, have a go at writing your own unit files, and report
    back with your findings, you brave explorer.
  prefs: []
  type: TYPE_NORMAL
- en: Working with systemd timers (and cron)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The new kids on the block, and another component that systemd brought into its
    gargantuan self, are systemd timers. Timers are another type of unit, only one
    that acts as the instruction for when another unit is to trigger.
  prefs: []
  type: TYPE_NORMAL
- en: In the old world, you'd control periodic events on a system with `cron`, and
    this is still widely used, but increasingly systemd timers are stealing that mantle
    away.
  prefs: []
  type: TYPE_NORMAL
- en: I say *new* but new is relative. Basically something can be in systemd for years
    before it finally trickles into Debian or CentOS. If you want the latest and greatest,
    run something like Fedora on a laptop.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we're going to look at existing `cron` and timer entries on
    our system, before converting our Python server into a timer-triggered service.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we're going to list existing periodic jobs on the system.
  prefs: []
  type: TYPE_NORMAL
- en: systemd timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting with systemd timers, we''re going to list what exists on our box by
    default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Within this output, we can see two timers. The first is `systemd-tmpfiles-clean.timer`
    and its action is to trigger `systemd-tmpfiles-clean.service`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `systemctl cat` against this file shows us its timer configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the service file reveals what''s actually run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Note that it's a `oneshot` service, meaning it's expected to exit after running.
  prefs: []
  type: TYPE_NORMAL
- en: From the previous information, we can tell when our timer has last run and when
    it's next due to.
  prefs: []
  type: TYPE_NORMAL
- en: The second timer we can see, `systemd-readahead-done.timer` and its companion
    service file, aren't active. This is denoted by the `n/a` details in the various
    time fields. This service is used in non-virtualized systems to log disk boot
    patterns, attempting to speed up subsequent boots.
  prefs: []
  type: TYPE_NORMAL
- en: This makes timers much easier to read and work out when they last ran, compared
    to `cron`.
  prefs: []
  type: TYPE_NORMAL
- en: cron
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'm not aware of an easy way to list information from `cron`; if you know of
    one, please write to me and blow my mind.
  prefs: []
  type: TYPE_NORMAL
- en: '`cron`, as we said previously, is a daemon for executing commands on a schedule.
    It''s still in wide use and there''s many systems out there with a hybrid systemd
    timers/`cron` setup.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `cron` features the following directories in `/etc/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Within `cron.d`, we can see a single file named `0hourly`, the contents of
    which are copied in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'And within the `/etc/cron.hourly` directory, we have only `0anacron`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Readable, this is not.
  prefs: []
  type: TYPE_NORMAL
- en: At a glance, it's awkward and fiddly to work out what jobs are running periodically
    through `cron`, and you'll always get that one bodge-job that someone's written,
    without any logging, that they forget about.
  prefs: []
  type: TYPE_NORMAL
- en: Chances are good you'll have `cron` screw you over at one point in your life,
    at least until it goes away forever, so if you ever get unexpected behavior on
    your system, stop and have a quick look through the `cron` directories for some
    indication of foul play.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the specific `cron` logs from `journalctl` easily enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: systemd timers are great; they also work very well, primarily because they're
    inherently tied to the init and unit system that they're managing the time triggers
    for.
  prefs: []
  type: TYPE_NORMAL
- en: In a perfect world, I'd love to see all of the `cron` entries featured in CentOS
    and Debian completely removed within their next release. The truth of the matter
    is `cron` will probably be around for a long time, and systems such as FreeBSD
    will use it long after the heat-death of the universe.
  prefs: []
  type: TYPE_NORMAL
- en: When we list timers, we're checking what systemd is aware of in terms of units
    it has to trigger.
  prefs: []
  type: TYPE_NORMAL
- en: When we're sifting through `cron` logs and subdirectories, we're banging our
    heads against a metaphorical desk in a vain effort to find that vague one-liner
    that's constantly touching the file we're trying to delete.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to write our own timer unit, using the Python unit file from the
    last example.
  prefs: []
  type: TYPE_NORMAL
- en: I would recommend starting by disabling the service if you've still got it running
    or destroying the VM and writing it again, referring to the last section if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adjusting our `pythonWebServer.service` file so that it looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Specifically, we've removed a few lines. Note the complete removal of the `[Install]`
    section, as it's not needed when the timer is controlling the startup.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, this wouldn't be something permanent such as a web server,
    it would usually be something small, such as a script to open a web page on a
    wallboard somewhere or send a request to the coffee machine to make you a latte.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''re going to write a `timer` file, putting it in the exact same place
    as our `service` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterwards, we''re going to reload systemd and enable the timer, but not the
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Note the creation of `symlink`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s reboot our box and see what happens. If you''re quick, and you manage
    to run `systemctl list-timers` before your ten seconds are up, you might see something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Running it again will show that the job has passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick `curl` will confirm our service is up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can check the status of a systemd timer in the same way as any other unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Seen in the following is the output and command used to check the status of
    our `pythonWebServer.timer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Other init systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: systemd might be the dominant init system in the Linux world, but there are
    others that you'll still come across. At the time of writing, CentOS 6 is very
    much alive and kicking, with its upstart core.
  prefs: []
  type: TYPE_NORMAL
- en: That's without going into the nitty-gritty of what the BSDs use and macOS to
    boot (which I actually quite like).
  prefs: []
  type: TYPE_NORMAL
- en: I have seen some absolutely ancient Debian installations in my time, some of
    which went out of support half a decade or longer ago. I once worked out that
    a box I was SSH'd into, could legally drive.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Connect to both of your other VMs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have two systems at play; CentOS 6 uses Upstart, and Debian 7 uses SysV init.
  prefs: []
  type: TYPE_NORMAL
- en: CentOS 6 and Upstart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the old world, `systemctl` won''t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: What's also slightly annoying is that there's no `upstart` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, `Upstart` is skinned to look like a typical `init` system. The main
    page even lists it as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '"init: Upstart process management daemon"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of `systemctl`, we use `service --status-all`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives you output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Confusingly, the service name might not be what you see. Take `sshd` as an
    example. The previous command might lead you to believe that the daemon on this
    system is called `openssh-daemon`, but that''s incorrect; it''s really `sshd`
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Confused? I was the first time I saw this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way to interact with services is to call them directly (as they''re
    just a script really):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting and stopping is very similar, but one thing that will catch you out
    is that traditional `init` systems put the control command at the end of the line
    (unlike systemd):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Note the `stop` and `start` tacked on the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Disabling and enabling services is different too; on old CentOS systems, `chkconfig`
    was your best friend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Note the concept of runlevels still existing, and that `sshd` starts in `2`,
    `3`, and `4`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can disable this service with another `chkconfig` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'And we enable it using `on`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we''re working with runlevels, you can head to the `rc*.d` directories.
    Specifically, we''re going to drop into `rc3.d` for runlevel `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Within this directory, we're again dealing with symlinks. You'll find a list
    of all jobs run at entry to runlevel `3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One will be `sshd` (assuming you''ve not disabled it in the last step):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Debian 7 and SysV init
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike CentOS 6, Debian 7 uses an older `init` system, its manual page lists
    it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '"init, telinit: process control initialization"'
  prefs: []
  type: TYPE_NORMAL
- en: Again, we're dealing with PID 1 on the system—that much hasn't changed, only
    now processes are primarily controlled by the `/etc/inittab` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Runlevels are again a major player, though we use a different command to discover
    where we are (as a regular user, `root` still has access to the `runlevel` command,
    if you want to use it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'As with `upstart`, the actual destination of our service files is the `/etc/init.d/`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that, like `Upstart`, we can manually interact with our service
    scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The tool we used previously (`chkconfig`) can be installed on Debian 7, but
    by default we use a tool called `update-rc.d` to control starting and stopping
    services at boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'If you really want to use `chkconfig`, I won''t shout at you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Both `Upstart` and traditional `init` systems rely on the `/etc/init.d/` directory and
    then the various `rc` directories to instruct them what to start at which runlevel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at Debian''s `inittab` we can see the default `runlevel` as configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: So, we know we'll likely end up at runlevel 2, meaning we can check the services
    that start at that runlevel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same can be said for `Upstart`, and on our CentOS system, we can see the
    default is set to 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Though it must be said, this is literally the only function that `inittab` serves
    on Upstart systems.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Honestly, there's a lot more to `Upstart`, and more to traditional `init` systems
    too, but I would suggest that if you're going to be working with Linux and modern
    systems, you should make learning systemd a priority.
  prefs: []
  type: TYPE_NORMAL
- en: If you're working on BSD systems, read up on their own `init` systems and how
    they differ.
  prefs: []
  type: TYPE_NORMAL
- en: If you're working with old servers that you're unlikely to be allowed to turn
    off any time soon, I'm sorry.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's good documentation on `Upstart` at [http://upstart.ubuntu.com/cookbook/](http://upstart.ubuntu.com/cookbook/).
  prefs: []
  type: TYPE_NORMAL
- en: There're also good accounts, if you can find them from the corners of the internet,
    detailing the events of the Debian Technical Committee vote on their new `init`
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Round-up - services and daemons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section turned out a lot longer than I'd expected it to, but at the same
    time, I'm glad that Ubuntu, CentOS, Red Hat, and Debian now share a single `init`
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Had I been writing this book four years ago, I might well have given up at the
    start of this section and gone climbing instead.
  prefs: []
  type: TYPE_NORMAL
- en: That said, it's over, and I hope you learned something about how systemd works
    in the last few pages.
  prefs: []
  type: TYPE_NORMAL
- en: One last thing to note is that, despite systemd being in all the big players
    now, it still has its critics, and you'll definitely come across the odd grumpy
    sysadmin who can't let go of his bash-script driven systems. My advice in these
    cases is to smile and nod; it's not worth it to get too involved—that or suggest
    they might like to give FreeBSD a go instead?
  prefs: []
  type: TYPE_NORMAL
- en: I have mixed memories of SysV and Upstart systems, most of them revolving around
    hacking default bash scripts just to get dependencies working correctly with each
    other. I do get slightly nostalgic when I log on to a system, discover it's running
    Fedora Core 3, and I'm forced to remember everything I thought I'd forgotten about
    SysV init.
  prefs: []
  type: TYPE_NORMAL
- en: systemd is here to stay, and I personally can't wait to see what it sucks into
    its heaving mass next.
  prefs: []
  type: TYPE_NORMAL
- en: People might draw the line at `systemd-kerneld` though.
  prefs: []
  type: TYPE_NORMAL
