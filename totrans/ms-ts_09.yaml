- en: Chapter 9. Let's Get Our Hands Dirty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at building a TypeScript single-page web application
    from the ground up. We will start with a discussion on what the site should look
    like, how we want our page transitions to flow, and then move on to expore the
    capabilities of the Bootstrap framework, and discuss a pure HTML version of our
    site. Our focus will then switch to the data structures that we will need for
    our application, and what Backbone models and colllections we need to represent
    this data. Along the way, we will write a set of unit and integration tests for
    these models and collections.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have data to work with, we will then use the **Marionette** framework
    to build views in order to render our application to the DOM. We will then show
    how to break up our pure HTML version of the site into smaller portions of HTML
    snippets, and then integrate these snippets with our Marionette views. Finally,
    we will tie the application together using events, and explore the **State** and
    **Mediator** Design Pattern to help us manage complex page transitions and DOM
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: Marionette
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Marionette is an extension of the Backbone library, and introduces a number
    of enhancements to the framework, in order to reduce boilerplate Backbone code,
    and make working with DOM elements and HTML fragments easier. Marionette also
    introduces the concept of layouts and regions to help with managing logical portions
    of HTML within a large web page. A Marionette layout is a type of controller that
    manages several regions, and a Marionette region is an object that manages a particular
    HTML portion of our page. As an example, we could have a region for the header
    panel, one for a side-bar panel, and another for a footer area. This allows us
    to break up our application into logical areas, and then tie them together through
    messaging.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will also be using Bootstrap to help with our page layout. Bootstrap is a
    popular mobile-first framework for rendering HTML elements across a number of
    different platforms. Bootstrap styling and customization is a topic big enough
    for its own book, so we won't be exploring the ins and outs of the various Bootstrap
    options. If you are keen on learning more, then be sure to read the excellent
    book by David Cochran and Ian Whitley called *Boostrap Site Blueprints*, *Packt
    Publishing* ([https://www.packtpub.com/web-development/bootstrap-site-blueprints](https://www.packtpub.com/web-development/bootstrap-site-blueprints)).
  prefs: []
  type: TYPE_NORMAL
- en: Board Sales
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application will be a rather simple one, called Board Sales, and will list
    a range of windsurfing boards on the main page, using a summary view, or board
    list view. Clicking on any one of these boards will transition the page to show
    detailed information on the selected board. On the left-hand side of the screen,
    there will be a simple panel to allow the user to filter the main board list via
    manufacturer, or board type.
  prefs: []
  type: TYPE_NORMAL
- en: Modern windsurfing boards come in a range of sizes, and are measured by volume.
    Smaller volume boards are generally used for wave sailing, and larger volume boards
    are used for racing, or slalom. Those in-between can be categorized as freestyle
    boards, and are used for performing acrobatic tricks on flat water. Another important
    element of any board is the range of sails that the board is designed for. In
    very strong winds, smaller sails are used to allow the windsurfer to control the
    power generated by the wind, and in lighter winds, larger sails are used to generate
    more power. Our summary view will include a quick reference to the volume measurements
    for each board, and our detail view will show all the various board measurements
    and a compatible list of sail ranges.
  prefs: []
  type: TYPE_NORMAL
- en: Page layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With this application, we will use the power of JavaScript to provide a left-to-right
    panel-style page layout. We will use some Bootstrap transitions to slide panels
    in from the left, or from the right, in order to provide the user with a slightly
    different browsing experience. Let''s take a look at what this will look like
    conceptually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Page layout](img/9665OS_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A conceptual view of page transitions for Board Sales
  prefs: []
  type: TYPE_NORMAL
- en: The **viewing panel** will be our main page, with a **header panel**, a **board
    listing panel**, and a **footer panel**. Hidden from view on the left-hand side
    will be the **filter panel**, with a button on the top-left of the main panel
    to show or hide this filter panel. The filter panel will slide in from the left
    when needed, and slide back to the left when hidden. Similarly, the **board detail**
    **panel** will slide in from the right when a board is clicked, and will slide
    back to the right when the back button is clicked, revealing the board listing
    panel.
  prefs: []
  type: TYPE_NORMAL
- en: When the site is viewed on a desktop device, the filter panel on the left will
    be shown by default, but when the site is viewed on a tablet device—with a smaller
    screen—then the filter panel will be hidden by default, in order to save on screen
    real estate.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Bootstrap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bootstrap is a collection of CSS styles and JavaScript functions that aid in
    building responsive websites rather simply and easily. The responsive nature of
    Boostrap means that pages will resize elements automatically, to allow rendering
    on the smaller screen sizes of mobile phones, as well as larger screens used on
    tablets and desktops. By using Bootstrap, we gain the additional benefit of being
    able to target mobile users and desktop users with very little change to our HTML
    or CSS style sheets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bootstrap can be installed with a NuGet package, along with the corresponding
    TypeScript definitions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once Bootstrap has been installed, we can start building a sample web page that
    is purely written in HTML using Bootstrap. Building a demo page in this way helps
    us to figure out what Bootstrap elements we will use, and allows us to modify
    our CSS styles and structure our HTML correctly, before we start to build our
    application. This is where the Brackets editor really comes into its own. By using
    the live preview functionality of the editor, we can edit our HTML and CSS in
    one IDE, and have instant visual feedback in the preview pane. Working on sample
    HTML in this way is both a rewarding and fun experience, not to mention a massive
    time-saver.
  prefs: []
  type: TYPE_NORMAL
- en: Using Bootstrap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our page will use a couple of Bootstrap elements for the main page regions,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A **Navbar** component to render the header panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A **Footer** component to render the footer panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A **Carousel** component to slide from the board list view to the board detail
    view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An **Accordion** component to render the filtering options in the left-hand
    side panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Row** and **Column** components to control the HTML layout of boards in our
    board list view, as well as in the board detail view.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Table CSS elements to render tables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this chapter, we will not go into detail about how to build HTML pages with
    Bootstrap. We will instead start with a working version that you can find in the
    sample code under the directory /`tscode/tests/brackets/TestBootstrap.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Bootstrap elements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Bootstrap](img/9665OS_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At the top of our page is the navbar element, which has been given a `navbar-inverse`
    style to render it with a black background. The **carousel panel 1** element is
    the first carousel panel, and contains the left-hand side filter panel, as well
    as the board list and the **show / hide panel** button. The **filter** options
    on the left-hand side panel use the Bootstrap accordion component. Finally, our
    footer is styled to be a "sticky footer", meaning that it will always show on
    the page.
  prefs: []
  type: TYPE_NORMAL
- en: When we click on any one of the boards in the board list, our carousel component
    will slide the carousel panel over to the left, and slide in the board detail
    view from the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our board detail panel is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Bootstrap](img/9665OS_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Again, we have the standard header and footer regions, but this time, we are
    viewing **carousel panel 2**. This panel has a back button on the top left-hand
    side, and shows the detailed information on the selected board.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice when you run this test page, that there are four links in the
    footer region named **next**, **prev**, **show**, and **hide**. These buttons
    are used to test the cycling of the carousel panels, and the show / hide functionality
    for the left hand-side panel.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap is ideal for building quick mock-ups of a working version of the site.
    This version can easily be taken to customers, or to project meetings for demo
    purposes. Showing a customer a demo mockup of a site will give you invaluable
    feedback on the overall site's flow and design. Ideally, this sort of work should
    be done by a senior web designer, or someone with equal skill set—who specializes
    in CSS styling.
  prefs: []
  type: TYPE_NORMAL
- en: We will be reusing and reworking this HTML later on when we start to build Marionette
    views. It is a good idea, however, to keep these demo HTML pages within your project,
    so that you can test their look and feel on different browsers and devices, all
    the while tweaking your HTML layout and CSS styles.
  prefs: []
  type: TYPE_NORMAL
- en: Data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a real-world application, data for websites would be stored and retrieved
    from a database of some sort. To use the data within a JavaScript web page, these
    data structures would be serialized to JSON format. Marionette uses standard Backbone
    models and collections for loading and serializing data structures. For the purpose
    of this sample application, our data structure will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data structure](img/9665OS_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Class diagram of ManufacturerCollection and related Backbone models
  prefs: []
  type: TYPE_NORMAL
- en: 'The source of our data is the `ManufacturerCollection`, which will have a `url`
    property to load data from our site. This `ManufacturerCollection` holds a collection
    of `ManufacturerModels`, that are available via the `models` property. The `ManufacturerCollection`
    also implements two interfaces: `IManufacturerCollection` and `IFilterProvider`.
    We will discuss these two interfaces later on.'
  prefs: []
  type: TYPE_NORMAL
- en: The properties of the `ManufacturerModel` will be used to render a single manufacturer's
    name and logo to the DOM. Each `ManufacturerModel` also has an array named `boards`,
    which holds an array of `BoardModels`.
  prefs: []
  type: TYPE_NORMAL
- en: Each `BoardModel` has properties that are necessary for rendering, as well as
    an array named `board_types`, which holds an array of `BoardType` classes. A `BoardType`
    is a simple string, and will hold a value of either "Wave", "Freestyle", or "Slalom".
  prefs: []
  type: TYPE_NORMAL
- en: Each `BoardModel` will also have an array of `sizes`, holding a `BoardSize`
    class, containing detailed information on the available sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the JSON data structure that is used to serialize the preceding
    object structure, would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In our sample application, a full JSON dataset can be found at `/tscode/tests/boards.json`.
  prefs: []
  type: TYPE_NORMAL
- en: Data interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to use this JSON data structure within TypeScript, we will need to
    define a set of interfaces to describe the above data structure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'These interfaces simply match the model properties in the previous diagram,
    and we can then build the corresponding `Backbone.Model` classes that implement
    these interfaces. Note that for brevity, we have not listed each individual property
    of each model here, so be sure to refer to the accompanying source code for a
    full listing. Our Backbone models are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Each class extends `Backbone.Model`, and implements one of the interfaces that
    we have defined earlier. There is not much to these classes, except for defining
    a `get` and `set` method for each property, and using the correct property type.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, our models are in place, and we can write a few unit tests,
    just to make sure that we can create our models correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We start with a simple test that creates a `BoardType` model, and then test
    that the `board_type` property has been set correctly. Similarly, we can create
    a test for the `BoardSize` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This test is also just creating an instance of the `BoardSize` model, but it
    is using the `beforeAll` Jasmine method. For brevity, we are only showing one
    test, which checks the `volume` property, but in a real-world application we would
    test each of the `BoardSize` properties. Finally, we can write a test of the `BoardModel`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we are creating a `BoardModel` instance in our `beforeAll` function,
    and then testing that the properties are set correctly. Note the tests near the
    bottom of this code snippet: we are checking whether the `sizes` property and
    `board_types` properties have been built correctly, and that they are in fact
    arrays that can be referenced with `[]` array notation.'
  prefs: []
  type: TYPE_NORMAL
- en: In the accompanying source code, you will find further tests for these models,
    as well as tests for the `ManufacturerModel`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note how each model is constructed with a simple cut-and-paste of sections of
    the original JSON sample. When Backbone models are hydrated through RESTful services,
    these services are simply returning JSON—and our tests are, therefore, matching
    what Backbone itself would be doing.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this stage, you may wonder why we are writing these sort of tests, as they
    might seem trivial, and are just checking whether certain properties have been
    constructed correctly. In real-world applications, models change quite frequently,
    especially in the beginning stages of a project. It is quite common to have one
    developer, or a portion of the team, who are responsible for the backend databases
    and server-side code that deliver JSON to the frontend. Another another team may
    be responsible for working on the frontend JavaScript code. By writing tests like
    these, you are clearly defining what your data structures should look like, and
    what properties you are expecting in your models. If a change is made server side
    that modifies a data structure, your team will be able to quickly identify where
    the cause of the problem lies.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason to write property-based tests is that Backbone, Marionette, and
    just about any other JavaScript library will use these property names to render
    HTML to the frontend. If you have a template that is expecting a property called
    `manufacturer_logo`, and you change this property name to `logo_image`, then your
    rendering code will break. These errors are quite often difficult to track down
    at runtime. Following the Test Driven Development mantra of "fail early, and fail
    loudly", our model property tests will quickly highlight these potential errors,
    should they occur.
  prefs: []
  type: TYPE_NORMAL
- en: Once a series of property-based tests are in place, we can now focus on an integration
    test that will actually call the server-side code. This will ensure that our RESTful
    services are working correctly, and that the JSON data structure that our site
    is generating matches the JSON data structure that our Backbone models expect.
    Again, if two separate teams are responsible for client-side and server-side code,
    this sort of integration test will ensure that the data exchange is consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be loading our data for this application through a `Backbone.Collection`
    class, and this collection will need to load multiple manufacturers. To this end,
    we can now build a `ManufacturerCollection` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very simple `Backbone.Collection` class, which just sets the `model`
    property to our `ManufacturerModel`, and the `url` property to `/tscode/boards.json`.
    As our sample application does not have a backend database or REST services, so
    we will just load our JSON from disk at this stage. Note that even though we are
    using a static JSON file in this test, Backbone will still issue an HTTP request
    back to our server in order to load this file, meaning that any test of this `ManufacturerCollection`
    is, in fact, an integration test. We can now write some integration tests to ensure
    that this model can be loaded correctly from the `url` property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We are again using the Jasmine `beforeAll` syntax to set up our `ManufacturerCollection`
    instance, and then calling `fetch({ async: false })` to wait for the collection
    to be loaded. We then have two tests, one to check that we are loading three manufacturers
    into our collection, and another to check the `Manufacturer` model at index `2`.'
  prefs: []
  type: TYPE_NORMAL
- en: Traversing a collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a full `ManufacturerCollection` loaded, we can turn our attention
    to processing the data that it contains. We will need to search this collection
    to find two things: a list of manufacturers, and a list of board types. These
    two lists will be used by our filtering panel on the left-hand side panel. In
    a real-world application, these two lists may be provided by server-side code,
    returning simple JSON data structures to represent these two lists. In our sample
    application, however, we will show how to traverse the main manufacturer Backbone
    collection that we have already loaded. The filtering data structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Traversing a collection](img/9665OS_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: FilterCollection class diagram with related Backbone models
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than listing the full implementation of Backbone models shown in the
    preceding diagram, we will take a look at the TypeScript interfaces instead. Our
    interfaces for these filtering models are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We start with a `FilterType` enum, which we will use to define each of the types
    of filters we have available. We can filter our board list by either manufacturer
    name, board type, or clear all filters by using the `None` filter type.
  prefs: []
  type: TYPE_NORMAL
- en: The `IFilterValue` interface simply holds a string value that will be used for
    filtering. When we are filtering by board type, this string value would be one
    of "Wave", "Freestyle", or "Slalom", and when we are filtering by manufacturer,
    this string value will be the name of the manufacturer.
  prefs: []
  type: TYPE_NORMAL
- en: The `IFilterModel` interface will hold the `FilterType`, a name for the filter,
    and array of `filterValues`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a Backbone model for each of these interfaces, meaning that
    we will end up with two Backbone models, named `FilterValue` (which implements
    the `IFilterValue` interface), and `FilterModel` (which implements the `IFilterModel`
    interface). To house a collection of `FilterModel` instances, we will also create
    a Backbone collection named `FilterCollection`. This collection has a single method
    named `buildFilterCollection`, which will use an `IFilterProvider` interface to
    build its internal array of `FilterModels`. This `IFilterProvider` interface is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Our `IFilterProvider` interface has two functions. The `findManufacturerNames`
    function will return a list of manufacturer names (and their associated logos),
    and the `findBoardTypes` function will return a list of strings of all board types.
    This information is all that is needed to build up our `FilterCollection` internal
    data structures.
  prefs: []
  type: TYPE_NORMAL
- en: All of the values needed to populate this `FilterCollection` will come from
    data that is already contained within our `ManufacturerCollection`. The `ManufacturerCollection`
    will, therefore, need to implement this `IFilterProvider` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Finding manufacturer names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s continue working within our test suite to flesh out the functionality
    of the `findManufacturerNames` function that the `ManufacturerCollection` will
    need to implement, as part of the `IFilterProvider` interface. This function returns
    an array of type `IManufacturerName`, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now build a test using this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This test is reusing the `manufacturers` variable that we set up in our previous
    test suite. It then calls the `findManufacturerNames` function, and expects the
    results to be an array of three manufacturer names, i.e. `"JP Australia"`, `"RRD",`
    and `"Starboard"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can update the actual `ManufacturerCollection` class, in order to provide
    an implementation of the `findManufacturerNames` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we are using the Underscore utility function named `map` to
    loop through our collection. Each Backbone collection class has an internal array
    named `models`. The `map` function will loop through this `models` property, and
    call the anonymous function for each item in the collection, passing the current
    model into our anonymous function via the `iterator` argument. Our code then builds
    a JSON object with the required properties of the `IManufacturer` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The TypeScript compiler will generate errors if the returned object does not
    conform to the `IManufacturer` name interface.
  prefs: []
  type: TYPE_NORMAL
- en: Finding board types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can now focus on the second function of the `IFilterProvider` interface,
    named `findBoardTypes` that the `ManufacturerCollection` will need to implement.
    Here is the unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This test calls the `findBoardTypes` function, which will return an array of
    strings. We are expecting the returned array to contain three strings: `"Wave"`,
    `"Freestyle"`, and `"Slalom"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding function in our `ManufacturerCollection` class is then implemented
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of the `findBoardTypes` function starts by creating a new
    string array named `boardTypes`, which will hold our results. We then use the
    Underscore `each` function to loop through each manufacturer. The Underscore `each`
    function is similar to the `map` function, and will iterate through each item
    in our collection. We then loop through each board in the manufacturer's arsenal,
    and through each board type listed per board. Finally, we are testing to see whether
    the board type collection contains an item already, using the underscore `_.contains`
    function. If it does not already have the board type in the array, we push the
    `board_type` string into our `boardTypes` array.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Underscore library has numerous utility functions available for searching,
    manipulating, and modifying arrays and collections—so be sure to consult the documentation
    to find suitable functions for use in your code. These functions are not limited
    to Backbone collections only, and can be used on any type of array.
  prefs: []
  type: TYPE_NORMAL
- en: This completes our work on the `IFilterProvider` interface, and its implementation
    within the `ManufacturerCollection` class.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering a Collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a user clicks on a filter option on the left-hand side panel, we will
    need to apply the selected filter to the data contained within our manufacturer
    collection. In order to do this, we will need to implement two functions, named
    `filterByManufacturer`, and `filterByBoardType` within the `ManufacturerCollection`
    class. Let''s start with a test to filter our collection by manufacturer name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This test calls the `filterByManufacturer` function, expecting only a single
    manufacturer to be returned. With this test in place, we can create the real `filterByManufacturer`
    function on the `ManufacturerCollection` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the Underscore function named `filter` to apply a filter
    to our collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second filtering function is by board type, and is a little more complicated.
    We will need to loop through each manufacturer in our collection, then through
    each board, and then through each board type. If we find a match for the board
    type, we will flag this board to be included in the result set. Before we tackle
    the `filterByBoardType` function, let''s write a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Our test calls the `filterByBoardType` function, using the string `"Slalom"`
    as a filter. Remember that this function will return a collection of `ManufacturerModel`
    objects at the top level, with the `boards` array within each of these objects
    filtered by board type. Our test then loops through each manufacturer, and each
    board in the result set, and then uses the Underscore function called `some` to
    test whether the `board_types` array has the correct board type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code to implement this function on the `ManufacturerCollection` is also
    a little tricky, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Our `ManufacturerCollection` class instance holds the entire collection that
    was loaded via the JSON file from the site. In order to keep this data for repeated
    filters, we will need to construct a new `ManufacturerModel` array to return from
    this function – so that we do not to modify the underlying "global" data. Once
    we have constructed this new array, we can then loop through each manufacturer.
    If we find a board matching the required filter, we will set a flag named `hasBoardType`
    to true, to indicate that this manufacturer must be added to our filtered array.
  prefs: []
  type: TYPE_NORMAL
- en: Each manufacturer in this filtered array will also need to list only the board
    types that match our filter criteria, so we will need another array—called `boardMatches`—to
    hold these matching boards. Our code will then loop through each board, and check
    whether it has the required `board_type`. If so, we will add it to the `boardMatches`
    array and set the `hasBoardType` flag to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have looped through each board for a manufacturer, we can check the
    `hasBoardType` flag. If our manufacturer has this board type, we will construct
    a new `ManufacturerModel`, and then set the `boards` property on this model to
    our in-memory array of the matching boards.
  prefs: []
  type: TYPE_NORMAL
- en: Our work with the underlying Backbone collections and models is now complete.
    We have also written a set of unit and integration tests to ensure that we can
    load our collection from the site, build our filtering lists from this collection,
    and then apply a particular filter to this data.
  prefs: []
  type: TYPE_NORMAL
- en: Marionette application, regions and layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now focus our attention on building the application itself. In Marionette,
    this is achieved by creating a class that derives from `Marionette.Application`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined a class named `BoardSalesApp` that derives from the `Marionette.Application`
    class, and will serve as the starting point for our application. Our constructor
    function is fairly simple, and creates a new instance of the `PageViewLayout`
    class, which we will discuss shortly. The only other function in our application
    is the `onStart` function, which renders our `PageViewLayout` to the screen. This
    `onStart` function will be triggered by Marionette when the application starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `PageLayoutView` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This class extends from `Marionette.LayoutView`, and does two important things.
    Firstly, it sets a number of properties on the `options` object, and then calls
    the base class constructor via the `super` function, passing in this `options`
    object. One of the properties of this `options` object is named `el`, and contains
    the name of the DOM element that this view will render into. In this code snippet,
    this `el` property is set to the DOM element `'#page_wrapper'`. Without this `el`
    property set, we will just get a blank screen when we try to render the viewto
    the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: The second important step in our constructor is to load a snippet from the `SnippetService`.
    This snippet is then used to set the `template` property on the `options` object.
    Marionette, similar to Backbone, loads a template, and then combines the underlying
    model properties with the view template, in order to generate the HTML that will
    be rendered to the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, in order to run our `BoardSalesApp`, and have it render the `PageViewLayout`
    to the DOM, we will need two things. The first is a DOM element in our `index.html`
    page with an `id="page_wrapper"`, to match our `options.el` property, and the
    second is our `PAGE_VIEW_LAYOUT_SNIPPET`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `index.html` page is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This page includes the `bootstrap.css` and `app.css` style sheets, as well as
    a call to Require, with the `data-main` attribute set to a Require config file
    named `/tscode/app/AppConfig`. The body of the `index.html` page just includes
    the DOM element with `id="page_wrapper"`, and a footer. This is a very stripped-down
    version of the demo HTML page that we built earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have also included a script named `head-1.0.3.js`, which can be installed
    via the NuGet package `HeadJS`. This script interrogates our browser to find out
    whether it is running on a mobile or desktop device, what browser we are using,
    and even what the current screen size is. We will use the output of `head.js`
    later in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now need to create an HTML snippet for the `PageViewLayout`. This file
    is called `PageViewLayout.html`, and resides in the `/tscode/app/views` directory,
    so it can be easily found when we are working with the `PageViewLayout.ts` file.
    Take a look at the sample code for a full listing of this HTML file, which includes
    the following relevant sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Our `PageViewSnippet.html` file contains the major elements of our page. We
    have the `main_panel_div` that serves as the middle panel of our application,
    with a `carousel-inner` div that contains our two carousel panel divs, named `carousel_panel_1`
    and `carousel_panel_2`. Within these carousel panels, we will be rendering the
    filter panel, board list panel and board detail panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to put together our `AppConfig.ts` file that Require will load,
    and set up the `SnippetService` to load the `PageViewLayout.html` snippet. In
    the interests of brevity, we have not listed the full `require.config` here, and
    have excluded the `paths` and `shims` section. We will just focus on the call
    to Require as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we included the `BoardSalesApp`, `tinyioc`, and `snippetservice`, as well
    as our `PageViewLayout.html` snippet in the call to require. We then set up the
    `SnippetService`, store the `pageViewLayoutSnippet` against the correct key, and
    register the `SnippetService` with our service locator. To start our Marionette
    application, we create a new instance of the `BoardSalesApp`, and call `start`.
    Once the `start` method is called, our `BoardSalesApp.onStart` method will be
    fired by Marionette, which will then render the `PageViewLayout` class.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the main collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this application, we will be loading our `ManufacturerCollection` only once,
    and then reusing this "global" collection for filtering purposes. Let''s now update
    our `BoardSalesApp` to include this "global" collection, and load it on application
    startup. Again, refer to the sample code for a full listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We have updated our `BoardSalesApp` to store an instance of the `ManufacturerCollection`
    class in the private variable named `_manufCollection`. Our `onStart` function
    has been updated to instantiate this collection, after the call to `viewLayout.render`.
    Note the next call to `TypeScriptTinyIoC`. We are registering `this._manufCollection`
    as a service that will implement the `IIManufacturerCollection` named interface.
    We then call the Backbone `fetch` function on the collection, with a `success`
    and `error` callback. Both the `success` callback and `error` callback simply
    raise an event.
  prefs: []
  type: TYPE_NORMAL
- en: 'By registering our instance of the `ManufacturerCollection` class against the
    named interface `IIManufacturerCollection`, any of our classes that need access
    to the main collection can simply request the instance of this class from our
    service locator. These named interfaces are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need to modify our `ManufacturerCollection` class to implement
    the `IManufacturerCollection` interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now have a look at the events that will be fired from our `success`
    and `error` callbacks. In the `success` function callback, we are raising an event
    of type `INotifyEvent`. Note that we are just listing the interface definitions
    here—for the corresponding `IInterfaceChecker` classes and event classes, please
    refer to the accompanying source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined an `EventType` enum to hold an event type, and then defined
    an `INotifyEvent` interface that just holds a property named `eventType`. We have
    also defined the corresponsing `INotifyEvent_Handler` interface that any handler
    will need to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our error event will use inheritance to derive from these interfaces as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are are deriving the `IErrorEvent` interface from `INotifyEvent`, thereby
    reusing the `EventType` enum and properties from the base interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now respond to these events in our `PageViewLayout` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We have implemented the `INotifyEvent_Handler` interface, and registered with
    `TypeScriptTinyIoC` for the `IINotifyEvent`. Our `handle_NotifyEvent` class will
    check that the event type is a `ManufacturerDataLoaded` event, and then create
    an instance of the `ManufacturerCollectionView` class and render it to the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Marionette views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Marionette provides a number of different view classes for us to use, based
    on what type of object we need to render to the DOM. Any class that needs to render
    a `Backbone.Collection` can use a `CollectionView`, and any class that needs to
    render a single item in this collection can use an `ItemView`. Marionette also
    provides a hybrid of these two views called a `CompositeView`. If we take a look
    at our demo application, we will be able to break up our screen into a number
    of logical views, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Marionette views](img/9665OS_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Board list view with Marionette view overlay
  prefs: []
  type: TYPE_NORMAL
- en: 'The identification of what views we need to build are pretty closely related
    to the data structure that we have in place for our Backbone collections and models.
    This relationship is clearly seen when we superimpose the preceding views on top
    of our class diagram for our `ManufacturerCollection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Marionette views](img/9665OS_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Model class diagram with corresponding Marionette Views
  prefs: []
  type: TYPE_NORMAL
- en: The ManufacturerCollectionView class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We start with a `ManufacturerCollectionView`, which is a view that renders the
    whole `ManufacturerCollection`. We will also need a `ManufacturerView` to render
    a particular `ManufacturerModel`, and then a `BoardView` to render each board
    in a manufacturer's arsenal. Each board has an internal array of `BoardSize` objects,
    so we will create a `BoardSizeView` to render these items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets start building these views, starting with the `ManufacturerCollectionView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This class extends from `Marionette.CollectionView`, and specifies our `ManufacturerModel`
    as the generic type for the class. Our `constructor` sets the `el` property of
    the `options` object to be `"#manufacturer_collection"`. As we saw with our `PageLayoutView`,
    Marionette will use this property to render the entire collection into the DOM.
    We have also set a `className` property in our `options`. Marionette will use
    the `className` property to append a `class="…"` attribute to the outer DOM element.
    This will apply the CSS styles of `row` and `board_row` to the `manufacturer_collection`
    element in the rendered HTML. Once we have constructed our `options` correctly,
    we call `super(options)` to pass these options to the base class constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The `childView` property of a `CollectionView` instructs Marionette to create
    an instance of the class we specify for each element that it finds in the collection.
    We have set this `childView` property to be `ManfuacturerView`, so Marionette
    will construct a new `ManufacturerView` for each element in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in our constructor, we are using our service locator pattern to look
    up an instance of our `ManufacturerCollection` service, and then we set the internal
    `this.collection` property to the returned object. Once we have defined a `childView`
    class name, and set the `this.collection` property, Marionette will automatically
    create instances of our child views, and render them to the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we don't need an HTML template or snippet for a `CollectionView`.
    This is because we are deferring the rendering of an individual item to the `childView`
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: The ManufacturerView class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our `childView` class, `ManufacturerView`, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this instance, we are deriving our view from `Marionette.CompositeView`,
    and using a standard `Backbone.Model` for the generic type. Because we have multiple
    manufacturers in our board list view, we don't really need to render anything
    specific for each manufacturer. Therefore, our template is a simple `<div></div>`.
  prefs: []
  type: TYPE_NORMAL
- en: The important part of this view is to set up a new `Backbone.Collection` for
    our `boards` array, and then set a `childView` class to render each `board` in
    the collection. Our `childView` property is set to `BoardView`, and we are also
    setting a `childViewOptions` property that will be sent through to each `BoardView`
    instance. Remember that each `BoardView` shows the manufacturer logo, but this
    logo image is held at the manufacturer level. Therefore, we need to pass this
    information down to each `BoardView` that is created. Marionette allows us to
    use the `childViewOptions` property to pass any extra properties down to the child
    view. Here, we have defined a `parentIcon` property as part of this `childViewOptions`
    object, in to order pass down the manufacturer logo to each instance of a child
    `BoardView` class. This `parentIcon` property will then be available to the child
    view via the `options` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The BoardView class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our `BoardView` class is also a `CompositeView` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This `BoardView` constructor does a couple of things. Firstly, it retrieves
    the snippet named `BOARD_VIEW_SNIPPET` to use as its own `template`. It then sets
    an internal model property named `parentIcon` to store the `parentIcon` property
    that was passed in via the `options` parameter from the parent view. We then create
    a new `Backbone.Collection` for the `sizes` array, and set the `childView` property
    to `BoardSizeView`. The `childViewContainer` property tells Marionette that there
    is a `<tbody></tbody>` HTML div within our snippet that it should use to render
    any `childView` into. Finally, we retrieve another snippet named `BOARD_SIZE_MINI_VIEW_SNIPPET`,
    and pass this snippet through to the `childView` as a `template` property.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of each `BoardSizeView` class resolving its own HTML snippet, we have
    moved control of which snippet to use up in the class hierarchy, to the parent
    of the `BoardSizeView`. This allows us to reuse the `BoardSizeView` class within
    this summary view, as well as in the `BoardDetailView`, which we will discuss
    later. As the internal data models are identical for the summary size view and
    the detail size view, all that will need to change is our HTML template. We therefore
    pass this template down into the `BoardSizeView` using the `childViewOption` properties,
    as we have seen previously.
  prefs: []
  type: TYPE_NORMAL
- en: The BoardSizeView class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our `BoardSizeView` class could not be simpler, and is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This class is simply an `ItemView`, which is using the `BoardSize` model as
    the generic type. We don't have any custom code within this class, but we are
    simply using it as a named `childView` in our preceding `BoardView` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look now at the HTML snippets that we will need for each of these
    views. First up is our `BoardViewSnippet.html`. Again, you can find the full snippet
    in the accompanying source code. The general structure of the `BoardViewSnippet.html`
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we have included the `<%= name %>`, `<%= description %>`, `<%=
    parentIcon %>` and `<%= image %>` syntax as placeholders for our model properties.
    Near the bottom of the snippet, we have created a table with an empty `<tbody></tbody>`
    tag. This tag corresponds to the `childViewContainer` property that we used in
    our `BoardView` class, and Marionette will render each `BoardSizeView` item into
    this `<tbody>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `BoardSizeMiniViewSnippet.html` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are only interested in the `<%= volume %>` property of the `BoardSize`
    model. With these view classes and two snippets in place, our board list view
    is complete. All we need to do is to load these snippets up in our `require.config`
    block, and store the appropriate snippets on our `SnippetService` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Filtering using the IFilterProvider interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we put together the `ManufacturerCollection` class, we wrote two functions
    to query the data structure, and return a list of manufacturers and board types.
    These two functions were called `findManufacturerNames` and `findBoardTypes` respectively.
    Our new `FilterCollection` class will need to call these methods to retrieve the
    filter values from our "global" dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could implement this functionality in two ways. One way would be to get
    a reference to the global `ManufacturerCollection` instance via the `IIManufacturerCollection`
    named interface. This option, however, would mean that the code for the `FilterCollection`
    would need to understand the code for the `ManufacturerCollection`. A better way
    of implementing this functionality would be to get a reference to an `IFilterProvider`
    interface. This interface would then just expose the two methods that we need
    to build our list of filters. Let''s take this second approach, and define a named
    interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then simply modify the existing `ManufacturerCollection` to implement
    this interface (which it already does):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now register the `ManufacturerCollection` with `TypeScriptTinyIoC` against
    the `IIFilterProvider` named interface in our `BoardSalesApp.onStart` method,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Our `ManufacturerCollection` is now registered to provide both the `IIManfacturerCollection`
    named interface, as well as the `IIFilterProvider` named interface.
  prefs: []
  type: TYPE_NORMAL
- en: The FilterCollection class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our `FilterCollection` can then resolve the `IIFilterProvider` interface in
    its constructor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are storing the class that is returned by the call to `TypeScriptTinyIoC`
    in a private variable named `_filterProvider`. By defining these interfaces for
    a `FilterProvider`, we can now unit test our `FilterCollection` with a mock `FilterProvider`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In the setup for our tests, we are creating a `MockFilterProvider` that implements
    our `IFilterProvider` interface, and we have registered it for the purposes of
    our tests. By using a mock provider, we also know exactly what data to expect
    within our tests. Our actual tests will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'These tests start by creating an instance of the `FilterCollectionClass`, and
    then call the `buildFilterCollection` function. We then test that the collection
    has a `FilterType.Manufacturer` at index `0`, along with expected values. With
    these failing tests in place, we can flesh out the `buildFilterCollection` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Our `buildFilterCollection` function is creating three instances of a `FilterModel`.
    The first instance, named `manufFilter` has its `filterType` set to `FilterType.Manufacturer`,
    and uses the `_filterProvider.findManufacterNames` function to build up the values
    for this `FilterModel`. The `manufFilter` instance is then added to the internal
    `collection` via the call `this.push(manufFilter)`. The second and third `FilterModel`
    instances have their `filterType` set to `FilterType.BoardType` and `FilterType.None`
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Again, the relationship between the Marionette views that we need to implement,
    and the underlying Backbone collections and models that we have, is easy to visualize
    when we superimpose the views on top of our Backbone models as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Filtering views](img/9665OS_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Filtering class diagram showing related Marionette views
  prefs: []
  type: TYPE_NORMAL
- en: The first view, named `FilterCollectionView`, will be derived from `CollectionView`,
    and will be tied to our top-level `FilterCollection`. The second view, named `FilterModelView`
    will be a `CompositeView`, and will render each `FilterType` to its own accordion
    header. The third and final view will be an `ItemView` for each of the filter
    options, and is named FilterItemView.
  prefs: []
  type: TYPE_NORMAL
- en: Building these Marionette views is a very similar process to what we have done
    with the previous manufacturer and board views. For this reason, we will not go
    into detail here on the implementation of each view. Be sure to refer to the sample
    code included with this chapter for full listings of these views and their relevant
    HTML snippets.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our filters rendering on the left-hand side panel, we will
    need to be able to respond to a click event on the `FilterItemView`, and trigger
    the actual filtering code.
  prefs: []
  type: TYPE_NORMAL
- en: DOM events in Marionette
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Marionette provides a simple syntax for trapping DOM events. Any view has an
    internal property named `events`, which will bind DOM events to our Marionette
    views. Our `FilterItemView`, then, can be updated to respond to DOM events as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We have added an `events` property to our `options` object, and registered a
    handler function for the `click` DOM event. Whenever someone clicks on a `FilterItemView`,
    Marionette will invoke the `filterClicked` function. We have also added a call
    to `_.bindAll` for this event, to ensure that the `this` variable is scoped to
    the class instance whenever the `filterClicked` function is called.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that each instance of this `FilterItemView` has a corresponding `FilterValue`
    model available to it via the internal `model` property. So, within our `filterClicked`
    function, we are simply raising a new `FilterEvent`, using properties from the
    internal `model` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our event definition interfaces are as follows—again, please refer to the sample
    code for the matching `IInterfaceChecker` definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now register handlers for these filter events elsewhere in our code.
    The logical place to put this event handler is on the `PageViewLayout` itself,
    as this class is responsible for rendering the board list. We will define our
    `handle_FilterEvent` function on the `PageViewLayout` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This function starts by obtaining a reference to our "global" registered `ManufacturerCollection`.
    We then define a variable named `filteredCollection` to hold our filtered version
    of the main `ManufacturerCollection`. Based on the `FilterType` within the event
    itself, we call either `filterByBoardType`, or `filterByManufacturer`. If the
    event type is `FilterType.None`, we simply set the `filteredCollection` to the
    `mainCollection`, effectively clearing all filters.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of this function sets the internal `collection` property of our
    main view (`this._manufacturerView`) to the resultant `filteredCollection`, and
    then calls `render`.
  prefs: []
  type: TYPE_NORMAL
- en: Our application is now responding to a click event on the `FilterItemView`,
    raising an event, and re-rendering the `ManufacturerView`, in order to apply the
    selected filter to our data for rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering a Detail view event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have another click event, however, that we need to respond to. When a user
    clicks on a particular board, we need to fire an event that will slide the panels
    over, and show the board detail view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move onto the board detail view and how it is rendered, let''s first
    hook up a click event on the `BoardView` class. To do so, we just need to specify
    a click event handler on the `options.events` parameters on the `BoardView` class,
    similar to our previous click event handler. We will also need to create an `onClicked`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The changes to this class are fairly minimal, we just set the `events` property
    on our `options` correctly, issue a call to `_.bindAll`, as we did in our `FilterItem`
    code, and then write an `onClicked` function. This `onClicked` function issues
    a call to `flip` as we saw in [Chapter 7](ch07.html "Chapter 7. Modularization"),
    *Modularization*, and then raises a new `BoardSelectedEvent`. Our `BoardSelectedEvent`
    interface and handler interfaces are as follows—again, please refer to the sample
    code for the matching `IInterfaceChecker` definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `BoardSelectedEvent` simply contains the entire `BoardModel` itself, in
    the `selectedBoard` property. With these event interfaces and clases in place,
    we can now register for a `BoardSelectedEvent` anywhere in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the BoardDetailView
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this application, the logical place for handling this `BoardSelectedEvent`
    would be in the `PageViewLayout`, as it is responsible for cycling the carousel
    panels, and rendering the `BoardDetailView`. Let''s update this class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have upated our `PageViewLayout` class to implement the `IBoardSelectedEvent_Hander`
    interface, and registered it with `TypeScriptTinyIoC`. We are responding to the
    `BoardSelectedEvent` by creating a new `BoardDetailView` class, using the full
    `BoardModel` included in the event, and then calling `render`. Our `BoardDetailView`
    class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `BoardDetailView` class is very similar to our `BoardView`, but it uses
    the `"#board_detail_view"` element for the `options.el` property—which is our
    corresponding DOM element. Our snippet has the `BOARD_DETAIL_VIEW_SNIPPET` key.
    We then create a `Backbone.Collection` out of the `sizes` property, and set the
    `childView` to the `BoardSize` view class template, in the same way that we did
    earlier for the `BoardView`.
  prefs: []
  type: TYPE_NORMAL
- en: Our `childViewContainer`, however, now targets the `<tbody></tbody>` tag to
    render children into. We are also passing the template from the `BOARD_SIZE_VIEW_SNIPPET`
    to the child `BoardSize` view, and setting the `tagName` to `'tr'`. Remember how
    we moved the configuration of the child `BoardSize` views up one level in our
    `BoardView`? Well, we are doing the same thing here.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the sample code for a full listing of the `BoardDetailViewSnippet.html`,
    and the `BoardSizeViewSnippet.html`.
  prefs: []
  type: TYPE_NORMAL
- en: The State Design Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our last task for this application is to control the various screen elements
    as users interact with our application. As a user navigates the application, we
    need to move from carousel panel 1 to carousel panel 2, and update screen elements,
    such as showing and hiding the left-hand side filter panel. In a large web application,
    there may be many screen elements, many different transitions, and things such
    as pop ups or masks that say **"loading…"** while our application fetches data
    from backend services. Keeping track of all of these elements becomes a difficult
    and time-consuming task, often leaving large swathes of if-else or switch statements
    in many different areas of our code, leading to a lot of direct DOM manipulation
    spaghetti.
  prefs: []
  type: TYPE_NORMAL
- en: The State Design Pattern is a design pattern that can simplify our application
    code, so that code that manipulates these various DOM elements can reside in one
    place. The State Design Pattern defines a set of states that the application could
    be in, and provides an easy mechanism to transition between these states, control
    visual screen elements, and handle animations.
  prefs: []
  type: TYPE_NORMAL
- en: Problem space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an example of what we are trying to achieve, consider the following business
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: When a user first logs into the BoardSales application on a desktop, the left-hand
    filter panel should be visible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user is using a mobile device, the left-hand filter panel should not
    be visible when a user first logs in. This is done to save on screen real estate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the filter panel is visible, then the expand icon should switch to a left-hand
    arrow (<) to allow the user to hide it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the filter panel is not visible, then the expand icon should be a right-hand
    arrow (>) to allow the user to show it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a user expands the filter panel, and then switches to a board detail view
    and back again, then the filter panel should remain expanded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a user hides the filter panel, and then switches to a board detail view and
    back again, then the filter panel should remain hidden.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On top of these business rules, we have an outstanding bug that has been reported
    for users on a Firefox browser (you can test this behavior using the demo HTML
    page):'
  prefs: []
  type: TYPE_NORMAL
- en: When clicking on a board in the board list view, with the filter panel open,
    the carousel panel does not behave correctly. The carousel first cycles across
    to the board detail view, and then closes the filter panel. This transition is
    inconsistent with other browsers, where the filter panel is cycled along with
    the board list at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'This bug therefore adds another business requirement to our list:'
  prefs: []
  type: TYPE_NORMAL
- en: For users on a Firefox browser, please hide the filter panel first, before cycling
    the carousel to the board detail view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The State Design Pattern uses a set of very similar classes, each representing
    a particular application state. Each of these state classes are derived from the
    same base class. When we want our application to change to a different state,
    we simply switch to the object that represents the state that we are interested
    in.
  prefs: []
  type: TYPE_NORMAL
- en: For example, our application really has only three states. We have a state where
    the board list and filter panels are both visible. We have another state where
    only the board list is visible, and our third state is where the board detail
    panel is visible. Depending on which state we are in, we should be either on `carousel_panel_1`,
    or on `carousel_panel_2`. Also, the icon that is used in conjunction with the
    filter panel needs to swich from a left-hand chevron `<` to a right-hand chevron
    `>`, depending on the application state.
  prefs: []
  type: TYPE_NORMAL
- en: The State Design Pattern also has the concept of a Mediator class, which will
    keep track of the current state, and contain the logic of how to switch between
    each of these states.
  prefs: []
  type: TYPE_NORMAL
- en: State class diagram
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following class diagram for the State and Mediator Design Pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![State class diagram](img/9665OS_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: State and Mediator pattern class diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with an enum named `StateType` that lists our three application states,
    and second enum named `PanelType` to indicate which carousel panel each of these
    states are on. We then define an interface named `IState` that each of these states
    must implement. To hold properties common to each state, we have also defined
    a base `State` class, from which all states will derive. Our implementation of
    these enums, the `IState` interface, and the base `State` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Our `StateType` enum has defined each state that we will be using. Our application,
    therefore, is either in `BoardListOnly` state, `BoardListWithFilter` state, or
    `BoardDetail` state. Our second enum, named `PanelType`, is used to indicate which
    of the carousel panels we are currently on, either the `Initial` panel (carousel_panel_1),
    or the `Secondary` panel (carousel_panel_2).
  prefs: []
  type: TYPE_NORMAL
- en: We then define an `IState` interface that all state objects must implement.
    This interface allows us to query each state, and determine four important pieces
    of information. The `getPanelType` function tells us what panel we should be currently
    viewing, and the `getStateType` function returns the `StateType` enum value. The
    `getShowFilterClass` function will return a string that is used to apply a CSS
    class to the show / hide filter button, and the `isFilterPanelVisible` function
    returns a boolean to indicate whether or not the filter panel is visible.
  prefs: []
  type: TYPE_NORMAL
- en: Each state needs a reference to the `Mediator` class, so we have created a base
    `State` class with a `constructor` function, from which each of our State objects
    can be derived from.
  prefs: []
  type: TYPE_NORMAL
- en: Concrete State classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s now create concrete classes for each of these states. The first state
    that our application can be in, is when we are viewing the board list, and the
    filter panel is hidden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Our `BoardListOnlyState` class extends the `State` class that we defined earlier,
    and implements the `IState` interface. In this `BoardListOnly` state, we should
    be on the `Initial` carousel panel, the class to be used for the show / hide filter
    panel button should be a `glyphicon-chevron-right` [ `>` ], and the left-hand
    side filter panel should NOT be visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next state that our application could be in, is when the board list is
    showing, and we also have the filter panel visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In the `BoardListWithFilterPanel` state, our carousel panel is again the `Initial`
    panel, but our class for the show / hide filter panel button is now a `glyphicon-chevron-left`
    (`<`). Our filter panel is also visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last state we need to define for our application, is when we have cycled
    over to `carousel_panel_2`, and are viewing the board detail screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the `DetailPanel` state, we are on the `Secondary` carousel panel, we do
    not need a class for the show / hide filter panel button (as the panel has moved
    off the screen), and the filter panel itself is NOT visible.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the sample application source code, you will find a series of unit
    tests that will test each of these properties. For the purposes of brevity, we
    will not list them here.
  prefs: []
  type: TYPE_NORMAL
- en: The Mediator class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In object-oriented patterns, a Mediator is used to encapsulate the logic of
    how a set of objects interacts. In our case, we have a set of states that define
    what visual elements should be shown. There is also a need to define how these
    various elements transition according to the movement between these states.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will, therefore, define a `Mediator` class to encapsulate all of this transition
    logic, and co-ordinate the changes to our visual elements, based on movements
    between states. In order for our `Mediator` class to interact with the UI, we
    will define a set of four functions that must be implemented by any class using
    this `Mediator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Our `IMediatorFunctions` interface has four functions. The `showLeftPanel` function
    will show our filter panel. The `hideLeftPanel` function will hide the filter
    panel. The `cyclePanels` function will be invoked with either a `'prev'` string,
    or a `'next'` string to cycle the carousel panel from `carousel_panel_1` to `carousel_panel_2`.
    The `showFilterButtonChangeClass` will be invoked with two arguments—a `fromClass`
    string that is a CSS class, and a `toClass` string that is another CSS class.
    This function will just remove the `fromClass` CSS class from the DOM element,
    and then add the `toClass` CSS class to the DOM element. In this way, we can change
    the icon used for our show / hide filter button from a chevron-right (`>`) to
    a chevron-left (`<`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now look at the internal logic of the `Mediator` class itself, starting
    with a set of private variables and the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Our `Mediator` class has a number of private variables. The `_currentState`
    variable is used to hold an instance of one of our `State` classes, and represents
    the current state of the UI. This `_currentState` variable can hold any one of
    our three states. The `_currentMainPanelState` variable again holds one of our
    `State` classes, but represents the current state of the main panel. This `_currentMainPanelState`
    will only hold either a `BoardListOnlyState`, or a `BoardListWithFilterPanelState`.
  prefs: []
  type: TYPE_NORMAL
- en: The `_pageViewLayout` variable will hold an instance of the class that implements
    our `IMediatorFunctions` interface, and we will apply state changes to the UI
    through this variable. For those of you familiar with the MVP pattern, the `Mediator`
    class is acting as a Presenter, and the `_pageViewLayout` variable is acting as
    the View.
  prefs: []
  type: TYPE_NORMAL
- en: The `_isMobile` variable just holds a boolean value indicating whether or not
    we are on a mobile device. We will set this variable a little later.
  prefs: []
  type: TYPE_NORMAL
- en: We then have three private variables that will hold instances of our three states—
    `BoardListOnlyState`, `DetailPanelState`, and `BoardListWithFilterPanelState`.
  prefs: []
  type: TYPE_NORMAL
- en: Our constructor simply sets up these private variables, and then instantiates
    an instance of each of our state classes, assigning them to the correct internal
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note the code near the bottom of the constructor. This is the implementation
    of one of our business rules. If the application is being viewed on a mobile device,
    then the filter panel should NOT be visible by default. We are, therefore, setting
    the value of the `_currentState` variable to one of the initial states, based
    on our `isMobile` flag. To round out our constructor function, we also set the
    initial value of the `_currentMainPanelState` variable to the `_currentState`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next `Mediator` function, `getNextState`, simply returns one of our private
    `State` variables, using a `StateType` enum as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This is essentially a mini factory method, and will return the correct internal
    `State` object, based on the value of the `StateType` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Moving to a new State
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main body of logic that controls how the UI needs to be updated, based
    on the movement between states, is implemented in the `moveToState` function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will be called whenever we want to move from one state to another.
    The first thing this function does, is to set up two variables: `previousState`
    and `nextState`. The `previousState` variable is actually our current state object,
    and the `nextState` variable is a `State` object for the state that we are moving
    to.'
  prefs: []
  type: TYPE_NORMAL
- en: We can now compare the `previousState` variable with the `nextState` variable
    and make some decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic for our first if statement goes something like this: if we are moving
    from an `Initial` panel type to a `Secondary` panel, then call the relevant functions
    on the UI to hide the left panel, and initiate a carousel cycle to `''next''`.
    This logic will fix the Firefox bug that we were notified of earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic for our second if statement is the opposite of the first one: if
    we are moving from a `Secondary` panel to an `Initial` panel, then initiate a
    carousel cycle with `''prev''`.'
  prefs: []
  type: TYPE_NORMAL
- en: The next step in our logic applies the class for the show / hide filter button
    to the UI, by calling the `showFilterButtonChangeClass` function on the UI, passing
    in the CSS class name from the `previousState`, and the CSS class name from the
    `nextState` as arguments. Remember that this will remove the CSS class from `previousState`,
    and then add the CSS class from `nextState` to the show / hide filter button CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Our next logical step checks whether the filter panel should be shown or hidden,
    and calls the corresponding function on our `_pageViewLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: As we are now done with our state change logic, and can set the value of the
    `_currentState` variable to now hold our `nextState`.
  prefs: []
  type: TYPE_NORMAL
- en: The last piece of logic just checks to see whether we are currently in `BoardListOnly`
    or `BoardListWithFilter` state, and if so, stores the current state in the `_currentMainPanelState`
    variable. This logic will form part of the business rules that we have been given,
    to ensure that when we switch from our main panel to our detail panel and back
    again, the status of the filter panel is maintained correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two more functions in our `Mediator` class to discuss, which are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The first function, called `showHideFilterButtonClicked` is actually the function
    that will need to be called when we click on the show / hide filter button in
    our application. Depending on whether the filter panel is open or closed, the
    behavior of this button will be slightly different. The only object that knows
    what to do, depending on what state the application is in, is the `Mediator` class
    itself. So, we are deferring the decision-making on what to do when the button
    is clicked, to the `Mediator` class.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the `showHideFilterButtonClicked` function just checks
    what our current state is, and then calls a `moveToState` with the correct `nextState`
    as the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you are building a large-scale application, there may be many different
    buttons or screen elements that change slightly depending on what state your application
    is in. Deferring the decision-making logic to a Mediator class provides a simple
    and elegant way of managing all of your screen elements. This business logic is
    captured in one place, and can also be tested thoroughly. Be sure to check the
    sample code for a full suite of tests surrounding the Mediator class.
  prefs: []
  type: TYPE_NORMAL
- en: Our final function, `getCurrentMainPanelState`, simply returns the last known
    state of our main panel, and will be used to implement the business logic for
    remembering whether the filter panel is open or closed.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the IMediatorFunctions interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the `Mediator` class needs to trigger changes to the UI, it calls functions
    on the `IMediatorFunctions` interface, as we have seen previously. Our application,
    therefore, must implement this `IMediatorFunctions` interface somewhere. As the
    `PageViewLayout` class holds references to each of the UI elements we need to
    change, the logical place to implement this interface is on the `PageViewLayout`
    class itself, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We have updated our `PageViewLayout` class to implement all of the functions
    in the `IMediatorFunctions` interface. We have also included a private variable
    named `_mediator` to hold an instance of the `Mediator` class, and set this up
    in our constructor.
  prefs: []
  type: TYPE_NORMAL
- en: As with our other views that need to respond to click events, we have set up
    an `options.events` object to tie a DOM `click` event on the `#show_filter_button`
    DOM element (which is our show / hide button), to the `showHideFilterButtonClicked`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are using jQuery to check whether the main HTML element in our page has a
    class named `mobile`. This class will be set by the `head.js` utility script that
    we included in our `index.html` page at the beginning of this chapter. In this
    way, we are able to determine whether our application is being used on a mobile
    or desktop device.
  prefs: []
  type: TYPE_NORMAL
- en: The `showLeftPanel` and `hideLeftPanel` functions just include the jQuery snippets
    to apply or remove the relevant classes, in order to slide the filter panel in
    or out.
  prefs: []
  type: TYPE_NORMAL
- en: The `cyclePanels` function calls our Bootstrap carousel function with either
    a `'next'` or `'prev'` parameter, as we did in our demo HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: The `showFilterButtonChangeClass` simply removes the `fromClass` CSS style from
    our `show_filter_button` DOM element, and then adds the new `toClass` CSS style.
    Removing and adding these CSS classes will switch the button displayed from a
    left chevron (`<`) to a right chevron (`>`), or vica versa.
  prefs: []
  type: TYPE_NORMAL
- en: When a user clicks on the `#show_filter_button` DOM element, our `showHideFilterButtonClicked`
    method will be invoked. As discussed earlier, we are forwarding this call to the
    `Mediator` instance, so that the `Mediator` logic can make the decision as to
    what to do when the button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering State changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To finish off our State and Mediator Design Pattern, we will now just need to
    call the `Mediator` functions in the right places, in order to trigger the logic
    to move to a different state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first place we call the `moveToState` function is in our `handle_NotifyEvent`,
    when our `ManufacturerDataLoaded` event is triggered. This event only ever occurs
    once in our application, and that is after the `ManufacturerCollection` has been
    successfully loaded. We already have an event handler for this in our `PageViewLayout`
    class, so let''s update this function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Our first `if` statement checks for the `ManufacturerDataLoaded` event type,
    and then creates a new `ManufacturerCollectionView` and calls its `render` function,
    as we have seen previously. We then call the `moveToState` function, passing in
    the Mediator's `currentMainPanelState` as an argument. Remember how we set the
    initial main panel state in the Mediator's constructor, based on whether or not
    the browser was on a mobile device? This call to `moveToState` will use that initial
    state as a parameter, essentially starting the application in the correct state.
  prefs: []
  type: TYPE_NORMAL
- en: Our second `if` statement will trigger a `moveToState` when the user is in the
    `BoardDetail` screen, and clicks on the back button on the header panel. This
    logic again uses the `currentMainPanelState` to restore our board list to the
    correct state, according to our business rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other function within the `PageLayoutView` that will trigger a call to
    `moveToState`, is our handler for a `BoardSelectedEvent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Whenever a user clicks on a board in the board list, a `BoardSelectedEvent`
    is triggered, and we render the `BoardDetailView`. This `BoardDetailView`, however,
    is on the second carousel panel, so we will need to move to the `BoardDetail`
    state as part of this event handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we will need to trigger the `moveToState` function when the user is
    in a `BoardDetailView`, and clicks on the back button. To implement this, we will
    need to raise a `NotifyEvent`, with the `eventType` set to `BoardDetailBackClicked`,
    from our `BoardDetailView`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have tied the `onPrev` function to the DOM `click` event on the `#prev_button`
    element. Once a click is triggered, we simply need to raise a new `NotifyEvent`,
    with the `eventType` set to `BoardDetailBackClicked`, in order to trigger a `moveToState`
    function call.
  prefs: []
  type: TYPE_NORMAL
- en: With our State and Mediator Design Pattern classes in place, our sample application
    is now complete.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built a full TypeScript single-page application from the
    ground up. We started with an initial idea of how the application would be designed,
    and how we wanted the pages to transition. We then built a pure HTML demo page
    using out-of-the-box Bootstrap elements, and sprinkled a little JavaScript magic
    to create a full demo page. We applied various styles to the HTML, previewed it
    in Brackets, and tweaked the look and feel until we were happy.
  prefs: []
  type: TYPE_NORMAL
- en: Our next major step was to understand, and work with, the data structures that
    we would need within our application. We wrote Jasmine unit tests and integration
    tests to solidify our Backbone models and collections, and wrote the filtering
    functions that we needed.
  prefs: []
  type: TYPE_NORMAL
- en: We then built up a set of Marionette views, and split up our demo HTML into
    snippets for each of these views to use. We tied the views to our collections
    and models, and used interfaces to work with data providers. Our application then
    started to come together by working with real server-side data.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we discussed page transition strategies, and implemented a State and
    Mediator Design Pattern to implement our required business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, you have enjoyed the journey of building an application from the
    ground up—from concept to visualization, and then through implementation and testing.
    We have finally arrived at an industrial strength, enterprise ready, TypeScript
    single-page Marionette application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  prefs: []
  type: TYPE_NORMAL
