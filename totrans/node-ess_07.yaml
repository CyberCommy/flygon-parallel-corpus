- en: Chapter 7. Socket.IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simple HTTP is great for things that don't need real-time data, but what about
    when we need to know about things as they happen. For example, if we were creating
    a website that had a chat interface or similar?
  prefs: []
  type: TYPE_NORMAL
- en: This is when something like Web sockets come into play. Web sockets are usually
    referred to as WebSockets and are full duplex or two-way low-latency communication
    channels. They are generally used by messaging applications and games where messages
    need to be relayed between the server and client. There is a really handy `npm`
    module called `socket.io`, which can add Web sockets to any Node.js application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install it we just need to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Socket.IO can be set up very simply to listen for connections. First, we want
    to be able to serve out a static html page to run client side code with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, lets create an HTML file as well, named `index.html`, in the same directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run our example and ensure that we get our page, we should be able to
    see **WS Example** on screen. Now, to add socket support to our application we
    just need to require `socket.io` and specify what `http` server to listen with
    to `IOServer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, whenever there is a new socket connection over `8080` we will get a `connection`
    event on `io:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Lets add some code to the client. Socket.IO provides us with a client library
    and they expose this through the endpoint `/socket.io/socket.io.js`. This is included
    in the preceding `index.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the client side code is contained within the second `script` tag of the
    `index.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: To create a connection with the server all we need to do is call `io.connect`
    and pass the location. This will return a socket for us with which we can communicate
    to our server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using the client provided by Socket.IO here, as it will detect whether
    WebSockets are available, and if possible use them. Otherwise, it will utilize
    other methods such as polling, which makes sure that it works everywhere rather
    than just on evergreen browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use a `p` element to log messages to the screen with. We can do that
    with this code, then all we need to do is call `logScreen`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a connection is made, just like on the server side a `connection` event
    is emitted, we can listen to this using `on`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run our server once we navigate to `http://localhost:8080`. You
    should be able to see **Connection!** showing up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Socket.IO](img/B04729_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To receive a message on server side, we just need to listen for the `message`
    event. For now, we will just echo the message back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'On the client side, we just need to call `send` to send a message and we want
    to do this inside our connection event. The `api` on each side is very similar
    to each other, as you can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'On the client side, we also want to listen for messages and log them to the
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once we restart the server and refresh our page, we should be able to see an
    additional **Hello** message appear on screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This happens because the server can now send the client packets of data. It
    also means that we can update the client at any time. For example, every second
    we can send an update to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we restart our server we should be able to see an update message every
    second.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that you didn't need to refresh your webpage for the
    connection to be opened again. This is because `socket.io` transparently keeps
    our connections "alive" as well as reconnecting if needed. This takes all the
    pain out of using sockets, as we have none of these troubles.
  prefs: []
  type: TYPE_NORMAL
- en: Rooms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Socket.IO also has the concept of rooms, where multiple clients can be grouped
    into different rooms. To emulate this, all you will need to do is navigate to
    `http://localhost:8080` in multiple tabs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a client connects, we need to call the `join` method to tell the socket
    what room to be in. If we wish to do something such as a group chat with specific
    users only, we need have a room identifier in a database or create one. For now
    we will just have everyone join the same room:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For every tab we open, we should see a message that we have joined a room:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can broadcast a message to the entire room. Let''s do this every
    time someone joins. Within the join callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look in your browser, with each connection the other clients get a notification
    that someone else has joined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is great, we can now communicate almost directly between browsers!
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to leave a room, all we need to do is call `leave`, we will broadcast
    this before we call the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'While running this, you will not see any messages from another client because
    you are leaving right away: however, if you were to put a delay on this you might
    see another client come and go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For authentication, we can use the same method that we used with our HTTP server
    and we can accept a JSON Web Token
  prefs: []
  type: TYPE_NORMAL
- en: In these examples, for simplicity we will just have a single HTTP route to login.
    We will sign a JWT that we will later authenticate by checking the signature
  prefs: []
  type: TYPE_NORMAL
- en: We need to install a couple of extra `npm` modules for this; we will include
    `chance` so that we can generate some random data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we are going to need a route to `login`. We will modify our handler
    to watch for the url `/login`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Our new function `generateToken` will create a JSON Web Token with some random
    data using `chance`. We will also need a secret for our tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, whenever we request `http://localhost:8080/login` we will receive a token
    that we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can enter this into the debugger at [http://jwt.io/](http://jwt.io/) and
    see the contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome, we have a token and a random user being generated for us. Now, we
    can use this to authenticate our users. Socket.IO has a method on the server to
    do this and we just need to pass a handler type function to it. This is where
    `socketio-jwt` comes in, we pass it our secret and it will ensure it is a real
    token, pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we try to connect to our server from the client it will never emit
    the `connect` event, as our client isn't authenticated. This is exactly what we
    want.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first want to wrap up our Socket.IO code (we will call this later); we also
    want to give it a parameter of `token`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a `login` function, this will request the login URL and
    then pass the response to the `socketIO` function, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we want to call the login function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can pass the token on to the server by changing the `connect` call to pass
    a query string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, when running our server and navigating to our client we should be able
    to connect—awesome! Since we have authenticated we can also respond with a personalized
    message for each user, inside our server-side `connection` event handler we will
    emit a message to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our socket will have a new property called `decoded_token`; using this we will
    be able to view the contents of our token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we join our room, we can tell the rest of the clients who have also joined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Socket.IO brings amazing capabilities to our applications. We can now instantly
    communicate with others, either individually or by broadcasting in a room. With
    the ability to identify users, we can record messages or the history of that user,
    ready to be served up by a RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to build real-time applications!
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  prefs: []
  type: TYPE_NORMAL
