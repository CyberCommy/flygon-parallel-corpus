- en: Chapter 10. Component-Based Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Procedural game systems are incredibly versatile by nature. Therefore, the frameworks
    and infrastructures that they're implemented into need to share the same properties.
    Component-based systems, such as the Unity game engine, excel at this, and typically
    offer more versatility over traditional inheritance-based systems.
  prefs: []
  type: TYPE_NORMAL
- en: When building a large, dynamic system such as a game engine, a tradition inheritance-based
    approach will present problems. Inheritance structures become messy and objects
    become larger as they are required to do more. As a result, behavior becomes less
    encapsulated. A component-based approach solves these issues, so to finish our
    work we'll branch off a little to take a look at what a component-based system
    is, why it works hand in hand with procedural generation, and how we can improve
    the existing engine to benefit from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Problems with a traditional inheritance approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pros and cons of a component-based approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding component-based architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a component-based system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are unfamiliar with the Unity engine, head to [https://unity3d.com/](https://unity3d.com/)
    and check it out. It's one of the industry's leading game engines and uses a component-based
    approach. The best part is that it's completely free!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding component-based architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Component-based architecture, also known as component-based design and modular
    programming, is an approach to software design that aims to break down behavior
    into succinct, reusable components. We already do this to a certain extent with
    object-orientated design, but component-based architecture takes this further.
    For example, if an object such as a sprite or a 3D model needs a certain behavior,
    it will be defined through a component that the object will own, as opposed to
    being inherited from a `base` class.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with a traditional inheritance-based approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we get into the pros and cons of a component-based approach, let's look
    at the problems that a traditional inheritance-based approach brings. It's these
    problems that we'll aim to fix.
  prefs: []
  type: TYPE_NORMAL
- en: Convoluted inheritance structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s suppose that we have a simple `player` object that requires a 3D model
    and to be effected by our game physics. Let''s look at an inheritance structure
    that may be needed to create this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Convoluted inheritance structures](img/B04920_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see from this diagram that even this simple scenario can result in a
    complex inheritance structure. If you now replace this simple example with an
    entire game engine, you can imagine how complex and unmanageable the inheritance
    structure would be.
  prefs: []
  type: TYPE_NORMAL
- en: This is a major downfall of traditional inheritance-based design; as your system
    grows larger, objects get more convoluted and entangled in the inheritance tree.
    This complexity does not help us when we're trying to create a procedural system.
    We want a system that is as flexible as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Circular dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another problem that can arise with complex inheritance structures is that
    of circular dependencies. This is where class `A` depends on class `B`, which
    in turn depends on class `A`, and so on. The following diagram should make this
    clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Circular dependencies](img/B04920_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While circular dependencies can be avoided through proper program structure,
    it becomes increasingly harder as the system grows larger. As the inheritance
    tree grows, so do the dependencies, and it can cause real problems within a system.
    By removing complex inheritance, we also remove the risk of messy dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of component-based architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As developers, we're always making trade-offs. It's imperative to know both
    the pros and cons of an approach so that we can make informed decisions regarding
    whether it belongs in a solution. Since we've identified some flaws with an inheritance-based
    approach, and aim to solve them with a component-based approach, let's familiarize
    ourselves with a few of its pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding complex inheritance structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We identified a hypothetical game situation earlier and looked at what a typical
    inheritance-based approach might look like. Let''s take a look at the same example
    if we take a component-based approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Avoiding complex inheritance structures](img/B04920_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It's clear that this solution is much simpler and neater than its inheritance-based
    equivalent. Instead of obtaining its behavior from parents and thus creating a
    chain of dependencies, it's instead broken into succinct components that can simply
    be attached to an object.
  prefs: []
  type: TYPE_NORMAL
- en: Code is broken into highly reusable chunks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another benefit of component-based architecture is the high reuse value of code
    once it's encapsulated in a component. Once encapsulated, behavior can be easily
    given to objects by simply attaching the component. This not only avoids duplicate
    code, but also makes it easy to build complex objects by combining multiple components.
    This is where it lends itself to procedural generation. We can procedurally put
    objects together like Lego with these reusable components.
  prefs: []
  type: TYPE_NORMAL
- en: Highly maintainable and scalable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a result of the code being reusable, it also makes it very easy to maintain.
    If a set of objects all obtain their behavior from a single source, then only
    one edit is needed and it will affect them all.
  prefs: []
  type: TYPE_NORMAL
- en: Component-based systems are also easier to scale. Since our components are succinct
    individual modules and don't have complex dependencies, we can add them at will.
    If we want new behavior, we don't have to worry about questions such as *Where
    it will go?*, *What will it depend on?*, *What will it inherit from?*, and so
    on. We simply build the new component and use it where we need to.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantages of component-based architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now it's time to have a look at the opposing side of the argument. Although
    component-based design does bring with it a range of great benefits, there are
    things that you need to consider.
  prefs: []
  type: TYPE_NORMAL
- en: Code can become too fragmented
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To a certain extent this is the goal of component-based design: to break code
    into manageable chunks. But this can be taken too far. If objects and functionality
    are broken down too far, then we end up with the code base scattered into hundreds
    of tiny components, making it a mess. Always keep this in mind. Yes, we do want
    to break our code into manageable and reusable components; just don''t go crazy
    with it!'
  prefs: []
  type: TYPE_NORMAL
- en: Unnecessary overhead
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Expanding on the previous point, if code is broken down into too many small
    components, then we'll see an increase in useless overhead. If a project contains
    many components, we'll frequently find ourselves dipping in and out of them to
    perform tasks. While adding a component might make code easier to manage and maintain,
    it also introduces overhead when it's used.
  prefs: []
  type: TYPE_NORMAL
- en: Complex to use
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final disadvantage of components is simply their use, as it can be more
    complex than a traditional object model. Instead of accessing a member function
    directly, we have to go through the component that they belong to. If we have
    20 components in an object, then we have to remember where the variables are and
    which component we need to use. While it's not rocket science, it's certainly
    more complex than having a single object that directly owns all the behavior and
    data.
  prefs: []
  type: TYPE_NORMAL
- en: An overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hopefully, it's now clear how component-based design aids procedural design
    more than a traditional inheritance-based approach. Procedural generation is all
    about flexibility, and when systems grow to a certain size an inheritance-based
    system can struggle to provide that. By allowing us to break code into reusable
    objects, component-based design keeps code flexible and without dependencies so
    that we can move components wherever we want.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the component system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A component-based system can be implemented in many ways. So, before we write
    any code, let's look at some possibilities. The goal is to break reusable behavior
    into succinct components and be able to add and remove them from the existing
    objects with ease. All objects share a common base class named object so we'll
    add the facility to add components to and remove them from this class. We can
    then ensure that it will be propagated to all the subsequent classes in the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of ways to implement a component-based approach, and there
    is no single right answer. For example, we could create a function to add or remove
    each component individually. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'While this will make things straightforward, we will have a lot of duplicate
    code in the class. Also, every time we add a component, we will have to create
    two matching functions: one to get the component and one to set it. That''s a
    bit cumbersome!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach involves simply making the component values public. So, instead
    of interacting with the components through functions, we can directly access them
    through the object that they belong to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Even though this is an attractive option, as it would make life a thousand times
    simpler for us, it's almost never a good idea to make variables public like this.
    Having to make variables public to make code work usually indicates a flaw in
    the architecture of the system. If you ever find that this is the case, the cause
    of the problem should be sorted.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at an existing component-based game engine such as Unity, we can
    see how they approach this problem. The following code demonstrates how to get
    a component from an object in Unity. This is taken directly from the Unity documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that a single function named `GetComponent` is defined, and a type
    is supplied to return the corresponding component. We could create a similar system
    using enumerators to denote the type, allowing users to specify a component type
    via a parameter and then using that in a `switch` statement to return the correct
    variable.Let''s assume that we created an `AttachComponent` function to add a
    component to an object using the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the function definition, we have something that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This would work fine if the user passed a matching type and component, but there's
    nothing about this that will guarantee that. For example, a user can specify a
    movement component but actually pass an audio component, and that would be bad!
    We'll actually solve this through the use of templates!
  prefs: []
  type: TYPE_NORMAL
- en: C++ templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ templates allow us to define functions and classes that work with generic
    types. This allows a function or a class to accept any type, and it only has to
    be written once. This is what we want. We want to define a single get/set function
    for components, and we'll template them to make them generic and flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at a practical example of templates to get a better idea of
    how they actually work.
  prefs: []
  type: TYPE_NORMAL
- en: Using templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s suppose that we require a function to add two numbers, and we want to
    support a range of types. To achieve this, we could declare a function for each
    type that we want to support, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Looking at these two functions, the only thing that is different about them
    is their return and parameter types. How great would it be if we could say "Don't
    worry about the type, I'll give you it later" and just have one function? Enter
    templates!
  prefs: []
  type: TYPE_NORMAL
- en: Template declarations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C++ templates allow us to define functions with generic types and specify the
    type later as we call the function. It''s an incredibly useful feature that creates
    flexible and reusable code instead of having multiple function definitions that
    are almost identical. If you use templates, the previous example requires only
    one function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Template parameters can use either the **typename** or the **class** keywords.
    Both of these keywords are entirely interchangeable and do the same thing. However,
    they can be used as a hint to denote the parameter type. Use **class** if a parameter
    is a class, and use **typename** with all the other types (int, char*, and so
    on).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following syntax is used to declare a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the declaration, we create a template parameter named `T`. This gives us
    an ambiguous data type that can be used within the function declaration until
    an actual type is set later when the template is called. The generic `T` type
    can be used just like normal types: specifying the return types, creating variables,
    and setting the parameter types.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The name of your template parameters can be anything that you like, although
    it's most commonly **TYPE** or **T**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Templates can also have multiple types defined. For example, let''s say that
    a function needs to take two different data types. We can use the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, templates can also be used with normal data types and they don''t
    have to be ambiguous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the templates defined, let''s have a look at how to use them. We''ve given
    the templates ambiguous types, so one way to call them is to explicitly tell the
    template what type we want to work with. This is done by passing a type in the
    <> brackets after the function/class call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two are straightforward; we assigned a type for each template parameter.
    However, the last one is slightly different. Since the second type is fixed, there''s
    no need to specify it in angle brackets. Instead, we can use it like a normal
    parameter, passing the value that we want to use. This leaves us with just one
    parameter in the parentheses: the generic type value.'
  prefs: []
  type: TYPE_NORMAL
- en: Something important that needs to be noted is that the value of template parameters
    is determined at compile time. This means that for each different instantiation
    of a template, a unique function is created. In the last example, the value of
    the **int** is passed as a template function, which means that a function that
    is hard-coded to multiply by the value 2 is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose that we called `IntegerMultiple` twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though we''ve called the same template, the complier will create two different
    versions of `IntegerMultiply`. One version will always multiply by 2, and the
    other version will always multiply by 10\. For this reason, the second template''s
    parameters, the integers, have to be constant expressions. The following code
    will result in a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'These functions can also be called without the type being explicitly denoted
    in angle brackets when the type can be resolved by the compiler. For this to happen
    there needs to be no ambiguity regarding the type. For example, the following
    calls are fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In these calls, each ambiguous type in the template is given a single type.
    The compiler can therefore deduce the type of **T** automatically. However, consider
    a scenario where different parameters are passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**T** now has two possible values, which means that the compiler cannot deduce
    the type and will result in an error.'
  prefs: []
  type: TYPE_NORMAL
- en: Template specialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have an understanding of how templates work in general, let's have
    a look at template specialization. We already know that we can define a template
    with generic types and define them later when we call the function. That's fine
    if all the possible implementations share the same behavior, but what if we want
    different behavior depending on the type?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose that we want to use the `Add` function with a string type. We
    want to pass in two words, but we want to put in a space between them when this
    is the case. The default template function doesn''t facilitate this so we have
    to specialize it for this case. To specialize a template we simply create a declaration
    where we replace the ambiguous type with a fixed one, which is `std::string` in
    our case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, when the `template` function is called and the `std::string` type is specified,
    it will use this definition and not the generic one. With this, we can still use
    templates but provide specific implementations for certain types. Very handy.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you wish to learn more about C++ templates, visit [http://www.cplusplus.com/doc/tutorial/templates/](http://www.cplusplus.com/doc/tutorial/templates/).
    This is a great site in general, and it has some awesome information on this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Function overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Somewhat similar to templates, function overloading is another way in which
    we can make code and classes more versatile. We've already used overloaded functions
    during the course of the book, but they were provided with the code base. So,
    let's take a quick look at them.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we define functions, we set fixed parameter types. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With this definition, we can only pass a parameter of the `T` type. What if
    we want a choice of parameters? What if we want to be able to pass parameters
    of type `T` or type `Y`. Well, we can redefine the function, setting the same
    return type and name, but with unique parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We now have two function declarations with different parameters. When we call
    `DoStuff`, we'll have the option of which parameter to pass. Also, with function
    overloading, each declaration gets its own body, just like with template specialization.
    While similar on the surface, function overloads and template specializations
    work in different ways, though that's beyond the scope of this book. For now,
    all that we need is a basic understanding of them and we can get started!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with templates, for further reading on function overloading, visit [http://www.cplusplus.com/doc/tutorial/functions2/](http://www.cplusplus.com/doc/tutorial/functions2/).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a base component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the theory covered, let's implement this into our project. The overwhelming
    message of this chapter has so far has been to use components to avoid messy inheritance,
    but we still need *some* inheritance as we need to use polymorphism!
  prefs: []
  type: TYPE_NORMAL
- en: Each object will be able to hold a range of components so we'll store them in
    a single `generic` container. In order for us to do this we need to make use of
    polymorphism, ensuring that all components inherit from a common base class. That
    base class is what we're going to implement now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a new class to the project and call it `Component`. We''ll leave
    it to you to implement the `.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that we've added a `virtual update` function here as a class must have
    at least one `virtual` function in order to be polymorphic. With the `Component`
    base class created, we can now add the functions to `get` and `set` components,
    and they will reside in the base `Object` class so that they are available to
    all objects.
  prefs: []
  type: TYPE_NORMAL
- en: Component functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we think about the behavior that we want, we need to be able to give an object
    a component of any given type. We also need to be able to fetch that same component
    later. We'll call these functions `AttachComponent` and `GetComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in the chapter, we identified how we can use templates to create a function
    with generic types and give them real values when we need them. We'll use templates
    and polymorphism to create these two functions.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching a component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first function that we're going to write will be used to attach a component
    of a given type to the `Object` class. Since we've already identified that we're
    going to store all components in a single generic container, this function will
    be a relatively simple template. The only thing that we need to be aware of is
    that we should not add the same component twice!
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by defining the container, as that's where we'll store the objects.
    Since we need to take advantage of polymorphism, we can't store actual objects.
    So instead, we're going to use shared pointers so that we can pass them around
    with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining the generic container in `Object.h`. Don''t forget
    to `#include` our new Component class so that Object can see it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now it's time for the actual `AttachComponent` method. We could take a naïve
    approach and just append the new component to the `generic` container. The problem
    here is that we could add multiples of the same component type, and that's not
    something that we want. Before we add the component to the collection, we'll first
    check whether a component of the same type already exists, and for that, we'll
    use the `std::dynamic_pointer_cast` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function lets us cast between pointers and returns a null pointer if it
    fails. It''s very handy, and when combined with templates, we can create a single
    function that will accept any component type, create one, check whether one of
    the same type already exists, and if it does, it will overwrite it. We''ll define
    this template function inline in the header. Let''s add the following code to
    `Object.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Using templates, we can operate with the generic `T` type, which allows us to
    perform the cast to check whether the types match. If they do match, we overwrite
    the old component with the new one; if not, we simply add it to our collection.
    We also return the new component when we're done in case the user wants it straightaway.
  prefs: []
  type: TYPE_NORMAL
- en: That's all there is to it, and the beauty of using templates like this is how
    scalable the system is. It doesn't matter if we add 1,000 components; this function
    will be able to attach them to any object.
  prefs: []
  type: TYPE_NORMAL
- en: Retuning a component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next template that we need to create is for a function that's used to return
    a given component. Again, let's think about where we'll need the generic type.
    The function will need to return the component type, so that needs to be generic,
    and we also need to find the correct component type. So, we'll use the generic
    type in the pointer cast like we did with the previous function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get this template defined in the header of `Object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have the ability to add any component to any object and return
    the correct type. The best part is that two simple functions provide all this
    functionality! How awesome are templates!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to test this code before we move on you can do. At the end of the
    `Game::Initialize` function, add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use **breakpoints** and look at the values at runtime, you''ll see that
    this code does the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: It adds a new `Component` object to the generic container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It tries to add a second `Component` object; so it instead overwrites the current
    one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It realizes that we want the component with the type `Component`; so it returns
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a transform component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the ability to attach and return components, let's get our first component
    built and added. We'll start with a simple one first. Currently, all objects have
    a position by default that's provided by the `Object` base class. Let's break
    this behavior into its own component.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating transform behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we're converting an inheritance-based approach to a component-based one,
    the first task is to take the transform behavior out of the `Object` class. Currently,
    that consists of a `single` position variable and a function to both `get` and
    `set` that value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new class named `TransformComponent` and move this behavior
    into it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also take the function definitions from `Object.cpp` file and place
    them in `TransformComponent.cpp`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a component that will provide a position to an object. The last
    thing that we need to do is include the header for this component in the `Object`
    class so that all the extending classes can see it. Let''s add the following code
    to `Object.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It's time to add this component to the objects! This is a large task, and it's
    one that will be left for you to complete in your own time, but to demonstrate
    how it's done, we'll quickly add the component to the `player` class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a transform component to the player
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we placed the two functions to attach and get components in the base
    `Object` class, we can call `AttachComponent` directly from within the player.
    We''ll do this in the constructor as we''ll need the component set up before we
    get to any logic. Let''s head to `Player::Player` and add the following code to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: That's all there is to it! The `player` now has all the data and functionality
    that we added to the transform component, and when we want to use it, we can simply
    go through this new component. You may remember that we identified overhead as
    one of the potential downsides of component-based design. We can see now how moving
    the behavior into a component has introduced overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Using the transform component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final part to this puzzle will be looking at how we use the new component.
    Previously, if we wanted to get the position of the player, all we had to do was
    use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Since these values now belong to the `transform` component, we need to make
    a slight change and access those values through the `component` instead, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Since these functions are public, we can call them anywhere. For example, if
    we were in the game class and wanted the position of the player object, we would
    do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Updating the game code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the architecture in place, and an understanding of how the `transform`
    component works, it's time to update the game code to make use of the new component.
    This will require a number of changes. For this reason, we won't be running through
    them in the chapter; it's left as a task for you!
  prefs: []
  type: TYPE_NORMAL
- en: 'Every object that has a position will need a `transform` component adding,
    and the places where these position variables are used will now need to be accessed
    via the component. If at any point you get stuck, refer to the previous code examples.
    If you do run through the project and make these changes yourself, make sure that
    you give the project a run once you''re done to ensure that everything is still
    running smoothly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the game code](img/B04920_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although things may look the same, we know that the underlying system is now
    much more flexible, maintainable, and saleable. Let's create more components!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a SpriteComponent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next component that we're going to make is a `SpriteComponent`. This will
    provide an `object` with either a `static` or an `animated` sprite. It's a behavior
    that is commonly reused through many objects so is a great candidate to be moved
    into a component.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating sprite behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Currently, all the animation-related behavior is inherited from the base `Object`
    class. The following code consists of all the sprite- and animation-related functions
    and variables that we''ll pull from `Object` into its own class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Currently, every object that we create has these variables and functions but
    doesn't necessarily need them which is a waste. With our `component`, we can give
    an object this behavior without worrying about inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a new class in the project and call it `SpriteComponent`,
    ensuring that it extends the base `Component` class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keeping a clean project is important. Create folders and organize your classes
    into logical groups!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add all the functions and variables that we pulled out of `Object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We've made some slight changes here regarding the `public`/`protected`/`private`
    modifiers that we use. Previously, with things being inheritance-based, a number
    of functions and variables were given the `protected` keyword, exposing them to
    child classes. Since we're moving away from inheritance, all of these have now
    been moved to `private`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now just need to initialize the variables in the initializer list of the
    constructor, and add the function''s definitions in `SpriteComponenet.cpp`. Again,
    these can just be picked up from the `Object` class and moved over. Also, don''t
    forget to include the class in `Object.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With the class complete and the header included, we can now implement the component!
  prefs: []
  type: TYPE_NORMAL
- en: Adding a sprite component to the player class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s continue using the player class to demonstrate, giving the class a `sprite`
    component. We decided earlier that the best place for this is within the constructor.
    So, let''s add the following code to `Player::Player` right after we create the
    `transform` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The updated drawing pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that our `objects` are able to receive `sprite` components, we need to
    update the drawing pipeline so that they can be used. Currently, we loop through
    all the objects in the main game loop, drawing each in turn. However, the object
    itself isn''t responsible for drawing now, the `sprite` component is (if it has
    one, that is). In the `main draw` loop, instead of iterating over all the objects
    and calling their `Draw` function directly, we need to check whether they have
    a sprite component attached, and if they do, call the `Draw` function of the component.
    The `GetComponent` function returns a `nullprt` if no component is found making
    this easy to check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: With the drawing pipeline updated, let's quickly look at how to use the `component`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the game code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here comes the big job again! On every occasion where a sprite is used, we need
    to update the code to go through the `sprite` component instead. As with the last
    component, this brings many changes to the code so is another task for you to
    complete in your own time.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s is also suggested at the end of the chapter that you try to split this
    component into multiple types: one for `static` sprites and another for `animated`
    sprites. This will keep the code even more encapsulated and efficient as currently
    this component provides animation even if it isn''t needed.'
  prefs: []
  type: TYPE_NORMAL
- en: If you do undertake this, hopefully nothing has imploded and you still are able
    to compile without issues. If all is well, we will see nothing new, but that's
    a good thing!
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the game code](img/B04920_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating an audio component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final component that we're going to create is an `audio` component. Now,
    this is the first component that we'll create from scratch. However, our experience
    with the two previous components should make this one easy to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the behavior of an audio component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is slightly different from our past components. Instead of encapsulating
    existing behavior, we need to define it. We're going to create a simple `audio`
    component, and the only behavior that we're going to have is the ability to play
    a single sound effect. For this, we'll require a single variable to hold the sound
    object, a function to set a sound buffer, and a function to play the sound.
  prefs: []
  type: TYPE_NORMAL
- en: In the function that will be used to set the sound buffer, we're going to make
    use of function overloading. If we think about how we may want to use this function,
    we might either want to pass an already created sound buffer into the component
    or pass a path to one and create it before we use it. We covered function overloading
    earlier in the chapter, and this is a textbook case of its use. We define the
    same function name and return type but varying parameter types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add this new `AudioComponent` class to the project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we''ll leave it as an exercise for you to complete this class and provide
    definitions for the functions. With the class complete let''s not forget that
    we have to include the class in the `Object.h` file so that all the objects can
    see and use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Adding an audio component to the player class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final step is to actually hook up our components to the object. We''ve
    covered doing this before and it''s simply a case of adding a call to the `AttachComponent`
    function, specifying `AudioComponent` as the type. To demonstrate this on the
    player, let''s add an audio component along with the sprite and transform components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Using the audio component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the `audio` component is very simple. We give it a sound buffer, which
    is either a pre-constructed one, or the path to a file that needs to be loaded,
    and then call the `AudioComponent::Play` function. Let''s give the player their
    own attack sound instead of it been held in the `main` game class. After we give
    the player the `audio` component, let''s set up the sound that it will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` class, where we detect the collision with the player, we now
    play the sound via this component instead directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You can see just how easy it was to add this behavior to an object, and it's
    not much work to add it to as many objects as we want! If we want to make a change,
    we just need to change the `component` class, and it affects all the child classes.
    Brilliant!
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To help you test your knowledge of this chapter''s content, here are a few
    exercises that you should work on. They are not imperative to the rest of the
    book, but working on them will help you assess your strengths and weaknesses in
    the material covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Move the game input from a fixed, `static` class to a component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Split `SpriteComponent` into two individual components; one that provides a
    static sprite, and one that provides an animated sprite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `component` that encapsulates a certain behavior and use it in your
    game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we took a good look at component-based architecture, including
    the major benefits that it brings when creating procedural systems and how it
    can be achieved through the use of templates. The approach outlined in this chapter
    is just one of many possible implementations so I encourage you to experiment
    with different methods. Its plug-and-play nature makes it very flexible, which
    is an important trait that we look for when creating procedural systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to take a retrospective look at the project
    and the topics that we covered as we reach the end of the book. For each area
    of procedural generation that we've used, we'll also identify some jumping-off
    points should you wish to explore the topic in more depth.
  prefs: []
  type: TYPE_NORMAL
