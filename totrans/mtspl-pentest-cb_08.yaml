- en: Chapter 8. Working with Exploits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting the module structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common exploit mixins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with msfvenom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting exploit to a Metasploit module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Porting and testing the new exploit module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fuzzing with Metasploit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a simple FileZilla FTP fuzzer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us start this chapter with a formal introduction to exploits. **Exploit**
    can be a piece of software, a chunk of data or a sequence of commands that takes
    advantage of vulnerability or a bug in another software to execute user-intended
    instructions. These user-intended instructions can cause unusual behavior in the
    vulnerable software. Exploits play a vital role in penetration testing as it can
    provide an easy entry into the target system.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have used the power of exploits extensively to perform penetration
    testing. The point to note here is that we cannot directly use any stand-alone
    proof of concept or exploit code into the Metasploit framework. We will have to
    convert it into a framework understandable module. The process is similar to development
    of auxiliary modules with some additional fields. This chapter will cover every
    detail that you need to know while you are working with exploits within the framework.
    We will not be covering those aspects which are related to developing exploits
    as it is a separate area of study. Here, we will use the available proof of concepts
    of exploits and see how it can be added into the framework. We will also learn
    about some important mixins that can ease the process of converting exploits into
    the Metasploit module. At the end, we will cover some recipes focusing on fuzzing
    modules. So let us move ahead with the recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting the module structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is very essential to understand the exploit module structure as it will help
    us in proper analysis of different exploit modules. As the Metasploit framework
    is an open source project, its development depends on the contribution from the
    community. Developers from around the globe convert proof of concepts of various
    exploits into the Metasploit module, so that it can be used by everyone. Hence,
    you can also contribute to the community by converting newly discovered exploits
    into modules. Also, there can be a situation where you need a particular exploit
    which is not in the framework. Knowledge about the exploit module structure will
    help you in easily converting the exploit into a module.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us start the recipe with understanding the modular structure of exploits
    within the framework. It is similar to an auxiliary structure with some specific
    fields. You can find the exploit modules in the `/pentest/exploits/framework3`
    directory. Let us analyze the structure of exploits in MSF.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we said earlier, the format of an exploit module is similar to auxiliary
    with some specific additions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The module starts with including the MSF core libraries into the script, along
    with the declaration of a class which extends the properties relevant to the exploit.
    In this example, the `Metasploit3` class extends `Remote Exploit` libraries. Further,
    the script includes other libraries such as TCP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have the `initialize` function that is used to initialize the different
    values and content definition about the modules. Some of the primary definitions
    of this function include `Name, Description, Author, Version`, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have the register options part of the script which is responsible
    for providing essential and default values of the script. The values can be changed
    according to users needs as well. So far, it has been very much similar to auxiliary
    modules. The difference lies in defining the `exploit()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is the main exploit body of the module that contains the shell code or
    the exploit pattern. The content of this function varies from exploit to exploit.
    Some of the key features that may exist in a remote exploit are listed in the
    body of the function. `connect()` is used to open a remote connection with the
    target. It is a function defined in the `Remote::TCP` library. A payload is also
    an essential part of the exploit body which helps in setting up back connections.
    We can also define handlers in the exploit body depending on the need.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, you can also declare a vulnerability test function, `check()`, which
    verifies whether the target is vulnerable or not. It verifies for all options
    except the payload.
  prefs: []
  type: TYPE_NORMAL
- en: This was a basic introduction to exploit modules of Metasploit. In the later
    recipes, we will discuss some core concepts related to exploits in the framework.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exploit module structure we just analyzed is Metasploit's way of making
    things understandable. Consider the function `def initialize()`. This part helps
    the module in picking up common exploit definitions. Similarly, `register_options()`
    is used by Metasploit to pick up different parameters or assign default parameter
    values to the exploit module. This is where modular architecture becomes handy.
    Later in this chapter, we will see how to convert an existing exploit code into
    a Metasploit module.
  prefs: []
  type: TYPE_NORMAL
- en: Common exploit mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mixins are a comprehensive mechanism in Ruby language to include functionality
    into a module. Mixins provide a way to have multiple-inheritance in a single-inheritance
    language like Ruby. Using mixins in exploit modules can help in calling different
    functions that the exploit will require. In this recipe, we will learn about some
    important Metasploit exploit mixins.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us take a quick look at some of the common exploit mixins. Then, we will
    see its implementation in an existing exploit module.
  prefs: []
  type: TYPE_NORMAL
- en: '`Exploit::Remote::TCP:` This mixin provides TCP functionality to the module.
    It can be used to set up a TCP connection. `connect()` and `disconnect()` functions
    are responsible for setting up and terminating connections respectively. It requires
    different parameters, such as `RHOST, RPORT, SSL`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exploit::Remote::UDP:` This mixin is used for UDP functionality in the module.
    UDP is generally treated as a faster mode of connectivity over TCP so it can also
    be a handy option when dealing with modules. This mixin further includes `Rex::Socket::UDP`
    which removes the overhead of worrying about setting socket connections with the
    target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exploit::Remote::DCERPC:` This mixin provides utility methods for interacting
    with a DCE/RPC service on a remote machine. The methods of this mixin are generally
    useful in the context of exploitation. This mixin extends the TCP mixin. `dcerpc_call(),
    dcerpc_bind()`, and so on are some useful functions of the DCE/RPC mixin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exploit::Remote::SMB:` This mixin defines functions that can help in communicating
    with the SMB service on the remote target. `smb_login(), smb_create(),and` so
    on are some useful functions present in this mixin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exploit::BruteTargets:` This is an interesting mixin that is used to brute
    force the target. It uses the `exploit_target(target)` function to receive the
    remote target IP and perform brute force. This mixin can be easily extended in
    different brute force exploits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exploit::Remote::Ftp:` This mixin can be used to exploit an FTP service on
    the remote target. The mixin includes `Remote::TCP` in order to setup a connection
    with the remote target. It uses the `connect()` function that receives values
    of `RHOST` and `RPORT` in order to connect with the FTP server on the remote system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exploit::Remote::MSSQL:` This mixin helps in querying with the remote database.
    The `Mssql_ping()` function queries for the database availability and stores the
    ping response as hash. The `Mssql_xpcmdshell()` function is used to execute system
    commands using `xp_cmdshell`. This mixin is very handy when dealing with exploits
    related to MS SQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exploit::Capture:` This mixin is helpful in sniffing data packets flowing
    in the network. The `open_pcap()` function is used to setup a device for capturing
    packets flowing through it. This mixin requires presence of pcap installed on
    the machine. Two important functions of this mixin include `inject(pkt="", pcap=self.capture)`
    and `inject_reply()`. The former is responsible for injecting packets into networking
    devices while the latter function is responsible for reporting the resultant packet
    returned by the device depending upon the injected packet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are some of the important exploit mixins that can be very handy when you
    are working with exploit modules within the framework. Use of mixins reduces the
    overhead of recoding same modules repeatedly. This is the reason why modular architecture
    is very flexible as it facilitates code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated earlier, mixins are used to provide multiple-inheritance in a single-inheritance
    language like Ruby. What we mean by that is we can call different functionalities
    in any module depending on our need. For example, if we want to establish a TCP
    connection in our exploit module, it is not required to define a complete function
    for it. We can simply call the mixin, `Exploit::Remote::TCP`, in our module and
    leverage its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us list some more important mixins.
  prefs: []
  type: TYPE_NORMAL
- en: Some more mixins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apart from the previously mentioned mixins, there are many more crucial mixins
    present in the framework. These include `fileformat, imap, java, smtp, she`, and
    so on. You can find these mixins at `lib/msf/core/exploit`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with msfvenom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have read about `mefencode` and `msfpayload` in [Chapter 4](ch04.html "Chapter 4. Client-side
    Exploitation and Antivirus Bypass"), *Client-side Exploitation and Antivirus Bypass*.
    Let us take a small recap. `msfpayload` is used to generate binary from the payload,
    whereas `msfencode` is used for encoding the binary using different encoding techniques.
    Here we will discuss another Metasploit tool which is a combination of both. This
    tool can play an important role in generating exploits that can execute stealthily.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start our experiment with `msfvenom`, launch the terminal window and pass
    on the `msfvenom -h` command.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us take a look at various available options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There are some interesting parameters to look at. The `-n` parameter creates
    an NOP sled of size of the payload. Another interesting parameter is `-b` which
    gives us the power of avoiding common characters of an exploit such as `\x00`.
    This can be really helpful in evading antivirus programs. The rest of the parameters
    are similar to those we can find in `msfpayload` and `msfencode`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An NOP slide, NOP sled or NOP ramp is a sequence of NOP (no-operation) instructions
    that are meant to "slide" the CPU's instruction execution flow to its final, desired,
    destination.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use `msfvenom`, we will have to pass a payload along with an encoding style.
    Let us perform this task on the terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice the different parameters that have been passed along with the payload.
    The presence of the `-b` parameter will avoid the use of `\x00` (null bytes) in
    the shell code. We can use this shell code in our exploit program.
  prefs: []
  type: TYPE_NORMAL
- en: '`msfvenom` can be a very handy tool in quickly generating shell codes using
    different payloads available in the framework. These shell codes can be implemented
    in the exploit code in order to provide back connection with the attacker once
    the vulnerability has been exploited.'
  prefs: []
  type: TYPE_NORMAL
- en: Converting exploit to a Metasploit module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have used exploit modules in order to compromise our target. In this
    recipe, we will take our module usage experience to the next level. We will try
    and develop a complete exploit module using an available proof of concept. Knowledge
    of converting exploits to a module is essential in order to convert any new exploit
    into a framework module and perform penetration testing without waiting for updates
    to come from the Metasploit team. Also, it is not possible that every exploit
    will be available in the form of a module within the framework. So let us move
    ahead with the recipe and see how we can build our own exploit modules using an
    available PoC.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start with, let us select any exploit which we can convert into a module.
    Let us consider the gAlan Zero day exploit that can be downloaded from [http://www.exploit-db.com/exploits/10339](http://www.exploit-db.com/exploits/10339).
  prefs: []
  type: TYPE_NORMAL
- en: '**gAlan** is an audio-processing tool (both on-line and off-line) for X Windows
    and Win32\. It allows you to build synthesizers, effects chains, mixers, sequencers,
    drum-machines, and so on in a modular fashion by linking together icons representing
    primitive audio-processing components.'
  prefs: []
  type: TYPE_NORMAL
- en: An exploit for gAlan will function only when the victim is using this application
    and the attacker has the knowledge about this beforehand. Hence, it is imperative
    for the attacker to know which applications are installed on the victim's machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we begin with the exploit conversion, it is imperative to know a little
    about Stack Overflow attacks.
  prefs: []
  type: TYPE_NORMAL
- en: In software, a stack overflow occurs when too much memory is used on the call
    stack. The call stack is the runtime stack of the software that contains a limited
    amount of memory, often determined at the start of the program. The size of the
    call stack depends on many factors, including the programming language, machine
    architecture, multi-threading, and amount of available memory. When a program
    attempts to use more space than is available on the call stack, the stack is said
    to overflow, typically resulting in a program crash. Essentially, `ESP, EIP`,
    and `EAX` are the registers which are mostly attacked during an exploit.
  prefs: []
  type: TYPE_NORMAL
- en: '`ESP:` Points to the top of the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EIP:` Points to the location of the next instruction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EAX:` The instruction to be executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As in a stack all the registers are stored linearly, we need to know the exact
    buffer size of the `EIP` register, so that overflowing it will give us the `EAX`
    and subsequent execution of the payload.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the proof of concept of the exploit, the next step will be to collect
    as much information about the exploit as possible. Let us take a good look at
    the proof of concept. The first few lines consist of the shellcode that is stored
    in the `$shellcode` variable. This can be generated using any of the payloads
    available in the framework using either `msfpayload` or `msfvenom:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The main exploit code starts with `$magic` which contains a four byte string.
    Then, we have the `$addr` variable which contains the location of the `ESP` stack
    pointer. Then we have the `$filename` variable containing the filename to be created
    as a post exploitation phase. `$retaddr` contains the location of the return address
    where the stack pointer will point and lead to the execution of the exploit code
    after the overflow. Finally, we have the execution of the payload, which is responsible
    for the exploitation and shellcode execution.
  prefs: []
  type: TYPE_NORMAL
- en: We know from the exploit that our shellcode can reach to a maximum of 700 bytes.
    Also the total length of our payload is 1214 bytes. This information will be helpful
    in building our module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can either use a repeated return address or we can also find the size when
    `EIP` gets overridden. Metasploit has an excellent tool called `pattern_create.rb`
    which can assist in finding the exact location where `EIP` gets overridden. This
    tool generates a string of unique patterns that can be passed to the exploit code
    and by using a debugger; we can find which string pattern is stored in `EIP`.
    Let us create a string of 5000 characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, edit the exploit script to replace `$payload` with another test variable
    `$junk` and copy the string of 5000 characters in this variable. Now, test the
    application with this script and check which pattern is stored in `EIP`. I am
    assuming that you are aware of the basics of reversing and debugging applications.
    Suppose the string pattern stored in `EIP` is "234abc". Now we will use another
    Metasploit tool called `pattern_offset.rb` to calculate the position where this
    pattern exists in the string we passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So the total number of bytes to be passed so as to get the exact location of
    `EIP` is 1032.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have collected enough information about the exploit and we are ready
    to convert it into a Metasploit module.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us start building our module. The first and foremost line of script will
    be importing libraries and creating the parent class. Then, we will define the
    `initialize()` function which will contain information about the exploit and also
    register options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So far, it was simple and straightforward. The twist begins with defining the
    `exploit()` function. Let us see how we can do this.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the first four bytes of the original exploit script, that
    is, `$magic = "Mjik"`;
  prefs: []
  type: TYPE_NORMAL
- en: It will be replaced with `sploit = "Mjik"` in our module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we move ahead and build our buffer. As we have found the position where
    `EIP` has been overwritten, we can replace the repeated return address value by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will have to add our nop slide. So that part of the exploit script
    changes to the following line in the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we build the complete shellcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can combine these lines of script under the `exploit()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This was a short and simple demonstration of how we can convert an existing
    exploit into a Metasploit module. The difficulty level of this process can vary
    from exploit to exploit. The best way to learn more about it is by viewing the
    available exploit modules in the Metasploit library. In the next recipe, we will
    learn how to port this exploit module into the framework so that we can use it
    for penetration testing.
  prefs: []
  type: TYPE_NORMAL
- en: Porting and testing the new exploit module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned about developing a complete exploit module
    for Metasploit using the available proof of concept. In this recipe, we will save
    the module in an appropriate location and then test it to see whether everything
    goes fine.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is very essential to take care of the folder where we are going to store
    our exploit module. This can help you in keeping a track of different modules
    and also facilitates the framework in understanding the basic module usage. Now
    that you have the complete module script, let us find out an appropriate location
    to save it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As this is an exploit module, targeting the Windows operating system which affects
    a particular file format, we will have to select the module location accordingly.
    Looking at the `modules/exploits/windows` directory you can find a specific folder
    for `fileformat` exploit modules. This is the location where we can save our module.
    Let us save it as `galan_fileformat_bof.rb`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next and final task will be to check if our module is functioning fine
    or not. We have already worked a lot with modules so far, so this step will be
    easy going. We will follow the same process that we have used so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once the exploit command is passed, the module will execute and create a file
    that can be used to cause an overflow on the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: This completes our module creation and execution process. You might have seen
    that the process is straightforward. The real effort lies in proper conversion
    of exploit scripts into a framework module. You can debug or modify any existing
    module according to your need. You can also submit any newly created module to
    the Metasploit community to help others benefit from it.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing with Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fuzz testing or Fuzzing is a software testing technique which consists of finding
    implementation bugs using random data injection. Fuzz scripts generate malformed
    data and pass it to the particular target entity to verify its overflow capacity.
    Metasploit provides several fuzzing modules that can be helpful in exploit development.
    Let us explore more about the basics of fuzzing and how Metasploit modules can
    be used as potential fuzzers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we jump to Metasploit fuzzer modules, let us have a brief overview of
    fuzzing and its types.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing is treated as a black box testing technique where we test for the maximum
    overflow capacity of the software. Fuzzing is actively used to find bugs in applications.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzers can be used to test software, protocols, and file formats. Fuzzers automate
    the process of data generation and injection. We can control the size of data
    or packet to be injected.
  prefs: []
  type: TYPE_NORMAL
- en: 'A fuzzer would try combinations of attacks on:'
  prefs: []
  type: TYPE_NORMAL
- en: Numbers (signed/unsigned integers, float, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chars (URLs and command-line inputs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Metadata: user-input text (the `id3` tag)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure binary sequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending upon the type of an application or a protocol we are targeting, we
    can set up our fuzzer to generate data/packets to test its overflow. Metasploit
    contains several fuzzer modules that can be used to test applications and protocols
    against black box testing. These modules can be located at `modules/auxiliary/fuzzers`.
    Let us analyze the implementation of these modules.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us experiment with a protocol-based fuzzer module. Metasploit has an FTP
    module named `client_ftp.rb` which acts as an FTP server and sends responses to
    the FTP client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can see there are many interesting parameters available to us. Let us find
    out what functionality each parameter holds.
  prefs: []
  type: TYPE_NORMAL
- en: The `CYCLIC` option is used to set up a cyclic pattern as fuzz data. This is
    done to determine offsets as every fourth byte of string is unique. If it is set
    to false, then the fuzzer will use a string of A's as the fuzz data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ENDSIZE` option defines the maximum length of fuzz data to send back to
    the FTP client. By default, it is set as 20000 bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ERROR` option, if set to true, will reply to the FTP client using error
    codes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `EXTRALINE` option is a fuzz test for directory listing. Some FTP clients
    can crash if a very large directory name request is sent to the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `FUZZCMDS` option allows us to define which response needs to be fuzzed.
    The possible requests are `LIST, NLST, LS, RETR`. We can also set `*` to fuzz
    all commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SRVHOST` option is the IP address where the fuzzer will bind with the FTP
    server. For a local machine, we can use `0.0.0.0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SRVPORT` option is the FTP server port which is by default 21.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `STARTSIZE` option is used to define the initial data length of the fuzz
    data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `STEPSIZE` option is used to define the increment each time the overflow
    fails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One should be careful when working with fuzzers. If the right parameter values
    are not passed, then fuzz testing might fail. You can always refer to the module
    source code to understand the fuzzer deeply. Let us run our FTP client fuzzer
    and see what output is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The output has several things to note. First of all, the FTP server is started
    on the attacking machine. Then, it connects back with the FTP client. Then, it
    starts sending different response commands to the client machine. The fuzzing
    process starts with the `NLST` command. Then, it moves on to LIST and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This was a small demonstration of how fuzzer modules work. In the next recipe,
    we will take a deeper look into protocol fuzzing by building our own fuzzing module.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fuzzers create different test cases according to the application we want to
    fuzz. In our example, the FTP server can be fuzzed by sending random data packets
    and then analyzing their response. The data packets can fuzz the following attributes
    over a network:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Packet header:** Fuzzers can insert random data packets of arbitrary length
    and value in the headers and analyze their response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packet checksum:** The checksum values can also be manipulated under specific
    conditions using fuzzers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packet size:** Data packets of arbitrary length can also be sent to the network
    application in order to determine a crash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a crash or overflow has been reported, the fuzzer can return its test case
    to provide the overflow data.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a simple FileZilla FTP fuzzer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We analyzed the working of fuzzer modules in our previous recipe. Let us take
    it a step ahead by building our own small FTP fuzzer that can be used against
    the FileZilla FTP server.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic template to build a fuzzer will be similar to the one we discussed
    for the development of an auxiliary module. So our basic template should look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: So we have imported the MSF libraries, created a class, and defined our options.
    The next step will be to define the main body of the fuzzer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let us analyze the script. The script begins with creating a UDP socket that
    will be required to establish a connection with the FileZilla server. Then, we
    declare variables `startsize` and `count` which holds the values for starting
    the data size of the fuzzer and increment length respectively. Then, we set up
    a loop under which we declare our evil string and a payload format that will be
    sent as a packet (pkt).
  prefs: []
  type: TYPE_NORMAL
- en: Then, the script tries to send the data packet to the server using the `udp_sock_sendto`
    function and its response is captured using `resp=udp_sock.get()`. Further, the
    count of the packet is increased by 100 every time the response is received.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start working with the module, we will have to save it under `modules/auxiliary/fuzzers/ftp`.
    Let us name the fuzzer module as `filezilla_fuzzer.rb:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'So, our module is working fine and displaying the available options to us.
    Let us pass the respective values and see what happens when we pass the `run`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Bingo! The fuzzer starts sending strings to the server and continues the process
    unless the server crashes or the loop ends. If the loop ends before the crash,
    then you can modify the script to send a bigger string length. This is a simple
    demonstration of using Metasploit to fuzz software. Generally it is not recommended
    to use Metasploit as a fuzzing platform for large software. We have several dedicated
    frameworks that are specially made for fuzzing software and applications.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us give a quick look to a fuzzing framework that you can work on if you
    want to enhance your knowledge of fuzzing and exploit development.
  prefs: []
  type: TYPE_NORMAL
- en: Antiparser fuzzing framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Antiparser is a fuzzing framework written in python. It assists in the creation
    of random data specifically for the construction of fuzzers. This framework can
    be used to develop fuzzers that will run across multiple platforms as the framework
    depends solely on the availability of a Python interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Antiparser can be downloaded from [http://sourceforge.net/projects/antiparser/](http://sourceforge.net/projects/antiparser/).
  prefs: []
  type: TYPE_NORMAL
