- en: Setting up a Backend for a Chat App Using Azure Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will build a chat app with real-time communication. To do
    this, we need a backend. We will create a backend that can scale up to handle
    a large number of users but also scale down when the number of users is reduced.
    To build that backend, we will use a serverless architecture based on services
    in Microsoft Azure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a SignalR service in Microsoft Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Azure functions as an API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling jobs with Azure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using blob storage to store photos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Azure Cognitive Services to scan photos for adult content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to complete this project, you need to have Visual Studio for Mac
    or PC installed. See [Chapter 1](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml),
    *Introduction to Xamarin*, for more details on how to set up your environment. You
    also need an Azure account. If you have a Visual Studio subscription, there is
    a specific amount of Azure credits included each month. To activate your Azure
    benefits, go to the following link: [https://my.visualstudio.com](https://my.visualstudio.com).
  prefs: []
  type: TYPE_NORMAL
- en: You can also create a free account, where you can use selected services for
    free over 12 months. You will get $200 worth of credit to explore any Azure service
    for 30 days and you can also use the free services at any time. Read more at the
    following link: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  prefs: []
  type: TYPE_NORMAL
- en: Azure serverless services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start to build a backend with a serverless architecture, we need to
    define what serverless actually means. In a serverless architecture, of course
    the code will run on a server, but we don't need to worry about that; the only
    thing we need to focus on is building our software. We let someone else handle
    everything to do with servers. We don't need to think about how much memory or
    CPU the server needs, or even how many servers we need. When we use services in
    Azure, Microsoft takes care of this for us.
  prefs: []
  type: TYPE_NORMAL
- en: Azure SignalR Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Azure SignalR Service** is a service in **Microsoft Azure** for real-time
    communication between a server and clients. The service will push content to the
    clients without them having to poll the server to get content updates. SignalR
    can be used for multiple types of applications, including mobile applications,
    web applications, and desktop applications.
  prefs: []
  type: TYPE_NORMAL
- en: SignalR will use WebSockets if that option is available. If it is not, SignalR
    will use other techniques for communication, such as **Server-Sent Events** (**SSE**)
    or **long polling**. SignalR will detect which transport technology is available
    and use it without the developer having to think about it at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'SignalR can be used in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chat applications**: Where the application needs updates from the server
    immediately when new messages are available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaborative applications**: For example, meeting applications or when users
    on multiple devices are working with the same document'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiplayer games**: Where all users need live updates about other users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dashboard applications**: Where users need live updates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure functions is a Microsoft Azure service that allows us to run code in a
    serverless way. We will deploy small pieces of code called **Functions**.Functions
    are deployed in groups, called **Function Apps**. When we are creating a Function
    App, we need to select whether we want it to run on a consumption plan or on an
    app service plan. We select a consumption plan if we want the application to be
    completely serverless, while with an app service plan, we have to specify the
    requirements of the server. With a consumption plan, we pay for the execution
    time and for how much memory the function uses. One benefit of the app service
    plan is that you can configure it to be Always On and you won't have any cold
    starts as long as you don't have to scale up to more instances. The big benefit
    of a consumption plan is that it will always scale according to which resources
    are needed at that time.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways in which a function can be triggered to run. Two examples
    are `HttpTrigger` and `TimeTrigger`. `HttpTrigger` will trigger the function to
    run when an HTTP request is calling the function. With `TimeTrigger`, functions
    will run at an interval that we can specify. There are also triggers for other
    Azure services. For example, we can configure a function to run when a file is
    uploaded to blob storage, when a new message is posted to an event hub or service
    bus, or when data is changed in an Azure CosmosDB.
  prefs: []
  type: TYPE_NORMAL
- en: Azure blob storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure blob storage is used for storing unstructured data objects, such as images,
    videos, audio, and documents. Objects or blobs can be organized into containers. Blob
    storage can be redundant over multiple data centers in Azure. This to protect
    the data from unplanned events ranging from transient hardware failures to network
    or power outages, or even massive natural disasters. Blob storage in Azure can
    have different tiers, depending on how often we want to use the objects that we
    are storing. These include archive and cold tiers, and hot and premium tiers,
    which are used for applications in which we need to access data more often. As
    well as blob storage, we can add a **Content Delivery Network** (**CDN**) to make
    the content in our storage closer to our users. This is important if we have users
    around the globe. If we can deliver our content from a place that is closer to
    the user, we can reduce the loading time of content and we can give the users
    a better experience.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Cognitive Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to describe **Azure Cognitive Services** is that it is **Machine
    Learning** as a service. With just a simple API call, we can use machine learning
    in our applications, without which we have to use complex data science techniques.
    When we use APIs, we are making predictions against the models that Microsoft
    has trained for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The services in Azure Cognitive Services have been organized into five categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vision**: The vision services are about image processing. These include APIs
    for face recognition, detection of adult content, image classification, and **Optical
    Character Recognition** (**OCR**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Knowledge**: An example of a knowledge service is the **Question and Answer**
    (**QnA**) makers that allow us to train a model with a knowledge base. When we
    have trained the model, we can use it for getting answers when we are asking questions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language**: The language services are about understanding text, such as text
    analytics, language understanding, and translations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speech**: Examples of speech APIs include speaker recognition, speech-to-text
    functionality, and speech translation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Search**: The search services are about using the power of a web search engine
    to find an answer to your problems. These include knowledge acquisition from images,
    the auto-completion of search queries, and the identification of similar people.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This project will be to set up the backend for a chat application. The biggest
    part of the project will be the configuration that we will carry out in the Azure
    portal. We will also write some code for the Azure Functions that will handle
    the SignalR connections. There will be one function to return information about
    the SignalR connection and one that posts messages to the SignalR service. The
    function that we will post messages to will also determine whether the message
    contains an image. If it does, it will be sent to the Vision API in Azure Cognitive
    Services to analyze whether it contains adult content. If it does, it won't be
    posted to the SignalR service and the other users will not get it. Because the
    SignalR service has a limitation about how big messages can be, we need to store
    images in blob storage and just post the URL of the image to the users. Because
    we don't save any chat history in this app, we also want to clear the blob storage
    at specific intervals. To do this, we will create a function that uses `TimeTrigger`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows an overview of the architecture of this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d439ffb-2128-471c-95c7-422d7b1cda07.png)'
  prefs: []
  type: TYPE_IMG
- en: The estimated time to complete this project is about two hours.
  prefs: []
  type: TYPE_NORMAL
- en: Building the serverless backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start setting up the backend based on the services described in the preceding
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a SignalR service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first service that we will set up is the one for SignalR:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Azure portal: [https://portal.azure.com](https://portal.azure.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new resource. The **SignalR Service** is in the web category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in a name for the resource in the form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the subscription you want to use for this project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We recommend that you create a new Resource Group and use it for all resources
    that we will create for this project. The reason that we want one resource group
    is that it is easier to track what resources are related to this project, and
    it is also easier to delete all the resources together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a location that is close to your users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select a pricing tier. For this project, we can use the free tier. We can always
    use the free tier for development and later scale up to a tier that can handle
    more connections. Refer to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/62b6c152-5606-4f37-962b-4a128ffefab8.png)'
  prefs: []
  type: TYPE_IMG
- en: This is all we need to do to set up a SignalR Service. We will return to it
    in the Azure portal later to grab a connection string to it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a storage account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to set up a storage account in which we can store the images
    that are uploaded by the users:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Storage Account resource. Storage Account is found under the Storage
    category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a subscription and a resource group. We recommend that you use the same
    as you did for the SignalR Service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the storage account a name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a location that is close to your users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a performance option. If we use Premium storage, the data will be stored
    on SSD disks. Select Standard storage for this project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use StorageV2 for the Account kind.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In replication, we can select how we want our data to be replicated across the
    data centers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the access tier, we will use Hot, because we will need to access the data
    frequently in this app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Create + review to review the settings before creating the storage account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click Create to create the storage account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f385b548-0a0f-4097-9513-c284754453b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The last step of the configuration of the blob storage is to go to the resource
    and create a container for the chat images:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the resource and select Blobs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a New container with the name `chatimages`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the Public access level to Blob (anonymous read access for blobs only).
    This means that it will have public read access, but that you have to be authorized
    to upload content. Refer to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f71fdee8-2685-4e61-8b4a-4563de5ea35b.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a Cognitive Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to use **Cognitive Services** to scan images for adult content,
    we need to create a resource in the Azure portal. This will give us a key that
    we can use when making calls to the API:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Custom Vision resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the resource a name and select a subscription.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a location that is close to your users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a pricing tier for prediction and training. This app will only use predictions
    because we will use a model that is already trained.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the same resource groups as you selected for the other resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click OK to create the new resource. Refer to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/35760e18-4d2d-4569-93ed-64609451c594.png)'
  prefs: []
  type: TYPE_IMG
- en: We have now finished creating the Cognitive Service. We will come back later
    to grab a key that we will use for the calls we will make against the API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code we will write in the backend will be functions. We will use version
    2 of Azure Functions, which will run on top of .NET Core. Version 1 ran on top
    of the full .NET framework.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Azure service for functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start to write any code, we will create the Function App. This will
    contain the functions in the Azure portal:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Function App resource. Function App is found under the Compute
    category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the Function App a name. The name will also be the start of the URL of
    the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a subscription for the Function App.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a resource group for the Function App, which should be the same as the
    other resources we have created in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because we will use .NET Core as the runtime for the functions, we can run them
    in both Windows and Linux. In this case, however, we will run them in Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will use the Consumption Plan as our Hosting Plan, so we only pay for what
    we use. The Function App will scale both up and down according to our requirements,
    without us having to think about it at all, if we select a Consumption Plan.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a location that is close to your users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select .NET as the Runtime stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For storage, we can either create a new storage account or use the one we created
    earlier in this project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set Application Insights to be On so that we can monitor our functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click Create to create the new resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6c829370-40e8-4cef-b9a3-b4a11a9afec7.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a function to return the connection information for the SignalR service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want, you can create functions in the Azure portal. I prefer to use
    Visual Studio, however, because the code editing experience is much better and
    you can use version tracking for the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project in Visual Studio of the Azure Functionstype. This can be
    found under the Cloud tabof the new project dialog box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the project `Chat.Functions`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click OK to continue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/164daf00-aeb7-4a95-af57-836603c096eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to create our first function:'
  prefs: []
  type: TYPE_NORMAL
- en: Select Azure Functions v2 (.NET Core) at the top of the dialog box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Http trigger as the trigger for our first function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the **Access rights** from Admin to Anonymous.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click OK to continue and our functions project will be created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eb5a4909-85eb-49dd-9769-cf701904b327.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our first function will return the connection information for the SignalR service.
    To do that, we need to connect the function by adding a connection string to the
    SignalR service:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the SignalR Service resource in the Azure Portal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the Keys tab and copy the connection string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the Function App resource and add the connection string under Application
    Settings. Use `AzureSignalRConnectionString` as the name for the setting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the connection string to the `Values` array in the `local.settings.json`
    file in the Visual Studio project to be able to run the function locally on the
    development machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can write the code for the function that will return the connection
    information. Go to Visual Studio and follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the `Microsoft.Azure.WebJobs.Extensions.SignalRService` NuGet package
    in the functions project. The package contains the classes we need to communicate
    with the SignalR service. It is a prerelease package so we have to check the Include
    prerelease checkbox. If an error occurs during this and you are not able to install
    the package, make sure that you have the latest version of all other packages
    in the project and try again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the function that was created when we created the functions project as `GetSignalRInfo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, rename the class as `GetSignalRInfo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To implement the binding to the SignalR service, we will add a parameter of
    the `SignalRConnectionInfo` type to the method of the function. The parameter
    will also have the `SignalRConnectionInfo` attribute, which specifies `HubName`,
    as in the following code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Return the connection info parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating a message library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now define a couple of message classes that we will use to send the
    chat messages. We will create a base message class that will contain information
    that is shared between all types of messages. We will also create a separate project
    for the messages, which will be a .NET Standard library. The reason that we will
    create it as a separate .NET Standard library is that we then can reuse it in
    the app we will build in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new .NET Standard 2.0 project and name it `Chat.Messages`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a reference to `Chat.Messages` in the `Chat.Functions` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class and name it `Message` in the `Chat.Messages` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `TypeInfo` property to the `Message` class. We need this property later
    in [Chapter 7](569915b8-d374-4dce-9c18-589fdadd5459.xhtml), *Building a Real-Time
    Chat Application*, when we will carry out serialization of the messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a property for the `Id` of the `string`type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a property for the `Timestamp` of the `DateTime`type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a property for the `Username` of the `string`type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an empty constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a constructor that takes a username as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the values of all properties as in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When a new client is connecting, a message will be sent to other users to indicate
    that they have connected:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `UserConnectedMessage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `Message` as the base class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an empty constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a constructor that takes the username as a parameter and sends it to the
    constructor of the base class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When a client is sending a message with text, it will send a `SimpleTextMessage`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `SimpleTextMessage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `Message` as the base class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an empty constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a constructor that takes the username as a parameter and sends it to the
    constructor of the base class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a string property called `Text`. Refer to the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If a user uploads an image, it will be sent to the functions as a `base64`
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `PhotoMessage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `Message` as the base class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an empty constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a constructor that takes the username as a parameter and sends it to the
    constructor of the base class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a string property called `Base64Photo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a string property called `FileEnding` as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The last message we will create is used to send information about a photo to
    the user:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `PhotoUrlMessage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `Message` as the base class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an empty constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a constructor that takes the username as a parameter and sends it to the
    constructor of the base class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a string property called `Url`. Refer to the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Creating a storage helper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a helper to share some of the code that we will write for Azure
    Blob Storage between the send message function and the clear photos function that
    we will create. When we are creating the Function App in the Azure Portal, a setting
    for the connection string is created so we just have to add this to the `local.settings.json`
    file in order to be able to run it locally. The name for the connection string
    will be `StorageConnection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For the helper, we will create a new static class, as given in the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the `WindowsAzure.Storage NuGet` package in the `Chat.Functions` project.
    This is to get the classes we need to work with storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class called `StorageHelper` in the `Chat.Functions` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the class `static`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new static method called `GetContainer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the static `GetEnviromentVariable` method on the `Environment` class to
    read the connection string for storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `CloudStorageAccount` object of it using the static `Parse` method
    on `CloudStorageAccount`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `CloudBlobClient` using the `CreateCloudBlobClient` method on the
    `CloudStorageAccount` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Get the container reference using the `GetContainerReference` method on the
    `CloudBlobClient` class and pass the name of the container we created earlier
    in the chapter as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To upload files to the blob storage, we will create a method that has the bytes
    of the photo and what type of photo it is as parameters. The photo type will be
    defined by its file ending:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `async static` method that returns `Task<string>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `byte[]` and a `string` parameter to the method. Name the parameters `bytes`
    and `fileEnding`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `GetContainer` method to get a reference to the container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a filename for the new blob and use it as an argument to `GetBlockBlobReference`
    in the `CloudBlobContainer` class. Use `GUID` as the filename to make sure that
    it is unique.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `MemoryStream` of the bytes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `UploadFromStreamAsync` method on the `BlockBlobReference` class to
    upload the photo to the cloud.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Return the `AbsoluteUri` of the blob:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The second public method that we will add to the helper is a method to delete
    all photos that are older than an hour:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `async static` method called `Clear` that returns `Task`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `GetContainer` method to get a reference to the container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get all blobs in the container by calling the `ListBlobsSegmentedAsync` method
    with the arguments shown in the following code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop through all blobs that are of the `CloudBlob` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an `if` statement to check whether the photos were created more than an
    hour ago. If so, the blob should be deleted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Creating a function for sending messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To handle messages that are sent by the user, we will create a new function:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a function with an `HttpTrigger` and with anonymous access rights.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the function `Messages`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a collection of `SignalRMessage` as in the following code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `SignalR` attribute to specify the hub name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The message parameter will be the message that the user sent. It will be of
    the `JObject` type (from `Newtonsoft.Json`). We need to convert it to the `Message`
    type that we created earlier. To do that, we need to add a reference to the `Chat.Messages`
    project. However, because the parameter is of an object type, we first need to
    cast it to `JObject`. Once we have done this, we can use the `ToObject` method
    to get a `Message`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If the message is a `PhotoMessage`, we will upload the photo to blob storage.
    All other messages will be sent directly to the SignalR service using the `AddAsync`
    method on the `signalRmessages` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we upload the photo to blob storage with the helper we created, we need
    to convert the `base64` string to a `byte[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the static `FromBase64String` method on the `Converter` class to convert
    the `base64` string to a `byte[]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload the photo to blob storage with the static `Upload` method on `StorageHelper`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `PhotoUrlMessage`, pass the username to the constructor, and set
    it as the value for the `msg` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Timestamp` property to the value of the original message, because we
    are interested in when the message was created by the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Id` property to the value of the original message so that it will be
    handled as the same message on the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Url` property to the URL that was returned by `StorageHelper` when
    we uploaded the photo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `AddAsync` method on the `signalRMessages` variable to send a message
    to the SignalR service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an empty return statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using the Computer Vision API to scan for adult content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To minimize the risk that offensive photos are shown in our chat, we will use
    machine learning to try to find problematic material and prevent it from being
    posted to the chat. For that, we will use the **Computer Vision API** in Azure,
    which is a part of the **Azure Cognitive services**. To use the API, we need a
    key. We will add it to the application settings of the Function App:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Azure Portal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the resource we created for the Custom Vision API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The key can be found under the Keys tab. You can use either Key 1 or Key 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the resource for `Function App`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the Key as an application setting named `ComputerVisionKey`. Also, add the
    key to `local.settings.json`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, add the Endpoint as an application setting. Use the name `ComputerVisionEndpoint`.
    The Endpoint can be found under the Overview tab of the Function App resource. Also,
    add the Endpoint to `local.settings.json`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `Microsoft.Azure.CognitiveServices.Vision.ComputerVision` NuGet
    package in the `Chat.Functions` project in Visual Studio. This isto get the necessary
    classes to use the Computer Vision API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code for the call to the Computer Vision API will be added to the `Message`
    function. After that, we convert the `base 64` string to a `byte[]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `MemoryStream` based on the byte array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `ComputerVisonClient` as shown in the following code and send the credentials
    to the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a list of which features we will use when we are analyzing the photo. In
    this case, we will use the `VisualFeatureTypes.Adult` feature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `AnalyzeImageInStreamAsync` method on `ComputerVisionClient` and pass
    the stream and feature list to the constructor to analyze the photo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the result is `IsAdultContent`, stop the execution of the function by using
    an empty return statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Creating a scheduled job to clear photos from storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last thing we will do is clean the blob storage at regular intervals and
    delete photos that are older than one hour. We will do that by creating a function
    that is triggered by `TimeTrigger`:'
  prefs: []
  type: TYPE_NORMAL
- en: To create a new function, right-click the `Chat.Functions` project and click
    New Azure Function, which will be found under the Add menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the function `ClearPhotos`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select that the function will use a Time trigger, because we want it to run
    on a time interval.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use a chron expression to set the Scheduleto `0 */60 * * * *` to make it run
    every 60 minutes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/edc5a51c-8e9e-44e9-b55a-b040ec05de41.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The only thing we will do in the `ClearPhotos` function is call the `Clear`
    method of the `StorageHelper` that we created earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Deploying the functions to Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last step in this chapter is to deploy the functions to Azure. You can
    do that as a part of a CI/CD pipeline, for example with Azure DevOps. But the
    easiest way to deploy the functions in this case is to do it directly from Visual
    Studio. Follow these steps to deploy the functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `Chat.Functions` project and select Publish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Select existing option. Also, check the `Run from package` file option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the Create profile button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sign in to the same Microsoft account that we used in the Azure portal when
    we were creating the Function App.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the subscription that contains the Function App. All Function Apps we
    have in the subscription will now be loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Function App and click OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the profile is created, click the Publish button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the last step. After that, the publishing profile
    is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fc2606f-d4e0-436b-97ef-d6b867fa5f85.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to set up a serverless backend for real-time
    communication with Azure Functions and the Azure SignalR Service. We have also
    learned how to use blob storage and machine learningwith the Azure Cognitive Services
    to scan for adult content in photos.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build a chat app that will use the backend we have
    built in this project.
  prefs: []
  type: TYPE_NORMAL
