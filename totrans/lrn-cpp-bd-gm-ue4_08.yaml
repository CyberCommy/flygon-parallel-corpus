- en: Actors and Pawns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will really delve into UE4 code. At first, it is going to look daunting.
    The UE4 class framework is massive, but don''t worry: the framework is massive
    so your code doesn''t have to be. You will find that you can get a lot done and
    a lot onto the screen using a lot less code. This is because the UE4 engine code
    is so extensive and well-programmed that they have made it possible to accomplish
    almost any game-related task easily. Just call the right functions and voila,
    what you want to see will appear on the screen. The entire notion of a framework
    is that it is designed to let you get the gameplay you want, without having to
    spend a lot of time sweating out the details.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The learning outcomes from this chapters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Actors versus pawns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a world to put your actors in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UE4 editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting from scratch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an actor to the scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a player entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing C++ code that controls the game's character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating non-player character entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a quote from each NPC dialog box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actors versus pawns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss actors and pawns. Although it sounds as if
    pawns will be a more basic class than actors, it is actually the other way around.
    A UE4 actor (the `Actor` class) object is the basic type of the things that can
    be placed in the UE4 game world. In order to place anything in the UE4 world,
    you must derive from the `Actor` class.
  prefs: []
  type: TYPE_NORMAL
- en: A `Pawn` is an object that represents something that you or the computer's **Artificial
    Intelligence** (**AI**) can control on the screen. The `Pawn` class derives from
    the `Actor` class, with the additional ability to be controlled by the player
    directly or by an AI script. When a pawn or actor is controlled by a controller
    or AI, it is said to be possessed by that controller or AI.
  prefs: []
  type: TYPE_NORMAL
- en: Think of the `Actor` class as a character in a play (although it could also
    be a prop in a play). Your game world is going to be composed of a bunch of *actors*,
    all acting together to make the gameplay work. The game characters, **Non-Player
    Characters** (**NPC**s), and even treasure chests will be actors.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a world to put your actors in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we will start from scratch and create a basic level into which we can
    put our game characters. The UE4 team has already done a great job of presenting
    how the world editor can be used to create a world in UE4\. I want you to take
    a moment to create your own world by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new, blank UE4 project to get started. To do this, in the Unreal Launcher,
    click on the Launch button beside your most recent engine installation, as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3d0f9dc1-a80e-4e54-9c15-0c8881dad25a.png)'
  prefs: []
  type: TYPE_IMG
- en: That will launch the Unreal Editor. The Unreal Editor is used to visually edit
    your game world. You're going to spend a lot of time in the Unreal Editor, so
    please take some time to experiment and play around with it.
  prefs: []
  type: TYPE_NORMAL
- en: I will only cover the basics of how to work with the UE4 editor. You will need
    to let your creative juices flow, however, and invest some time in order to become
    familiar with the editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about the UE4 editor, take a look at the *Getting Started: Introduction
    to the UE4 Editor* playlist, which is available at [https://www.youtube.com/playlist?list=PLZlv_N0_O1gasd4IcOe9Cx9wHoBB7rxFl](https://www.youtube.com/playlist?list=PLZlv_N0_O1gasd4IcOe9Cx9wHoBB7rxFl).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be presented with the Projects dialog. The following screenshot shows
    the steps to be performed with numbers corresponding to the order in which they
    need to be performed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a610e410-863d-4628-888b-504b78722746.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Perform the following steps to create a project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the New Project tab at the top of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the C++ tab (the second sub-tab).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Basic Code from the available projects listing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the directory where your project is located (mine is Y:Unreal Projects).
    Choose a hard disk location with a lot of space (the final project will be around
    1.5 GB).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your project. I called mine GoldenEgg.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Create Project to finalize project creation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you've done this, the UE4 launcher will launch Visual Studio (or Xcode).
    This could take a while, and the progress bar could wind up behind other windows.
    There will only be a couple of source files available, but we're not going to
    touch those now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that Development Editor is selected from the Configuration Manager
    dropdown at the top of the screen, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6107dc53-907d-420b-bfdb-9b37e848dcdf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Unreal Editor will also have been launched, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c5ccf1d-cd4b-4fb6-8595-b3376e98bdab.png)'
  prefs: []
  type: TYPE_IMG
- en: The UE4 editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will explore the UE4 editor here. We'll start with the controls since it
    is important to know how to navigate in Unreal.
  prefs: []
  type: TYPE_NORMAL
- en: Editor controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''ve never used a 3D editor before, the controls can be quite hard to
    learn. These are the basic navigation controls while in edit mode:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the arrow keys to move around in the scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Press *Page Up* or *Page Down* to go up and down vertically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Left mouse click + drag it left or right to change the direction you are facing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Left mouse click + drag it up or down to *dolly* (move the camera forward and
    backward, same as pressing up/down arrow keys)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right mouse click + drag to change the direction you are facing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Middle mouse click + drag to pan the view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right mouse click and the *W*, *A*, *S*, and *D* keys to move around the scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play mode controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Click on the Play button in the bar at the top, as shown in the following screenshot.
    This will launch play mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9110d2aa-8a04-46d7-b1b4-f6520d6fdf75.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you click on the Play button, the controls change. In play mode, the controls
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The *W*, *A*, *S*, and *D* keys for movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The left or right arrow keys to look toward the left or right, respectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mouse's motion to change the direction in which you look
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Esc* key to exit play mode and return to edit mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, I suggest you try to add a bunch of shapes and objects to the
    scene and try to color them with different *materials*.
  prefs: []
  type: TYPE_NORMAL
- en: Adding objects to the scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding objects to the scene is as easy as dragging and dropping them in from
    the Content Browser tab, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Content Browser tab appears, by default, docked at the bottom of the window.
    If it isn''t seen, simply select Window and navigate to Content Browser in order
    to make it appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/807f76e7-3dcc-47e5-8257-83ad5a5ef5e2.png)'
  prefs: []
  type: TYPE_IMG
- en: Make sure that the Content Browser is visible in order to add objects to your
    level
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the `StarterContent` folder to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click the `Props` folder to find objects you can drag into your scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag and drop things from the Content Browser into your game world:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/836a4d4e-0f9a-4ba5-99cf-4934c60f92ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To resize an object, press *R* on your keyboard (hit *W* to move it again,
    or *E* to rotate the object). The manipulators around the object will appear as
    boxes, which denotes resize mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a2034959-5072-4e20-ba52-d6b7d91e2461.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To change the material that is used to paint the object, simply drag and drop
    a new material from the Content Browser window inside the Materials folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7eb693d2-dcc1-4c9c-a3ba-6236a1ae129f.png)'
  prefs: []
  type: TYPE_IMG
- en: Materials are like paints. You can coat an object with any material you want
    by simply dragging and dropping the material you desire onto the object you desire
    it to be painted on. Materials are only skin deep; they don't change the other
    properties of an object (such as weight).
  prefs: []
  type: TYPE_NORMAL
- en: Starting a new level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to start creating a level from scratch, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on File and navigate to New Level..., as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/13852d6b-750d-4e72-a365-ac1071e21140.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can then select between Default, VR-Basic, and Empty Level. I think selecting
    Empty Level is a good idea:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b38499e3-8b1e-46f2-a2d1-92f421a87646.png)'
  prefs: []
  type: TYPE_IMG
- en: The new level will be completely black to start with. Try dragging and dropping
    some objects from the Content Browser tab again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This time, I added a resized shapes/shape_plane for the ground plane (don't
    use the regular plane under modes or you'll fall through it once you add the player)
    and textured it with T_ground_Moss_D, a couple of Props / SM_Rocks, and Particles
    / P_Fire.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be sure to save your map. Here''s a snapshot of my map (how does yours look?):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1d1b823-1c5e-422e-9501-3c2afa46821f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to change the default level that opens when you launch the editor,
    go to Edit | Project Settings | Maps & Modes; then, you will see a Game Default
    Map and Editor Startup Map setting, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f5069206-46dc-4fd0-af8c-7e63d548efa0.png)'
  prefs: []
  type: TYPE_IMG
- en: Just make sure you save the current scene first!
  prefs: []
  type: TYPE_NORMAL
- en: Adding light sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that your scene may appear completely (or mostly) black when you try to
    run it. This is because you haven't put a light source in it yet!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous scene, the P_Fire particle emitter acts as a light source,
    but it only emits a small amount of light. To make sure that everything appears
    well lit in your scene, you should add a light source, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to Window and then click on Modes to ensure that the light sources panel
    is shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/536b5a94-2f3d-4d35-b2b3-4c7399e8ad5e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the Modes panel, drag one of the Lights objects into the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9e64a618-4720-4acc-a369-83b053f2b03c.png)'
  prefs: []
  type: TYPE_IMG
- en: Select the Lightbulb and box icon (it looks like a mushroom, but it isn't).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Lights in the left-hand panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the type of light you want and just pull it into your scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you don't have a light source, your scene will appear completely black when
    you try to run it (or if there are just no objects in the scene).
  prefs: []
  type: TYPE_NORMAL
- en: Collision volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have noticed that, so far, the camera just passes through at least
    some of the scene geometry, even in play mode. That's not good. Let's make it
    so that the player can't just walk through the rocks in our scene.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few different types of collision volumes. Generally, perfect mesh-mesh
    collisions are way too expensive to do at runtime. Instead, we use an approximation
    (a bounding volume) to guess the collision volume.
  prefs: []
  type: TYPE_NORMAL
- en: A mesh is the actual geometry of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Adding collision volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we have to do is associate a collision volume with each of the
    rocks in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this from the UE4 editor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on an object in the scene for which you want to add a collision volume.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click on this object in the World Outliner tab (the default appears on
    the right-hand side of the screen) and select edit, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cfd4d03d-80a9-4853-9685-7727f7d73ab6.png)'
  prefs: []
  type: TYPE_IMG
- en: You will find yourself in the mesh editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the Collision menu and then click on Add Capsule Simplified Collision:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/934c27c4-7f97-421e-8b25-4cbdb7f064d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The collision volume, when added successfully, will appear as a bunch of lines
    surrounding the object, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ddf3cd4b-6b70-4b18-8664-c32c781dae5b.png)'
  prefs: []
  type: TYPE_IMG
- en: The default collision capsule (left) and manually resized versions (right)
  prefs: []
  type: TYPE_NORMAL
- en: You can resize (R), rotate (E), move (W), and change the collision volume as
    you wish, the same way you would manipulate an object in the UE4 editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you're done adding collision meshes, save and go back to the main editor
    window and click on Play; you will notice that you can no longer pass through
    your collidable objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding the player to the scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a scene up and running, we need to add an actor to the scene.
    Let's first add an avatar for the player, complete with a collision volume. To
    do this, we'll have to inherit from a class from the UE4 `GameFramework` such
    as `Actor` or `Character`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create an onscreen representation of the player, we'll need to derive
    from the `ACharacter` class in Unreal.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting from UE4 GameFramework classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'UE4 makes it easy to inherit from the base framework classes. All you have
    to do is perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your project in the UE4 editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to File and then select New C++ Class...:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/88ecd03a-96b4-48a8-a5b5-fc45d6c067d7.png)'
  prefs: []
  type: TYPE_IMG
- en: Navigating to File | New C++ Class... will allow you to derive from any of the
    UE4 GameFramework classes
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose the base class you want to derive from. You have Character, Pawn, Actor,
    and so on, but for now, we will derive from Character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b2bf7b68-86ba-4a8a-a4ad-7c0c2cb7fee1.png)'
  prefs: []
  type: TYPE_IMG
- en: Select the UE4 class you want to derive from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on Next to get this dialog box, where you name the class. I named my
    player class `Avatar`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/72788a9d-a226-4aed-aac5-033641857c8d.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on Create Class to create the class in code, as shown in the preceding
    screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let UE4 refresh your Visual Studio or Xcode project if it asks you. Open the
    new `Avatar.h` file from the Solution Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: The code that UE4 generates will look a little weird. Remember the macros that
    I suggested you avoid in [Chapter 5](b03d850b-1687-48a9-83a0-412526247bed.xhtml),
    *Functions and Macros*? The UE4 code uses macros extensively. These macros are
    used to copy and paste boilerplate starter code that lets your code integrate
    with the UE4 editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of the `Avatar.h` file are shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's talk about macros for a moment.
  prefs: []
  type: TYPE_NORMAL
- en: The `UCLASS()` macro basically makes your C++ code class available in the UE4
    editor. The `GENERATED_BODY()` macro copies and pastes code that UE4 needs to
    make your class function properly as a UE4 class.
  prefs: []
  type: TYPE_NORMAL
- en: For `UCLASS()` and `GENERATED_BODY()`, you don't truly need to understand how
    UE4 works its magic. You just need to make sure that they are present at the right
    spot (where they were when you generated the class).
  prefs: []
  type: TYPE_NORMAL
- en: Associating a model with the Avatar class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we need to associate a model with our character object. To do this, we
    need a model to play with. Fortunately, there is a whole pack of sample models
    available from the UE4 marketplace for free.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading free models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create the player object, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the Animation Starter Pack file (which is free) from the Marketplace
    tab. The easiest way to find it is to search for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f1073a42-b50b-4964-8013-2a20e849d90f.png)'
  prefs: []
  type: TYPE_IMG
- en: From the Unreal Launcher, click on Marketplace and search for Animation Starter
    Pack, which is free at the time of writing this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you''ve downloaded the Animation Starter Pack file, you will be able to
    add it to any of the projects you''ve previously created, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/113956d6-bf7c-4cb6-95dd-efc546c88354.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you click on Add to project under Animation Starter Pack, you will get
    this popup, asking which project to add the pack to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/66f17733-1221-4546-92b5-0ed1c9e04730.png)'
  prefs: []
  type: TYPE_IMG
- en: Simply select your project and the new artwork will be available in your Content
    Browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loading the mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, it is considered a bad practice to hardcode your assets (or objects
    used in-game) into the game. Hardcoding means that you write C++ code that specifies
    the asset to load. However, hardcoding means the loaded asset is part of the final
    executable, which will mean that changing the asset that is loaded wouldn't be
    modifiable at runtime. This is a bad practice. It is much better to be able to
    change the asset loaded during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, we're going to use the UE4 blueprints feature to set up the
    model mesh and collision capsule of our `Avatar` class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a blueprint from our C++ class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and create a blueprint—it''s really easy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Class Viewer tab by navigating to Window | Developer Tools and then
    clicking on Class Viewer, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/40fa53a9-8873-4867-b9c1-e5646dffd0d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Class Viewer dialog, start typing in the name of your C++ class. If
    you have properly created and exported the class from your C++ code, it will appear,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b5a0efe8-efa9-4f15-b014-92c290522a84.png)'
  prefs: []
  type: TYPE_IMG
- en: If your `Avatar` class does not show up, close the editor and compile/run the
    C++ project in Visual Studio or Xcode again.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the class that you want to create a blueprint of (in my case,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: it's my Avatar class) and choose Create Blueprint Class....
  prefs: []
  type: TYPE_NORMAL
- en: Name your blueprint something unique. I called my blueprint BP_Avatar. BP_ identifies
    it as a blueprint and makes it easier to search for later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The new blueprint should open automatically for editing. If it doesn''t, open
    it by double-clicking on BP_Avatar (it will appear in the Class Viewer tab after
    you add it, just under Avatar), as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3354a828-7007-4665-9e70-bfa050b3bdd7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will be presented with the blueprints window for your new BP_Avatar object,
    as shown here (make sure to select the Event Graph tab):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ba5ad46c-4b2b-4838-a0d3-5e2a09809db5.png)'
  prefs: []
  type: TYPE_IMG
- en: From this window, you can attach a model to the `Avatar` class visually. Again,
    this is the recommended pattern since artists will typically be the ones setting
    up their assets for game designers to play with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your blueprint will have already inherited a default skeletal mesh. To see
    the options for it, click on Mesh (Inherited) under CapsuleComponent on the left:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/82e63e31-ade0-4cf5-9b21-8e1a16aad62b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the dropdown and select SK_Mannequin for your mesh:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5ee928d3-2f02-432c-b73f-8d9336092d2a.png)'
  prefs: []
  type: TYPE_IMG
- en: If SK_Mannequin doesn't appear in the dropdown, make sure that you download
    and add the Animation Starter Pack to your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What about the collision volume? You already have one called CapsuleComponent.
    If your capsule doesn't encapsulate your model, adjust the model so that it fits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your model ended up like mine, the capsule is off the mark! We need to adjust
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccef727b-a32d-4679-aa96-364d28b76c57.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Avatar model and then click and hold the blue arrow pointing up,
    as shown in the preceding screenshot. Move him down until he fits inside the capsule.
    If the capsule isn''t big enough, you can adjust its size in the Details tab under
    Capsule Half-Height and Capsule Radius:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6e2931d1-ffbc-460d-9b34-4cdfc41d572a.png)'
  prefs: []
  type: TYPE_IMG
- en: You can stretch your capsule by adjusting the Capsule Half-Height property
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add this avatar to the game world. Click and drag your BP_Avatar model
    from the Class Viewer tab to your scene in the UE4 editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/47722d4b-ab9b-4455-9466-c5c85c77e8c4.png)'
  prefs: []
  type: TYPE_IMG
- en: Our Avatar class added to the scene
  prefs: []
  type: TYPE_NORMAL
- en: 'The pose of Avatar is the default pose. You want him animated, you say! Well,
    that''s easy, just perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on your Mesh in the Blueprint editor and you will see Animation under
    Details on the right. Note: if you closed the blueprint for any reason and reopen
    it you won''t see the full blueprint. If that happens, click the link to open
    the full blueprint editor.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can now use a blueprint for the animation. This way, an artist can properly
    set the animation based on what the character is doing. If you select UE4ASP_HeroTPP_AnimBlueprint
    from the `AnimClass` drop-down menu, the animation will be adjusted by the blueprint
    (which would have been done by an artist) as the character moves:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0904ac8d-0a09-4db4-aa81-d78268b3ed59.png)'
  prefs: []
  type: TYPE_IMG
- en: If you save and compile the blueprint and hit play in the main game window,
    you will see the idle animation.
  prefs: []
  type: TYPE_NORMAL
- en: We can't cover everything here. Animation blueprints are covered in [Chapter
    11](1bee5b28-fd5d-4d05-8347-f8b2886cf011.xhtml), *Monsters*. If you're really
    interested in animation, it wouldn't be a bad idea to sit through a couple of
    Gnomon Workshop tutorials on IK, animation, and rigging, which can be found at
    [gnomonworkshop.com/tutorials](http://gnomonworkshop.com/tutorials).
  prefs: []
  type: TYPE_NORMAL
- en: 'One more thing: let''s make the camera for the Avatar appear behind it. This
    will give you a third-person point of view, which will allow you to see the whole
    character, shown in the following screenshot, with the corresponding steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the BP_Avatar blueprint editor, select BP_Avatar (Self) and click on Add
    Component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down to choose to add a Camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A camera will appear in the viewport. You can click on the camera and move
    it around. Position the camera so that it is somewhere behind the player. Make
    sure that the blue arrow on the player is facing the same direction as the camera.
    If it isn''t, rotate the Avatar model mesh so that it faces the same direction
    as its blue-colored arrow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98e53d3b-5ffa-429f-842b-32dbd53351ec.png)'
  prefs: []
  type: TYPE_IMG
- en: The blue-colored arrow on your model mesh indicates the forward direction for
    the model mesh. Make sure that the camera's opening faces the same direction as
    the character's forward vector.
  prefs: []
  type: TYPE_NORMAL
- en: Writing C++ code that controls the game's character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you launch your UE4 game, you might notice that the camera hasn't changed.
    What we will do now is make the starting character an instance of our `Avatar`
    class and control our character using the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Making the player an instance of the Avatar class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we go about this. In the Unreal Editor, perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a subclass of Game Mode by navigating to File | New C++ Class... and
    selecting Game Mode Base. I named mine `GameModeGoldenEgg`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/23a322b6-c022-43ea-97fb-9807874a5637.png)'
  prefs: []
  type: TYPE_IMG
- en: The UE4 GameMode contains the rule of the game and describes how the game is
    played to the engine. We will work more with our `GameMode` class later. For now,
    we need to subclass it.
  prefs: []
  type: TYPE_NORMAL
- en: It should automatically compile your C++ code after you create the class, so
    you can create a `GameModeGoldenEgg` blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the GameMode blueprint by going to the Blueprints icon in the menu bar
    at the top, clicking on GameMode New, and then selecting + Create | GameModeGoldenEgg
    (or whatever you named your GameMode subclass in step 1):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2f3f5cc3-d6a3-453a-831f-420ff6bfba75.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Name your blueprint; I called mine `BP_GameModeGoldenEgg`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7a38f985-9ad1-419a-98be-5946eb81ea29.png)'
  prefs: []
  type: TYPE_IMG
- en: Your newly created blueprint will open in the blueprint editor. If it doesn't,
    you can open the BP_GameModeGoldenEgg class from the Class Viewer tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select your BP_Avatar class from the Default Pawn Class panel, as shown in
    the following screenshot. The Default Pawn Class panel is the type of object that
    will be used for the player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/23295e1f-cf29-4e40-bc83-a00c8eef7b91.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Launch your game. You can see a back view as the camera is placed behind the
    player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/09b890d9-96b0-43e7-bec8-5e0ef4b8b9a2.png)'
  prefs: []
  type: TYPE_IMG
- en: You'll notice that you can't move. Why is that? The answer is because we haven't
    set up the controller input yet. The following section will teach you exactly
    how to go about doing it.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up controller input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to set up input:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up controller input, go to Settings | Project Settings...:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a408251e-921d-4c48-b3aa-f05828af46dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the left-hand panel, scroll down until you see Input under Engine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/513f595b-2dbe-4f82-88dc-f9881ae1a587.png)'
  prefs: []
  type: TYPE_IMG
- en: On the right-hand side, you can set up some Bindings. Click + to add a new binding
    and then click on the small arrow next to Axis Mappings in order to expand it.
    Add just two axis mappings to start, one called Forward (connected to the keyboard
    letter *W*) and one called Strafe (connected to the keyboard letter *D*). Remember
    the names that you set; we will look them up in C++ code in just a moment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Close the Project Settings dialog. Open your C++ code. In the `Avatar.h` constructor,
    you need to add two member function declarations, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the existing functions, `SetupPlayerInputComponent` and `Tick`, are
    overrides of virtual functions. `SetupPlayerInputComponent` is a virtual function
    in the `APawn` base class. We will also be adding code to this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Avatar.cpp` file, you need to add the function bodies. Inside `SetupPlayerInputComponent`
    under `Super::SetupPlayerInputComponent(PlayerInputComponent);`, add the following
    lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This member function looks up the Forward and Strafe axis bindings that we
    just created in Unreal Editor and connects them to the member functions inside
    the `this` class. Which member functions should we connect to? Why, we should
    connect to `AAvatar::MoveForward` and `AAvatar::MoveRight`. Here are the member
    function definitions for these two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Controller` object and the `AddMovementInput` function are defined in the
    `APawn` base class. Since the `Avatar` class derives from `ACharacter`, which
    in turn derives from `APawn`, we get free use of all the member functions in the `APawn` base
    class. Now, do you see the beauty of inheritance and code reuse?    If you test
    this out, make sure you click inside the game window, because otherwise the game
    won't receive keyboard events.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add axis bindings and C++ functions to move the player to the left and back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a hint: you only need to add axis bindings if you realize going backward
    is simply the negative of going forward.'
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enter two extra axis bindings by navigating to Settings | Project Settings...
    | Input, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90c0f3a9-20ee-4edf-a119-0de485d653cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Scale the S and A input by -1.0\. This will invert the axis, so pressing the
    *S* key in the game will move the player forward. Try it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can define two completely separate member functions in your
    `AAvatar` class, as follows, and bind the *A* and *S* keys to `AAvatar::MoveLeft`
    and `AAvatar::MoveBack`, respectively (and make sure to add the bindings for these
    to `AAvatar::SetupPlayerInputComponent`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Yaw and pitch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can change the direction in which the player looks by setting the yaw and
    pitch of the controller. Check out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add new axis bindings for the mouse, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/92087a57-27cd-4228-ade9-ae57c6b78825.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From C++, add two new member function declarations to `AAvatar.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The bodies of these member functions will go in the `AAvatar.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add two lines to `SetupPlayerInputComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, notice how I've multiplied the `amount` values in the `Yaw` and `Pitch`
    functions by 200\. This number represents the mouse's sensitivity. You can (should)
    add a `float` member to the `AAvatar` class in order to avoid hardcoding this
    sensitivity number.
  prefs: []
  type: TYPE_NORMAL
- en: '`GetWorld()->GetDeltaSeconds()` gives you the amount of time that passed between
    the last frame and this frame. It isn''t a lot; `GetDeltaSeconds()` should be
    around 16 milliseconds (0.016 s) most of the time (if your game is running at
    60 fps).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: you may notice that right now Pitch doesn''t actually work. This is because
    you''re using a third-person camera. While it might not make sense for this camera,
    you can get it working by going into BP_Avatar, selecting the camera, and checking
    Use Pawn Control Rotation under Camera Options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18534c33-1564-4a99-aab9-28422d145e3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, now we have player input and control. To add new functionality to your
    Avatar, this is all that you have to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Bind your key or mouse actions by going to Settings | Project Settings | Input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a member function to run when that key is pressed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a line to `SetupPlayerInputComponent`, connecting the name of the bound
    input to the member function we want to run when that key is pushed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating non-player character entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, we need to create a few **NPC** (**non-playable characters**). NPCs are
    characters in the game that help the player. Some offer special items, some are
    shop vendors, and some have information to give to the player. In this game, they
    will react to the player as he gets near. Let''s program in some of this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: Create another subclass of Character. In the UE4 Editor, go to File | New C++
    Class... and choose the Character class from which you can make a subclass. Name
    your subclass `NPC`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit your code in Visual Studio. Each NPC will have a message to tell the player,
    so we add in a `UPROPERTY() FString` property to the `NPC` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FString` is UE4''s version of C++''s `<string>` type. When programming in
    UE4, you should use `FString` objects over C++ STL''s `string` objects. In general,
    you should use UE4''s built-in types, as they guarantee cross-platform compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how to add the `UPROPERTY() FString` property to the `NPC` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we put the `EditAnywhere` and `BlueprintReadWrite` properties into
    the `UPROPERTY` macro. This will make `NpcMessage` editable in blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: Full descriptions of all the UE4 property specifiers are available at [https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/index.html](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Recompile your project (as we did for the `Avatar` class). Then, go to the Class
    Viewer, right-click on your `NPC` class, and create a blueprint class from it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Each NPC character you want to create can be a blueprint based off of the `NPC`
    class. Name each blueprint something unique, as we''ll be selecting a different
    model mesh and message for each NPC that appears, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4e56443b-06bf-4682-ba59-640982763c4a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the blueprint and select Mesh (Inherited). You can then change the material
    of your new character in the Skeletal Mesh dropdown so that it looks different
    from the player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6539c287-1585-4a05-a469-3b448b3fa947.png)'
  prefs: []
  type: TYPE_IMG
- en: Change the material of your character in your mesh's properties by selecting
    from the dropdown for each element available
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Details tab with the blueprint name (self) selected in the Components
    tab, look for the `NpcMessage` property. This is our connection between C++ code
    and blueprints; because we entered a `UPROPERTY()` function on the `FString NpcMessage`
    variable, that property appears editable in UE4, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a1b93490-aa67-4b8b-bc38-7d39feb6f7e1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Drag BP_NPC_Owen into the scene. You can create a second or third character
    as well, and be sure to give them unique names, appearances, and messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/369f6e1e-e458-4bdd-b7ff-dcdc3605201d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I''ve created two blueprints for NPCs based on the NPC base classes: BP_NPC_Jonathan
    and BP_NPC_Owen. They have different appearances and different messages for the
    player:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc0b7f35-74e7-42fe-b77a-6cb51e93f894.png)'
  prefs: []
  type: TYPE_IMG
- en: Jonathan and Owen in the scene
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a quote from each NPC dialog box
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To display a dialog box, we need a custom **heads-up display** (**HUD**). In
    the UE4 editor, go to File | New C++ Class... and choose the `HUD` class from
    which the subclass is created (you'll need to scroll down to find it). Name your
    subclass as you wish; I've named mine `MyHUD`.
  prefs: []
  type: TYPE_NORMAL
- en: After you have created the `MyHUD` class, let Visual Studio reload. We will
    make some code edits.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying messages on the HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the `AMyHUD` class, we need to implement the `DrawHUD()` function in
    order to draw our messages to the HUD and to initialize a font draw to the HUD
    with, as shown in the following code in `MyHUD.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The HUD font will be set in a blueprinted version of the `AMyHUD` class. The
    `DrawHUD()` function runs once per frame. In order to draw within the frame, add
    a function to the `AMyHUD.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait! We haven''t initialized our font yet. Let''s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set it up in blueprints. Compile your Visual Studio project in the editor,
    then go to the Blueprints menu at the top and navigate to GameMode | HUD | + Create
    | MyHUD:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e7338fbe-3349-4835-9170-23c3c8b968d2.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a blueprint of the MyHUD class
  prefs: []
  type: TYPE_NORMAL
- en: 'I called mine `BP_MyHUD`.  Find `Hud Font`, select the dropdown, and create
    a new Font asset. I named mine `MyHUDFont`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7da1c1a0-5e0a-4be6-a077-10aed0bd1e75.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Locate MyHUDFont in the content browser and double-click on it to edit it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/032d326f-aa66-45f5-bc40-e85bd4610b06.png)'
  prefs: []
  type: TYPE_IMG
- en: In the window that follows, you can click on where it says `+ Add Font` to create
    a new Default Font Family. You can name it what you like and click the folder
    icon to choose a font from your hard drive (you can find .TTF or TrueType Fonts
    online for free at many sites – I used a Blazed font I found); When you import
    a font, it will ask you to save the Font Face. You will also want to change the
    Legacy Font Size in MyHUDFont to a much bigger size (I used 36).
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit your Game Mode blueprint (BP_GameModeGoldenEgg) and select your new `BP_MyHUD`
    (not `MyHUD`) class for the HUD Class panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cf43dd26-ad50-423c-be6f-7bff4f073942.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Compile and test your program by running it! You should see text printed on
    the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f46ba1db-4910-4069-a458-cde7dad072cd.png)'
  prefs: []
  type: TYPE_IMG
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can see that the text isn't fully centered. That's because the position
    is based on the top-left corner of the text, not the middle.
  prefs: []
  type: TYPE_NORMAL
- en: 'See whether you can fix that. Here''s a hint: get the width and height of the
    text and subtract half of that from the viewport width and height/2 you''re already
    using. You''ll want to use something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using TArray<Message>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each message we want to display for the player will have a few properties:'
  prefs: []
  type: TYPE_NORMAL
- en: An `FString` variable for the message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `float` variable for the time to display it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `FColor` variable for the color of the message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, it makes sense for us to write a little `struct` function to contain all
    this information.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `MyHUD.h`, insert the following `struct` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the `AMyHUD` class, we want to add a `TArray` of these messages.
    `TArray` is a UE4-defined special type of dynamically-growable C++ array. We will
    cover the detailed use of `TArray` in [Chapter 9](8f0cd854-e496-4f99-a30a-185ef8078e04.xhtml), *Templates
    and Commonly-Used Containers*, but this simple use of `TArray` should be a nice
    introduction to garner your interest in the usefulness of arrays in games. This
    will be declared as `TArray<Message>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Also add ** `#include "CoreMinimal.h"`** *to the top of the file*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, whenever the NPC has a message to display, we just need to call `AMyHud::addMessage()`
    with our message. The message will be added to the `TArray` of the messages to
    be displayed. When a message expires (after a certain amount of time), it will
    be removed from the HUD.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `AMyHUD.cpp` file,  add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `AMyHUD::DrawHUD()` function now draws all the messages in the `messages`
    array, and arranges each message in the `messages` array by the amount of time
    that passed since the last frame. Expired messages are removed from the `messages`
    collection once their `time` value drops below 0.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refactor the `DrawHUD()` function so that the code that draws the messages to
    the screen is in a separate function, called `DrawMessages()`. You will probably
    want to create at least one sample message object and call `addMessage` with it
    so you can see it.
  prefs: []
  type: TYPE_NORMAL
- en: The `Canvas` variable is only available in `DrawHUD()`, so you will have to
    save `Canvas->SizeX` and `Canvas->SizeY` in class-level variables.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring means changing the way code works internally so that it is more
    organized or easier to read but still has the same apparent result to the user
    running the program. Refactoring often is a good practice. The reason why refactoring
    occurs is because nobody knows exactly what the final code should look like when
    they start writing it.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering an event when the player is near an NPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To trigger an event near the NPC, we need to set an additional collision detection
    volume that is a bit wider than the default capsule shape. The additional collision
    detection volume will be a sphere around each NPC. When the player steps into
    the NPC sphere, the NPC (shown as follows) reacts and displays a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/492972ff-87a2-4db4-a813-5aa37fd55b3f.png)'
  prefs: []
  type: TYPE_IMG
- en: We're going to add the dark red sphere to the NPC so that it can tell when the
    player is nearby.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside your `NPC.h` class file, add `#include "Components/SphereComponent.h"`
    at the top and the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This looks a bit messy, but it is actually not that complicated. Here, we declare
    an extra bounding sphere volume called `ProxSphere`, which detects when the player
    is near the NPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `NPC.cpp` file, we need to add the following code in order to complete
    the proximity detection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Making the NPC display something to the HUD when the player is nearby
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the player is near the NPC sphere-collision volume, display a message to
    the HUD that alerts the player about what the NPC is saying.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the complete implementation of `ANPC::Prox_Implementation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, make sure you add the following at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we do in this function is cast `OtherActor` (the thing that
    came near the NPC) to `AAvatar`. The cast succeeds (and is not `nullptr`) when
    `OtherActor` is an `AAvatar` object. We get the HUD object (which happens to be
    attached to the player controller) and pass a message from the NPC to the HUD.
    The message is displayed whenever the player is within the red bounding sphere
    surrounding the NPC:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92ceff6f-a598-4b30-8c21-855ab81441b3.png)'
  prefs: []
  type: TYPE_IMG
- en: Jonathan's greeting
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try these out for more practice:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `UPROPERTY` function name for the NPC's name so that the name of the NPC
    is editable in blueprints, similar to the message that the NPC has for the player.
    Show the NPC's name in the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `UPROPERTY` function (type `UTexture2D*`) for the NPC's face texture.
    Draw the NPC's face beside its message in the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Render the player's HP as a bar (filled rectangle).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following property to the `ANPC` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `ANPC::Prox_Implementation`, change the string passed to the HUD to
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This way, the NPC's name will be attached to the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `this` property to the `ANPC` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Then, you can select face icons to be attached to the NPC's face in blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attach a texture to your `struct Message`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To render these icons, you need to add a call to `DrawTexture()` with the right
    texture passed in to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Be sure to check whether the texture is valid before you render it. The icons
    should look similar to what is shown here, at the top of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/945c32ed-8d00-47bf-84c0-c8ed6a4f0b24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is how a function to draw the player''s remaining health in a bar will
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You also need to add `Hp` and `MaxHp` to the Avatar class (you can just set
    default values for now for testing), and add the following to the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through a lot of material. We showed you how to create
    a character and display it on the screen, control your character with axis bindings,
    and create and display NPCs that can post messages to the HUD. It may seem daunting
    now, but it'll make sense once you get more practice.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapters, we will develop our game further by adding an inventory
    system and pickup items, as well as the code and the concept to account for what
    the player is carrying. Before we do that, though, in the next chapter we will
    perform an in-depth exploration of some of the UE4 container types.
  prefs: []
  type: TYPE_NORMAL
