- en: Chapter 1. Designing for Fun and Profit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is an evolving language that has come a long way from its inception.
    Possibly more than any other programming language, it has grown and changed with
    the growth of the World Wide Web. The exploration of how JavaScript can be written
    using good design principles is the topic of this module. The preface of this
    module contains a detailed explanation of the sections of the module.
  prefs: []
  type: TYPE_NORMAL
- en: In the first half of this chapter, we'll explore the history of JavaScript and
    how it came to be the important language that it is today. As JavaScript has evolved
    and grown in importance, the need to apply rigorous methods to its construction
    has also grown. Design patterns can be a very useful tool to assist in developing
    maintainable code. The second half of the chapter will be dedicated to the theory
    of design patterns. Finally, we'll look briefly at anti-patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: History of JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a design pattern?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anti-patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The road to JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll never know how language first came into being. Did it slowly evolve from
    a series of grunts and guttural sounds made during grooming rituals? Perhaps it
    developed to allow mothers and their offspring to communicate. Both of these are
    theories, all but impossible to prove. Nobody was around to observe our ancestors
    during that important period. In fact, the general lack of empirical evidence
    led the Linguistic Society of Paris to ban further discussions on the topic, seeing
    it as unsuitable for serious study.
  prefs: []
  type: TYPE_NORMAL
- en: The early days
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fortunately, programming languages have developed in recent history and we've
    been able to watch them grow and change. JavaScript has one of the more interesting
    histories of modern programming languages. During what must have been an absolutely
    frantic 10 days in May of 1995, a programmer at Netscape wrote the foundation
    for what would grow up to be modern JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time, Netscape was involved in the first of the browser wars with Microsoft.
    The vision for Netscape was far grander than simply developing a browser. They
    wanted to create an entire distributed operating system making use of Sun Microsystems''
    recently-released Java programming language. Java was a much more modern alternative
    to the C++ Microsoft was pushing. However, Netscape didn''t have an answer to
    Visual Basic. Visual Basic was an easier to use programming language, which was
    targeted at developers with less experience. It avoided some of the difficulties
    around memory management that make C and C++ notoriously difficult to program.
    Visual Basic also avoided strict typing and overall allowed more leeway. Here
    is an illustration of the timeline of JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The early days](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Brendan Eich was tasked with developing Netscape repartee to VB. The project
    was initially codenamed Mocha, but was renamed LiveScript before Netscape 2.0
    beta was released. By the time the full release was available, Mocha/LiveScript
    had been renamed JavaScript to tie it into the Java applet integration. Java Applets
    were small applications which ran in the browser. They had a different security
    model from the browser itself and so were limited in how they could interact with
    both the browser and the local system. It is quite rare to see applets these days,
    as much of their functionality has become part of the browser. Java was riding
    a popular wave at the time and any relationship to it was played up.
  prefs: []
  type: TYPE_NORMAL
- en: The name has caused much confusion over the years. JavaScript is a very different
    language from Java. JavaScript is an interpreted language with loose typing, which
    runs primarily on the browser. Java is a language that is compiled to bytecode,
    which is then executed on the Java Virtual Machine. It has applicability in numerous
    scenarios, from the browser (through the use of Java applets), to the server (Tomcat,
    JBoss, and so on), to full desktop applications (Eclipse, OpenOffice, and so on).
    In most laypersons' minds, the confusion remains.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript turned out to be really quite useful for interacting with the web
    browser. It was not long until Microsoft had also adopted JavaScript into their
    Internet Explorer to complement VBScript. The Microsoft implementation was known
    as JScript.
  prefs: []
  type: TYPE_NORMAL
- en: By late 1996, it was clear that JavaScript was going to be the winning web language
    for the near future. In order to limit the amount of language deviation between
    implementations, Sun and Netscape began working with the **European Computer Manufacturers**
    **Association** (**ECMA**) to develop a standard to which future versions of JavaScript
    would need to comply. The standard was released very quickly (very quickly in
    terms of how rapidly standards organizations move), in July of 1997\. On the off
    chance that you have not seen enough names yet for JavaScript, the standard version
    was called **ECMAScript**, a name which still persists in some circles.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the standard only specified the very core parts of JavaScript.
    With the browser wars raging, it was apparent that any vendor that stuck with
    only the basic implementation of JavaScript would quickly be left behind. At the
    same time, there was much work going on to establish a standard **Document Object
    Model** (**DOM**) for browsers. The DOM was, in effect, an API for a web page
    that could be manipulated using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: For many years, every JavaScript script would start by attempting to determine
    the browser on which it was running. This would dictate how to address elements
    in the DOM, as there were dramatic deviations between each browser. The spaghetti
    of code that was required to perform simple actions was legendary. I remember
    reading a year-long 20-part series on developing a **Dynamic HTML** (**DHTML**)
    drop down menu such that it would work on both Internet Explorer and Netscape
    Navigator. The same functionally can now be achieved with pure CSS without even
    having to resort to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: DHTML was a popular term in the late 1990s and early 2000s. It really referred
    to any web page that had some sort of dynamic content that was executed on the
    client side. It has fallen out of use, as the popularity of JavaScript has made
    almost every page a dynamic one.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the efforts to standardize JavaScript continued behind the scenes.
    Versions 2 and 3 of ECMAScript were released in 1998 and 1999\. It looked like
    there might finally be some agreement between the various parties interested in
    JavaScript. Work began in early 2000 on ECMAScript 4, which was to be a major
    new release.
  prefs: []
  type: TYPE_NORMAL
- en: A pause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Then, disaster struck. The various groups involved in the ECMAScript effort
    had major disagreements about the direction JavaScript was to take. Microsoft
    seemed to have lost interest in the standardization effort. It was somewhat understandable,
    as it was around that time that Netscape self-destructed and Internet Explorer
    became the de-facto standard. Microsoft implemented parts of ECMAScript 4 but
    not all of it. Others implemented more fully-featured support, but without the
    market leader on-board, developers didn't bother using them.
  prefs: []
  type: TYPE_NORMAL
- en: Years passed without consensus and without a new release of ECMAScript. However,
    as frequently happens, the evolution of the Internet could not be stopped by a
    lack of agreement between major players. Libraries such as jQuery, Prototype,
    Dojo, and Mootools, papered over the major differences in browsers, making cross-browser
    development far easier. At the same time, the amount of JavaScript used in applications
    increased dramatically.
  prefs: []
  type: TYPE_NORMAL
- en: The way of GMail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The turning point was, perhaps, the release of Google's GMail application in
    2004\. Although XMLHTTPRequest, the technology behind **Asynchronous JavaScript
    and XML** (**AJAX**), had been around for about five years when GMail was released,
    it had not been well-used. When GMail was released, I was totally knocked off
    my feet by how smooth it was. We've grown used to applications that avoid full
    reloads, but at the time, it was a revolution. To make applications like that
    work, a great deal of JavaScript is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: AJAX is a method by which small chunks of data are retrieved from the server
    by a client instead of refreshing the entire page. The technology allows for more
    interactive pages that avoid the jolt of full page reloads.
  prefs: []
  type: TYPE_NORMAL
- en: The popularity of GMail was the trigger for a change that had been brewing for
    a while. Increasing JavaScript acceptance and standardization pushed us past the
    tipping point for the acceptance of JavaScript as a proper language. Up until
    that point, much of the use of JavaScript was for performing minor changes to
    the page and for validating form input. I joke with people that, in the early
    days of JavaScript, the only function name which was used was `Validate()`.
  prefs: []
  type: TYPE_NORMAL
- en: Applications such as GMail that have a heavy reliance on AJAX and avoid full
    page reloads are known as **Single Page Applications** or **SPAs**. By minimizing
    the changes to the page contents, users have a more fluid experience. By transferring
    only a **JavaScript Object Notation** (**JSON**) payload instead of HTML, the
    amount of bandwidth required is also minimized. This makes applications appear
    to be snappier. In recent years, there have been great advances in frameworks
    that ease the creation of SPAs. AngularJS, backbone.js, and ember are all Model
    View Controller style frameworks. They have gained great popularity in the past
    two to three years and provide some interesting use of patterns. These frameworks
    are the evolution of years of experimentation with JavaScript best practices by
    some very smart people.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSON is a human-readable serialization format for JavaScript. It has become
    very popular in recent years, as it is easier and less cumbersome than previously
    popular formats such as XML. It lacks many of the companion technologies and strict
    grammatical rules of XML, but makes up for it in simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time as the frameworks using JavaScript are evolving, the language
    is too. 2015 saw the release of a much-vaunted new version of JavaScript that
    had been under development for some years. Initially called ECMAScript 6, the
    final name ended up being ECMAScript-2015\. It brought with it some great improvements
    to the ecosystem. Browser vendors are rushing to adopt the standard. Because of
    the complexity of adding new language features to the code base, coupled with
    the fact that not everybody is on the cutting edge of browsers, a number of other
    languages that transcompile to JavaScript are gaining popularity. CoffeeScript
    is a Python-like language that strives to improve the readability and brevity
    of JavaScript. Developed by Google, Dart is being pushed by Google as an eventual
    replacement for JavaScript. Its construction addresses some of the optimizations
    that are impossible in traditional JavaScript. Until a Dart runtime is sufficiently
    popular, Google provides a Dart to the JavaScript transcompiler. TypeScript is
    a Microsoft project that adds some ECMAScript-2015 and even some ECMAScript-201X
    syntax, as well as an interesting typing system, to JavaScript. It aims to address
    some of the issues that large JavaScript projects present.
  prefs: []
  type: TYPE_NORMAL
- en: 'The point of this discussion about the history of JavaScript is twofold: first,
    it is important to remember that languages do not develop in a vacuum. Both human
    languages and computer programming languages mutate based on the environments
    in which they are used. It is a popularly held belief that the Inuit people have
    a great number of words for "snow", as it was so prevalent in their environment.
    This may or may not be true, depending on your definition for the word and exactly
    who makes up the Inuit people. There are, however, a great number of examples
    of domain-specific lexicons evolving to meet the requirements for exact definitions
    in narrow fields. One need look no further than a specialty cooking store to see
    the great number of variants of items which a layperson such as myself would call
    a pan.'
  prefs: []
  type: TYPE_NORMAL
- en: The Sapir–Whorf hypothesis is a hypothesis within the linguistics domain, which
    suggests that not only is language influenced by the environment in which it is
    used, but also that language influences its environment. Also known as linguistic
    relativity, the theory is that one's cognitive processes differ based on how the
    language is constructed. Cognitive psychologist Keith Chen has proposed a fascinating
    example of this. In a very highly-viewed TED talk, Dr. Chen suggested that there
    is a strong positive correlation between languages that lack a future tense and
    those that have high savings rates ([https://www.ted.com/talks/keith_chen_could_your_language_affect_your_ability_to_save_money/transcript](https://www.ted.com/talks/keith_chen_could_your_language_affect_your_ability_to_save_money/transcript)).
    The hypothesis at which Dr. Chen arrived is that when your language does not have
    a strong sense of connection between the present and the future, this leads to
    more reckless behavior in the present.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, understanding the history of JavaScript puts one in a better position
    to understand how and where to make use of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The second reason I explored the history of JavaScript is because it is absolutely
    fascinating to see how quickly such a popular tool has evolved. At the time of
    writing, it has been about 20 years since JavaScript was first built and its rise
    to popularity has been explosive. What more exciting thing is there than to work
    in an ever-evolving language?
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript everywhere
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the GMail revolution, JavaScript has grown immensely. The renewed browser
    wars, which pit Internet Explorer and Edge against Chrome and against Firefox,
    have lead to building a number of very fast JavaScript interpreters. Brand new
    optimization techniques have been deployed and it is not unusual to see JavaScript
    compiled to machine-native code for the added performance it gains. However, as
    the speed of JavaScript has increased, so has the complexity of the applications
    built using it.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is no longer simply a language for manipulating the browser, either.
    The JavaScript engine behind the popular Chrome browser has been extracted and
    is now at the heart of a number of interesting projects such as Node.js. Node.js
    started off as a highly asynchronous method of writing server-side applications.
    It has grown greatly and has a very active community supporting it. A wide variety
    of applications have been built using the Node.js runtime. Everything from build
    tools to editors have been built on the base of Node.js. Recently, the JavaScript
    engine for Microsoft Edge, ChakraCore, was also open sourced and can be embedded
    in Node.js as an alternative to Google's V8\. SpiderMonkey, the Firefox equivalent,
    is also open source and is making its way into more tools.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript can even be used to control microcontrollers. The Johnny-Five framework
    is a programming framework for the very popular Arduino. It brings a much simpler
    approach to programming devices than the traditional low-level languages used
    for programming these devices. Using JavaScript and Arduino opens up a world of
    possibilities, from building robots to interacting with real-world sensors.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the major smartphone platforms (iOS, Android, and Windows Phone) have
    an option to build applications using JavaScript. The tablet space is much the
    same, with tablets supporting programming using JavaScript. Even the latest version
    of Windows provides a mechanism for building applications using JavaScript. This
    illustration shows some of the things possible with JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JavaScript everywhere](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'JavaScript is becoming one of the most important languages in the world. Although
    language usage statistics are notoriously difficult to calculate, every single
    source which attempts to develop a ranking puts JavaScript in the top 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Language index | Rank of JavaScript |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Langpop.com | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| Statisticbrain.com | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| Codeval.com | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| TIOBE | 8 |'
  prefs: []
  type: TYPE_TB
- en: What is more interesting is that most of of these rankings suggest that the
    usage of JavaScript is on the rise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The long and short of it is that JavaScript is going to be a major language
    in the next few years. More and more applications are being written in JavaScript
    and it is the lingua franca for any sort of web development. Developer of the
    popular Stack Overflow website Jeff Atwood created Atwood''s Law regarding the
    wide adoption of JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Any application that can be written in JavaScript, will eventually be written
    in JavaScript" – Atwood''s Law, Jeff Atwood*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This insight has been proven to be correct time and time again. There are now
    compilers, spreadsheets, word processors—you name it—all written in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the applications which make use of JavaScript increase in complexity, the
    developer may stumble upon many of the same issues as have been encountered in
    traditional programming languages: how can we write this application to be adaptable
    to change?'
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the need for properly designing applications. No longer can
    we simply throw a bunch of JavaScript into a file and hope that it works properly.
    Nor can we rely on libraries such as jQuery to save ourselves. Libraries can only
    provide additional functionality and contribute nothing to the structure of an
    application. At least some attention must now be paid to how to construct the
    application to be extensible and adaptable. The real world is ever-changing and
    any application that is unable to change to suit the changing world is likely
    to be left in the dust. Design patterns provide some guidance in building adaptable
    applications, which can shift with changing business needs.
  prefs: []
  type: TYPE_NORMAL
- en: What is a design pattern?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the most part, ideas are only applicable in one place. Adding peanut butter
    is really only a great idea in cooking and not in sewing. However, from time to
    time it is possible to find applicability for a great idea outside of its original
    purpose. This is the story behind design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 1977, Christopher Alexander, Sara Ishikawa, and Murray Silverstein authored
    a seminal book on what they called design patterns in urban planning, called *A
    Pattern Language: Towns, Buildings, Construction*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The book described a language for talking about the commonalities of design.
    In the book, a pattern is described thusly:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"The elements of this language are entities called patterns. Each pattern
    describes a problem that occurs over and over again in our environment, and then
    describes the core of the solution to that problem, in such a way that you can
    use this solution a million times over, without ever doing it the same way twice."
    — Christopher Alexander*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'These design patterns were such things as how to layout cities to provide a
    mixture of city and country living, or how to build roads in loops as a traffic-calming
    measure in residential areas, as is shown in the following picture taken from
    the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a design pattern?](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Even for those without a strong interest in urban planning, the book presents
    some fascinating ideas about how to structure our world to promote healthy societies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the work of Christopher Alexander and the other authors as a source of
    inspiration, Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides wrote
    a book called *Design Patterns: Elements of Reusable Object-Oriented Software*.
    When a book is very influential in a computer science curriculum, it is often
    given a pet name. For instance, most computer science graduates will know of which
    book you mean if you talk about *The Dragon Book* (*Principles of Compiler Design*,
    1986). In enterprise software, *The Blue Book* is well known to be Eric Evan''s
    book on domain-driven design. The design patterns book has been so important that
    it is commonly referred do as the GoF book, or *Gang of Four* book, for its four
    authors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This book outlined 23 patterns for use in object-oriented design. It is divided
    the patterns into three major groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creational**: These patterns outlined a number of ways in which objects could
    be created and their lifecycles managed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavioral**: These patterns describe how objects interact with each other'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural**: These patterns describe a variety of different ways to add
    functionality to existing objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of design patterns is not to instruct you on how to build software,
    but rather to give guidance on ways in which to solve common problems. For instance,
    many applications have a need to provide some sort of an undo function. The problem
    is common to text editors, drawing programs, and even e-mail clients. Solving
    this problem has been done many times before so it would be great to have a common
    solution. The command pattern provides just such a common solution. It suggests
    keeping track of all the actions performed in an application as instances of a
    command. This command will have forward and reverse actions. Every time a command
    is processed it is placed onto a queue. When it comes time to undo a command it
    is as simple as popping the top command off of the command queue and executing
    the undo action on it.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns provide some hints about how to solve common problems like the
    undo problem. They have been distilled from performing hundreds of iterations
    of solving the same problem. The design pattern may not be exactly the correct
    solution for the problem you have, but it should, at the very least, provide some
    guidance to implement a solution more easily.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A consultant friend of mine once told me a story about starting an assignment
    at a new company. The manager told them that he didn't think there would be a
    lot of work to do with the team because they had bought the GoF design pattern
    book for the developers early on and they'd implemented every last design pattern.
    My friend was delighted about hearing this because he charges by the hour. The
    misapplication of design patterns paid for much of his first-born's college education.
  prefs: []
  type: TYPE_NORMAL
- en: Since the GoF book, there has been a great proliferation of literature dealing
    with enumerating and describing design patterns. There are books on design patterns
    which are specific to a certain domains and books which deal with patterns for
    large enterprise systems. The Wikipedia category for software design patterns
    contains 130 entries for different design patterns. I would, however, argue that
    many of the entries are not true design patterns but rather programming paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, design patterns are simple constructs that don't need complicated
    support from libraries. While there do exist pattern libraries for most languages,
    you need not go out and spend a lot of money to purchase the libraries. Implement
    the patterns as you find the need. Having an expensive library burning a hole
    in your pocket encourages blindly applying patterns just to justify having spent
    the money. Even if you did have the money, I'm not aware of any libraries for
    JavaScript whose sole purpose is to provide support for patterns. Of course, GitHub
    is a wealth of interesting JavaScript projects, so there may well be a library
    on there of which I'm unaware.
  prefs: []
  type: TYPE_NORMAL
- en: There are some who suggest that design patterns should be emergent. That is
    to say, that by simply writing software in an intelligent way, one can see the
    patterns emerge from the implementation. I think that may be an accurate statement,
    however, it ignores the actual cost of getting to those implementations by trial
    and error. Those with an awareness of design patterns are much more likely to
    spot the emergent pattern early on. Teaching junior programmers about patterns
    is a very useful exercise. Knowing early on which pattern or patterns can be applied
    acts as a shortcut. The full solution can be arrived at earlier and with fewer
    missteps.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If there are common patterns to be found in good software design, are there
    also patterns that can be found in bad software design? Absolutely! There are
    any number of ways to do things incorrectly, but most of them have been done before.
    It takes real creativity to screw up in a hitherto unknown way.
  prefs: []
  type: TYPE_NORMAL
- en: The shame of it is that it is very difficult to remember all the ways in which
    people have gone wrong over the years. At the end of many major projects, the
    team will sit down and put together a document called *Lessons Learned*. This
    document contains a list of things that could have gone better on the project
    and may even outline some suggestions as to how these issues can be avoided in
    the future. That these documents are only constructed at the end of a project
    is unfortunate. By that time, many of the key players have moved on and those
    who are left must try to remember lessons from the early stages of the project,
    which could be years ago. It is far better to construct the document as the project
    progresses.
  prefs: []
  type: TYPE_NORMAL
- en: Once complete, the document is filed away ready for the next project to make
    use of. At least, that is the theory. For the most part, the document is filed
    away and never used again. It is difficult to create lessons that are globally
    applicable. The lessons learned tend to only be useful for the current project
    or an exactly identical project, which almost never happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, by looking at a number of these documents from various projects, patterns
    start to emerge. It was by following such an approach that William Brown, Raphael
    Malveau, Skip McCormick, and Tom Mowbray, collectively known as the Upstart Gang
    of Four in reference to the original Gang of Four, wrote the initial book on anti-patterns.
    The book, *AntiPatterns: Refactoring Software, Architectures, and Projects in
    Crisis*, outlined anti-patterns not just for issues in code, but also in the management
    process which surrounds code.'
  prefs: []
  type: TYPE_NORMAL
- en: Patterns outlined include such humorously named patterns as *The Blob and Lava
    Flow*. The Blob, also known as the God object, is the pattern where one object
    grows to take on the responsibility for vast swathes of the application logic.
    Lava Flow is a pattern that emerges as a project ages and nobody knows if code
    is still used. Developers are nervous about deleting the code because it might
    be used somewhere or may become useful again. There are many other patterns described
    in the book that are worth exploring. Just as with patterns, anti-patterns are
    emergent from writing code, but in this case, code which gets out of hand.
  prefs: []
  type: TYPE_NORMAL
- en: This module will not cover JavaScript anti-patterns, but it is useful to remember
    that one of the anti-patterns is an over-application of design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design patterns have a rich and interesting history. From their origin as tools
    for helping to describe how to build the structures to allow people to live together,
    they have grown to be applicable to a number of domains.
  prefs: []
  type: TYPE_NORMAL
- en: It has now been a decade since the seminal work on applying design patterns
    to programming. Since then, a vast number of new patterns have been developed.
    Some of these patterns are general-purpose patterns such as those outlined in
    the GoF book, but a larger number are very specific patterns which are designed
    for use in a narrow domain.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript also has an interesting history and is really coming of age. With
    server-side JavaScript taking off and large JavaScript applications becoming common,
    there is a need for more diligence in building JavaScript applications. It is
    rare to see patterns being properly exploited in most modern JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Leaning on the teachings provided by design patterns to build modern JavaScript
    patterns gives one the best of both worlds. As Isaac Newton famously wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"If I have seen further it is by standing on ye shoulders of Giants."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Patterns give us easily-accessible shoulders on which to stand.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will look at some techniques for building structure into
    JavaScript. The inheritance system in JavaScript is unlike that of most other
    object-oriented languages and that provides us both opportunities and limits.
    We'll see how to build classes and modules in the JavaScript world.
  prefs: []
  type: TYPE_NORMAL
