- en: Chapter 2. Automating the Jenkins UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be looking at a selection of different approaches that
    can be used to alter and enhance the Jenkins **user interface** (**UI**).
  prefs: []
  type: TYPE_NORMAL
- en: As with Jenkins as a whole, the Jenkins UI is highly customizable and has been
    clearly designed from the outset to be adaptable and extendable so that you can
    tailor and adapt it to fit your particular requirements and environment.
  prefs: []
  type: TYPE_NORMAL
- en: There are different ways in which you can customize the UI, ranging from purely
    *look and feel* cosmetic alterations to user input refinements, and then towards
    the automatic creation of Jenkins jobs and setting up a dynamic Slave Node provisioning
    system.
  prefs: []
  type: TYPE_NORMAL
- en: The focus and the most suitable approach is usually driven by the way in which
    Jenkins will be used; focusing on the areas that matter the most in a particular
    situation is usually where the most benefit is to be gained.
  prefs: []
  type: TYPE_NORMAL
- en: We will examine four of the most common use case scenarios in this chapter and
    the different ways in which the automation and development of the Jenkins UI could
    be helpful for each case.
  prefs: []
  type: TYPE_NORMAL
- en: Use case scenario 1 – a large number of jobs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A single Jenkins instance can contain many jobs. The practical limit varies
    widely and depends on multiple factors, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Hardware resources such as RAM, CPU, disk, and network performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slave nodes—how many there are, how they are set up, and their performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How well the jobs are distributed across the Master and Slave nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Settings of individual jobs; their size, function, history, and retention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's not unusual for a Jenkins instance to have over 1,000 jobs, or around 100
    Slave nodes attached to a Master node.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the performance load that this causes is a big task in itself, and
    Jenkins also needs to manage the presentation and housekeeping of these jobs—your
    users will not want to look through more than 1,000 jobs just to search for the
    one they need, and we also need to make sure that old jobs are cleaned up or archived
    and that new ones can be created both easily and accurately.
  prefs: []
  type: TYPE_NORMAL
- en: If you can reduce the number of jobs you require, then administration and resource
    overheads will be reduced as a result, and performance, usability, and reliability
    will also be increased, and the user experience will be improved.
  prefs: []
  type: TYPE_NORMAL
- en: Some planning and a little automation of the UI can often help us achieve this—let's
    take a look at a few scenarios and the possible solutions.
  prefs: []
  type: TYPE_NORMAL
- en: If the most pressing issue or bottleneck is that there are too many jobs, it
    would be helpful to first understand where the need for all these jobs originates,
    and then see what we can do about alleviating that.
  prefs: []
  type: TYPE_NORMAL
- en: Frequently, development teams work in Sprints and/or Releases. This usually
    means having a mainline development stream and one or more branch streams. Often
    this convention will be followed in Jenkins as well—we may want to set up Jenkins
    jobs to build and then deploy Sprint 3 or Release 49 code to integration environments,
    while deploying our mainline changes to CI and development environments. At the
    same time, there may be a logical or business requirement to support a production
    version of *everything*, just in case something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: This could mean setting up jobs that are named accordingly, such as `Sprint
    3`, and having this value hardcoded in the configuration with a pseudocode, something
    along the lines of *fetch the Sprint 3 war file and deploy it to the Sprint 3
    server…*.
  prefs: []
  type: TYPE_NORMAL
- en: These jobs will have a finite (and probably pretty short) life and will then
    need cleaning up or updating with new values for the next Sprint or Release. This
    type of regular and manual maintenance becomes a headache very quickly, which
    further increases the possibility of human error leading to the wrong thing being
    deployed to the wrong place.
  prefs: []
  type: TYPE_NORMAL
- en: 'One simple solution for this common scenario is to make use of Jenkins Environment
    Variables. If you navigate to **Manage Jenkins** | **Configure System** | **Global
    Properties**, you can create and define your own key-value pairs, which are immediately
    available to every job on any node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Use case scenario 1 – a large number of jobs](../images/00004.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows a few simplistic examples of the kinds of key-value
    pairs that you may want to set up—they can be whatever you like or need though.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this approach means that, rather than creating rafts of new jobs per
    Release or Sprint and catering to multiple concurrent Releases that will become
    obsolete shortly, you could just define two or three permanent sets of jobs that
    will pick up the key-value pairs from the location and use these to drive what
    they do—our job configuration pseudocode then changes. Initially, this in the
    form of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*fetch the Sprint 3 war file and deploy it to the Sprint 3 server…*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This changes to something more generic along the lines of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*fetch the ${SPRINT} war file and deploy it to the ${SPRINT} server…*'
  prefs: []
  type: TYPE_NORMAL
- en: This simple alteration to the approach can, in some circumstances, allow you
    to greatly reduce the number of Jenkins jobs by simply (and centrally) updating
    these Environment Variables to the new properties at the required point of your
    development life cycle—for example, at the end of a Release, Sprint, or Iteration
    cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'This one central configuration change will immediately update all of the jobs
    so that they can use these new values, and this approach could be extended to
    include information about many other aspects of build, test, and deployment processes,
    the branch location to checkout and build from, or the environment or host that
    the built artifacts should be deployed to, and so on. The following screenshot
    shows the Console Output page where the change is reflected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Use case scenario 1 – a large number of jobs](../images/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you need to create new jobs per Iteration, there are also ways in which you
    can automate the UI to simplify this process—we can use Jenkins to manage Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take a look at your Jenkins home directory on the filesystem (as defined
    by the JENKINS_HOME variable), you will see the structure used to store the settings
    for each Jenkins job: each job is represented by a folder bearing the name of
    the job it represents, with each folder containing an XML file called `config.xml`.
    Each `config.xml` file contains the settings and information for that job.'
  prefs: []
  type: TYPE_NORMAL
- en: There are normally several other files and folders too, such as a file to track
    the number of the next build (`nextBuildNumber`) and folders that are used to
    track and store history and artifacts created by previous builds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bare bones of a Jenkins job are, at its most basic form, as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: A folder named after the job—for example, `VeryBasicJob`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside this folder, a file called `config.xml`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside this file, some XML along the lines of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this minimal job contains some very simple XML tags and data
    that detail the `<description>` and `<command>` tags, and various other settings
    used by Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Jenkins UI will interpret this folder and the XML file and display the
    **Config** page like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Use case scenario 1 – a large number of jobs](../images/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When the source configuration and the frontend UI are seen side-by-side just
    as you can see in the preceding screenshot, it becomes obvious that changing the
    XML file should change the job displayed by the UI and vice-versa.
  prefs: []
  type: TYPE_NORMAL
- en: So if we could automatically create these XML files and load them in to Jenkins
    somehow, we should then also be able to automate and do version control of all
    of our Jenkins jobs and allow end users to apply whatever customization they require
    at runtime, removing the need for manual intervention.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching folder structures and XML files from Version Control, updating these
    XML files with user-selected values, and loading the resultant configuration into
    our Jenkins instance are just the sort of tasks for which Jenkins is the ideal
    tool—we can set up Jenkins to set up Jenkins!
  prefs: []
  type: TYPE_NORMAL
- en: In short, this process can be achieved by first *templating* your XML files—replace
    all references to the variable factors (such as references to **Release**, **Sprint**,
    **Hostnames**, and so on) with something easily identifiable. Then, create the
    Jenkins jobs that enable a user to specify what they would like to use in place
    of these placeholder values.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to perform some string replacement (using your preferred tool—**Perl**,
    **Sed**, **Awk**, and so on) to substitute the placeholder values with the user-selected
    ones, and then you just need to load the new configuration into Jenkins at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate one possible approach to this, here is a basic functional shell
    script that does the job with comments explaining what''s going on at each step.
    This uses the `Jenkins-cli.jar` file, which you can download and find out more
    about by going to your Jenkins instance and adding `/cli` to the URL, for example:
    `http://myjenkins.instance:8080/cli`.'
  prefs: []
  type: TYPE_NORMAL
- en: Here you will also find detailed help and information on the many features and
    abilities that Jenkins offers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This simple example, when set up in a Jenkins job, could be adapted to allow
    your users to create (or clean up) new Jenkins jobs quickly, easily, and reliably
    by pulling templates from version control and allowing the user to select from
    a predefined and valid set of options.
  prefs: []
  type: TYPE_NORMAL
- en: Use case scenario 2 – multiple hosts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Jenkins UI can also be tailored to help in managing installations that require
    a large numbers of Slave hosts. This may be required to improve the performance
    of builds or test runs by distributing the load to other systems, or wherever
    Jenkins is used to perform functions spanning a multiple-host Operating System—something
    that Jenkins can do very easily through the built-in JNLP functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Often, testing requirements dictate that a wide variety of different nodes running
    varying combinations of OSes and software are essential—this is common when you
    have an application that needs testing on different versions of Internet Explorer;
    each version requires a different Windows host, as each host can only support
    one version of the browser at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Managing multiple and varying Slave Nodes can be problematic; however, the Jenkins
    UI provides several features that can help to simplify and automate this aspect.
  prefs: []
  type: TYPE_NORMAL
- en: One of the simplest approaches to manage instances with many Slave nodes is
    to use a Slave labeling scheme and a naming convention that describes the abilities
    or functions that the individual node perform.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, you first need to label your Slave nodes—this can be done as and
    when they are created, or you can go back to existing Slave Nodes and label them
    as desired—note the multiple labels specified in the following Slave definition
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Use case scenario 2 – multiple hosts](../images/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, this simple Slave has been given multiple labels of `tomcat`,
    `java6`, and `integration`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now create or amend a job and select the **Restrict where this project
    can be run** option, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Use case scenario 2 – multiple hosts](../images/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we enter a label that matches one or more existing labels (`integration`
    in this instance), then this job will be run on a node matching this label. In
    cases where there are multiple matches, the job will be run on just one of the
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: This simple yet extremely powerful UI feature enables you to distribute the
    load across multiple nodes. The nodes may perform different functions, or they
    could be set up with different abilities—the labels can be whatever that helps
    you to decide what is best for your situation.
  prefs: []
  type: TYPE_NORMAL
- en: You could decide to distinguish between the physical characteristics of your
    nodes, such as those with a large free disk space, more memory or fast processors,
    or ones that have local databases or code deployments at the desired level, or
    with application servers or other supporting tools on them. This way you can not
    only distribute the load, but also maximize performance and reduce turnaround
    time by putting the right jobs on the hosts that are best suited for them, and
    by pooling your resources to fine-tune the response time of the various build
    tasks—getting the urgent tasks turned around as quickly as possible and leaving
    the less urgent jobs queued on a pool of dedicated servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach can be taken further using the Swarm plugin: [https://wiki.jenkins-ci.org/display/JENKINS/Swarm+Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Swarm+Plugin).'
  prefs: []
  type: TYPE_NORMAL
- en: This plugin provides an added functionality that enables you to automatically
    provision and connect new Slave Nodes via a UDP broadcast that discovers and connects
    new nodes to the existing Master node, thereby creating an ad hoc cluster that
    you can tailor to meet demands.
  prefs: []
  type: TYPE_NORMAL
- en: You can use this to set things up so that when the build queue reaches a predefined
    threshold, new nodes will be dynamically provisioned and added to the pool of
    available nodes. You need to install the feature on the Master node and use the
    command-line client on the new Slave nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Swarm nodes can also be assigned multiple labels at creation time through the
    `-labels` argument in the CLI. These values can additionally be set by the script
    that creates them; for example, the script could check for the existence of a
    local Oracle installation or a high percentage of free disk space and then use
    these results to decide which labels to apply to itself—`database`, `performance`,
    `java6`, `tomcat`, and so on accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another very powerful tool for dynamic host provisioning and management is
    Docker, and, not surprisingly, there is a Jenkins plugin available for this too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://wiki.jenkins-ci.org/display/JENKINS/Docker+Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Docker+Plugin)'
  prefs: []
  type: TYPE_NORMAL
- en: Docker allows you to quickly and easily create and manage **Docker Images**
    that run in **Docker Containers**. These are quite similar in practice to virtual
    machines, but are smaller and of lighter weight, and therefore far quicker and
    easier to provision than traditional VMs.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Images can also be version controlled via a **Docker Registry**, which
    works like a Git or Subversion repository for virtual machines; you can pull an
    existing Image from the Docker Index and update it to suit your requirements (as
    you would for a virtual machine—performing tasks such as deploying Tomcat, installing
    and configuring Apache, uploading some scripts, adding a version of Java, or installing
    Jenkins). Once you have customized your image, you can optionally push/publish
    it back to the index in exactly the same state that you created but under a new
    name, thus creating a template Slave that you can provision both rapidly and reliably
    to any platform that runs Docker. You can even run Docker on virtual machines—the
    possibilities that this approach provides are very interesting, and we will look
    at this in a little more detail in [Chapter 9](part0061_split_000.html#1Q5IA2-497efea050ab4b7582c7e2ed4ba920ee
    "Chapter 9. Putting Things Together") *Putting Things Together*.
  prefs: []
  type: TYPE_NORMAL
- en: Use case scenario 3 – helping your users through UI automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Customizing and automating the Jenkins user interface can help and empower users
    of your Jenkins instance to help themselves.
  prefs: []
  type: TYPE_NORMAL
- en: By ensuring that it is possible only for your users to input valid data, we
    can greatly reduce the risk of invalid input and the resulting issues, which should
    improve the user experience too.
  prefs: []
  type: TYPE_NORMAL
- en: The most common way to do this is to validate the user input at runtime. For
    example, if your job prompts the user to enter a day of the week or a build number,
    you may assign this to a variable called something like `$WEEKDAY` or `$MY_BUILD_NUM`
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We can then set up our job to ensure that the supplied user data is valid—if
    the value of `$WEEKDAY` is not a valid day of the week, or the user has supplied
    the build number as `Build Two` instead of an integer value that we may have been
    hoping for, we can cause the build to fail with an error message explaining what
    the user has done wrong and how to correct it, rather than allowing our job to
    carry on regardless and letting it attempt to perform a function or create something
    that we know to be invalid.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also good practice and generally helpful for all concerned if you can
    let your users know what you expect—this is easily done by setting the description
    next to the input box like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Use case scenario 3 – helping your users through UI automation](../images/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: At runtime, this configuration will provide the user with a description of what
    we would like them to enter, and by setting a default value of 0, we can give
    them another hint.
  prefs: []
  type: TYPE_NORMAL
- en: This Jenkins job could then check that the value of `$MY_BUILD_NUM` is (as we'd
    hoped and requested) a numerical value greater than zero and less than 101, and
    then we can be reasonably happy that things are ok to continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is often much safer to take the next logical step and restrict the options
    that are left open to the users. This further reduces the risks and also makes
    the experience nicer for the users—they may only run certain jobs occasionally,
    and expecting them to remember what you want may be a bit much to ask at times.
    This can be achieved by presenting them with a list of valid options and ensuring
    that they pick one of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Use case scenario 3 – helping your users through UI automation](../images/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding information will be presented to the user at runtime like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Use case scenario 3 – helping your users through UI automation](../images/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This approach should hopefully be much more robust—so long as we remember to
    check that the value of ${WEEKDAY} is not equal to **Please Select…** before we
    attempt to use it!
  prefs: []
  type: TYPE_NORMAL
- en: This approach can be extended further by pulling in data from other sources
    and dynamically building up the options that are available to the user at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful and more powerful example is the ability to populate a selection
    list with the values derived from current Subversion Tags.
  prefs: []
  type: TYPE_NORMAL
- en: This can be done through the **List Subversion Tags (and more)** option for
    parameterized builds. This allows you to present the user with a current list
    of available tags to select from—as an example, these tags could be created by
    other Jenkins jobs and may contain a list of candidate builds that the user can
    select from, to have a build deployed to an environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have a Subversion repository with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://subversionrepo/mainproject/tags/Build_12.56`'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://subversionrepo/mainproject/tags/Build_14.78`'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://subversionrepo/mainproject/tags/Build_18.20`'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the user will be presented with a drop-down menu offering a choice
    of one of these three builds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The option that the user selects is assigned at runtime to the variable that
    you created, say `$BUILD_TO_DEPLOY`, and your job can then use this selection
    to check out the requested build and deploy it using the SVN URL combined with
    the user''s preferred option:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://subversionrepo/mainproject/tags/${BUILD_TO_DEPLOY}`'
  prefs: []
  type: TYPE_NORMAL
- en: This functionality is provided as a part of the Subversion plugin, which is
    now a part of the core Jenkins build.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other plugins and features that you can use to structure and
    improve your UI experience—the built-in Jenkins **Views** functionality allows
    you to create a dynamic list of jobs matching your criteria. This can be expressed
    as a simple regular expression so that all the matching jobs will be presented
    in one view. This works especially well when combined with a sensible naming convention
    for jobs.
  prefs: []
  type: TYPE_NORMAL
- en: Other approaches that may improve the user experience include setting up pipelines
    that manage job execution and flow. By setting up processes that the user can
    initiate easily, which will then carry on to work through a sequence of other
    jobs, the user only needs to trigger the first of several actions, like knocking
    over a line of dominoes, rather than trigger each build after checking that the
    previous build has completed and checking its stated output.
  prefs: []
  type: TYPE_NORMAL
- en: This can be achieved by simply using the built-in **Build other projects** option
    under **Post-Build Actions** for each job to create a simple sequence. Using the
    various trigger options, we can fine-tune things slightly so that certain jobs
    will stop the process if they have an issue, or can be set to carry on regardless,
    if appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to add more options, there are plenty of plugins readily available
    to help you. The Build Pipeline plugin offers some useful features, and the Join
    plugin can be incredibly useful. If you would like to run multiple jobs concurrently,
    then wait for them to complete before continuing and triggering the next job—as
    ever, there's a Jenkins plugin for most occasions!
  prefs: []
  type: TYPE_NORMAL
- en: Use case scenario 4 – UI tweaks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes Jenkins is set up and then left running in the background doing its
    thing; it's rarely checked upon or looked at unless things go wrong, and users
    are happy that things get done.
  prefs: []
  type: TYPE_NORMAL
- en: On other occasions, the Jenkins UI is used heavily by many people at the same
    time, all of whom will inevitably have their own requirements and priorities,
    and then the look and feel of Jenkins becomes a high priority.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways in which you can give the users what they want, including
    setting up numerous views, each providing a different user or group with a view
    of the (Jenkins) world that suits them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Use case scenario 4 – UI tweaks](../images/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using the simple `.*job.*` regular expression ensures that all jobs (both present
    and future) that contain the string `"job"` in their title will be displayed on
    this view. Again, this really relies on a decent naming convention being followed,
    but if this is done, it can reduce the maintenance requirements of this aspect
    to nothing—when a new matching job is created, it's automatically added to the
    view.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins that provide further enhancements in this area include the Personal
    View plugin; as its name suggests, it enables users to create and manage their
    own view of the world, view **Job Filters**, and allows further tweaking. The
    **Chosen Views Tab** bar is helpful if you end up having too many Views and want
    to easily manage all of them on one screen!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the ways in which the user interface can be altered
    to suit your requirements. We looked at a few common issues and reviewed some
    possible approaches that could be used to alleviate them.
  prefs: []
  type: TYPE_NORMAL
- en: As you have seen, the Jenkins user interface is extremely powerful, and much
    of this power comes from its flexibility and extensibility.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting the Jenkins user interface to address whatever use case applies to
    your environment can make a massive difference to the success of your Jenkins
    installation. At the same time, it also makes the user experience much more positive
    and can guide your users to interact with Jenkins in a mutually beneficial way.
    When it's easy for people to find what they want and hard for them to make mistakes
    (for example, due to runtime validation, dynamically populated forms, and automatically-created
    suites of jobs), you should have happier users and a more robust and efficient
    Jenkins too.
  prefs: []
  type: TYPE_NORMAL
- en: The in-built functionality of Jenkins can often provide enough flexibility to
    address whatever your most pressing Jenkins UI issues are; however, the wealth
    of available plugins allows you to quite easily take things much further should
    you wish to.
  prefs: []
  type: TYPE_NORMAL
- en: In chapters 6 and 7, we will revisit this topic in more detail when we look
    at extending the Jenkins user interface ourselves. We will see how you can develop
    and add your own customized GUI items directly to the Jenkins user interface,
    allowing you to extend things even further using Jelly, your own plugins, and
    the provided Jenkins extension points.
  prefs: []
  type: TYPE_NORMAL
