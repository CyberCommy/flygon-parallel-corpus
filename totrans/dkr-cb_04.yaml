- en: Chapter 4. Network and Data Management for Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing containers from outside
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing data in containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking two or more containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a LAMP application by linking containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking of multihost container with Flannel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning IPv6 addresses to containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have worked with a single container and accessed it locally. But
    as we move to more real world use cases, we will need to access the container
    from the outside world, share external storage within the container, communicate
    with containers running on other hosts, and so on. In this chapter, we'll see
    how to fulfill some of those requirements. Let's start by understanding Docker's
    default networking setup and then go to advanced use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the Docker daemon starts, it creates a virtual Ethernet bridge with the
    name `docker0`. For example, we will see the following with the `ip addr` command
    on the system that runs the Docker daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](../Images/image00314.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, `docker0` has the IP address 172.17.42.1/16\. Docker randomly
    chooses an address and subnet from a private range defined in RFC 1918 ([https://tools.ietf.org/html/rfc1918](https://tools.ietf.org/html/rfc1918)).
    Using this bridged interface, containers can communicate with each other and with
    the host system.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, every time Docker starts a container, it creates a pair of virtual
    interfaces, one end of which is attached to the host system and other end to the
    created container. Let''s start a container and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](../Images/image00315.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The end that is attached to the `eth0` interface of the container gets the
    172.17.0.1/16 IP address. We also see the following entry for the other end of
    the interface on the host system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](../Images/image00316.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s create a few more containers and look at the `docker0` bridge with
    the `brctl` command, which manages Ethernet bridges:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](../Images/image00317.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Every veth* binds to the `docker0` bridge, which creates a virtual subnet shared
    between the host and every Docker container. Apart from setting up the `docker0`
    bridge, Docker creates IPtables NAT rules, such that all containers can talk to
    the external world by default but not the other way around. Let''s look at the
    NAT rules on the Docker host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](../Images/image00318.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we try to connect to the external world from a container, we will have to
    go through the Docker bridge that was created by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](../Images/image00319.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Later in this chapter, we will see how the external world can connect to a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'When starting a container, we have a few modes to select its networking:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--net=bridge`: This is the default mode that we just saw. So, the preceding
    command that we used to start the container can be written as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`--net=host`: With this option, Docker does not create a network namespace
    for the container; instead, the container will network stack with the host. So,
    we can start the container with this option as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then run the `ip addr` command within the container as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](../Images/image00320.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can see all the network devices attached to the host. An example of using
    such a configuration is to run the `nginx` reverse proxy within a container to
    serve the web applications running on the host.
  prefs: []
  type: TYPE_NORMAL
- en: '`--net=container:NAME_or_ID`: With this option, Docker does not create a new
    network namespace while starting the container but shares it from another container.
    Let''s start the first container and look for its IP address:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![Introduction](../Images/image00321.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now start another as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![Introduction](../Images/image00322.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, both containers contain the same IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Containers in a Kubernetes ([http://kubernetes.io/](http://kubernetes.io/))
    Pod use this trick to connect with each other. We will revisit this in [Chapter
    8](part0081.xhtml#aid-2D7TI1 "Chapter 8. Docker Orchestration and Hosting Platforms"),
    *Docker Orchestration and Hosting Platforms*.
  prefs: []
  type: TYPE_NORMAL
- en: '`--net=none`: With this option, Docker creates the network namespace inside
    the container but does not configure networking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about the different networking we discussed in the preceding
    section, visit [https://docs.docker.com/articles/networking/#how-docker-networks-a-container](https://docs.docker.com/articles/networking/#how-docker-networks-a-container).
  prefs: []
  type: TYPE_NORMAL
- en: From Docker 1.2 onwards, it is also possible to change `/etc/host`, `/etc/hostname`,
    and `/etc/resolv.conf` on a running container. However, note that these are just
    used to run a container. If it restarts, we will have to make the changes again.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have looked at networking on a single host, but in the real world,
    we would like to connect multiple hosts and have a container from one host to
    talk to a container from another host. Flannel ([https://github.com/coreos/flannel](https://github.com/coreos/flannel)),
    Weave ([https://github.com/weaveworks/weave](https://github.com/weaveworks/weave)),
    Calio ([http://www.projectcalico.org/getting-started/docker/](http://www.projectcalico.org/getting-started/docker/)),
    and Socketplane ([http://socketplane.io/](http://socketplane.io/)) are some solutions
    that offer this functionality. Later in this chapter, we will see how to configure
    Flannel to multihost networking. Socketplane joined Docker Inc in March '15.
  prefs: []
  type: TYPE_NORMAL
- en: Community and Docker are building a **Container Network Model** (**CNM**) with
    libnetwork ([https://github.com/docker/libnetwork](https://github.com/docker/libnetwork)),
    which provides a native Go implementation to connect containers. More information
    on this development can be found at [http://blog.docker.com/2015/04/docker-networking-takes-a-step-in-the-right-direction-2/](http://blog.docker.com/2015/04/docker-networking-takes-a-step-in-the-right-direction-2/).
  prefs: []
  type: TYPE_NORMAL
- en: Accessing containers from outside
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the container is up, we would like to access it from outside. If you have
    started the container with the `--net=host` option, then it can be accessed through
    the Docker host IP. With `--net=none`, you can attach the network interface from
    the public end or through other complex settings. Let's see what happens in by
    default—where packets are forwarded from the host network interface to the container.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure the Docker daemon is running on the host and you can connect through
    the Docker client.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start a container with the `-P` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](../Images/image00323.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This automatically maps any network port of the container to a random high port
    of the Docker host between 49000 to 49900.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PORTS` section, we see `0.0.0.0:49159->80/tcp`, which is of the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So, in case any request comes on port `49159` from any interface on the Docker
    host, the request will be forwarded to port `80` of the `centos1` container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also map a specific port of the container to the specific port of the
    host using the `-p` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](../Images/image00324.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, all requests coming on port `5000` from any interface on the Docker
    host will be forwarded to port `22` of the `centos2` container.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the default configuration, Docker sets up the firewall rule to forward
    the connection from the host to the container and enables IP forwarding on the
    Docker host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](../Images/image00325.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the preceding example, a `DNAT` rule has been set up to forward
    all traffic on port `5000` of the host to port `22` of the container.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, with the `-p` option, Docker will forward all the requests coming
    to any interface to the host. To bind to a specific interface, we can specify
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, only requests coming to port `5000` on the interface that has
    the IP `192.168.1.10` on the Docker host will be forwarded to port `22` of the
    `f20` container. To map port `22` of the container to the dynamic port of the
    host, we can run following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can bind multiple ports on containers to ports on hosts as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can look up the public-facing port that is mapped to the container''s port
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To look at all the network settings of a container, we can run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Networking documentation on the Docker website at [https://docs.docker.com/articles/networking/](https://docs.docker.com/articles/networking/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing data in containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any uncommitted data or changes in containers get lost as soon as containers
    are deleted. For example, if you have configured the Docker registry in a container
    and pushed some images, as soon as the registry container is deleted, all of those
    images will get lost if you have not committed them. Even if you commit, it is
    not the best practice. We should try to keep containers as light as possible.
    The following are two primary ways to manage data with Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data volumes**: From the Docker documentation ([https://docs.docker.com/userguide/dockervolumes/](https://docs.docker.com/userguide/dockervolumes/)),
    a data volume is a specially-designated directory within one or more containers
    that bypasses the Union filesystem to provide several useful features for persistent
    or shared data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volumes are initialized when a container is created. If the container's base
    image contains data at the specified mount point, that data is copied into the
    new volume.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data volumes can be shared and reused between containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes to a data volume are made directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes to a data volume will not be included when you update an image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volumes persist until no containers use them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data volume containers**: As a volume persists until no container uses it,
    we can use the volume to share persistent data between containers. So, we can
    create a named volume container and mount the data to another container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure that the Docker daemon is running on the host and you can connect
    through the Docker client.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a data volume. With the `-v` option with the `docker run` command, we add
    a data volume to the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can have multiple data volumes within a container, which can be created
    by adding `-v` multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `VOLUME` instruction can be used in a Dockerfile to add data volume as well
    by adding something similar to `VOLUME ["/data"]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `inspect` command to look at the data volume details of a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it...](../Images/image00326.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If the target directory is not there within the container, it will be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we mount a host directory as a data volume. We can also map a host directory
    to a data volume with the `-v` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be very useful in cases such as testing code in different environments,
    collecting logs in central locations, and so on. We can also map the host directory
    in read-only mode as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also mount the entire root filesystem of the host within the container
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If the directory on the host (`/srv`) does not exist, then it will be created,
    given that you have permission to create one. Also, on the Docker host where SELinux
    is enabled and if the Docker daemon is configured to use SELinux (`docker -d --selinux-enabled`),
    you will see the `permission denied` error if you try to access files on mounted
    volumes until you relabel them. To relabel them, use either of the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Please visit [Chapter 9](part0092.xhtml#aid-2NNJO2 "Chapter 9. Docker Security"),
    *Docker Security*, for more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a data volume container. While sharing the host directory to a
    container through volume, we are binding the container to a given host, which
    is not good. Also, the storage in this case is not controlled by Docker. So, in
    cases when we want data to be persisted even if we update the containers, we can
    get help from data volume containers. Data volume containers are used to create
    a volume and nothing else; they do not even run. As the created volume is attached
    to a container (not running), it cannot be deleted. For example, here''s a named
    data container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will just create a volume that will be mapped to a directory managed by
    Docker. Now, other containers can mount the volume from the data container using
    the `--volumes-from` option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can mount a volume from the data volume container to multiple containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it...](../Images/image00327.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can also use `--volumes-from` multiple times to get the data volumes from
    multiple containers. We can also create a chain by mounting volumes from the container
    that mounts from some other container.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In case of data volume, when the host directory is not shared, Docker creates
    a directory within `/var/lib/docker/` and then shares it with other containers.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Volumes are deleted with `-v` flag to `docker rm`, only if no other container
    is using it. If some other container is using the volume, then the container will
    be removed (with `docker rm`) but the volume will not be removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the previous chapter, we saw how to configure the Docker registry, which
    by default starts with the `dev` flavor. In this registry, uploaded images were
    saved in the `/tmp/registry` folder within the container we started. We can mount
    a directory from the host at `/tmp/registry` within the registry container, so
    whenever we upload an image, it will be saved on the host that is running the
    Docker registry. So, to start the container, we run following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To push an image, we run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After the image is successfully pushed, we can look at the content of the directory
    that we mounted within the Docker registry. In our case, we should see a directory
    structure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The documentation on the Docker website at [https://docs.docker.com/userguide/dockervolumes/](https://docs.docker.com/userguide/dockervolumes/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://container42.com/2013/12/16/persistent-volumes-with-docker-container-as-volume-pattern/](http://container42.com/2013/12/16/persistent-volumes-with-docker-container-as-volume-pattern/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://container42.com/2014/11/03/docker-indepth-volumes/](http://container42.com/2014/11/03/docker-indepth-volumes/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking two or more containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With containerization, we would like to create our stack by running services
    on different containers and then linking them together. In the previous chapter,
    we created a WordPress container by putting both a web server and database in
    the same container. However, we can also put them in different containers and
    link them together. Container linking creates a parent-child relationship between
    them, in which the parent can see selected information of its children. Linking
    relies on the naming of containers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure the Docker daemon is running on the host and you can connect through
    the Docker client.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a named container called `centos_server`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](../Images/image00328.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s start another container with the `name` client and link it with
    the `centos_server` container using the `--link` option, which takes the `name:alias`
    argument. Then look at the `/etc/hosts` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](../Images/image00329.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding example, we linked the `centos_server` container to the client
    container with an alias server. By linking the two containers, an entry of the
    first container, which is `centos_server` in this case, is added to the `/etc/hosts`
    file in the client container. Also, an environment variable called `SERVER_NAME`
    is set within the client to refer to the server.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](../Images/image00330.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s create a `mysql` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s link it from a client and check the environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![There''s more…](../Images/image00331.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, let''s look at the `docker ps` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](../Images/image00332.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you look closely, we did not specify the `-P` or `-p` options to map ports
    between two containers while starting the `client` container. Depending on the
    ports exposed by a container, Docker creates an internal secure tunnel in the
    containers that links to it. And, to do that, Docker sets environment variables
    within the linker container. In the preceding case, `mysql` is the linked container
    and client is the linker container. As the `mysql` container exposes port `3306`,
    we see corresponding environment variables (`MYSQL_SERVER_*`) within the client
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As linking depends on the name of the container, if you want to reuse a name,
    you must delete the old container.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation on the Docker website at [https://docs.docker.com/userguide/dockerlinks/](https://docs.docker.com/userguide/dockerlinks/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a LAMP application by linking containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's extend the previous recipe by creating a LAMP application (WordPress)
    by linking the containers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To pull MySQL and WordPress images from the Docker registry:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For MySQL:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For image, visit [https://registry.hub.docker.com/_/mysql/](https://registry.hub.docker.com/_/mysql/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Dockerfile, visit [https://github.com/docker-library/docker-mysql](https://github.com/docker-library/docker-mysql)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For WordPress:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For image, visit [https://registry.hub.docker.com/_/wordpress/](https://registry.hub.docker.com/_/wordpress/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Dockerfile, visit [https://github.com/docker-library/wordpress](https://github.com/docker-library/wordpress)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, start a `mysql` container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, start the `wordpress` container and link it with the `mysql` container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](../Images/image00333.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We have the Docker host's `8080` port to container `80` port, so we can connect
    WordPress by accessing the `8080` port on the Docker host with the `http://<DockerHost>:8080`
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A link is created between the `wordpress` and `mysql` containers. Whenever the
    `wordpress` container gets a DB request, it passes it on to the `mysql` container
    and gets the results. Look at the preceding recipe for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Networking of multihost containers with Flannel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll use Flannel ([https://github.com/coreos/flannel](https://github.com/coreos/flannel))
    to set up multihost container networking. Flannel is a generic overlay network
    that can be used as an alternative to **Software Defined Networking** (**SDN**).
    It is an IP-based solution that uses **Virtual Extensible LAN** (**VXLAN**), in
    which unique IP addresses are assigned to each container on a unique subnet given
    to the host that is running that container. So, in this kind of a solution, a
    different subnet and communication occurs within each host in the cluster, using
    the overlay network. Flannel uses the `etcd` service ([https://github.com/coreos/etcd](https://github.com/coreos/etcd))
    for the key-value store.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will require three VMs or physical machines with Fedora
    21 installed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's call one machine/VM `master` and other two `minion1` and `minion2`. According
    to your system's IP addresses, update the `/etc/hosts` file as follows:![How to
    do it…](../Images/image00334.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install `etcd`, `Flannel`, and `Docker` on all the systems we set up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the value of the `ETCD_LISTEN_CLIENT_URLS` to `http://master.example.com:4001`
    in the `/etc/etcd/etcd.conf` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the master, start the `etcd` service and check its status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the master, create a file called `flannel-config.json` with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Upload the preceding configuration file to `etcd` using `config` as the key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](../Images/image00335.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In master, update `FLANNEL_OPTIONS` in the `/etc/sysconfig/flanneld` file to
    reflect the interface of the system. Also, update `FLANNEL_ETCD` to use hostname
    instead of the 127.0.0.1:4001 address.![How to do it…](../Images/image00336.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To enable and start the `flanneld` service in master:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](../Images/image00337.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'From the minion systems, check the connectivity to master for `etcd`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Update the `/etc/sysconfig/flanneld` file in both minions to point to the `etcd`
    server running in master and update `FLANNEL_OPTIONS` to reflect the interface
    of the minion host:![How to do it…](../Images/image00338.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To enable and start the `flanneld` service in both the minions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In any of the hosts in the cluster, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](../Images/image00339.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This tells us the number of hosts in the network and the subnets associated
    (look at the key for each node) with them. We can associate the subnet with the
    MAC address on the hosts. On each host, the `/run/flannel/docker` and `/run/flannel/subnet.env`
    files are populated with subnet information. For instance, in `minion2`, you would
    see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](../Images/image00340.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To restart the Docker daemon in all the hosts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, look at the IP address of the `docker0` and `flannel.1` interfaces. In
    `minion2`, it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](../Images/image00341.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the `docker0` interface got the IP from the same subnet as the
    `flannel.1` interface, which is used to route all traffic.
  prefs: []
  type: TYPE_NORMAL
- en: We are all set to spawn two containers in any of the hosts and they should be
    able to communicate. Let's create one container in `minion1` and get its IP address:![How
    to do it…](../Images/image00342.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now create another container in `minion2` and ping the container running in
    `minion1` as follows:![How to do it…](../Images/image00343.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Flannel, we first configure the overlay with the `10.0.0.0/16` network.
    Then, each host picks up a random `/24` network; for instance, in our case, `minion2`
    gets the `10.0.62.0/24` subnet and so on. Once configured, a container in the
    host gets the IP address from that chosen subnet. Flannel encapsulates the packets
    and sends it to remote hosts using UDP.
  prefs: []
  type: TYPE_NORMAL
- en: Also, during installation, Flannel copies a configuration file (`flannel.conf`)
    within `/usr/lib/systemd/system/docker.service.d/`, which Docker uses to configure
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The diagram from Flannel GitHub to help you understand the theory of operations
    at [https://github.com/coreos/flannel/blob/master/packet-01.png](https://github.com/coreos/flannel/blob/master/packet-01.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation on the CoreOS website at [https://coreos.com/blog/introducing-rudder/](https://coreos.com/blog/introducing-rudder/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scott Collier's blog post about setting Flannel on Fedora at [http://www.colliernotes.com/2015/01/flannel-and-docker-on-fedora-getting.html](http://www.colliernotes.com/2015/01/flannel-and-docker-on-fedora-getting.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning IPv6 addresses to containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Docker assigns IPv4 addresses to containers. With Docker 1.5, a
    feature has been added to support IPv6 addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure the Docker daemon (version 1.5 and above) is running on the host and
    you can connect through the Docker client.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start the Docker daemon with the `--ipv6` option, we can add this option
    in the daemon''s configuration file (`/etc/sysconfig/docker` on Fedora) as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if we start Docker in daemon mode, then we can start it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: By running either of these commands, Docker will set up the `docker0` bridge
    with the IPv6 local link address `fe80::1`.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](../Images/image00344.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's start the container and look for the IP addresses assigned to it:![How
    to do it…](../Images/image00345.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we can see, both the IPv4 and local link IPv6 addresses are available to
    the container. To ping on the IPv6 address of a container from the host machine,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To ping the `docker0` bridge from the container, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker configures the `docker0` bridge to assign IPv6 addresses to containers,
    which enables us to use the IPv6 address of containers.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, containers will get the link-local address. To assign them a globally
    routable address, you can pass the IPv6 subnet pick address with `--fixed-cidr-v6`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '![There''s more…](../Images/image00346.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From here, we can see that the globally routable address (GlobalIPv6Address)
    is now being set.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Docker 1.5 release notes at [https://blog.docker.com/2015/02/docker-1-5-ipv6-support-read-only-containers-stats-named-dockerfiles-and-more/](https://blog.docker.com/2015/02/docker-1-5-ipv6-support-read-only-containers-stats-named-dockerfiles-and-more/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation on the Docker website at [http://docs.docker.com/v1.5/articles/networking/#ipv6](http://docs.docker.com/v1.5/articles/networking/#ipv6).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might need to delete the exiting `docker0` bridge on the host before setting
    the IPv6 option. To understand how to do so, visit [http://docs.docker.com/v1.5/articles/networking/#customizing-docker0](http://docs.docker.com/v1.5/articles/networking/#customizing-docker0).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
