- en: Chapter 8. Dealing with Legacy Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading a Django code base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering relevant documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incremental changes versus full rewrites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests before changing code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Legacy database integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It sounds exciting when you are asked to join a project. Powerful new tools
    and cutting-edge technologies might await you. However, quite often, you are asked
    to work with an existing, possibly ancient, codebase.
  prefs: []
  type: TYPE_NORMAL
- en: To be fair, Django has not been around for that long. However, projects written
    for older versions of Django are sufficiently different to cause concern. Sometimes,
    having the entire source code and documentation might not be enough.
  prefs: []
  type: TYPE_NORMAL
- en: If you are asked to recreate the environment, then you might need to fumble
    with the OS configuration, database settings, and running services locally or
    on the network. There are so many pieces to this puzzle that you might wonder
    how and where to start.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Django version used in the code is a key piece of information.
    As Django evolved, everything from the default project structure to the recommended
    best practices have changed. Therefore, identifying which version of Django was
    used is a vital piece in understanding it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Change of Guards**'
  prefs: []
  type: TYPE_NORMAL
- en: Sitting patiently on the ridiculously short beanbags in the training room, the
    SuperBook team waited for Hart. He had convened an emergency go-live meeting.
    Nobody understood the "emergency" part since go live was at least 3 months away.
  prefs: []
  type: TYPE_NORMAL
- en: Madam O rushed in holding a large designer coffee mug in one hand and a bunch
    of printouts of what looked like project timelines in the other. Without looking
    up she said, "We are late so I will get straight to the point. In the light of
    last week's attacks, the board has decided to summarily expedite the SuperBook
    project and has set the deadline to end of next month. Any questions?"
  prefs: []
  type: TYPE_NORMAL
- en: '"Yeah," said Brad, "Where is Hart?" Madam O hesitated and replied, "Well, he
    resigned. Being the head of IT security, he took moral responsibility of the perimeter
    breach." Steve, evidently shocked, was shaking his head. "I am sorry," she continued,
    "But I have been assigned to head SuperBook and ensure that we have no roadblocks
    to meet the new deadline."'
  prefs: []
  type: TYPE_NORMAL
- en: There was a collective groan. Undeterred, Madam O took one of the sheets and
    began, "It says here that the Remote Archive module is the most high-priority
    item in the incomplete status. I believe Evan is working on this."
  prefs: []
  type: TYPE_NORMAL
- en: '"That''s correct," said Evan from the far end of the room. "Nearly there,"
    he smiled at others, as they shifted focus to him. Madam O peered above the rim
    of her glasses and smiled almost too politely. "Considering that we already have
    an extremely well-tested and working Archiver in our Sentinel code base, I would
    recommend that you leverage that instead of creating another redundant system."'
  prefs: []
  type: TYPE_NORMAL
- en: '"But," Steve interrupted, "it is hardly redundant. We can improve over a legacy
    archiver, can''t we?" "If it isn''t broken, then don''t fix it", replied Madam
    O tersely. He said, "He is working on it," said Brad almost shouting, "What about
    all that work he has already finished?"'
  prefs: []
  type: TYPE_NORMAL
- en: '"Evan, how much of the work have you completed so far?" asked O, rather impatiently.
    "About 12 percent," he replied looking defensive. Everyone looked at him incredulously.
    "What? That was the hardest 12 percent" he added.'
  prefs: []
  type: TYPE_NORMAL
- en: O continued the rest of the meeting in the same pattern. Everybody's work was
    reprioritized and shoe-horned to fit the new deadline. As she picked up her papers,
    readying to leave she paused and removed her glasses.
  prefs: []
  type: TYPE_NORMAL
- en: '"I know what all of you are thinking... literally. But you need to know that
    we had no choice about the deadline. All I can tell you now is that the world
    is counting on you to meet that date, somehow or other." Putting her glasses back
    on, she left the room.'
  prefs: []
  type: TYPE_NORMAL
- en: '"I am definitely going to bring my tinfoil hat," said Evan loudly to himself.'
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Django version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ideally, every project will have a `requirements.txt` or `setup.py` file at
    the root directory, and it will have the exact version of Django used for that
    project. Let''s look for a line similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that the version number is exactly mentioned (rather than `Django>=1.5.9`),
    which is called **pinning**. Pinning every package is considered a good practice
    since it reduces surprises and makes your build more deterministic.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, there are real-world codebases where the `requirements.txt` file
    was not updated or even completely missing. In such cases, you will need to probe
    for various tell-tale signs to find out the exact version.
  prefs: []
  type: TYPE_NORMAL
- en: Activating the virtual environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In most cases, a Django project would be deployed within a virtual environment.
    Once you locate the virtual environment for the project, you can activate it by
    jumping to that directory and running the activated script for your OS. For Linux,
    the command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the virtual environment is active, start a Python shell and query the
    Django version as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The Django version used in this case is Version 1.5.9.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can run the `manage.py` script in the project to get a similar
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this option would not be available if the legacy project source snapshot
    was sent to you in an undeployed form. If the virtual environment (and packages)
    was also included, then you can easily locate the version number (in the form
    of a tuple) in the `__init__.py` file of the Django directory. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If all these methods fail, then you will need to go through the release notes
    of the past Django versions to determine the identifiable changes (for example,
    the `AUTH_PROFILE_MODULE` setting was deprecated since Version 1.5) and match
    them to your legacy code. Once you pinpoint the correct Django version, then you
    can move on to analyzing the code.
  prefs: []
  type: TYPE_NORMAL
- en: Where are the files? This is not PHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most difficult ideas to get used to, especially if you are from the
    PHP or ASP.NET world, is that the source files are not located in your web server's
    document root directory, which is usually named `wwwroot` or `public_html`. Additionally,
    there is no direct relationship between the code's directory structure and the
    website's URL structure.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, you will find that your Django website's source code is stored in an
    obscure path such as `/opt/webapps/my-django-app`. Why is this? Among many good
    reasons, it is often more secure to move your confidential data outside your public
    webroot. This way, a web crawler would not be able to accidentally stumble into
    your source code directory.
  prefs: []
  type: TYPE_NORMAL
- en: As you would read in the [Chapter 11](ch11.html "Chapter 11. Production-ready"),
    *Production-ready* the location of the source code can be found by examining your
    web server's configuration file. Here, you will find either the environment variable
    `DJANGO_SETTINGS_MODULE` being set to the module's path, or it will pass on the
    request to a WSGI server that will be configured to point to your `project.wsgi`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with urls.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if you have access to the entire source code of a Django site, figuring
    out how it works across various apps can be daunting. It is often best to start
    from the root `urls.py` `URLconf` file since it is literally a map that ties every
    request to the respective views.
  prefs: []
  type: TYPE_NORMAL
- en: With normal Python programs, I often start reading from the start of its execution—say,
    from the top-level main module or wherever the `__main__` check idiom starts.
    In the case of Django applications, I usually start with `urls.py` since it is
    easier to follow the flow of execution based on various URL patterns a site has.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Linux, you can use the following `find` command to locate the `settings.py`
    file and the corresponding line specifying the root `urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Jumping around the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reading code sometimes feels like browsing the web without the hyperlinks. When
    you encounter a function or variable defined elsewhere, then you will need to
    jump to the file that contains that definition. Some IDEs can do this automatically
    for you as long as you tell it which files to track as part of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use Emacs or Vim instead, then you can create a TAGS file to quickly
    navigate between files. Go to the project root and run a tool called **Exuberant
    Ctags** as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This creates a file called TAGS that contains the location information, where
    every syntactic unit such as classes and functions are defined. In Emacs, you
    can find the definition of the tag, where your cursor (or point as it called in
    Emacs) is at using the `M-.` command.
  prefs: []
  type: TYPE_NORMAL
- en: While using a tag file is extremely fast for large code bases, it is quite basic
    and is not aware of a virtual environment (where most definitions might be located).
    An excellent alternative is to use the `elpy` package in Emacs. It can be configured
    to detect a virtual environment. Jumping to a definition of a syntactic element
    is using the same `M-.` command. However, the search is not restricted to the
    tag file. So, you can even jump to a class definition within the Django source
    code seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the code base
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is quite rare to find legacy code with good documentation. Even if you do,
    the documentation might be out of sync with the code in subtle ways that can lead
    to further issues. Often, the best guide to understand the application's functionality
    is the executable test cases and the code itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The official Django documentation has been organized by versions at [https://docs.djangoproject.com](https://docs.djangoproject.com).
    On any page, you can quickly switch to the corresponding page in the previous
    versions of Django with a selector on the bottom right-hand section of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the code base](img/6644_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the same way, documentation for any Django package hosted on [readthedocs.org](http://readthedocs.org)
    can also be traced back to its previous versions. For example, you can select
    the documentation of `django-braces` all the way back to v1.0.0 by clicking on
    the selector on the bottom left-hand section of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the code base](img/6644_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the big picture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most people find it easier to understand an application if you show them a high-level
    diagram. While this is ideally created by someone who understands the workings
    of the application, there are tools that can create very helpful high-level depiction
    of a Django application.
  prefs: []
  type: TYPE_NORMAL
- en: 'A graphical overview of all models in your apps can be generated by the `graph_models`
    management command, which is provided by the `django-command-extensions` package.
    As shown in the following diagram, the model classes and their relationships can
    be understood at a glance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the big picture](img/6644_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Model classes used in the SuperBook project connected by arrows indicating their
    relationships
  prefs: []
  type: TYPE_NORMAL
- en: This visualization is actually created using PyGraphviz. This can get really
    large for projects of even medium complexity. Hence, it might be easier if the
    applications are logically grouped and visualized separately.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**PyGraphviz Installation and Usage**'
  prefs: []
  type: TYPE_NORMAL
- en: If you find the installation of PyGraphviz challenging, then don't worry, you
    are not alone. Recently, I faced numerous issues while installing on Ubuntu, starting
    from Python 3 incompatibility to incomplete documentation. To save your time,
    I have listed the steps that worked for me to reach a working setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Ubuntu, you will need the following packages installed to install PyGraphviz:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now activate your virtual environment and run pip to install the development
    version of PyGraphviz directly from GitHub, which supports Python 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Next, install `django-extensions` and add it to your `INSTALLED_APPS`. Now,
    you are all set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample usage to create a GraphViz dot file for just two apps and
    to convert it to a PNG image for viewing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Incremental change or a full rewrite?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, you would be handed over legacy code by the application owners in the
    earnest hope that most of it can be used right away or after a couple of minor
    tweaks. However, reading and understanding a huge and often outdated code base
    is not an easy job. Unsurprisingly, most programmers prefer to work on greenfield
    development.
  prefs: []
  type: TYPE_NORMAL
- en: In the best case, the legacy code ought to be easily testable, well documented,
    and flexible to work in modern environments so that you can start making incremental
    changes in no time. In the worst case, you might recommend discarding the existing
    code and go for a full rewrite. Or, as it is commonly decided, the short-term
    approach would be to keep making incremental changes, and a parallel long-term
    effort might be underway for a complete reimplementation.
  prefs: []
  type: TYPE_NORMAL
- en: A general rule of thumb to follow while taking such decisions is—if the cost
    of rewriting the application and maintaining the application is lower than the
    cost of maintaining the old application over time, then it is recommended to go
    for a rewrite. Care must be taken to account for all the factors, such as time
    taken to get new programmers up to speed, the cost of maintaining outdated hardware,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the complexity of the application domain becomes a huge barrier against
    a rewrite, since a lot of knowledge learnt in the process of building the older
    code gets lost. Often, this dependency on the legacy code is a sign of poor design
    in the application like failing to externalize the business rules from the application
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: The worst form of a rewrite you can probably undertake is a conversion, or a
    mechanical translation from one language to another without taking any advantage
    of the existing best practices. In other words, you lost the opportunity to modernize
    the code base by removing years of cruft.
  prefs: []
  type: TYPE_NORMAL
- en: Code should be seen as a liability not an asset. As counter-intuitive as it
    might sound, if you can achieve your business goals with a lesser amount of code,
    you have dramatically increased your productivity. Having less code to test, debug,
    and maintain can not only reduce ongoing costs but also make your organization
    more agile and flexible to change.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Code is a liability not an asset. Less code is more maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Irrespective of whether you are adding features or trimming your code, you must
    not touch your working legacy code without tests in place.
  prefs: []
  type: TYPE_NORMAL
- en: Write tests before making any changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the book *Working Effectively with Legacy Code*, Michael Feathers defines
    legacy code as, simply, code without tests. He elaborates that with tests one
    can easily modify the behavior of the code quickly and verifiably. In the absence
    of tests, it is impossible to gauge if the change made the code better or worse.
  prefs: []
  type: TYPE_NORMAL
- en: Often, we do not know enough about legacy code to confidently write a test.
    Michael recommends writing tests that preserve and document the existing behavior,
    which are called characterization tests.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the usual approach of writing tests, while writing a characterization
    test, you will first write a failing test with a dummy output, say *X*, because
    you don't know what to expect. When the test harness fails with an error, such
    as "**Expected output X but got Y**", then you will change your test to expect
    *Y*. So, now the test will pass, and it becomes a record of the code's existing
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we might record buggy behavior as well. After all, this is unfamiliar
    code. Nevertheless, writing such tests are necessary before we start changing
    the code. Later, when we know the specifications and code better, we can fix these
    bugs and update our tests (not necessarily in that order).
  prefs: []
  type: TYPE_NORMAL
- en: Step-by-step process to writing tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing tests before changing the code is similar to erecting scaffoldings before
    the restoration of an old building. It provides a structural framework that helps
    you confidently undertake repairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might want to approach this process in a stepwise manner as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the area you need to make changes to. Write characterization tests
    focusing on this area until you have satisfactorily captured its behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look at the changes you need to make and write specific test cases for those.
    Prefer smaller unit tests to larger and slower integration tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Introduce incremental changes and test in lockstep. If tests break, then try
    to analyze whether it was expected. Don't be afraid to break even the characterization
    tests if that behavior is something that was intended to change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have a good set of tests around your code, then you can quickly find
    the effect of changing your code.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you decide to rewrite by discarding your code but not
    your data, then Django can help you considerably.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is an entire section on legacy databases in Django documentation and rightly
    so, as you will run into them many times. Data is more important than code, and
    databases are the repositories of data in most enterprises.
  prefs: []
  type: TYPE_NORMAL
- en: You can modernize a legacy application written in other languages or frameworks
    by importing their database structure into Django. As an immediate advantage,
    you can use the Django admin interface to view and change your legacy data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Django makes this easy with the `inspectdb` management command, which looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This command, if run while your settings are configured to use the legacy database,
    can automatically generate the Python code that would go into your models file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some best practices if you are using this approach to integrate to
    a legacy database:'
  prefs: []
  type: TYPE_NORMAL
- en: Know the limitations of Django ORM beforehand. Currently, multicolumn (composite)
    primary keys and NoSQL databases are not supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't forget to manually clean up the generated models, for example, remove
    the redundant '`ID`' fields since Django creates them automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foreign Key relationships may have to be manually defined. In some databases,
    the auto-generated models will have them as integer fields (suffixed with `_id`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organize your models into separate apps. Later, it will be easier to add the
    views, forms, and tests in the appropriate folders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that running the migrations will create Django's administrative tables
    (`django_*` and `auth_*`) in the legacy database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In an ideal world, your auto-generated models would immediately start working,
    but in practice, it takes a lot of trial and error. Sometimes, the data type that
    Django inferred might not match your expectations. In other cases, you might want
    to add additional meta information such as `unique_together` to your model.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, you should be able to see all the data that was locked inside that
    aging PHP application in your familiar Django admin interface. I am sure this
    will bring a smile to your face.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at various techniques to understand legacy code.
    Reading code is often an underrated skill. But rather than reinventing the wheel,
    we need to judiciously reuse good working code whenever possible. In this chapter
    and the rest of the book, we emphasize the importance of writing test cases as
    an integral part of coding.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about writing test cases and the often frustrating
    task of debugging that follows.
  prefs: []
  type: TYPE_NORMAL
