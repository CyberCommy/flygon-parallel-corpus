- en: Chapter 27. Android Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we are going to make apps that offer our users significant features, then
    almost certainly we are going to need a way to manage, store, and filter significant
    amounts of data.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to efficiently store very large amounts of data with JSON, but
    when we need to use that data selectively rather than simply restricting ourselves
    to the options of "save everything" and "load everything", we need to think about
    which other options are available.
  prefs: []
  type: TYPE_NORMAL
- en: A good computer science course would probably teach the algorithms necessary
    for handling the sorting and filtering our data, but the effort involved would
    be quite extensive, and what are the chances of us coming up with a solution that
    is as good as the people who provide us with the Android API?
  prefs: []
  type: TYPE_NORMAL
- en: So often, it makes sense to use the solutions provided in the Android API. As
    we have seen, `JSON` and `SharedPreferences` classes have their place but at some
    point, we need to move on to using real databases for real-world solutions. Android
    uses the SQLite database management system and, as you would expect, there is
    an API to make it as easy as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Find out exactly what a database is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn what SQL and SQLite are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn the basics of the SQL language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a look at the Android SQLite API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code the Age Database app that we started in the previous chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database 101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's answer a whole bunch of those database-related questions, and then we
    can get started making apps that use SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is a database?
  prefs: []
  type: TYPE_NORMAL
- en: What is a database?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **database** is both a place of storage and the means to retrieve, store,
    and manipulate data. It helps to be able to visualize a database before learning
    how to use it. The actual structure of the internals of a database varies greatly
    depending upon the database in question. SQLite actually stores all its data in
    a single file.
  prefs: []
  type: TYPE_NORMAL
- en: It will aid our comprehension greatly however if we visualize our data as if
    it were in a spreadsheet, or sometimes, multiple spreadsheets. Our database, like
    a spreadsheet, will be divided into multiple columns that represent different
    types of data, and rows that represent entries into the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about a database with names and exam scores. Take a look at this visual
    representation of this data for how we could imagine it in a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a database?](img/B12806_27_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice, however, that there is an extra column of data—an **ID** column. We
    will talk more about this as we proceed. This single spreadsheet-like structure
    is called a **table**. As mentioned before, there might be, and often are, multiple
    tables in a database. Each column of the table will have a name that can be referred
    to when speaking to the database. When we ask the database questions, we say that
    we are **querying** the database.
  prefs: []
  type: TYPE_NORMAL
- en: What is SQL?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SQL** stands for **Structured Query Language**. It is the syntax that is
    used to get things done with the database.'
  prefs: []
  type: TYPE_NORMAL
- en: What is SQLite?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLite is the name of the entire database system that is favored by Android,
    and it has its own version of SQL. The reason the SQLite version of SQL needs
    to be slightly different to some other versions is because the database has different
    features.
  prefs: []
  type: TYPE_NORMAL
- en: The SQL syntax primer that follows will focus on the SQLite version.
  prefs: []
  type: TYPE_NORMAL
- en: The SQL syntax primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can learn how to use SQLite with Android, we need to first learn the
    basics of how to use SQLite in general, in a platform-neutral context.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some example SQL code that could be used on an SQLite database
    directly, without any Kotlin or Android classes, and then we can more easily understand
    what our Kotlin code is doing later on.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite example code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQL has keywords, much like Kotlin, that cause things to happen. Here is a
    flavor of some of the SQL keywords we will soon be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '`INSERT`: Allows us to add data to the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: Allows us to remove data from the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SELECT`: Allows us to read data from the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WHERE`: Allows us to specify the parts of the database that match specific
    criteria we want to `INSERT`, `DELETE,` or `SELECT` from'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FROM`: Used for specifying a table or column name in a database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many more SQLite keywords than this and, for a comprehensive list,
    take a look at this link: [https://sqlite.org/lang_keywords.html](https://sqlite.org/lang_keywords.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to keywords, SQL has **types**. Some examples of SQL types are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**integer**: Just what we need for storing whole numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**text**: Perfect for storing a simple name or address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**real**: For large floating-point numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many more SQLite types than this and, for a comprehensive list, take
    a look at this link: [https://www.sqlite.org/datatype3.html](https://www.sqlite.org/datatype3.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how we can combine those types with keywords to create tables,
    and add, remove, modify, and read data, using full SQLite statements.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It would be a perfectly decent question to ask why we don''t first create a
    new database. The reason for this is that every app has access to an SQLite database
    by default. The database is private to that app. Here is the statement we would
    use to create a table within that database. I have highlighted a few parts to
    make the statement clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The previous code creates a table called `StudentsAndGrades` with an **integer**
    row **id** that will be automatically increased (incremented) each time a row
    of data is added.
  prefs: []
  type: TYPE_NORMAL
- en: The table will also have a `name` column that will be of the `text` type and
    cannot be blank (`not null`).
  prefs: []
  type: TYPE_NORMAL
- en: It will also have a `score` column that will be of the `int` type. Also, notice
    that the statement is completed by a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting data into the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is how we might insert a new row of data into that database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The previous code added a row to the database. After the preceding statement,
    the database will have one entry with the values (1, "Bart", 23) for the columns
    (_ID, name, and score).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we might insert another new row of data into that database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The previous code added a new row of data with the values (2, "Lisa", 100) for
    the columns (_ID, name, and score).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our spreadsheet-like structure would now look like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inserting data into the database](img/B12806_27_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Retrieving data from the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is how we would access all the rows and columns from our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The previous code asks for every row and column. The `*` symbol can be read
    as **all**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also be a little more selective, as the following code demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The previous code would only return `100`, which, of course, is the score associated
    with the name Lisa.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the database structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can even add new columns after the table has been created and the data added.
    This is simple as far as the SQL is concerned, but can cause some issues with
    regard to a user''s data on already-published apps. The next statement adds a
    new column called `age` that is of the `int` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There are many more data types, keywords, and ways to use them than we have
    seen so far. Next, let's look at the Android SQLite API, and we will begin to
    see how we can use our new SQLite skills.
  prefs: []
  type: TYPE_NORMAL
- en: The Android SQLite API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of different ways in which the Android API makes it fairly
    easy to use our app's database. The first class we need to get familiar with is
    `SQLiteOpenHelper`.
  prefs: []
  type: TYPE_NORMAL
- en: SQLiteOpenHelper and SQLiteDatabase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SQLiteDatabase` class is the class that represents the actual database.
    The `SQLiteOpenHelper` class, however, is where most of the action takes place.
    This class will enable us to get access to a database and initialize an instance
    of `SQLiteDatabase`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the `SQLiteOpenHelper` class, which we will inherit from in our
    *Age database* app, has two functions to override. First, it has an `onCreate`
    function, which is called the first time a database is used, and it therefore
    makes sense that we would incorporate our SQL in which to create our table structure.
  prefs: []
  type: TYPE_NORMAL
- en: The other function we must override is `onUpgrade`, which, you can probably
    guess, is called when we upgrade our database (`ALTER` its structure).
  prefs: []
  type: TYPE_NORMAL
- en: Building and executing queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As our database structures become more complex and as our SQL knowledge grows,
    our SQL statements will get quite long and awkward. The potential for syntax errors
    or typos is high.
  prefs: []
  type: TYPE_NORMAL
- en: The way we will help overcome the problem of this complexity is to build our
    queries from parts into a `String`. We can then pass that `String` to the function
    (we will see this soon) that will execute the query for us.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we will use `String` instances to represent things such as table
    and column names, so we can't get in a muddle with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could declare the following `String` instances in a `companion`
    object, which would represent the table name and column names from the fictitious
    example from earlier. Note that we will also give the database itself a name and
    have a `String` for that too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We could then build a query like this in the next example. The following example
    adds a new entry to our hypothetical database and incorporates Kotlin variables
    into the SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that in the previous code, the regular Kotlin variables, `name` and
    `score`, arehighlighted. The previous `String` called `query` is now the SQL statement,
    exactly equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is not essential to completely grasp the previous two blocks of code in order
    to proceed with learning Android programming. But, if you want to build your own
    apps and construct SQL statements that do exactly what you need, it *will* help
    to do so. Why not study the previous two blocks of code in order to discern the
    difference between the parts of the `String` joined together with the pairs of
    single quote marks, `'`, that are part of the SQL syntax?
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the typing of the query, Android Studio prompts us as to the names
    of our variables, making the chances of an error much less likely, even though
    it is more verbose than simply typing the query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use the classes we introduced previously to execute the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When adding data to the database, we will use `execSQL`, as in the previous
    code, and when getting data from the database, we will use the `rawQuery` function,
    demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `rawQuery` function returns an object of `Cursor` type.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several different ways in which we can interact with SQLite, and they
    each have their advantages and disadvantages. We have chosen to use raw SQL statements
    as it is entirely transparent as to what we are doing, at the same time as reinforcing
    our knowledge of the SQL language.
  prefs: []
  type: TYPE_NORMAL
- en: Database cursors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the classes that give us access to the database, and the functions
    that allow us to execute our queries, there is the issue of exactly how the results
    we get back from our queries are formatted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there is the `Cursor` class. All our database queries will return
    objects of the `Cursor` type. We can use the functions of the `Cursor` class to
    selectively access the data returned from the queries, as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The previous code would output to the logcat window the two values stored in
    the first two columns of the result that the query returned. It is the `Cursor`
    object itself that determines which row of our returned data we are currently
    reading.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access various functions of the `Cursor` object, including the `moveToNext`
    function, which, unsurprisingly, would move the `Cursor` to the next row ready
    for reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: On certain occasions, we will be able to bind a `Cursor` to a part of our UI
    (such as `RecyclerView`), as we did with an `ArrayList` in the *Note to self*
    app, and just leave everything to the Android API.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more useful functions in the `Cursor` class, some of which we
    will see soon.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This introduction to the Android SQLite API really only scratches the surface
    of its capabilities. We will bump into a few more functions and classes as we
    proceed further. It is, however, worth studying further if your app idea requires
    complex data management.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can see how all this theory comes together and how we will structure
    our database code in the Age Database app.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the database class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will put into practice everything we have learned so far and finish
    coding the Age database app. Before our `Fragment` classes from the previous section
    can interact with a shared database, we need a class to handle interaction with,
    and creation of, the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a class that manages our database by implementing `SQLiteOpenHelper`.
    It will also define some `String` variables in a `companion object` to represent
    the names of the table and its columns. Furthermore, it will supply a bunch of
    helper functions we can call to perform all the necessary queries. Where necessary,
    these helper functions will return a `Cursor` object that we can use to show the
    data we have retrieved. It would be trivial then to add new helper functions should
    our app need to evolve:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `DataManager` and add the companion object, the constructor,
    and the `init` block:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We discussed the `companion object` in [Chapter 25](ch25.html "Chapter 25. Advanced
    UI with Paging and Swiping"), *Advanced UI with Paging and Swiping*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I named the database and the table as it could evolve to be an address book
    app that also keeps track of ages and perhaps birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: The previous code gives us all our handy `String` instances for building our
    queries, and it also declares and initializes our database and helper class.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can add the helper functions we will access from our `Fragment` classes;
    first, the `insert` function, which executes an `INSERT` SQL query based on the
    `name` and `age` parameters passed into the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `insert` function to the `DataManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This next function, called `delete`, will delete a record from the database
    if it has a matching value in the `name` column to that of the passed-in `name`
    parameter. It achieves this using the SQL `DELETE` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `delete` function to the `DataManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Next, we have the `selectAll` function, which also does as the name suggests.
    It achieves this with a `SELECT` query using the `*` parameter, which is equivalent
    to specifying all the columns individually. Also, note that the function returns
    a `Cursor`, which we will use in some of the `Fragment` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `selectAll` function to the `DataManager` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we add a `searchName` function, which has a `String` parameter for the
    name the user wants to search for. It also returns a `Cursor` object, which will
    contain all the entries that were found. Notice that the SQL statement uses `SELECT`,
    `FROM`, and `WHERE` to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Finally, for the `DataManager` class, we create an `inner` class that will be
    our implementation of `SQLiteOpenHelper`. It is a barebones implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We have a constructor that receives a `Context` object, the database name, and
    the database version.
  prefs: []
  type: TYPE_NORMAL
- en: We also override the `onCreate` function, which has the SQL statement that creates
    our database table with `_ID`, `name`, and `age` columns.
  prefs: []
  type: TYPE_NORMAL
- en: The `onUpgrade` function is left intentionally blank for this app, but still
    needs to be present because it is part of the contract when we inherit from `SQLiteOpenHelper`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the inner `CustomSQLiteOpenHelper` class to the `DataManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can add code to our `Fragment` classes to use our new `DataManager`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Fragment classes to use the DataManager class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add this highlighted code to the `InsertFragment` class to update the `onCreateView`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the code, we get an instance of our `DataManager` class and a reference to
    each of our UI widgets. Then, in the `onClick` function of the button, we use
    the `insert` function to add a new name and age to the database. The values to
    insert are taken from the two `EditText` widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this highlighted code to the `DeleteFragment` class to update the `onCreateView`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the `DeleteFragment` class, we create an instance of our `DataManager` class,
    and then get a reference to the `EditText` and the `Button` from our layout. When
    the button is clicked, the `delete` function is called, passing in the value of
    any text from the `EditText`. The delete function searches our database for a
    match and, if one is found, it deletes it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this highlighted code to the `SearchFragment` class to update the `onCreateView`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we do for all our different `Fragment` classes, we create an instance of
    `DataManager` and get a reference to all the different UI widgets in the layout.
    In the `onClick` function of the button, the `searchName` function is used, passing
    in the value from the `EditText`. If the database returns a result in the `Cursor`,
    then the `TextView` uses its `text` property to output the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this highlighted code to the `ResultsFragment` class to update the `onCreateView`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this class, the `Cursor` object is loaded up with data using the `selectAll`
    function before any interactions take place. The contents of the `Cursor` are
    then output into the `TextView` by concatenating the results. The `\n` in the
    concatenation is what creates a new line between each result in the `Cursor`.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Age Database app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s run through some of the functions of our app to make sure it is working
    as expected. First, I added a new name to the database using the **Insert** menu
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the Age Database app](img/B12806_27_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And then, I confirmed it was there by viewing the **Results** option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the Age Database app](img/B12806_27_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, I used the **Delete** menu option and looked at the **Results** option
    again to check that my chosen name was, in fact, removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the Age Database app](img/B12806_27_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, I searched for a name that I knew existed to test the **Search** function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the Age Database app](img/B12806_27_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's review what we have done in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a lot in this chapter. We have learned about databases and,
    in particular, the database of Android apps, SQLite. We have practiced the basics
    of communicating with and querying a database using the SQL language.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how the Android API helps us use an SQLite database, and have implemented
    our first working app with a database.
  prefs: []
  type: TYPE_NORMAL
- en: That is just about it, but please look at the brief final chapter that follows.
  prefs: []
  type: TYPE_NORMAL
