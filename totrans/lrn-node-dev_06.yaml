- en: Callbacks in Asynchronous Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is the second part of our asynchronous programming in Node.js.
    In this chapter, we'll look at callbacks, HTTP requests, and more. We're going
    to handle a lot of the errors that happen inside callbacks. There's a lot of ways
    our request in `app.js` can go wrong, and we'll want to figure out how to recover
    from errors inside of our callback functions when we're doing asynchronous programming.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll be moving our request code block into a separate file and abstracting
    a lot of details. We'll talk about what that means and why it's important for
    us. We'll be using Google's Geolocation API, and we'll be using the Dark Sky API
    to take location information like a zip code and turn that into real-world current
    weather information.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we'll start wiring up that forecast API, fetching real-time weather data
    for the address that's geocoded. We'll add our request inside of the callback
    for `geocodeAddress`. This will let us take that dynamic set of latitude and longitude
    coordinates, the `lat`/`lng` for the address used in the arguments list, and fetch
    the weather for that location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we''ll look into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Encoding user input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callback errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstracting callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wiring up weather search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining callbacks together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll learn how to set up yargs for the weather app. You'll
    also learn how to include user input, which is very important for our application.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the previous chapter, *HTTPS request* section, the user will not
    type their encoded address into the Terminal; instead they will be typing in a
    plain text address like `1301 Lombard Street`.
  prefs: []
  type: TYPE_NORMAL
- en: Now this will not work for our URL, we need to encode those special characters,
    like the space, replacing them with `%20`. Now `%20` is the special character
    for the space, other special characters have different encoding values. We'll
    learn how to encode and decode strings, so we can set up our URL to be dynamic.
    It's going to be based off of the address provided in the Terminal. That's all
    we're going to discuss in this section. By the end of the section, you'll be able
    to type in any address you like, and you'll see the formatted address, the latitude,
    and the longitude.
  prefs: []
  type: TYPE_NORMAL
- en: Installing yargs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can get started doing any encoding, we have to get the address from
    the user, and before we can set up yargs we have to install it. In the Terminal,
    we''ll run the `npm install` command, the module name is `yargs`, and we''ll look
    for version 10.1.1, which is the latest version at the time of writing. We''ll
    use the `save` flag to run this installation, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/156cf3a2-81f0-4235-ad5d-681739b3e2bd.png)'
  prefs: []
  type: TYPE_IMG
- en: Now the `save` flag is great because as you remember. It updates the `package.json`
    file and that's exactly what we want. This means that we can get rid of the node
    modules folder which takes up a ton of space, but we can always regenerate it
    using `npm install`.
  prefs: []
  type: TYPE_NORMAL
- en: If you run `npm install` without anything else, no other module names or flags.
    It will dig through that `package.json` file looking for all the modules to install,
    and it will install them, recreating your node modules folder exactly as you left
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the installation is going on, we do a bit of configuration in the `app.js`
    file. So we can get started by first loading in yargs. For this, in the `app.js`
    file, next to request constant, I''ll make a constant called `yargs`, setting
    it equal to `require(yargs)` just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can go ahead and actually do that configuration. Next we''ll make another
    constant called `argv`. This will be the object that stores the final parsed output.
    That will take the input from the process variable, pass it through `yargs`, and
    the result will be right here in the `argv` constant. This will get set equal
    to `yargs`, and we can start adding some calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now when we created the notes app we had various commands, you could add a note
    and that required some arguments, list a note which required just the title, list
    all notes which didn't require any arguments, and we specified all of that inside
    of `yargs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the weather app the configuration will be a lot simpler. There is no command,
    the only command would be get weather, but if we only have one why even make someone
    type it. In our case, when a user wants to fetch the weather all they will do
    is type `node app.js` followed by the `address` flag just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then they can type their address inside of quotes. In my case it could be something
    like `1301 lombard street`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly how the command will get executed. There's no need for an actual
    command like fetch weather, we go right from the file name right into our arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring yargs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To configure yargs, things will look a little different but still pretty similar.
    In the Atom, I''ll get started by calling `.options`, which will let us configure
    some top level options. In our case, we''ll pass in an object where we configure
    all of the options we need. Now I''ll format this like I do for all of my chained
    calls, where I move the call to the next line and I indent it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can set up our options and in this case we just have one, it will be
    that `a` option; `a` will be short for address. I could either type address in
    the options and I could put `a` in the alias, or I could put `a` in the options
    and type address in the alias. In this case I''ll put a as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, I can go ahead and provide that empty object, and we''ll go through
    these same exact options we used inside of the notes app. We will demand it. If
    you''ll fetch the weather we need an address to fetch the weather for, so I''ll
    set `demand` equal to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we can set an `alias`, I''ll set `alias` equal to `address`. Then
    finally we''ll set `describe`, we can set `describe` to anything we think would
    be useful, in this case I''ll go with `Address to fetch weather for`, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now these are the three options we provided for the notes app, but I''ll add
    a fourth one to make our yargs configuration for the weather app even more full
    proof. This will be an option called `string`. Now `string` takes a Boolean either
    `true` or `false`. In our case we want `true` to be the value. This tells `yargs`
    to always parse the `a` or `address` argument as a string, as opposed to something
    else like a number or a Boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the Terminal, if I were to delete the actual string `address`, `yargs` would
    still accept this, it would just think I'm trying to add a Boolean flag, which
    could be useful in some situations. For example, do I want to fetch in Celsius
    or in Fahrenheit? But in our case, we don't need any sort of `true` or `false`
    flag, we need some data, so we'll set string to true to make sure we get that
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our options configuration in place, we can go ahead and add
    a couple other calls that we''ve explored. I''ll add `.help`, calling it as shown
    in the following code, which adds the `help` flag. This is really useful especially
    when someone is first using a command. Then we can access `.argv`, which takes
    all of this configuration, runs it through our arguments, and restores the result
    in the `argv` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `help` method adds that `help` argument, we can also add an alias for
    it right afterwards by calling `.alias`. Now `.alias` takes two arguments, the
    actual argument that you want to set an alias for and the alias. In our case,
    we already have `help` registered, it gets registered when we call `help`, and
    we''ll set an alias which will just be the letter `h`, awesome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have all sorts of really great configurations set up for the weather
    app. For example, inside the Terminal I can now run `help`, and I can see all
    of the help information for this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd9c75d0-680d-48a5-90ec-e92f63354ea7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I could also use the shortcut `-h`, and I get the exact same data back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e32d8d46-d22c-4e84-89df-1a2653e8ad44.png)'
  prefs: []
  type: TYPE_IMG
- en: Printing the address to screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now the address is also getting passed through but we don''t print it to the
    screen, so let''s do that. Right after the configuration, let''s use `console.log`
    to print the entire `argv` variable to the screen. This will include everything
    that got parsed by `yargs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go ahead and rerun it in the Terminal, this time passing in an address.
    I''ll use the `a` flag, and specifying something like `1301 lombard street`, closing
    the quotes, and hitting *enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When we do this we get our object, and as shown in the code output, we have
    1301 Lombard St, Philadelphia, PA 19147, USA, the plain text address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1dde3911-17c4-4789-8bd6-b79856e7ee36.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, notice that we happen to fetch the latitude and
    longitude for that address, but that's just because we have it hard coded in the
    URL in `app.js`. We still need to make some changes in order to get the address,
    the one that got typed inside the argument, to be the address that shows up in
    the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding and decoding the strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To explore how to encode and decode strings we''ll head into the Terminal.
    Inside the Terminal, first we''ll clear the screen using the `clear` command,
    and then we boot up a node process by typing the `node` command as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here we can run any statements we like. When we're exploring a really basic
    node or JavaScript feature, we'll look into some examples first, and then we go
    ahead and add it into our actual application. We'll look at two functions, `encodeURIComponent`
    and `decodeURIComponent`. We'll get started with encoding first.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding URI component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Encoding, the method is called `encodeURIComponent`, encode URI in uppercase
    component, and it takes just one argument, the string you want to encode. In our
    case, that string will be the address, something like `1301 lombard street philadelphia`.
    When we run this address through `encodeURIComponent` by hitting *enter*, we get
    the encoded version back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the following code output, we can see all the spaces, like the space
    between 1301 and lombard, have been replaced with their encoded character, and
    for the case of the space it is %20\. By passing our string through `encodeURIComponent`,
    we'll create something that's ready to get injected right into the URL so we can
    fire off that dynamic request.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ac17918-e2f3-4184-a815-3a8a08346cf0.png)'
  prefs: []
  type: TYPE_IMG
- en: Decoding URI component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now the alternative to `encodeURIComponent` is. This will take an encoded string
    like the one in the previous example, and take all the special characters, like
    `%20`, and convert them back into their original values, in this case space. For
    this, inside of `decodeURIComponent` once again we'll pass a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and type our first and last name. In my case it''s `Andrew`,
    and instead of a space between them I''ll add `%20`, which we know is the encoded
    character for a space. Since we''re trying to decode something, it''s important
    to have some encoded characters here. Once yours looks like the following code
    with your first and last name, you can go ahead and hit *enter*, and what we get
    back is the decoded version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following code output, I have Andrew Mead with the `%20` being
    replaced by the space, exactly what we expected. This is how we can encode and
    decode URI components in our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51ce6a42-36f4-41c9-b256-f15defda1d8f.png)'
  prefs: []
  type: TYPE_IMG
- en: Pulling the address out of argv
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now what we want to do is pull the address out of `argv`, we already saw that
    it''s there, we want to encode it and we want to inject it in our URL in `app.js`
    file, replacing the address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96f8070c-683c-408c-b92c-10a215cc04a7.png)'
  prefs: []
  type: TYPE_IMG
- en: This will essentially create that dynamic request we've been talking about.
    We'll be able to type in any address we want, whether it's an address or a zip
    code or a city state combination, and we'll be able to fetch the formatted address,
    the latitude, and the longitude.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get started, the first thing I'll do is get the encoded address.
    Let's make a variable called `encodedAddress` in the `app.js` next to the `argv`
    variable, where we can store that result. We'll set this equal to the return value
    from the method we just explored in the Terminal, `encodeURIComponent`. This will
    take the plain text address and return the encoded result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we do need to pass in the string, and we have that available on `argv.address`
    which is the alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here we could use `argv.a` as well as `argv.address`, both will work the same.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have that encoded result all that's left to do is inject it inside of
    the URL string. In the `app.js`, currently we're using a regular string. We'll
    swap this out for a template string so I can inject a variable inside of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a template string, we can highlight the static address which
    ends at `philadelphia` and goes up to the `=` sign, and remove it, and instead
    of typing in a static address we can inject the dynamic variable. Inside of my
    curly braces, `encodedAddress`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With this in place we are now done. We get the address from the Terminal, we
    encode it, and we use that inside of a `geocode` call. So the formatted address,
    latitude, and longitude should match up. Inside the Terminal, we'll shut down
    node by using *control* + *C* twice and use clear to clear the Terminal output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can go ahead and run our app using `node app.js`, passing in either
    the `a` or `address` flag. In this case, we''ll just use `a`. Then we can go ahead
    and type in an address, for example, `1614 south broad street philadelphia` as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When you run it you should have that small delay while we fetch the data from
    the geocode URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case we''ll find that it''s actually taking a little longer than we
    would expect, about three or four seconds, but we do get the address back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f86d2f0-ed20-4a97-a21c-1e9fae8c8d83.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here we have the formatted address with a proper zip code state and country,
    and we also have the latitude and longitude showing up. We''ll try a few other
    examples. For example for a town in Pennsylvania called Chalfont, we can type
    in `chalfont pa` which is not a complete address, but the Google Geocode API will
    convert it into the closest thing, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0c920a5-202c-4ddd-8786-456e04217af5.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that it's essentially the address of the town, Chalfont, PA 18914
    is the zip, with the state USA. Next, we have the general latitude and longitude
    data for that town, and this will be fine for fetching weather data. The weather
    isn't exactly changing when you move a few blocks over.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our data coming in dynamically, we are able to move on to the
    next section where we'll handle a lot of the errors that happen inside of callbacks.
    There are a lot of ways this request can go wrong, and we'll want to figure out
    how to recover from errors inside of our callback functions when we're doing asynchronous
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Callback errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section we''ll learn how to handle errors inside of your callback functions,
    because as you might guess things don''t always go as planned. For example, the
    current version of our app has a few really big flaws, if I try to fetch weather
    using `node app.js` with the `a` flag for a zip that doesn''t exist, like `000000`,
    the program crashes, which is a really big problem. It''s going off. It''s fetching
    the data, eventually that data will come back and we get an error, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e68227c6-de88-4db7-9b5f-7e0af311d56a.png)'
  prefs: []
  type: TYPE_IMG
- en: It's trying to fetch properties that don't exist, such as `body.results[0].formatted_address`
    is not a real property, and this is a big problem.
  prefs: []
  type: TYPE_NORMAL
- en: Our current callback expects everything went as planned. It doesn't care about
    the error object, doesn't look at response codes; it just starts printing the
    data that it wants. This is the happy path, but in real world node apps we have
    to handle errors as well otherwise the applications will become really useless,
    and a user can get super frustrated when things don't seem to be working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do this, we'll add a set of `if`/`else` statements inside of the
    callback. This will let us check certain properties to determine whether or not
    this call, the one to our URL in the `app.js`, should be considered a success
    or a failure. For example, if the response code is a 404, we might want to consider
    that a failure and we'll want to do something other than trying to print the address,
    latitude and longitude. If everything went well though, this is a perfectly reasonable
    thing to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of errors that we''ll worry about in this section. That
    will be:'
  prefs: []
  type: TYPE_NORMAL
- en: The machine errors, things like being unable to connect to a network, these
    are usually will show up in the error object, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The errors coming from the other server, the Google server, this could be something
    like an invalid address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to get started, let's take a look at what can happen when we pass a
    bad data to the Google API.
  prefs: []
  type: TYPE_NORMAL
- en: Checking error in Google API request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To view what actually comes back in a call like the previous example, where
    we have an invalid address, we''ll head over to the browser and pull up the URL
    we used in the `app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c6cf191-835b-435f-99bd-823a33746850.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will remove the address we used earlier from the browser history, and type
    in `000000`, hit *enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc168f1e-1ff6-46aa-b1a9-b929a40c5166.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We get our results arrive but those are no results, and we have the status,
    the status says `ZERO_RESULTS`, and this is the kind of information that''s really
    important to track down. We can use the status text value to determine whether
    or not the request was successful. If we pass in a real zip code like `19147`,
    which is `Philadelphia`, we''ll get our results back, and as shown in the following
    image, the `status` will get set equal to `OK`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48300c3e-0bab-46fe-843a-2a2fddbdd26e.png)'
  prefs: []
  type: TYPE_IMG
- en: We can use this status to determine that things went well. Between these status
    property and the error object, which we have inside of our app, we can determine
    what exactly to do inside of the callback.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the if statement for callback errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we''ll do is add an `if` statement as shown below, checking
    if the error object exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This will run the code inside of our code block if the error object exists,
    if it doesn't fine, we'll move on into the next `else if` statement, if there
    is any.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is an error, all we''ll do is add a `console.log` and a message to
    the screen, something like `Unable to connect to Google servers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will let the user know that we were unable to connect to the user servers,
    not that something went wrong with their data, like the address was invalid. This
    is what be inside of the error object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the next thing that we''ll do is add an `else if` statement, and inside
    of the condition we''ll check the status property. If the status property is `ZERO_RESULTS`,
    which it was for the zip code `000000`, we want to do something other than trying
    to print the address. Inside of our conditional in Atom, we can check that using
    the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If that''s the case, we''ll print a different message, other than `Unable to
    connect Google servers`, for this one we can use `console.log` to print `Unable
    to find that address.`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This lets the user know that it wasn't a problem with the connection, we were
    just unable to find the address they provided, and they should try with something
    else.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have error handling for those system errors, like being unable to connect
    to the Google servers, and for errors with the input, in this case we're unable
    to find a location for that address, and this is fantastic, we have both of our
    errors handled.
  prefs: []
  type: TYPE_NORMAL
- en: Now the `body.status` property that shows up in the `else if` statement, is
    not going to be on every API, this is specific to the Google Geocode API. When
    you explore a new API it's important to try out all sorts of data, good data like
    a real address and bad data like an invalid zip code, to see exactly what properties
    you can use to determine whether or not the request was successful, or if it failed.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, if the status is `ZERO_RESULTS`, we know the request failed and
    we can act accordingly. Inside of our `app`, now we'll add our last `else if`
    clause, if things went well.
  prefs: []
  type: TYPE_NORMAL
- en: Adding if else statement to check body status property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we want to add the `else if` clause checking if the `body.status` property
    equals `OK`. If it does, we can go ahead and run these three lines inside of the
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If it doesn't, these lines shouldn't run because the code block will not execute.
    Then we'll test things out inside of the Terminal, try to fetch the address of
    `00000`, and make sure that instead of the program crashing we get our error message
    printing to the screen. Then we go ahead and mess up the URL in the app by removing
    some of the important characters, and make sure this time we get the `Unable to
    connect to the Google servers.` message. And last we'll see what happens when
    we enter a valid address, and make sure our three `console.log` statements still
    execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started we''ll add that `else if` statement, and inside of the condition
    we''ll check if `body.status` is `OK`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If it is `OK`, then we''ll simply take the three `console.log` lines (shown
    in the previous code block) and move them in the `else if` condition. If it is
    `OK`, we''ll run these three `console.log` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a request that handles errors really well. If anything goes wrong
    we have a special message for it, and if things go right we print exactly what
    the user expects, the address, the latitude, and the longitude. Next we'll test
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the body status property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test this inside of the Terminal, we''ll start by rerunning the command
    with an address that''s invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/88293218-c888-4e6d-91ff-6b275377596d.png)'
  prefs: []
  type: TYPE_IMG
- en: When we run this command, we see that Unable to find address. prints to the
    screen. Instead of the program crashing, printing a bunch of errors, we simply
    have a little message printing to the screen. This is because the code we have
    in second `else if` statement, that tried to access those properties that didn't
    exist, no longer runs because our first `else if` condition gets caught and we
    simply print the message to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we also want to test that the first message (`Unable to connect to the
    Google servers.`) prints when it should. For this, we''ll delete some part of
    the URl in our code, let''s say, `s` and `.`, and save the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll rerun the previous command in the Terminal. This time around we
    can see `Unable to connect to Google servers.` prints to the screen just like
    it should:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3677a152-c7e8-40c0-8a6b-98c6ed8e2ce1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can test it the final thing, by first readjusting the URL to make it
    correct, and then fetching a valid address from the Terminal. For example, we
    can use the `node app.js`, setting `address` equal to `08822`, which is a zip
    code in New Jersey:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this command, we do indeed get our formatted address for Flemington,
    NJ, with a zip code and the state, and we have our latitude and longitude as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/020794e0-eb20-429a-a2f9-b256419ccd3d.png)'
  prefs: []
  type: TYPE_IMG
- en: We now have a complete error handling model. When we make a request to Google
    providing a address that has problems, in this case there's `ZERO_RESULTS`, the
    error object will get populated, because it's not technically an error in terms
    of what request thinks an error is, it's actually in the response object, which
    is why we have to use `body.status` in order to check the error.
  prefs: []
  type: TYPE_NORMAL
- en: That is it for this section, we now have error handling in place, we handle
    system errors, Google server errors, and we have our success case.
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll be refactoring `app.js`, taking a lot of the complex
    logic related to geocoding and moving it into a separate file. Currently, all
    of the logic for making the request and determining whether or not the request
    succeeded, our `if else` statements, live inside of `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is not exactly reusable and it really doesn't belong here. What I'd like
    to do before we add even more logic related to fetching the forecast, that's the
    topic of the next section, is break this out into its own function. This function
    will live in a separate file, like we did for the notes application.
  prefs: []
  type: TYPE_NORMAL
- en: In the `notes app` we had a separate file that had functions for adding, listing,
    and removing notes from our local adjacent file. We'll be creating a separate
    function responsible for geocoding a given address. Although the logic will stay
    the same, there really is no way around it, it will be abstracted out of the `app.js`
    file and into its own location.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring app.js and code into geocode.js file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First up, we will need to create a new directory and a new file then we'll add
    a few more advanced features to the function. But before that, we'll see what
    the require statement will look like.
  prefs: []
  type: TYPE_NORMAL
- en: Working on request statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll load in via a constant variable called `geocode` the module, and we''ll
    set it equal to `require`, since we''re requiring a local file we''ll add that
    relative path, `./geocode/geocode.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: That means you need to make a directory called `geocode` in the `weather-app`
    folder, and a file called `geocode.js`. Since we have a `.js` extension, we can
    actually leave it off of our require call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `app.js` file, next to `.argv` object, we need to call `geocode.geocodeAddress`.
    The `geocodeAddress` function, that will be the function responsible for all the
    logic we currently have in `app.js`. The `geocodeAddress` function will take the
    address, `argv.address`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It will be responsible for doing everything, encoding the URL, making the request,
    and handling all of the error cases. This means, in that new file we need to export
    the `geocodeAddress` function, just like we exported functions from the `notes
    application` file. Next, we have all of the logic here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This logic needs to get moved inside of the `geocodeAddress` function. Now we
    can copy and paste the preceding shown code directly, there really is no way around
    some of the more complex logic, but we will need to make a few changes. We'll
    need to load requests into that new file, since we use it and it isn't going to
    be required in that file by default. Then we can go ahead and clean up the request
    require call in the code, since we won't be using it in this file.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, the `argv` object is not going to exist, we'll get that passed in via
    the first argument, just like the `argv.address` in the `geocode.Address` statement.
    This means we'll need to swap this out for whatever we call that first argument
    for example, address. Once this is done, the program should work exactly as it
    works without any changes in `app.js`, there should be no change in functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Creating geocode file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, let''s make a brand new directory in the `weather-app` folder,
    that''s the first thing we need to do. The directory is called `geocode`, which
    aligns with the require statement we have in the `geocode` variable. In `geocode`
    folder, we''ll make our file `geocode.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e0d6ccb-5aa4-4944-8978-897aac4e8cdd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now inside of `geocode.js`, we can get started by loading in request, let''s
    make a constant called `request`, and we''ll set it equal to `require(''request'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can go ahead and define the function responsible for geocoding, this
    one will be called `geocodeAddress`. We''ll make a variable called `geocodeAddress`,
    setting it equal to an arrow function, and this arrow function will get an `address`
    argument past in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the plain text unencoded address. Now before we copy the code from
    `app.js` into this function body, we want to export our `geocodeAddress` function
    using `module.exports`, which we know as an object. Anything we put on `module.exports`
    object will be available to any files that require this file. In our case, we
    want to make a `geocodeAddress` property available, setting it equal to the `geocodeAddress`
    function that we defined in the preceding statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to actually copy all of the code from `app.js` in to `geocode.js`.
    We''ll cut the request function code, move in to `geocode.js`, and paste it inside
    of the body of our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing we need to change inside of this code, is how we get the plaintext
    address. We no longer have that `argv` object, instead we get `address` passed
    in as an argument. The final code will look like the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we''re now done with the `geocode` file. It contains all
    of the complex logic for making and finishing the request. Over at `app.js`, we
    can clean things up by removing some extra spaces, and removing the request module
    which is no longer used in this file. The final `app.js` file will look like the
    following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now at this point the functionality should be exactly the same. Inside of the
    Terminal, I''ll go ahead and run a few to confirm the changes worked. We''ll use
    the `a` flag to search for a zip code that does exist, something like `19147`,
    and as shown, we can see the address, the latitude, and the longitude:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48c16ab9-b3db-41f7-8b33-1a568c4614ff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we''ll swap out that zip code to one that does not exist, like `000000`,
    when we run this through the geocoder, you can see Unable to find address prints
    to screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88013ae2-3b27-4d13-807b-197612ebf260.png)'
  prefs: []
  type: TYPE_IMG
- en: It means all of the logic inside of `geocode.js` is still working. Now the next
    step in the process is the process of adding a callback function to `geocodeAddress`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding callback function to geocodeAddress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of refactoring the code and `app.js` was not to get rid of the callback,
    the goal was to abstract all the complex logic related to encoding the data, making
    that request, and checking for errors. `app.js` should not care about any of that,
    it doesn't even need to know that an HTTP request was ever made. All the `app.js`
    should care about is passing an address to the function, and doing something with
    the result. The result being either an error message or the data, the formatted
    address, the latitude, and the longitude.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the function in geocodeAddress function in app.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we go ahead and make any changes in `geocode.js`, we want to take a
    look at how we''ll structure things inside of `app.js`. We''ll pass an arrow function
    to `geocodeAddress`, and this will get called after the request comes back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the parentheses, we''ll expect two arguments, `errorMessage`, which will
    be a string, and `results`, which will contain the address, the latitude, and
    the longitude:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Out of these two only one will be available at a time. If we have an error
    message we''ll not have results, and if we have results we''ll not have an error
    message. This will make the logic in the arrow function, of determining whether
    or not the call succeeded, much simpler. We''ll be able to use an `if` statement,
    `if (errorMessage)`, and if there is an error message, we can simply print it
    to the screen using `console.log` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There's no need to dig into any sort of object and figure out exactly what's
    going on, all of that logic is abstracted in `geocode.js`. Now if there is no
    error message inside of the `else` clause, we can go ahead and print the results.
    We'll use that pretty print method we talked about in the previous chapter, we'll
    add the `console.log(JSON.stringify)` statement, and we'll pretty print the results
    object which will be an object containing an address property, a latitude property,
    and a longitude property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we''ll pass the `undefined` argument as our second argument. This skips
    over the filtering function which we don''t need, and then we can specify the
    spacing, which will format this in a really nice way, we''ll use two spaces as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our function set up inside of `geocodeAddress` function in
    `app.js`, and we have a good idea about how it will look, we can go ahead and
    implement it inside of `geocode.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the callback function in geocode.js file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our arguments definition, instead of just expecting an address argument we'll
    also expect a callback argument, and we can call this callback argument whenever
    we like. We'll call it in three places. We'll call it once inside of the `if (error)`
    block, instead of calling `console.log` we'll simply call the callback with the
    `Unable to connect to Google servers.` string. This string will be the error message
    we defined in `geocodeAddress` function in `app.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, all we need to do is change our `console.log` call to
    a `callback` call. We''ll pass it as the first argument our error message. We
    can take the string exactly as it appeared in `console.log`, and move it into
    the arguments for `callback`. Then I can remove the `console.log` call and save
    the file. The resultant code will look like following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can do the exact same thing in the next `else if` block for our other
    `console.log` statement, when there is `zero results`, we''ll replace `console.log`
    with `callback`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the last `else if` block will be a little trickier. It''s a little trickier
    because we don''t exactly have our object. We also need to create an `undefined`
    variable for the first argument, since an error message will not be provided when
    things go well. All we have to do to create that undefined error message is call
    `callback`, passing an `undefined` variable as the first argument. Then we can
    go ahead and specify our object as the second argument, and this object, this
    will be exactly what''s in the `geocodeAddress` function, results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now as I mentioned the results have three properties: the first one will be
    formatted address, so let''s go ahead and knock that out first. We''ll set `address`
    equal to `body.results`, just like we have in the `Address` variable of `console.log`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here we're making things even easier, instead of having complex properties that
    are nested deep inside of an object inside of `app.js`, we'll be able to access
    a simple `address` property, and we'll do the same thing for `Latitude` and `Longitude`
    of `console.log` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll grab the code that let us fetch the latitude, and I''ll add my
    second property, `latitude`, setting it equal to the code we grab from the `console.log`
    statement. Then we can go ahead and add the last property, which will be `longitude`,
    setting that equal to the `latitude` code, replacing `lat` with `lng`. Now that
    we have this in place we can add a semicolon at the end, and remove the `console.log`
    statements since they''re no longer necessary, and with this we are done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We can now rerun the file, and when we do we'll pass an address to `geocodeAddress`,
    this will go off and make the request, and when the request comes back, we'll
    be able to handle that response in a really simple way.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the callback function in geocode.js file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inside of the Terminal, we'll go back to run two `node app.js` commands; the
    command where we used the zip code of `19147`, everything works as expected and
    a bad zip code `000000`, to show the error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following code output, we can see our results object with an
    address property, a latitude property, and a longitude property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26f6b5c3-9e0d-4608-92d3-55324d54be59.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In case of a bad zip code, we just want to make sure the error message still
    shows up, and it does, Unable to find that address. prints to the screen, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/463842fb-3761-4e42-8fd3-07f4a6c4fcfc.png)'
  prefs: []
  type: TYPE_IMG
- en: This is happening because of the `if` statement in the `geocodeAddress` function
    in `app.js`.
  prefs: []
  type: TYPE_NORMAL
- en: After abstracting all of that logic to the `geocode` file, the `app.js` file
    is now a lot simpler and a lot easier to maintain. We can also call `geocodeAddress`
    in multiple locations. If we want to reuse the code we don't have to copy and
    paste the code, which would not follow the **DRY** principle, which stands for
    **Don't Repeat Yourself**, instead we can do the DRY thing and simply call `geocodeAddress`
    like we have in the `app.js` file. With this in place we are now done fetching
    the `geocode` data.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up weather search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll make your very first request to the weather API, and
    we'll do this in a static way at first, meaning that it will not use the actual
    latitude and longitude for the address we passed in, we'll simply have a static
    URL. We'll make the request and we'll explore what data we get back in the body.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring working of API in the browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now before we can add anything to Atom, we want to go ahead and explore this
    API so we can see how it works in the browser. This will give us a better idea
    about what weather data we get back, when we pass a latitude and longitude to
    the API. To do this we'll head over to the browser, and we'll visit a couple of
    URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'First up let''s go to [forecast.io](http://forecast.io). It is a regular weather
    website, you type in your location and you get all the weather information you''d
    expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4025c4f9-7c8a-48a9-a0dc-021ddab3e9d3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding image, there''s warnings, there''s radar, there''s
    the current weather, and we also have the weekly forecast in the website as shown
    in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9857030-e147-4319-8064-8296d25ec765.png)'
  prefs: []
  type: TYPE_IMG
- en: This is similar to [weather.com](http://weather.com), but the one cool thing
    about [forecast.io](http://forecast.io) is that the API that powers this website,
    it's actually available to you as a developer. You can make a request to our URL,
    and you can fetch the exact same weather information.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is exactly what we''ll do when we can explore the API by going to the
    website [developer.forecast.io](http://developer.forecast.io). Here we can sign
    up for a free developer account, in order to get started making those weather
    requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31b0a5f4-3092-44ab-ab18-95728da0bdfd.png)'
  prefs: []
  type: TYPE_IMG
- en: The Dark Sky Forecast API gives you 1,000 free requests a day, and I do not
    see us going over that limit. After the 1,000 requests, each costs a one thousandth
    of a penny, so you get a thousand requests for every penny you spend. We'll never
    go over that limit so don't even worry about it. There is no credit card required
    to get started, you'll simply get cut off after you make a thousand requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started you''ll need to register for a free account, it''s really simple,
    we just need an email and a password. Once we''ve created an account and we can
    see the dashboard as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4539477b-cb00-44e1-8dea-4e2d44639191.png)'
  prefs: []
  type: TYPE_IMG
- en: The only piece of information we need from this page is our API key. The API
    key is like a password, it will be part of the URL we request and it will help
    [forecast.io](http://forecast.io) keep track of how many requests we make a day.
    Now I'll take this API key and paste it in the `app.js`, so we have it accessible
    later when we need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we''ll do is explore the documentation, the actual URL structure
    we need to provide in order to fetch the weather for a given latitude and longitude.
    We can get that by clicking the API Docs link button, which is present in the
    top-right side of The Dark Sky Forecast API page. This''ll lead us to following
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9c839c4-d900-43bf-969b-a333b244ede1.png)'
  prefs: []
  type: TYPE_IMG
- en: In the API Docs link, we have a Forecast Request URL. As shown in the preceding
    image, this URL is exactly what we need to make a request to in order to fetch
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the actual URL for code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we add this URL into our app and use the request library, we need to
    find the actual URL which we can use to make the request. For this, we''ll copy
    it and paste it into a new tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ac92c03-3509-4d37-8a59-d2bf52d31368.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we do need to swap out some of the URL information. For example, we have
    our API key that needs to get replaced, we also have latitude and longitude. Both
    of those need to get replaced with the real data. Let''s get started with that
    API key first since we already copy and pasted it inside of `app.js`. We''ll copy
    the API key, and replace the letters `[key]` with the actual value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2dc75c0a-083b-439a-affb-517e7d066bca.png)'
  prefs: []
  type: TYPE_IMG
- en: Next up, we can grab a set of longitude and latitude coordinates. For this,
    go inside the Terminal and run our app, `node app.js`, and for the address we
    can use any zip let's say, `19146` to fetch the latitude and longitude coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we''ll copy these and place into the URL where they belong. The latitude
    goes between the forward slash and the comma, and the longitude will go after
    the comma, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a36c1af-c2fb-47f5-948e-957334f560ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have a real URL with all of those three pieces of info swapped out
    for actual info, we can make the request, and what we''ll get back is the forecast
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/106731ba-7d2f-4a16-b3f6-24a99cff2dd6.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember, this way the information is showing in the preceding image is due
    to JSONView, I highly recommend installing it.
  prefs: []
  type: TYPE_NORMAL
- en: Now the data we get back, it is overwhelming. We have a forecast by the minute,
    we have forecasts by the hour, by the week, by the day, all sorts of information,
    it's really useful but it's also super overwhelming. In this chapter, we'll be
    using the first object that is `currently`. This stores all of the current weather
    information, things like the current summary which is clear, the temperature,
    the precipitation probability, the humidity, a lot of really useful information
    is sitting in it.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, what we really care about is the temperature. The current temperature
    in Philadelphia is shown `84.95` degrees. This is the kind of information we want
    to use inside of our application, when someone searches for the weather in a given
    location.
  prefs: []
  type: TYPE_NORMAL
- en: Making a request for the weather app using the static URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now in order to play around with the weather API, we'll take the exact same
    URL we have defined in the previous section, and we'll make a request in `app.js`.
    First, we want to do a little setup work.
  prefs: []
  type: TYPE_NORMAL
- en: Inside of `app.js`, we'll comment out everything we have so far, and next to
    our API key we'll make a call to request, requesting this exact URL, just like
    we did for the geocode API in the previous section/chapter, before we made it
    dynamic. Then we'll print out the `body.currently.temperature` property to the
    screen, so when we run the app we'll see the current temperature for whatever
    latitude and longitude we used. In our case it's a static latitude and longitude
    representing Philadelphia.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get started we''ll load in request. Now we had it in the `app.js`
    file before and then we removed it in the previous section, but we''ll add it
    back once again. We''ll add it next to the commented out code, by creating a constant
    called `request`, and loading it in, `const request` equals to `require(''request'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can go ahead and make the actual request, just like we did for the geocode
    API by calling `request`, it''s a function just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to pass in our two arguments, the options object is the first one,
    and the second one is the arrow function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This is our callback function that gets fired once the HTTP request finishes.
    Before we fill out the actual function, we want to set up our options. There''re
    two options, URL and JSON. We''ll set `url` equal to the static string, the exact
    URL we have in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in the next line after comma, we can set `json` equal to `true`, telling
    the request library to go ahead and parse that body as JSON, which it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, we can go ahead and add our callback arguments; `error`, `response`,
    and `body`. These are the exact same three arguments we have in the `if` block
    of `geocode.js` file for the `geocoding` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have this in place, the last thing we need to do is print the current
    temperature, which is available on the body using `console.log` statement. We''ll
    use `console.log` to print `body.currently.temperature`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the temperature printing, we need to test it by running it
    from the Terminal. In the Terminal, we''ll rerun the previous command. The address
    is not actually being used here since we commented out that code, and what we
    get is 28.65, as shown in this code output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4afe0e93-2da7-4d5e-9631-f40646805e7d.png)'
  prefs: []
  type: TYPE_IMG
- en: With this we have our weather API call working inside of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling in the the callback function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we do want to add a little error handling inside of our callback function.
    We''ll handle errors on the error object, and we''ll also handle errors that come
    back from the [forecast.io](http://forecast.io) servers. First up, just like we
    did for the geocoding API, we''ll check if error exists. If it does, that means
    that we were unable to connect to the servers, so we can print a message that
    relays that message to the user, `console.log` something like `Unable to connect
    to forecast.io server.`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've handled general errors, we can move on to a specific error that
    the [forecast.io](http://forecast.io) API throws. This happens when the format
    of the URL, the latitude and longitude, is not correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we delete some numbers including the comma in the URL, and
    hit *enter* we''ll get a 400 Bad Request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41a55d28-22ae-4309-9e2f-cf0907b38ab0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the actual HTTP status code. If you remember from the `geolocation`
    API we had a `body.status` property that was either `OK` or `ZERO_RESULTS`. This
    is similar to that property, only this uses the HTTP mechanisms instead of some
    sort of custom solution that Google used. In our case, we''ll want to check if
    the status code is 400\. Now if we have a bad API key, I''ll add a couple e''s
    in the URL, we''ll also get a 400 Bad Request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8f92f30-e83f-4762-a592-aca23adb78d6.png)'
  prefs: []
  type: TYPE_IMG
- en: So both of these errors can be handled using the same code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside of Atom, we can handle this by checking the status code property. After
    our `if` statement closing curly brace, we''ll add `else if` block, `else if (response.statusCode)`,
    this is the property we looked at when we looked at the response argument in detail.
    `response.statusCode` will be equal to `400` if something went wrong, and that''s
    exactly what we''ll check for here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If the status code is `400` we''ll print a message, `console.log(''Unable to
    fetch weather'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Now we've handled those two errors, and we can move on to the success case.
    For this we'll add another else if block with `response.statusCode` equals `200`.
    The status code will equal `200` if everything went well, in that case we'll print
    the current temperature to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll cut the `console.log(body.currently.temperature)` line out and paste
    it inside of the else if code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Another way of error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s is another way to represent our entire if block code. The following
    is an updated code snippet, and we can actually replace everything we have in
    the current callback function with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This condition checks if there is no error and the response status code is a
    `200`, if that's the case what do we do? We simply print the temperature like
    we were doing last time, that was in the `else if` clause at the very bottom.
    Now we have an `else` case in the updated code snippet, so if there is an error
    or the status code is not a `200`, we'll go ahead and print this message to the
    screen. This will handle things like the server not having a network connection,
    or 404s from an invalid or broken URL. All right, use this code instead and everything
    should be working as expected with the latest version of the weather API.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the error handling in callback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have some error handling in place and we can go ahead and test that
    our app still works. From the Terminal we''ll rerun the previous command, and
    we still get a temperature 28.71:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28b3db9f-71ca-4139-87ed-b70ea758317a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Back inside of Atom, we''ll trash some of the data by removing the comma, saving
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'When we rerun it from the Terminal, this time, we would expect Unable to fetch
    weather. to print to the screen, and when I rerun the app that is exactly what
    we get, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a7ac319-1d5f-47bb-b8ad-8c1ef3fbc20b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s add the comma back in and test our last part of the code. To test
    the if error, we can test that by removing something like the dot from `forecast.io`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We can rerun the app, and we see Unable to connect to Forecast.io server.:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9b695a9-2e81-4df2-88d8-6b2323e6a914.png)'
  prefs: []
  type: TYPE_IMG
- en: All of our error handling works great, and if there is no errors the proper
    temperature prints to the screen, which is fantastic.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining callbacks together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll take the code that we created in the last section, and
    break it out into its own file. Similar to what we did with the Geocoding API
    request where we called `geocodeAddress` instead of actually having the request
    call in `app.js`. That means we'll make a new folder, a new file, and we'll create
    a function in there that gets exported.
  prefs: []
  type: TYPE_NORMAL
- en: After that we'll go ahead and learn how to chain callbacks together. So when
    we get that address from the Terminal we can convert that into coordinates. And
    we can take those coordinates and convert them into temperature information, or
    whatever weather data we want to pull off of the return result from the Forecast
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring our request call in weather.js file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now before we can dive into the refactoring, we'll create a brand new file,
    and we'll worry about getting the code we created in the previous section into
    that function. Then we'll go for creating that callback.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the new function getWeather in weather file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's make the directory. The directory will be called `weather`. And
    in the `weather` directory we'll make a new file called `weather.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now in this file we can take all of our code from `app.js`, and paste it in
    `weather.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing we need to do in order to take this code and convert it to create
    that function, which will get exported. And then we can move our call to the request
    inside of it. We''ll make a brand new function called `getWeather` next to the
    `request` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '`getWeather` will take some arguments, but that''ll be added later. For now
    we''ll leave the arguments list empty. Next, we''ll take our call to request and
    move it inside the `getWeather` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can go ahead and export this `getWeather` function. We''ll add `module.exports.getWeather`
    and set it equal to the `getWeather` function that we defined up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Providing weather directory in app.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have this in place, we can go ahead and move into `app.js` to add
    some code. The first thing we need do is remove the API key. We no longer need
    that. And we'll highlight all of the commented code and uncomment it using the
    command `/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll import the `weather.js` file. We''ll create a `const` variable called
    `weather`, and setting it equal to the `require`, return result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case we''re requiring our brand new file we just created. We''ll provide
    a relative path `./` because we''re loading in a file that we wrote. Then we''ll
    provide the directory named `weather` followed by the file named `weather.js`.
    And we can leave off that `js` extension, as we already know:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the Weather API loaded in, we can go ahead and call it. We''ll
    comment out our call to `geocodeAddress` and, we''ll run `weather.getWeather()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now as I mentioned before, there will be arguments later in the section. For
    now we''ll leave them empty. And we can run our file from the Terminal. This means
    we should see the weather printing for the coordinates, we hard-coded in the previous
    section. So, we''ll run `node app.js`. We''ll need to provide an address since
    we haven''t commented out the yargs code. So we''ll add a dummy address. I''ll
    use a zip code in New Jersey:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/c01e3671-6f77-4290-a189-3bc1d4462223.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, the `geolocation` code is never running, because that is commented out.
    But we are running the weather code that got moved to the new file. And we are
    indeed seeing a temperature 31.82 degrees, which means that the code is properly
    getting executed in the new file.
  prefs: []
  type: TYPE_NORMAL
- en: Passing the arguments in the getWeather function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we'll need to pass in some arguments, including a callback function and
    inside `getWeather` variable in weather file. We'll need to use those arguments
    instead of a static `lat`/`lng` pair. And we'll also need to call the callback
    instead of using `console.log`. The first thing we'll do before we actually change
    the `weather.js` code is change the `app.js` code. There are three arguments to
    be added. These are `lat`, `lng` and `callback`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First up we''ll want to pass in the latitude. We''ll take the static data,
    like the latitude part from the URL in `weather.js`, copy it, and paste it right
    inside of the arguments list in `app.js` as first argument. The next one will
    be the longitude. We''ll grab that from the URL, copy it, and paste it inside
    of `app.js` as the second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can go ahead and provide the third one, which will be the callback
    function. This function will get fired once the weather data comes back from the
    API. I''ll use an arrow function that will get those two arguments we discussed
    earlier in the previous section: `errorMessage` and `weatherResults`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `weatherResults` object containing any sort of temperature information we
    want. In this case it could be the temperature and the actual temperature. Now,
    we have used `weatherResults` in place of results, and this is because, we want
    to differentiate `weatherResults` from the results variable in `geocodeAddress`.
  prefs: []
  type: TYPE_NORMAL
- en: Printing errorMessage in the getWeather function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside of the `getWeather` function in `app.js`, we now need to use `if`-`else`
    statements in order to print the appropriate thing to the screen, depending on
    whether or not the error message exists. If there is `errorMessage` we do want
    to go ahead and print it using `console.log`. In this case we''ll pass in the
    `errorMessage` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if there is no error message we''ll use the `weatherResults` object. We''ll
    be printing a nice formatted message later. For now we can simply print the `weatherResults`
    object using the pretty printing technique we talked about in the previous chapter,
    where we call `JSON.stringify` inside of `console.log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `JSON.stringify` parentheses, we''ll provide those three arguments,
    the actual object; `weatherResults`, `undefined` for our filtering function, and
    a number for our indentation. In this case we''ll go with `2` once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: And now that we have our `getWeather` call getting called with all three arguments,
    we can go ahead and actually implement this call inside of `weather.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing getWeather callback inside weather.js file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started we'll make the URL in the `weather.js` file dynamic, which means
    we need to replace the url strings with template strings. Once we have template
    strings in place, we can inject the arguments, latitude and longitude, right into
    the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Adding dynamic latitude and longitude
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and define all the arguments that are getting passed in. We
    add `lat`, `lng`, and our `callback`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'First off let''s inject that latitude. We''ll take the static latitude, remove
    it, and between the forward slash and the comma we''ll inject it using dollar
    with our curly braces. This lets us inject a value into our template string; in
    this case `lat`. And we can do the exact same thing right after the comma with
    the longitude. We''ll remove the static longitude, use the dollar sign with our
    curly braces to inject the variable into the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Now that the URL is dynamic, the last thing we need to do inside of `getWeather`
    is change our `console.log` calls to `callback` calls.
  prefs: []
  type: TYPE_NORMAL
- en: Changing console.log calls into callback calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To change our `console.log` into `callback` calls, for the first two `console.log`
    calls we can replace `console.log` with `callback`. And this will line up with
    the arguments that we specified in `app.js`, where the first one is the `errorMessage`
    and the second one is the `weatherResults`. In this case we''ll pass the `errorMessage`
    back and the second argument is `undefined`, which it should be. We can do the
    same thing for `Unable to fetch weather`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the third `console.log` call will be a little more complex. We''ll have
    to actually create an object instead of just passing the temperature back. We''ll
    call the `callback` with the first argument being `undefined`, because in this
    case there is no `errorMessage`. Instead we''ll provide that `weatherResults`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the parentheses, we can define all the temperature properties we like.
    In this case we''ll define `temperature`, setting it equal to `body.currently`,
    which stores all of the `currently` weather data, `.temperature`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the `temperature` variable we can go ahead and provide that
    second property to the object, which is `actual temperature`. Actual temperature
    will account for things like humidity, wind speed, and other weather conditions.
    The actual temperature data is available under a property on currently called
    `apparentTemperature`. We''ll provide that. And as the value we''ll use the same
    thing. This gets us to the `currently` object, just like we do for temperature.
    This will be `body.currently.apparentTemperature`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have our two properties, so we can go ahead and remove that `console.log`
    statement. Add a semicolon. The final code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can go ahead and run the app. We have our `getWeather` function wired
    up both inside of the `weather.js` file and inside of `app.js`. Now once again
    we are still using static coordinates, but this will be the last time we run the
    file with that static data. From the Terminal we''ll rerun the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fec933d9-d879-4d1d-a377-c6f1c2ce06b5.png)'
  prefs: []
  type: TYPE_IMG
- en: And as shown we get our temperature object printing to the screen. We have our
    temperature property 48.82 and we have the apparentTemperature, which is already
    at 47.42 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place we're now ready to learn how to chain our callbacks together.
    That means in `app.js` we'll take the results that come back from `geocodeAddress`,
    pass them in to `getWeather`, and use that to print dynamic weather for the address
    you provide over here in the Terminal. In this case we would get the address for
    the town in New Jersey. As opposed to the static address which we're using in
    the `app.js` file that latitude/longitude pair is for Philadelphia.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining the geocodeAddress and getWeather callbacks together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started we have to take our `getWeather` call and actually move it inside
    of the `callback` function for `geocodeAddress`. Because inside this `callback`
    function is the only place we have access to the latitude and longitude pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Now if we open the `geocode.js` file, we can see that we get `formatted_address`
    back as the address property, we get the `latitude` back as latitude, and we get
    `longitude` back as longitude. We'll start wiring this up.
  prefs: []
  type: TYPE_NORMAL
- en: Moving getWeather call into geocodeAddress function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we do need to remove the comments of `geocodeAddress` in the `app.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll go ahead and take the `console.log` statement in the success case
    and replace it with a `console.log` call that will print the formatted address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: This will print the address to the screen, so we know exactly what address we're
    getting weather data for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our `console.log` printing the address, we can take the `getWeather`
    call, and move it right below the `console.log` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: And with this in place we're now really close to actually chaining the two callbacks
    together. All that's left to do is take these static coordinates and replace them
    with the dynamic ones, which will be available in the `results` object.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing static coordinates with dynamic coordinates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first argument will be `results.latitude`, which we defined in `app.js`
    on the object. And the second one will be `results.longitude`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This is all we need to do to take the data from `geocodeAddress` and pass it
    in to `getWeather`. This will create an application that prints our dynamic weather,
    the weather for the address in the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now before we go ahead and run this, we''ll replace the object call with a
    more formatted one. We''ll take both of the pieces of information-the `temperature`
    variable and the `apparentTemperature` variable from `weather.js` file, and use
    them in that string in `app.js`. This means that we can remove the `console.log`
    in the `else` block of `getWeather` call, replacing it with a different `console.log`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use template strings, since we plan to inject a few variables in; these''re
    currently, followed by the temperature. We''ll inject that using `weatherResults.temperature`.
    And then we can go ahead and put a period, and add something along the lines of:
    `It feels like`, followed by the `apparentTemperature` property, which I''ll inject
    using `weatherResults.apparentTemperature`. I''ll put a period after that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: We now have a `console.log` statement that prints the weather to the screen.
    We also have one that prints the address to the screen, and we have error handlers
    for both `geocodeAddress` and `getWeather`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the chaining of callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and test this by rerunning the `node app.js` command in the
    Terminal. We''ll use the same zip code, `08822`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/f48ffac3-6759-42f6-ade3-c5385a843cce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we run it we get Flemington, NJ as the formatted address and It''s currently
    is 31.01\. It feels like 24.9\. Now to test that this is working we''ll type in
    something else inside of quotes, something like `Key West fl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/a81c7d4c-fab7-4c1e-98c9-14d9a411b022.png)'
  prefs: []
  type: TYPE_IMG
- en: And when we run this command we do get Key West, FL as shown as the formatted
    address, and It's currently 64.51\. It feels like 64.52.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, the weather application is now wired up. We take the address
    we get the latitude/longitude pair using the Google Geocoding API. Then we use
    our forecast API to take that latitude/longitude pair and convert it into temperature
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about how to set up yargs for the `weather-app`
    file and how to include user input in it. Next, we looked into how to handle errors
    inside of our callback functions and how to recover from those errors. We simply
    added `else`/`if` statements inside of the `callback` function. Callbacks are
    just one function, so in order to figure out if things went well or if things
    didn't go well, we have to use `else`/`if` statements, this lets us do different
    things, such as print different messages, depending on whether or not we perceive
    the request to have gone well. Then, we made our first request to the weather
    API, and we looked into a way to fetch the weather based off of the latitude-longitude
    combination.
  prefs: []
  type: TYPE_NORMAL
- en: Last, we looked in chaining the `geocodeAddress` and `getWeather` call functions.
    We took that request call that was originally in `app.js`, and we moved it into
    `weather.js`, defining it there. We used a callback to pass the data from `weather.js`
    into `app.js` where we imported the `weather.js` file. Then, inside of the callback
    for `geocodeAddress` we call `getWeather` and inside of that `callback` we printed
    the weather specific information to the screen. This was all done using `callback`
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll talk about a different way we can synchronize our
    asynchronous code using ES6 promises.
  prefs: []
  type: TYPE_NORMAL
