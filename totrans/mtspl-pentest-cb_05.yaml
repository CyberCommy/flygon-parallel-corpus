- en: Chapter 5. Using Meterpreter to Explore the Compromised Target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing meterpreter system commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Privilege escalation and process migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up multiple communication channels with the target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meterpreter filesystem commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing file attributes using timestomp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using meterpreter networking commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The getdesktop and keystroke sniffing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a scraper meterpreter script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have laid more stress on the pre-exploitation phase in which we tried
    out various techniques and exploits to compromise our target. In this chapter,
    we will lay stress on the post-exploitation phase—what we can do after we have
    exploited the target machine. Metasploit provides a very powerful post-exploitation
    tool named meterpreter that provides us with many features that can ease our task
    of exploring the target machine. We have already seen the use of meterpreter and
    post-exploitation in the previous chapter of antivirus bypass. In this chapter,
    we will understand in detail about meterpreter and how to use it as a potential
    tool for the post-exploitation phase.
  prefs: []
  type: TYPE_NORMAL
- en: We have been using payloads in order to achieve specific results but they have
    a major disadvantage. Payloads work by creating new processes in the compromised
    system. This can trigger alarms in the antivirus programs and can be caught easily.
    Also, a payload is limited to perform only some specific tasks or execute specific
    commands that the shell can run. To overcome these difficulties meterpreter came
    into light.
  prefs: []
  type: TYPE_NORMAL
- en: '**Meterpreter** is a command interpreter for Metasploit that acts as a payload
    and works by using in memory DLL injection and a native shared object format.
    It works in context with the exploited process, hence it does not create any new
    process. This makes it more stealthy and powerful.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us give a look at how meterpreter functions. The following diagram shows
    a simple stepwise representation of loading meterpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/7423_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the first step, the exploit and first stage payload is sent to the target
    machine. After exploitation, the stager binds itself to the target with a specific
    task and tries to connect back to the attacking `msfconsole` and a proper communication
    channel is set up. Now the stager loads the DLL. `msfconsole` and sends the second
    stage DLL injection payload. After successful injection, MSF sends the meterpreter
    DLL to establish a proper communication channel. Lastly, meterpreter loads extensions
    such as `stdapi` and `priv`. All these extensions are loaded over TLS/1.0 using
    a TLV protocol. Meterpreter uses encrypted communication with the target user
    that is another major advantage of using it. Let us quickly summarize the advantages
    of meterpreter over specific payloads:'
  prefs: []
  type: TYPE_NORMAL
- en: It works in context with the exploited process, so it doesn't create a new process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can migrate easily among processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It resides completely in the memory, so it writes nothing on disk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses encrypted communications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses a channelized communication system, so that we can work with several
    channels at a time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a platform to write extensions quickly and easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter is dedicated entirely towards exploring the target machine by using
    the various commands and scripts that meterpreter provides us with. We will start
    with analyzing common meterpreter commands. Then, we will move ahead with setting
    up different communication channels, use of networking commands, key sniffing,
    and so on. Finally, we will discuss the scraper meterpreter script which can create
    a single directory containing various pieces of information about the target user.
    In this chapter, we will focus mainly on those commands and scripts which can
    be helpful in exploring the compromised system.
  prefs: []
  type: TYPE_NORMAL
- en: So let us move ahead with the recipes to dive deeper into meterpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing meterpreter system commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us start using meterpreter commands to understand their functionality. As
    it is a post exploitation tool, we will require a compromised target to execute
    the commands. We will be using a Windows 7 machine as a target that we have exploited
    using browser vulnerability. You can refer to the *Internet Explorer CSS recursive
    call memory corruption* recipe in [Chapter 4](ch04.html "Chapter 4. Client-side
    Exploitation and Antivirus Bypass"), *Client-side Exploitation and Antivirus Bypass*,
    for further details.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After compromising the Windows 7 target machine, we will have a meterpreter
    session started as we have used the `windows/meterpreter/bind_tcp` payload. We
    will start off by using a simple `?` command that will list all the available
    meterpreter commands, along with a short description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Take a quick look at the entire list. Many of the commands are self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us start with some useful system commands.
  prefs: []
  type: TYPE_NORMAL
- en: '`background:` This command is used to set the current session as background,
    so that it can be used again when needed. This command is useful when there are
    multiple active meterpreter sessions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getuid:` This command returns the username that is running, or in which we
    broke in, on the target machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`getpid:` This command returns the process ID in which we are currently running
    the meterpreter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`ps:` This command will list all the running processes on the target machine.
    This command can be helpful in identifying various services and software running
    on the target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`sysinfo:` This is a handy command to quickly verify the system information,
    such as the operating system and architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`shell:` This command takes us into a shell prompt. We have already seen the
    use of this meterpreter command in some of our previous recipes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`exit:` This command is used to terminate a meterpreter session. This command
    can also be used to terminate the shell session and return back to meterpreter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These were a few useful system commands that can be used to explore the compromised
    target to gain more information about it. There are lots of other commands, which
    I am leaving for you to try and explore. You might have noticed how easy it is
    to use the meterpreter commands and explore the target that, in turn, would have
    been a difficult task without it. In our next recipe, we will focus on some advanced
    meterpreter commands.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Meterpreter works like any command interpreter. It is designed to understand
    and respond to various parameter calls through commands. It resides in the context
    of an exploited/compromised process and creates a client/server communication
    system with the penetration tester's machine.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7423_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram demonstrates the functioning of meterpreter in a nutshell.
    Once the communication channel is set up, we can send command calls to the meterpreter
    server to get its response back to our machine. We will understand the communication
    between the pen-testing machine and the compromised target in greater detail as
    we move ahead with this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Privilege escalation and process migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will focus on two very useful commands of meterpreter. The
    first one is for **privilege escalation**. This command is used to escalate the
    rights/authority on the target system. We might break in as a user who has less
    privilege to perform tasks on the system. So, we can escalate our privilege to
    the system admin in order to perform our tasks without interruption. The second
    command is for **process migration**. This command is used to migrate from one
    process to another process without writing anything on the disk.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to escalate our privilege, meterpreter provides us with the `getsystem`
    command. This command automatically starts looking out for various possible techniques
    by which the user rights can be escalated to a higher level. Let us analyze different
    techniques used by the `getsystem` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are three different techniques by which the `getsystem` command tries
    to escalate privilege on the target. The default value `0` tries for all the listed
    techniques unless a successful attempt is made. Let us take a quick look at these
    escalation techniques.
  prefs: []
  type: TYPE_NORMAL
- en: A **named pipe** is a mechanism that enables inter-process communication for
    applications to occur locally or remotely. The application that creates the pipe
    is known as the pipe server, and the application that connects to the pipe is
    known as the pipe client. **Impersonation** is the ability of a thread to execute
    in a security context different from that of the process that owns the thread.
    Impersonation enables the server thread to perform actions on behalf of the client,
    but within the limits of the client's security context. The problem arises when
    the client has more rights than the server. This scenario would create a privilege
    escalation attack called a **Named Pipe Impersonation** escalation attack.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A detailed article on Named Pipe Impersonation can be found at [http://hackingalert.blogspot.com/2011/12/namedpipe-impersonation-attacks.html](http://hackingalert.blogspot.com/2011/12/namedpipe-impersonation-attacks.html).
  prefs: []
  type: TYPE_NORMAL
- en: Every user of an operating system is provided with a unique token ID. This ID
    is used to check the permission levels of various users of the system. Token duplication
    works by copying of a token ID of a higher privilege user by a low privilege user.
    The lower privilege user then behaves in a similar manner as the higher privilege
    user and it holds all the rights and authorities as that of the higher privilege
    user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The KiTrapOD exploit was released in early 2010, which affected nearly every
    operating system that Microsoft had made until then. When access to 16-bit applications
    is enabled on a 32-bit x86 platform, it does not properly validate certain BIOS
    calls. This allows local users to gain privileges by crafting a `VDM_TIB` data
    structure in the **Thread Environment Block (TEB)**, to improperly handled exceptions
    involving the #GP trap handler (nt!KiTrap0D), a.k.a. "Windows Kernel Exception
    Handler Vulnerability."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have understood the various escalation techniques used by the `getsystem`
    command, our next step will be to execute the command on our target to see what
    happens. First, we will use the `getuid` command to check our current user ID,
    and then we will try to escalate our privilege by using the `getsystem` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see that previously we were a less privileged user and after using
    the `getsystem` command we escalated our privilege to System user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next important meterpreter command that we are going to discuss is the
    `migrate` command. This command is used to migrate from one process context to
    another. This command is helpful in situations where the current process, in which
    we have broken, in might crash. For example, if we use a browser exploit to penetrate
    the system, then the browser may hang after exploitation and the user may close
    it. So migrating to a stable system process can help us perform our penetration
    testing smoothly. We can migrate to any other active process by using the process
    ID. The `ps` command can be used to identify the ID of all active processes. For
    example, if the ID of `explorer.exe` is `2084`, then we can migrate to `explorer.exe`
    by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: These two meterpreter commands are very handy and are used frequently during
    penetration testing. Their simplicity and high productivity makes them optimal
    for usage. In our next recipe we will deal with communication channels and how
    to use them effectively to communicate with the target.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up multiple communication channels with the target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at how we can set up multiple channels for communication
    with the target. We have discussed in the chapter's introduction that the communication
    between client and server in meterpreter is in encrypted form and it uses **Type-Length-Value
    (TLV)** protocol for data transfer. The major advantage of using TLV is that it
    allows tagging of data with specific channel numbers, thus allowing multiple programs
    running on the victim to communicate with the meterpreter on the attacking machine.
    This facilitates in setting up several communication channels at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now analyze how to set up multiple communication channels with the target
    machine using meterpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Meterpreter provides us with a specific command named `execute` which can be
    used to start multiple communication channels. To start with, let us run the `execute
    -h` command to see the available options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can see the various parameters available to us with the `execute` command.
    Let us use some of these parameters in setting up multiple channels.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start with creating channels, we will use the `-f` operator with the `execute`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the use of different parameters. The `-f` parameter is used for setting
    an executable command and the `-c` operator is used to set up a channelized I/O.
    Now we can again run the execute command to start another channel without terminating
    the current channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have three different channels running simultaneously on the victim machine.
    To list the available channels, we can use the `channel -l` command. If we want
    to send some data or write something on a channel, we can use the `write` command
    followed by the channel ID we want to write in. Let us go ahead and write a message
    in one of our active channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Executing the `write` command along with the channel ID prompted us to enter
    our data followed by a dot. We successfully wrote `Metasploit!!` on the channel.
    In order to read the data of any channel, we can use the `read` command followed
    by the channel ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, if we want to interact with any channel, we can use the `interact`
    command followed by the channel ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see that our channel 2 was a command prompt channel so by using the
    `interact` command, we are directly dropped into the command prompt mode from
    where we can execute system commands. We can easily switch between channels by
    using the `interact` command. In order to end a channel, we can use the `close`
    command followed by the channel ID.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe demonstrates the power of using multiple channels. It also shows
    how easy it is to manage them simultaneously and switch between different channels.
    The use of channels becomes important when we are running multiple services on
    the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we will focus on exploring the file system of the target
    machine using meterpreter.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Metasploit tags each message with a separate channel ID which helps it in identifying
    the channel context in which the particular command should be executed. As stated
    earlier, the communication process in meterpreter follows the TLV protocol which
    gives the flexibility of tagging different messages with specific channel IDs
    in order to provide multi-channel communication support.
  prefs: []
  type: TYPE_NORMAL
- en: Meterpreter filesystem commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will move ahead with filesystem commands. These commands
    can be helpful in exploring the target system to perform various tasks such as
    searching for files, downloading files, and changing directory. You will notice
    how easy it is to control the target machine using meterpreter. So let us start
    working with some of the useful filesystem commands.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start with the simple `pwd` command which lists our present working
    directory on the target machine. Similarly, we can use the `cd` command to change
    our working directory to our preferred location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we first listed our working directory using the `pwd` command
    and then changed our working directory to `c:` by using the `cd` command. We can
    also use the `ls` command to list the available files in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we can work with directories, our next task will be to search for
    files on the drive. It will be very tedious to browse every directory and sub-directory
    to look for files. We can use the `search` command to quickly search for specific
    file types. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This command will search for all files in the `C` drive having `.doc` as the
    file extension. The `f` parameter is used to specify the file pattern to search
    for and the `d` parameter tells the directory which file is to be searched.
  prefs: []
  type: TYPE_NORMAL
- en: 'So once we have searched for our specific file, the next thing we can do is
    download the file locally on the target machine. Let us first try to download
    the file to our attacking system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: By using the `download` command, we can successfully download any file from
    the target machine to our machine. The `d:\secret.doc` file gets downloaded in
    the `root` folder of our attacking machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can use the `upload` command to send any file to the target machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can use the `del` command to delete a file or a directory from the
    target machine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Meterpreter gives us complete access to the target machine by setting up an
    interactive command prompt. We can also drop a shell session to work in the default
    windows DOS mode but it will not have as many functionalities. This was a quick
    reference to some of the important filesystem commands of meterpreter, which can
    help us in exploring the files present on the target machine. There are more commands
    as well; it is recommended that you should try them out and find the various possibilities
    that can exist.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we will look at a very interesting meterpreter command called
    `timestomp` that can be used to modify the file attributes on the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: Changing file attributes using timestomp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we read about some of the important and useful meterpreter
    file system commands that can be used to perform various tasks on the target machine.
    Meterpreter contains another interesting command called `timestomp`. This command
    is used to change the **Modified-Accessed-Created-Entry (MACE)** attributes of
    a file. The attribute value is the date and time when any of the MACE activities
    occurred with the file. Using the `timestomp` command, we can change these values.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before starting with the recipe, there is a question that may strike in your
    mind. Why change the MACE values? Hackers generally use the technique of changing
    the MACE values so as to make the target user feel that the file has been present
    on the system for long and that it has not been touched or modified. In case of
    suspicious activity, the administrators may check for recently modified files
    to find out if any of the files have been modified or accessed. So, using this
    technique, the file will not appear in the list of recently accessed or modified
    items. Even though there are other techniques as well, to find out if the file
    attributes have been modified, this technique can still be handy.
  prefs: []
  type: TYPE_NORMAL
- en: Let's pick up a file from the target machine and change its MACE attributes.
    The following screenshot shows the various MACE values of a file before using
    `timestomp:`
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/7423_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we will move ahead to change the various MACE values. Let us start with
    the common `timestomp -h` command that is used to list the various available options.
    We can use the `-v` operator to list the values of MACE attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start with changing the creation time of the file. Notice the various
    parameters passed with the `timestomp` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `-c` operator is used to change the creation time of the file. Similarly,
    we can use the `-m` and `-a` operators to change the modified and last accessed
    attributes of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the attributes have been changed, we can again use the `-v` operator to
    check and verify whether we have successfully executed the commands or not. Let
    us move ahead and check the file attributes again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Bingo! We have successfully modified the MACE attributes of the file. Now this
    file can be easily hidden from the list of recently modified or recently accessed
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can also use the `-z` operator to change all four MACE values
    in a go. We will not have to pass the commands separately for each of them. But
    the `-z` operator will assign the same values to all four MACE attributes that
    is practically not possible. There has to be some time difference between creation
    and accessed time. So, the use of the `-z` operator should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: This was a small recipe dealing with the `timestomp` utility. In the next recipe,
    we will look at some of the useful meterpreter networking commands that will be
    of great use to us when we will understand pivoting.
  prefs: []
  type: TYPE_NORMAL
- en: Using meterpreter networking commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Meterpreter provides us some useful networking commands as well. These commands
    can be useful in understanding the network structure of the target user. We can
    analyze whether the system belongs to a LAN or it is a standalone system. We can
    also know the IP range, DNS, and other information as well. Such network information
    can be useful when we have to perform pivoting. Pivoting is a concept by which
    we can compromise other machines on the same network in which our target is present.
    We will understand pivoting in our next chapter where we will focus on the advanced
    use of meterpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we get into the recipe, there are three networking terms which we will
    encounter here. So let us give a quick brush to our memory by looking at the following
    terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Subnetwork** or **subnet** is the concept of dividing a large network into
    smaller identifiable parts. Subnetting is done to increase the address utility
    and security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **netmask** is a 32-bit mask that is used to divide an IP address into subnets
    and specify the network's available hosts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gateway** specifies the forwarding or the next hop IP address over which
    the set of addresses defined by the network destination and subnet mask are reachable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be using these three terms when we will deal with the `route` command.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are three networking commands provided by meterpreter. These are `ipconfig,
    route`, and `portfwd`. Let us give a quick look at each of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Ipconfig` command is used to display all the TCP/IP network configurations
    of the target machine. It lists information such as the target IP address, hardware
    MAC, and netmask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the output of `ipconfig` lists the various active TCP/IP configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next networking command is the `route` command. It is similar to the `route`
    command of MS DOS. This command is used to display or modify the local IP routing
    table on the target machine. Executing the `route` command lists the current table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Let us execute the `route -h` command to figure out how we can modify the table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If you take a look at the output of the `ipconfig` command, you can figure
    out that the IP address `115.242.228.85` is used by the target to connect to the
    Internet. So we can add a route value to pass the connection through `115.242.228.85`
    as the gateway. This can provide us a firewall bypass on the target machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we can use the `delete` command to remove a route from the table.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move to the last networking command—`portfwd`. This command is used to
    forward incoming TCP and/or UDP connections to remote hosts. Consider the following
    example to understand port forwarding.
  prefs: []
  type: TYPE_NORMAL
- en: Consider host "A", host "B" (in the middle), and host "C". Host A should connect
    to host C in order to do something, but if for any reason it's not possible, host
    B can directly connect to C. If we use host B in the middle, to get the connection
    stream from A and pass it to B while taking care of the connection, we say host
    B is doing **port forwarding**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how things will appear on the wire: host B is running a software that
    opens a TCP listener on one of its ports, say port 20\. Host C is also running
    a listener that is used to connect to host B when a packet arrives from port 20\.
    So, if A sends any packet on port 20 of B, it will automatically be forwarded
    to host C. Hence, host B is port forwarding its packets to host C.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start port forwarding with a remote host we can add a forwarding rule first.
    Consider the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Notice the different command parameters. With the `-a` parameter we can add
    a new port forwarding rule. The `-L` parameter defines the IP address to bind
    a forwarded socket to. As we're running these all on host A, and want to continue
    our work from the same host, we set the IP address to `127.0.0.1`.
  prefs: []
  type: TYPE_NORMAL
- en: '`-l` is the port number which will be opened on host A, for accepting incoming
    connections. `-h` defines the IP address of host C, or any other host within the
    internal network. `-p` is the port you want to connect to, on host C.'
  prefs: []
  type: TYPE_NORMAL
- en: This was a simple demonstration of using port forwarding. This technique is
    actively used to bypass firewalls and intrusion detection systems.
  prefs: []
  type: TYPE_NORMAL
- en: The getdesktop and keystroke sniffing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will deal with some of the `stdapi` user interface commands
    associated with desktops and keystroke sniffing. Capturing the keystrokes depends
    on the current active desktop, so it is essential to understand how we can sniff
    different keystrokes by switching between processes running in different desktop
    active sessions. Let us move ahead with the recipe to understand this deeply.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us start with executing some of the user interface commands which we will
    primarily deal with in this recipe. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`enumdesktops:` This command will list all the accessible desktops and window
    stations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here you can see that all the available desktop stations are associated with
    session 0\. We will see in a while what exactly we mean by session 0.
  prefs: []
  type: TYPE_NORMAL
- en: '`getdesktop:` This command returns the current desktop in which our meterpreter
    session is working.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can relate the output of the `getdesktop` command with `enumdesktops` to
    understand about the current desktop station in which we are working.
  prefs: []
  type: TYPE_NORMAL
- en: '`setdesktop:` This command is used to change the current meterpreter desktop
    to another available desktop station.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keyscan_start:` This command is used to start the keystroke sniffer in the
    current active desktop station.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keyscan_dump:` This command dumps the recorded keystrokes of the active meterpreter
    desktop session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us now analyze how these commands work in a real-time scenario and how we
    can sniff keystrokes through different desktop stations.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we proceed further with the recipe, there is an important concept about
    Windows desktop that we will look at.
  prefs: []
  type: TYPE_NORMAL
- en: Windows desktop is divided into different **sessions** in order to define the
    ways we can interact with the Windows machine. Session 0 represents the console.
    The other sessions —Session 1, Session 2, and so on represent remote desktop sessions.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in order to capture the keystrokes of the system we broke in to, we must
    work in desktop Session 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7423_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Every Windows desktop session comprises of different stations. In the preceding
    diagram, you can see different stations associated with Session 0\. Out of these
    stations, WinSta0 is the only interactive station. This means that the user can
    interact with only the WinSta0 station. All the other stations are non-interactive.
    Now WinSta0 consists of three different desktops namely Default, Disconnect, and
    Winlogon. The Default desktop is associated with all the applications and tasks
    that we perform on our desktop. The `Disconnect` desktop is concerned with the
    screensaver lock desktop. The Winlogon desktop is concerned with the Windows login
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: The point to note here is that each desktop has its own keyboard buffer. So,
    if you have to sniff the keystrokes from the `Default` desktop, you will have
    to make sure that your current meterpreter active browser is set to `Session 0/WinSta0/Default`.
    If you have to sniff the logon password then you will have to change the active
    desktop `to Session 0/WinSta0/Winlogon`. Let us take an example to make it clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check our current desktop using the `getdesktop` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are not in the `WinSta0` station which is the only interactive
    desktop station. So if we run a keystroke capturing here then it won't return
    any result. Let's change our desktop to `WinSta0\Default:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command line shows that we moved to the interactive Windows desktop
    station by using the `setdesktop` command. So, now we are ready to run a keystroke
    sniffer to capture the keys pressed by the user on the target machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the dumped keystrokes, you can clearly identify that the target user
    went to [gmail.com](http://gmail.com) and entered his credentials to login.
  prefs: []
  type: TYPE_NORMAL
- en: What if you want to sniff the windows login password? Obviously, you can switch
    your active desktop to `WinSta0\Winlogon` using the `setdesktop` command but here
    we will discuss an alternate approach as well. We can migrate to a process which
    runs during Windows logon. Let us execute the `ps` command to check the running
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find `winlogon.exe` running as a process with a process id. Let us
    assume that the **process ID (PID)** of `winlogon.exe` is `1180`. Now let''s migrate
    to this PID and check our active desktop again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can see that our active desktop has changed to `WinSta0\Winlogon`. Now we
    can run the `keyscan_start` command to start sniffing the keystrokes on the Windows
    logon screen.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can get back to the Default desktop by migrating to any process
    that is running on the default desktop. Consider `explorer.exe` with PID `884:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You might have noticed the importance of migrating to different processes and
    desktop environments for sniffing keystrokes. Generally, people get no results
    when they directly run `keyscan` without giving a look at the current active desktop.
    This is because the process in which they have penetrated might belong to a different
    session or station. So keep this concept of desktop in mind while working with
    keystroke sniffing.
  prefs: []
  type: TYPE_NORMAL
- en: Using a scraper meterpreter script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we learned about several meterpreter commands. Here, we will take a
    look at an important meterpreter script which can help us in exploring our target
    deeper. The next chapter extensively covers meterpreter scripts so here we will
    just focus on using the script. During penetration testing, you might require
    lot of time to dig out information on the target. So having a local backup of
    useful information can be really handy for penetration testers so that even if
    the target is down, they still have information to work on. It also makes sharing
    of information with other testers easy. Scraper accomplishes this task for us.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The scraper meterpreter script can dig out lots of information about the compromised
    target such as registry information, password hashes, and network information,
    and store it locally on the tester's machine.
  prefs: []
  type: TYPE_NORMAL
- en: In order to execute a Ruby script on the target using meterpreter, we can use
    the `run` command. Executing the `run scraper -h` command will list the various
    available parameters we can pass with the script. Let's move ahead and analyze
    how we can download the information locally.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script does everything automatically after it is executed. It creates a
    directory under `/root/.msf4/logs/scripts/scraper` where all the files are saved.
    You might notice an error during the script execution which can be because a command
    may fail to execute on the target (the command line output has been shortened
    to fit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The script automatically downloads and saves the information in the destination
    folder. Let us take a look at the source code to analyze if we can make some changes
    according to our needs.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The source code for `scraper.rb` is present under `/pentest/exploits/framework3/scripts/meterpreter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ruby coding experience can help you in editing the scripts to add your own
    features. We can change the download location by editing the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you want to obtain the result of a list of available processes as well,
    then you can simply add the following line of code in the main body of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: By using a little bit of Ruby language and code reuse, you can easily modify
    the code to fit according to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us learn about another meterpreter script that can be used for collecting
    information from the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: Using winenum.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`winenum.rb` is another meterpreter script that can help you collect information
    about the target and download it locally. It works similar to `scraper.rb`. You
    can try out this script as well to see what extra information it can provide.
    The script can be found at the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/pentest/exploits/framework3/scripts/meterpreter/winenum.rb`'
  prefs: []
  type: TYPE_NORMAL
