- en: Observables, Actions, and Reactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Describing the structure of the client state is the first step in UI development.
    With MobX, you do this by creating your tree of **observables**. As the user interacts
    with the app, actions are invoked on your observable state, which in turn can
    cause reactions (aka side-effects). Continuing from [Chapter 1](part0023.html#LTSU0-58c2559ca4304cecab9bc46f496bc070), *Introduction
    to State Management*, we will now take a deeper look at the core concepts of MobX.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the various kinds of observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the actions that mutate the observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using reactions to handle external changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have JavaScript programming language. Finally, to use
    the Git repository of this book, the user needs to install Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/MobX-Quick-Start-Guide/tree/master/src/Chapter02](https://github.com/PacktPublishing/MobX-Quick-Start-Guide/tree/master/src/Chapter02)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2NEww85](http://bit.ly/2NEww85)'
  prefs: []
  type: TYPE_NORMAL
- en: Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data is the lifeblood of your UI. Going back to the equation that defines the
    relationship between data and UI, we know that the following is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, it makes sense to focus on *defining the structure* of data that will drive
    the UI. In MobX, we do this with the observables. Take a look at this diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '*Observables*, as the name suggests, are entities that can be observed. They
    keep track of changes happening to their values and notify all the *observers*.
    This seemingly simple behavior has powerful implications when you start designing
    the structure of your client-state. In the preceding diagram, every circle represents
    an **Observable**, and every diamond is an **Observer**. An observer can observe
    one or more observables and get notified when any of them change value.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest way to create an observable is to use the `observable()` function.
    Take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`item` is now an `observable` object and will start tracking changes to its
    properties. You can use this object as a regular JavaScript object without any
    special API to *get* or *set* its values. In the preceding snippet, you can also
    create an observable `item` using `observable.object()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, we can see simple mutations made to the observables,
    like any regular JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Observable objects only track the properties provided in the initial value given
    to `observable()` or `observable.object()`. This means if you add new properties
    later, they will not become observable automatically. This is an important characteristic
    to remember about observable objects. They are like records or classes with a
    fixed set of attributes. If you do need dynamic tracking of properties, you should
    consider using *observable maps*; these will be covered further ahead in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, MobX takes care of transparently tracking the property changes and
    notifying the corresponding observers. We will look into this internal behavior
    in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `observable()` function automatically converts an *object*, an *array*,
    or a *map* into an observable entity. This automatic conversion is *not applied*
    for other types of data—such as JavaScript primitives (number, string, boolean,
    null, undefined), functions, or for class- instances (objects with prototypes).
    So, if you call `observable(20)`, it will fail with an error, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As suggested in the error, we have to use the more specialized `observable.box()`
    to convert primitive values into an observable. Observables that wrap *primitives*, *functions*,
    or *class-instances* are called **boxed observables**. Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have to use the `get()` and `set()` methods of a boxed observable instead
    of directly reading or assigning to it. These methods give us the observability
    that is inherent to MobX.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides objects and singular values, you can also create observables out of
    arrays and maps. They have a corresponding API, as can be seen in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| objects | `observable.object({ })` |'
  prefs: []
  type: TYPE_TB
- en: '| arrays | `observable.array([ ])` |'
  prefs: []
  type: TYPE_TB
- en: '| maps | `observable.map(value)` |'
  prefs: []
  type: TYPE_TB
- en: '| primitives, functions, class-instances | `observable.box(value)` |'
  prefs: []
  type: TYPE_TB
- en: As we mentioned earlier, `observable()` will automatically convert an object,
    array, or a map into an observable. It is shorthand for `observable.object()`,
    `observable.array()`, or `observable.map()`, respectively. For primitives, functions,
    and class-instances, you should use the `observable.box()` API. Although, in practice,
    the use of `observable.box()` is fairly rare. It is more common to use `observable.object()`, `observable.array()`, or `observable.map()`.
  prefs: []
  type: TYPE_NORMAL
- en: MobX applies *deep observability* when creating an observable. This means MobX
    will automatically observe every property, at every level, in the object-tree,
    array, or map. It also tracks additions or removals in the cases of arrays and
    maps. This behavior works well for most scenarios but could be excessive in some
    cases. There are special decorators that you can apply to control this observability.
    We will look into this in [Chapter 4](part0065.html#1TVKI0-58c2559ca4304cecab9bc46f496bc070), *Crafting
    the Observable Tree*.
  prefs: []
  type: TYPE_NORMAL
- en: Observable arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using `observable.array()` is very similar to using an `observable()`. You
    pass an array as initial value or start with an empty array. In the following
    code example, we are starting with an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Do note that the observable array is *not* a real JavaScript array, even though
    it has the same API as a JS Array. When you are passing this array to other libraries
    or APIs, you can convert it into a JS Array by calling `toJS()`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: MobX will apply deep observability to observable arrays, which means it will
    track additions and removals of items from the array and also track property changes
    happening to each item in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Observable maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can make an observable map with the `observable.map()` API. In principle,
    it works the same way as `observable.array()` and `observable.object()`, but it
    is meant for ES6 Maps. The observable map instance shares the same API as a regular
    ES6 Map. Observable maps are great for tracking dynamic changes to the keys and
    values. This is in stark contrast to observable objects*,* which do not track
    properties that are added after creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code example, we are creating a dynamic dictionary of Twitter-handles
    to names. This is a great fit for an observable map, as we are *adding* keys after
    creation. Take a look at this code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A note on observability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you use the `observable()` API, MobX will apply *deep observability* to
    the observable instance. This means it will track changes happening to the observable
    object, array, or map and do it for every property, at every level. In the cases
    of arrays and maps, it will also track the additions and removals of entries.
    Any new entry in an array or a map is also made into a deep observable. This is
    definitely a great sensible default and works well for most situations. However,
    there will be cases where you may not want this default.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can change this behavior at the time of creating the observable. Instead
    of using `observable()`, you can use the sibling APIs (`observable.object()`,
    `observable.array()`, `observable.map()`) to create the observable. Each of these
    takes an extra argument for setting options on the observable instance. Take a
    look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'By passing in `{ deep: false }` as an option, you can effectively *prune* the
    observability just to the first level. This means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: For observable objects, MobX only observes the initial set of properties. If
    the value of property is an object, an array, or a map, it won't do any further
    observation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `{ deep: false }` option is the third argument for `observable.object()`.
    The second argument, called **decorators**, gives you more fine-grained control
    over the observability. We will be covering this in a later chapter. For now,
    you can just pass an empty object as the second argument.'
  prefs: []
  type: TYPE_NORMAL
- en: For observable arrays, MobX only observes the addition and removal of items
    in the array. If an item is an object, an array, or a map, it won't do any further
    observation.
  prefs: []
  type: TYPE_NORMAL
- en: For observable maps, MobX only observes the addition and removal of items in
    the map. If the value of a key is an object, an array, or a map, it won't do any
    further observation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is worth mentioning that `observable()` internally calls one of the
    preceding APIs and sets the option to `{ deep: true }`. This is the reason `observable()` has
    deep observability.'
  prefs: []
  type: TYPE_NORMAL
- en: The computed observable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The observables we have seen so far have a direct correspondence with the shape
    of the client-state. If you are representing a list of items, you would use an
    observable array in your client-state. Similarly, each item in a list can be an observable
    object or an observable map. The story does not stop there. MobX gives you yet
    another kind of observable, called a **computed property** or a **computed observable**.
  prefs: []
  type: TYPE_NORMAL
- en: A computed property is not an observable that is inherent to the client state.
    Instead, it is an observable that *derives its value* from other observables.
    Now, *why would that be useful*? you may ask. Let's take an example to see the
    benefits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the `cart` observable, which tracks a list of items. Take a look at
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say you want to have a `description` property that describes the `cart`
    in this format: There `{is, are} {no, one, n} item{s}` in the cart.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For zero items, the description says this: *There are no items in the cart*.'
  prefs: []
  type: TYPE_NORMAL
- en: When there is only one item, the description becomes this: *There is one item
    in the cart*.
  prefs: []
  type: TYPE_NORMAL
- en: For two or more items *(n)*, the description should be: *There are* *n* *items
    in the cart*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s ponder how we can go about modeling this property. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, the `description` is not an inherent property of the cart. Its value
    depends on `items.length`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can add an observable property called `description`, but then we have to
    update it anytime `items` or `items.length` changes. That is extra work and easy
    to forget. Also, we run the risk of someone modifying the description from the
    outside.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Description should just be a getter with no setter. If someone is observing
    description, they should be notified anytime it changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can tell from the preceding analysis, we can''t seem to fit this behavior
    into any of the previously-discussed observable types. What we need here is the
    computed property. We can define a *computed* description property by simply adding
    a `get-property` to the `cart` observable. It will derive its value from `items.length`.
    Take a look at this code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can simply read `cart.description` and always get the latest description.
    Anyone observing this property would be automatically notified when `cart.description`
    changes, which will happen if you add or remove items from the cart.The following
    is an example of how this computed property can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that it also satisfies all of the criteria from the previous brainstorming
    on the `description` property. I'll let you, the reader, confirm this is the case.
  prefs: []
  type: TYPE_NORMAL
- en: '*Computed properties*, also known as **derivations**, are one of the most powerful
    tools in the MobX toolbox. By thinking of your client-state in terms of a minimal
    set of observables and augmenting it with derivations (computed properties), you
    can model a variety of scenarios effortlessly. Computed properties derive their
    value from other observables. If any of these depending observables change, the
    computed property changes as well.'
  prefs: []
  type: TYPE_NORMAL
- en: You can build a computed property out of other computed properties too. MobX
    internally builds a dependency tree to keep track of the observables. It also
    caches the value of the computed property to avoid unnecessary computation. This
    is an important characteristic that greatly improves the performance of the MobX
    reactivity system. Unlike JavaScript get properties, which are always eagerly
    evaluated, computed properties memoize (aka cache) the value and only evaluate
    when the dependent observables change.
  prefs: []
  type: TYPE_NORMAL
- en: As you develop experience using MobX, you will realize that *computed properties*
    are possibly your best observable-friends.
  prefs: []
  type: TYPE_NORMAL
- en: Better syntax with decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of our examples so far have used the *ES5 API* of MobX. However, there is
    a special form of the API, which gives us a very convenient way of expressing
    the observables. This is made possible with the `@decorator` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'The decorator syntax is still a pending proposal (as of this writing) for inclusion
    in the JavaScript language standard. But that doesn''t stop us from using it,
    as we have **Babel** to help us out. By using the Babel plugin, `transform-decorators-legacy`,
    we can transpile the decorator syntax into regular ES5 code. If you are using
    TypeScript, you can also enable decorator support by setting your `{ experimentalDecorators:
    true}` compiler option in your `tsconfig.json`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The decorator syntax is *only available for classes* and can be used for class
    declarations, properties and methods. Here is an equivalent `Cart` observable,
    expressed with decorators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of decorators to *decorate* the observable properties. The default
    `@observable` decorator does deep observation on all the properties of the value.
    It is actually a shorthand for using `@observable.deep`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we have the `@observable.shallow` decorator, which is a *rough*
    equivalent of setting the `{ deep: false }` option on the observable. It works
    for objects, arrays, and maps. We will cover the more technically correct ES5
    equivalent of `observable.shallow` in [Chapter 4](part0065.html#1TVKI0-58c2559ca4304cecab9bc46f496bc070) ,
    *Crafting the Observable Tree*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The snippet below shows the `items` and `metadata` properties, marked as *shallow
    observables*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We will be covering a few more decorators in a later chapter, but we did not
    want to wait until then to discuss the decorator syntax. We definitely think you
    should pick decorators as your first choice for declaring observables. Note that
    they are only available inside classes. However, the vast majority of the time,
    you will be using classes to model your observable tree, so decorators greatly
    help in making it more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although you can change an observable directly, it is highly recommended that
    you use *actions* to do it. If you remember, in the previous chapter, we saw that
    actions are the ones that cause a state-change. The UI simply fires the actions
    and expects some observables to be mutated. Actions hide the details of how the
    mutation should happen or what observables should be affected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram below is a reminder that **UI** can modify the **State** only via
    an **Action**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Actions introduce *vocabulary* into the UI and give declarative names to the
    operations that mutate the state. MobX embraces this idea completely and makes
    actions a *first-class* concept. To create an action, we simply wrap the mutating
    function inside the `action()` API. This gives us back a function that can be
    invoked just like the original passed-in function. Take a look at this code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we have introduced two actions: `addItem()` and `removeItem()`,
    which add and remove an item to and from the `cart` observable. Since `action()` returns
    a function that forwards arguments to the passed-in function, we can invoke `addItem()` and
    `removeItem()` with the required arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Besides improving the readability of the code, actions also boost performance
    of MobX. By default, when you modify an observable, MobX will *immediately* fire
    a notification for the change. If you are modifying a bunch of observables together,
    you would rather fire the change notifications after all of them are modified.
    This would reduce the noise of too many notifications and also treat the set of
    changes as one *atomic transaction*. These are, in essence, the core responsibilities
    of an `action()`.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing the use of actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It should come as no surprise that MobX strongly recommends using *actions*
    for modifying observables. In fact, this can be made mandatory by configuring
    MobX to always enforce this policy, also called the **strict mode**. The `configure()`
    function can be used to set the `enforceActions` option to true. MobX will now
    throw an error if you try to modify an observable outside of an action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our previous example with `cart`, if we try to modify it *outside* an
    *action*, MobX will fail with an error, as you can see from the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one little thing to remember regarding the use of `configure({ enforceActions:
    true })`: It will only throw errors if there are observers watching the observables
    that you are trying to mutate. If there are no observers for those observables,
    MobX will safely ignore it. This is because there is no risk of triggering reactions
    too early. However, if you do want to be strict about this, you can also set `{
    enforceActions: ''strict'' }`. This will throw an error even if there are no observers
    attached to the mutating observables.'
  prefs: []
  type: TYPE_NORMAL
- en: Decorating actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The use of decorators is pervasive in MobX. Actions also get special treatment
    with the `@action` decorator to mark class methods as actions. With decorators,
    the `Cart` class can be written as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we used `@action.bound` for the `removeItem()` action.
    This is a special form that pre-binds the instance of the class to the method.
    This means you can pass around the reference to `removeItem()` and be assured
    that the `this` value always points to the instance of the Cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'A different way of declaring the `removeItem` action with a pre-bound `this`
    is with the use of class properties and arrow-functions. This can be seen in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, `removeItem` is a *class-property* whose value is an *arrow-function*.
    Because of the *arrow-function*, it binds to the *lexical* `this`, which is the
    instance of the `Cart`.
  prefs: []
  type: TYPE_NORMAL
- en: Reactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Reactions** can really change the world for your app. They are the side-effect
    causing behaviors that react to the changes in observables. Reactions complete
    the core triad of MobX and act as the observers of the observables. Take a look
    at this diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: MobX gives you three different ways to express your reactions or side-effects.
    These are `autorun()`, `reaction()`, and `when()`. Let's see each of these in
    turn.
  prefs: []
  type: TYPE_NORMAL
- en: autorun()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`autorun()` is a long-running side-effect that takes in a function (`effect-function`)
    as its argument. The `effect-function` function is where you apply all your side-effects.
    Now, these side-effects may depend on one or more observables. MobX will automatically
    keep track of any change happening to these *dependent* observables and re-execute
    this function to apply the side-effect. It''s easier to see this in code, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example we are logging an *observable* (`this.items.length`)
    to the console. The logging happens *immediately* and also any time the observable
    changes. This is the defining characteristic of `autorun()`; it runs immediately
    and also on every change to the dependent observables.
  prefs: []
  type: TYPE_NORMAL
- en: 'We mentioned earlier that `autorun()` is a long-running side-effect and continues
    as long as you don''t explicitly stop it. But then, how do you actually stop it?
    Well, the return-value of `autorun()` is a function that is in fact a `disposer-function`.
    By calling it, you can cancel the `autorun()` side-effect. Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we are storing the return-value of `autorun()` (a
    `disposer-function`) in a class property: `cancelAutorun`. By invoking it just
    after instantiating `Cart`, we have canceled the side-effect. Now `autorun()`
    only prints once, and never again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quick Reader Question: Why does it print only once? Since we are cancelling
    immediately, shouldn''t `autorun()` skip printing altogether? The answer to this
    is to refresh the core characteristic of `autorun`.'
  prefs: []
  type: TYPE_NORMAL
- en: reaction()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`reaction()` is yet another kind of reaction in MobX. Yes, the choice of the
    API name was intentional. `reaction()` is similar to `autorun()` but waits for
    a change in the observables before executing the `effect-function`. `reaction()`
    in fact takes two arguments, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`tracker-function` is where all the observables are tracked. Any time the tracked
    observables change, it will re-execute. It is supposed to return a value that
    is used to compare it to the previous run of `tracker-function`. If these return-values
    differ, the `effect-function` is executed.'
  prefs: []
  type: TYPE_NORMAL
- en: By breaking up the activity of a reaction into a change-detecting function (`tracker`
    function) and the `effect` function, `reaction()` gives us more fine-grained control
    over when a side-effect should be caused. It is no longer just dependent on the
    observables it is tracking inside the `tracker` function. Instead, it now depends
    on the data returned by the tracker function. The `effect` function receives this
    data in its input. Any observables used in the effect function are not tracked.
  prefs: []
  type: TYPE_NORMAL
- en: Just like `autorun()`, you also get a `disposer` function as the return-value
    of `reaction()`. This can be used to cancel the side-effect anytime you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can put this into practice with an example. Let''s say you want to be notified
    anytime an item in your `Cart` changes its price. After all, you don''t want to
    purchase something that suddenly shoots up in price. At the same time, you don''t
    want to miss out on a great deal as well. So, getting a notification when the
    price changes is a useful thing to have. We can implement this by using `reaction()`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we are setting up a price tracker in *comment 1*,
    as a *reaction to track price changes*. Notice that it takes two functions as
    inputs. The first function (`tracker-function`) finds the item with the given
    `name` and returns its price as the output of the `tracker` function. Any time
    it changes, the corresponding `effect` function is executed.
  prefs: []
  type: TYPE_NORMAL
- en: The console logs also print only when the price changes. This is exactly the
    behavior we wanted and achieved through a `reaction()`. Now that you are notified
    of the price changes, you can make better buying decisions.
  prefs: []
  type: TYPE_NORMAL
- en: A reactive UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the topic of reactions, it is worth mentioning that the UI is one of the
    most glorious reactions (or side-effect) you can have in an app. As we saw in
    the earlier chapter, *UI* depends on data and applies a transformation function
    to generate the visual representation. In the MobX world, this UI is also reactive,
    in the sense that it reacts to the changes in data and automatically re-renders
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: MobX provides a companion library called ***mobx-react*** that has bindings
    to React. By using a decorator function (`observer()`***) ***from `mobx-react`,
    you can transform a react component to observe the observables used in the `render()`
    function. When they change, a re-render of the react component is triggered. Internally,
    `observer()` creates a wrapper component that uses a plain `reaction()` to watch
    the observables and re-render as a side-effect. This is why we treat UI as being
    just another side-effect, albeit a very visible and obvious one.
  prefs: []
  type: TYPE_NORMAL
- en: 'A short example of using `observer()` is shown next. We are using a **stateless
    functional component,** which we are passing to the observer. Since we are reading
    the `item` observable, the component will now react to changes in `item`. After
    two seconds, when we update `item`, the `ItemComponent` will automatically re-render.
    Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We will cover `mobx-react` in [Chapter 3](part0055.html#1KEEU0-58c2559ca4304cecab9bc46f496bc070), *A
    React App with MobX*, and also throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: when()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, `when()` only executes the `effect-function` *when a condition
    is met* and automatically disposes the side-effect after that. Thus, `when()`
    is a one-time side-effect compared to `autorun()` and `reaction()`, which are
    long-running. The `predicate` function normally relies on some observables to
    do the conditional checks. If the observables change, the `predicate` function
    will be re-evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: '`when()` takes two arguments, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `predicate`function is expected to return a Boolean value. When it becomes
    `true`, the `effect` function is executed, and the `when()` is automatically disposed.
    Note that `when()` also gives you back a `disposer` function that you can call
    to prematurely cancel the side-effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this following code block, we are monitoring the availability of an item
    and notifying the user when it is back in stock. This is the case of a one-time
    effect that you don''t really have to continuously monitor. It''s only when the
    item count in the inventory goes above zero, that you execute the side-effect
    of notifying the user. Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`when()` here takes two arguments. The `predicate`function returns true when
    the `item.quantity` is greater than zero. The `effect` function simply notifies
    (via `console.log`) that the item is available in the store. When the predicate
    becomes true, `when()` executes the side-effect and automatically disposes itself.
    Thus, when we add two pairs of shoes into the inventory, `when()` executes and
    logs the availability.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we add one more pair of shoes into the inventory, no logs are
    printed. This is because at this time `when()` has been disposed and is no longer
    monitoring the availability of *Shoes*. This is the one-time effect of `when()`.
  prefs: []
  type: TYPE_NORMAL
- en: when() with a promise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a special version of `when()`, which takes only one argument (the
    `predicate` function), and gives back a promise instead of the `disposer` function.
    This is a nice trick where you can skip using the `effect` function and instead
    wait for `when()` to resolve before executing the effect. This is easier to see
    in code, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In *comment 1*, we are waiting for the availability of the item using `when()`
    that only takes the `predicate` function. By using the `async-await` operators
    to wait for the promise, we get clean, readable code. Any code that follows the
    `await` statement is automatically scheduled to execute after the promise resolves.
    This is a nicer form of using `when()` if you prefer *not* to pass an effect callback.
  prefs: []
  type: TYPE_NORMAL
- en: '`when()` is also very efficient and does not poll the `predicate` function
    to check for changes. Instead, it relies on the MobX reactivity system to re-evaluate
    the `predicate` function, when the underlying observables change.'
  prefs: []
  type: TYPE_NORMAL
- en: Quick recap on reactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MobX offers a couple of ways to execute side-effects, but you have to identify
    which one fits your needs. Here is a quick round-up that can help you in making
    the right choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have three ways of running side-effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`autorun( effect-function: () => {} )`: Useful for long-running side-effects.
    The `effect` function executes immediately and also anytime the dependent observables
    (used within it) change. It returns a `disposer`function that can be used to cancel
    anytime.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`reaction( tracker-function: () => data, effect-function: (data) => {} )`: Also
    for long-running side-effects. It executes the `effect` function only when the
    data returned by the `tracker` function is different. In other words, `reaction()`
    waits for a change in the observables before any side-effects are run. It also
    gives back a `disposer` function to cancel the effect prematurely.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`when( predicate-function: () => boolean, effect-function: () => {} )`: Useful
    for one-off effects. The `predicate` function is evaluated anytime its dependent
    observables change. It executes the `effect` function only when the `predicate`
    function returns `true`***.*** `when()` automatically disposes itself after running
    the `effect` function. There is a special form of `when()` that only takes in
    the `predicate` function and returns a promise. Use it with `async-await` for
    a simpler `when()`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The story of MobX revolves around observables. Actions mutate these observables.
    Derivations and Reactions observe and react to changes to these observables. Observables,
    actions, and reactions form the core triad.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen several ways to shape your observables with objects, arrays, maps,
    and boxed observables. Actions are the recommended way to modify observables.
    They add to the vocabulary of operations and boost performance by minimizing change
    notifications. Reactions are the observers that react to changes in observables.
    They are the ones causing side-effects in the app.
  prefs: []
  type: TYPE_NORMAL
- en: Reactions come in three flavors, `autorun()`, `reaction()`, and`when()`, and
    distinguish themselves as being long-running or one-time. `when()`, the only one-time
    effector, comes in a simpler form, where it can return a promise, given a `predicate`
    function.
  prefs: []
  type: TYPE_NORMAL
