- en: Searching for Questions with Elasticsearch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that users can ask and answer questions, we'll add a search functionality
    to Answerly to help users find questions. Our search will be powered by Elasticsearch.
    Elasticsearch is a popular open source search engine powered by Apache Lucene.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the chapter, we will do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Elasticsearch service to abstract our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bulk load existing `Question` model instances into Elasticsearch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a search view powered by Elasticsearch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save new models into Elasticsearch automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by setting up our project to use Elasticsearch.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with Elasticsearch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Elasticsearch is maintained by Elastic, though the server is open source. Elastic
    offers proprietary plugins to make running it in production easier. You can run
    Elasticsearch yourself or use a SaaS provider, such as Amazon, Google, or Elastic.
    In development, we'll run Elasticsearch using a Docker image provided by Elastic.
  prefs: []
  type: TYPE_NORMAL
- en: Elasticsearch is made up of zero or more indexes. Each index contains documents.
    Documents are the objects that one searches for. A document is made of up fields.
    Fields are indexed by Apache Lucene. Each index is also split up into one or more
    shards to make indexing and searching faster by distributing it across nodes in
    a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: We can interact with Elasticsearch using its RESTful API. Most requests and
    responses are in JSON by default.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's start by getting an Elasticsearch server running in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Starting an Elasticsearch server with docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest way to get an Elasticsearch server running is using the Docker
    image that Elastic provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain and start the Elasticsearch docker image, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command does four things, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It downloads the Elasticsearch 6.0 docker image from Elastic's servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It runs a container using the Elasticsearch 6.0 docker image as a single node
    cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It detaches (`-d`) the docker command from the running container (so that we
    can run more commands in our shell)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It opens ports (`-p`) `9200` and `9300` on the host computer and redirects them
    to the container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To confirm that our server is running, we can make the following request to
    the Elasticsearch server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When interacting with Elasticsearch yourself, always add the `pretty` `GET`
    parameter to have Elasticsearch print the JSON. However, don't use this parameter
    in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our Elasticsearch server, let's configure Django to know about
    our server.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Answerly to use Elasticsearch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we'll update our `settings.py` and `requirements.txt` files to work with
    Elasticsearch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update `django/config/settings.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These are custom settings that our app will use. Django has no built-in support
    for Elasticsearch. Instead, we’ll reference these settings in our own code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the Elasticsearch library to our `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is the official Elasticsearch Python library published by Elastic. This
    library offers a low-level interface that looks much like the RESTful API we can
    use with cURL. This means that we can easily build a query on the command line
    with cURL and then convert the JSON to a Python `dict`.
  prefs: []
  type: TYPE_NORMAL
- en: Elastic also offers a higher-level, more Pythonic API called `elasticsearch-dsl`.
    It includes a pseudo-ORM to write a more Pythonic persistence layer. This may
    be a good option if your project includes a lot of Elasticsearch code. However,
    the low-level API closely mirrors the RESTful API, making it easier to reuse code
    and get assistance from the Elasticsearch community.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's create the Answerly index in our Elasticsearch server.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Answerly index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create an index in Elasticsearch by sending a `PUT` request to our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Great! Now, we can load our existing `Question` model instances into our Elasticsearch
    index.
  prefs: []
  type: TYPE_NORMAL
- en: Loading existing Questions into Elasticsearch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding a search feature means that we will need to load our existing `Question` model
    instances into Elasticsearch. The simplest way to solve a problem like this is
    by adding a `manage.py` command. Custom `manage.py` commands combine the simplicity
    of writing a regular Python script with the power of the Django API.
  prefs: []
  type: TYPE_NORMAL
- en: Before we add our `manage.py` command, we will need to write our Elasticsearch-specific
    code. To separate the Elasticsearch code from our Django code, we'll add an `elasticsearch`
    service to the `qanda` app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Elasticsearch service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much of the code that we'll be writing in this chapter will be Elasticsearch
    specific. We don't want to put that code in our views (or `manage.py` commands)
    because that would introduce coupling between two unrelated components. Instead,
    we'll isolate the Elasticsearch code into its own module inside `qanda`, then
    have our views and `manage.py` command call our service module.
  prefs: []
  type: TYPE_NORMAL
- en: The first function we'll create will bulk load `Question` model instances into
    Elasticsearch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a separate file for our Elastic Service code. We''ll put our
    bulk insert code into `django/qanda/service/elasticsearch.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We've created two functions in our new service, `get_client()` and `bulk_load()`.
  prefs: []
  type: TYPE_NORMAL
- en: The  `get_client()`  function will return an `Elasticcearch` client configured
    with values from `settings.py`.
  prefs: []
  type: TYPE_NORMAL
- en: The `bulk_load()` function takes an iterable collection of `Question` model
    instances and loads them into Elasticsearch using the `streaming_bulk()` helper.
    Since `bulk_load()` expects an iterable collection, this means that our `manage.py`
    command will be able to send a `QuerySet` object. Remember that even though we're
    using a generator expression (which is lazy), our `questions` parameter will execute
    the full query as soon as we try to iterate over it. It's only the execution of
    the `as_elasticsearch_dict()` method that will be lazy. We'll write and discuss
    the new `as_elasticsearch_dict()` method after we're finished looking at the `bulk_load()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `bulk_load()` function uses the `streaming_bulk()` function. The
    `streaming_bulk()` function takes four arguments and returns an iterator for reporting
    the progress of the load. The four arguments are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An `Elasticsearch` client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `Question` generator (an iterator)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The index name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A flag telling the function not to raise an exception in case of an error (this
    will cause the `ok` variable to be `False` in case of errors)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The body of our `for` loop will log if there's an error when loading a question.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's give `Question` a method that can convert it into a `dict` that
    Elasticsearch can correctly process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the `Question` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `as_elasticsearch_dict()` method turns a `Question` model instance into
    a dict suitable for loading into Elasticsearch. The following are the three fields
    that we specially add to our Elasticsearch dict that aren’t in our model:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_id`: This is the ID of the Elasticsearch document. This doesn''t have to
    be the same as the model ID. However, if we want to be able to update the Elasticsearch
    document representing a `Question`, then we need to either store the document''s
    `_id` or be able to calculate it. For simplicity''s sake, we just use the same
    ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_type`: This is the document''s mapping type. As of Elasticsearch 6, Elasticsearch
    indexes are only able to store one mapping type each. So, all documents in the
    index should have the same `_type` value. Mapping types are similar to database
    schema''s, telling Elasticsearch how to index and track a document and its fields.
    One of the convenient features of Elasticsearch is that it doesn''t require us
    to define our type ahead of time. Elasticsearch dynamically builds the document''s
    type based on the data we load.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text`: This is a field we will create in the document. For search, it''s convenient
    to have the title and body of the document together in an indexable field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the fields in the dictionary are the same as the model's fields.
  prefs: []
  type: TYPE_NORMAL
- en: The presence of `as_elasticsearch_dict()` as a model method may seem problematic.
    Shouldn't the `elasticsearch` service know how to convert a `Question` in to an
    Elasticsearch dict? Like many design questions, the answer depends on a variety
    of factors. One factor that influenced me adding this method to the model is Django's
    *fat models* philosophy. Generally, Django encourages writing operations on the
    model as model methods. Also, the properties of this dict are coupled to the model's
    fields. Keeping both the lists of fields close together makes it easier for future
    developers to keep the two lists in sync. However, there may be projects and contexts
    in which the right thing is to put this kind of function in the service module.
    As Django developers, it's our job to evaluate the trade-offs and make the best
    decision for a particular project.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our `elasticsearch` service knows how to bulk add `Questions`, let's
    expose that functionality with a `manage.py` command.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a manage.py command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've used `manage.py` commands to start projects and apps as well as create
    and run migrations. Now, we'll create a custom command to load all the questions
    in our project into an Elasticsearch server. This will be a simple introduction
    to Django management commands. We'll discuss the topic more in [Chapter 12](ae91eed9-a595-4233-9215-6edc0c43918c.xhtml),
    *Building an API*.
  prefs: []
  type: TYPE_NORMAL
- en: A Django management command must be in an app's `manage/commands` subdirectory.
    An app may have multiple commands. Each command will be called the same as its
    filename. Inside the file should be a `Command` class that subclasses `django.core.management.BaseCommand`.
    The code that it should execute should be in the `handle()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our command in `django/qanda/management/commands/load_questions_into_elastic_search.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When designing commands, we should think of them as views, that is, *Fat models,
    thin commands*. This may be a bit more complicated, as there isn't a separate
    template layer for command-line output, but our output shouldn't be very complex
    anyway.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the `handle()` method gets a `QuerySet` of all `Questions` then
    passes it to `elasticsearch.bulkload`. We then print out whether it was successful
    or not using helper methods of `Command`. These helper methods are preferred over
    using `print()` directly because they make writing tests easier. We'll cover this
    topic in greater detail in our next chapter, [Chapter 8](20763fd1-7b33-43c7-bb4b-a5b919e84048.xhtml),
    *Testing Answerly*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With all the questions loaded, let’s confirm that they’re in our Elasticsearch
    server. We can access the Elasticsearch server using `curl` to confirm that our
    questions have been loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Assuming your ElasticSearch server is running on localhost on port 9200, the
    preceding command will return all the data in the `answerly` index. We can review
    the results to confirm that our data has been successfully loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some questions in Elasticsearch, let's add a search view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a search view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll create a view that will let users search our `Question`s
    and will display the matching results. To achieve this result, we will do the
    following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `search_for_question()` function to our `elasticsearch` service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make a search view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make a template to display search results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the base template to have search available everywhere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by adding search to our `elasticsearch` service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a search function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The responsibility for querying our Elasticsearch server for a list of questions
    matching the user's query lies with our `elasticsearch` service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a function that will send a search query and parse the results to
    `django/qanda/service/elasticsearch.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After we connect with the client, we will send our query and parse the results.
  prefs: []
  type: TYPE_NORMAL
- en: Using the client's `search()` method, we send the query as a Python `dict` in
    the Elasticsearch Query DSL (domain-specific language). The Elasticsearch Query
    DSL provides a language for querying Elastic search using a series of nested objects.
    When sent by HTTP, the query becomes a series of nested JSON objects. In Python,
    we use `dict` s.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we're using a `match` query on the `text` field of the documents
    in the Answerly index. A `match` query is a fuzzy query that checks each document’s
    `text` field to check whether it matches. The Query DSL also supports a number
    of configuration options to let you build more complex queries. In our case, we
    will accept the default fuzzy configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Next, `search_for_questions` iterates over the results. Elasticsearch returns
    a lot of metadata describing the number of results, the quality to the match,
    and the resulting document. In our case, we will return an iterator of the matching
    documents (stored in`_source`).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can get our results from Elasticsearch, we can write our `SearchView`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the SearchView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `SearchView` will take a `GET` parameter `q` and perform a search using
    our service module’s `search_for_questions()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll build our `SearchView` using a `TemplateView`. `TemplateView` renders
    a template in response to `GET` requests. Let''s add `SearchView` to `django/qanda/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll add a `path()` object routing to our `SearchView` to our URLConf
    in `django/qanda/urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our our view, let's build our `search.html` template.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the search template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll put our search template in `django/qanda/templates/qanda/search.html`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the body of the template, we have a search form that displays the query.
    If there was a `query`, then we will also show its results (if any).
  prefs: []
  type: TYPE_NORMAL
- en: We have seen many of the tags we are using here before (for example, `for`,
    `if`, `url`, and `markdownify`). A new filter that we will add is `truncate_words_html`,
    which receives text via the pipe and a number as an argument. It will truncate
    the text to the provided number of words (not counting HTML tags) and close any
    open HTML tags in the resulting fragment.
  prefs: []
  type: TYPE_NORMAL
- en: The result of this template is a list of hits that match our query with a preview
    of the text of each question. Since we stored the body, title, and ID of the question
    in Elasticsearch, we are able to show the results without querying our normal
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's update our base template to let users search from every page.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the base template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s update the base template to let users search from anywhere. To do that,
    we''ll need to edit `django/templates/base.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, we've got the search form in our header on every page.
  prefs: []
  type: TYPE_NORMAL
- en: With our search complete, let's make sure that every new question is automatically
    added to Elasticsearch.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Questions into Elasticsearch on save()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to perform an operation that is each time a model is saved to override
    the `save()` method that the model inherits from `Model`. We will provide a custom
    `Question.save()` method to make sure that `Question`s are added and updated in
    ElasticSearch as soon as they're saved by the Django ORM.
  prefs: []
  type: TYPE_NORMAL
- en: You can still perform an operation when a Django model is saved even if you
    don’t control the source code of that model. Django offers a signals dispatcher
    ([https://docs.djangoproject.com/en/2.0/topics/signals/](https://docs.djangoproject.com/en/2.0/topics/signals/))
    that lets you listen for events on models you don't own. However, signals introduce
    a lot of complexity into your code. It's *discouraged* to use signals unless there
    is no other option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our `Queston` model in `django/qanda/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `save()` method is called by `CreateView`, `UpdateView`, `QuerySet.create()`,
    `Manager.create()`, and most third-party code to persist a model. We make sure
    to call our `upsert()` method after the original `save()` method has returned
    because we want our model to have an `id` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's create our Elasticsearch service's `upsert` method.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring code coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Code coverage** measures which lines of code have been executed during a
    test. Ideally, by tracking code coverage, we can ensure which code is tested and
    which code is not. Since Django projects are mainly Python, we can use Coverage.py
    to measure our code coverage. The following are the two caveats for Django projects:'
  prefs: []
  type: TYPE_NORMAL
- en: Coverage.py won't be able to measure the coverage of our templates (they're
    not Python)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Untested class-based views seem more covered than they are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finding the coverage of a Django app is a two-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: Running our tests with the `coverage` command
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generating a coverage report using `coverage report` or `coverage html`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s run Django''s unit `test` command with `coverage` to take a look at
    the baseline for an untested project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command tells `coverage` to run a command (in our case, `manage.py
    test`) to record test coverage. We will use this command with the following two
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--branch`: To track whether both parts of branching statements were covered
    (for example, when an `if` statement evaluated to `True` and `False`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--source=qanda,user`: To record coverage only for the `qanda` and `user` modules
    (the code we wrote)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we''ve recorded the coverage, let''s take a look at the coverage of
    an app without any tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand how an untested project is 55% covered, let''s look at the coverage
    of `django/qanda/views.py`. Let''s generate an HTML report of the cover using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will create a `django/htmlcov` directory and HTML files
    that show the coverage report and a visual display of the code coverage. Let''s
    open `django/htmlcov/qanda_views_py.html` and scroll down to around line 72:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3856b79c-6ff4-43ef-8f73-f774db940d2c.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows that `DailyQuestionList` is completely covered
    but `QuestionDetailView.get_context_data()` is not. In the absence of any tests,
    the difference seems counterintuitive.
  prefs: []
  type: TYPE_NORMAL
- en: Let's remind ourselves how code coverage works. Code coverage tools check whether
    a particular line of code was *executed* during a test. In the preceding screenshot,
    the `DailyQuestionList` class and its members *were* executed. When the test runner
    starts, Django will build up the root URLConf much like when it starts for development
    or production. When the root URLConf is created, it imports the other referenced
    URLConfs (for example, `qanda.urls`). Those URLConfs, in turn, import their views.
    Views import forms, models, and other modules.
  prefs: []
  type: TYPE_NORMAL
- en: This import chain means that anything at the top level of a module will appear
    covered, regardless of whether it is tested. The class definition of `DailyQuestionList`
    was executed. However, the class itself was not instantiated, nor any of its methods
    executed. This also explains why the body of `QuestionDetailView.get_context_data()` is
    not covered. The body of `QuestionDetailView.get_context_data()` was never executed.
    This is a limitation of code coverage tools when working with declarative code
    such as `DailyQuestionList`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand some of the limitations of code coverage, let's write
    a unit test for `qanda.models.Question.save()`.
  prefs: []
  type: TYPE_NORMAL
- en: Upserting into Elasticsearch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An upsert operation will update an object if it exists and insert it doesn't.
    Upsert is a portmanteau of *update* and *insert*. Elasticsearch supports upsert
    operations out of the box, which can make our code much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add our `upsert()` method to `django/qanda/service/elastic_search.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We've defined our `get_client()` function in the preceding code block.
  prefs: []
  type: TYPE_NORMAL
- en: To perform an upsert, we use the `update()` method of Elasticsearch `client`.
    We provide the model as a document `dict` under the `doc` key. To force Elasticsearch
    to perform an upsert, we will include the `doc_as_upsert` key with a `True` value.
    One difference between the `update()` method and the bulk insert function we used
    earlier is that `update()` will not accept an implicit ID (`_id`) in the document.
    However, we provide the ID of the document to upsert as the `id` argument in our
    `update()` call. We also remove the `_type` key and value from the `dict` returned
    by the `question_model.as_elasticsearch_dict()` method and pass value (stored
    in the `doc_type` variable) as an argument to the `client.update()` method.
  prefs: []
  type: TYPE_NORMAL
- en: We return the response, though our view won't use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can test our view by running our development server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once our development server has started, we can ask a new question at [http://localhost:8000/ask](http://localhost:8000/ask)
    and then search for it at [http://localhost:8000/q/search](http://localhost:8000/q/search).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we're done adding search functionalities to Answerly!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've added search so that users can search for questions.
    We set up an Elasticsearch server for development using Docker. We created a `manage.py`
    command to load all our `Question`s into Elasticsearch. We added a search view
    where users could see the results of their question. Finally, we updated `Question.save`
    to keep Elasticsearch and the Django DB in sync.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll take an in-depth look at testing a Django app so that we can have
    confidence as we make future changes.
  prefs: []
  type: TYPE_NORMAL
