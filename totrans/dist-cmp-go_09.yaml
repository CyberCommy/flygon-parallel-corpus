- en: Foundations of Web Scale Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 5](../Text/Ch05.xhtml), *Introducing Goophr*, [Chapter 6](../Text/Ch06.xhtml),
    *Goophr Concierge*, and [Chapter 7](../Text/Ch07.xhtml), *Goophr Librarian* were
    about the design and implementation of a distributed search index system, starting
    from basic concepts to running individual components and verifying that they work
    as expected. In [Chapter 8](../Text/Ch08.xhtml), *Deploying Goophr*, we connected
    the various components with the help of **docker-compose** so that we could launch
    and connect all the components in an easy and reliable manner. We have achieved
    quite a lot in the past four chapters, but you may have noticed that we ran everything
    on a single machine, most likely our laptop or desktop.'
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we should next try to prepare our distributed system to work reliably
    under a heavy user load and expose it over the web for general use. However, the
    reality is that we will have to make a lot of upgrades to our current system to
    make it reliable and resilient enough to be able to work under real-world traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to look at various factors we should keep in
    mind while we try to design for the web. We will be looking at:'
  prefs: []
  type: TYPE_NORMAL
- en: Scaling a web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monolith app versus microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling a web application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we will not be discussing Goophr but instead a simple web application
    for blogging so that we can concentrate on scaling it for the web. Such an application
    may consist of a single server instance running the database and the blog server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scaling a web application is an intricate topic, and we will devote a lot of
    time to this very subject. As we shall see throughout this section, there are
    multiple ways to scale a system:'
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the system as a whole
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting up the system and scaling individual components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing specific solutions to better scale the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with the most basic setup, a single server instance.
  prefs: []
  type: TYPE_NORMAL
- en: The single server instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A single server setup will generally consist of:'
  prefs: []
  type: TYPE_NORMAL
- en: A web server to serve web pages and handle server-side logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A database to save all user data (blog posts, user login details, and so on)
    related to the blog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows what such a server would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74eb2b09-6ebf-4c93-9a5b-9db3bd3e2f4b.png)'
  prefs: []
  type: TYPE_IMG
- en: The figure shows a simple setup where the user interacts with the blog server,
    which will be interacting with a database internally. This setup of a database
    and blog server on the same instance will be efficient and responsive only up
    to a certain number of users.
  prefs: []
  type: TYPE_NORMAL
- en: As the system starts to slow down or storage starts to fill up, we can redeploy
    our application (database and blog server) on to a different server instance with
    more storage, RAM, and CPU power; this is known as **vertical scaling**. As you
    may suspect, this can be time consuming and an inconvenient way of upgrading your
    server. Wouldn't it be better if we could stave off this upgrade for as long as
    possible?
  prefs: []
  type: TYPE_NORMAL
- en: 'An important point to think about is that the issue might be due to any combination
    of the following factors:'
  prefs: []
  type: TYPE_NORMAL
- en: Out of memory due to the database or blog server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance degradation due to the web server or database requiring more CPU
    cycles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out of storage space due to the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling the complete application for any of the preceding factors isn't an optimal
    way to deal with the issue because we are spending a lot of money where we could
    have solved the issue with far fewer resources! So how should we fashion our system
    so that we can solve the right problem in the right manner?
  prefs: []
  type: TYPE_NORMAL
- en: Separate layers for the web and database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we take the three issues stated earlier, we can solve each of them in one
    or two ways. Let''s look at them first:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Issue #1**: Out of memory'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Due to the database**: Increase RAM for the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Due to the blog server**: Increase RAM for the blog server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Issue #2**: Performance degradation'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Due to the database***:* Increase the CPU power for the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Due to the blog server**: Increase the CPU power for the blog server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Issue #3**: Out of storage space'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Due to the database**: Increase the storage space for the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using this listing, we can upgrade our system as and when required for a particular
    problem we are facing. However, we first need to correctly identify the component
    that is causing the issue. For this reason, even before we start scaling our application
    vertically, we should separate our database from our web server as shown in this
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf3987e3-753d-44d1-844f-a0a4ac2ee2fc.png)'
  prefs: []
  type: TYPE_IMG
- en: This new setup with the database and the blog server on separate server instances
    would enable us to monitor which component is having an issue and vertically scale
    only that particular component. We should be able to serve a larger user traffic
    with this new setup.
  prefs: []
  type: TYPE_NORMAL
- en: However, as the load on the server increases, we might have other issues on
    our hands. For example, what would happen if our blog server were to become unresponsive?
    We would no longer be able to serve blog posts and no one would be able to post
    comments on said blog posts. This is a situation no one wants to face. Wouldn't
    it be nice if we could keep serving traffic even if the blog server were down?
  prefs: []
  type: TYPE_NORMAL
- en: Multiple server instances
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Serving a large traffic of users with a single server instance for our blog
    server or any application (business logic) server is dangerous because we are
    essentially creating a single point of failure. The most logical and simplest
    way to avoid such a situation is to have duplicate instances of our blog server
    to handle incoming user traffic. This approach of scaling a single server to multiple
    instances is known as **horizontal scaling**. However, this raises the question:
    how can we reliably distribute the traffic between the various instances of our
    blog server? For this we use a **load balancer**.'
  prefs: []
  type: TYPE_NORMAL
- en: The load balancer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A load balancer is a type of HTTP server responsible for distributing traffic
    (routing) to various web servers based on the rules defined by the developer.
    A load balancer, in general, is a very fast and specialized application. Trying
    to implement similar logic in a web server might not be optimal because the resources
    available to your web server have to be split between handling requests for your
    business logic and requests that need to be routed. Also, a load balancer provides
    us with a lot of features out of the box such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Load balancing algorithms**: The following are some algorithms for load balancing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Random**: Distribute randomly across the servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Round robin**: Distribute equally and sequentially across servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asymmetric load**: Distribute between servers in certain proportions. For
    example, for 100 requests, send 80 to Server A and 20 to Server B.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Least connections**: Send a new request to the server with the least number
    of active connections (an asymmetric load can also be integrated with least connections).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session persistence**: Imagine an e-commerce site where a user has added
    items to his shopping cart and the information about items in the cart is stored
    on, Server A. However, when the user wants to complete the purchase, the request
    is sent to a different server, Server B! This would be an issue for the user because
    all details related to his shopping cart is on Server A. Load balancers have the
    provision to ensure that such requests are redirected to the relevant server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP compression**: Load balancers also have the provision to compress the
    outgoing response using `gzip` so that it has less data to send to the user. This
    tends to greatly improve the user experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP caching**: For sites that serve more than REST API content, a lot of
    files can be cached because they do not change as often and cached content can
    be delivered much faster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on which load balancer is being used, they can provide a lot more
    features than the ones stated above. This should give an idea about the capability
    of a load balancer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows how a load balancer and multiple servers might work
    together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a855d3a-5d7c-4b76-9f86-d8b145ad2f71.png)'
  prefs: []
  type: TYPE_IMG
- en: The user's requests reach the load balancer, which then routes the request to
    one of the many instances of the blog server. However, note that even now we are
    using the same database for read and write operations.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-availability zones
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we talked about the single point of failure and why
    having multiple instances of the application server is a good thing. We can extend
    this concept further; what if we have all of our servers in one location and due
    to some major malfunction or outage, all of our servers go down? We will not be
    able to serve any user traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that having our servers in one location also creates a single point
    of failure. The solution for this would be to have application server instances
    available in multiple locations. Then the next question would be: how do we decide
    on the locations to deploy our servers? Should we deploy the servers to multiple
    locations within a single country or should we deploy them to multiple countries?
    We can rephrase the question using cloud computing terminology as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: We need to decide whether we want to deploy our servers to **multiple regions**
    or **multiple zones**, or perhaps a combination of both.
  prefs: []
  type: TYPE_NORMAL
- en: 'One important point to note is that deploying to multiple zones may lead to
    network delay and we may want to deploy to multiple regions first. However, before
    we deploy to multiple regions and zones, we need to make sure of two facts:'
  prefs: []
  type: TYPE_NORMAL
- en: Our website has heavy traffic that our single server setup is no longer able
    to handle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a significant chunk of users from another country, and it might be a
    good idea to deploy servers in a zone near them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we have given consideration to these factors and decided to deploy to
    additional zones and regions, our blogging system as a whole might look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8356325-b9ee-4215-9fbc-9bca596afbfa.png)'
  prefs: []
  type: TYPE_IMG
- en: The database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have been scaling the application/blog server and seen how to scale the server
    vertically and horizontally, and how to factor multiple zones and regions for
    high availability and performance of the overall system.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed in all of the previous designs that we still relied on
    a single database instance. By now, you may have realized that having a single
    instance of any service/server can become a single point of failure and may bring
    the system to a complete standstill.
  prefs: []
  type: TYPE_NORMAL
- en: The tricky part is that we cannot use the straightforward strategy of running
    multiple database instances as we did for the application server. We were able
    to use this strategy for application server because the application server is
    responsible for business logic and what little state it maintains within itself
    is temporary, while all vital and important information is being pushed to the
    database which forms the single source of truth, and, ironically, the single source
    of failure. Before we dig deeper into the complexity of scaling a database and
    the challenges that come along with it, let us first look at an important topic
    that needs to be addressed.
  prefs: []
  type: TYPE_NORMAL
- en: SQL versus NoSQL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For the uninitiated, databases come in two varieties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Relational databases**: These use SQL (with minor variations) for querying
    the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NoSQL databases**: These can store unstructured data and use the database
    specific query language'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational databases have been around for a long time now, and a lot of effort
    has been put into optimizing their performance and making them as robust as possible.
    However, the reliability and performance requires us to plan and organize our
    data into well-defined tables and relationships. Our data is bound to the schema
    of the database tables. Anytime we need to add more fields/columns to our table,
    we will have to migrate the table to a new schema, and this would require us to
    create migration scripts that take care of adding the new fields, and also to
    provide conditions and data to fill the newly created fields for the already existing
    rows in your table.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases tend to have a more free-form structure. We need not define
    schemas for our tables since data is stored as a single row/document. We can insert
    data of any schema into a single table and then query it. Given that the data
    is not confined to schema rules, we might end up inserting wrong or ill-formed
    data into our database. This means that we will have to deal with ensuring that
    we retrieve the correct data and also have to take precautions to ensure that
    data of different schemas do not crash the program.
  prefs: []
  type: TYPE_NORMAL
- en: Which type of database should we use?
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At first, one might be tempted to go with NoSQL because then we don't need to
    worry about structuring our data and join queries. However, it is important to
    realize that, instead of writing these queries in SQL form, we will instead be
    retrieving all the data into the user space, that is, the program, and then write
    the manual join queries within the program.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, if we rely upon relational databases, we can be assured of smaller
    storage space, more efficient join queries, and data with well-defined schemas.
    All relational databases and some of the NoSQL databases provide indexing, which
    also helps in optimizing for faster search queries. However, one major drawback
    of relational databases with using tables and joins is that, as the data grows
    bigger, it is possible that the joins will start getting slower. By this point,
    you will have a clear idea of which parts of your data can take advantage of NoSQL
    solutions, and you will start maintaining your data in a combination of SQL and
    NoSQL system.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, start with relational databases and, once you have a significant
    amount of data in your tables and no further database tuning can be done, then
    consider moving tables that really need the high performance of NoSQL datastores.
  prefs: []
  type: TYPE_NORMAL
- en: Database replication
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have established why we are opting to use a relational database,
    let us move onto the next question: how can we ensure that our database doesn''t
    become a single point of failure?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us first consider what are the consequences if a database fails:'
  prefs: []
  type: TYPE_NORMAL
- en: We cannot write new data to the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot read from the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of the two consequences, the latter is more critical. Consider our blogging
    application, while being able to write new blog posts is important, the vast majority
    of the users on our site will be readers. This is the norm for most everyday user-facing
    applications. Hence, we should try to ensure that we are always able to read data
    from the database even if we are no longer able to write new data to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Database replication and redundancy try to address these issues and, generally,
    the solutions are included as part of the database or a plugin. In this section,
    we shall discuss three strategies used for database replication:'
  prefs: []
  type: TYPE_NORMAL
- en: Master-replica replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Master-master replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failover cluster replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Master-replica replication
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This is the most straightforward method of replication. It can be explained
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We take a cluster of databases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/05818c20-497a-4808-b4cb-a9f2945a25cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Cluster of databases
  prefs: []
  type: TYPE_NORMAL
- en: 'Designate one of them as the master, and the remaining databases as replicas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b380eeef-f090-425c-a3d2-7ed6a47bc54c.png)'
  prefs: []
  type: TYPE_IMG
- en: DB-3 is designated as the master
  prefs: []
  type: TYPE_NORMAL
- en: 'All writes are performed to the master:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bd4944ec-aba0-413f-a338-a05e46b08a9b.png)'
  prefs: []
  type: TYPE_IMG
- en: Three writes are performed on the master
  prefs: []
  type: TYPE_NORMAL
- en: 'All reads are performed from the replicas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '>![](img/542a9156-003e-4c02-a8be-59d1ebd0b1de.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Reads performed from the replicas
  prefs: []
  type: TYPE_NORMAL
- en: 'The master ensures that all the replicas have the latest state which is the
    state of the master database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4b07728c-7236-4a5f-a59d-89839bd3fbb6.png)'
  prefs: []
  type: TYPE_IMG
- en: The master updates all the replicas with the latest update
  prefs: []
  type: TYPE_NORMAL
- en: 'Failure in master database still allows reads from replicant databases but
    writes are not possible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fd0bb311-32cb-47da-9bc6-ada8f6e5b8d9.png)'
  prefs: []
  type: TYPE_IMG
- en: Master failure; no writes, only reads
  prefs: []
  type: TYPE_NORMAL
- en: Master-master replication
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You may have noticed two issues with the master-replica setup:'
  prefs: []
  type: TYPE_NORMAL
- en: The master is used extensively for database writes, and hence is under constant
    duress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The issue of reads has been solved with replicas but the single point of failure
    for writes is still present
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Master-master replication tries to solve these issues by making every database
    a master. It can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We take a cluster of databases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/adc01142-21d5-48a6-8e21-7b4b31c39aab.png)'
  prefs: []
  type: TYPE_IMG
- en: Cluster of databases
  prefs: []
  type: TYPE_NORMAL
- en: 'We designate every database as a master:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f97237e8-3f47-4085-8663-16ca50668ab0.png)'
  prefs: []
  type: TYPE_IMG
- en: All databases are designated as a master
  prefs: []
  type: TYPE_NORMAL
- en: 'Reads can be performed from any of the masters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/04b29bf9-962f-48f5-86ed-d89509748c73.png)'
  prefs: []
  type: TYPE_IMG
- en: Reads performed on masters
  prefs: []
  type: TYPE_NORMAL
- en: 'Writes can be performed to any of the masters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5509f284-1103-4d8b-a789-3aea941a01f1.png)'
  prefs: []
  type: TYPE_IMG
- en: Writes made to DB-1 and DB-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Every master updates every other master with the writes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6dfbc383-b6d5-4444-9e53-e19d58552f2c.png)'
  prefs: []
  type: TYPE_IMG
- en: Database state synchronized across the masters
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, the state is maintained across all the databases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c78429cb-281f-4406-8e5d-2197b54b4e98.png)'
  prefs: []
  type: TYPE_IMG
- en: DB-1 failure, successful reads and writes
  prefs: []
  type: TYPE_NORMAL
- en: It may seem like this strategy works fine, but it has its own limitations and
    challenges; the major one being conflict resolution between writes. Here's a simple
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two master-master databases **DB-1** and**DB-2**,and both have the
    latest state of the database system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec564223-6449-4fd9-b4e3-ce86ad1af8bb.png)'
  prefs: []
  type: TYPE_IMG
- en: Latest state of DB-1 and DB-2
  prefs: []
  type: TYPE_NORMAL
- en: We have two simultaneous write operations to perform, so we send "Bob" to **DB-1**
    and "Alice" to **DB-2***.*
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39c2dd82-bfa7-4a4b-a150-22b179f055fb.png)'
  prefs: []
  type: TYPE_IMG
- en: Write "Bob" to DB-1 and Write "Alice" to DB-2
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that both databases have written the data to their tables, they need to
    update the other master with its own latest state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cda8ddb8-8758-407a-bf96-0e99ed0d29c0.png)'
  prefs: []
  type: TYPE_IMG
- en: States before DB synchronization
  prefs: []
  type: TYPE_NORMAL
- en: 'This will lead to conflict because in both tables, **ID# 3** is populated with **Bob** for
    **DB-1** and **Alice** for **DB-2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd911985-d51b-40a7-be08-2cb8302b61b8.png)'
  prefs: []
  type: TYPE_IMG
- en: Conflict while updating DB-1 and DB-2 states because ID# 3 is already populated.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, the master-master strategy would have in-built mechanisms to deal
    with these kinds of issues, but they may induce a performance penalty or other
    challenges. This is a complex subject and we have to decide on what trade-offs
    are worth making if we want to use master-master replication.
  prefs: []
  type: TYPE_NORMAL
- en: Failover cluster replication
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Master-replica replication allows us to have a simple setup for reads and writes
    at the potential risk of being unable to write to the master database. Master-master
    replication allows us to be able to read and write to the database even if one
    of the masters fail. However, the complexity of maintaining a consistent state
    across all the masters and the possible performance penalty can mean that it is
    not the ideal choice in all circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'The failover cluster replication tries to take the middle ground by providing
    features of both replication strategies. It can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We take a cluster of databases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A database is assigned as the master depending on the master selection strategy
    used, which can vary from database to database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The remaining databases are assigned as the replicas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The master is responsible for updating the replicas with the latest state of
    the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the master fails for some reason, a selection is made to assign one of the
    remaining databases as the new master.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So which replication strategy should we use? It would be best to start with
    the simplest one, that is, the master-replica strategy because this will cover
    most of initial needs with great ease. Let us now see what our application would
    look like if we used the master-replica strategy for database replication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ffbc1129-0b4a-4b21-b1ec-d3ccb95e4879.png)'
  prefs: []
  type: TYPE_IMG
- en: An application with the master-replica database setup
  prefs: []
  type: TYPE_NORMAL
- en: Monolith versus microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the new projects start out as a single codebase where all the components
    interact with one another via direct function calls. However, as the user traffic
    and codebase increases, we will start facing issues with the codebase. Here are
    a few possible reasons for this:'
  prefs: []
  type: TYPE_NORMAL
- en: Your codebase is growing in size and this means that it will take longer for
    any new developer to understand the complete system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a new feature will take longer because we have to make sure that the
    change doesn't break any of the other components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Redeploying code for every new feature might become cumbersome because of the
    following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment failed and/or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the redeployed components had an unexpected bug which crashed the program
    and/or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The build process may take longer because of a large number of tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling the complete application to support a CPU intensive component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microservices provide a solution to this by splitting up the major components
    of the application into separate smaller applications/services. Does this mean
    we should split our application from the start into microservices so that we don''t
    face this issue? That is one possible way of approaching this subject. However,
    there are certain drawbacks to this approach as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Too many moving parts**: Dividing each component into its own service means
    that we will have to monitor and maintain servers for each of them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased complexity**: Microservices increase the number of possible reasons
    for failure. Failures in a monolith may be limited to the server(s) going down
    or issues with code execution. However, with a microservice we have to:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify which component's server(s) went down or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If a component fails, identify the failing component and then further investigate
    whether the failure was due to:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faulty code or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to failure in one of the dependant components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Harder to debug the whole system**: The increased complexity described in
    the preceding points makes it harder to debug the complete system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have seen some of the pros and cons of microservices and monolith
    architecture, which one is better? The answer should be fairly obvious by now:'
  prefs: []
  type: TYPE_NORMAL
- en: Small to medium-sized codebases benefit from the simplicity offered by a monolith
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large codebases benefit from the granular control offered by the microservices
    architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that we should design our monolith codebase with the expectation
    that it might eventually grow to a very large size, and then we will have to refactor
    it into microservices. In order to make the task of refactoring the codebase into
    microservices as effortless as possible, we should identify the possible components
    as early as possible, and implement the interaction between them and the rest
    of the code using the **Mediator design pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: Mediator design pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mediator acts as an intermediary between components in the code, and this leads
    to very loose coupling between various components. This allows us to make minimal
    changes to the code, as we only need to change the interaction between the mediator
    and the component which is being extracted into its own microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example. We have a monolith, which is defined by **Codebase
    A**. It consists of five components—**Component 1** through **Component 5**. We
    realize that **Component 1** and **Component 2** rely on interacting with **Component
    5**, while **Component 2** and **Component 3** rely on **Component 4**. If **Component
    1** and **Component 2** were to directly call **Component 5**, and similarly **Component
    2** and **Component 4** were to directly call **Component 4**, then we would create
    tightly coupled components.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to introduce a function that takes input from the calling components
    and calls the necessary component as a proxy, and if all data were passed using
    well-defined structs, then we would have introduced the mediator design pattern.
    This can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/805a38af-f4cb-437e-95c5-0aaad75e2466.png)'
  prefs: []
  type: TYPE_IMG
- en: Components within a codebase connected via the mediator
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if a situation arises where we might need to separate one of the components
    into its own separate microservices, we only need to change the implementation
    of the proxy function. In our example, `Component 5` is segregated into its own
    separate microservice, and we have changed the implementation of the proxy function
    **mediator 1** to communicate with **Component 5** using HTTP and JSON instead
    of communicating via function calls and structs. This is illustrated in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3aeaa9a3-9b0c-4c7a-8831-29fc0e08ad24.png)'
  prefs: []
  type: TYPE_IMG
- en: Component separated into a microservice and the change in the mediator implementation
  prefs: []
  type: TYPE_NORMAL
- en: Deployment options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have looked at various strategies for scaling our application, different
    types of databases, how to structure our code, and finally how to use the mediator
    pattern to make the transition from monolith to microservices. However, we haven't
    discussed where we would be deploying said web application and databases. Let's
    take a brief look at the deployment landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Till the early 2000s, most servers were deployed on hardware owned by the companies
    writing the software. There would be dedicated infrastructure and a team to deal
    with this critical part of software engineering. This was mostly the subject of
    data centers.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the 2000s, companies began to realize that data centers could be
    abstracted away because most of the developers weren't interested in handling
    these problems. This allowed for cheaper and faster development and deployment
    of software, especially for web applications. Now, instead of buying hardware
    and space at a data center, the developers would be provided with server instances
    they could access via SSH. One of the most prominent companies in this field from
    the start was Amazon.com, Inc. This allowed them to expand their business beyond
    e-commerce.
  prefs: []
  type: TYPE_NORMAL
- en: 'These services also gave rise to the question: do developers need to install
    and maintain generic applications such as databases, load balancers, or other
    such services? The reality was that not all developers or companies wanted to
    be involved with maintaining these services. This created demand for ready-to-use
    application instances that would be maintained by the company selling these applications
    as a service.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many companies which initially started out as software companies that
    maintained their own data centers—Amazon, Google, and Microsoft to name a few
    examples—and they now boast a great set of such services for general consumption.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability of multiple instances
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The availability of the mentioned services improve our life significantly yet
    there is a lot of complexity involved with maintaining a plethora of applications
    running across multiple server instances. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: How can we update the server instances without bringing down the whole service?
    Can this be done with less effort?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there a reliable way to scale our application (vertically and horizontally)
    with ease?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given that all modern deployments make use of containers, we can make use of
    container orchestration software that helps with the maintainability issues. Kubernetes
    ([https://kubernetes.io/](https://kubernetes.io/)) and Mesos ([http://mesos.apache.org/](http://mesos.apache.org/))
    are examples of two such solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we took the example of a simple blogging application and showed
    how we can scale it to meet the demands of growing user traffic. We also looked
    at the complexity and strategies involved with scaling databases.
  prefs: []
  type: TYPE_NORMAL
- en: We then took a brief look at how to architect our codebase and what the trade-offs
    are that we might need to consider. Finally, we looked at one approach to easily
    refactor our codebase from a monolith into microservices.
  prefs: []
  type: TYPE_NORMAL
