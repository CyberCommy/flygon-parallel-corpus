- en: Hierarchical Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating hierarchical categories with django-mptt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a category administration interface with django-mptt-admin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering categories in a template with django-mptt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a single selection field to choose a category in forms with django-mptt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a checkbox list to choose multiple categories in forms with django-mptt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating hierarchical categories with django-treebeard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a basic category administration interface with django-treebeard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether you build your own forum, threaded comments, or categorization system,
    there will be a moment when you need to save hierarchical structures in a database.
    Although the tables of relational databases (such as MySQL and PostgreSQL) are
    flat, there is a fast and effective way to store hierarchical structures. It is
    called **Modified Preorder Tree Traversal** (**MPTT**). MPTT allows you to read
    tree structures without recursive calls to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, let''s get familiar with the terminology of tree structures. A tree
    data structure is a nested collection of **nodes**, starting at the **root** node
    and with references to **child** nodes. There are restrictions: for instance,
    no node should reference back to create a loop and no reference should be duplicated.
    The following are some other terms to remember:'
  prefs: []
  type: TYPE_NORMAL
- en: A parent is any node that has references to child nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Descendants** are nodes that can be reached by recursively traversing from
    a parent to its children. Therefore, a node''s descendants will be its child,
    the child''s children, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ancestors** are nodes that can be reached by recursively traversing from
    a child to its parent. Therefore, a node''s ancestors will be its parent, the
    parent''s parent, and so on up to the root.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Siblings** are nodes with the same parent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **leaf** is a node without children.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, I''ll explain how MPTT works. Imagine laying out your tree horizontally
    with the root node at the top. Each node in the tree has left and right values.
    Imagine them as small left and right handles on the left- and right-hand sides
    of the node. Then, you walk (traverse) around the tree counterclockwise, starting
    from the root node, and mark each left or right value that you find with a number:
    1, 2, 3, and so on. It will look similar to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4db12ec1-4fb9-4f86-9cf4-0daa2f13d6cb.png)'
  prefs: []
  type: TYPE_IMG
- en: In the database table of this hierarchical structure, you have a title, left
    value, and right value for each node.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you want to get the **subtree** of the **B** node with **2** as the
    left value and **11** as the right value, you will have to select all of the nodes
    that have a left value between **2** and **11**. They are **C**, **D**, **E**,
    and **F**.
  prefs: []
  type: TYPE_NORMAL
- en: To get all of the **ancestors** of the **D** node with **5** as the left value
    and **10** as the right value, you have to select all of the nodes that have a
    left value that is less than **5** and a right value that is more than **10**.
    These would be **B** and **A**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the number of the **descendants** for a node, you can use the following
    formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*descendants = (right - left - 1) / 2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the number of **descendants** for the **B** node can be calculated
    as shown in the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*(11 - 2 - 1) / 2 = 4*'
  prefs: []
  type: TYPE_NORMAL
- en: If we want to attach the **E** node to the **C** node, we will have to update
    the left and right values only for the nodes of their first common ancestor, the
    **B** node. Then, the **C** node will still have **3** as the left value; the
    **E** node will get **4** as the left value and **5** as the right value; the
    right value of the **C** node will become **6**; the left value of the **D** node
    will become **7**; the left value of the **F** node will stay at **8**; the others
    will also remain the same.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, there are other tree-related operations with nodes in MPTT. It might
    be too complicated to manage all of this by yourself for every hierarchical structure
    in your project. Luckily, there is a Django app called `django-mptt` that has
    a long history of handling these algorithms and provides a straightforward API
    to handle the tree structures. Another app, `django-treebeard`, has also been
    tried and tested and gained additional traction as a powerful alternative when
    it replaced MPTT in django CMS 3.1\. In this chapter, you will learn how to use
    these helper apps.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need the latest stable version of Python 3, MySQL, or PostgreSQL and
    a Django project with a virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: You can find all of the code for this chapter at the `ch08` directory of the
    GitHub repository, at: [https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: Creating hierarchical categories with django-mptt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To illustrate how to deal with MPTT, we will build on top of the `ideas` app
    from [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)*, Forms and Views*.
    In our changes, we will replace the categories with a hierarchical `Category`
    model and update the `Idea` model to have a many-to-many relationship with the
    categories. Alternatively, you can create the app from fresh, using only the content
    shown here, to implement a very basic version of the `Idea` model from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `django-mptt` in your virtual environment using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `categories` and `ideas` apps if you have not done so already. Add
    those apps as well as `mptt` to `INSTALLED_APPS` in the settings, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a hierarchical `Category` model and tie it to the `Idea` model,
    which will have a many-to-many relationship with the categories, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `models.py` file in the `categories` app and add a `Category` model
    that extends `mptt.models.MPTTModel` and
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CreationModificationDateBase`, defined in [Chapter 2](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)*,
    Models and Database Structure*. In addition to the fields coming from the mixins,
    the `Category` model will need to have a `parent` field of the `TreeForeignKey`
    type and a `title` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `Idea` model to include the `categories` field of the `TreeManyToManyField`
    type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Update your database by making migrations and running them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `MPTTModel` mixin will add the `tree_id`, `lft`, `rght`, and `level` fields
    to the `Category` model:'
  prefs: []
  type: TYPE_NORMAL
- en: The `tree_id` field is used as you can have multiple trees in the database table.
    In fact, each root category is saved in a separate tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `lft` and `rght` fields store the left and right values used in the MPTT
    algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `level` field stores the node's depth in the tree. The root node will be
    level 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through the `order_insertion_by` meta option specific to MPTT, we ensure that
    when new categories are added, they stay in alphabetical order by title.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides new fields, the `MPTTModel` mixin adds methods to navigate through
    the tree structure similar to how you navigate through DOM elements using JavaScript.
    These methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to access the ancestors of a category, use the following code. Here,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'the `ascending` parameter defines from which direction to read the nodes (the
    default is `False`), and the `include_self` parameter defines whether to include
    the category itself in `QuerySet` (the default is `False`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To just get the root category, use the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to get the direct children of a category, use the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To get all of the descendants of a category, use the following code. Here,
    the `include_self` parameter again defines whether or not to include the category
    itself in `QuerySet`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to get the descendant count without querying the database, use
    the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To get all siblings, call the following method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Root categories are considered siblings of other root categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'To just get the previous and next siblings, call the following methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, there are methods to check whether the category is root, child, or leaf,
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: All of these methods can be used either in views, templates, or management commands.
    If you want to manipulate the tree structure, you can also use the `insert_at()`
    and `move_to()` methods. In this case, you can read about them and the tree manager
    methods at [https://django-mptt.readthedocs.io/en/stable/models.html](https://django-mptt.readthedocs.io/en/stable/models.html).
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding models, we used `TreeForeignKey` and `TreeManyToManyField`.
    These are similar to `ForeignKey` and `ManyToManyField`, except that they show
    the choices indented in hierarchies in the administration interface.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that in the `Meta` class of the `Category` model, we order the categories
    by `tree_id` and then by the `lft` value to show the categories naturally in the
    tree structure.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a model mixin to handle creation and modification dates* recipe
    in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 2](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)*, Models and Database
    Structure*'
  prefs: []
  type: TYPE_NORMAL
- en: The *Creating a category administration interface with django-mptt-admin* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a category administration interface with django-mptt-admin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `django-mptt` app comes with a simple model administration mixin that allows
    you to create a tree structure and list it with indentation. To reorder trees,
    you need to either create this functionality yourself or use a third-party solution.
    One app that can help you to create a draggable administration interface for hierarchical
    models is `django-mptt-admin`. Let's take a look at it in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, set up the `categories` app as described in the previous, *Creating
    hierarchical categories with django-mptt* recipe. Then, we need to install the
    `django-mptt-admin` app by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the app in your virtual environment using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Put it in `INSTALLED_APPS` in the settings, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that the static files for `django-mptt-admin` are available to your
    project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create an `admin.py` file in which we will define the administration interface
    for the `Category` model. It will extend `DjangoMpttAdmin` instead of `admin.ModelAdmin`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The administration interface for the categories will have two modes: tree view
    and grid view. Your tree view will look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3cf0a708-a606-4aa8-9012-9bec7832fcd1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The tree view uses the **jqTree** jQuery library for node manipulation. You
    can expand and collapse categories for a better overview. To reorder them or change
    the dependencies, you can drag and drop the titles in this list view. During reordering,
    the **User Interface** (**UI**) looks similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b2d02dd-4565-49f8-9d5f-3516d165c675.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that any usual list-related settings, such as `list_display` or `list_filter`,
    will be ignored in the tree view. Also, any ordering driven by the `order_insertion_by`
    meta property will be overridden by manual sorting.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to filter categories, sort them by a specific field, or apply admin
    actions, you can switch to the grid view, which shows the default category change
    list, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af21708a-ced6-4258-8e5a-a78530d4f598.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating hierarchical categories with django-mptt* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a category administration interface with django-treebeard* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering categories in a template with django-mptt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have created categories in your app, you need to display them hierarchically
    in a template. The easiest way to do this with MPTT trees, as described in the
    *Creating hierarchical categories with django-mptt* recipe, is to use the `{%
    recursetree %}` template tag from the `django-mptt` app. We will show you how
    to do that in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure you have the `categories` and `ideas` apps. There, your `Idea` model should
    have many-to-many relation to the `Category` model, as per the *Creating hierarchical
    categories with django-mptt* recipe. Enter some categories in the database.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pass `QuerySet` of your hierarchical categories to the template and then use
    the `{% recursetree %}` template tag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a view that loads all of the categories and passes them to a template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a template with the following content to output the hierarchy of categories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a URL rule to show the view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The template will be rendered as nested lists, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb80e578-01f8-4373-831f-f04f41a5b866.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `{% recursetree %}` block template tag takes `QuerySet` of the categories
    and renders the list using the template content nested within the tag. There are
    two special variables used here:'
  prefs: []
  type: TYPE_NORMAL
- en: The `node` variable is an instance of the `Category` model whose fields or methods
    can be used to add specific CSS classes or HTML5 `data-*` attributes for JavaScript,
    such as `{{ node.get_descendent_count }}`, `{{ node.level }}`, or `{{ node.is_root
    }}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, we have a `children` variable that defines where the rendered child
    nodes of the current category will be placed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your hierarchical structure is very complex, with more than 20 levels, it
    is recommended to use the `{% full_tree_for_model %}` and `{% drilldown_tree_for_node
    %}` iterative tags or the non-recursive `tree_info` template filter.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on how to do this, refer to the official documentation
    at [https://django-mptt.readthedocs.io/en/latest/templates.html#iterative-tags](https://django-mptt.readthedocs.io/en/latest/templates.html#iterative-tags)[.](https://django-mptt.readthedocs.io/en/latest/templates.html#iterative-tags)
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using HTML5 data attributes* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating hierarchical categories with django-mptt* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating hierarchical categories with django-treebeard* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using a single selection field to choose a category in forms with django-mptt*
    recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a single selection field to choose a category in forms with django-mptt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What happens if you want to show category selection in a form? How will the
    hierarchy be presented? In `django-mptt`, there is a special `TreeNodeChoiceField`
    form field that you can use to show the hierarchical structures in a selected
    field. Let's take a look at how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start with the `categories` and `ideas` apps that we defined in the
    previous recipes. For this recipe, we will also need `django-crispy-forms`. Have
    a look at how to install it in the *Creating a form layout with django-crispy-forms*
    recipe in [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)*, Forms and
    Views*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s enhance the filter form for `ideas` that we created in the *Filtering
    object lists* recipe in [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)*,
    Forms and Views*, by adding a field for filtering by category:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `forms.py` file of the `ideas` app, create a form with a category field
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We should already have created `IdeaListView`, an associated URL rule, and
    the `idea_list.html` template to show this form. Make sure to render the filter
    form in the template using the `{% crispy %}` template tag, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The category selection drop-down menu will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a76c13c-f012-4740-945f-f1b1b723f074.png)'
  prefs: []
  type: TYPE_IMG
- en: '`TreeNodeChoiceField` acts like `ModelChoiceField`; however, it shows hierarchical
    choices as indented. By default, `TreeNodeChoiceField` represents each deeper
    level prefixed by three dashes, `---`. In our example, we have changed the level
    indicator to be four non-breaking spaces (the `&nbsp;` HTML entities) by passing
    the `level_indicator` parameter to the field. To ensure that the non-breaking
    spaces aren''t escaped, we use the `mark_safe()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Rendering categories in a template with django-mptt* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using a checkbox list to choose multiple categories in forms with django-mptt*
    recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a checkbox list to choose multiple categories in forms with django-mptt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When one or more categories need to be selected at once in a form, you can use
    the `TreeNodeMultipleChoiceField` multiple selection field that is provided by
    `django-mptt`. However, multiple selection fields (for example, `<select multiple>`)
    are not very user-friendly from an interface point of view, as the user needs
    to scroll and hold control or command keys while clicking to make multiple choices.
    Especially when there is a fairly large number of items to choose from, and the
    user wants to select several at once, or the user has accessibility handicaps,
    such as poor motor control, this can lead to a really awful user experience. A
    much better approach is to provide a checkbox list from which the user can choose
    categories. In this recipe, we will create a field that allows you to show the
    hierarchical tree structure as indented checkboxes in the form.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start with the `categories` and `ideas` apps that we defined in the
    previous recipes and the `core` app, which you should have in your project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To render an indented list of categories with checkboxes, we will create and
    use a new `MultipleChoiceTreeField` form field and create an HTML template for
    this field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The specific template will be passed to the `crispy_forms` layout in the form.
    To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `core` app, add a `form_fields.py` file and create a `MultipleChoiceTreeField`
    form field that extends `ModelMultipleChoiceField`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the new field with the categories to choose from in a new form for idea
    creation. Also, in the form layout, pass a custom template to the `categories`
    field, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a template for a Bootstrap-style checkbox list based on the `crispy`
    forms template, `bootstrap4/layout/checkboxselectmultiple.html`, as shown in the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new view for adding an idea, using the form we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the associated template to show the form with the `{% crispy %}` template
    tag, whose usage you can learn more about in the *Creating a form layout with
    django-crispy-forms* recipe in [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)*,
    Forms and Views*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a URL rule pointing to the new view, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Add rules to your CSS file to indent the labels using the classes generated
    in the checkbox tree field template, such as `.level-0`, `.level-1`, and `.level-2`,
    by setting the `margin-left` parameter. Make sure that you have a reasonable amount
    of these CSS classes for the expected maximum depth of trees in your context,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a result, we get the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7c8f727-c145-45f4-863a-a8805faf30ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Contrary to the default behavior of Django, which hardcodes field generation
    in Python code, the `django-crispy-forms` app uses templates to render the fields.
    You can browse them under `crispy_forms/templates/bootstrap4` and copy some of
    them to an analogous path in your project's template directory to overwrite them
    when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: In our idea creation and editing form, we pass a custom template for the `categories`
    field that will add the `.level-*` CSS classes to the `<label>` tag, wrapping
    the checkboxes. One problem with the normal `CheckboxSelectMultiple` widget is
    that when rendered, it only uses choice values and choice texts, whereas we need
    other properties of the category, such as the depth level. To solve this, we also
    created a custom `MultipleChoiceTreeField` form field, which extends `ModelMultipleChoiceField`
    and overrides the `label_from_instance()` method to return the category instance
    itself, instead of its Unicode representation. The template for the field looks
    complicated; however, it is mostly a refactored multiple checkbox field template
    (`crispy_forms/templates/bootstrap4/layout/checkboxselectmultiple.html`), with
    all of the necessary Bootstrap markup. We mainly just made a slight modification
    to add the `.level-*` CSS classes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a form layout with django-crispy-forms* recipe in [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml),
    *Forms and Views*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Rendering categories in a template with django-mptt* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using a single selection field to choose a category in forms* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating hierarchical categories with django-treebeard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several algorithms for tree structures, each with its own benefits.
    An app called `django-treebeard`, an alternative to `django-mptt` that is used
    by django CMS, provides support for three tree forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adjacency List** trees are simple structures, where each node has a parent
    attribute. Although read operations are fast, this comes at the cost of slow writes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nested Sets** trees and MPTT trees are the same; they structure nodes as
    sets nested beneath the parent. This structure also provides very fast read access
    at the cost of more expensive writing and deletion, particularly when writes require
    some particular ordering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Materialized Path** trees are built with each node in the tree having an
    associated path attribute, which is a string indicating the full path from the
    root to the node—much like a URL path indicates where to find a particular page
    on a website. This is the most efficient approach supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a demonstration of the support it has for all of these algorithms, we will
    use `django-treebeard` and its consistent API. We will extend the `categories`
    app from [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml), *Forms and Views*.
    In our changes, we will enhance the `Category` model with support for hierarchy
    via one of the supported tree algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `django-treebeard` in your virtual environment using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `categories` and `ideas` apps if you have not done so already. Add
    the `categories` app as well as `treebeard` to `INSTALLED_APPS` in the settings,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will enhance the `Category` model using the **Materialized Path** algorithm,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `models.py` file and update the `Category` model to extend `treebeard.mp_tree.MP_Node`
    instead of the standard Django model. It should also inherit from `CreationModificationDateMixin`,
    which we defined in [Chapter 2](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml), *Models
    and Database Structure*. In addition to the fields coming from the mixins, the
    `Category` model will need to have a `title` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This will require an update to the database, so next, we''ll need to migrate
    the `categories` app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'With the use of abstract model inheritance, treebeard tree nodes can be related
    to other models using standard relationships. As such, the `Idea` model can continue
    to have a simple `ManyToManyField` relation to `Category`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `MP_Node` abstract model provides the `path`, `depth`, and `numchild` fields,
    as well as the `steplen`, `alphabet`, and `node_order_by` attributes, to the `Category`
    model as necessary for constructing the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: The `depth` and `numchild` fields provide metadata about a node's location and
    descendants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `path` field is indexed, enabling database queries against it using `LIKE`
    to be very fast.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `path` field is made up of fixed-length encoded segments, where the size
    of each segment is determined by the `steplen` attribute value (which defaults
    to 4), and the encoding uses characters found in the given `alphabet` attribute
    value (defaults to Latin alphanumeric characters).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `path`, `depth`, and `numchild` fields should be treated as read-only. Also,
    `steplen`, `alphabet`, and `node_order_by` values should never be changed after
    saving the first object to a tree; otherwise, the data will be corrupted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides new fields and attributes, the `MP_Node` abstract class adds methods
    for navigation through the tree structure. Some important examples of these methods
    are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to get the **ancestors** of a category, which are returned as `QuerySet`
    of ancestors from the root to the parent of the current node, use the following
    code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To just get the `root` category, which is identified by having a depth of 1,
    use the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to get the direct `children` of a category, use the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To get all `descendants` of a category, returned as `QuerySet` of all children
    and their children, and so on, but not including the current node itself, use
    the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to get just the `descendant` count, use the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To get all `siblings`, including the reference node, call the following method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Root categories are considered to be siblings of other root categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'To just get the previous and next `siblings`, call the following methods, where
    `get_prev_sibling()` will return `None` for the leftmost sibling, as will `get_next_sibling()`
    for the rightmost one:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, there are methods to check whether the category is `root`, `leaf`, or
    related to another node:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe only scratched the surface of the power of `django-treebeard` and
    its Materialized Path trees. There are many other methods available for the navigation
    as well as the construction of trees. In addition, the API for Materialized Path
    trees is largely identical to those for Nested Sets trees and Adjacency List trees,
    which are available simply by implementing your model with the `NS_Node` or `AL_Node`
    abstract classes, respectively, instead of using `MP_Node`.
  prefs: []
  type: TYPE_NORMAL
- en: Read the `django-treebeard` API documentation for a complete listing of the
    available properties and methods for each of the tree implementations at [https://django-treebeard.readthedocs.io/en/latest/api.html](https://django-treebeard.readthedocs.io/en/latest/api.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)*, Forms and Views*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating hierarchical categories with django-mptt* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a category administration interface with django-treebeard* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a basic category administration interface with django-treebeard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `django-treebeard` app provides its own `TreeAdmin`, extending from the
    standard `ModelAdmin`. This allows you to view tree nodes hierarchically in the
    administration interface, with interface features dependent upon the tree algorithm
    used. Let's take a look at this in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, set up the `categories` app and `django-treebeard` as described in the
    *Creating hierarchical categories with django-treebeard* recipe earlier in this
    chapter. Also, make sure that the static files for `django-treebeard` are available
    to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create an administration interface for the `Category` model from the `categories`
    app that extends `treebeard.admin.TreeAdmin` instead of `admin.ModelAdmin` and
    uses a custom form factory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The administration interface for the categories will have one of two modes,
    dependent upon the tree implementation used. For Materialized Path and Nested
    Sets trees, an advanced UI is provided, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d89ba79-960b-472b-8ab1-99bf15903f13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This advanced view allows you to expand and collapse categories for a better
    overview. To reorder them or change the dependencies, you can drag and drop the
    titles. During reordering, the user interface looks similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9dffa371-4bb5-40cb-b241-343cc47067ee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you apply filtering or sorting of categories by a specific field, the advanced
    functionality is disabled, but the more attractive look and feel of the advanced
    interface remains. We can see this intermediate view here, where only categories
    created in the Past 7 days are shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51dcef77-3e70-4410-9687-7e56147148e2.png)'
  prefs: []
  type: TYPE_IMG
- en: However, if your tree uses the Adjacency List algorithm, a basic UI is provided
    with less aesthetic presentation and none of the toggling or reordering functionality
    given in the advanced UI.
  prefs: []
  type: TYPE_NORMAL
- en: More details about `django-treebeard` administration, including a screenshot
    of the basic interface, can be found in the documentation at: [https://django-treebeard.readthedocs.io/en/latest/admin.html](https://django-treebeard.readthedocs.io/en/latest/admin.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating hierarchical categories with django-mptt* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating hierarchical categories with django-treebeard* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a category administration interface with django-mptt-admin* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
