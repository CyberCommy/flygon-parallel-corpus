- en: '*Chapter 7*: Assessing and Pentesting Lambda Services'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambda services run code that can later respond to events and other tasks within
    the Lambda environment as needed. These events and tasks are anything that occurs
    within the AWS environment – HTTP requests, modifications to S3 buckets, and new
    EC2 instances being brought up, for instance. This makes Lambda an essential service
    when it comes to setting up and extending a network and its services for an organization.
    However, Lambda does present some issues, such as creating weak restrictions on
    accessing Lambda, vulnerable functions that can carry out unauthorized actions,
    and rules built within the Lambda policies that allow exploitation to occur.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will focus on how vulnerability discovery in Lambda can lead to
    exploiting services and discovering internal processes and objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and setting up Lambda services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digging into Lambda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding misconfigurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Popping reverse shells with Lambda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code used in this chapter is available at the following link: [https://github.com/PacktPublishing/AWS-Penetration-Testing/tree/master/Chapter%207:%20Assessing%20and%20Pentesting%20Lambda%20Services](https://github.com/PacktPublishing/AWS-Penetration-Testing/tree/master/Chapter%207:%20Assessing%20and%20Pentesting%20Lambda%20Services).'
  prefs: []
  type: TYPE_NORMAL
- en: You will also need Kali Linux on an EC2 instance with a public DNS name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/35XHn7Q](https://bit.ly/35XHn7Q)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and setting up a Lambda service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to Lambda, where your code is executed on an easily run and managed
    server. Lambda is an excellent way for companies to simplify things for ops and
    devs within their organizations due to how Lambda substantially scales and automates
    infrastructure. It allows code to be executed only when it needs to be executed
    and can help automate other services so that you don't have to worry about all
    the upkeep!
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how we can set up a Lambda function!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Lambda function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lambda functions are much like Python functions as they execute the code that
    is built within them, not outside them. In Python, this is what we call **internal**
    and **global** syntax. The internal syntax is the code that is built within the
    function and can only run within the function, whereas global syntax can run outside
    the function. Lambda functions run everything within the function. These functions
    are used to automate, scale, and do everything in between. While we aren''t going
    to look at the various reasons for using Lambda functions, you can find plenty
    of resources on Amazon about the possibilities of Lambda. To find out more, check
    out this AWS resource for extensive information on AWS Lambda: [https://docs.aws.amazon.com/lambda/latest/dg/welcome.html](https://docs.aws.amazon.com/lambda/latest/dg/welcome.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's log back in to our AWS console and pin the Lambda dashboard shortcut to
    our main dashboard. Having the Lambda function icon pinned will make it easier
    for us to reference the Lambda section a little more quickly, because we won't
    have to scroll through all the services when locating Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps help us create a Lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the AWS console and search for `Lambda`:![Figure 7.1 – Pinning Lambda
    to AWS console
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.01_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Pinning Lambda to AWS console
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the Lambda shortcut, go ahead and click on it; let''s get started
    with making a function that we can test. When you get into the Lambda dashboard,
    click on `testFunction`. The **Runtime** option will use **Python 3.6**, which
    will be the environment for the code we write:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Creating a Lambda function from scratch'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.02_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – Creating a Lambda function from scratch
  prefs: []
  type: TYPE_NORMAL
- en: Upon completion, you'll be shown where you can save and "test" your function.
    While it is essential to look at portions within the function configuration manager,
    we won't worry about that too much right now because it doesn't have much to do
    with what we are doing. The important part is that we understand where and how
    to set up Lambda within our AWS console – as we just did and will be doing more
    of throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more on Lambda, take a look at the AWS docs: [https://docs.aws.amazon.com/lex/latest/dg/gs-bp-create-lambda-function.html](https://docs.aws.amazon.com/lex/latest/dg/gs-bp-create-lambda-function.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take this knowledge a little bit further in the next section and start
    looking at how we can create more with Lambda, as well as looking at how security
    engineers and pentesters use certain techniques to find misconfigurations within
    Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Digging into Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have had a brief introduction to what Lambda is and how to set up
    our own Lambda service, it's time we started looking at some of the security issues
    with Lambda. You may see some of them during an actual pentesting engagement.
    When it comes to AWS, one of the most significant issues I have seen as a pentester
    is policy issues associated with Lambda. Policies are what restrict and allow
    access to resources, similar to what we looked at in [*Chapter 4*](B15630_04_Final_ASB_ePub.xhtml#_idTextAnchor171)*,
    Exploiting S3 Buckets*. We are going to be doing something using the same *methodology*
    within this section, but we will be looking at misconfigurations with Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You'll begin to notice that, while the target differs in each chapter in this
    book, the methodology stays more or less the same, because we use the same steps
    to extract results from our targets.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin to move forward with more concepts and start building some stuff
    in Lambda. Let's start by making a Lambda function that works with S3.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Lambda function that is compatible with S3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are just going to continue building. It's important that
    we understand the Lambda service and what it is capable of. In this case, it is
    capable of linking together services that could be potential **pivot** points
    during a pentest.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Pivoting is the process of performing lateral movements in an environment after
    gaining access.
  prefs: []
  type: TYPE_NORMAL
- en: What we are going to do here is start looking at how Lambda and S3 work together,
    and then we can look at some misconfigurations that can lead to some downfalls
    if not mitigated properly. It's essential that we understand how systems are created
    before we exploit them. Doing so allows us to be able to take a "hands-on" approach
    to mitigating these issues, and it also helps us understand how to flow break
    on a first-hand basis between various services such as S3 and Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an idea of what to expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create an S3 bucket**: This bucket will be linked to the Lambda function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Create a Lambda function**: The Lambda function will be integrated as a trigger
    for the S3 bucket.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Integrate the function with S3**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Begin exploring** what we created from a pentesting point of view.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s begin! Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To begin, we will create our S3 bucket with the AWS command line, and verify
    that our bucket was created by viewing it from the AWS console – this is best
    practice in my opinion. Make sure you have your AWS ID and AWS secret for your
    account at hand. Once you have your credentials, log in to your AWS environment
    using the `aws configure` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need help locating your keys, here is a great reference that you can
    use for help: [https://aws.amazon.com/blogs/security/how-to-find-update-access-keys-password-mfa-aws-management-console/](https://aws.amazon.com/blogs/security/how-to-find-update-access-keys-password-mfa-aws-management-console/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you''re in the environment, let''s get started and create a bucket!
    Using the command line, use the following command to make a bucket that we will
    store in our AWS environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You'll need to use your own unique naming scheme for the bucket name. Also,
    if you don't specify a region, it will be placed in the **US East** region by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve finished creating the bucket with the command line, log in to
    your AWS console and verify that the bucket was created. We can verify this by
    checking the S3 bucket dashboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Created S3 bucket for Lambda'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.03_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – Created S3 bucket for Lambda
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our bucket set up, it's time to move on over and make another
    Lambda function that we can attach our new bucket to through a trigger. This bucket
    will be a little different from the first Lambda function we created, but now
    you know the basic methodology of setting up a Lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by making a new function and calling it `s3lambda`. Remember that
    you can only use numbers and lowercase letters! For **Runtime**, select the current
    version of Python. For this example, we are using Python 3.8\. Before we click
    **Create function**, we do need to do a couple of other things with our Lambda
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to create a basic role of permissions that will be associated with
    our Lambda function. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the `s3_pentesting_lambda`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '--**Policy templates**: **Amazon S3 object read-only permissions** and **AWS
    Config Rules permissions**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Creating a new function for S3'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.04_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – Creating a new function for S3
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to go ahead and **create a trigger** in the Lambda function.
    This function is triggered by things going on within the Lambda environment. Click
    on **Add trigger** to get started, and select **S3** Link the bucket we made titled
    **pentestawslambda** and save:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Creating an S3 trigger'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.05_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – Creating an S3 trigger
  prefs: []
  type: TYPE_NORMAL
- en: Great job – we've created a new Lambda function that links with triggers! It
    is important to understand that Lambda can link to other environments, because
    you may come across it during a real pentest. If you find vulnerable Lambda functions
    connected to other services, ensure that you detail out the issues and how the
    vulnerable Lambda function may make other services weaker.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of vulnerabilities derived from misconfigurations, let's move forward
    and discuss misconfigurations within Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding misconfigurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finding misconfigurations in weak policies is one of the more important portions
    of pentesting AWS services such as Lambda and S3\. Due to the security already
    being "built in" within the services, a lot of the issues presented in Lambda
    are due to misconfigurations on the user side of things. That does not mean that
    mistakes aren't made and that there couldn't be inherent flaws within Lambda;
    however, for sake of argument, we will be looking at its configurations.
  prefs: []
  type: TYPE_NORMAL
- en: A **misconfiguration** – for Lambda policy – occurs when a certain attribute
    is set in a "loose" manner. The word "loose" means that the policy allows more
    than was intended. These policies are what allow unauthorized individuals to view
    information that was not intended for their viewing, or worse, allow malicious
    vectors to view and exfiltrate that data.
  prefs: []
  type: TYPE_NORMAL
- en: '`List`, `Read`, `Write`, `Permissions management`, or `Tagging`. Actions noted
    as `"*"` in the actions for a policy mean that anyone can execute actions on the
    service, which is never good!'
  prefs: []
  type: TYPE_NORMAL
- en: So, what makes these loose policies, and how do we find them in Lambda? That's
    what we are about to discover. Moreover, we are going to do that by using the
    tools built into the AWS CLI.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, we'll start looking at the bucket we made with S3\. Recall that we
    set some pretty "loose" permissions when creating the Lambda function and integrating
    it with the bucket. Let's take a look at how easily and quickly that can escalate
    to something it wasn't intended for.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: We will be doing both Lambda and S3 security checks as we assess the Lambda
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving forward, let''s query the policy of the Lambda function that we created.
    This will list the attributes of the Lambda function for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the layout of the policy is pretty straightforward. However,
    if you take a closer look, you''ll notice something interesting about this function.
    Before we keep going, let''s have a close look at the function. If we were on
    a pentest and pulled something similar to this policy, we would conclude the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Allow` action for **invoking** the function is allowed. While this is good,
    we typically don't want to let anyone do this. Allowing anyone to invoke can create
    big issues later down the line, because if someone were to compromise the internal
    AWS network, they could essentially continue to run the Lambda function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also see the `pentestawslambda` S3 bucket in the policy. While this is more
    informational, it lets us know the full URL of the S3 bucket. An attacker could
    use this information to discover more about the S3 bucket, or to discover even
    more buckets that could be in that environment. Therefore, access controls such
    as IAM policies are crucial in only letting those with need-to-know access be
    able to access services within AWS environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know a little more about how to pentest Lambda and what to look
    out for, let's take a different approach and look at how we can get persistent
    access within a Lambda environment.
  prefs: []
  type: TYPE_NORMAL
- en: Popping reverse shells with Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final section of this chapter covers one of my favorite parts of pentesting.
    This section is going to walk us through setting up a vulnerable Lambda function
    and then using that function to initiate a reverse connection on our pentesting
    machine. For this section, we will need to use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Kali Linux on an EC2 instance with a public DNS name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Lambda function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you are using an EC2 instance with a public DNS. The Lambda function
    will need to connect to that public DNS.
  prefs: []
  type: TYPE_NORMAL
- en: The coolness of reverse shells
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Getting a "shell" is one of the most rewarding parts of pentesting. Being able
    to get a reverse shell means that you were able to successfully exploit a target
    and get persistence on that machine (persistence being a terminal connection on
    that machine). However, it is more than just a connection; it also highlights
    issues within the tested environment. For example, a server that calls out to
    the web may have rules that allow various outgoing connections that you usually
    would not see. This allows reverse shells to go out to the public.
  prefs: []
  type: TYPE_NORMAL
- en: Shells for pentesting?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A client may want you to test the monitoring and detection of their security.
    Creating a vulnerable Lambda function that makes calls inside and outside the
    network is a fantastic way to test companies' monitoring practices and solutions
    and have some fun with Lambda at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a shell is much more than *just* getting a shell – it tests monitoring,
    firewall rules, and general security posture. During a pentest, if you are able
    to get a reverse shell outside the network using a vulnerable Lambda function,
    it can be assumed that other vulnerabilities within the network could use the
    same route to call outside the network.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know more about reverse shells, let's check out how we can set up
    a vulnerable Lambda function that can make callbacks to us and allow remote access
    to a Lambda environment.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Before moving forward, it's essential to know that Lambda does bill by the millisecond.
    If you continuously run Lambda functions, you will be charged for them.
  prefs: []
  type: TYPE_NORMAL
- en: Time for the shell!
  prefs: []
  type: TYPE_NORMAL
- en: The ethical hacking game plan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get our shell, now that we understand a little background about shells
    and their impact on pentesting. We will take a look at the order of events that
    are going to occur before actually executing them. When performing an attack path,
    it can be good practice to have your game plan laid out before executing:'
  prefs: []
  type: TYPE_NORMAL
- en: Start up an EC2 instance with a public DNS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a vulnerable Lambda function that will call back to the public DNS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start a listener on the EC2 instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test and run the vulnerable Lambda function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get a shell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting a shell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have a game plan, let''s move forward and start up the EC2 instance
    that we created earlier. Once that is up and running, go ahead and log in to our
    Lambda dashboard. Now let''s look at how we execute this by moving forward with
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From here we will click the **Create function** button to get started:![Figure
    7.6 – Creating another function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.06_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – Creating another function
  prefs: []
  type: TYPE_NORMAL
- en: Once you have logged in, create a new function and name it `LambdaShell` and
    ensure that **Python 2.7** is selected. The role we created will work for this
    example:![Figure 7.7 – Creating a function for a reverse shell
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.07_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – Creating a function for a reverse shell
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to start setting up our function to create a reverse connection
    to the EC2 instance. I set up a GitHub repository from which we can pull the code:
    [https://github.com/PacktPublishing/AWS-Penetration-Testing/blob/master/Chapter%207:%20Assessing%20and%20Pentesting%20Lambda%20Services/Lambda_Shell.txt](https://github.com/PacktPublishing/AWS-Penetration-Testing/blob/master/Chapter%207:%20Assessing%20and%20Pentesting%20Lambda%20Services/Lambda_Shell.txt).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code that you put in should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to make sure that the function does not time out too quickly.
    By default, the function should be set to time out after about 3 seconds or so.
    We need to establish persistence, so we can go ahead and set the timeout to about
    `5` minutes – feel free to set it longer if you like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The maximum time allowed for Lambda functions is `15` minutes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Setting the shell timeout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.08_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8 – Setting the shell timeout
  prefs: []
  type: TYPE_NORMAL
- en: Next, you'll need to SSH into your Kali machine and set up a `su -` command
    to switch over to the `sudo` before every command, since you'll be running as
    the root account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next command sets up the **netcat** listener that we will use to **listen**
    for incoming connections from our target **Lambda service**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We should have our listener standing by and our function ready to test. Now
    comes the time when we get our reverse shell and gain some persistence in the
    Lambda environment. To execute, click the **Test** button in the top-right corner.
    You'll be prompted with a window that displays **Configure test event** – go ahead
    and click **Create** to move forward by clicking **Test** again. Note that before
    clicking **Test**, you will be given an event template with three keys. Leave
    those as default:![Figure 7.9 – Configuring the test event before executing the
    function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.09_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.9 – Configuring the test event before executing the function
  prefs: []
  type: TYPE_NORMAL
- en: 'After you click the **Test** button, you''ll see that the function is running
    within the dashboard. Now move back over to the Terminal you have on the Kali
    machine. You''ll be greeted with a reverse connection on the Lambda instance!
    Feel free to run some Linux commands in your shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Obtaining a reverse shell'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.10_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.10 – Obtaining a reverse shell
  prefs: []
  type: TYPE_NORMAL
- en: Check it out! We have consistent access to the Lambda environment! While this
    is a cool and fun example, we need to know some of the underlying problems and
    why we would log this during a pentest. Let's say we were testing a Lambda environment
    for weak policies. A policy should not be able to allow pentesters to execute
    calls outside the Lambda environment as we did – remember, we went to a public
    DNS, which means we went outside the VPC!
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so we did all this from the GUI within the AWS console, which was fun
    and pretty cool. Let's take a quick look at a more practical way – using the AWS
    CLI. We will assume that credentials have been compromised and that the function
    is ready to go for us.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking with AWS CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our function in the environment, let''s see how we could use
    this for persistence only using our Kali Linux machine that is hosted on our public
    EC2 instance. To start, make sure you''re logged in to Kali via SSH and run `netcat`
    in the background by putting `&` at the end of the command. Running the command
    in the background allows you to still use the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now your listener is set up in the background and ready to go. We need to be
    configured to the AWS environment before we can execute the connection. Type `aws
    configure` in your Terminal and ensure that you use the ID and secret key that
    we have used in previous chapters. Once set to the environment, run the following
    command to initiate a shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'You may need to install the AWS CLI on your Kali instance. To install the AWS
    CLI, run the following command: `$ apt-get install awscli -y`.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, getting a shell in Lambda can be fun, but it can also be dangerous
    for unsuspecting businesses. A great way to combat this is deploying monitoring
    solutions within a network – devices such as network prevention and detection
    systems that have egress rules that detect malformed traffic going out of the
    network, as well as ingress rules that look at packets coming in. In regard to
    AWS, **CloudTrail** is a great resource to use when attempting to detect traffic
    to and from your AWS environment.
  prefs: []
  type: TYPE_NORMAL
- en: We have talked quite a bit about Metasploit throughout this book, so now let's
    look at how we can use Metasploit with Lambda. We are going to look at how we
    can leverage the handler within Metasploit to capture sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Sessions are connections that have been hooked within Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: Having fun with Metasploit and Lambda
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we understand how to create shell scripts with Python and Lambda, let's
    take a look at how we can use Metasploit to get similar results! For this exercise,
    we can use the same payload as before; however, you may need to change your instance
    DNS name if you restarted your instance or you're using a different EC2.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start, let's discuss what exactly we are going to be doing; remember,
    it's best to lay out a plan before executing it, even if that plan is small! For
    example, we will need to use the `netcat` to establish connections. We learned
    about `netcat` when setting up reverse shells with our Lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have used Metasploit before, in [*Chapter 3*](B15630_03_Final_ASB_ePub.xhtml#_idTextAnchor098)*,
    Exploring Pentesting and AWS*, there won't be a need to talk about Metasploit
    or how to start it up. We will need to ensure that we use the correct payload,
    however. The following steps will show how to set up a handler using a Python
    payload that will catch our connection from our vulnerable Lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start up Metasploit and input the following commands to begin setting up your
    handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once you begin running the handler, your handler will go into `netcat` works,
    except we are using Meterpreter for our interpreting shell instead of the default
    Bash shell used in the connection with our shell and `netcat`. Meterpreter shells
    are much more powerful than `netcat` connections because they offer copious amounts
    of modules that you can load within your Meterpreter shell. We will learn more
    about it in [*Chapter 9*](B15630_09_Final_ASB_ePub.xhtml#_idTextAnchor381)*, Real-Life
    Pentesting with Metasploit and More!*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our listener is running, go back to your vulnerable Lambda function
    and test it and try to connect to your Meterpreter listener. If all goes well,
    you''ll have a stager and then a session. Your session is your interactive shell
    with the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Obtaining a reverse shell via Meterpreter'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.11_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.11 – Obtaining a reverse shell via Meterpreter
  prefs: []
  type: TYPE_NORMAL
- en: Great, now we have an interactive shell via Meterpreter on our Lambda instance.
    If this Lambda instance were connecting with other resources, the possibility
    of pivoting would exist – however, we aren't going to worry much about that in
    this example. There will be more on pivoting in [*Chapter 9*](B15630_09_Final_ASB_ePub.xhtml#_idTextAnchor381)*,
    Real-Life Pentesting with Metasploit and More!*. For now, feel free to move around
    with your shell, try different payloads, and even expand your environment to see
    what else you can do!
  prefs: []
  type: TYPE_NORMAL
- en: Great job making it through this portion of the book! This chapter focused quite
    a bit on some new techniques used in pentesting, and you also learned how to get
    reverse shells on Lambda!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to create Lambda functions and their functionality
    in AWS. We also looked at vulnerable issues with Lambda and the vulnerabilities
    that those issues can present to an organization that fails to isolate those issues.
    Creating reverse shells helps us understand the seriousness of what can go wrong
    if a vulnerable Lambda function becomes present in an environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to start looking at how we attack AWS APIs
    and see how they handle requests, as well as discussing the techniques used to
    secure them.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Interactive Lambda shell: [http://www.lambdashell.com/](http://www.lambdashell.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Metasploit handler: [https://www.rapid7.com/db/modules/exploit/multi/handler](https://www.rapid7.com/db/modules/exploit/multi/handler)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
