- en: SVG Animation and Visualizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter addresses the most dynamic and impressive use case for SVG: using
    SVG for data visualizations and animations. The tools you''ve already learned
    about, SVG, JavaScript, and CSS, and some new tools, will come together to create
    powerful options for you to build dynamic sites and applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to produce a static data visualization using SVG, JavaScript, and structured
    data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of the general techniques for animating SVG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating SVG with Vivus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation with GSAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After working through the examples in this chapter, you'll be able to create
    animations and data visualizations with SVG and will know about two of the best
    tools for working with SVG and animation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive right in.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an SVG data visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This first section is going to focus on putting together a basic data visualization
    using SVG and JavaScript. This particular visualization will focus on an illustration,
    the positive/negative variance from an average. In this case, it will illustrate
    the number of home runs hits, per season, by the baseball player David Ortiz in
    his career with the Boston Red Sox compared with his average number of home runs
    over his Red Sox career.
  prefs: []
  type: TYPE_NORMAL
- en: From 2003 until 2016 David Ortiz hit a minimum of 23 and a maximum of 54 home
    runs in a season while playing for the Red Sox. He averaged 34.5 per season. This
    visualization will show the relative positive/negative variance of his home run
    totals for every year against that 34.5 average. Years in which he hit more than
    the average will be in green. Years, where he hit less, will be in red.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps we''ll need to go through are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We will take the data and get the total number of years, the total number of
    home runs, and then calculate the average.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will loop through the data and calculate the positive/negative offset for
    each year.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will calculate some metrics based on the available screen real estate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will draw a baseline, centered vertically on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will draw a series of rectangles in the appropriate place, with the appropriate
    height to indicate the positive/negative variance, along with some simple labels
    indicating the year and number of home runs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will add a legend indicating the average number of home runs and number of
    years.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final visualization will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb90380e-2dd8-4c7d-92a3-facb795e4e45.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have the basics planned out, let's look at how this works in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with the markup, which is very simple. We first include Bootstrap
    and the Raleway font as part of our standard template. Following that, we set
    the background of the SVG element and set the font family, size, and color of
    two different types of text element. Then we just include the target SVG element
    and the JavaScript file that runs the visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The included JavaScript file is where the real work is done.
  prefs: []
  type: TYPE_NORMAL
- en: This JavaScript file is written using several ES6 features.
  prefs: []
  type: TYPE_NORMAL
- en: '`scripts.js` itself is basically one large function, `viz`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `viz` we have the `data` variable. This variable is an array
    of JavaScript objects. Each object has two properties, `year` and `hrs`, indicating
    the year in question and the number of home runs Ortiz hit that year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you were running this visualization interactively, either accepting input
    from a user or inserting the result of a web service call to a statistical database
    into the visualization, you would just need to have the right structure (an array
    of objects) and format (`hrs` and `year`) and everything else would work itself
    out. Keep that in mind as we look at the variables and methods that populate the
    rest of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting after `data`, there are several different variables we set that we''ll
    use, in addition to `data`, throughout the visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '`doc`: A reference to the document'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`canvas`: A reference the SVG element with an `id` of `#canvas`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NS`: A reference to the namespace derived from the `SVG` element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`elem`: A placeholder variable for the elements we''ll create'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next up are several utility methods we use to populate the visualization with
    values and elements.
  prefs: []
  type: TYPE_NORMAL
- en: The first, `addText`, lets us add the text labels to the visualization. It takes
    in a coordinates object, `coords`, the `text` to be entered, and then finally
    an optional CSS class, `cssClass`. We'll explore the use case for the CSS class
    argument in one of the examples. The first two arguments should be straightforward
    and are required.
  prefs: []
  type: TYPE_NORMAL
- en: Following `addText`, there is an `addLine` function that allows us to draw lines
    on the screen. It takes a coordinates object, `coords` (which in this case contains
    four coordinates) and an optional `stroke` color. You'll notice that the `stroke`
    is created with a default value in the function signature. If there is no stroke
    color provided, the `stroke` will be `#ff8000`.
  prefs: []
  type: TYPE_NORMAL
- en: Next up is the `addRect` function that allows us to add rectangles to the screen.
    It accepts a coordinates object, `coords`, which contains `height` and `width`
    properties, as well as optional `stroke` and `fill` colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there''s a function, `maxDiffer`, which figures out the maximum difference
    between a set of positive/negative numbers. Getting this range and then using
    this maximum difference ensures that no matter how the numbers are spread, the
    maximum height needed above or below the baseline will fit into the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After those utility functions, we have the code that defines the heart of the
    visualization. It happens in a function that runs on the `DOMContentLoaded` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the function runs, we create multiple variables, holding different properties
    that we need to generate the visualization. Here''s what they do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`viewBox` is a local reference to the SVG element''s `viewBox`. We store this
    and the following DOM references locally so that we can save on the number of
    DOM lookups of the `viewBox`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width` is a local reference to the width from the SVG element''s `viewBox`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`height` is a local reference to the `height` from the `viewBox`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x` is a local reference to the `x` point from the `viewBox`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y` is a local reference to the `y` point from the `viewBox`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`padding` is an arbitrary constant that creates several padding calculations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vizWidth` defines the visible width of the SVG canvas. This defines the area
    in which we can safely draw elements into the SVG element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`years` is a reference to the number of years in the data set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`total` is a calculated value that represents the total number of home runs
    hit over the full data set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`avg` is the average number of home runs hit per year, calculated by dividing
    the `total` by the number of `years`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`verticalMidPoint` represents the vertical mid-point of the SVG element. This
    is the line on which positive or negative variances are drawn.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`diffs` is an array holding the positive and negative difference between the
    average number of home runs and the number of home runs hit in every year.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxDiff` is the maximum difference between the average number of home runs
    and the number of home runs hit in a given year.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yInterval` is the number of pixels per home run. This ensures that the boxes
    scale properly, vertically, based on the number of home runs hit in any given
    year.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xInterval` is the number of pixels per year. This value allows us to evenly
    space boxes no matter how many years are in the data set:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Following the creation of all those variables, we get to the business of drawing
    the different boxes and adding the labels. To do so, we use a `for...in` loop
    to loop through the array of `diffs`, doing two calculations that create two new
    variables, the `newX` and the `newY`. The `newX` is a regular interval based on
    the value of `i` multiplied by the `intervalX` variable we previously created.
    The `newY` variable is calculated by multiplying the value of `diffs[i]`, the
    current diff, by the `yInterval` constant. This gives us a distance to use to
    calculate the height of the rectangle in order to represent the number of home
    runs in each year.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we test whether or not the current `diff` is greater or less than zero.
    If it's greater than zero, we want to draw a box that goes up from the `verticalMidPoint`.
    If the current `diff` is less than zero, then we draw a box that goes `down` from
    the `verticalMidPoint`. Since the direction of the rectangle and the associated
    anchor points for the box are different in each case, we need to handle them differently.
    We will also use different colors for the two variations in order to highlight
    the differences with a secondary indication.
  prefs: []
  type: TYPE_NORMAL
- en: While there are differences between the two branches of this `if`, both branches
    call `addRect` and `addText`. Let's look at the similarities and the differences
    between the two branches of the `if`.
  prefs: []
  type: TYPE_NORMAL
- en: For starters, each call to `addRect` follows the same pattern for the `x` and
    `width` properties. `x` is always the `newX` value added to the `padding` and
    the `width` is the `xInterval` value plus the `padding`.
  prefs: []
  type: TYPE_NORMAL
- en: The `y` and `height` values are handled differently by the two branches.
  prefs: []
  type: TYPE_NORMAL
- en: If the current difference is less than zero, then the new `y` coordinate is
    `verticalMidpoint`. This anchors the top of the box to the line that represents
    zero on the visualization and indicates that the box will hang below that line.
    If the current difference is greater than zero, then the `y` coordinate is set
    to be `verticalMidPoint` minus the `newY`. This sets the top of the new rectangle
    to be the value of `newY` abovethe line that indicates zero.
  prefs: []
  type: TYPE_NORMAL
- en: The `height`, if the current difference is less than zero, is the `newY` value
    passed into `Math.abs()`. You can't pass in a negative value to an SVG element,
    so the negative value needs to be converted to a positive value using `Math.abs()`.
    The `height`, in the case of a current diff, that's greater than zero, is just
    the `newY` value, since it's already a positive number.
  prefs: []
  type: TYPE_NORMAL
- en: The calls to `addText` in each branch of the `if` diverge on the placement of
    the `y` point. If the `newY` value is negative, then, once again, `Math.abs` has
    to convert the  `newY` value to a positive number. Otherwise, it's passed through
    unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Following that, we add the zero line to the vertical mid-point with a call to
    `addLine`. The arguments passed in are the unchanged  `x` and `width` from the
    `viewBox` for the leftmost and rightmost points and `verticalMidpint` for the
    `y` value for both points
  prefs: []
  type: TYPE_NORMAL
- en: Finally we add a little bit of text that explains the basics of the visualization.
    Here is where we use the optional `cssClass` argument to `addLine`, passing in
    `large` so that we can make slightly larger text. The `x` and `y` arguments leverage
    the `x` and `height` variables along with the `padding` variable to place the
    text slightly off the bottom left edge of the SVG element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final line of code simply calls the `viz()` function to kick off the visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If this were a visualization destined for production, or for more general-purpose
    use, then there are still things that we'd want to do with it. Eagle-eyed readers
    will spot that we don't actually deal with the case where the number of home runs
    exactly equals the average number of home runs, for example. That said, for the
    purposes of this book, the detail here is enough to illustrate how one works with
    JavaScript, SVG, and data to tell the story of a data-set visually.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've looked at static visualizations, let's look at adding some movement
    to the screen. The next section will deal with multiple ways in which you can
    animate SVG in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: General techniques for animating SVG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will introduce various general techniques for animating SVG. While
    there are different tools available to do this work (you'll meet two later on
    in this chapter), it's useful to know how these things are done without the aid
    of frameworks or libraries. This section will provide that foundation.
  prefs: []
  type: TYPE_NORMAL
- en: You've already previously seen some of these techniques, but it's good to look
    at them again, solely in the context of animation.
  prefs: []
  type: TYPE_NORMAL
- en: Animating with pure JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before there were CSS keyframe animations and CSS transitions, two techniques
    we'll look at later in this chapter, we had to produce all of our animations and
    interesting effects in the browser by hand using JavaScript; updating properties
    in a loop and optimizing frame rates manually. Eventually, libraries such as jQuery
    came along and removed the need to know how this worked, by presenting animations
    as part of their API. Thankfully, these days, in addition to the animation methods
    available in your tool of choice, you can leverage CSS animations for many things
    we used to use JavaScript for so there's less and less need for people to learn
    these skills these days.
  prefs: []
  type: TYPE_NORMAL
- en: That said, there are places where CSS animations won't cut it, so there's some
    benefit to seeing how it works under the hood and without the aid of a library.
  prefs: []
  type: TYPE_NORMAL
- en: This simple animation will animate a circle element across an SVG element from
    left to right. We will need to calculate several metrics to create the animation,
    so even though it's simple, it will illustrate many of the challenges you might
    run into doing this sort of coding.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is nothing of interest in the `head`, so let''s skip straight to the
    `body` of the page. The `body` has the standard Bootstrap markup we''ve been working
    with throughout the book. Inside the main `div`, we have an `SVG` element that
    contains a single `circle` element at `75, 225` with a `50`-pixel radius. It''s
    got an `id` of `circle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The JavaScript is straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: It consists of a single function added to the `DOMContentLoaded` event. That
    function does some familiar things. It creates local references to `doc`, `canvas`,
    and `circle` so that we can reference those elements easily throughout the animation. Following
    that there are several variables created to store properties of the `viewBox`: `viewBox`
    itself, `height`, `width`, and `x`. We then set two constants representing the
    number of `seconds` for the animation to run and the number of **frames per second**
    (**fps**) we're aiming for with our animation).
  prefs: []
  type: TYPE_NORMAL
- en: Following that we grab the current `x` value of the circle element as a variable, `currX`. 
    After that we calculate the ending point, `newX`, by using the radius of the circle
    and multiplying it by 3\. That gives us a comfortable ending point, visually.
  prefs: []
  type: TYPE_NORMAL
- en: Next we create some variables to run the animation. The first, `diffX`, is a
    calculation of the difference between the current `x` value and the target, `newX`,
    value. Then we take the `diffX`, divide it by the number of seconds, and multiply
    it by the number of frames per second. This will create three seconds' worth of
    intervals to animate by.
  prefs: []
  type: TYPE_NORMAL
- en: Finally we create the animated variable, `animX`, which is the variable we will
    work with in every frame as we animate the element across the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Following that, there's a function that adjusts the position of the element
    on the screen every frame. It does three things. It adds the interval to the `animX`
    to move the element over by that calculated interval. It then sets the `cx` property
    of the element, moving it to its new position. Finally it calls itself recursively
    using `window.requestAnimationFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: '`requestAnimationFrame` is a method that allows the browser to optimize the
    way that JavaScript animations are drawn onto the screen. The number of frames
    per second it''s optimized to is usually `60`, but technically it will match the
    display refresh rate of the device.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All of that takes place inside an `if` block that stops the animation when
    it has completed. If `animX` is less than `newX`, then the code executes, calling
    `animate` again to kick off the next frame. If `animX`  is greater than or equal
    to `newX`, then the animation stops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This isn't the most complicated animation, but using `window.requestAnimationFrame`
    means that it looks pretty good in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: While there are other options for animating SVG, and you should learn about
    them and use them where appropriate, JavaScript is going to be the most powerful
    and ultimately the most flexible option out there. If your animation needs to
    work across the most possible browsers, then you're going to want to use JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is, as you'll see later on in the chapter, there are excellent
    tools to simplify animating with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at the first of several JavaScript libraries for working with
    SVG, let''s look at the two other options for animating SVG, using core web technologies:
    CSS, and SMIL.'
  prefs: []
  type: TYPE_NORMAL
- en: Animating with CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animating SVG with CSS is straightforward in that it works the same way that
    CSS animations and transitions work with regular HTML elements. You define some
    CSS properties and, depending on whether or not you're using keyframe animation
    or transitions, you create specific CSS rules that handle how they are rendered
    over a period of time. The problem with the idea of that process being straightforward
    is that only presentation attributes, which drive much of SVG, that are also available
    as CSS properties can be manipulated with CSS.  As you can see on the following
    website, the list, as defined in SVG 1.1, is missing many important properties: [https://www.w3.org/TR/SVG/propidx.html](https://www.w3.org/TR/SVG/propidx.html).
    SVG 2.0 adds many more properties, but support for those new properties is not
    universal and, unfortunately, there isn't a proper compendium of what properties
    are supported where.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, there are some potential rough edges using these technologies,
    depending on what your browser support matrix looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, even with that somewhat rough story, it's still worth seeing these techniques
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: There are three examples here. Two show animations similar to the previous JavaScript
    animation; they move a blue circle across the screen. They're implemented in two
    different ways. This illustrates the implementation differences you might see
    depending on what browsers you're targeting. The first example uses CSS transforms
    and CSS animation to translate the element across the screen. This technique has
    broader browser support. The second example uses the simpler approach of setting
    a transition on the `cx` property and then changing the value on hover of the
    SVG element. `cx` is available as a CSS property in Chrome, so in that browser
    this is the easier approach.
  prefs: []
  type: TYPE_NORMAL
- en: The third example shows a transition on the `fill` on an element, to illustrate
    an example where leaving the calculations to the browser and CSS is of great benefit.
    If it's not clear how you would animate from one color value to another, then
    you can probably see at least one great use case for leaving the heavy lifting
    to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the examples in order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first example is simple. In it, we have the same markup as the previous
    JavaScript example, with one exception: setting the `cx` property via CSS. We
    do that in the `#circle` selector in the `head` of the document.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we set a `transition` property on that selector, watching the
    `cx` property for changes and transitioning for three seconds when it changes.
    In the next selector, `svg:hover #circle`, we trigger the animation via a hover
    event on the parent SVG element, which sets the `cx` value to the final destination,
    `875` pixels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this CSS in place, when you mouse over the SVG element, the new `cx` is
    set and the browser will animate across the screen between `75` and `875` pixels
    on the *x* axis of the SVG element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This next example is set up similarly. It has exactly the same SVG markup as
    the previous example animated by JavaScript. The differences are once again in
    the CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two sections of interest. The first section defines a two-keyframe
    animation called `animate-circle`. The first keyframe, at `0%,` has a `0px` translation
    across the *X* axis, using `transform: translateX`. The second keyframe, at `100%`,
    increases that transformation to `800px`.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the `#circle` selector, we define the `animation` property with the
    named animation, a duration of three seconds and linear easing. Then we set the
    `animation-fill-mode` to forwards, which indicates that the animation should run
    forwards once and complete, keeping the animated element at its final state.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this runs, the circle smoothly animates across the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The final example also uses transitions, this time animating the `fill` property
    from blue to red. This property is one of the earlier presentation properties
    defined as being available in CSS, so it's got better support in browsers than
    a property such as `cx` at this present time.
  prefs: []
  type: TYPE_NORMAL
- en: The CSS definition is very simple. There's a `fill` property set on the `#circle` definition,
    alongside a `transition` that watches for changes to `fill` and transitions the
    change over a 2-second duration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `#circle:hover` we change the `fill` to blue. Running it in a browser and
    hovering over the circle will animate the color of the circle element, without
    using anyJavaScript and without figuring out how to animate from one named color
    to another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: All of these examples are intentionally basic and as mentioned, browser support
    for them is weak (none work in versions of IE older than Edge, for example); but
    they remain powerful. If your browser matrix support leans toward the latest and
    greatest browsers, then you can have a lot of fun with CSS and SVG.
  prefs: []
  type: TYPE_NORMAL
- en: Animating SVG with SMIL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another interesting and powerful option for animating SVG has a similarly frustrating
    support matrix to CSS. SMIL isn't supported at all in Microsoft browsers and was
    even deprecated briefly by Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: This is a shame, as there are some nice things about SMIL. It's a clear, declarative
    way to animate elements. It's not as powerful as JavaScript or as commonly used
    as a general-purpose technology like CSS, but it's still pretty great.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In it, we have our now familiar markup: a simple `circle` on an otherwise blank
    SVG element. This time there''s one small twist. There is an `animate` element
    as a child of the `circle` element. The `animate` element is where the animation
    is defined. It has several attributes that we need to look at:'
  prefs: []
  type: TYPE_NORMAL
- en: The `xlink:href` attribute points to the `#circle` element that will be animated.
    The fact that the `animate` element is a child of the `circle` element automatically
    associates the animation with it. Using the `xlink:href` attribute ensures that
    the connection is precisely defined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attributeName` defines the attribute that will be animated. In this case it''s
    the `cx` attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `from` and `to` attributes indicate the beginning and endpoint of the animation.
    In this case we'll be moving from `"75"` to `"900"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dur` indicates the duration of the animation. In this case,  it''s defined
    as `"3s"`, for three seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `begin` attribute indicates when the animation should begin. This lets you
    delay the animation as needed. In our case we start the animation immediately
    with `"0s"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fill` attribute, confusingly named the same as the common `fill` attribute,
    indicates whether or not the animated values should remain on the element after
    the animation concludes. This value, `"freeze"`, indicates that the element should
    remain frozen at the state it reaches at the end of the animation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There seems no good reason why `fill` is overloaded to do two separate, basically
    unrelated, tasks in the context of SVG. It's unfortunate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this in the browser creates a similar animation to the one we''ve seen
    in several instances in this chapter; the ball starts on the left and over the
    course of three seconds moves over to the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've looked at manual methods for data visualization and animation
    in SVG, let's look at some tools that will help with animating elements.
  prefs: []
  type: TYPE_NORMAL
- en: Animating SVG with Vivus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vivus is a library that does one thing and does it really well ([https://maxwellito.github.io/vivus/](https://maxwellito.github.io/vivus/)).
    Vivus allows you to "draw" the stroke of an SVG element across a period of time.
  prefs: []
  type: TYPE_NORMAL
- en: The following series of screenshots show how that will look. It's a nice effect.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed8a7cc6-8324-4d72-b7ea-194f55650f43.png)'
  prefs: []
  type: TYPE_IMG
- en: As a note, the same illustration is used in three samples in this chapter. The
    code samples printed in the book truncate the `d` attribute of each path element
    in order to shorten the code sample to a manageable length. If you'd like to see
    the full sample, please refer to the code on GitHub ([https://github.com/roblarsen/mastering-svg-code](https://github.com/roblarsen/mastering-svg-code)[). ](https://github.com/roblarsen/mastering-svg-code)
  prefs: []
  type: TYPE_NORMAL
- en: As long as the `stroke` is set with a value and the `fill` is set to `none`,
    simply including the Vivus JavaScript file (in this case we do so by running `npm
    install` in the Vivus folder and then linking to the JavaScript file located in
    the `node_modules` folder) and then creating a new Vivus instance are all it takes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new Vivus instance is very easy. Using the `new` keyword you can
    instantiate a new Vivus object with two arguments. The first is the `id` of the
    SVG element. The second is the configuration object. In this case, we're passing
    in just one option, the `duration` argument, setting the duration of the animation
    to three seconds (3,000 milliseconds).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sample shows just how easy it is to work with Vivus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There are other configuration options available to Vivus, you can find them
    here: [https://github.com/maxwellito/vivus#option-list](https://github.com/maxwellito/vivus#option-list).
    We won''t go through them all, but we will illustrate one more, one that will
    be very useful, that of running a callback function once the animation is completed.'
  prefs: []
  type: TYPE_NORMAL
- en: Everything about it is the same as the previous Vivus example, except we define
    a simple callback function, called `callback`, that goes through all instances
    of elements with the class `stroke` and changes their stroke to a different color.
  prefs: []
  type: TYPE_NORMAL
- en: 'The end result looks like the following screenshot. The text will be red once
    the animation completes and the callback function is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e79b6c5-b695-4721-8f6c-a5f78f63d1e2.png)'
  prefs: []
  type: TYPE_IMG
- en: The callback function is passed in as an optional third argument to the Vivus
    constructor. It then executes when the animation is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sample shows how that works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've looked at an animation library that does one thing, let's take
    a look at a more full-featured animation library, **GreenSock Animation Platform
    (GSAP)**.
  prefs: []
  type: TYPE_NORMAL
- en: Animating SVG with GSAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GSAP is a set of powerful JavaScript tools for animation on the web. It works
    very well with SVG.
  prefs: []
  type: TYPE_NORMAL
- en: GSAP is a powerful set of tools and exploring all it has to offer in depth would
    spread across multiple chapters. *And that's just the free version*. There's also
    a premium version which includes even more features and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that, even though it's incredibly powerful, the GSAP API is
    straightforward, so once you find your desired feature and get a look at the strong
    documentation ([https://greensock.com/docs](https://greensock.com/docs)), you're
    going to be able to do a lot very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at two separate examples to give you an intro to the sort
    of things that GSAP can do and how it does them.
  prefs: []
  type: TYPE_NORMAL
- en: This first example replicates the same animation we've done several times so
    far in this chapter. We're moving a ball from one side of the SVG element to the
    other. This one actually uses some familiar code from the initial JavaScript example
    to calculate the finishing position.
  prefs: []
  type: TYPE_NORMAL
- en: The markup is the same as we've seen several times so far. It's a `circle` element
    with an `id` of `circle` alone in an SVG element.
  prefs: []
  type: TYPE_NORMAL
- en: To get started using GSAP, we need to include their JavaScript in our demo.
    In this case, we're including the TweenMax script. Running `npm install` in the
    project folder will install GSAP and then we can include it from the project's
    `node_modules` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different Tween* modules that GSAP provides: `TweenLite` and
    `TweenMax`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'They are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: TweenLite is an extremely fast, lightweight, and flexible animation tool that
    serves as the foundation of the GSAP. A TweenLite instance handles tweening one
    or more properties of any object (or array of objects) over time.
  prefs: []
  type: TYPE_NORMAL
- en: TweenMax extends TweenLite, adding many useful (but non-essential) features
    like repeat(), repeatDelay(), yoyo(), and more. It also includes many extra plugins
    by default, making it extremely full-featured.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use TweenMax for this demo. If you're going to start to experiment with
    GSAP, TweenMax is going to offer you the largest footprint of tools to work with
    right off the bat. It's slightly slower but it's more powerful, and while you're
    experimenting with it, it's going to be more fun to have everything at your fingertips.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the JavaScript file loaded, let's work with it.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript should look familiar, at least to start with. We set several
    familiar consts: `doc` as an alias for the `document`, `canvas` as a reference
    to the SVG element,  `circle` as a local reference to the circle we're going to
    animate, `viewBox` as a local reference for the `viewBox` of the SVG element,
    `width` for the `viewBox.width`, and `newX` for the calculated finish position
    of the circle element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new GSAP-specific code follows as we call `TweenMax.to.`  `TweenMax.to` is
    a method that animates an HTML element to a certain state. The arguments are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"#circle"` is the CSS selector to use to match the element we''re going to
    animate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` is the number of times the animation will run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, there is a configuration object to define the animation. In our example
    we're passing in the `newX` variable as the new value of the `cx` element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And that''s all it takes; GSAP handles the rest, smoothly animating the circle
    from one end of the screen to the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This next example has the same setup, but changes the arguments that are passed
    into `TweenMax.to` and adds another chained method call to change the duration
    of the animation. In this example we pass in four separate attributes to animate
    the element against, `cx`, `cy`,  `r`, and `fill`.  This example illustrates one
    of the real powers of GSAP. You don't have to figure out anything about the timing
    of those multiple property animations, what the individual intervals look like,
    or how to sync them and parse them out so that they run smoothly. You just give
    GSAP an end state and watch it do its magic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we''re adding a new method, chained to the end of the call to TweenMax.to.
    Calling `TweenMax.duration` changes the duration of the animation. Here we''re
    passing in `5` to extend the animation to last a full five seconds. This chained
    interface allows you to work with animations in a manner similar to working with
    jQuery and many other JavaScript libraries. It''s a powerful, friendly, interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the previous code in a browser produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/775b243b-51ae-4631-a379-da143bb5840e.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned about visualizations and animations with SVG.
    This included working with pure JavaScript, SMIL, CSS, and two libraries for animation:
    GSAP and Vivus.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we looked at:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom data visualization with JavaScript, SVG, and CSS. You took
    a data set, manipulated it with JavaScript, and used the results to create a nice
    looking visualization that illustrates a set of data in an easy-to-read way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom SVG animation with JavaScript. This included calculating increments
    to animate over 60 frames-per-second and using `requestAnimationFrame` as a method
    to ensure that you're providing the smoothest possible experience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating SVG with CSS. You learned that the powerful options for animating
    SVG come with uncertain browser support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating SVG with SMIL, which also comes with uncertain browser support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating SVG with the Vivus library, which makes implementing a "drawing" animation
    in SVG as easy as including the library and adding a single line of JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, you got a glimpse at the powerful GSAP library, which offers incredibly
    powerful options for the animation of SVG and other elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've introduced a couple of libraries into the mix, it will be a smooth
    transition into a whole chapter on helper libraries for SVG, Snap.svg, and SVG.js.
    These are important tools and will be invaluable if you're looking to do advanced,
    custom work with SVG.
  prefs: []
  type: TYPE_NORMAL
