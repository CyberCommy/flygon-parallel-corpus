- en: Part I. Classical Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Organizing Code
  prefs: []
  type: TYPE_NORMAL
- en: Creational Patterns
  prefs: []
  type: TYPE_NORMAL
- en: Structural Patterns
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral Patterns
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2. Organizing Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we'll look at how to organize JavaScript code into reusable,
    understandable chunks. The language itself doesn't lend itself well to this sort
    of modularization but a number of methods of organizing JavaScript code have emerged
    over the years. This chapter will argue for the need to break down code and then
    work through the methods of creating JavaScript modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Global scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototype inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 2015 classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chunks of code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing anybody learns to program is the ubiquitous Hello World application.
    This simple application prints some variation of "hello world" to the screen.
    Depending on who you ask, the phrase hello world dates back to the early 1970s
    where it was used to demonstrate the B programming language or even to 1967 where
    it appears in a BCL programming guide. In such a simple application there is no
    need to worry about the structure of code. Indeed, in many programming languages,
    hello world needs no structure at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Ruby, it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For JavaScript (via Node.js), it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Programming modern computers was originally done using brutally simplistic techniques.
    Many of the first computers had problems they were attempting to solve hard-wired
    into them. They were not general purpose computing machines like the ones we have
    today. Instead they were built to solve just one problem such as decoding encrypted
    texts. Stored program computers were first developed in the late 1940s.
  prefs: []
  type: TYPE_NORMAL
- en: The languages used to program these computers were complicated at first, usually
    very closely tied to the binary. Eventually higher and higher-level abstractions
    were created to make programming more accessible. As these languages started to
    take shape through the 50s and 60s it quickly became apparent that there needed
    to be some way to divide up large blocks of code.
  prefs: []
  type: TYPE_NORMAL
- en: In part this was simply to maintain the sanity of programmers who could not
    keep an entire, large program in their heads at any one time. However, creating
    reusable modules also allowed for code to be shared within an application and
    even between applications. The initial solution was to make use of statements,
    which jumped the flow control of the program from one place to another. For a
    number of years these GOTO statements were heavily relied upon. To a modern programmer
    who has been fed a continual stream of warnings about the use of GOTO statements
    this seems like insanity. However it was not until some years after the first
    programming languages emerged that structured programming grew to replace the
    GOTO syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Structured programming is based on the Böhm-Jacopini theorem, which states
    that there is a rather large class of problems, the answer to which can be computed
    using three very simple constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: Sequential execution of sub-programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional execution of two sub-programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeated execution of a sub-program until a condition is true
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Astute readers will recognize these constructs as being the normal flow of execution,
    a branch or `if` statement, and a loop.
  prefs: []
  type: TYPE_NORMAL
- en: Fortran was one of the earliest languages and was initially built without support
    for structured programming. However structured programming was soon adopted as
    it helped to avoid spaghetti code.
  prefs: []
  type: TYPE_NORMAL
- en: Code in Fortran was organized into modules. Modules were loosely coupled collections
    of procedures. For those coming from a modern object oriented language, the closest
    concept might be that a module was like a class that contains only static methods.
  prefs: []
  type: TYPE_NORMAL
- en: Modules were useful for dividing code into logical groupings. However, it didn't
    provide for any sort of structure for the actual applications. The structure for
    object-oriented languages, that is classes and subclasses, can be traced to a
    1967 paper written by Ole-Johan Dahl and Kristen Nygaard. This paper would go
    on to form the basis of Simula-67, the first language with support for object
    oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: While Simula-67 was the first language to have classes, the language most talked
    about in relation to early object oriented programming is Smalltalk. This language
    was developed behind closed doors at the famous Xerox **Palo Alto Research Center**
    ( **PARC** ) during the 1970s. it was released to the public in 1980 as Smalltalk-80
    (it seems like all historically relevant programming languages where prefixed
    with the year of release as a version number). What Smalltalk brought was that
    everything in the language was an object, even literal numbers like 3 could have
    operations performed on them.
  prefs: []
  type: TYPE_NORMAL
- en: Almost every modern programming language has some concept of classes to organize
    code. Often these classes will fall into a higher-level structure commonly called
    a namespace or module. Through the use of these structures, even very large programs
    can be divided into manageable and understandable chunks.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the rich history and obvious utility of classes and modules, JavaScript
    did not support them as first class constructs until just recently. To understand
    why, one has to simply look back at the history of JavaScript from [Chapter 1](text00014.html#ch01
    "Chapter 1. Designing for Fun and Profit") , *Designing For Fun and Profit* ,
    and realize that for its original purpose having such constructs would have been
    overkill. Classes were a part of the ill-fated ECMAScript 4 standard and they
    finally became part of the language with the release of the ECMAScript 2015 standard.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we'll explore some of the ways to recreate the well worn class
    structure of other modern programming languages in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: What's the matter with global scope anyway?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In browser based JavaScript every object you create is assigned to the global
    scope. For the browser, this object is simply known as **window** . It is simple
    to see this behavior in action by opening up the development console in your favorite
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Opening the Development Console**'
  prefs: []
  type: TYPE_NORMAL
- en: Modern browsers have, built into them, some very advanced debugging and auditing
    tools. To access them there is a menu item, which is located under **Tools** |
    **Developer Tools in Chrome** | **Tools** | **Web Developer in Firefox** , and
    directly under the menu as **F12 Developer Tools** in Internet Explorer. Keyboard
    shortcuts also exist for accessing the tools. On Windows and Linux, *F12* is standard
    and, on OSX, `Option` + `Command` + `I` is used.
  prefs: []
  type: TYPE_NORMAL
- en: Within the developer tools is a console window that provides direct access to
    the current page's JavaScript. This is a very handy place to test out small snippets
    of code or to access the page's JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the console open, enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this will be `hello world` printed to the console. By declaring
    words globally it is automatically attached to the top level container: window.'
  prefs: []
  type: TYPE_NORMAL
- en: In Node.js the situation is somewhat different. Assigning a variable in this
    fashion will actually attach it to the current module. Not including the `var`
    object will attach the variable to the `global` object.
  prefs: []
  type: TYPE_NORMAL
- en: For years you've likely heard that making use of global variables is a bad thing.
    This is because globals are very easily polluted by other code.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a very commonly named variable such as `index` . It is likely that
    in any application of appreciable size that this variable name would be used in
    several places. When either piece of code makes use of the variable it will cause
    unexpected results in the other piece of code. It is certainly possible to reuse
    variables, and it can even be useful in systems with very limited memory such
    as embedded systems, but in most applications reusing variables to mean different
    things within a single scope is difficult to understand and a source of errors.
  prefs: []
  type: TYPE_NORMAL
- en: Applications that make use global scoped variables also open themselves up to
    being attacked on purpose by other code. It is trivial to alter the state of global
    variables from other code, which could expose secrets like login information to
    attackers.
  prefs: []
  type: TYPE_NORMAL
- en: Finally global variables add a great deal of complexity to applications. Reducing
    the scope of variables to a small section of code allows developers to more easily
    understand the ways in which the variable is used. When the scope is global then
    changes to that variable may have an effect far outside of the one section of
    code. A simple change to a variable can cascade into the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule global variables should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Objects in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript is an object oriented language but most people don''t make use of
    the object oriented features of it except in passing. JavaScript uses a mixed
    object model in that it has some primitives as well as objects. JavaScript has
    five primitive types:'
  prefs: []
  type: TYPE_NORMAL
- en: undefined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of these five, only two are what we would expect to be an object anyway. The
    other three, boolean, string, and number all have wrapped versions, which are
    objects: Boolean, String, and Number. They are distinguished by starting with
    uppercase. This is the same sort of model used by Java, a hybrid of objects and
    primitives.'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript will also box and unbox the primitives as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code you can see the boxed and unboxed versions of JavaScript primitives
    at work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating objects in JavaScript is trivial. This can be seen in this code for
    creating an object in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Because JavaScript is a dynamic language, adding properties to objects is also
    quite easy. This can be done even after the object has been created. This code
    creates the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Objects contain both data and functionality. We''ve only seen the data part
    so far. Fortunately in JavaScript, functions are first class objects. Functions
    can be passed around and functions can be assigned to variables. Let''s try adding
    some functions to the object we''re creating in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax is a bit painful, building up objects an assignment at a time.
    Let''s see if we can improve upon the syntax for creating objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax seems, at least to me, to be a much cleaner, more traditional way
    of building objects. Of course it is possible to mix data and functionality in
    an object in this fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of things to note in this piece of code. The first is that
    the different items in the object are separated using a comma and not a semi-colon.
    Those coming from other languages such as C# or Java are likely to make this mistake.The
    next item of interest is that we need to make use of the `this` qualifier to address
    the `greeting` variable from within the `doThings` function. This would also be
    true if we had a number of functions within the object as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `this` keyword behaves differently in JavaScript than you might expect coming
    from other C-syntax languages. `this` is bound to the owner of the function in
    which it is found. However, the owner of the function is sometimes not what you
    expect. In the preceding example `this` is bound to the `functionObject` object,
    however if the function were declared outside of an object this would refer to
    the global object. In certain circumstances, typically event handlers, this is
    rebound to the object firing the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`this` takes on the value of target. Getting used to the value of `this` is,
    perhaps, one of the trickiest things in JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: 'ECMAScript-2015 introduces the `let` keyword which can replace the `var` keyword
    for declaring variables. `let` uses block level scoping which is the scoping you''re
    likely to use from most languages. Let''s see an example of how they differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With the var scoped version you can see that the variable lives on outside of
    the block. This is because behind the scenes the declaration of `varScoped` is
    hoisted to the beginning of the code block. With the `let` scoped version of the
    code `letScoped` is scoped just within the `for` loop so, once we leave the loop,
    `letScoped` is undefined. When given the option of using `let` or `var` we would
    tend to err on the side of always using `let` . There are some cases when you
    actually would want to use var scoping but they are few and far between.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have built up a pretty complete model of how to build objects within JavaScript.
    However, objects are not the same thing as classes. Objects are instances of classes.
    If we want to create multiple instances of our `functionObject` object we''re
    out of luck. Attempting to do so will result in an error. In the case of Node.js
    the error will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The stack trace here shows an error in a module called `repl` . This is the
    read-execute-print loop that is loaded by default when starting Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time that a new instance is required, the object must be reconstructed.
    To get around this we can define the object using a function as can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax allows for a constructor to be defined and for new objects to be
    created from this function. Constructors without return values are functions that
    are called as an object is created. In JavaScript the constructor actually returns
    the object created. You can even assign internal properties using the constructor
    by making them part of the initial function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Build me a prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As previously mentioned, there was, until recently, no support for creating
    true classes in JavaScript. While ECMAScript-2015 brings some syntactic sugar
    to classes, the underlying object system is still as it has been in the past,
    so it remains instructive to see how we would have created objects without this
    sugar. Objects created using the structure in the previous section have a fairly
    major drawback: creating multiple objects is not only time consuming but also
    memory intensive. Each object is completely distinct from other objects created
    in the same fashion. This means that the memory used to hold the function definitions
    is not shared between all instances. What is even more fun is that you can redefine
    individual instances of a class without changing all of the instances. This is
    demonstrated in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Altering the functionality of a single instance or really of any already defined
    object in this fashion is known as **monkey** **patching** . There is some division
    over whether or not this is a good practice. It can certainly be useful when dealing
    with library code but it adds great confusion. It is generally considered better
    practice to extend the existing class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without a proper class system JavaScript, of course, has no concept of inheritance.
    However, it does have a prototype. At the most basic level an object in JavaScript
    is an associative array of keys and values. Each property or function on an object
    is simply defined as part of this array. You can even see this in action by accessing
    members of an object using array syntax as is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Accessing members of an object using array syntax can be a very handy way to
    avoid using the eval function. For instance, if I had the name of the function
    I wanted to call in a string called `funcName` and I wanted to call it on an object,
    `obj1` , then I could do so by doing `obj1[funcName]()` instead of using a potentially
    dangerous call to eval. Eval allows for arbitrary code to be executed. Allowing
    this on a page means that an attacker may be able to enter malicious scripts on
    other people's browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an object is created, its definition is inherited from a prototype. Weirdly
    each prototype is also an object so even prototypes have prototypes. Well, except
    for the object which is the top-level prototype. The advantage to attaching functions
    to the prototype is that only a single copy of the function is created; saving
    on memory. There are some complexities to prototypes but you can certainly survive
    without knowing about them. To make use of a prototype you need to simply assign
    functions to it as is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: One thing to note is that only the functions are assigned to the prototype.
    Instance variables such as `name` are still assigned to the instance. As these
    are unique to each instance there is no real impact on the memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: In many ways a prototypical language is more powerful than a class-based inheritance
    model.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you make a change to the prototype of an object at a later date then all
    the objects which share that prototype are updated with the new function. This
    removes some of the concerns expressed about monkey typing. An example of this
    behavior is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When building up objects you should be sure to take advantage of the prototype
    object whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know about prototypes there is an alternative approach to building objects
    in JavaScript and that is to use the `Object.create` function. This is a new syntax
    introduced in ECMAScript 5\. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The create syntax will build a new object based on the given prototype. You
    can also pass in a `propertiesObject` object that describes additional fields
    on the created object. These descriptors consist of a number of optional fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`writable` : This dictates whether the field should be writable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`configurable` : This dictates whether the files should be removable from the
    object or support further configuration after creation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enumerable` : This dictates whether the property can be listed during an enumeration
    of the object''s properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` : This dictates the default value of the field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also possible to assign a `get` and `set` functions within the descriptor
    that act as getters and setters for some other internal property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `object.create` for our castle we can build an instance using `Object.create`
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll notice that we explicitly define the `name` field. `Object.create`
    bypasses the constructor so the initial assignment we described in the preceding
    code won''t be called. You might also notice that writeable is set to `false`
    . The result of this is that the reassignment of `name` to `Highgarden` has no
    effect. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the niceties of objects is that they can be built upon to create increasingly
    complex objects. This is a common pattern, which is used for any number of things.
    There is no inheritance in JavaScript because of its prototypical nature. However,
    you can combine functions from one prototype into another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we have a base class called `Castle` and we want to customize
    it into a more specific class called `Winterfell` . We can do so by first copying
    all of the properties from the `Castle` prototype onto the `Winterfell` prototype.
    This can be done like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course this is a very painful way to build objects. You''re forced to know
    exactly which functions the base class has to copy them. It can be abstracted
    in a rather naïve fashion like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are into object diagrams this shows how **Winterfell** extends **Castle**
    in this diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inheritance](Image00004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This can be used quite simply as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We say that this is naïve because it fails to take into account a number of
    potential failure conditions. A fully-fledged implementation is quite extensive.
    The jQuery library provides a function called `extend` which implements prototype
    inheritance in a robust fashion. It is about 50 lines long and deals with deep
    copies and null values. The function is used extensively, internally in jQuery
    but it can be a very useful function in your own code. We mentioned that prototype
    inheritance is more powerful than the traditional methods of inheritance. This
    is because it is possible to mix and match bits from many base classes to create
    a new class. Most modern languages only support single inheritance: a class can
    have only one direct parent. There are some languages with multiple inheritance
    however, it is a practice that adds a great deal of complexity when attempting
    to decide which version of a method to call at runtime. Prototype inheritance
    avoids many of these issues by forcing selection of a method at assembly time.'
  prefs: []
  type: TYPE_NORMAL
- en: Composing objects in this fashion permits taking properties from two or more
    different bases. There are many times when this can be useful. For example a class
    representing a wolf might take some of its properties from a class describing
    a dog and some from another class describing a quadruped.
  prefs: []
  type: TYPE_NORMAL
- en: By using classes built in this way we can meet pretty much all of the requirements
    for constructing a system of classes including inheritance. However inheritance
    is a very strong form of coupling. In almost all cases it is better to avoid inheritance
    in favor of a looser form of coupling. This will allow for classes to be replaced
    or altered with a minimum impact on the rest of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a complete class system it would be good to address the global
    namespace discussed earlier. Again there is no first class support for namespaces
    but we can easily isolate functionality to the equivalent of a namespace. There
    are a number of different approaches to creating modules in JavaScript. We'll
    start with the simplest and add some functionality as we go along.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start we simply need to attach an object to the global namespace. This object
    will contain our root namespace. We''ll name our namespace `Westeros` ; the code
    simply looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This object is, by default, attached to the top level object so we need not
    do anything more than that. A typical usage is to first check if the object already
    exists and use that version instead of reassigning the variable. This allows you
    to spread your definitions over a number of files. In theory you could define
    a single class in each file and then bring them all together as part of the build
    process before delivering them to the client or using them in an application.
    The short form of this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the object, it is simply a question of assigning our classes as
    properties of that object. If we continue to use the `Castle` object then it would
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to build a hierarchy of namespaces that is more than a single level
    deep, that too is easily accomplished, as seen in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This class can be instantiated and used in a similar way to previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course with JavaScript there is more than one way to build the same code
    structure. An easy way to structure the preceding code is to make use of the ability
    to create and immediately execute a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This code seems to be a bit longer than the previous code sample but I find
    it easier to follow due to its hierarchical nature. We can create a new castle
    using them in the same structure as shown in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Inheritance using this structure is also relatively easily done. If we were
    to define a `BaseStructure` class which was to be in the ancestor of all structures,
    then making use of it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll note that the base structure is passed into the `Castle` object when
    the closure is evaluated. The highlighted line of code makes use of a helper method
    called `__extends` . This method is responsible for copying the functions over
    from the base prototype to the derived class. This particular piece of code was
    generated from a TypeScript compiler which also, helpfully, generated an `extends`
    method which looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can continue the rather nifty closure syntax we''ve adopted for a class
    to implement an entire module. This is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Within this structure you can see the same code for creating modules that we
    explored earlier. It is also relatively easy to define multiple classes inside
    a single module. This can be seen in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted code creates a second class inside of the module. It is also
    perfectly permissible to define one class in each file. Because the code checks
    to get the current value of `Westeros` before blindly reassigning it, we can safely
    split the module definition across multiple files.
  prefs: []
  type: TYPE_NORMAL
- en: The last line of the highlighted section shows exposing the class outside of
    the closure. If we want to make private classes that are only available within
    the module then we only need to exclude that line. This is actually known as the
    revealing module pattern. We only reveal the classes that need to be globally
    available. It is a good practice to keep as much functionality out of the global
    namespace as possible.
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript 2015 classes and modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve seen so far that it is perfectly possible to build classes and even
    modules in pre ECMAScript -2015 JavaScript. The syntax is, obviously, a bit more
    involved than in a language such as C# or Java. Fortunately ECMAScript-2015, brings
    support for some syntactic sugar for making classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'ECMAScript-2015 also brings a well thought out module system for JavaScript.
    There''s also syntactic sugar for creating modules which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As modules can contain functions they can, of course, contain classes. ECMAScript-2015
    also defines a module import syntax and support for retrieving modules from remote
    locations. Importing a module looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Some of this syntactic sugar is available in any environment which has full
    ECMAScript-2015 support. At the time of writing, all major browser vendors have
    very good support for the class portion of ECMAScript-2015 so there is almost
    no reason not to use it if you don't have to support ancient browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices and troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an ideal world everybody would get to work on greenfield projects where they
    can put in standards right from the get go. However that isn't the case. Frequently
    you may find yourself in a situation where you have a bunch of non-modular JavaScript
    code as part of a legacy system.
  prefs: []
  type: TYPE_NORMAL
- en: In these situations it may be advantageous to simply ignore the non-modular
    code until there is an actual need to upgrade it. Despite the popularity of JavaScript,
    much of the tooling for JavaScript is still immature making it difficult to rely
    on a compiler to find errors introduced by JavaScript refactoring. Automatic refactoring
    tools are also complicated by the dynamic nature of JavaScript. However, for new
    code, proper use of modular JavaScript can be very helpful to avoid namespace
    conflicts and improve testability.
  prefs: []
  type: TYPE_NORMAL
- en: How to arrange JavaScript is an interesting question. From a web perspective
    I have taken the approach of arranging my JavaScript in line with the web pages.
    So each page has an associated JavaScript file, which is responsible for the functionality
    of that page. In addition, components which are common between pages, say a grid
    control, are placed into a separate file. At compile time all the files are combined
    into a single JavaScript file. This helps strike a balance between having a small
    code file with which to work and reducing the number of requests to the server
    from the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It has been said that there are only two really hard things in computing science.
    What those issues are varies depending on who is speaking. Frequently it is some
    variation of cache invalidation and naming. How to organize your code is a large
    part of that naming problem.
  prefs: []
  type: TYPE_NORMAL
- en: As a group we seem to have settled quite firmly on the idea of namespaces and
    classes. As we've seen, there is no direct support for either of these two concepts
    in JavaScript. However there are myriad ways to work around the problem, some
    of which actually provide more power than one would get through a traditional
    namespace/class system.
  prefs: []
  type: TYPE_NORMAL
- en: The primary concern with JavaScript is to avoid polluting the global namespace
    with a large number of similarly named, unconnected objects. Encapsulating JavaScript
    into modules is a key step on the road toward writing maintainable and reusable
    code.
  prefs: []
  type: TYPE_NORMAL
- en: As we move forward we'll see that many of the patterns which are quite complex
    arrangements of interfaces become far simpler in the land of JavaScript. Prototype-based
    inheritance, which seems difficult at the outset, is a tremendous tool for aiding
    in the simplification of design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3. Creational Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter we took a long look at how to fashion a class. In this chapter
    we'll look at how to create instances of classes. On the surface it seems like
    a simple concern but how we create instances of a class can be of great importance.
  prefs: []
  type: TYPE_NORMAL
- en: We take great pains in creating our code so that it be as decoupled as possible.
    Ensuring that classes have minimal dependence on other classes is the key to building
    a system that can change fluently with the changing needs of those using the software.
    Allowing classes to be too closely related means that changes ripple through them
    like, well, ripples.
  prefs: []
  type: TYPE_NORMAL
- en: 'One ripple isn''t a huge problem but, as you throw more and more changes into
    the mix, the ripples add up and create interference patterns. Soon the once placid
    surface is an unrecognizable mess of additive and destructive nodes. This same
    problem occurs in our applications: the changes magnify and interact in unexpected
    ways. One place where we tend to forget about coupling is in the creation of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see in this class that the Ruler''s house is strongly coupled to the
    class `Targaryen` . If this were ever to change then this tight coupling would
    have to change in a great number of places. This chapter discusses a number of
    patterns, which were originally presented in the gang of four book, *Design Patterns:
    Elements of Reusable Object-Oriented Software* . The goal of these patterns is
    to improve the degree of coupling in applications and increase the opportunities
    for code reuse. The patterns are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Builder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factory method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course not all of these are applicable to JavaScript, but we'll see all about
    that as we work through the creational patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first pattern presented here is a method for creating kits of objects without
    knowing the concrete types of the objects. Let's continue with the system presented
    in the preceding section for ruling a kingdom.
  prefs: []
  type: TYPE_NORMAL
- en: For the kingdom in question the ruling house changes with some degree of frequency.
    In all likelihood there is a degree of battling and fighting during the change
    of house but we'll ignore that for the moment. Each house will rule the kingdom
    differently. Some value peace and tranquility and rule as benevolent leaders,
    while others rule with an iron fist. The rule of a kingdom is too large for a
    single individual so the king defers some of his decisions to a second in command
    known as the hand of the king. The king is also advised on matters by a council,
    which consists of some of the more savvy lords and ladies of the land.
  prefs: []
  type: TYPE_NORMAL
- en: 'A diagram of the classes in our description look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory](Image00005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Unified Modeling Language** ( **UML** ) is a standardized language developed
    by the Object Management Group, which describes computer systems. There is vocabulary
    in the language for creating user interaction diagrams, sequence diagrams, and
    state machines, amongst others. For the purposes of this book we''re most interested
    in class diagrams, which describe the relationship between a set of classes.'
  prefs: []
  type: TYPE_NORMAL
- en: The entire UML class diagram vocabulary is extensive and is beyond the scope
    of this book. However, the Wikipedia article available at [https://en.wikipedia.org/wiki/Class_diagram](https://en.wikipedia.org/wiki/Class_diagram)
    acts as a great introduction as does Derek Banas' excellent video tutorial on
    class diagrams available at [https://www.youtube.com/watch?v=3cmzqZzwNDM](https://www.youtube.com/watch?v=3cmzqZzwNDM)
    .
  prefs: []
  type: TYPE_NORMAL
- en: An issue is that, with the ruling family, and even the member of the ruling
    family on the throne, changing so frequently, coupling to a concrete family such
    as Targaryen or Lannister makes our application brittle. Brittle applications
    do not fare well in an ever-changing world.
  prefs: []
  type: TYPE_NORMAL
- en: An approach to fixing this is to make use of the abstract factory pattern. The
    abstract factory declares an interface for creating each of the various classes
    related to the ruling family.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class diagram of this pattern is rather daunting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory](Image00006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The abstract factory class may have multiple implementations for each of the
    various ruling families. These are known as concrete factories and each of them
    will implement the interface provided by the abstract factory. The concrete factories,
    in return, will return concrete implementations of the various ruling classes.
    These concrete classes are known as products.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking at the code for the interface for the abstract factory.
  prefs: []
  type: TYPE_NORMAL
- en: 'No code? Well, actually that is exactly the case. JavaScript''s dynamic nature
    precludes the need for interfaces to describe classes. Instead of having interfaces
    we''ll just create the classes right off the bat:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory](Image00007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Instead of interfaces, JavaScript trusts that the class you provide implements
    all the appropriate methods. At runtime the interpreter will attempt to call the
    method you request and, if it is found, call it. The interpreter simply assumes
    that if your class implements the method then it is that class. This is known
    as **duck typing** .
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Duck typing**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The name duck typing comes from a 2000 post to the *comp.lang.python* news
    group by Alex Martelli in which he wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '*In other words, don''t check whether it IS-a duck: check whether it QUACKS-like-a
    duck, WALKS-like-a duck, and so on, depending on exactly what subset of duck-like
    behavior you need to play your language-games with.*'
  prefs: []
  type: TYPE_NORMAL
- en: I enjoy the possibility that Martelli took the term from the witch-hunt sketch
    from *Monty Python and the Holy Grail* . Although I can find no evidence of that,
    I think it quite likely as the Python programming language takes its name from
    Monty Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Duck typing is a powerful tool in dynamic languages allowing for much less
    overhead in implementing a class hierarchy. It does, however, introduce some uncertainty.
    If two classes implement an identically named method which have radically different
    meanings then there is no way to know if the one being called is the correct one.
    Consider for example this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Both classes have a `punch()` method but they clearly have different meanings.
    The JavaScript interpreter has no idea that they are different classes and will
    happily call punch on either class, even when one doesn't make sense.
  prefs: []
  type: TYPE_NORMAL
- en: Some dynamic languages support a generic method, which is called whenever an
    undefined method is called. Ruby, for instance, has `missing_method` , which has
    proven to be very useful in a number of scenarios. As of writing, there is currently
    no support for `missing_method` in JavaScript. However, ECMAScript 2016, the follow
    up to ECMAScript 2015, defines a new construct called `Proxy` which will support
    dynamically wrapping objects, with this one could implement an equivalent of `missing_method`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate an implementation of the Abstract Factory the first thing we''ll
    need is an implementation of the `King` class. This code provides that implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This code does not include the module structure suggested in [Chapter 2](text00019.html#page
    "Chapter 2. Organizing Code") , *Organizing Code* . Including the boiler-plate
    module code in every example is tedious and you're all smart cookies so you know
    to put this in modules if you're going to actually use it. The fully modularized
    code is available in the distributed source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is just a regular concrete class and could really contain any implementation
    details. We''ll also need an implementation of the `HandOfTheKing` class which
    is equally unexciting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The concrete factory method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This code simply instantiates new instances of each of the required classes
    and returns them. An alternative implementation for a different ruling family
    would follow the same general form and might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of the Abstract Factory in JavaScript is much easier than
    in other languages. However the penalty for this is that you lose the compiler
    checks, which force a full implementation of either the factory or the products.
    As we proceed through the rest of the patterns, you'll notice that this is a common
    theme. Patterns that have a great deal of plumbing in statically typed languages
    are far simpler but create a greater risk of runtime failure. Appropriate unit
    tests or a JavaScript compiler can ameliorate this situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make use of the Abstract Factory we''ll first need a class that requires
    the use of some ruling family:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now call this `CourtSession` class and inject different functionality
    depending on which factory we pass in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Despite the differences between a static language and JavaScript, this pattern
    remains applicable and useful in JavaScript applications. Creating a kit of objects,
    which work together, is useful in a number of situations; any time a group of
    objects need to collaborate to provide functionality but may need to be replaced
    wholesale. It may also be a useful pattern when attempting to ensure that a set
    of objects be used together without substitutions.
  prefs: []
  type: TYPE_NORMAL
- en: Builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our fictional world we sometimes have some rather complicated classes, which
    need to be constructed. The classes contain different implementations of an interface
    depending on how they are constructed. In order to simplify the building of these
    classes and encapsulate the knowledge about building the class away from the consumers,
    a builder may be used. Multiple concrete builders reduce the complexity of the
    constructor in the implementation. When new builders are required, a constructor
    does not need to be added, a new builder just needs to be plugged in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tournaments are an example of a complicated class. Each tournament has a complicated
    setup involving the events, the attendees, and the prizes. Much of the setup for
    these tournaments is similar: each one has a joust, archery, and a melee. Creating
    a tournament from multiple places in the code means that the responsibility for
    knowing how to construct a tournament is distributed. If there is a need to change
    the initiation code then it must be done in a lot of different places.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Employing a builder pattern avoids this issue by centralizing the logic necessary
    to build the object. Different concrete builders can be plugged into the builder
    to construct different complicated objects. The relationship between the various
    classes in the builder pattern is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Builder](Image00008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s drop in and look at some of the code. To start with, we''ll create a
    number of utility classes, which will represent the parts of a tournament as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The tournament itself is a very simple class as we don''t need to assign any
    of the public properties explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll implement two builders which create different tournaments. This can
    be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally the director, or as we''re calling it `TournamentBuilder` , simply
    takes a builder and executes it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Again you'll see that the JavaScript implementation is far simpler than the
    traditional implementation due to there being no need for interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Builders need not return a fully realized object. This means that you can create
    a builder which partially hydrates an object then allows the object to be passed
    on to another builder for it to finish. A good real world analogy might be the
    manufacturing process for a car. Each station along the assembly line builds just
    a part of the car before passing it onto the next station to build another part.
    This approach allows for dividing the work of building an object amongst several
    classes with limited responsibility. In our example above we could have a builder
    that is responsible for populating the events and another that is responsible
    for populating the attendees.
  prefs: []
  type: TYPE_NORMAL
- en: Does the builder pattern still make sense in view of JavaScript's prototype
    extension model? I believe so. There are still cases where a complicated object
    needs to be created according to different approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Factory method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already looked at the Abstract Factory and a builder. The Abstract Factory
    builds a family of related classes and the builder creates complicated objects
    using different strategies. The factory method pattern allows a class to request
    a new instance of an interface without the class making decisions about which
    implementation of the interface to use. The factory may use some strategy to select
    which implementation to return:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Factory method](Image00009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sometimes this strategy is simply to take a string parameter or to examine some
    global setting to act as a switch.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our example world of Westeros there are plenty of times when we would like
    to defer the choice of implementation to a factory. Just like the real world,
    Westeros has a vibrant religious culture with dozens of competing religions worshiping
    a wide variety of gods. When praying in each religion, different rules must be
    followed. Some religions demand sacrifices while others demand only that a gift
    be given. The prayer class doesn't want to know about all the different religions
    and how to construct them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with creating a number of different gods to which prayers can
    be offered. This code creates three gods including a default god to whom prayers
    fall if no other god is specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve avoided any sort of implementation details for each god. You may imagine
    whatever traditions you want to populate the `prayTo` methods. There is also no
    need to ensure that each of the gods implements an `IGod` interface. Next we''ll
    need a factory, which is responsible for constructing each of the different gods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that in this example we''re taking in a simple string to decide
    how to create a god. It could be done via a global or via a more complicated object.
    In some polytheistic religions in Westeros, gods have defined roles as gods of
    courage, beauty, or some other aspect. The god to which one must pray is determined
    by not just the religion but the purpose of the prayer. We can represent this
    with a `GodDeterminant` class as is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The factory would be updated to take this class instead of the simple string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the last step is to see how this factory would be used. It is quite
    simple, we just need to pass in a string that denotes which religion we wish to
    observe and the factory will construct the correct god and return it. This code
    demonstrates how to call the factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Once again there is certainly need for a pattern such as this in JavaScript.
    There are plenty of times where separating the instantiation from the use is useful.
    Testing the instantiation is also very simple thanks to the separation of concerns
    and the ability to inject a fake factory to allow testing of `Prayer` is also
    easy.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing the trend of creating simpler patterns without interfaces, we can
    ignore the interface portion of the pattern and work directly with the types,
    thanks to duck typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Factory Method is a very useful pattern: it allows classes to defer the selection
    of the implementation of an instantiation to another class. This pattern is very
    useful when there are multiple similar implementations such as the strategy pattern
    (see [Chapter 5](text00044.html#page "Chapter 5. Behavioral Patterns") , *Behavioral
    Patterns* ) and is commonly used in conjunction with the Abstract Factory pattern.
    The Factory Method is used to build the concrete objects within a concrete implementation
    of the abstract factory. An Abstract Factory pattern may contain a number of Factory
    Methods. Factory Method is certainly a pattern that remains applicable in the
    land of JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Singleton pattern is perhaps the most overused pattern. It is also a pattern
    that has fallen out of favor in recent years. To see why people are starting to
    advise against using Singleton let's take a look at how the pattern works.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton is used when a global variable is desirable, but Singleton provides
    protection against accidentally creating multiple copies of complex objects. It
    also allows for the deferral of object instantiation until the first use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The UML diagram for Singleton looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Singleton](Image00010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is clearly a very simple pattern. The Singleton acts as a wrapper around
    an instance of the class and the singleton itself lives as a global variable.
    When accessing the instance we simply ask the Singleton for the current instance
    of the wrapped class. If the class does not yet exist within the Singleton it
    is common to create a new instance at that time.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within our ongoing example in the world of Westeros, we need to find a case
    where there can only ever be one of something. Unfortunately, it is a land with
    frequent conflicts and rivalries, and so my first idea of using the king as the
    Singleton is simply not going to fly. This split also means that we cannot make
    use of any of the other obvious candidates (capital city, queen, general, and
    so on). However, in the far north of Westeros there is a giant wall constructed
    to keep an ancient enemy at bay. There is only one of these walls and it should
    pose no issue having it in the global scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and create a singleton in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The code creates a lightweight representation of the Wall. The Singleton is
    demonstrated in the two highlighted sections. In a language like C# or Java we
    would normally just set the constructor to be private so that it could only be
    called by the static method `getInstance` . However, we don''t have that ability
    in JavaScript: constructors cannot be private. Thus we do the best we can and
    return the current instance from the constructor. This may appear strange but
    in the way we''ve constructed our classes the constructor is no different from
    any other method so it is possible to return something from it.'
  prefs: []
  type: TYPE_NORMAL
- en: In the second highlighted section we set a static variable, `_instance` , to
    be a new instance of the Wall when one is not already there. If that `_instance`
    already exists, we return that. In C# and Java, there would need to be some complicated
    locking logic in this function to avoid race conditions as two different threads
    attempted to access the instance at the same time. Fortunately, there is no need
    to worry about this in JavaScript where the multi-threading story is different.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Singletons have gained something of a bad reputation in the last few years.
    They are, in effect, glorified global variables. As we've discussed, global variables
    are ill conceived and the potential cause of numerous bugs. They are also difficult
    to test with unit tests as the creation of the instance cannot easily be overridden
    and any form of parallelism in the test runner can introduce difficult-to-diagnose
    race conditions. The single largest concern I have with them is that singletons
    have too much responsibility. They control not just themselves but also their
    instantiation. This is a clear violation of the single responsibility principle.
    Almost every problem that can be solved by using a Singleton is better solved
    using some other mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript makes the problem even worse. It isn't possible to create a clean
    implementation of the Singleton due to the restrictions on the constructor. This,
    coupled with the general problems around the Singleton, lead me to suggest that
    the Singleton pattern should be avoided in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final creational pattern in this chapter is the Prototype pattern. Perhaps
    this name sounds familiar. It certainly should: it is the mechanism through which
    JavaScript inheritance is supported.'
  prefs: []
  type: TYPE_NORMAL
- en: We looked at prototypes for inheritance but the applicability of prototypes
    need not be limited to inheritance. Copying existing objects can be a very useful
    pattern. There are numerous cases where being able to duplicate a constructed
    object is handy. For instance, maintaining a history of the state of an object
    is easily done by saving previous instances created by leveraging some sort of
    cloning.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Westeros, we find that members of a family are frequently very similar;
    as the adage goes: "like father, like son". As each generation is born it is easier
    to create the new generation through copying and modifying an existing family
    member than to build one from scratch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 2](text00019.html#page "Chapter 2. Organizing Code") , *Organizing
    Code* , we looked at how to copy existing objects and presented a very simple
    piece of code for cloning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This code can easily be altered to be used inside a class to return a copy
    of itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted section of code is the modified clone method. It can be used
    as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The Prototype pattern allows for a complex object to be constructed only once
    and then cloned into any number of objects that vary only slightly. If the source
    object is not complicated there is little to be gained from taking a cloning approach.
    Care must be taken when using the prototype approach to think about dependent
    objects. Should the clone be a deep one?
  prefs: []
  type: TYPE_NORMAL
- en: Prototype is obviously a useful pattern and one that forms an integral part
    of JavaScript from the get go. As such it is certainly a pattern that will see
    some use in any JavaScript application of appreciable size.
  prefs: []
  type: TYPE_NORMAL
- en: Tips and tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creational patterns allow for specialized behavior in creating objects. In many
    cases, such as the factory, they provide extension points into which crosscutting
    logic can be placed. That is to say logic that applies to a number of different
    types of objects. If you're looking for a way to inject, say, logging throughout
    your application, then being able to hook into a factory is of great utility.
  prefs: []
  type: TYPE_NORMAL
- en: For all the utility of these creational patterns they should not be used very
    frequently. The vast majority of your object instantiations should still be just
    the normal method of improving the objects. Although it is tempting to treat everything
    as a nail when you've got a new hammer, the truth is that each situation needs
    to have a specific strategy. All these patterns are more complicated than simply
    using `new` and complicated code is more liable to have bugs than simple code.
    Use `new` whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presented a number of different strategies for creating objects.
    These methods provide abstractions over the top of typical methods for creating
    objects. The Abstract Factory provides a method for building interchangeable kits
    or collections of related objects. The Builder pattern provides a solution to
    telescoping parameters issues. It makes the construction of large complicated
    objects easier. The Factory Method, which is a useful complement to Abstract Factory,
    allows different implementations to be created though a static factory. Singleton
    is a pattern for providing a single copy of a class that is available to the entire
    solution. It is the only pattern we've seen so far which has presented some questions
    around applicability in modern software. The Prototype pattern is a commonly used
    pattern in JavaScript for building objects based on other existing objects.
  prefs: []
  type: TYPE_NORMAL
- en: We'll continue our examination of classical design patterns in the next chapter
    by looking at structural patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4. Structural Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at a number of ways to create objects in
    order to optimize for reuse. In this chapter, we'll take a look at structural
    patterns; these are patterns that are concerned with easing the design by describing
    simple ways in which objects can interact.
  prefs: []
  type: TYPE_NORMAL
- en: Again, we will limit ourselves to the patterns described in the GoF book. There
    are a number of other interesting structural patterns that have been identified
    since the publication of the GoF and we'll look at those in part 2 of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The patterns we''ll examine here are:'
  prefs: []
  type: TYPE_NORMAL
- en: Adapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bridge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Façade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flyweight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once again, we'll discuss whether the patterns that were described years ago
    are still relevant for a different language and a different time.
  prefs: []
  type: TYPE_NORMAL
- en: Adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From time to time there is a need to fit a round peg in a square hole. If you''ve
    ever played with a child''s shape sorting toy then you may have discovered that
    you can, in fact, put a round peg in a square hole. The hole is not completely
    filled and getting the peg in there can be difficult:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adapter](Image00011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To improve the fit of the peg an adapter can be used. This adapter fills the
    hole in completely resulting in a perfect fit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adapter](Image00012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In software a similar approach is often needed. We may need to make use of a
    class that does not perfectly fit the required interface. The class may be missing
    methods or may have additional methods we would like to hide. This occurs frequently
    when dealing with third party code. In order to make it comply with the interface
    needed in your code, an adapter may be required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class diagram for an adapter is very simple as can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adapter](Image00013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The interface of the implementation does not look the way we would like it to
    for use in our code. Normally the solution to this is to simply refactor the implementation
    so it looks the way we would like it to. However, there are a number of possible
    reasons that cannot be done. Perhaps the implementation exists inside third party
    code to which we have no access. It is also possible that the implementation is
    used elsewhere in the application where the interface is exactly as we would like
    it to be.
  prefs: []
  type: TYPE_NORMAL
- en: The adapter class is a thin piece of code that implements the required interface.
    It typically wraps a private copy of the implementation class and proxy calls
    through to it. The adapter pattern is frequently used to change the abstraction
    level of the code. Let's take a look at a quick example.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the land of Westeros, much of the trade and travel is done by boat. It is
    not only more dangerous to travel by ship than to walk or travel by horse, but
    also riskier due to the constant presence of storms and pirates. These ships are
    not the sort which might be used by Royal Caribbean to cruise around the Caribbean;
    they are crude things which might look more at home captained by 15th century
    European explorers.
  prefs: []
  type: TYPE_NORMAL
- en: 'While I am aware that ships exist, I have very little knowledge of how they
    work or how I might go about navigating one. I imagine that many people are in
    the same ( *cough!* ) boat as me. If we look at the interface for a Ship in Westeros,
    it looks intimidating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'I would really like a much simpler interface that abstracts away all the fiddly
    little details. Ideally something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This looks like something I could probably figure out even living in a city
    that is over 1000 kilometers from the nearest ocean. In short, what I'm looking
    for is a higher-level abstraction around the Ship. In order to transform a Ship
    into a SimpleShip we need an adapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The adapter will have the interface of SimpleShip but it will perform actions
    on a wrapped instance of Ship. The code might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In reality these functions would be far more complex, but it should not matter
    much because we've got a nice simple interface to present to the world. The presented
    interface can also be set up so as to restrict access to certain methods on the
    underlying type. When building library code, adapters can be used to mask the
    internal method and only present the limited functions needed to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this pattern, the code might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: You would likely not want to use adapter in the name of your client class as
    it leaks some information about the underlying implementation. Clients should
    be unaware they are talking to an adapter.
  prefs: []
  type: TYPE_NORMAL
- en: The adapter itself can grow to be quite complex to adjust one interface to another.
    In order to avoid creating very complex adapters, care must be taken. It is certainly
    not inconceivable to build several adapters, one atop another. If you find an
    adapter becoming too large then it is a good idea to stop and examine if the adapter
    is following the single responsibility principle. That is to say, ensure that
    each class has only one thing for which it has some responsibility. A class that
    looks up users from a database should not also contain functionality for sending
    e-mails to these users. That is too much responsibility. Complex adapters can
    be replaced with a composite object, which will be explored later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: From the testing perspective, adapters can be used to totally wrap third party
    dependencies. In this scenario they provide a place into which to hook tests.
    Unit tests should avoid testing libraries but they can certainly test the adapters
    to ensure that they are proxying through the correct calls.
  prefs: []
  type: TYPE_NORMAL
- en: The adapter is a very powerful pattern for simplifying code interfaces. Massaging
    interfaces to better match a requirement is useful in countless places. The pattern
    is certainly useful in JavaScript. Applications written in JavaScript tend to
    make use of a large number of small libraries. By wrapping up these libraries
    in adapters I'm able to limit the number of places I interact with the libraries
    directly; this means that the libraries can easily be replaced.
  prefs: []
  type: TYPE_NORMAL
- en: The adapter pattern can be slightly modified to provide consistent interfaces
    over a number of different implementations. This is usually known as the bridge
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Bridge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bridge pattern takes the adapter pattern to a new level. Given an interface,
    we can build multiple adapters, each one of which acts as an intermediary to a
    different implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'An excellent example that I''ve run across, is dealing with two different services
    that provide more or less the same functionality and are used in a failover configuration.
    Neither service provides exactly the interface required by the application and
    both services provide different APIs. In order to simplify the code, adapters
    are written to provide a consistent interface. The adapters implement a consistent
    interface and provide fills so that each API can be called consistently. To expand
    on the shape sorter metaphor a bit more, we can imagine that we have a variety
    of different pegs we would like to use to fill the square hole. Each adapter fills
    in the missing bits and helps us get a good fit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bridge](Image00014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The bridge is a very useful pattern. Let''s take a look at how to implement
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bridge](Image00015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The adapters shown in the preceding diagram sit between the implementation and
    the desired interface. They modify the implementation to fit in with the desired
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've already discussed that in the land of Westeros the people practice a number
    of disparate religions. Each one has a different way of praying and making offerings.
    There is a lot of complexity around making the correct prayers at the correct
    time and we would like to avoid exposing this complexity. Instead we'll write
    a series of adapters that can simplify prayers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need is a number of different gods to which we can pray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'These classes should look familiar as they are basically the same classes found
    in the previous chapter where they were used as examples for the factory method.
    You may notice, however, that the signature for the `prayTo` method for each religion
    is slightly different. This proves to be something of an issue when building a
    consistent interface like the one shown in pseudo code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'So let''s slot in a few adapters to act as a bridge between the classes we
    have and the signature we would like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Each one of these adapters implements the `God` interface we wanted and abstracts
    away the complexity of dealing with three different interfaces, one for each god:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the Bridge pattern, we could write code like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This code uses the bridges to provide a consistent interface to the gods such
    that they can all be treated as equals.
  prefs: []
  type: TYPE_NORMAL
- en: In this case we are simply wrapping the individual gods and proxying method
    calls through to them. The adapters could each wrap a number of objects and this
    is another useful place in which to use the adapter. If a complex series of objects
    needs to be orchestrated, then an adapter can take some responsibility for that
    orchestration providing a simpler interface to other classes.
  prefs: []
  type: TYPE_NORMAL
- en: You can imagine how useful the bridge pattern is. It can be used well in conjunction
    with the factory method pattern presented in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern certainly remains a very useful one for use in JavaScript. As I
    mentioned at the start of this section, it is handy for dealing with different
    APIs in a consistent fashion. I have used it for swapping in different third party
    components such as different graphing libraries or phone system integration points.
    If you're building applications on a mobile platform using JavaScript, then the
    bridge pattern is going to be a great friend for you, allowing you to separate
    your common and platform specific code cleanly. Because there are no interfaces
    in JavaScript, the bridge pattern is far closer to the adapter in JavaScript than
    in other languages. In fact, it is basically exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: A bridge also makes testing easier. We are able to implement a fake bridge and
    use this to ensure that the calls into the bridge are correct.
  prefs: []
  type: TYPE_NORMAL
- en: Composite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter I mentioned that we would like to avoid coupling our
    objects together tightly. Inheritance is a very strong form of coupling and I
    suggested that, instead, composites should be used. The composite pattern is a
    special case of this in which the composite is treated as interchangeable with
    the components. Let's explore how the composite pattern works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class diagram contains two different ways to build a composite
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Composite](Image00016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the first one, the composite component is built from a fixed number of a
    variety of components. The second component is constructed from a collection of
    indeterminate length. In both cases the components contained within the parent
    composition could be of the same type as the composition. So a composition may
    contain instances of its own type.
  prefs: []
  type: TYPE_NORMAL
- en: The key feature of the composite pattern is the interchangeability of a component
    with its children. So, if we have a composite which implements `IComponent` ,
    then all of the components of the composite will also implement `IComponent` .
    This is, perhaps, best illustrated with an example.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tree structures are very useful in computing. It turns out that a hierarchical
    tree can represent many things. A tree is made up of a series of nodes and edges
    and is a cyclical. In a binary tree, each node contains a left and right child
    until we get down to the terminal nodes known as leaves.
  prefs: []
  type: TYPE_NORMAL
- en: 'While life is difficult in Westeros there is an opportunity for taking joy
    in things like religious holidays or weddings. At these events there is typically
    a great deal of feasting on delicious foods. The recipes for these foods is much
    as you would find in your own set of recipes. A simple dish like baked apples
    contains a list of ingredients:'
  prefs: []
  type: TYPE_NORMAL
- en: Baking apple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Honey
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Butter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nuts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each one of these ingredients implements an interface which we'll refer to as
    `IIngredient` . More complex recipes contain more ingredients, but in addition
    to that, more complex recipes may contain complex ingredients that are themselves
    made from other ingredients.
  prefs: []
  type: TYPE_NORMAL
- en: 'A popular dish in a southern part of Westeros is a dessert which is not at
    all unlike what we would call tiramisu. It is a complex recipe with ingredients
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Custard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whipped cream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coffee
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of course custard itself is made from:'
  prefs: []
  type: TYPE_NORMAL
- en: Milk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sugar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eggs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vanilla
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custard is a composite as is coffee and cake.
  prefs: []
  type: TYPE_NORMAL
- en: Operations on the composite object are typically proxied through to all of the
    contained objects.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A simple ingredient, one which would be a leaf node, is shown in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be used interchangeably with a compound ingredient which has a list
    of ingredients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The composite ingredient loops over its internal ingredients and performs the
    same operation on each of them. There is, of course, no need to define an interface
    due to the prototype model.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make use of this compound ingredient we might do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course this only shows part of the power of the pattern. We could use rice
    pudding as an ingredient in an even more complicated recipe: rice pudding stuffed
    buns (they have some strange foods in Westeros). As both the simple and compound
    version of the ingredient have the same interface, the caller does not need to
    know that there is any difference between the two ingredient types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Composite is a heavily used pattern in JavaScript code that deals with HTML
    elements, as they are a tree structure. For example, the jQuery library provides
    a common interface if you have selected a single element or a collection of elements.
    When a function is called it is actually called on all the children, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This will hide all the links on a page regardless of how many elements are actually
    found by calling `$("a")` . The composite is a very useful pattern for JavaScript
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The decorator pattern is used to wrap and augment an existing class. Using a
    decorator pattern is an alternative to subclassing an existing component. Subclassing
    is typically a compile time operation and is a tight coupling. This means that
    once subclassing is performed, there is no way to alter it at runtime. In cases
    where there are many possible subclassings that can act in combination, the number
    of combinations of subclassings explodes. Let's look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The armor worn by knights in Westeros can be quite configurable. Armor can
    be fabricated in a number of different styles: scale, lamellar, chainmail, and
    so on. In addition to the style of armor, there is also a variety of different
    face guards, knee, and elbow joints, and, of course, colors. The behavior of armor
    made from lamellar and a grille is different from chainmail with a face visor.
    You can see, however, that there is a large number of possible combinations; far
    too many combinations to explicitly code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What we do instead is implement the different styles of armor using the decorator
    pattern. A decorator works using a similar theory to the adapter and bridge patterns,
    in that it wraps another instance and proxy calls through. The decorator pattern,
    however, performs the redirections at runtime by having the instance to wrap passed
    into it. Typically, a decorator will act as a simple pass through for some methods
    and for others it will make some modifications. These modifications could be limited
    to performing an additional action before passing the call off to the wrapped
    instance or could go so far as to change the parameters passed in. A UML representation
    of the decorator pattern looks like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Decorator](Image00017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This allows for very granular control over which methods are altered by the
    decorator and which remain as mere pass-through. Let's take a look at an implementation
    of the pattern in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this code we have a base class, `BasicArmor` , and it is then decorated
    by the `ChainMail` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ChainMail` armor takes in an instance of armor that complies with an interface,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: That instance is wrapped and calls proxied through. The method `GetArmorIntegiry`
    modifies the result from the underlying class while `CalculateDamageFromHit` modifies
    the arguments that are passed into the decorated class. This `ChainMail` class
    could, itself, be decorated with several more layers of decorators until a long
    chain of methods is actually called for each method call. This behavior, of course,
    remains invisible to outside callers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make use of this armor decorator, look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: It is tempting to make use of JavaScript's ability to rewrite individual methods
    on classes to implement this pattern. Indeed, in an earlier draft of this section
    I had intended to suggest just that. However, doing so is syntactically messy
    and not a common way of doing things. One of the most important things to keep
    in mind when programming is that code must be maintainable, not only by you but
    also by others. Complexity breeds confusion and confusion breeds bugs.
  prefs: []
  type: TYPE_NORMAL
- en: The decorator pattern is a valuable pattern for scenarios where inheritance
    is too limiting. These scenarios still exist in JavaScript, so the pattern remains
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: Façade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The façade pattern is a special case of the Adapter pattern that provides a
    simplified interface over a collection of classes. I mentioned such a scenario
    in the section on the adapter pattern but only within the context of a single
    class, `SimpleShip` . This same idea can be expanded to provide an abstraction
    around a group of classes or an entire subsystem. The façade pattern in UML form
    looks like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Façade](Image00018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we take the same `SimpleShip` as before and expand it to an entire fleet,
    we have a great example of a use for creating a façade. If it was difficult to
    sail a single ship it would be far more difficult to command an entire fleet of
    ships. There is a great deal of nuance required, commands to individual ships
    would have to be made. In addition to the individual ships there must also be
    a fleet Admiral and a degree of coordination between the ships in order to distribute
    supplies. All of this can be abstracted away. If we have a collection of classes
    representing the aspects of a fleet such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we might build a façade as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Façades are very useful abstractions, especially in dealing with APIs. Using
    a façade around a granular API can create an easier interface. The level of abstraction
    at which the API works can be raised so that it is more in sync with how your
    application works. For instance, if you''re interacting with the Azure blob storage
    API you could raise the level of abstraction from working with individual files
    to working with collections of files. Instead of writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'A façade could be written which encapsulates all of these calls and provides
    an interface, like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: As you can see façades remain useful in JavaScript and should be a pattern that
    remains in your toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Flyweight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In boxing there is a light weight division between 49-52 kg known as the flyweight
    division. It was one of the last divisions to be established and was named, I
    imagine, for the fact that the fighters in it were tiny, like flies.
  prefs: []
  type: TYPE_NORMAL
- en: The flyweight pattern is used in instances when there are a large number of
    instances of objects which vary only slightly. I should perhaps pause here to
    mention that a large number, in this situation, is probably in the order of 10,000
    objects rather than 50 objects. However, the cutoff for the number of instances
    is highly dependent on how expensive the object is to create.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the object may be so expensive that only a handful are required
    before they overload the system. In this case introducing flyweight at a smaller
    number would be beneficial. Maintaining a full object for each object consumes
    a lot of memory. It seems that the memory is largely consumed wastefully too,
    as most of the instances have the same value for their fields. Flyweight offers
    a way to compress this data by only keeping track of the values that differ from
    some prototype in each instance.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript's prototype model is ideal for this scenario. We can simply assign
    the most common value to the prototype and have individual instances override
    them as needed. Let's see how that looks with an example.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Returning once more to Westeros (aren''t you glad I''ve opted for a single
    overarching problem domain?) we find that armies are full of ill-equipped fighting
    people. Within this set of people there is really very little difference from
    the perspective of the generals. Certainly each person has their own life, ambitions,
    and dreams but they have all been adapted into simple fighting automatons in the
    eyes of the general. The general is only concerned with how well the soldiers
    fight, if they''re healthy, and if they''re well fed. We can see the simple set
    of fields in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, with an army of 10,000 soldiers, keeping track of all of this requires
    quite some memory. Let''s take a different approach and use a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this approach, we are able to defer all requests for the soldier''s health
    to the prototype. Setting the value is easy too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: You'll note that we make a call to delete to remove the property override and
    return the value back to the parent value.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final pattern presented in this chapter is the proxy. In the previous section
    I mentioned how it is expensive to create objects and how we would like to avoid
    creating too many of them. The proxy pattern provides a method of controlling
    the creation and use of expensive objects. The UML of the proxy pattern looks
    like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Proxy](Image00019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the proxy mirrors the interface of the actual instance. It
    is substituted in for the instance in all the clients and, typically, wraps a
    private instance of the class. There are a number of places where the proxy pattern
    can be of use:'
  prefs: []
  type: TYPE_NORMAL
- en: Lazy instantiation of an expensive object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protection of secret data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stubbing for remote method invocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interposing additional actions before or after method invocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often an object is expensive to instantiate and we don't want to have instances
    created before they're actually used. In this case the proxy can check its internal
    instance and, if not yet initiated, create it before passing on the method call.
    This is known as lazy instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: If a class has been designed without any security in mind but now requires some,
    this can be provided through the use of a proxy. The proxy will check the call
    and only pass on the method call in cases where the security checks out.
  prefs: []
  type: TYPE_NORMAL
- en: The proxy may be used to simply provide an interface to methods that are invoked
    somewhere else. In fact, this is exactly how a number of web socket libraries
    function, proxying calls back to the web server.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there may be cases where it is useful to interpose some functionality
    into the method invocation. This could be logging of parameters, validating of
    parameters, altering results, or any number of things.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a look at a Westeros example where method interposition is needed.
    As tends to happen, the units of measurement for liquids vary greatly from one
    side of the land to the other. In the north, one might buy a pint of beer, while
    in the south, one would buy it by the dragon. This causes no end of confusion
    and code duplication, but can be solved by wrapping classes that care about measurement
    in proxies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this code is for a barrel calculator which estimates the number
    of barrels needed to ship a quantity of liquid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Although it is not well documented, here this version takes pints as a volume
    parameter. A proxy is created which deals with the transformation thusly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Equally we might create another proxy for a pint-based barrel calculator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This proxy class does the unit conversion for us and helps alleviate some confusion
    around units. Some languages, such as F#, support the concept of units of measure.
    In effect it is a typing system which is overlaid over simple data types such
    as integers, preventing programmers from making mistakes such as adding a number
    representing pints to one representing liters. Out of the box in JavaScript there
    is no such capability. Using a library such as JS-Quantities ([http://gentooboontoo.github.io/js-quantities/](http://gentooboontoo.github.io/js-quantities/)
    ) is an option however. If you look at it, you'll see the syntax is quite painful.
    This is because JavaScript doesn't permit operator overloading. Having seen how
    weird adding things such as an empty array to an empty array are (it results in
    an empty string), I think perhaps we can be thankful that operator overloading
    isn't supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to protect against accidentally using the wrong sort of calculator
    when we have pints and think we have dragons, then we could stop with our primitive
    obsession and use a type for the quantity, a sort of poor person''s units of measure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'This can then be used as a guard in the proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we end up with pretty much what JS-Quantities does but in a
    more ES6 form.
  prefs: []
  type: TYPE_NORMAL
- en: The proxy is absolutely a useful pattern within JavaScript. I already mentioned
    that it is used by web socket libraries when generating stubs but it finds itself
    useful in countless other locations.
  prefs: []
  type: TYPE_NORMAL
- en: Hints and tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of the patterns presented in this chapter provide methods of abstracting
    functionality and of molding interfaces to look the way you want. Keep in mind
    that with each layer of abstraction a cost is introduced. Function calls take
    longer but it is also much more confusing for people who need to understand your
    code. Tooling can help a little but tracking a function call through nine layers
    of abstraction is never fun.
  prefs: []
  type: TYPE_NORMAL
- en: Also be wary of doing too much in the façade pattern. It is very easy to turn
    the façade into a fully-fledged management class and that degrades easily into
    a God object that is responsible for coordinating and doing everything.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we've looked at a number of patterns used to structure the interaction
    between objects. Some of them are quite similar to each other but they are all
    useful in JavaScript, although the bridge is effectively reduced to an adapter.
    In the next chapter we'll finish our examination of the original GoF patterns
    by looking at behavioral patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5. Behavioral Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter we looked at structural patterns that describe ways in which
    objects can be constructed to ease interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we''ll take a look at the final, and largest, grouping of GoF
    patterns: behavioral patterns. These patterns are ones that provide guidance on
    how objects share data or, from a different perspective, how data flows between
    objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The patterns we''ll look at are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Chain of responsibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpreter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mediator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memento
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once again there are a number of more recently identified patterns that could
    well be classified as behavioral patterns. We'll defer looking at those until
    a later chapter, instead keeping to the GoF patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Chain of responsibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can think of a function call on an object as sending that object a message.
    Indeed this message passing mentality is one that dates back to the days of Smalltalk.
    The chain of responsibility pattern describes an approach in which a message tickles
    down from one class to another. A class can either act on the message or allow
    it to be passed on to the next member of the chain. Depending on the implementation
    there are a few different rules that can be applied to the message passing. In
    some situations only the first matching link in the chain is permitted to act.
    In others, every matching link acts on the message. Sometimes the links are permitted
    to stop processing or even to mutate the message as it continues down the chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chain of responsibility](Image00020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see if we can find a good example of this pattern in our go-to example:
    the land of Westeros.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is very little in the way of a legal system in Westeros. Certainly there
    are laws and even city guards who enforce them but the judicial system is scant.
    The law of the land is really decided by the king and his advisors. Those with
    the time and money can petition for an audience with the king who will listen
    to their complaint and pass a ruling. This ruling is law. Of course any king who
    spent his entire day listening to the complaints of peasants would go mad. For
    this reason many of the cases are caught and solved by his advisors before they
    reach his ears.
  prefs: []
  type: TYPE_NORMAL
- en: 'To represent this in code we''ll need to start by thinking about how the chain
    of responsibility would work. A complaint comes in and it starts with the lowest
    possible person who can solve it. If that person cannot or will not solve the
    problem it tickles up to a more senior member of the ruling class. Eventually
    the problem reaches the king who is the final arbiter of disputes. We can think
    of him as the default dispute solver who is called upon when all else fails. The
    chain of responsibility is visible in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](Image00021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll start with an interface to describe those who might listen to complaints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface requires two methods. The first is a simple check to see if the
    class is able to resolve a given complaint. The second listens to and resolves
    the complaint. Next we''ll need to describe what constitutes a complaint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we need a couple of different classes which implement `ComplaintListener`
    and are able to solve complaints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Each one of these classes implements a different approach to solving the complaint.
    We need to chain them together making sure that the king is in the default position.
    This can be seen in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will work its way through each of the listeners until it finds one
    that is interested in hearing the complaint. In this version the result is returned
    immediately, halting any further processing. There are variations of this pattern
    in which multiple listeners could fire, even allowing the listeners to mutate
    the parameters for the next listener. The following diagram shows multiple listeners
    configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](Image00022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chain of responsibility is a highly useful pattern in JavaScript. In browser-based
    JavaScript the events that fire fall through a chain of responsibility. For instance
    you can attach multiple listeners to the click event on a link and each of them
    will fire and then, finally, the default navigation listener. It is likely that
    you're using chain of responsibility in much of your code without even knowing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The command pattern is a method of encapsulating both the parameters to a method,
    as well as the current object state, and which method is to be called. In effect
    the command pattern packs up everything needed to call a method at a later date
    into a nice little package. Using this approach one can issue a command and wait
    until a later date to decide which piece of code will execute the command. This
    package can then be queued or even serialized for later execution. Having a single
    point of command execution also allows for easily adding functionality such as
    undo or command logging.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern can be a bit difficult to imagine so let''s break it down into
    its components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Command](Image00023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Command message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first component of the command pattern is, predictably, the command itself.
    As I mentioned, the command encapsulates everything needed to invoke a method.
    This includes the method name, the parameters, and any global state. As you can
    imagine keeping track of global state in each command is very difficult. What
    happens if the global state changes after the command has been created? This dilemma
    is yet another reason why using a global state is problematic and should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of options for setting up commands. At the simple end of
    the scale all that is needed is to track a function and a set of parameters. Because
    functions are first class objects in JavaScript, they can easily be saved into
    an object. We can also save the parameters to the function into a simple array.
    Let's build a command using this very simple approach.
  prefs: []
  type: TYPE_NORMAL
- en: The deferred nature of commands suggests an obvious metaphor in the land of
    Westeros. There are no methods of communicating quickly in Westeros. The best
    method is to attach small messages to birds and release them. The birds have a
    tendency to want to return to their homes, so each lord raises a number of birds
    in their home and, when they come of age, sends them to other lords who might
    wish to communicate with them. The lords keep an aviary of birds and retain records
    of which bird will travel to which other lord. The king of Westeros sends many
    of his commands to his loyal lords through this method.
  prefs: []
  type: TYPE_NORMAL
- en: The commands sent by the king contain all necessary instructions for the lords.
    The command may be something like bring your troops and the arguments to that
    command may be a number of troops, a location, and a date by which the command
    must be carried out.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript the simplest way of representing this is through an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'This array can be passed around and invoked at will. To invoke it, a generic
    function can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this function only works for commands with three arguments.
    You can, of course, expand this to any number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The additional parameters are undefined, but the function doesn't use them so
    there are no ill effects. Of course, this is not at all an elegant solution.
  prefs: []
  type: TYPE_NORMAL
- en: It is desirable to build a class for each sort of command. This allows you to
    ensure the correct arguments have been supplied and easily distinguish the different
    sorts of commands in a collection. Typically, commands are named using the imperative,
    as they are instructions. Examples of this are BringTroops, Surrender, SendSupplies,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s transform our ugly simple command into a proper class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: We may wish to implement some logic to ensure that the parameters passed into
    the constructor are correct. This will ensure that the command fails on creation
    instead of on execution. It is easier to debug the issue during creation rather
    than during execution as execution could be delayed, even for days. The validation
    won't be perfect, but even if it catches only a small portion of the errors it
    is helpful.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned these commands can be saved for later use in memory or even written
    to disk.
  prefs: []
  type: TYPE_NORMAL
- en: Invoker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The invoker is the part of the command pattern which instructs the command
    to execute its instructions. The invoker can really be anything: a timed event,
    a user interaction, or just the next step in the process may all trigger invocation.
    When we executed the `simpleCommand` command in the preceding section, we were
    playing at being the invoker. In a more rigorous command the invoker might look
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, invoking a command is very easy. Commands may be invoked at
    once or at some later date. One popular approach is to defer the execution of
    the command to the end of the event loop. This can be done in a node with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The function `process.nextTick` defers the execution of a command to the end
    of the event loop such that, if it is executed next time the process has nothing
    to do.
  prefs: []
  type: TYPE_NORMAL
- en: Receiver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final component in the command pattern is the receiver. This is the target
    of the command execution. In our example we created a receiver called `LordInstructions`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The receiver knows how to perform the action that the command has deferred.
    There need not be anything special about the receiver, in fact it may be any class
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: Together these components make up the command pattern. A client will generate
    a command, pass it off to an invoker that may delay the command or execute it
    at once, and the command will act upon a receiver.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of building an undo stack, the commands are special, in that they
    have both an `Execute` and an `Undo` method. One takes the application state forward
    and the other takes it backwards. To perform an undo, simply pop the command off
    the undo stack, execute the `Undo` function, and push it onto a redo stack. For
    redo, pop from redo, execute `Execute` , and push to the undo stack. Simple as
    that, although one must make sure all state mutations are performed through commands.
  prefs: []
  type: TYPE_NORMAL
- en: The GoF book outlines a slightly more complicated set of players for the command
    pattern. This is largely due to the reliance on interfaces that we've avoided
    in JavaScript. The pattern becomes much simpler thanks to the prototype inheritance
    model in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The command pattern is a very useful one for deferring the execution of some
    piece of code. We'll actually explore the command pattern and some useful companion
    patterns in [Chapter 10](text00087.html#page "Chapter 10. Messaging Patterns")
    , *Messaging Patterns* .
  prefs: []
  type: TYPE_NORMAL
- en: Interpreter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The interpreter pattern is an interesting pattern as it allows for the creation
    of your own language. This might sound like something of a crazy idea, we're already
    writing JavaScript, why would we want to create a new language? Since the publication
    of the GoF book **Domain specific languages** ( **DSLs** ) have had something
    of a renaissance. There are situations where it is quite useful to create a language
    that is specific to one requirement. For instance the **Structured Query** **Language**
    ( **SQL** ) is very good at describing the querying of relational databases. Equally,
    regular expressions have proven themselves to be highly effective for the parsing
    and manipulation of text.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many scenarios in which being able to create a simple language is
    useful. That''s really the key: a simple language. Once the language gets more
    complicated, the advantages are quickly lost to the difficulty of creating what
    is, in effect, a compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is different from those we've seen to this point as there is no
    real class structure that is defined by the pattern. You can design your language
    interpreter however you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our example let us define a language which can be used to describe historical
    battles in the land of Westeros. The language must be simple for clerics to write
    and easy to read. We''ll start by creating a simple grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that we''re just writing out a rather nice syntax that will
    let people describe battles. A battle between Robert Baratheon and RhaegarTargaryen
    at the river Trident would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Using this grammar we would like to build some code which is able to query a
    list of battles for answers. In order to do this we're going to rely on regular
    expressions. For most languages this wouldn't be a good approach as the grammar
    is too complicated. In those cases one might wish to create a lexor and a parser
    and build up syntax trees, however, by that point you may wish to re-examine if
    creating a DSL is really a good idea. For our language the syntax is very simple
    so we can get away with regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we establish is a JavaScript data model for the battle like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we need a parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'It is likely best that you don''t think too much about that regular expression.
    However, the class does take in a list of battles (one per line) and using `next
    Battle` , allows one to parse them. To use the class we simply need to do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: This data structure can now be queried like one would for any other structure
    in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned earlier there is no fixed way to implement this pattern, so the
    implementation done in the preceding code is provided simply as an example. Your
    implementation will very likely look very different and that is just fine.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreter can be a useful pattern in JavaScript. It is, however, a pretty
    infrequently used pattern in most situations. The best example of a language interpreted
    in JavaScript is the less language that is compiled, by JavaScript, to CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traversing collections of objects is an amazingly common problem. So much so
    that many languages provide for special constructs just for moving through collections.
    For example C# has a `foreach` loop and Python has `for x in` . These looping
    constructs are frequently built on top of an iterator. An iterator is a pattern
    that provides a simple method for selecting, sequentially, the next item in a
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface for an iterator looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the land of Westeros there is a well-known sequence of people in line for
    the throne in the very unlikely event that the king was to die. We can set up
    a handy iterator over the top of this collection and simply call `next` on it
    should the ruler die:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'This is primed with an array and then we can call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'An interesting application of iterators is to not iterate over a fixed collection.
    For instance an iterator can be used to generate sequential members of an infinite
    set like the fibonacci sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'This is used like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Iterators are handy constructs allowing for exploring not just arrays but any
    collection or even any generated list. There are a ton of places where this can
    be used to great effect.
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript 2015 iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Iterators are so useful that they are actually part of the next generation
    of JavaScript. The iterator pattern used in ECMAScript 2015 is a single method
    that returns an object that contains `done` and `value` . `done` is `true` when
    the iterator is at the end of the collection. What is nice about the ECMAScript
    2015 iterators is that the array collection in JavaScript will support the iterator.
    This opens up a new syntax which can largely replace the `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterators are a syntactic nicety that has long been missing from JavaScript.
    Another great feature of ECMAScript-2015 are generators. This is, in effect, a
    built in iterator factory. Our fibonacci sequence could be rewritten like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'This is used like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Mediator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing many-to-many relationships in classes can be a complicated prospect.
    Let's consider a form that contains a number of controls, each of which wants
    to know if other controls on the page are valid before performing their action.
    Unfortunately, having each control know about each other control creates a maintenance
    nightmare. Each time a new control is added, each other control needs to be modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'A mediator will sit between the various components and act as a single place
    in which message routing changes can be made. By doing so the mediator simplifies
    the otherwise complex work needed to maintain the code. In the case of controls
    on a form, the mediator is likely to be the form itself. The mediator acts much
    like a real life mediator would, clarifying and routing information exchange between
    a number of parties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mediator](Image00024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the land of Westeros there are many times when a mediator is needed. Frequently
    the mediator ends up deceased, but I'm sure that won't be the case with our example.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of great families in Westeros who own large castles and vast
    tracts of land. Lesser lords swear themselves to the great houses forming an alliance,
    frequently supported through marriage.
  prefs: []
  type: TYPE_NORMAL
- en: When coordinating the various houses sworn to them, the great lord will act
    as a mediator, communicating information back and forth between the lesser lords
    and resolving any disputes they may have amongst themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example we''ll greatly simplify the communication between the houses
    and say that all messages pass through the great lord. In this case we''ll use
    the house of Stark as our great lord. They have a number of other houses which
    talk with them. Each of the houses looks roughly like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'They have two functions, one of which receives messages from a third party
    and one of which sends messages out to their great lord, which is set upon instantiation.
    The `HouseStark` class looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: By passing all messages through the `HouseStark` class the various other houses
    do not need to concern themselves with how their messages are routed. This responsibility
    is handed off to `HouseStark` which acts as the mediator.
  prefs: []
  type: TYPE_NORMAL
- en: Mediators are best used when the communication is both complex and well defined.
    If the communication is not complex then the mediator adds extra complexity. If
    the communication is ill defined then it becomes difficult to codify the communication
    rules in a single place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simplifying communication between many-to-many objects is certainly useful
    in JavaScript. I would actually argue that in many ways jQuery acts as a mediator.
    When acting on a set of items on the page, it serves to simplify communication
    by abstracting away code''s need to know exactly which objects on the page are
    being changed. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Is jQuery shorthand for toggling the visibility of all the elements on the page
    which have the `error` class?
  prefs: []
  type: TYPE_NORMAL
- en: Memento
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the section on the command pattern we talked briefly about the ability to
    undo operations. Creating reversible commands is not always possible. For many
    operations there is no apparent reversing operation which can restore the original
    state. For instance, imagine code which squares a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Giving this code -9 will result in 81 but giving it 9 will also result in 81\.
    There is no way to reverse this command without additional information.
  prefs: []
  type: TYPE_NORMAL
- en: The memento pattern provides an approach to restore the state of objects to
    a previous state. The memento keeps a record of the previous values of a variable
    and provides the functionality to restore them. Keeping a memento around for each
    command allows for easy restoration of non-reversible commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to an undo-stack there are many instances where having the ability
    to roll back the state of an object is useful. For instance doing what-if analysis
    requires that you make some hypothetical changes to state and then observe how
    things change. The changes are generally not permanent so they could be rolled
    back using the memento pattern or, if the projects are desirable, left in place.
    A diagram of the memento pattern can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Memento](Image00025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A typical memento implementation involves three players:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Originator** : The originator holds some form of state and provides an interface
    for generating new mementos.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caretaker** : This is the client of the pattern, it is what requests that
    new mementos be taken and governs when they are to be restored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memento** : This is a representation of the saved state of the originator.
    This is what can be persisted to storage to allow for rolling back.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can help to think of the members of the memento pattern as a boss and a secretary
    taking notes. The boss (caretaker) dictates some memo to the secretary (originator)
    who writes notes in a notepad (memento). From time to time the boss may request
    that the secretary cross out what he has just written.
  prefs: []
  type: TYPE_NORMAL
- en: The involvement of the caretaker can be varied slightly with the memento pattern.
    In some implementation the originator will generate a new memento each time a
    change is made to its state. This is commonly known as copy on write, as a new
    copy of the state is created and the change applied to it. The old version can
    be saved to a memento.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the land of Westeros there are a number of soothsayers, foretellers of the
    future. They work by using magic to peer into the future and examine how certain
    changes in the present will play out in the future. Often there is need for numerous
    foretelling with slightly different starting conditions. When setting their starting
    conditions, a memento pattern is invaluable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start off with a world state which gives information on the state of the
    world for a certain starting point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: This `WorldState` class is responsible for tracking all the conditions that
    make up the world. It is what is altered by the application every time a change
    to the starting conditions is made. Because this world state encompasses all the
    states for the application, it can be used as a memento. We can serialize this
    object and save it to disk or send it back to some history server somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we need is a class which provides the same state as the memento
    and allows for the creation and restoration of mementos. In our example we''ve
    called this as `WorldStateProvider` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally we need a client for the foretelling, which we''ll call `Soothsayer`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: This class provides a number of convenience methods which alter the state of
    the world and then run a foretelling. Each of these methods pushes the previous
    state into the history array, `startingPoints` . There is also a method, `tryADifferentChange`
    , which undoes the previous state change ready to run another foretelling. The
    undo is performed by loading back the memento which is stored in an array.
  prefs: []
  type: TYPE_NORMAL
- en: Despite a great pedigree it is very rare that client side JavaScript applications
    provide an undo function. I'm sure there are various reasons for this, but for
    the most part it is likely that people do not expect such functionality. However
    in most desktop applications, having an undo function is expected. I imagine that,
    as client side applications continue to grow in their capabilities, undo functionality
    will become more important. When it does, the memento pattern is a fantastic way
    of implementing the undo stack.
  prefs: []
  type: TYPE_NORMAL
- en: Observer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The observer pattern is perhaps the most used pattern in the JavaScript world.
    The pattern is used especially with modern single pages applications; it is a
    big part of the various libraries that provide **Model View View-Model** ( **MVVM**
    ) functionality. We'll explore those patterns in some detail in [Chapter 7](text00067.html#page
    "Chapter 7. Reactive Programming") , *Reactive Programming* .
  prefs: []
  type: TYPE_NORMAL
- en: 'It is frequently useful to know when the value on an object has changed. In
    order to do so you could wrap up the property of interest with a getter and setter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The setter function can now be augmented with a call to some other object which
    is interested in knowing that a value has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: This setter will now notify the listener that a property change has occurred.
    In this case both the old and new value have been included. This is not necessary
    as the listener can be tasked with keeping track of the previous value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The observer pattern generalizes and codifies this idea. Instead of having
    a single call to the listener, the observer pattern allows interested parties
    to subscribe to change notifications. Multiple subscribers can be seen in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Observer](Image00026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The court of Westeros is a place of great intrigue and trickery. Controlling
    who is on the throne and what moves they make is a complex game. Many of the players
    in the game of thrones employ numerous spies to discover what moves others are
    making. Frequently these spies are employed by more than one player and must report
    what they have found to all of the players.
  prefs: []
  type: TYPE_NORMAL
- en: The spy is a perfect place to employ the observer pattern. In our particular
    example, the spy being employed is the official doctor to the king and the players
    are very interested in how much painkiller is being prescribed to the ailing king.
    Knowing this can give a player advanced knowledge of when the king might die –
    a most useful piece of information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The spy looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'In other languages, the subscriber usually has to comply with a certain interface
    and the observer will call only the interface method. This encumbrance doesn''t
    exist with JavaScript and, in fact, we just give the `Spy` class a function. This
    means that there is no strict interface required for the subscriber. This is an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be used like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: This provides a very simple and highly effective way of building observers.
    Having subscribers decouples the subscriber from the observable object.
  prefs: []
  type: TYPE_NORMAL
- en: The observer pattern can also be applied to methods as well as properties. In
    so doing you can provide hooks for additional behavior to happen. This is a common
    method of providing a plugin infrastructure for JavaScript libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In browsers all the event listeners on various items in the DOM are implemented
    using the observer pattern. For instance, using the popular jQuery library, one
    can subscribe to all the `click` events on buttons on a page by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Even in vanilla JavaScript the same pattern applies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Clearly the observer pattern is very useful when dealing with JavaScript. There
    is no need to change the pattern in any significant fashion.
  prefs: []
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'State machines are an amazingly useful device in computer programming. Unfortunately
    they are not used very frequently by most programmers. I''m sure that at least
    some of the objection to state machines is that many people implement them as
    a giant `if` statement like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: This is just a sample of what could be much longer. The `if` statements of this
    length are painful to debug and highly error prone. Simply flipping a greater
    than sign is enough to drastically change how the `if` statement works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using a single giant `if` statement block we can make use of the
    state pattern. The state pattern is characterized by having a state manager which
    abstracts away the internal state and proxies a message through to the appropriate
    state which is implemented as a class. All the logic within states and governing
    state transitions is governed by the individual state classes. The state manager
    pattern can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![State](Image00027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Splitting state into a class per state allows for much smaller blocks of code
    to debug and makes testing much easier.
  prefs: []
  type: TYPE_NORMAL
- en: The interface for the state manager is fairly simple and usually just provides
    the methods needed to communicate with the individual states. The manager may
    also contain some shared state variables.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As alluded to in the `if` statement example, Westeros has a banking system.
    Much of it is centered on the island of Braavos. Banking there runs in much the
    same way as banking here, with accounts, deposits, and withdrawals. Managing the
    state of a bank account involves keeping an eye on all of the transactions and
    changing the state of the bank account in accordance with the transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at some of the code which is needed to manage a bank account
    at the Iron Bank of Braavos. First is the state manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: The `BankAccountManager` class provides a state for the current balance and
    also the current state. To protect the balance, it provides an accessory for reading
    the balance and another for adding to the balance. In a real banking application,
    I would rather expect the function that sets the balance, have more protection
    than this. In this version of `BankManager` , the ability to manipulate the current
    state is accessible to the states. They have the responsibility to change states.
    This functionality can be centralized in the manager but that increases the complexity
    of adding new states.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve identified three simple states for the bank account: `Overdrawn` , `OnHold`
    , and `GoodStanding` . Each one is responsible for dealing with withdrawals and
    deposits when in that state. The `GoodStandingstate` class looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OverdrawnState` class looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `OnHold` state looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we've managed to reproduce all the logic of the confusing `if`
    statement in a number of simple classes. The amount of code here looks to be far
    more than the `if` statement but, in the long run, encapsulating the code into
    individual classes will pay off.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is plenty of opportunity to make use of this pattern within JavaScript.
    Keeping track of state is a typical problem in most applications. When the transitions
    between the states are complex, then wrapping it up in a state pattern is one
    method of simplifying things. It is also possible to build up a simple workflow
    by registering events as sequential. A nice interface for this might be a fluent
    one so that you could register states like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It has been said that there is more than one way to skin a cat. I have, wisely,
    never looked into how many ways there are. The same is frequently true for algorithms
    in computer programming. Frequently there are numerous versions of an algorithm
    that trades off memory usage for CPU usage. Sometimes there are different approaches
    that provide different levels of fidelity. For example, performing a geo-location
    on a smart phone typically uses one of three different sources of data:'
  prefs: []
  type: TYPE_NORMAL
- en: GPS chip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cell phone triangulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nearby WiFi points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the GPS chip provides the highest level of fidelity however it is also
    the slowest and requires the most battery. Looking at the nearby WiFi points requires
    very little energy and is very quick, however it provides poor fidelity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The strategy pattern provides a method of swapping these strategies out in
    a transparent fashion. In a traditional inheritance model each strategy would
    implement the same interface which would allow for any of the strategies to be
    swapped in. The following diagram shows multiple strategies that could be swapped
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategy](Image00028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Selecting the correct strategy to use can be done in a number of different ways.
    The simplest method is to select the strategy statically. This can be done through
    a configuration variable or even hard coded. This approach is best for times when
    the strategy changes infrequently or is specific to a single customer or user.
  prefs: []
  type: TYPE_NORMAL
- en: Alternately an analysis can be run on the dataset on which the strategy is to
    be run and then a proper strategy selected. If it is known that strategy A works
    better than strategy B when the data passed in is clustered around a mean, then
    a fast algorithm for analyzing spread could be run first and then the appropriate
    strategy selected.
  prefs: []
  type: TYPE_NORMAL
- en: If a particular algorithm fails on data of a certain type, this too can be taken
    into consideration when choosing a strategy. In a web application this can be
    used to call a different API depending on the shape of data. It can also be used
    to provide a fallback mechanism should one of the API endpoints be down.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting approach is to use progressive enhancement. The fastest
    and least accurate algorithm is run first to provide rapid user feedback. At the
    same time a slower algorithm is also run and, when it is finished, the superior
    results are used to replace the existing results. This approach is frequently
    used in the GPS situation outlined above. You may notice when using a map on a
    mobile device your location is updated a moment after the map loads; this is an
    example of progressive enhancement.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the strategy can be chosen completely at random. It sounds like a strange
    approach but can be useful when comparing the performance of two different strategies.
    In this case, statistics would be gathered about how well each approach works
    and an analysis run to select the best strategy. The strategy pattern can be the
    foundation for A/B testing.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting which strategy to use can be an excellent place to apply the factory
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the land of Westeros there are no planes, trains, or automobiles but there
    is still a wide variety of different ways to travel. One can walk, ride a horse,
    sail on a seagoing vessel, or even take a boat down the river. Each one has different
    advantages and drawbacks but in the end they still take a person from point A
    to point B. The interface might look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'The travel result communicates back to the caller some information about the
    method of travel. In our case we track how long the trip will take, what the risks
    are, and how much it will cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: In this scenario we might like to have an additional method which predicts some
    of the risks to allow for automating selection of a strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing the strategies is as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: In a traditional implementation of the strategy pattern the method signature
    for each strategy should be the same. In JavaScript there is a bit more flexibility
    as excess parameters to a function are ignored and missing parameters can be given
    default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, the actual calculations around risk, cost, and duration would not
    be hard coded in an actual implementation. To make use of these one needs only
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'To improve the level of abstraction for this strategy we might replace the
    specific strategies with more generally named ones that describe what it is we''re
    optimizing for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Strategy is a very useful pattern in JavaScript. We''re also able to make the
    approach much simpler than in a language which doesn''t use prototype inheritance:
    there is no need for an interface. We don''t need to return the same shaped object
    from each of the different strategies. So long as the caller is somewhat aware
    that the returned object may have additional fields, this is a perfectly reasonable,
    if difficult to maintain, approach.'
  prefs: []
  type: TYPE_NORMAL
- en: Template method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The strategy pattern allows for replacing an entire algorithm with a complimentary
    one. Frequently, replacing the entire algorithm is overkill: the vast majority
    of the algorithm remains the same in every strategy with only minor variations
    in specific sections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The template method pattern is an approach which allows for some sections of
    an algorithm to be shared and other sections implemented using different approaches.
    These farmed out sections can be implemented by any one of a family of methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Template method](Image00029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The template class implements parts of the algorithm and leaves other parts
    as abstract to later be overridden by classes which extend it. The inheritance
    hierarchy can be several layers deep, with each level implementing more and more
    of the template class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An abstract class is one that contains abstract methods. Abstract methods are
    simply methods that have no body to them. The abstract class cannot be used directly
    and must, instead, be extended by another class that implements the abstract methods.
    An abstract class may extend another abstract class so that not all methods need
    to be implemented by the extending class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach applies the principles of progressive enhancement to an algorithm.
    We move closer and closer to a fully implemented algorithm and, at the same time,
    build up an interesting inheritance tree. The template method helps keep identical
    code to a single location while still allowing for some deviation. A chain of
    partial implementations can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Template method](Image00030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Overriding methods left as abstract is a quintessential part of object oriented
    programming. It is likely that this pattern is one which you've used frequently
    without even being aware that it had a name.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I have been told, by those in the know, that there are many different ways to
    produce beer. These beers differ in their choice of ingredients and in their method
    of production. In fact beer does not even need to contain hops – it can be made
    from any number of grains. However there are similarities between all beers. They
    are all created through the fermentation process and all proper beers contain
    some alcohol content.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Westeros there are a great number of craftsmen who pride themselves on creating
    top notch beers. We would like to describe their processes as a set of classes,
    each one describing a different beer making methodology. We start with a simplified
    implementation of creating a beer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'As there is no concept of abstract in JavaScript we''ve added exceptions to
    the various methods which must be overridden. The remaining methods can be changed
    but do not require it. An implementation of this for a raspberry beer would look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Additional sub-classing may be performed at this stage for more specific raspberry
    beers.
  prefs: []
  type: TYPE_NORMAL
- en: The template method remains a fairly useful pattern in JavaScript. There is
    some added syntactic sugar around creating classes, but it isn't anything we haven't
    already seen in a previous chapter. The only warning I would give is that the
    template method uses inheritance and thus strongly couples the inherited classes
    with the parent class. This is generally not a desirable state of affairs.
  prefs: []
  type: TYPE_NORMAL
- en: Visitor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final pattern in this section is the visitor pattern. The visitor provides
    a method of decoupling an algorithm from the object structure on which it operates.
    If we wanted to perform some action over a collection of objects which differ
    in type and we want to perform a different action depending on the object type,
    we would typically need to make use of a large `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get right into an example of this in Westeros. An army is made up of
    a few different classes of fighting person (it is important that we be politically
    correct as there are many notable female fighters in Westeros). However, each
    member of the army implements a hypothetical interface called `IMemberOfArmy`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple implementation of this might be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a collection of these different types, we can use an `if` statement
    to only call the `printName` function on the knights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Except, if you run this code, you''ll actually find that all we get is the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: This is because, despite an object being a knight, it is still an object and
    `typeof` will return object in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative approach is to use `instanceof` instead of `typeof` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'The instance of approach works great until we run into somebody who makes use
    of the `Object.create` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Despite being a knight this will return `false` when asked if it is an instance
    of `Knight` .
  prefs: []
  type: TYPE_NORMAL
- en: This poses something of a problem for us. The problem is exacerbated by the
    visitor pattern as it requires that the language supports method overloading.
    JavaScript does not really support this. There are various hacks which can be
    used to make JavaScript somewhat aware of overloaded methods but the usual advice
    is to simply not bother and create methods with different names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s not abandon this pattern just yet, though; it is a useful pattern. What
    we need is a way to reliably distinguish one type from another. The simplest approach
    is to just define a variable on the class which denotes its type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the new `_type` variable we can now fake having real method overrides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this approach we can now implement a visitor. The first step is to expand
    our various members of the army to have a generic method on them which takes a
    visitor and applies it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to build a visitor. This code approximates the `if` statements
    we had in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'This visitor would be used as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see we''ve pushed the decisions about the type of the item in the
    collection down to the visitor. This decouples the items themselves from the visitor
    as can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visitor](Image00031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we allow the visitor to make decisions about what methods are called on the
    visited objects there is a fair bit of trickery required. If we can provide a
    constant interface for the visited objects then all the visitor needs do is call
    the interface method. This does, however, move logic from the visitor into the
    objects that are visited, which is contrary to the idea that the objects shouldn't
    know they are part of a visitor.
  prefs: []
  type: TYPE_NORMAL
- en: Whether suffering through the trickery is worthwhile is really an exercise for
    you. Personally I would tend to avoid using the visitor pattern in JavaScript
    as the requirements to get it working are complicated and non-obvious.
  prefs: []
  type: TYPE_NORMAL
- en: Hints and tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a couple of brief tips to keep in mind about some of the patterns
    we''ve seen in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: When implementing the interpreter pattern you may be tempted to use JavaScript
    proper as your DSL and then use the `eval` function to execute the code. This
    is actually a very dangerous idea as `eval` opens up an entire world of security
    issues. It is generally considered to be very bad form to use `eval` in JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you find yourself in the position to audit the changes to data in your project,
    then the memento pattern can easily be modified to suit. Instead of keeping track
    of just the state changes, you can also track when the change was made and who
    changed it. Saving these mementos to disk somewhere allows you to go back and
    rapidly build an audit log pointing to precisely what happened to change the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The observer pattern is notorious for causing memory leaks when listeners aren't
    properly unregistered. This can happen even in a memory managed environment such
    as JavaScript. Be wary of failing to unhook observers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we've looked at a bunch of behavioral patterns. Some of these
    patterns such as observer and iterator will be ones you'll use almost every day,
    while others such as interpreter you might use no more than a handful of times
    in your entire career. Learning about these patterns should help you identify
    well-defined solutions to common problems.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the patterns are directly applicable to JavaScript and some of them,
    such as the strategy pattern, become more powerful in a dynamic language. The
    only pattern we found that has some limitations is the visitor pattern. The lack
    of static classes and polymorphism makes this pattern difficult to implement without
    breaking proper separation of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: These aren't, by any means, all of the behavioral patterns in existence. The
    programming community has spent the past two decades building on the ideas of
    the GoF book and identifying new patterns. The remainder of this book is dedicated
    to these newly identified patterns. The solutions may be very old ones but not
    generally recognized as common solutions until more recently. As far as I'm concerned
    this is the point where the book starts to get very interesting as we start looking
    at less well known and more JavaScript-specific patterns.
  prefs: []
  type: TYPE_NORMAL
