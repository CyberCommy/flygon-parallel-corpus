- en: Building a Real-Time Chat Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will build a chat app with real-time communication. In the
    app, you will be able to send and receive messages and photos to and from other
    users, which will appear without the page needing to be refreshed. We will look
    at how we can use SignalR to implement a real-time connection with the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use SignalR in a Xamarin.Forms app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use template selectors for a ListView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use CSS-styling in a Xamarin.Forms app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you can build the app for this project, you need to build the backend
    that we detailed in [Chapter 6](a652292c-994d-4788-ad47-7a8deba3230c.xhtml)*, Setting
    up a Backend for a Chat App Using Azure Services*. You will also need to have
    Visual Studio for Mac or PC installed, as well as the Xamarin components. See [Chapter
    1](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml), *Introduction to Xamarin*, for
    more details on how to set up your environment. The source code for this chapter
    is available in the GitHub repository, which is available at [https://github.com/PacktPublishing/Xamarin.Forms-Projects/tree/master/Chapter-6-and-7](https://github.com/PacktPublishing/Xamarin.Forms-Projects/tree/master/Chapter-6-and-7).
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building a chat app, it is really important to have real-time communication
    because the user expects messages to arrive more or less immediately. To achieve
    this, we will use SignalR, which is a library for real-time communication. SignalR
    will use WebSockets if they are available and, if not, it will have several fallback
    options it can use instead. In the app, a user will be able to send text and photos
    from the photo library on the device.
  prefs: []
  type: TYPE_NORMAL
- en: The build time for this project is about 180 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use either Visual Studio 2017 on a PC or Visual Studio for Mac to do
    this project. To build an iOS app using Visual Studio for PC, you have to have
    a Mac connected. If you don't have a access to a Mac at all, you can choose to
    just build the Android part of the app.
  prefs: []
  type: TYPE_NORMAL
- en: Building the chat app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to start building the app. We recommend that you use the same method
    as in [Chapter 6](a652292c-994d-4788-ad47-7a8deba3230c.xhtml), *Setting up a Backend
    for a Chat App Using Azure Services*, because this will make code sharing easier.
    In that solution, create a Mobile App (Xamarin.Forms) with the name `Chat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36568c5f-b137-44c0-bc52-0e4248b43864.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the Blank template and use .NET Standard as the Code Sharing Strategy. Select iOS
    and Android as the platforms. After we have created the project, we will update
    all NuGet packages to the latest versions because the project templates are not
    updated as often as the packages that are used inside the templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e6b50ff-8208-4344-b14e-bd0666082aca.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating the chat service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we will do is create a chat service that will be used by both
    the iOS and Android applications. To make the code more testable and to make it
    easier to replace the chat service if we want to use another provider in the future,
    we will follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Chat` project, add a reference to the `Chat.Messages` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder in the `Chat` project called `Services`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new interface called `IChatService` in the `Services` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `bool` property called `IsConnected`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a method called `SendMessage`that takes `Message` as an argument and returns `Task`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a method called `CreateConnection` that returns `Task`. The method will
    create and start a connection to the SignalR service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a method called `Dispose` that returns` Task`. The method will be used
    when the app goes to sleep to ensure that the connection to the SignalR service
    is properly closed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface will also contain an event, but before we add the event to the
    interface, we will create an `EventArgs` class that the event will use. We will
    do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Chat` project, create a new folder called `Events`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class called `NewMessageEventArgs` in the `Events` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `EventArgs` as a base class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a property called `Message` of the `Message` type with a public getter
    and a private setter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a constructor with `Message` as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the parameter of the constructor to the `Message` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code is the result of these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have created a new `EventArgs` class, we can use it and add an
    event to the interface. We will name the event `NewMessage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we will do in the service is to make a call to the `GetSignalRInfo`
    service that we created in [Chapter 6](a652292c-994d-4788-ad47-7a8deba3230c.xhtml), *Setting
    up a Backend for a Chat App Using Azure Services*, to obtain information about
    how to connect to the SignalR service. To serialize that information, we will
    create a new class:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Chat` project, create a new folder called `Models`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class called `ConnectionInfo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a string property called `Url` for the `string`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a string property called `AccessToken` for the `string`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the interface and a model to obtain the connection information,
    it is time to create an implementation of the `IChatService` interface. To use
    SignalR, we need to add a package for NuGet that will give us the necessary classes.
    Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Chat` project, install the NuGet package, `Microsoft.AspNetCore.SignalR.Client`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Services` folder, create a new class called `ChatService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add and implement the `IChatService` interface to the `ChatService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a private field for `HttpClient` called `httpClient`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a private field for `HubConnection` called `hub`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a private field for `SemaphoreSlim` called `semaphoreSlim` and create a
    new instance with an initial and maximum count of one in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We will start with the `CreateConnection`, which will call the `GetSignalRInfo`
    function. We will then use the information to connect to the SignalR service and
    start listening for messages. To do this, carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a call to the `WaitAsync` method of `SemaphoreSlim` to make sure that only
    one thread can use the method at any one time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check weather `httpClient` is `null`. If it is, create a new instance. We will
    reuse the instance of the `httpClient` because this is better from a performance
    perspective.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make a call to `GetSignalRInfo` and serialize the result to a `ConnectionInfo`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have the information about how to connect to the SignalR service, we
    can use the `HubConnectionBuilder` to create a connection. We can then start listening
    for messages:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `HubConnectionBuilder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `WithUrl` method to specify the URL to the SignalR service as the first
    argument. The second argument is an `Action` of the `HttpConnectionObject` type.
    This means that you will get an object of the `HttpConnectionObject` type as a
    parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the action, set `AccessTokenProvider` to a `Func` that returns the value
    of the `AccessToken` property on the `ConnectionInfo` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `Build` method of the `HubConnectionBuilder` to create a connection
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `Action` that will run when new messages arrive using the `On<object>`
    method on the `HubConnection` object. The action will be specified as the second
    argument. For the first argument, we will specify the name of the target (we specified
    the target in [Chapter 6](a652292c-994d-4788-ad47-7a8deba3230c.xhtml), *Setting
    up a Backend for a Chat App Using Azure Services*, when we sent the message),
    which is `newMessage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Action`, convert the incoming message to a string using the `ToString`
    method and deserialize it to a `Message` object so we can read its `TypeInfo`
    property. To do this, use the `JsonConvert` class and the `DeserializeObject<Message>`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The reason we have to deserialize the object twice is that we only get the value
    of properties in the `Message` class the first time. When we know which subclass
    of `Message` we received, we can use this to deserialize that information for
    that class. We are casting it to `Message` so we can pass it to the `NewMessageEventArgs` object.
    In this case, we will not lose the properties of the subclass. To access the properties,
    we just cast the class back to the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: When we know what type the message is, we can use this to deserialize the object
    to the actual type. Use the `DeserializeObject` method of `JsonConvert` and pass
    the JSON string and the `TypeInfo` to it and then cast it to `Message`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the `NewMessage` event and pass the current instance of the `ChatService` and
    a new `NewMessageEventArgs` object to it. Pass the `Message` object to the constructor
    of `NewMessageEventArgs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we have a connection object and we have configured what will happen when
    a message arrives, we will start to listen to messages with the `StartAsync` method
    of the `HubConnection`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `IsConnected` property to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `Release` method of `SemaphoreSlim` to let other threads go to the
    `CreateConnection` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The next method to implement is the `SendMessage` method. This will send a
    message to an Azure function, which will add the message to the SignalR service:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `Serialize` method on the `JsonConvert` class to serialize the `Message`
    object to JSON.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `StringContent` object and pass the JSON string as the first argument,
    `Encoding.UTF8` as the second argument, and the content-type `application/json`
    as the last argument to the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `PostAsync` method on the `HttpClient` object with the URL as the first
    argument and the `StringContent` object as the second argument to post the message
    to the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The last method to implement is the `Dispose` method. This will close the connection
    when the app is entering the background state, for example when a user hits the
    home button or switches app:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `WaitAsync` method to ensure that there is no thread that is trying
    to create a connection or to dispose of a connection when we are running the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `if` statement to ensure that the hub field isn't `null`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is not null, call the `StopAsync` method and the `DisposeAsync` method
    of the `HubConnection`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `httpClient` field to `null`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `IsConnected` to `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Release `SemaphoreSlim`with the `Release` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Initializing the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now ready to write the initialization code for the app. We will set up
    **Inversion-of-Control** (**IoC**) and carry out the necessary configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a resolver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a helper class that will ease the process of resolving object
    graphs through Autofac. This will help us to create types based on a configured
    IoC container. In this project, we will use `Autofac` as the IoC library:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the `NuGet` package, `Autofac`, in the `Chat` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class called `Resolver` in the `Chat` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `private static` field called `container` of the `IContainer` type (from
    `Autofac`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a public static method called `Initialize` with `IContainer` as a parameter.
    Set the value of the parameter to the container field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a generic static public method called `Resolve`, which will return an instance
    that is based on the argument type with the `Resolve` method of `IContainer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Bootstrapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we will create a `Bootstrapper` class that we will use to set up the
    common configurations that we need in the startup phase of the app. Usually, there
    is one part of the Bootstrapper for each target platform and one that is shared
    for all platforms. In this project, we only need the shared part:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `Bootstrapper` in the`Chat`project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new public static method called `Init`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `ContainerBuilder` and register the types to the `container`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Container` using the `Build` method of the `ContainerBuilder`. Create
    a variable called `container` that should contain the instance of the `Container`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `Initialize` method on the `Resolver` and pass the `container` variable
    as an argument, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `Init` method of the `Bootstrapper` in the constructor in the `App.xaml.cs` file
    after the call to `InitializeComponents`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Creating a base ViewModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have a service that is responsible for handling the communication with
    the backend. It''s time to create a view model. First, however, we will create
    a base view model, where we can put the code that will be shared between all view
    models of the app:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder called `ViewModels`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class called `ViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the new class public and abstract.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a static field called `Navigation` of the `INavigation` type. This will
    be used to store a reference to the navigation services provided by Xamarin.Forms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a static field called `User` of the `string` type. The field will be used
    when connecting to the chat service so that messages you send will be displayed
    with your name attached.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add and implement the `INotifiedPropertyChanged` interface. This is necessary
    because we want to use data bindings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `Set` method that will make it easier for us to raise the `PropertyChanged` event
    from the `INotifiedPropertyChanged` interface. The method will check if the value
    has changed. If it has, it will raise the event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Creating the Mainview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our `ViewModel` base class set up and all of the code for receiving
    and sending messages, it's time to create the two views. These will act as the
    user interface of the app.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to start by creating the main view. This is the view that will
    be displayed when the user starts the app. We will add an entry control (an input
    textbox) so that the user can enter a username and add a command to navigate to
    the chat view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main view will be composed of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A `ViewModel` file called `MainViewModel.cs`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An XAML file called `MainView.xaml`, which contains the layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A code-behind file called `MainView.xaml.cs`, which will carry out the data-binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by creating the `ViewModel` for the `MainView`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating MainViewModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `MainViewModel` that we are about to create will hold a username that the
    user will enter in the UI. It will also contain a `Command` property called `Start`
    that will be bound to a `Button` that the user will click after entering their
    username:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `ViewModel` folder, create a class called `MainViewModel.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inherit the class from `ViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the class `public`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a property called `Username` of the `string` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a property called `Start` of the `ICommand` type and implement it as shown
    as the following. The `Start` command will assign the `Username` from the `Username`
    property and assign it to the static `User` property in the base `ViewModel`.
    It then creates a new instance of `ChatView` by using the `Resolver` and pushing
    it onto the navigation stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MainViewModel` should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the `MainViewModel`, we need a view that goes with it. It's
    time to create the `MainView`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the MainView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `MainView` will display a user interface that allows the user to enter a
    name before starting the chat. This section will be about creating the `MainView`
    XAML file and the code behind that view.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by removing the template-generated `MainPage` and replacing it
    with an MVVM-friendly `MainView`.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the MainPage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we created the app, the template generated a page called `MainPage`. Since
    we are using MVVM as a pattern, we need to remove this page and replace it with
    a view called `MainView` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: In the root of the `Chat` project, delete the page called `MainPage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder called `Views`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new XAML page called `MainView` in the `Views` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Editing the XAML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s now time to add some content to the newly created `MainView.xaml` file.
    The icons that are mentioned next can be found in the same folder that they should
    be added to if you go to the project on GitHub. The GitHub URL can be found at
    the beginning of this chapter. There is a lot going on here, so make sure to check
    what you write against the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `chat.png` icon to the `Drawable` folder that is inside the `Resources`
    folder in the Android project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `chat@2x.png` icon to the `Resources` folder in the iOS project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `MainView.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Title` property in the `ContentPage` node. This will be the title displayed
    in the navigation bar of the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Grid` and define two rows in it. The first one should have a height of
    `"*"` and the second one of `"2*"`. This will partition the space in two rows,
    of which the first will take up `1/3` of the space and the second will take up `2/3`
    of the space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `Image` with the `Source` set to `"chat.png"` and its `VerticalOptions`
    and `HorizontalOptions` set to `"Center"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `StackLayout` with the `Grid.Row` set to `"1"`, the `Padding` set to `"10"`,
    and the `Spacing` set to `"20"`. The `Grid.Row` property positions the `StackLayout`
    in the second row. The `Padding` adds 10 units of space around the `StackLayout`
    and the `Spacing` defines the amount of space between each element added in the
    `StackLayout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `StackLayout`, add an `Entry` node that has its `Text` property set to
    `"{Binding UserName}"` and a `Placeholder` property set to `"Enter a username"`.
    The binding of the Text node will make sure that, when the user enters a value
    in the `Entry` control, it's updated in the `ViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `StackLayout`, add a `Button` control that will have the `Text` property
    set to `"Start"` and its `Command` property set to `"{Binding Start}"`. The `Command` property
    binding will execute when the user taps the button. It will run the code that
    we defined in the `MainViewModel` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When finished, the code should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The layout is finished and we now need to turn our focus to the code behind
    this view to wire up some loose ends.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the code behind the view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with all views, when using MVVM, we need to pass our view a `ViewModel`.
    Since we are using dependency injection in this project, we will pass it through
    the constructor and then assign it to the `BindingContext` of the view itself.
    We will also make sure that we enable safe areas to avoid controls being partially
    hidden behind the iPhone X notch at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainView.xaml.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a parameter called `viewModel` of the `MainViewModel` type in the constructor
    of the `MainView` class. The argument for this parameter will be injected by `Autofac`
    at runtime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `platform-specific` statement that instructs the application to use safe
    areas on iOS. A safe area makes sure that the app does not use the space on the
    side of the notch at the top of the screen on an iPhone X.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the `viewModel` argument to the `BindingContext` property of the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The changes made are marked in bold in the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Our `MainView` is complete but we still need to tell the application to use
    it as the entry point view.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the main view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The entry point view, also referred to as the application''s `MainPage`, is
    set during the initialization of a Xamarin.Forms app. Usually, it is set in the
    constructor of the App class. We will be creating the `MainView` through the resolver
    we created earlier and wrapping it in `NavigationPage` to enable platform-specific
    navigation on the device that the app runs on:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `App.xaml.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resolve an instance to a `MainView` class by using the `Resolver` and storing
    it in a variable called `mainView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new instance of `NavigationPage` by passing the `mainView` variable
    as a constructor argument and assigning it to a variable called `navigationPage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the `navigationPage.Navigation` property to the static `Navigation` property
    on the `ViewModel` type. This property will be used when navigating between pages
    later on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assign the `navigationPage` variable to the `MainPage` property on the `App`
    class. This sets the start view of our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it for the `MainView`; nice and easy. Let''s now move on to something
    more interesting: the `ChatView` that will be used to send and receive messages.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ChatView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ChatView` is a standard chat client. It will have an area for displaying
    incoming and outgoing messages and a text field at the bottom in which the user
    can type a message. It will also have a button for taking a photo and a button
    for sending messages if the user doesn't hit return on the on-screen keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by creating the `ChatViewModel` that contains all of the logic
    by acting as the glue between the view and the model. Our model, in this case,
    is represented by our `ChatService`.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will create the `ChatView` that handles the rendering of the **Graphical
    User Interface** (**GUI**).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ChatViewModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated previously, the `ChatViewModel` is the glue between the visual representation
    (the `View`) and the model (which is basically our `ChatService`). The `ChatViewModel`
    will handle the storing of messages and the communication with the `ChatService`
    by hooking up the functionality to send and receive messages.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ChatViewModel` is a simple class that inherits from the `ViewModel` base
    class we created earlier. In the first code exercise, we will create the class,
    adding relevant `using` statements and a property called Messages in which we
    will store the messages that we have received. The view will use the Message collection
    to display the messages in a `ListView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is a large block of code, we recommend that you write it first and
    then go over the numbered list to get to grips with what has been added to the
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `ChatViewModel` in the `ViewModels` folder of the
    `Chat` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the class `public` and inherit it from the `ViewModel` base class to gain
    the common base functionality from the base class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `readonly` property called `chatService` of the `IChatService` type. This
    will store a reference to an object that implements `IChatService` and make the
    concrete implementation of `ChatService` replaceable. It's good practice to expose
    any service as an interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a public property called `Messages` of the `public ObservableCollection<Message>`type
    with a private setter. This collection will hold all messages. The private setter
    makes the property inaccessible from outside this class. This maintains the integrity
    of the collection by ensuring messages are not inserted anywhere but inside the
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a constructor parameter called `chatService` of the `IChatService` type. When
    we use dependency injection, this is where `Autofac` will inject an object that
    implements `IChatService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the constructor, assign the `chatService` parameter to the `chatService`
    property. This will store the reference to the `ChatService` so that we can use
    it during the lifetime of the `ChatViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the constructor, instantiate the `Messages` property to a new `ObservableCollection<Message>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the constructor, create a `Task.Run` statement that will call the `chatService.CreateConnection()`
    method if the `chatService.IsConnected` property is `false`. End the `Task.Run`
    statement by sending a new `UserConnected` message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our `ChatViewModel` instantiated, it's time to add a property
    that will hold whatever the user is typing at that moment.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the text property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the bottom of the GUI, there will be a text field (an entry control) that
    will allow the user to enter the message. This entry will be data-bound to a property
    that we will call `Text` in the `ChatViewModel`. Whenever the user changes the
    text, this property will be set. This is classic data binding:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new private field called `text` of the `string`type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a public property called `Text` that returns the private text field in
    the getter and makes a call to the `Set()` method of the base class in the setter.
    The `Set` method is defined in the `ViewModel` base class and will raise an event
    back to the view if the property changes in the `ChatViewModel`, effectively keeping
    them in `sync`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We now have a property ready for data-binding. Let's look at some code for receiving
    messages from the `ChatService`.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a message is sent from the server, over SignalR, the `ChatService` will
    parse this message and transform it into a Message object. It will then raise
    an event called `NewMessage`, which is defined in the ChatService.
  prefs: []
  type: TYPE_NORMAL
- en: What we will do in this section is implement an event handler to handle these
    events and add them to the Messages collection, unless a message with the same
    ID already exists in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, follow the steps and look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `ChatViewModel`, create a method called `ChatService_NewMessage`, which will
    be a standard event handler. This has two parameters:  `sender`, which is of the
    `object` type, and `e`, which is of the `Events.NewMessageEventArgs` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wrap the code in this method in a `Device.BeginInvokeOnMainThread()` since we
    are going to add messages to the Message collection. Items added to this collection
    will be modifying the view and any code that modifies the view must be run on
    the UI thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Device.BeginInvokeOnMainThread`, add the incoming message from `e.Message`
    to the `Messages` collection if a message with the specific `Message.Id` isn't
    already present in the collection. This is to avoid message duplication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The method should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When the event handler is defined, we need to hook it up in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the constructor of the `ChatViewModel` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wire up a `chatService.NewMessage` event to the `ChatService_NewMessage` handler
    we just created. A good place to do this is under the instantiation of the `Messages`
    collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code marked in bold is what we should add to the `ChatViewModel` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The app will now be able to receive messages. How about sending them? Well,
    stay tuned!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the LocalSimpleTextMessage class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make it easier to recognize whether a message is coming from the server
    or whether it is sent by the user of the device that the code is executing on,
    we will create a `LocalSimpleTextMessage`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class with the name `LocalSimpleTextMessage` in the `Chat.Messages`
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `SimpleTextMessage` as the base class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a constructor with `SimpleTextMessage` as the parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the value to all of the base properties with the value from the parameter,
    as in the code that follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Sending text messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sending text messages is also very straightforward. We need to create a command
    that we can data-bind for the GUI. The command will be executed either when the
    user hits return or when the user clicks the send button. When a user does either
    of these two things, the command will create a new `SimpleTextMessage` and pass
    in the current user to identify the message for other users. We will copy the
    text from the `ChatViewModel` text property, which, in turn, is in sync with the
    `Entry` control.
  prefs: []
  type: TYPE_NORMAL
- en: We will then add the message to the Messages collection, triggering the `ListView`
    that will be handling messages to update. After that, we will pass the message
    to the `ChatService` and clear the `ChatViewModel` text property. By doing this,
    we notify the GUI that it has changed and let the data-binding magic clear the
    field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following steps and look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new property called `Send` of the `ICommand` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign it a new `Command` instance and follow these steps to implement it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new instance of a `SimpleTextMessage` class by passing the User property
    of the base class as an argument. Assign the instance to a variable called `message`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Text` property of the message variable to the `Text` property of the
    `ChatViewModel` class. This copies the current text in the chat entry defined
    by the GUI later on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `LocalSimpleTextMessage` object and pass in the message variable as
    a constructor argument. The `LocalSimpleTextMessage` is a `SimpleTextMessage`
    and makes it possible for the view to recognize it as a message that the user
    of the app sent, effectively rendering it on the right side of the chat area.
    Add the `LocalSimpleTextMessage` instance to the Messages collection. This will
    display the message in the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a call to the `chatService.SendMessage()` method and pass the message variable
    as an argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Empty the `Text` property of the `ChatViewModel` to clear the entry control
    in the GUI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: What good is a chat app if we can't send photos? Let's implement this in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Acr.UserDialogs plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Acr.UserDialogs` is a plugin that makes it possible to use several standard
    user dialogs from code that are shared between platforms. To install and configure
    it, there are a few steps we need to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the `Acr.UserDialogs`NuGet package to the `Chat-`, `Chat.iOS`, and `Chat.Android` projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `MainActivity.cs` file, add `UserDialogs.Init(this)` in the `OnCreate`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Installing the Media plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the `Xam.Plugin.Media` NuGet package to access the photo library
    of the device. We need to install the package to the `Chat-`, `Chat.iOS`, and
    `Chat.Android` projects in the solution. Before we can use the package, however,
    we need to do some configuration for each platform. We will start with Android:'
  prefs: []
  type: TYPE_NORMAL
- en: The plugin needs the `WRITE_EXTERNAL_STORAGE`and `READ_EXTERNAL_STORAGE` permissions.
    The plugin will add these for us, but we need to override the `OnRequestPermissionResult`
    in the `MainActivity.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `OnRequestPermissionsResult` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `CrossCurrentActivity.Current.Init(this, savedInstanceState)`after the
    initalizing of Xamarin.Forms in the `OnCreate` method in the `MainActivity.cs`
    file, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add some configuration for the file paths from which the users
    can pick photos:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a folder called `xml` to the `Resources` folder in the Android project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new XML file called `file_paths.xml` in the new folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to `file_paths.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to do to set up the plugin for the Android project is
    to add the code that follows in the `AndroidManifest.xml` field inside the application
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For the iOS project, the only thing we need to do is to add the following four
    usage descriptions to the `info.plist`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Sending photos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to send photos, we will have to use a source of photos. In our case,
    we will be using the camera as the source. The camera will return the photo as
    a stream after it has been taken. We need to convert that stream into a byte array
    and then finally Base64 encode it into a string that is easy to send over SignalR.
  prefs: []
  type: TYPE_NORMAL
- en: The method that we are about to create, called `ReadFully()`, takes a stream
    and turns it into a byte array, which is a step towards achieving the Base64-encoded
    string. This is a standard piece of code that creates a buffer that will be used
    when we are reading the `Stream` parameter and writing it to the `MemoryStream`
    in chunks until we have read the full stream, hence the name of the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow along and check out the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a method called `ReadFully` that takes a `stream` called `input` as a
    parameter and returns a `byte` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare a `buffer` variable of the `byte[]` type and initialize it as a 16 KB
    big byte array. (`16 * 1024`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside a using statement, create a new `MemoryStream` called `ms`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Read the input of the `Stream` into the `ms` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Following this, we have a large chunk of code. This code exposes a command that
    will be executed when the user clicks the photo button in the app. It starts by
    configuring `CrossMedia` (a media plugin), which indicates the quality the photo
    should be, and then it starts the photo picker. When the photo picker returns
    from the `async` call to `PickPhotoAsync()`, we start uploading the photo. To
    notify the user, we use `UserDialogs.Instance.ShowLoading` to create a loading
    overlay with a message to indicate that we are uploading the photo.
  prefs: []
  type: TYPE_NORMAL
- en: We will then get the stream of the photo, convert it into a byte array using
    the `ReadFully()` method, and Base64 encode it into a string. The string will
    be wrapped in a `PhotoMessage` instance, added to the local `Message` collection
    of the `ChatViewModel`, and then sent to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the steps and study the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new property called `Photo` of the `ICommand` type. Assign it a new
    `Command` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an anonymous `async` method (a lambda expression) and add the code defined
    in the upcoming steps into it. You can see the full code of the method in the
    code section following.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new instance of the `PickMediaOptions` class and set the `CompressionQuality`
    property to `50`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `CrossMedia.Current.PickPhotoAsync` with an `async` method call and save
    the result to a local variable called `photo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the NuGet package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show a message dialog by calling `UserDialogs.Instance.ShowLoading()` with the
    text, `"Uploading photo"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the photo stream by calling the `GetStream()` method of the photo variable
    and save it to a variable called `stream`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the stream in to a byte array by calling the `ReadFully()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the byte array in to a Base64-encoded string using the `Convert.ToBase64String()`
    method. Save the string to a variable called `base64photo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `PhotoMessage` instance and pass the `User` as the constructor
    argument. Set the `Base64Photo` property to the `base64photo` variable and the
    `FileEnding` property to the file ending of the `photo.Path` string, using the
    `Split` function of the string object. Store the new `PhotoMessage` instance in
    a variable called `message`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the message object to the `Messages` collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the message to the server by calling the async `chatService.SendMessage()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hide the loading dialog by calling `UserDialogs.Instance.HideLoading()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code that follows shows how this can be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `ChatViewModel` is complete. It's now time to visualize our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ChatView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ChatView` is responsible for creating the user interface that the user
    will interact with. It will display local and remote messages, both text and photos,
    and also notify a user when a remote user has joined the chat. We'll start by
    creating a converter that will convert photos represented as a Base64-encoded
    string into an `ImageSource` that can be used as the source of the image control
    in XAML.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Base64ToImageConverter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we take a picture using the phone's camera, it will be handed to us as
    a byte array. In order to send this to the server, we will convert in it to a
    Base64-encoded string. To display that message locally, we will need to convert
    it back into a byte array and then pass that byte array to a helper method of
    the `ImageSource` class to create an instance of the `ImageSource` object. This
    object will make sense to the `Image` control and an image will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since there is a lot of code here, we suggest you follow the steps and look
    at each line of code in detail as you follow them:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder called `Converters` in the `Chat` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class called `Base64ImageConverter` in the `Converters` folder;
    let the class implement the `IValueConverter` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Convert()` method of the class, cast the object parameter called value
    to a string called `base64String`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the `base64String` to a byte array using the `System.Convert.FromBase64String()`
    method. Save the result to a variable called `bytes`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `MemoryStream` by passing the byte array into its constructor.
    Save the stream to a variable called `stream`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `ImageSource.FromStream()` method and pass the stream as a lambda expression
    that returns the stream variable. Return the `ImageSource` object created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `ConvertBack()` method does not need to be implemented since we will never
    convert an image back into a Base64-encoded string via data-binding. We will just
    let it throw a `NotImplementedException`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now it's time to start adding some actual XAML code to the view. We will start
    by creating the main layout skeleton that we will then gradually build on until
    we have the finished view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the skeleton ChatView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This XAML file will contain the view that lists messages we have sent and messages
    we have received. It''s quite a large file to create, so for this part, I suggest
    that you copy the XAML and study every step carefully:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `XAML Content Page` in the `Views` folder called `ChatView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add XML namespaces for `Chat.Selectors` and `Chat.Converters` and call them
    `selectors` and converters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `ContentPage.Resources` node that will, later on, contain resources for
    this view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `ScrollView` as the page content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `Grid` as the only child of the `ScrollView` and name it `MainGrid` by setting
    the `x:Name` property to `MainGrid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `RowDefinitions` element that contains three rows. The first should
    have a height of `*`, the second a height of `1`, and the third a platform-specific
    height based on the platform using an `OnPlatform` element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save some space for the `ListView` that will be inserted later on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `BoxView` that will act as a visual divider by setting the `HeightRequest`
    property to `1`, the `BackgroundColor` property to `#33000000`, and the `Grid.Row`
    property to `1`. This will position the `BoxView` in the one-unit-high row of
    the grid, effectively drawing a single line across the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add another `Grid` that will use the space of the third row by setting the
    `Grid.Row` property to `2`. Also, add some padding by setting the `Padding` property
    to `10`. Define three rows in the grid with heights of `30`, `*`, and `30`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have completed the main skeleton of our page, we need to start adding
    some specific content. First, we will add `ResourceDictionary` to create a `DataTemplate`
    selector that will select the correct layouts for different chat messages. Then,
    we need to put the `Base64ToImageConverter` to use and, to do that, we need to
    define it in the view.
  prefs: []
  type: TYPE_NORMAL
- en: Adding ResourceDictionary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s now time to add some resources to the view. In this case, we will be
    adding a template selector that we will create later on, and the `Base64ToImageConverter`
    that we created earlier. The template selector will look at each row that we will
    bind to the `ListView`, which will be presenting messages and selecting the best
    layout template that suits that message. To be able to use these pieces of code
    from XAML, we need to define a way for the XAML parser to find them:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the `<!-- TODO Add resources -->` comment inside the `ContentPage.Resources`
    element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the XAML in the sample as follows, right underneath this comment mentioned
    in *step 1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This will create one instance of each resource that we define and make it accessible
    to the rest of the view.
  prefs: []
  type: TYPE_NORMAL
- en: Adding ListView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using a `ListView` to display the messages in the chat app. Again,
    follow the steps and take a look at the code to make sure you understand each
    step:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the `<!-- TODO Add ListView -->` comment in the `ChatView.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `ListView` and set the `x:Name` property to `MessageList`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data-bind the `ListView` by setting the `ItemsSource` property to `{Binding
    Messages}`. This will make the `ListView` aware of changes in the `ObservableCollection<Message>`,
    which is exposed through the `Messages` property. Any time a message is added
    or removed, the `ListView` will update to reflect this change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `SelectMessageTemplate` resource we defined in the previous section
    to the `ItemTemplate` property. This will run some code each time that an item
    is added to make sure that we programmatically select the correct visual template
    for a specific message. No worries, we will soon write that code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that the `ListView` is able to create rows of uneven height by setting
    the `HasUnevenRows` property to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last property we need to set is the `SeparatorVisibility`, and we set it
    to `None` to avoid a row in between each row.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define a placeholder where we will add resources. The resources we will be
    adding are the different `DataTemplate` that we will be using to render different
    types of messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The XAML should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Adding templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now be adding five different templates, each corresponding to a specific
    message type that the app either sends or receives. Each of these templates goes
    under the `<!-- Resources go here later on -->` comment from the code snippet
    in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: We will not be explaining each of these templates step by step, since the XAML
    that they contain should be starting to feel familiar at this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each template starts the same way: the root element is a `DataTemplate` with
    a name set. The name is important because we will be referencing it in code very
    soon. The first child of the `DataTemplate` is always `ViewCell` with the `IsEnabled`
    property set to `false` to avoid the user being able to interact with the content.
    We simply want to display it. The content that follows after this element is the
    actual content that the row will be constructed from.'
  prefs: []
  type: TYPE_NORMAL
- en: Bindings inside the `ViewCell` will also be local to each item or row that the
    `ListView` renders. In this case, this will be an instance of a `Message` class,
    since we are data binding the `ListView` to a collection of Message objects. You
    will see some `StyleClass` properties in the code. These will be used when we
    do the final styling of the app using **Cascading Style Sheets** (**CSS**).
  prefs: []
  type: TYPE_NORMAL
- en: Our task here is to write each of these templates under the `<!-- Resources
    go here later on -->` comment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SimpleText` is the `DataTemplate` that is selected when the Message is
    a remote message. It will be rendered on the left side of the list view, just
    as you might expect. It displays a `username` and a `text` message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LocalSimpleText` template is the same as the `SimpleText` data template,
    except that it renders on the right side of the `ListView` by setting the `Grid.Column`
    property to `1`, effectively using the right column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This `DataTemplate` is used when a user connects to the chat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'A photo that is uploaded to the server is accessible via a URL. This `DataTemplate`
    displays an image based on a URL and is used for remote images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'A message that contains a photo that is sent by the user and rendered directly
    based on the Base64-encoded image that we generate from the camera. Since we don''t
    want to wait for the image to upload, we use this `DataTemplate`, which utilizes
    the `Base64ImageConverter` that we wrote earlier to transform the string into `ImageSource`
    that can be displayed by the Image control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: These are all of the templates we need. It's now time to add some code to make
    sure we select the right template for the message to display.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a template selector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using a template selector is a powerful way of injecting different layouts
    based on the items that are being data-bound. In this case, we will look at each
    message that we want to display and select the best `DataTemplate` for them. The
    code is somewhat repetitive, so we will be using the same approach as for the
    XAML—simply adding the code and letting you study it yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder called `Selectors` in the `Chat` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class called `ChatMessagesSelector` in the `Selectors` folder and
    inherit it from `DataTemplateSelector`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code, which will look at each object that is data-bound and
    pull the correct `DataTemplate` from the resources we just added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Adding the buttons and entry control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will add the buttons and the entry that the user will use for writing
    chat messages. The icons that we are using can be found in the GitHub repository
    for this chapter. For Android, the icons will be placed in the `Drawable` folder
    inside the `Resource` folder and for iOS, they will be in the `Resource` folder.
    The icons are in the same folder on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the `<!-- TODO Add buttons and entry controls -->` comment in the `ChatView.xaml`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `ImageButton`. The `Source` should be set to `photo.png`, the `Command`
    set to `{Binding Photo}`, and the `VerticalOptions` and `HorizontalOptions` set
    to `Center`. The `Source` is used to display an image; the `Command` will be executed
    when a user taps the image and the `HorizontalOptions` and `VerticalOptions` will
    be used to center the image in the middle of the control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `Entry` control to allow the user the enter a message to be sent. The
    `Text` property should be set to `{Binding Text}`. Set the `Grid.Column` property
    to `1` and the `ReturnCommand` to `{Binding Send}` to execute the send command
    in the `ChatViewModel` when a user hits *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An `ImageButton` with the `Grid.Column` property set to `2`, the `Source` set
    to `send.png`, and the `Command` set to `{Binding Send}` (the same as the return
    command). Center it horizontally and vertically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Fixing the code behind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the XAML is done, we have some work to do in the code behind. We''ll
    start by modifying the class to be partial and then we''ll be adding some using
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ChatView.xaml.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mark the class as `partial`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `private` field called `viewModel` of the `ChatViewModel` type, which will
    hold a local reference to the `ChatViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `using statements` for `Chat.ViewModels`, `Xamarin.Forms`, and `Xamarin.Forms.PlatformConfiguration.iOSSpecific`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The class should now look as follows. The bold code indicates what should have
    changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'When a new message arrives, this will be added to the Messages collection in
    the `ChatViewModel`. To make sure that the `MessageList` and `ListView` scroll
    appropriately so that the new message is visible, we need to write some additional
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new method called `Messages_CollectionChanged` that takes an object
    as the first parameter and `NotifyCollectionChangedEventArgs` as the second parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a call to the `MessageList.ScrollTo()` method and pass the last Message
    in the `viewModel.Messages` collection by calling `viewModel.Messages.Last()`.
    The second parameter should be set to `ScrollPosition.End`, indicating that we
    want to make the entire messages `ListView` row visible. The third parameter should
    be set to `true` to enable animations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The method should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s now time to extend the constructor so that it takes `ChatViewModel` as
    a parameter and sets the `BindingContext` in the way that we are used to. The
    constructor will also make sure that we use the safe area when rendering controls
    and that we hook up to the events necessary for handling changes in the `Messages`
    collection of the `ChatViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify the constructor in the `ChatView` class so that it takes a `ChatViewModel`
    as the only parameter and name the parameter `viewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the `viewModel` parameter from the constructor to the local `viewModel`
    field in the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The call to the `InitializeComponent()` method, add a platform-specific call
    to the `SetUseSafeArea(true)` method to ensure that the app will be visually safe
    to use on an iPhone X and not partially hidden behind the notch at the top:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time a view appears, the `OnAppearing()` method is called. This method
    is virtual and we can override it. We will use this feature to make sure that
    we will have the correct height on the `MainGrid`. This is because we have to
    wrap everything in a `ScrollView` because the view has to be able to scroll when
    the keyboard appears. If we don''t calculate the width of the `MainGrid` it could
    be bigger than the screen because the `ScrollView` allows it to expand:'
  prefs: []
  type: TYPE_NORMAL
- en: Override the `OnAppearing()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the safe area to use by calling the platform-specific method, `On<Xamarin.Forms.PlatformConfiguration.iOS>().SafeAreaInsets()`.
    This will return a `Xamarin.Forms.Thickness` object that will contain the inset
    information we need in order to calculate the height of the `MainGrid`. Assign
    the `Thickness` object to a variable called `safeArea`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `MainGrid.HeightRequest` property to the height of the view (`this.Height`)
    and then subtract the `Top` and `Bottom`properties of the `safeArea`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Styling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Styling is an important part of an app. Just like with HTML, you can do styling
    by setting properties on each control directly, or by setting `Style` elements
    in the application's resource dictionary. Recently, however, a new way of styling
    has emerged in Xamarin.Forms, which is using Cascading Style Sheets, better known
    as CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Since CSS doesn't cover all cases, we will fall back to standard application
    resource dictionary styling as well.
  prefs: []
  type: TYPE_NORMAL
- en: Styling with CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Xamarin.Forms supports styling via CSS files. It has a subset of the functionalities
    you would expect from normal CSS, but support is getting better with each version.
    We are going to use two different selectors to apply the styling.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create the style sheet and we''ll discuss the content of it after
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder called `Css` in the `Chat` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new text file in the `Css` folder and name it `Styles.css`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the style sheet, shown as follows, into that file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The first selector, button, applies to every button control in the entire application.
    It sets the background color to `#A4243B` and the foreground color to `white`.
    You can do this for almost every type of control in Xamarin.Forms.
  prefs: []
  type: TYPE_NORMAL
- en: The second selectors we use are class selectors, which are the ones beginning
    with a period, such as `.chatHeader`. The selectors are used in the XAML with
    the `StyleClass` property. Look back at the `ChatView.xaml` file we created earlier
    and you'll find these in the template resources.
  prefs: []
  type: TYPE_NORMAL
- en: Each property in the CSS is mapped to a property on the control itself. There
    are also some Xamarin.Forms specific properties that can be used, but those are
    out of the scope of this book. If you search for Xamarin.Forms and CSS on the
    internet, you'll find all of the information you need to dive deeper into this.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the style sheet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A style sheet is no good on its own. We need to apply it to our application.
    We also need to set some styling on the NavigationPage here as well, since we
    can't gain access to it from the CSS directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be adding some resources and a reference to the style sheet. Copy the
    code and refer  to the steps to study what each line does:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `App.xaml` file in the `Chat` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Application.Resources` node, add a `<StyleSheet Source="/Css/Styles.css"
    />` node to reference the style sheet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Following is the `StyleSheet` node. Add a `Style` node with the `TargetType`
    set to `"NavigationPage"` and create a setter for the `BarBackgroundColor` property
    with a value of `"#273E47"` and a setter for the `BarTextColor` property with
    a value of `"White"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `App.xaml` file should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Handling life cycle events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we need to add some life cycle events that will take care of our SignalR
    connection in case the app goes to sleep or when it wakes up again:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `App.Xaml.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the code that follows somewhere in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `OnSleep()` method will be called when the user minimizes the app and it
    will dispose of any active `chatService` that is running by closing the active
    connections. The `OnResume()` method has a little more content. It will recreate
    the connection if there isn't one already active and, depending on whether the
    user is set or not, it will resolve to the correct view. If a user isn't present,
    it will display the `MainView`; otherwise it will display the `ChatView`. Finally,
    it sets the selected view, wrapped in a navigation page.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That's that—good work! We have now created a chat app that connects to our backend.
    We have learned how to work with SignalR, how to style an app with CSS, how to
    use template selectors in a `ListView`, and how to use a value converter to convert
    a `byte[]` into a Xamarin.Forms `ImageSource`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive into an augmented world! We will create an
    AR-game for iOS and Android using UrhoSharp together with ARKit (iOS) and ARCore
    (Android).
  prefs: []
  type: TYPE_NORMAL
