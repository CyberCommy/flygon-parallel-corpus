- en: Flexbox, Part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s carry on our exploration of flexbox and the power it offers. You should
    have the basics under your belt now, so in this chapter we''ll go ahead and build
    a new section—the product listing that you see below—to get some practical experience
    of building things with flexbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00438.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We'll also talk about what needs to be prefixed when using flexbox, and how
    to add prefixes in the easiest way possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a new section using flexbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using flex-wrap and align-content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the display order of flex items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling vendor prefixes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the product listing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s build a product listing with flexbox. We''re going to see what else
    we can build with flexbox by creating a product listing. We''ll explore two new
    flexbox properties: `align-items` and `align-self`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using align-items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build the product listing, we''re going to start with some new markup that
    will sit directly above the footer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There's quite a bit of markup, but it's not very complex. There's an unordered
    list with six list items (`<li>` tags). Each list item has an SVG image (`<figure><img></figure>`),
    a headline (`<h2>`), a paragraph (`<p>`), and an anchor (`<a>`). In the previous
    code snippet, I've omitted the guts of all the list items except for the first
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re also starting with some CSS that bootstraps this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what we''re starting with in our product listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00439.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We want each list item to have its contents laid out horizontally. We can target
    the class, `product-list-item`, and use `display: flex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This ruleset is targeting six different `li` tags with the class of `product-list-item`.
    This is important because we have six different flex containers. Adding `display:
    flex` should lay out all the different flex items in each flex container—horizontally.
    Because that''s what flexbox does. By default `flex-direction` is `row`, so everything
    is laid out in a row:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00440.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Alright, so things don''t look great. One of the things we can do is add `flex-basis`
    with a value of `250px` to the `h2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This should add some semblance of organization and it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00441.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s use automatic margins to align the button to the far right edge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Reviewing what we learned in the last section, `margin-left: auto` is going
    to auto calculate the amount of margin it has to the left of the button and push
    it all the way to the far right. This is much better, but still, things are a
    little tight:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00442.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s fix this with a new property called `align-items`. So these buttons
    are way too close to each other and this paragraph sits up high. We want the images,
    the headline, the paragraph and the button all centered vertically. The `align-items`
    is a property that can be used on flex containers that controls the positioning
    of flex items along the cross axis. Here''s that diagram again to remind us of
    where the cross axis runs when `flex-direction` is set to `row`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00443.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, the cross axis runs from top to bottom when `flex-direction`
    is row. We''ll add `align-items` with a value of `center`. And that really won''t
    do much noticeably unless we add a `height` of `80px`. So let''s do that too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'So, using `align-items: center` will align items in the middle of the cross
    axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00444.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Okay, not bad! All our flex items are centered vertically, with one property,
    and each item has a different height. Also, I want to note that the default value
    of `align-items` is `stretch`, which forces the flex item to stretch from the
    start of the cross axis to the end of it. This is the reason why flexbox comes
    standard with equal height columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use `flex-start`, which aligns all the flex items to the top of
    the flex container or the start of the cross axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the output of preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00445.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try `flex-end`, which will align all the flex items—you guessed it—to
    the bottom or the end of the cross axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Our flex items are now aligned to the end of the cross axis—the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00446.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s change this back to `center`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s go back to our three columns; we still have problems with our images
    and headlines aligned to the left, and we want them to be centered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00447.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's see how we can use `align-items` to center our sea creatures and headlines,
    when the `flex-direction` is set to `column`. In this use case, the cross axis
    runs horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00448.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is good news. Since `align-items` is used for alignment on the cross axis,
    which runs horizontally for `flex-direction: column`, this should center our sea
    creature images and headlines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remembering that each `.column` is a flex item of `.columns`, but also its
    own flex container for its own flex items. Those flex items being things like
    the sea creature image, the headline, the paragraph, and the button. So each column
    is its own flex container. We can use `align-items: center`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So here''s what we end up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00449.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Things are centered, like the headline and the button at the bottom, but our
    sea creature images have totally disappeared and our buttons have shrunk. Let''s
    tackle these problems one at a time, starting by thinking about why our sea creatures
    have disappeared. Let''s inspect in the general vicinity of where the sea creatures
    would be and find the images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00450.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Inspecting the `figure` element that holds the `img` element in the DevTools
    shows that the width is 0 and the height is 150\. So why would the width be 0
    if we have this CSS in place?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, we don''t have an explicit `width` set for these SVGs. We have a `max-width`
    set but that really doesn''t force a width. Recall that `max-width` just says,
    "never be wider than x number of pixels", but doesn''t enforce any width below
    that threshold. And our `flex-basis` of `150px` is controlling the height because
    the `flex-direction` is `column`. We never set a true width at all. When we set
    `align-items: center`, it forces the elements to only take up as much width or
    height as they need, almost like when you `float` a block-level element to the
    `left` or `right`. Also, SVG is unique in the universe of images. Traditional
    images like PNG''s and JPG''s have set dimensions even if nothing is specified
    in the CSS. SVG''s, since they are scalable to any size big or small, don''t have
    a baseline size. Since there are never any widths or heights set for the `figure`
    or `img`, the `align-items` property kind of squeezes the width to 0, which is
    why they vanished on us.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is easily fixable; we''ll just add a `width`. Let''s make it even a little
    smaller than they were before, about 50 percent of their container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Our sea creatures are back!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00451.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The buttons at the bottom have the same problem as our images just had; they
    don't have any `padding` or `width` set, so `align-items` forces the width to
    only be as wide as the content, hence why they look all squished and small.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this is the same: just set a `width`. Let''s have the `width`
    as `90%` in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'That fixes that problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00452.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using the align-self Flexbox property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looks good, but what if I don't want all the flex items to be centered? I might
    prefer the `h2` to be aligned to `flex-start` (in fact I do). The `align-items`
    is a property used on the flex container to control the cross axis alignment of
    all flex items. Another, flexbox property called `align-self` controls alignment
    along the cross axis but is a property used directly on flex items. This will
    help us aligning only our `h2` to the left.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new selector for the `h2` and add `align-self: flex-start`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that `align-self` is a property only for flex items; its default value
    is `auto`, which means tells it to check the value of `align-items` for cross
    axis alignment. It also accepts `stretch`, `flex-start`, `flex-end`, `center`,
    and `baseline`. It allows us to override the `align-items` value for a single
    flex item.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we refresh the browser now, we will see that our `h2` tags are aligned to
    the left - at their `flex-start`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00453.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We're looking good now. Let's take a minute to quickly fix a bug we created
    a little while back. We'll take a look at this bug as we inspect the page by right-clicking
    and choosing Inspect; we'll move the DevTools to the right in Chrome. I'll just
    resize it to tablet size; we can see the problem now, our sea creatures are out
    of control!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00454.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our columns are all jumbled up on top of each other. So we've got to figure
    out why that's happening. This is because we have `flex-basis` set to `30%` for
    each column. It worked great when `flex-direction` was row, but as you may recall
    from the section *Floats to Flexbox*, we changed `flex-direction` to `column`
    inside a media query for smaller devices. When `flex-direction` is `column`, `flex-basis`
    controls the height instead of the width because the main axis runs vertically
    instead of horizontally in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s fix this inside of our media query. Let''s create a new selector
    and set `flex-basis` to `auto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll recall that setting `flex-basis` to `auto` implies this: look at my
    width or height. Because we don''t have a height set explicitly; the height is
    determined by the content, exactly what we want—just have the height be the size
    of the content. Also, I snuck in a `margin-bottom` of `50px` to provide each one
    with a little breathing room between each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00455.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this section, we built our product listing using flexbox and introduced
    two new flex properties: `align-items` and `align-self`. In the next section,
    I''ll introduce two more properties: `flex-wrap` and `align-content`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using flex-wrap and align-content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `flex-wrap` property allows us to determine whether we are going to wrap
    our content to a second row or squeeze all the flex items into a single row; `align-content`
    determines the alignment of a row that is being wrapped to multiple lines, thus
    becoming multiple rows. They are basically best friends.
  prefs: []
  type: TYPE_NORMAL
- en: Using flex-wrap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll return and use our flexbox sample page (`flexbox.html`) as a playground
    for testing these properties. Here''s our CSS we ended up with in this area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The flex container has all of the content justified to `flex-start`, or in
    our case, to the left. This is because `flex-direction` is not set, and hence
    it defaults to `row`. The last flex item is being pushed to the far right with
    `margin-left: auto;`. This is how our `flexbox.html` page should look at the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00456.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In `flexbox.html`, let''s add quite a few more flex items and save them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now we see how flexbox is really squishing the flex items to fit on one single
    row inside the flex container.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00457.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So what we''ll do is wrap multiple rows by adding the `flex-wrap` property
    to the flex container with the value of `wrap`. Also, let''s get rid of `margin-left:
    auto` on our last flex item by just removing that entire rule set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: So all the flex items, which were previously shrinking to fit on one row, now
    expand to their natural size; this implies the width of the text plus `20px` of
    `padding` on each side of the text. This creates two rows of content. Good, exactly
    what we want!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00458.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The default for `flex-wrap` is `nowrap;`. That makes sense because before we
    set it to `wrap` it was forcing all our flex items to fit on one row. As if we
    omitted `flex-wrap` altogether. Let''s swap in `nowrap` to test this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As if we never specified a `flex-wrap` at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00459.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There''s also `wrap-reverse;` let''s try that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The last item is now the first, and the first item is the last. Technically,
    the last item is now the fourth on the first row:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00460.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The cool thing about using `flex-wrap` is that each row now works independently
    of other rows when it comes to properties like `flex-grow`, `flex-shrink`, and
    `justify-content`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test it out and add `flex-grow: 1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This redistributes any extra space between the flex items to make sure they
    fill all the leftover space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00461.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Each row has their flex items expanded to occupy the extra space. As you can
    see, the first row has its flex items stretched farther to fill up the extra space
    than the row below. In these other two rows underneath it, the flex items are
    only stretched a tiny bit to fill up the extra space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take another look at how these rows work independently of each other
    by changing `justify-content` to `space-between` the flex container. We''ll also
    get rid of `flex-grow` on the flex item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'So there''s this extra space allocated between each flex item:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00462.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The first row has a lot of extra space, while the second row has only a little
    extra space between each flex item. Again, each row functions independently of
    each other on how to handle `flex-grow`, `flex-shrink`, and `justify-content`.
    This is the sort of stuff that works extremely well with dynamic, unknown quantities
    of content coming from a **content management system** (**CMS**).
  prefs: []
  type: TYPE_NORMAL
- en: Using align-content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alright, let's take a look at another property called `align-content`. Like
    `flex-wrap`, `align-content` is a property that only works on the flex container;
    however, `align-content` is dependent on `flex-wrap` being set to `wrap` or `wrap-reverse`,
    which means `align-content` is ignored under all other scenarios. Also, `align-content`
    is similar to `align-items` because it controls arrangements or alignments along
    the cross axis. The only difference is that instead of redistributing each *flex
    item* along the cross axis, it redistributes each *row* along the cross axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set a `align-content` to `space-between`. We''ll also give it a height
    of `300px` and a dark gray border:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And I''m also going to double the number of flex items to keep things interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have 3 rows and we have space between each row thanks to `align-content`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00463.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `height` property is relevant because if omitted, the height of the flex
    container will only be as tall as its flex items; therefore, `align-content` wouldn't
    do anything because there wouldn't be any extra vertical space to play with. Other
    values aside from `space-between` for `align-items` include `flex-start`, `flex-end`,
    `center`, and `space-around`. These values should be familiar from when we studied
    the `justify-content` property. The default value is `stretch`. The `space-around`
    value redistributes the extra space around all the items evenly, including the
    first and the last.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s change it from `space-between` to `space-around`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see with space-around, there is a space between the top of the flex
    container and the first row and the bottom of the container and the last row:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00464.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Whereas `space-between` had the first and last rows hugging tightly to the flex
    container, which is a subtle difference. Again we've noticed this subtlety from
    before when we studied `justify-content`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s change the value of `align-content` to `center`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As we would expect, our rows are centered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00465.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s change `flex-direction` to column now to see how `flex-wrap` and `align-content`
    work together in this use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'So there''s a lot going on here, and it''s hard to tell exactly what, but one
    thing we can say is we are centered horizontally:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00466.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s simplify this a little to comprehend what''s happening. First, let''s
    change `flex-wrap` from `wrap-reverse` back to just `wrap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In `flexbox.html`, we''ll reduce the number of flex items considerably:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s a little easier to see that `flex-direction` is `column`, which
    forces two vertical columns because `flex-wrap` is set to `wrap` and we are out
    of available space for all 6 flex items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00467.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our `space-between` setting for `justify-content` is redistributing the extra
    space between each flex item. Notice how both the columns are getting their extra
    space redistributed independently, as shown in the following diagram.
  prefs: []
  type: TYPE_NORMAL
- en: When there is extra space along the cross axis and multiple rows, `align-content`
    is used to arrange rows along the cross axis. And as we know the cross axis runs
    from top to bottom when `flex-direction` is row.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00468.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And, the cross axis runs from left to right when `flex-direction` is column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00469.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: My apologies, if I'm starting to sound like a broken record, but I feel it's
    important to over-communicate things that are important to how flexbox operates.
  prefs: []
  type: TYPE_NORMAL
- en: Using the flex-flow shorthand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously, we looked at how the `flex` shorthand combined `flex-grow`, `flex-shrink`,
    and `flex-basis` together. Let''s introduce another shorthand, `flex-flow`, which
    will allow us to cut down on our properties a bit by combining `flex-direction`
    and `flex-wrap` together. Anyway, this simplifies our CSS a little bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing changes, which is exactly what we want when we refactor using a shorthand:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00470.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Given how closely dependent `align-content` is on `flex-wrap`, I would expect
    `align-content` to be part of the `flex-flow` shorthand. However, `align-content`
    isn't part of the `flex-flow` shorthand with `flex-direction` and `flex-wrap`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how `flex-wrap` allows us to create multiple streams—or
    rows—of content, while `align-items` positions those multiple rows within their
    container along the cross axis.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the display order of flex items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll talk about how we can change the display order of flex
    items and how this can be helpful for responsive web design. We'll also talk about
    how this impacts web accessibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'At wider screen widths, the content is displayed horizontally: first with the
    octopus, then the crab, and then the whale:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00471.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'At narrower device widths, the content is displayed in the same order, just
    vertically, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00472.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In both the cases, the display order is identical to the source order, and this
    makes sense in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do something different here. Let''s say we''re working with a designer
    who wants to feature the crab this week and give it visual priority over the octopus
    and whale. That''s what we have done here. I''ve added a little extra to the HTML
    and CSS to achieve this new featured treatment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00473.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the markup, I added a number to the headline of each column so we can easily
    remember the source order when viewing in the browser. Then, for the crab, I added
    a class called `featured` and a `div` tag with a class called `ribbon`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve added some CSS to style the ribbon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have noticed that the featured ribbon was stretched across the top;
    this was done using `align-self: stretch`. As we already discussed, `align- self`
    aligns flex items along the cross axis, which in our case runs from left to right
    since `flex-direction` is set to `column`. The `align-self` property is like `align-items`,
    except that it''s used on a flex item and overrides the `align-items` property.'
  prefs: []
  type: TYPE_NORMAL
- en: On the desktop or a wider view, our business partners and designers are really
    happy when they see this. But on a mobile, they are saying, *"Mmmmm, I don't know,
    the crab is still showing second."* And they might be right, it's the featured
    content, so it should not only be visually featured, it should also appear first.
    Well, if our content was coming from a database, we could update it so the crab
    would appear first; alternatively, we could use some JavaScript to rearrange our
    featured content to put the crab first. Both of these solutions are, at a minimum,
    not ideal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flexbox comes to the rescue here. In our media query for smaller devices we
    can use a property for flex items called `order`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright, when I refresh the browser, it instantly moves our crab to the first
    position, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00474.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: By default, all flex items are given an `order` of `0`, so providing `-1` moved
    the crab to the top. The order of items runs with the main axis; the lowest-ordered
    flex item will be at the start of the main axis, while the highest-ordered flex
    items will appear at the end of the main axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, in our case, since `flex-direction` is `column`, the main axis runs
    from top to bottom. Let''s change the `order` to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This moves the crab to the bottom because since both the octopus and whale
    are, by default, `0` - and, we''ve specified the crab as `1`—so now it''s placed
    at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00475.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Alright, let''s add two more rulesets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re using the `nth-child` pseudo classes to mix up the order a bit. When
    we refresh the browser now, the crab is first in display order (second in the
    source order), the whale is second (but third in the source order), and the octopus
    is third (but first in the source order). This is what it should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00476.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So I can also put them in reverse order. I already have the first one as third,
    and I can make the second one second, and the third one first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00477.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we have the third as the first, second as second, and the first as third.
    Reverse order. But remember, I have an easier way to do this; I can actually just
    get rid of all three of these rulesets and just specify `flex-direction` as `column-reverse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when I refresh the browser, they''re still in reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00478.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Accessibility impact
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One thing I want to mention is that there''s a downside to changing the display
    order that you may want to be aware of: tabbing through content. The tab order
    is still based on the source order, which becomes an accessibility issue. Now
    you might be thinking that in our example, the tab order is logical on a desktop
    but only becomes out of logic on smaller devices, such as phones, which most likely,
    but not always, will not be tabbing through fields. Perhaps that''s mostly true;
    however, changing the display order is also a problem for screen readers, such
    as JAWS, which read the content to visually impaired users based on the source
    order and not the display order. So, your content will still be announced by the
    screen reader based on the source order, which will not be in sync with the visual
    order. This could be an accessibility issue. So, it''s good to just keep this
    in mind if changing the order.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how the `order` property can change the display
    order of flex items within a flex container and how that impacts tab sequence
    and accessibility.
  prefs: []
  type: TYPE_NORMAL
- en: Vendor prefixes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's talk about vendor prefixes. In this section, we'll talk about browser
    support for flexbox and how we should add vendor prefixes to our flexbox CSS in
    order to get deeper flexbox support. We'll also talk about something called **Autoprefixer**,
    which helps us add those prefixes.
  prefs: []
  type: TYPE_NORMAL
- en: Flexbox support starts at IE10 and later version if we use the `-ms-` vendor
    prefix. But this might not be the only vendor prefix you want to add since the
    W3C specification has actually changed since it was first implemented in browsers.
    When it was implemented, the syntax and property names were different from that
    they are today. To get deep browser support, we can use an older syntax combined
    with the newer syntax to support some of the early adopting browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our original ruleset where we first added flexbox, which was
    our `.columns`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Wow! There''s a ton going on here. We''re not just adding `-ms-`, `-moz-`,
    and `-webkit-` to the beginning of the property. We''re adding the vendor prefix
    to the start of the value when it comes to the values for the `display` property.
    And the values themselves aren''t very different from our non-prefixed version.
    And there''s 2 `-webkit-`values! Chrome and Safari were really early adopters
    of flexbox, so there''s actually two different prefixes that WebKit browsers were
    supporting: `-webkit-box` and `-webkit-flex`. So, that''s a lot of prefixes and
    a lot of memorizing and it looks just as crazy for the `justify-content` property.
    This is a lot. The tricky part is learning and remembering the older syntax, especially
    since it''s not obvious which prefixes are still needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Autoprefixer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s where a tool such as Autoprefixer CSS online ([https://autoprefixer.github.io/](https://autoprefixer.github.io/))
    can be super helpful. It provides the prefixes we need based on the total market
    share of the browsers and the number of versions we want to go back for each browser.
    Let''s update this filter to `.01%`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00479.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s get rid of all these prefixes and just copy and paste this ruleset to
    the left box of the Autoprefixer tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00480.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the right-hand side, it provides the prefixes we should use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00481.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s copy that back over to our CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty sweet and much easier than memorizing the different syntaxes
    of all the flexbox properties. It would be nice if there were some way to automatically
    add vendor prefixes for us, without us having to do all this copying and pasting.
    One thing we can do is we can use a preprocessor, such as **Sass**, to write something
    called a **mixin** to add vendor prefixes for us, so we don't have to think about
    this as much. We'll look at Sass mixins in the next chapter
  prefs: []
  type: TYPE_NORMAL
- en: Gulp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now I want to mention something that you may have heard of: Gulp.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00482.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Gulp ([https://gulpjs.com/](https://gulpjs.com/)), and its friend Grunt([https://gruntjs.com/](https://gruntjs.com/)),
    allow us to create build processes that things like minify our CSS and JavaScript
    files, compile Sass into CSS, and even add vendor prefixes to CSS automatically,
    using Autoprefixer. Gulp runs on Node and requires you to download it and then
    download Gulp. You can then download individual tasks, such as Autoprefixer. Learning
    Gulp is far out of the scope of this book, but Gulp is really useful and I really
    like it a lot. In order to get started with it, I highly recommend that you read
    *Getting Started with Gulp*, *Travis Maynard*, *Packt Publishing*, which does
    an excellent job of explaining how to install Gulp, set it up, and use it. This
    is how I learned how to use Gulp, by reading this book.
  prefs: []
  type: TYPE_NORMAL
- en: Gulp is a *command line* tool that you can configure to run Autoprefixer every
    time you save your CSS file. So if I write a flexbox property in my CSS and do
    a *Ctrl* + *S*, Gulp will be watching my file for any deltas and if it detects
    a change, it will tell Autoprefixer to run and update my CSS file with the necessary
    vendor prefixes. I know that sounds weird—update my CSS file with vendor prefixes—but
    technically, what it does is it creates a new CSS file that will have all the
    vendor prefixes. There's more to it than what I've explained here, but check out
    Travis Maynard's book to get it set up. This way, you'll never have to think about
    vendor prefixes again because Autoprefixer and Gulp will do the thinking for you.
  prefs: []
  type: TYPE_NORMAL
- en: Flexbox homework assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve built one heck of a site:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00483.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, it is not without its problems. One thing you may have noticed is,
    in the product listing section, when we shrink down our browser, it starts to
    look a little wonky, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00484.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: One final take-home test for you would be to update the CSS inside a media query
    to make the display look good here in smaller device sizes.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we talked about how we need to add vendor prefixes to our flexbox
    properties in order to get deeper browser support. Vendor prefixes, though, can
    be tricky, and it's best to leave prefixing to a tool such as Autoprefixer. Better
    yet, it's best to automate Autoprefixer so it is executed every time you save
    your CSS file. You can use a task runner, such as Gulp or Grunt, for this.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'That completes our journey through flexbox. We''ve now seen every single one
    of the properties associated with it, and put them into practice building a new
    product listing for our site. In the next chapter, we''ll look at the next steps
    for advancing your skillset and tooling around CSS in the finale: [Chapter 11](part0236.html#7124O0-a72d261cc09f412988422c8a08f12cd5),
    *Wrapping Up*.'
  prefs: []
  type: TYPE_NORMAL
