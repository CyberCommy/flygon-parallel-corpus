- en: Webpack in Vue CLI 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we saw how to start using Vue CLI via both the command
    line and the UI. In this chapter, we will cover webpack basics from the viewpoint
    of Vue CLI 3\. We will begin with an overview of what webpack is. We''ll look
    at concepts behind module bundling, tree shaking, webpack loaders and output,
    webpack plugins, **Hot Module Replacement** (**HMR**), code coverage and code
    splitting, and then we''ll look at how these concepts fit in with Vue CLI 3 as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The evolution of the **JavaScript** (**JS**) language from the script tag to
    module bundlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The script tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immediately Invoked Function Expressions** (**IIFEs**), what problems they
    solve, and what problems they don''t'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How **Node Package Manager** (**NPM**) helps teams share third-party libraries
    in their code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The role of JS task runners and NPM scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the CommonJS specification is and how modules work in JavaScript and Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What module bundlers are and how they bridge the gap between Node.js and the
    browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What webpack, and how it works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to run webpack on a project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bundling assets with webpack using production and development modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a Vue project via NPM and using webpack with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding exactly how webpack works is crucial to understanding the magic
    that Vue CLI 3 performs. If you are familiar with webpack, you still might find
    some sections of this chapter useful. If you feel you are a webpack pro, you can
    probably just skip this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Before getting into what is webpack and to properly understand the issues that
    webpack solves, we need to look back at a bit of history of changes that happened
    to the JS language in the last decade.
  prefs: []
  type: TYPE_NORMAL
- en: The evolution of the JS language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Looking from the vantage point of webpack, here is the chronological list of
    approaches, techniques, best practices, and patterns that were added to the JS
    ecosystem, which led to the current state of things:'
  prefs: []
  type: TYPE_NORMAL
- en: The `script` tag as the answer to adding interactivity to web pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immediately invoked function expressions as the answer to modularizing libraries
    and avoiding code collisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem with IIFEs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing third-party libraries in a team environment with NPM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JS task runners and NPM scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules in JS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at each one of these solutions in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The script tag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Initially, adding JS to your web page meant that you would need to add some
    `script` tags directly in your HTML. For quick prototypes, this is still a valid
    way of doing things even to this day. Very often, third-party libraries get added
    via the `src` attribute inside a `script` tag (which usually gets placed right
    above the closing `body` tag in our HTML).
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, you usually need more than one `script` tag inside your HTML.
    And regardless of whether you add your JS code directly to your page, you add
    it from another file in your project, or you add it from a remote location (such
    as from a **content delivery network** (**CDN**) using the `src` attribute), ultimately,
    all these scripts are added to the global JS scope. This means one thing, collision.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid collisions, a clever approach was taken, the use of IIFEs.
  prefs: []
  type: TYPE_NORMAL
- en: Immediately Invoked Function Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are IIFEs all about? IIFEs simply exploit the fact that in JS, *parentheses
    can't contain statements*. This fact alone allowed JS developers to put in anonymous
    functions that they could immediately invoke, without getting any errors from
    the parser, by simply wrapping them in parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: An IIFE is essentially a quirk of the JS language, but a very useful one; with
    an IIFE, all the code is scoped to the function, and thus your code is safe from
    anything else that is outside of it. In other words, using IIFEs is a simple way
    to avoid collisions, that is, the accidental overwriting of variables or functions.
    Thus, at one point, many popular libraries started wrapping their own code into
    IIFEs. For example, if you open the code for the jQuery library ([https://code.jquery.com](https://code.jquery.com)),
    or for the Chart.js library ([https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.3/Chart.bundle.js](https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.3/Chart.bundle.js)),
    or for many other popular JS libraries, you'd find that they use the IIFE pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, with IIFEs, we could add different scripts to our pages, without the worry
    that code collisions might happen.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with IIFEs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unfortunately, simply using IIFEs does not fix all our problems. To illustrate
    the issue at hand, let''s quote Joe Armstrong, creator of Erlang:'
  prefs: []
  type: TYPE_NORMAL
- en: '"You wanted a banana, but what you got is the gorilla holding the banana, and
    the entire jungle."'
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that in this quote, Mr. Armstrong was discussing a problem with
    object-oriented languages, but the underlying issue is applicable in JS code modularization.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, our problem with IIFEs is that we can't cherry-pick specific functionality
    that we'd like to use from a JS library. With the IIFE pattern, we *must* use
    everything that is wrapped up in an IIFE, even if we are only using just a small
    piece of a specific library's codebase. Of course, to be honest, IIFEs are not
    the ones to blame for this. JS, the language, for a long time simply did not have
    the ability to cherry-pick any kind of code functionality, because in JS, it was
    simply impossible to split your code into modules.
  prefs: []
  type: TYPE_NORMAL
- en: Another major pain point of JS was the issue of reusing third-party code across
    teams.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing third-party libraries in a team environment with NPM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IIFEs solved the problem of code collisions, but they didn't solve the problem
    of code reuse. What if a developer on my team has a different, updated version
    of a library, with breaking changes? What if I decide to update the dependencies
    on my computer? How will my other team members deal with that? Besides using source
    version control, are there any other options for faster collaboration?
  prefs: []
  type: TYPE_NORMAL
- en: '**Node Package Manager** (**NPM**) was the answer to these problems. Node is
    just a Google V8 JS engine that can run on a server. NPM simply allows a developer
    to install new libraries into a project, regardless of whether it is to be used
    on the frontend or the backend of an app. So, effectively, NPM is the JS package
    manager, similar to what we have in Ruby (gems ([https://rubygems.org/](https://rubygems.org/))),
    C# (NuGet ([https://www.nuget.org/](https://www.nuget.org/))), or in Linux (`apt-get`,
    `yum`).'
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's say we wanted to install Vue via NPM. If we have Node installed
    on our machine, we'll have NPM too, since NPM comes bundled with a Node installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create a new directory. Let''s change this directory''s name
    to `vue-from-npm`, and point our command-line console to it. We can then follow
    it up with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Running the preceding command will create a `package.json` file. The `-y` flag
    accepts all the default answers that you'd be prompted with in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we looked at the newly created `package.json` file inside our project directory,
    we''d see the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `npm init` command only adds a `package.json` file to an empty
    directory. That's all that it does!
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding Vue is then as simple as running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will do a few things, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: It will add the `node_modules` directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will put the entire Vue library inside the `node_modules` directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will create the `package-lock.json` file in the root of our project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will update the `package.json` file in the root of our project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The updated `package.json` file now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If it is not obvious, the file has been updated with a new entry: `dependencies`.
    This entry lists all the dependencies included in the project. Specifically, we
    have added Vue (version 2.6.7 or above) to our project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A great thing about NPM is that we can add any other library to our project,
    just as easily as we did with Vue. For example, to update our project with accounting.js,
    we just run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the installation is complete, let''s again inspect the `node_modules`
    directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that for the sake of brevity, we are only showing the second level of folders
    and files inside the `accounting-js` folder. The `is-string`, `object-assign`,
    and `vue` folders are shown collapsed.
  prefs: []
  type: TYPE_NORMAL
- en: 'What this shows us is that sometimes other NPM modules come bundled with the
    actual libraries that we installed. In the case of `accounting-js`, we also got
    the `is-string` and `object-assign` NPM modules. Let''s also inspect the updated
    `package.json` file in the root of our directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the root `package.json` file has been updated with the proper
    version of `accounting-js`. Let's locate another `package.json` file, this time
    inside the `node_modules/accounting-js` folder. If you opened that file, it holds
    a lot more information, in just a bit over 100 lines of code. This information
    is specific to the actual NPM module, `accounting-js`.
  prefs: []
  type: TYPE_NORMAL
- en: OK, so now our project is ready for collaboration. The way to do it? Let's see
    how a colleague of ours, let's call him `John`, would add the project we just
    created, and all the project dependencies, on his own computer.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we'll create a new folder, let's call it `johns-computer`, and let's
    just copy the root level `package.json` from our `vue-from-npm` folder into our
    `johns-computer` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s simply run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Running the preceding command will install all the projects and dependencies
    that we had in the `vue-from-npm` folder.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript task runners and NPM scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Around the same time during which NPM was gaining popularity, another frontend
    technology was also on the rise: task runners. Task runners are simple tools;
    they run repetitive tasks. Sometimes, task runners are referred to as build tools
    because they act as intermediaries between updates that a developer makes to a
    codebase, and what the production ready code ends up being. This is what''s known
    as a *build step*, a part of the software development process in which something
    happens to your code *after* you''ve written it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, new features that get added to CSS3 usually start off as *vendor
    prefixes* (also known as *browser prefixes*). In other words, before a new CSS
    functionality is available in all browsers, it gets implemented in an experimental
    stage in individual browsers, using browser-specific prefixes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this alphabetically ordered list of browser prefixes, we can see browser
    prefixes for Microsoft browsers, Mozilla, old versions of Opera, and finally,
    all the webkit-based browsers (Chrome, Safari, newer Opera, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping track of updates to browser prefixes is kind of difficult. It is probably
    not the best use of a developer''s time to monitor for changes to CSS implementations,
    and then update their code accordingly. For example, at a certain point in the
    past, it was necessary to use the following browser prefixes on the CSS `transition`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, today we simply use the `transition` property in our CSS declarations,
    without any browser prefixes, because the `transition` property is widely supported
    in all modern browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having to deal with the constantly shifting landscape of changes to the CSS
    specification and its implementations in various browsers led to a solution in
    the form of a task runner. Instead of having to manually add vendor prefixes to
    their CSS code, frontend developers could now simply add a plugin to their task
    runner and it would do the dirty work for them: add vendor prefixes where needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, what we saw previously was just one example of what task runners
    are used for. Some other examples include: minifying CSS and JS files, transpiling
    from ES6 to ES5, compiling CSS from SASS, removing unused CSS, reloading the browser
    whenever a file is saved in your project, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, there are a number of different tools that help us to effectively automate
    some tasks in our development process. Three tools stand out: Grunt, Gulp, and
    NPM scripts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While Grunt and Gulp are standalone task runners that you can install via NPM,
    NPM scripts are an interesting alternative for the following few reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: You are using NPM anyway, so why not get more familiar with a tool you are already
    using?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using NPM scripts instead of the aforementioned task runners will streamline
    your development further.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using NPM, you avoid the complexity of having to use a task runner plugin
    for tasks that can be automated straight in NPM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Up until this point, we've looked back at the history and the evolution of the
    JS ecosystem. We've seen how IIFEs were used to take care of accidental scope
    leaks. We've also seen how NPM takes care of code sharing. We've further looked
    at how some repetitive tasks can be automated with the help of task runners, and
    how NPM can be used to remove an unnecessary layer of abstraction by keeping our
    tasks inside NPM scripts.
  prefs: []
  type: TYPE_NORMAL
- en: However, we still haven't looked at ways to solve the problem of code modularization
    in JS. So, let's look at that next.
  prefs: []
  type: TYPE_NORMAL
- en: Modules in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any programming language, a module is a self-contained piece of functionality. You
    can think of them as different episodes of a TV show. They can be looked at independently.
    They can stand on their own, although they are a part of a greater whole.
  prefs: []
  type: TYPE_NORMAL
- en: And just like an episode in a TV show has a season and a number, so that we
    know *where it fits* in the bigger plot, a module also holds the information that
    tells us what other modules it relies on (the *module dependencies*), and what
    functionality it adds to the entire app; this is what's known as a *module's interface*,
    the API that's exposed to other modules.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen how in the beginning, JS did not have modules at all. This changed
    with the introduction of Node.js. Node.js is actually an implementation of CommonJS,
    a project that was started in 2009 by Mozilla's Kevin Dangoor.
  prefs: []
  type: TYPE_NORMAL
- en: 'CommonJS project''s purpose was to define a standard library that would provide
    JS APIs to be used outside of the browser. This included a module specification,
    which resulted in developers being able to use code like this in Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Working with modules in Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s require and use some modules in Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: To begin, we'll create a new directory. Let's call it `module-practice`. Let's
    point our Git Bash to this folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once inside it, let''s create two new files. Let''s call these files `main.js`
    and `whatever.js` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s open this entire folder in VS Code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add some code to `whatever.js` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is as simple as a piece of code in JS can get.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see how can we make it available in our `main.js` file. We''ll just
    need to require `whatever.js` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that it is required, we can use it, so let''s update `main.js` to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now run this code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: What will happen now is, we will see the word `whatever` printed inside Git
    Bash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take our experiment a step further. Here''s our updated `whatever.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Consequently, we need to update `main.js` too as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As we have already seen, the `require` keyword imports a module's code and makes
    it available in another file; in our example, the `main.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `exports` keyword lets us make the code available to other files, with
    one caveat. It also allows us to choose what parts of our module we want to make
    available to other files. As we see, the `module.exports` is an object. The contents
    of this object is what will be returned when our `whatever` module is required
    by `main.js`. This allows us to expose only certain sections of our code, and
    enables the setup of a module''s interface. In other words, `module.exports` is
    what enables us to keep parts of our code private. Consider this update to `whatever.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We don't need to make any changes to `main.js`. If we ran it from Git Bash,
    we'd still get the word `whatever` output to console. But we have made parts of
    `whatever.js` not directly accessible.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, notice that in the preceding code, the function syntax of ES3
    and ES5 are used alongside one another. The section of code that defines the `returnSomething`
    function is using newer syntax, which lets us write function definitions without
    having to use the `function` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Module bundlers, a way to use modules in the browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, you can't just use the `require` keyword, as we just saw, straight
    in the browser. The `require` keyword is not a part of JS's browser API. It is
    important to note here that Node.js has the ability to read from and to the filesystem
    of your computer. Thus, if you installed any NPM package in a project, using Node.js,
    you would be able to require such a module as explained previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, JS in the browser does not have access to the file system of your
    OS, and thus this leaves us with a conundrum: how do we use the JS module syntax
    inside the browser?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer: we have a tool for that, and it''s called a **module bundler**.'
  prefs: []
  type: TYPE_NORMAL
- en: Today, in 2019, there are a number of different module bundlers available, such
    as webpack ([http://webpack.github.io/](http://webpack.github.io/)), FuseBox ([https://fuse-box.org/](https://fuse-box.org/)),
    Parcel ([https://parceljs.org/](https://parceljs.org/)), rollup.js ([https://rollupjs.org/guide/en](https://rollupjs.org/guide/en)),
    or Browserify ([http://browserify.org/](http://browserify.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'What is a module bundler? Here is a quote from the Browserify home page, which
    puts it succinctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Browserify lets you require (''modules'') in the browser by bundling up all
    of your dependencies."'
  prefs: []
  type: TYPE_NORMAL
- en: Besides bundling all the dependencies that get required through modules in your
    project, module bundlers also solve issues such as cyclical dependencies; that
    is, they use algorithms that resolve the order in which all the project's dependencies
    should be bundled in your project.
  prefs: []
  type: TYPE_NORMAL
- en: We have almost finished our overview of the JS ecosystem. Next, we'll look at
    one particular flavor of a module bundler, and that is webpack.
  prefs: []
  type: TYPE_NORMAL
- en: Once we know just what exactly webpack is and how it works under the hood, we'll
    be able to fully comprehend where it fits within Vue CLI.
  prefs: []
  type: TYPE_NORMAL
- en: What is webpack?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Webpack is a module bundler for the web. Some people also refer to it as an
    asset compiler for web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to webpack''s GitHub page:'
  prefs: []
  type: TYPE_NORMAL
- en: '"It packs many modules into a few bundled assets and so on. Modules can be
    CommonJs, AMD, ES6 modules, CSS, images, JSON, CoffeeScript, LESS, and so on,
    and your custom stuff."'
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in this chapter, in the section titled *Working with modules in Node.js*,
    we barely scratched the surface of how modules get exported and required in Node
    apps. What we did not mention is that there are all kinds of different module
    syntaxes that we can use. As already mentioned, Node.js works with the CommonJS
    module syntax. Besides CommonJS, there is also **Asynchronous Module Definition**
    (**AMD**). Alongside AMD, you can use ESM modules. With ESM modules, the syntax
    is a bit different from what we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite the `whatever` module using ESM syntax by taking the following
    steps, and use it in `main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep things easy, let''s also create a new folder as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s point our Git Bash by using the `cd` command (the *change directory*
    command) as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add our two files as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s open our folder with VS Code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s add the code for `main2.mjs` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s follow it up with code for `whatever2.mjs` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we needed to save the files as ESM modules, using the `mjs`
    file extension. Node.js supports ESM modules experimentally, so you need to run
    the following command in Git Bash:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon running the preceding command, this is the output you''ll see in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, besides receiving the expected output in the console, we also
    got the `ExperimentalWarning` message. Hopefully, this demonstration of two different
    kinds of module syntaxes helps us understand what webpack will do for us. Among
    other things, it will *level the playing field*, so that we can use various standard
    and non-standard ways to work with modules in our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, what webpack does is, it takes our modules with dependencies (including
    our project's assets such as `.png`, `.jpeg`, and `.scss` files), and it outputs
    static assets (`.js`, `.css`, and `.image` files).
  prefs: []
  type: TYPE_NORMAL
- en: How webpack works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen how to use the CommonJS and ESM module syntax. Again, CommonJS is
    the syntax used for Node.js modules. This means that all the dependencies in a
    Node.js module are described using the `require` command. Contrary to this, a
    webpack module's dependency can be described in a wide variety of syntaxes. For
    example, if your module's dependency was an SCSS partial, you'd use an `@import`
    statement. If you were importing an AMD module's dependency, you'd be using it's
    own `require` and `define` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: What this means is, that basically, *webpack modules accept all the different
    syntaxes for importing various dependencies* of a module. Even the `src` attribute
    (for the `img` HTML element) is considered a webpack module's dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Building a new project and running webpack on it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now build a project and integrate webpack bundling into our workflow
    by taking the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a new directory. Let''s run a command that doesn''t exist as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The console will return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Now, let''s use the *repeat last command* shortcut, the double exclamation
    mark, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding command will create our `new-project-with-webpack` folder,
    and will `cd` into this new directory. The double ampersand command (`&&`) is
    just a way to run multiple commands one after another, rather than having to type
    them out one by one. The double exclamation mark command (`!!`) means *repeat
    the previous line*, so the preceding command actually means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s add our `package.json`, and accept all the defaults (using the
    `-y` flag) as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s inspect the contents of our folder in VS Code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once VS Code is running on our screen, we can double-click the `package.json`
    file and verify it''s contents as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add webpack to our project as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Once done, let''s go back to VS Code and review our `package.json` again as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, a new key has been added: `devDependencies`. Inside it, we have
    the `webpack` and the `webpack-cli` development dependencies. These `devDependencies`
    are the dependencies that you will be using only while building your project,
    and webpack is a perfect example of such a dependency: you will not need webpack
    in production. That''s why we''ve used the `--save-dev` flag when we installed
    webpack via NPM.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the file structure of our project, we can now see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If you open the `node_modules` folder, you see over 300 folders inside. This
    huge list of dependencies begins with a `.bin` folder. Contrast this with one
    of our previous examples, `vue-from-npm`, where we had only four subfolders inside
    the `node_modules` folder, even though we installed both the `vue` and `accounting-js` NPM
    packages. Note also that inside the `vue-from-npm` folder, there is no `.bin`
    folder. This is the case regardless of whether you install it with the `--save`
    or the `--save-dev` flag when running `npm install`. While this might be obvious
    to more experienced developers, it might be important for better understanding
    to those developers who do not have enough experience with Node.js and NPM ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is this `.bin` folder? It just stores the compiled native binaries
    (that is, executable files) of a Node module that you installed using `npm install`.
    Not all NPM modules have these compiled native binaries and this is why you won't
    always see the `.bin` folder inside the `node_modules` folder. Inside this `.bin`
    folder, there are many different Node modules. These are all necessary for webpack
    to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our project, let''s now add two files to it: `index.js`, and `whatever.js` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Currently, we won't be adding any code to either of those files. Right now,
    we'll focus on running webpack in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Running webpack on a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go back to our `new-project-with-webpack` folder, and examine the contents
    of `package.json` again, with the focus on the `scripts` key as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command in Git Bash to run `test` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This will throw an error, with `exit code 1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make some changes to it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Let's run the test again with `npm run test`. This time the output in the console
    will not be as ghastly, because we removed the `exit 1` command, and we altered
    the wording of what will be echoed when running the `test` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try something else entirely as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we get no errors, because our `index.js` is empty. Let''s add something
    to it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Save changes to `index.js`, run `npm run test` again, and this time the output
    in Git Bash will be number `4` printed to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: What does this tell us? It tells us that we are in complete control of what
    our scripts are going to do! So, initially we had a script that was named test.
    This script would echo out a message and throw an error with `exit code 1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'And just as we can give our scripts any arbitrary key name, such as `test`,
    we can also give them any arbitrary value. Of course, `console.log(2+2)` is a
    silly value to give to a script key. We can give our scripts keys much better
    values, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run an NPM script with the value of webpack, this script will
    then run the webpack executable. Let''s try it out as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns an error, but out of all the information that gets logged out,
    the following two lines are the most important:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason we got this error is because webpack looks for an entry point to
    get started on. By default, this entry point is set to `./src/index.js`. So, let''s
    add this `src` folder, and move our `index.js` into it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run webpack from the command line again as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This time we''ll get a much better output. However, there is no syntax highlighting
    in Git Bash by default. This can be fixed really fast. Since we are already using
    VS Code, simply type the keyboard shortcut of *Ctrl* + *~*. If you''re not familiar
    with this symbol, it''s called a *tilde*, and it''s located right under the *Esc*
    key, and above the *Tab* key. Pressing this keyboard shortcut will open up a terminal
    window inside VS Code, and if you execute the `npm run webpack` command again,
    you''d get nicely formatted and color highlighted output, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3d6cb640-cf6b-4d45-8781-a79d20bdb165.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Webpack logging out information to console in VS CodeAs a side
    note, your screen''s colors might look different, depending on the color scheme
    you are using in your VS Code. To access the color themes, use the following keyboard
    shortcut: *Ctrl + K* *Ctrl + T*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the message that was output to the console, we can see that it can
    be grouped in two sections: the one with the actual information (hash, version,
    time, built at, entrypoint, and so on) and the warning. The warning reads that
    we haven''t set the `mode` option.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If unset, the `mode` option defaults to production. However, we can also set
    it to `development`, which is optimized for faster builds. This means that we
    can add another script in our `scripts` section of `package.json`, and this script
    can then be used for the development build of our project. This is the updated
    `scripts` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run the development mode in webpack, with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the complete output in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, it took webpack `108ms` to bundle my project in the development
    mode. When I ran it in production mode (the default `npm run webpack` command
    in my setup), it took `447ms`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What does actually happen when we run this command? What does webpack do in
    the background? It builds a dependency graph of all the module dependencies. To
    go back to our analogy from earlier in the chapter, it''s as if we gave it a bunch
    of episodes of a TV show, recorded on a bunch of Blu-ray discs, and it takes all
    of them and lines them up properly. Webpack figures out the correct place for
    each of these modules, and then bundles them up and serves them to the `dist`
    folder. If you look at your project''s file structure again, you''ll see that
    now there''s a new addition: the `dist` folder. If we inspect the contents of
    the `dist` folder, this is what we''ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If we inspect the `main.js` file, we'll see that there is a lot of stuff that
    webpack adds. Even on a tiny project like ours, the output gets to be about 100
    lines long.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first few lines of our `main.js` file look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Let's run our `npm run webpack` command again to see how it will affect the
    output in `main.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we inspect `main.js`, we will see that now we have only a single line of
    code, beginning with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: What this means is that webpack uglifies and minifies our code when run in production
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, this affects the file size too. While the bundled `main.js` file
    has the file size of 3.81 KB in development mode, when bundled in production mode,
    it has just 944 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to avoid seeing the warning message, we can update our scripts entry
    in `package.json` to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we can start using webpack with Vue. However, we won't be using
    the Vue CLI. Instead, we'll see how to set everything up manually. This is not
    the best way to do things, but it will help us better understand why things are
    done the way they are in the Vue ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Vue project via NPM and using webpack with it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll build a new project with NPM, then add webpack to it,
    and finally add a Vue single file component to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s make a new directory by taking the following steps. We''ll call
    our project `npm-vue-webpack`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Git Bash and add a new folder as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize `npm` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install Vue and webpack into our new project as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Once the NPM installation is complete, we can verify the folders and the contents
    of `package.json` as we did earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the source and output folders our project will use as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Open our new project in VS Code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add two new files right from the VS Code editor. We''ll call the
    first file `source.js`, and we''ll call the second file `output.js`. Make sure
    you have added and saved these two empty files in your project at this stage:
    `source.js` in the `src` folder, and `output.js` in the `dist` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding our Vue component as a JavaScript module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s add our Vue component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add this code to `source.js` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: On the first line, we're importing a file called `CustomArticle.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's make a new file inside the `src` folder. We'll call this file `CustomArticle.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we're using the ESM syntax to export and import a JS module.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling JavaScript modules with webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are almost ready now to compile our `source.js` to `output.js` with the
    help of webpack. However, before we do it, we still need to update the `scripts`
    section of our `package.json` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run the following command inside Git Bash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: As expected, we see the output in the console, together with the warning about
    setting the mode option. We now know what this means, so it's not important to
    deal with it at this time.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we inspect the contents of `output.js`, we''ll see that it''s empty, and
    that, by default, webpack minified and obfuscated our output code to the default
    `main.js` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: So, how do we make webpack output to a different file, other than the default
    `main.js`? We use the webpack configuration file!
  prefs: []
  type: TYPE_NORMAL
- en: Adding options with the help of the webpack configuration file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the webpack configuration file, we can add various options to the way
    our apps get bundled with webpack. Here is how:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new file to the root of our project. We''ll call this `webpack.config.js`
    file. Here is the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run our command again as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This time it outputs to the correct file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as we can specify the output file, we can also specify the input file as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We still need to render our Vue component somewhere on the screen. We need an
    HTML file for that.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an HTML file so that we can render our Vue component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add a new HTML file, we''ll call it `index.html`, to our `dist` folder as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Just as we discussed at the very beginning of this chapter, we are adding scripts
    directly to our HTML in the *old-school* way, by just stacking `script` tags at
    the bottom of our HTML file. The first `script` tag we're using is fetching Vue
    from a CDN, and the second `script` tag fetches our `output.js` file from the
    `dist` folder.
  prefs: []
  type: TYPE_NORMAL
- en: If you're using VS Code, you can now right-click on your new `dist/index.html`
    file, and click the Open in default browser command.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the following sentence on the web page that opens:'
  prefs: []
  type: TYPE_NORMAL
- en: Our own custom article component!
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to give webpack the ability to output an HTML file. For that, we'll
    need to use the `html-webpack-plugin`.
  prefs: []
  type: TYPE_NORMAL
- en: Giving webpack the ability to output an HTML file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll see how to output an HTML file using a webpack plugin
    by taking the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `html-webpack-plugin` via NPM as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `devDependencies` of `package.json` have updated accordingly as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, update our `webpack.config.js`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Before we continue, delete the `index.html` file that we had in our `dist` folder.
    Don't worry about deleting it, though, since webpack will soon recreate it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, let''s run the webpack script again as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Webpack just created a new `index.html` file for us! Here''s the contents of
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This is all great, but obviously, our file is not the same. We have lost our
    entry point for the Vue component we had. Also, we need to update our Vue code
    so that it works as a single file component.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a .vue file as a JavaScript module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s update the `source.js` file, to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now also rename our `CustomArticle.js` to `CustomArticle.vue`, and add
    the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, webpack doesn't work with `.vue` files out of the box. To fix
    the issue at hand, we need to use a **webpack loader**. A webpack loader helps
    webpack understand the files it's working with. There are many loaders out there,
    but for now, we need to work with Vue.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a webpack loader to work with .vue files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To work with `.vue` files, take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install a webpack loader called `vue-loader` via NPM as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve saved it, we need to use it, and we''ll do that by updating
    the webpack configuration as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Try running webpack now as follows. Spoiler alert: it will fail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The error message we get reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix this error, we need to add a rule for our Vue loader, by updating our
    `webpack.config.js` file to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The `test` key inside the array in the `rules` option receives a regex as a
    value. This regex is checking for the presence of a file with a `vue` file extension.
    If it matches, that is, if it finds a `vue` file, it will use the `vue-loader`
    module on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run our webpack script again as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This will throw another error as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'There are more errors logged out to the console, but this is the one that we
    need to fix by adding another NPM package, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `devDependencies` entry inside `package.json` just received another update, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now we can run webpack again as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: After webpack ran, if you opened `output.js` at this time, you'll see that it
    has the full Vue library inside of it, along with our `CustomArticle` at the very
    end. This all compiled without any errors.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the issue with our index.html file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We still have the issue of the `index.html` file in the `dist` folder. It''s
    an easy fix! We''ll just add our own `index.html` file to the `src` folder, with
    the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have now removed our own `script` tags, since webpack will be
    adding them. Also, make sure to delete the `index.html` file inside the `dist`
    folder. Now, run the `npm run webpack` command again, and you''ll get this output
    in `dist/index.html` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Why is this not working?
  prefs: []
  type: TYPE_NORMAL
- en: It is not working because we need to update both the JS files to be output,
    as well as the HTML files. Currently, we are only updating the JS files, but we
    still need to do it for our `index.html` file. Luckily, we already have `html-webpack-plugin`
    to help out.
  prefs: []
  type: TYPE_NORMAL
- en: Delivering HTML files via webpack with the help of html-webpack-plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll begin by updating the `html-webpack-plugin` in the `webpack.config.js`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'What we did in the plugins section was, we passed an `options` object to our
    `HtmlWebpackPlugin()` call. Inside this `options` object, we specified our template:
    `./src/index.html`.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we run the webpack script again, we need to make sure to add the `meta`
    tag with `charset` set to `utf-8`. Otherwise, we'll get an error in our console
    when we open `dist/index.html` in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now run `npm run webpack` again. This time, everything works! We get
    our humble looking sentence on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: Our own custom article component!
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! Although it is humble looking, you have successfully added
    a Vue app to an NPM-powered project, running on webpack.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll learn about HMR, and how it helps us in our Vue development.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Hot Module Replacement in Vue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HMR has become a sort of a buzzword in the past couple of years. What's the
    big deal? In this section, we'll discuss how HMR works.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we''ll build another default simple app, just like we did in [Chapter
    1](081bc26f-96a8-4cb0-8e73-d7c6e67f409b.xhtml), *Introducing Vue CLI 3, *as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'After a while, once it''s done, we''ll go into our app''s directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s open the project''s folder in VS Code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can see the entire contents of our `second-default-project`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can serve the app as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Of course, our app is now serving in our browser.
  prefs: []
  type: TYPE_NORMAL
- en: To view your app, visit `localhost:8080` in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at HMR updates happening in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Observing HMR updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the browser window is active, let''s press the *F12* key to turn on the
    developer tools. Let''s also make sure that our the Elements panel is the active
    tab inside the dev tools, so that we can see the **Document Object Model** (**DOM**)
    structure, like in the following zoomed-in screenshot from the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/555e8cdc-a628-43eb-870d-45c51239a104.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: The welcome screen of second-default-app with the Elements panel
    open in dev tools'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see HMR in action. Ideally, to see this in action, you'd need to
    use two monitors. Thus, you could, for example, move your VS Code window to the
    left monitor, and your browser with the app served to the right monitor. Alternatively,
    you can use a single monitor and view both apps side by side (with each one taking
    up half the screen width). The point of this exercise is to be able to see at
    the same time your VS Code window, your Vue app browser window, and your Elements
    panel inside your browser's dev tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, inside VS Code, open the `App.vue` file (inside the `src` folder of your
    project). Look at line 4, which currently reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: We'll soon change that line to something else. Before you change the line, pay
    attention to how these changes reflect in the browser serving your app. Will the
    browser refresh?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you''re focused on tracking changes in browser, let''s update line
    4 in `App.vue` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to the browser while you're saving changes to `App.vue` in VS
    Code. The best way to do this is to have VS Code in focus, but watch the browser
    window, specifically the Elements panel. With VS Code in focus, you can save changes
    with the shortcut key *Ctrl* + *S*.
  prefs: []
  type: TYPE_NORMAL
- en: If you pay close attention, and if you're using Chrome, you'll notice a flash
    of purple color inside the Elements panel. That's the Chrome browser notifying
    us of the changes that happened to the DOM of our Vue app. If you pay close attention,
    you'll notice that there is a flash on the `head` element, as well as the `h1`
    element and it's child text node, `HMR is cool`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you might notice that there was no refresh on the browser. Neither webpack,
    our app's code, or we ourselves forced the browser to refresh. What's the conclusion
    here? Webpack is actually not forcing a page refresh with HMR! Instead, it just
    injects an HMR.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the change on the `h1` element is obvious (as it is the immediately visible
    consequence of us changing the text inside the `App.vue` file), the update that
    happens in the `head` element is both more obscure and more helpful. To see what
    is happening, let''s twirl open the head tag by clicking on the little black triangle
    to the left of the `head` tag inside the Elements panel, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/495be8e0-9fbb-415a-ac5e-e73a101235f3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Twirl-open the head tag inside Elements panel in dev tools'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll need to scroll all the way down to the closing `</head>` tag.
    Right above it, there will be a `script` tag that reads something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s keep close attention on this section of the DOM tree in the Elements
    panel, while we make another change to `App.vue`. Let''s update our `msg` attribute
    on line 4 to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'If you observed the `script` tag, you''ll notice it change as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Did you notice that Vue injected another script above the closing `</head>`
    tag? That injected script is HMR in action, right there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s inspect the very first line of the appended script file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: How does this whole process work? Webpack simply runs our changes, bundles an
    update to our app, and, since it is already running, injects the new code using
    Vue loader.
  prefs: []
  type: TYPE_NORMAL
- en: So, as we've just seen, HMR is just a feature of webpack that helps us do things
    more smoothly, without the need to worry about refreshing our apps.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we discussed the evolution of the JS language and its ecosystem,
    and how this evolution lead to the appearance of module bundlers. We also looked
    at webpack, the module bundler of choice of Vue CLI 3.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at how to plug in a very basic Vue-powered app, running on single
    file Vue templates. Alongside this mini-project, we also looked at a number of
    important webpack concepts. We finished the chapter by observing HMR on a Vue
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the very basics of how webpack works, in the chapters that
    follow, we'll discuss some other related technologies and we'll build on our knowledge
    of webpack and Vue CLI 3\. The next topic we'll be closely examining is Babel.
  prefs: []
  type: TYPE_NORMAL
