- en: Webpack in Vue CLI 3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue CLI 3中的Webpack
- en: 'In the previous chapter, we saw how to start using Vue CLI via both the command
    line and the UI. In this chapter, we will cover webpack basics from the viewpoint
    of Vue CLI 3\. We will begin with an overview of what webpack is. We''ll look
    at concepts behind module bundling, tree shaking, webpack loaders and output,
    webpack plugins, **Hot Module Replacement** (**HMR**), code coverage and code
    splitting, and then we''ll look at how these concepts fit in with Vue CLI 3 as
    follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何通过命令行和UI开始使用Vue CLI。在本章中，我们将从Vue CLI 3的角度介绍webpack的基础知识。我们将首先概述webpack是什么。我们将研究模块捆绑、摇树、webpack加载器和输出、webpack插件、**热模块替换**（**HMR**）、代码覆盖和代码拆分的概念，然后我们将看看这些概念如何与Vue
    CLI 3配合，如下所示：
- en: The evolution of the **JavaScript** (**JS**) language from the script tag to
    module bundlers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从脚本标签到模块捆绑器的JavaScript（JS）语言的演变
- en: The script tag
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本标签
- en: '**Immediately Invoked Function Expressions** (**IIFEs**), what problems they
    solve, and what problems they don''t'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**立即调用函数表达式**（**IIFEs**），它们解决了什么问题，以及它们没有解决的问题'
- en: How **Node Package Manager** (**NPM**) helps teams share third-party libraries
    in their code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node Package Manager** (**NPM**)如何帮助团队在他们的代码中共享第三方库'
- en: The role of JS task runners and NPM scripts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JS任务运行器和NPM脚本的作用
- en: What the CommonJS specification is and how modules work in JavaScript and Node.js
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CommonJS规范是什么，以及它如何在JavaScript和Node.js中工作
- en: What module bundlers are and how they bridge the gap between Node.js and the
    browser
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块捆绑器是什么，以及它们如何弥合Node.js和浏览器之间的差距
- en: What webpack, and how it works
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: webpack是什么，以及它是如何工作的
- en: How to run webpack on a project
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在项目中运行webpack
- en: Bundling assets with webpack using production and development modes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生产和开发模式使用webpack捆绑资产
- en: Adding a Vue project via NPM and using webpack with it
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过NPM添加Vue项目并使用webpack
- en: Understanding exactly how webpack works is crucial to understanding the magic
    that Vue CLI 3 performs. If you are familiar with webpack, you still might find
    some sections of this chapter useful. If you feel you are a webpack pro, you can
    probably just skip this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 准确理解webpack的工作原理对于理解Vue CLI 3的魔力至关重要。如果您熟悉webpack，您可能仍然会发现本章的某些部分有用。如果您觉得自己是webpack专家，您可能可以直接跳过本章。
- en: Before getting into what is webpack and to properly understand the issues that
    webpack solves, we need to look back at a bit of history of changes that happened
    to the JS language in the last decade.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解webpack是什么以及正确理解webpack解决的问题之前，我们需要回顾一下过去十年中JS语言发生的一些变化。
- en: The evolution of the JS language
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JS语言的演变
- en: 'Looking from the vantage point of webpack, here is the chronological list of
    approaches, techniques, best practices, and patterns that were added to the JS
    ecosystem, which led to the current state of things:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从webpack的角度来看，以下是JS生态系统中添加的方法、技术、最佳实践和模式的时间顺序列表，这些方法、技术、最佳实践和模式导致了当前的状态：
- en: The `script` tag as the answer to adding interactivity to web pages
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`script`标签作为向网页添加交互性的答案'
- en: Immediately invoked function expressions as the answer to modularizing libraries
    and avoiding code collisions
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即调用函数表达式作为模块化库和避免代码冲突的答案
- en: The problem with IIFEs
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IIFEs的问题
- en: Sharing third-party libraries in a team environment with NPM
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NPM在团队环境中共享第三方库
- en: JS task runners and NPM scripts
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JS任务运行器和NPM脚本
- en: Modules in JS
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JS中的模块
- en: Let's look at each one of these solutions in more detail.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些解决方案中的每一个。
- en: The script tag
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本标签
- en: Initially, adding JS to your web page meant that you would need to add some
    `script` tags directly in your HTML. For quick prototypes, this is still a valid
    way of doing things even to this day. Very often, third-party libraries get added
    via the `src` attribute inside a `script` tag (which usually gets placed right
    above the closing `body` tag in our HTML).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，将JS添加到您的网页意味着您需要直接在HTML中添加一些`script`标签。对于快速原型，这仍然是一种有效的做法，甚至到今天。很多时候，第三方库是通过`script`标签内的`src`属性添加的（通常放在我们的HTML中关闭`body`标签的正上方）。
- en: Unfortunately, you usually need more than one `script` tag inside your HTML.
    And regardless of whether you add your JS code directly to your page, you add
    it from another file in your project, or you add it from a remote location (such
    as from a **content delivery network** (**CDN**) using the `src` attribute), ultimately,
    all these scripts are added to the global JS scope. This means one thing, collision.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，您通常需要在HTML中添加多个`script`标签。而不管您是直接将JS代码添加到页面中，还是从项目中的另一个文件添加，或者从远程位置添加（例如从**内容传送网络**（**CDN**）使用`src`属性），最终，所有这些脚本都被添加到全局JS范围内。这意味着一件事，冲突。
- en: To avoid collisions, a clever approach was taken, the use of IIFEs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免冲突，采取了一个巧妙的方法，即使用IIFE。
- en: Immediately Invoked Function Expressions
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 立即调用的函数表达式
- en: What are IIFEs all about? IIFEs simply exploit the fact that in JS, *parentheses
    can't contain statements*. This fact alone allowed JS developers to put in anonymous
    functions that they could immediately invoke, without getting any errors from
    the parser, by simply wrapping them in parentheses.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: IIFE到底是什么？IIFE简单地利用了JS中*括号不能包含语句*的事实。这个事实本身允许JS开发人员放入匿名函数，他们可以立即调用，而不会因为简单地将它们包装在括号中而从解析器中得到任何错误。
- en: An IIFE is essentially a quirk of the JS language, but a very useful one; with
    an IIFE, all the code is scoped to the function, and thus your code is safe from
    anything else that is outside of it. In other words, using IIFEs is a simple way
    to avoid collisions, that is, the accidental overwriting of variables or functions.
    Thus, at one point, many popular libraries started wrapping their own code into
    IIFEs. For example, if you open the code for the jQuery library ([https://code.jquery.com](https://code.jquery.com)),
    or for the Chart.js library ([https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.3/Chart.bundle.js](https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.3/Chart.bundle.js)),
    or for many other popular JS libraries, you'd find that they use the IIFE pattern.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: IIFE本质上是JS语言的一个怪癖，但是非常有用；通过IIFE，所有的代码都被限定在函数范围内，因此您的代码不会受到外部任何其他东西的影响。换句话说，使用IIFE是避免冲突的一种简单方法，即意外覆盖变量或函数。因此，有一段时间，许多流行的库开始将它们自己的代码包装成IIFE。例如，如果您打开jQuery库的代码（[https://code.jquery.com](https://code.jquery.com)），或Chart.js库的代码（[https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.3/Chart.bundle.js](https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.3/Chart.bundle.js)），或许多其他流行的JS库的代码，您会发现它们使用了IIFE模式。
- en: Thus, with IIFEs, we could add different scripts to our pages, without the worry
    that code collisions might happen.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过IIFE，我们可以向页面添加不同的脚本，而不必担心代码冲突可能发生。
- en: The problem with IIFEs
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IIFE的问题
- en: 'Unfortunately, simply using IIFEs does not fix all our problems. To illustrate
    the issue at hand, let''s quote Joe Armstrong, creator of Erlang:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，仅仅使用IIFE并不能解决我们所有的问题。为了说明手头的问题，让我们引用Erlang的创始人Joe Armstrong的话：
- en: '"You wanted a banana, but what you got is the gorilla holding the banana, and
    the entire jungle."'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: “你想要香蕉，但你得到的是拿着香蕉的大猩猩，整个丛林。”
- en: Bear in mind that in this quote, Mr. Armstrong was discussing a problem with
    object-oriented languages, but the underlying issue is applicable in JS code modularization.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在这段引用中，阿姆斯特朗先生讨论的是面向对象语言的问题，但根本问题在JS代码模块化中也适用。
- en: Basically, our problem with IIFEs is that we can't cherry-pick specific functionality
    that we'd like to use from a JS library. With the IIFE pattern, we *must* use
    everything that is wrapped up in an IIFE, even if we are only using just a small
    piece of a specific library's codebase. Of course, to be honest, IIFEs are not
    the ones to blame for this. JS, the language, for a long time simply did not have
    the ability to cherry-pick any kind of code functionality, because in JS, it was
    simply impossible to split your code into modules.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们对IIFEs的问题在于我们无法从JS库中精选出我们想要使用的特定功能。使用IIFE模式，我们*必须*使用IIFE中包含的所有内容，即使我们只是使用特定库代码库的一小部分。当然，老实说，IIFEs并不是这个问题的罪魁祸首。长期以来，JS语言根本没有能力精选任何类型的代码功能，因为在JS中，将代码拆分成模块是不可能的。
- en: Another major pain point of JS was the issue of reusing third-party code across
    teams.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: JS的另一个主要痛点是在团队之间重复使用第三方代码的问题。
- en: Sharing third-party libraries in a team environment with NPM
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NPM在团队环境中共享第三方库
- en: IIFEs solved the problem of code collisions, but they didn't solve the problem
    of code reuse. What if a developer on my team has a different, updated version
    of a library, with breaking changes? What if I decide to update the dependencies
    on my computer? How will my other team members deal with that? Besides using source
    version control, are there any other options for faster collaboration?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: IIFEs解决了代码冲突的问题，但并没有解决代码重用的问题。如果我的团队中的开发人员有一个不同的、更新的库版本，其中有破坏性的更改，该怎么办？如果我决定在我的计算机上更新依赖关系，我的其他团队成员将如何处理？除了使用源代码版本控制，还有其他更快的协作选项吗？
- en: '**Node Package Manager** (**NPM**) was the answer to these problems. Node is
    just a Google V8 JS engine that can run on a server. NPM simply allows a developer
    to install new libraries into a project, regardless of whether it is to be used
    on the frontend or the backend of an app. So, effectively, NPM is the JS package
    manager, similar to what we have in Ruby (gems ([https://rubygems.org/](https://rubygems.org/))),
    C# (NuGet ([https://www.nuget.org/](https://www.nuget.org/))), or in Linux (`apt-get`,
    `yum`).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**Node Package Manager**（**NPM**）是这些问题的答案。Node只是一个可以在服务器上运行的Google V8 JS引擎。NPM允许开发人员将新库安装到项目中，无论是用于应用程序的前端还是后端。因此，NPM实际上是JS包管理器，类似于Ruby（gems
    ([https://rubygems.org/](https://rubygems.org/)））、C#（NuGet ([https://www.nuget.org/](https://www.nuget.org/)））或Linux中的`apt-get`、`yum`。'
- en: For example, let's say we wanted to install Vue via NPM. If we have Node installed
    on our machine, we'll have NPM too, since NPM comes bundled with a Node installation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想通过NPM安装Vue。如果我们的计算机上安装了Node，那么我们也会有NPM，因为NPM随Node一起捆绑安装。
- en: 'Next, we need to create a new directory. Let''s change this directory''s name
    to `vue-from-npm`, and point our command-line console to it. We can then follow
    it up with this command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个新目录。让我们将此目录的名称更改为`vue-from-npm`，并将命令行控制台指向它。然后我们可以跟随这个命令：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Running the preceding command will create a `package.json` file. The `-y` flag
    accepts all the default answers that you'd be prompted with in the console.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令将创建一个`package.json`文件。`-y`标志接受控制台中提示的所有默认答案。
- en: 'If we looked at the newly created `package.json` file inside our project directory,
    we''d see the following contents:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看项目目录中新创建的`package.json`文件，我们会看到以下内容：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that the `npm init` command only adds a `package.json` file to an empty
    directory. That's all that it does!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`npm init`命令只会将`package.json`文件添加到空目录中。就是这样！
- en: 'Adding Vue is then as simple as running this command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加Vue就像运行这个命令一样简单：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding command will do a few things, namely:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将执行一些操作，即：
- en: It will add the `node_modules` directory.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将添加`node_modules`目录。
- en: It will put the entire Vue library inside the `node_modules` directory.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将整个Vue库放在`node_modules`目录中。
- en: It will create the `package-lock.json` file in the root of our project.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将在我们项目的根目录中创建`package-lock.json`文件。
- en: It will update the `package.json` file in the root of our project.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将更新我们项目的根目录中的`package.json`文件。
- en: 'The updated `package.json` file now looks like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的`package.json`文件现在看起来是这样的：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If it is not obvious, the file has been updated with a new entry: `dependencies`.
    This entry lists all the dependencies included in the project. Specifically, we
    have added Vue (version 2.6.7 or above) to our project.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不明显的话，文件已经更新了一个新条目：`dependencies`。这个条目列出了项目中包含的所有依赖项。具体来说，我们已经将Vue（版本2.6.7或以上）添加到了我们的项目中。
- en: 'A great thing about NPM is that we can add any other library to our project,
    just as easily as we did with Vue. For example, to update our project with accounting.js,
    we just run this command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: NPM的一个很棒的地方是，我们可以像添加Vue一样轻松地向我们的项目添加任何其他库。例如，要使用accounting.js更新我们的项目，我们只需运行这个命令：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once the installation is complete, let''s again inspect the `node_modules`
    directory as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，让我们再次检查`node_modules`目录：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that for the sake of brevity, we are only showing the second level of folders
    and files inside the `accounting-js` folder. The `is-string`, `object-assign`,
    and `vue` folders are shown collapsed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了简洁起见，我们只显示了`accounting-js`文件夹内的第二级文件夹和文件。`is-string`，`object-assign`和`vue`文件夹都被折叠显示。
- en: 'What this shows us is that sometimes other NPM modules come bundled with the
    actual libraries that we installed. In the case of `accounting-js`, we also got
    the `is-string` and `object-assign` NPM modules. Let''s also inspect the updated
    `package.json` file in the root of our directory as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们展示了有时其他NPM模块会捆绑实际安装的库。在`accounting-js`的情况下，我们还得到了`is-string`和`object-assign`
    NPM模块。让我们也检查一下我们目录根目录中更新的`package.json`文件：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we can see, the root `package.json` file has been updated with the proper
    version of `accounting-js`. Let's locate another `package.json` file, this time
    inside the `node_modules/accounting-js` folder. If you opened that file, it holds
    a lot more information, in just a bit over 100 lines of code. This information
    is specific to the actual NPM module, `accounting-js`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，根`package.json`文件已经更新为正确的`accounting-js`版本。让我们找到另一个`package.json`文件，这次是在`node_modules/accounting-js`文件夹中。如果你打开了那个文件，它包含了更多信息，仅仅超过100行代码。这些信息是特定于实际的NPM模块`accounting-js`。
- en: OK, so now our project is ready for collaboration. The way to do it? Let's see
    how a colleague of ours, let's call him `John`, would add the project we just
    created, and all the project dependencies, on his own computer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们的项目已经准备好进行协作了。怎么做呢？让我们看看我们的一个同事，让我们称他为“约翰”，如何在他自己的电脑上添加我们刚刚创建的项目和所有项目依赖项。
- en: To do this, we'll create a new folder, let's call it `johns-computer`, and let's
    just copy the root level `package.json` from our `vue-from-npm` folder into our
    `johns-computer` folder.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将创建一个新文件夹，让我们称之为`johns-computer`，然后我们只需将`vue-from-npm`文件夹中的根级`package.json`复制到我们的`johns-computer`文件夹中。
- en: 'Next, let''s simply run this command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们简单地运行这个命令：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Running the preceding command will install all the projects and dependencies
    that we had in the `vue-from-npm` folder.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令将安装我们在`vue-from-npm`文件夹中的所有项目和依赖项。
- en: JavaScript task runners and NPM scripts
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript任务运行器和NPM脚本
- en: 'Around the same time during which NPM was gaining popularity, another frontend
    technology was also on the rise: task runners. Task runners are simple tools;
    they run repetitive tasks. Sometimes, task runners are referred to as build tools
    because they act as intermediaries between updates that a developer makes to a
    codebase, and what the production ready code ends up being. This is what''s known
    as a *build step*, a part of the software development process in which something
    happens to your code *after* you''ve written it.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在NPM变得流行的同时，另一种前端技术也在崛起：任务运行器。任务运行器是简单的工具；它们运行重复的任务。有时，任务运行器被称为构建工具，因为它们充当开发人员对代码库进行更新和最终生成的生产就绪代码之间的中介。这就是所谓的*构建步骤*，这是软件开发过程中的一部分，在这个过程中，你的代码在你编写完之后会发生一些事情。
- en: 'For example, new features that get added to CSS3 usually start off as *vendor
    prefixes* (also known as *browser prefixes*). In other words, before a new CSS
    functionality is available in all browsers, it gets implemented in an experimental
    stage in individual browsers, using browser-specific prefixes as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，CSS3中添加的新功能通常以*供应商前缀*（也称为*浏览器前缀*）的形式开始。换句话说，在新的CSS功能在所有浏览器中可用之前，它会在各个浏览器中以实验阶段实现，使用浏览器特定的前缀，如下所示：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this alphabetically ordered list of browser prefixes, we can see browser
    prefixes for Microsoft browsers, Mozilla, old versions of Opera, and finally,
    all the webkit-based browsers (Chrome, Safari, newer Opera, and so on).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个按字母顺序排列的浏览器前缀列表中，我们可以看到微软浏览器、Mozilla、旧版本的Opera，最后是所有基于webkit的浏览器（Chrome、Safari、新版Opera等）的浏览器前缀。
- en: 'Keeping track of updates to browser prefixes is kind of difficult. It is probably
    not the best use of a developer''s time to monitor for changes to CSS implementations,
    and then update their code accordingly. For example, at a certain point in the
    past, it was necessary to use the following browser prefixes on the CSS `transition`
    property:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪浏览器前缀的更新是有点困难的。开发人员的时间可能不是最好的用法，去监视CSS实现的变化，然后相应地更新他们的代码。例如，在过去的某个时间点，有必要在CSS的`transition`属性上使用以下浏览器前缀：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Obviously, today we simply use the `transition` property in our CSS declarations,
    without any browser prefixes, because the `transition` property is widely supported
    in all modern browsers.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，今天我们在CSS声明中简单地使用`transition`属性，而不需要任何浏览器前缀，因为`transition`属性在所有现代浏览器中得到了广泛支持。
- en: 'Having to deal with the constantly shifting landscape of changes to the CSS
    specification and its implementations in various browsers led to a solution in
    the form of a task runner. Instead of having to manually add vendor prefixes to
    their CSS code, frontend developers could now simply add a plugin to their task
    runner and it would do the dirty work for them: add vendor prefixes where needed.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 不得不应对不断变化的CSS规范和各种浏览器中的实现带来的不断变化的情况，导致了任务运行器这种解决方案的出现。前端开发人员现在不再需要手动向他们的CSS代码中添加供应商前缀，而是可以简单地向他们的任务运行器添加一个插件，它会为他们做这些繁重的工作：在需要时添加供应商前缀。
- en: 'Of course, what we saw previously was just one example of what task runners
    are used for. Some other examples include: minifying CSS and JS files, transpiling
    from ES6 to ES5, compiling CSS from SASS, removing unused CSS, reloading the browser
    whenever a file is saved in your project, and so on.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们之前看到的只是任务运行器用于的一个例子。其他一些例子包括：压缩CSS和JS文件，从ES6转译为ES5，从SASS编译CSS，删除未使用的CSS，在项目中保存文件时重新加载浏览器，等等。
- en: 'Today, there are a number of different tools that help us to effectively automate
    some tasks in our development process. Three tools stand out: Grunt, Gulp, and
    NPM scripts.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，有许多不同的工具帮助我们有效地自动化开发过程中的一些任务。三个工具脱颖而出：Grunt、Gulp和NPM脚本。
- en: 'While Grunt and Gulp are standalone task runners that you can install via NPM,
    NPM scripts are an interesting alternative for the following few reasons:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Grunt 和 Gulp 是独立的任务运行器，可以通过 NPM 安装，但基于 NPM 的脚本是一个有趣的替代方案，原因如下：
- en: You are using NPM anyway, so why not get more familiar with a tool you are already
    using?
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您已经在使用 NPM，为什么不更熟悉一下您已经在使用的工具呢？
- en: Using NPM scripts instead of the aforementioned task runners will streamline
    your development further.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 NPM 脚本而不是前面提到的任务运行器将进一步简化您的开发流程。
- en: By using NPM, you avoid the complexity of having to use a task runner plugin
    for tasks that can be automated straight in NPM.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 NPM，您可以避免使用任务运行器插件来自动化 NPM 中可以自动化的任务的复杂性。
- en: Up until this point, we've looked back at the history and the evolution of the
    JS ecosystem. We've seen how IIFEs were used to take care of accidental scope
    leaks. We've also seen how NPM takes care of code sharing. We've further looked
    at how some repetitive tasks can be automated with the help of task runners, and
    how NPM can be used to remove an unnecessary layer of abstraction by keeping our
    tasks inside NPM scripts.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 直到这一点，我们已经回顾了 JS 生态系统的历史和演变。我们已经看到了 IIFE 如何用来处理意外的作用域泄漏。我们还看到了 NPM 如何处理代码共享。我们进一步看到了如何使用任务运行器自动化一些重复的任务，以及如何使用
    NPM 来通过将任务保留在 NPM 脚本中来消除不必要的抽象层。
- en: However, we still haven't looked at ways to solve the problem of code modularization
    in JS. So, let's look at that next.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还没有看到解决 JS 中代码模块化问题的方法。所以，让我们接着看看。
- en: Modules in JavaScript
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 中的模块
- en: In any programming language, a module is a self-contained piece of functionality. You
    can think of them as different episodes of a TV show. They can be looked at independently.
    They can stand on their own, although they are a part of a greater whole.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何编程语言中，模块都是一个独立的功能块。您可以将它们视为电视节目的不同集数。它们可以独立查看。它们可以独立存在，尽管它们是整体的一部分。
- en: And just like an episode in a TV show has a season and a number, so that we
    know *where it fits* in the bigger plot, a module also holds the information that
    tells us what other modules it relies on (the *module dependencies*), and what
    functionality it adds to the entire app; this is what's known as a *module's interface*,
    the API that's exposed to other modules.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 就像电视节目中的一集有一个季节和一个编号，这样我们就知道*它在*更大情节中的位置一样，一个模块也包含了告诉我们它依赖的其他模块（*模块依赖*）以及它为整个应用程序添加了什么功能的信息；这就是所谓的*模块接口*，对其他模块公开的
    API。
- en: We've seen how in the beginning, JS did not have modules at all. This changed
    with the introduction of Node.js. Node.js is actually an implementation of CommonJS,
    a project that was started in 2009 by Mozilla's Kevin Dangoor.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，在开始时，JS 根本没有模块。这在 Node.js 的引入后发生了变化。Node.js 实际上是 CommonJS 的一种实现，这是由 Mozilla
    的 Kevin Dangoor 在 2009 年发起的一个项目。
- en: 'CommonJS project''s purpose was to define a standard library that would provide
    JS APIs to be used outside of the browser. This included a module specification,
    which resulted in developers being able to use code like this in Node.js:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS 项目的目的是定义一个标准库，提供供在浏览器之外使用的 JS API。这包括一个模块规范，这导致开发人员能够在 Node.js 中使用这样的代码：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Working with modules in Node.js
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Node.js 中使用模块
- en: 'Let''s require and use some modules in Node.js:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Node.js 中要求并使用一些模块：
- en: To begin, we'll create a new directory. Let's call it `module-practice`. Let's
    point our Git Bash to this folder.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个新目录。让我们称之为`module-practice`。让我们将 Git Bash 指向这个文件夹。
- en: 'Once inside it, let''s create two new files. Let''s call these files `main.js`
    and `whatever.js` as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入其中，让我们创建两个新文件。让我们将这些文件命名为`main.js`和`whatever.js`，如下所示：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, let''s open this entire folder in VS Code as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们按照以下步骤在 VS Code 中打开整个文件夹：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s add some code to `whatever.js` as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们向`whatever.js`添加一些代码如下：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is as simple as a piece of code in JS can get.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是JS中代码的简单形式。
- en: 'Let''s now see how can we make it available in our `main.js` file. We''ll just
    need to require `whatever.js` as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使它在我们的`main.js`文件中可用。我们只需要像下面这样要求`whatever.js`：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that it is required, we can use it, so let''s update `main.js` to this:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在它被要求了，我们可以使用它，所以让我们将`main.js`更新为这样：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s now run this code with the following:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们用以下方式运行这段代码：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What will happen now is, we will see the word `whatever` printed inside Git
    Bash.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在会发生的是，我们将在Git Bash中看到单词`whatever`被打印出来。
- en: 'Let''s take our experiment a step further. Here''s our updated `whatever.js`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步进行我们的实验。这是我们更新后的`whatever.js`：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Consequently, we need to update `main.js` too as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要更新`main.js`如下：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we have already seen, the `require` keyword imports a module's code and makes
    it available in another file; in our example, the `main.js` file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，`require`关键字导入了一个模块的代码，并使其在另一个文件中可用；在我们的例子中，就是`main.js`文件。
- en: 'The `exports` keyword lets us make the code available to other files, with
    one caveat. It also allows us to choose what parts of our module we want to make
    available to other files. As we see, the `module.exports` is an object. The contents
    of this object is what will be returned when our `whatever` module is required
    by `main.js`. This allows us to expose only certain sections of our code, and
    enables the setup of a module''s interface. In other words, `module.exports` is
    what enables us to keep parts of our code private. Consider this update to `whatever.js`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`exports`关键字让我们可以将代码提供给其他文件，但有一个注意事项。它还允许我们选择我们想要向其他文件提供的模块的哪些部分。正如我们所看到的，`module.exports`是一个对象。这个对象的内容在我们的`main.js`要求`whatever`模块时将被返回。这使我们能够仅暴露代码的某些部分，并且使模块接口的设置成为可能。换句话说，`module.exports`是使我们能够保持代码的部分私有的东西。考虑对`whatever.js`的这个更新：'
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We don't need to make any changes to `main.js`. If we ran it from Git Bash,
    we'd still get the word `whatever` output to console. But we have made parts of
    `whatever.js` not directly accessible.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要对`main.js`进行任何更改。如果我们从Git Bash运行它，仍然会在控制台输出单词`whatever`。但是我们已经使`whatever.js`的部分内容不直接可访问。
- en: As a side note, notice that in the preceding code, the function syntax of ES3
    and ES5 are used alongside one another. The section of code that defines the `returnSomething`
    function is using newer syntax, which lets us write function definitions without
    having to use the `function` keyword.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个旁注，注意在前面的代码中，ES3和ES5的函数语法一起使用。定义`returnSomething`函数的代码部分使用了更新的语法，这使我们能够在不使用`function`关键字的情况下编写函数定义。
- en: Module bundlers, a way to use modules in the browser
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块捆绑器，一种在浏览器中使用模块的方法
- en: Unfortunately, you can't just use the `require` keyword, as we just saw, straight
    in the browser. The `require` keyword is not a part of JS's browser API. It is
    important to note here that Node.js has the ability to read from and to the filesystem
    of your computer. Thus, if you installed any NPM package in a project, using Node.js,
    you would be able to require such a module as explained previously.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，你不能直接在浏览器中使用`require`关键字，正如我们刚才看到的那样。`require`关键字不是JS浏览器API的一部分。这里需要注意的是，Node.js有能力读取和写入计算机文件系统。因此，如果你在项目中使用Node.js安装了任何NPM包，你就可以像之前解释的那样要求这样一个模块。
- en: 'However, JS in the browser does not have access to the file system of your
    OS, and thus this leaves us with a conundrum: how do we use the JS module syntax
    inside the browser?'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，浏览器中的JS无法访问你的操作系统文件系统，因此这给我们留下了一个难题：我们如何在浏览器中使用JS模块语法？
- en: 'The answer: we have a tool for that, and it''s called a **module bundler**.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是：我们有一个工具可以做到这一点，它被称为**模块捆绑器**。
- en: Today, in 2019, there are a number of different module bundlers available, such
    as webpack ([http://webpack.github.io/](http://webpack.github.io/)), FuseBox ([https://fuse-box.org/](https://fuse-box.org/)),
    Parcel ([https://parceljs.org/](https://parceljs.org/)), rollup.js ([https://rollupjs.org/guide/en](https://rollupjs.org/guide/en)),
    or Browserify ([http://browserify.org/](http://browserify.org/)).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'What is a module bundler? Here is a quote from the Browserify home page, which
    puts it succinctly:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '"Browserify lets you require (''modules'') in the browser by bundling up all
    of your dependencies."'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Besides bundling all the dependencies that get required through modules in your
    project, module bundlers also solve issues such as cyclical dependencies; that
    is, they use algorithms that resolve the order in which all the project's dependencies
    should be bundled in your project.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: We have almost finished our overview of the JS ecosystem. Next, we'll look at
    one particular flavor of a module bundler, and that is webpack.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Once we know just what exactly webpack is and how it works under the hood, we'll
    be able to fully comprehend where it fits within Vue CLI.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: What is webpack?
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Webpack is a module bundler for the web. Some people also refer to it as an
    asset compiler for web applications.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'According to webpack''s GitHub page:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '"It packs many modules into a few bundled assets and so on. Modules can be
    CommonJs, AMD, ES6 modules, CSS, images, JSON, CoffeeScript, LESS, and so on,
    and your custom stuff."'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in this chapter, in the section titled *Working with modules in Node.js*,
    we barely scratched the surface of how modules get exported and required in Node
    apps. What we did not mention is that there are all kinds of different module
    syntaxes that we can use. As already mentioned, Node.js works with the CommonJS
    module syntax. Besides CommonJS, there is also **Asynchronous Module Definition**
    (**AMD**). Alongside AMD, you can use ESM modules. With ESM modules, the syntax
    is a bit different from what we saw earlier.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite the `whatever` module using ESM syntax by taking the following
    steps, and use it in `main.js`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep things easy, let''s also create a new folder as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s point our Git Bash by using the `cd` command (the *change directory*
    command) as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s add our two files as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s open our folder with VS Code as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, let''s add the code for `main2.mjs` as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, let''s follow it up with code for `whatever2.mjs` as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As we can see, we needed to save the files as ESM modules, using the `mjs`
    file extension. Node.js supports ESM modules experimentally, so you need to run
    the following command in Git Bash:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Upon running the preceding command, this is the output you''ll see in the console:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As we can see, besides receiving the expected output in the console, we also
    got the `ExperimentalWarning` message. Hopefully, this demonstration of two different
    kinds of module syntaxes helps us understand what webpack will do for us. Among
    other things, it will *level the playing field*, so that we can use various standard
    and non-standard ways to work with modules in our projects.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Basically, what webpack does is, it takes our modules with dependencies (including
    our project's assets such as `.png`, `.jpeg`, and `.scss` files), and it outputs
    static assets (`.js`, `.css`, and `.image` files).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: How webpack works
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen how to use the CommonJS and ESM module syntax. Again, CommonJS is
    the syntax used for Node.js modules. This means that all the dependencies in a
    Node.js module are described using the `require` command. Contrary to this, a
    webpack module's dependency can be described in a wide variety of syntaxes. For
    example, if your module's dependency was an SCSS partial, you'd use an `@import`
    statement. If you were importing an AMD module's dependency, you'd be using it's
    own `require` and `define` syntax.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: What this means is, that basically, *webpack modules accept all the different
    syntaxes for importing various dependencies* of a module. Even the `src` attribute
    (for the `img` HTML element) is considered a webpack module's dependency.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Building a new project and running webpack on it
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now build a project and integrate webpack bundling into our workflow
    by taking the following steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a new directory. Let''s run a command that doesn''t exist as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The console will return the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Great! Now, let''s use the *repeat last command* shortcut, the double exclamation
    mark, as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Running the preceding command will create our `new-project-with-webpack` folder,
    and will `cd` into this new directory. The double ampersand command (`&&`) is
    just a way to run multiple commands one after another, rather than having to type
    them out one by one. The double exclamation mark command (`!!`) means *repeat
    the previous line*, so the preceding command actually means the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, let''s add our `package.json`, and accept all the defaults (using the
    `-y` flag) as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s inspect the contents of our folder in VS Code as follows:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once VS Code is running on our screen, we can double-click the `package.json`
    file and verify it''s contents as follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let''s add webpack to our project as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once done, let''s go back to VS Code and review our `package.json` again as
    follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As we can see, a new key has been added: `devDependencies`. Inside it, we have
    the `webpack` and the `webpack-cli` development dependencies. These `devDependencies`
    are the dependencies that you will be using only while building your project,
    and webpack is a perfect example of such a dependency: you will not need webpack
    in production. That''s why we''ve used the `--save-dev` flag when we installed
    webpack via NPM.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the file structure of our project, we can now see the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you open the `node_modules` folder, you see over 300 folders inside. This
    huge list of dependencies begins with a `.bin` folder. Contrast this with one
    of our previous examples, `vue-from-npm`, where we had only four subfolders inside
    the `node_modules` folder, even though we installed both the `vue` and `accounting-js` NPM
    packages. Note also that inside the `vue-from-npm` folder, there is no `.bin`
    folder. This is the case regardless of whether you install it with the `--save`
    or the `--save-dev` flag when running `npm install`. While this might be obvious
    to more experienced developers, it might be important for better understanding
    to those developers who do not have enough experience with Node.js and NPM ecosystem.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: So, what is this `.bin` folder? It just stores the compiled native binaries
    (that is, executable files) of a Node module that you installed using `npm install`.
    Not all NPM modules have these compiled native binaries and this is why you won't
    always see the `.bin` folder inside the `node_modules` folder. Inside this `.bin`
    folder, there are many different Node modules. These are all necessary for webpack
    to work properly.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our project, let''s now add two files to it: `index.js`, and `whatever.js` as
    follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Currently, we won't be adding any code to either of those files. Right now,
    we'll focus on running webpack in our project.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Running webpack on a project
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go back to our `new-project-with-webpack` folder, and examine the contents
    of `package.json` again, with the focus on the `scripts` key as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Use the following command in Git Bash to run `test` script:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will throw an error, with `exit code 1`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make some changes to it as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Let's run the test again with `npm run test`. This time the output in the console
    will not be as ghastly, because we removed the `exit 1` command, and we altered
    the wording of what will be echoed when running the `test` command.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try something else entirely as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we get no errors, because our `index.js` is empty. Let''s add something
    to it as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Save changes to `index.js`, run `npm run test` again, and this time the output
    in Git Bash will be number `4` printed to the screen.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: What does this tell us? It tells us that we are in complete control of what
    our scripts are going to do! So, initially we had a script that was named test.
    This script would echo out a message and throw an error with `exit code 1`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'And just as we can give our scripts any arbitrary key name, such as `test`,
    we can also give them any arbitrary value. Of course, `console.log(2+2)` is a
    silly value to give to a script key. We can give our scripts keys much better
    values, for example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, when we run an NPM script with the value of webpack, this script will
    then run the webpack executable. Let''s try it out as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This returns an error, but out of all the information that gets logged out,
    the following two lines are the most important:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The reason we got this error is because webpack looks for an entry point to
    get started on. By default, this entry point is set to `./src/index.js`. So, let''s
    add this `src` folder, and move our `index.js` into it as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let''s run webpack from the command line again as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This time we''ll get a much better output. However, there is no syntax highlighting
    in Git Bash by default. This can be fixed really fast. Since we are already using
    VS Code, simply type the keyboard shortcut of *Ctrl* + *~*. If you''re not familiar
    with this symbol, it''s called a *tilde*, and it''s located right under the *Esc*
    key, and above the *Tab* key. Pressing this keyboard shortcut will open up a terminal
    window inside VS Code, and if you execute the `npm run webpack` command again,
    you''d get nicely formatted and color highlighted output, like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3d6cb640-cf6b-4d45-8781-a79d20bdb165.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Webpack logging out information to console in VS CodeAs a side
    note, your screen''s colors might look different, depending on the color scheme
    you are using in your VS Code. To access the color themes, use the following keyboard
    shortcut: *Ctrl + K* *Ctrl + T*.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the message that was output to the console, we can see that it can
    be grouped in two sections: the one with the actual information (hash, version,
    time, built at, entrypoint, and so on) and the warning. The warning reads that
    we haven''t set the `mode` option.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'If unset, the `mode` option defaults to production. However, we can also set
    it to `development`, which is optimized for faster builds. This means that we
    can add another script in our `scripts` section of `package.json`, and this script
    can then be used for the development build of our project. This is the updated
    `scripts` section:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we can run the development mode in webpack, with the following command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here is the complete output in the console:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As we can see, it took webpack `108ms` to bundle my project in the development
    mode. When I ran it in production mode (the default `npm run webpack` command
    in my setup), it took `447ms`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'What does actually happen when we run this command? What does webpack do in
    the background? It builds a dependency graph of all the module dependencies. To
    go back to our analogy from earlier in the chapter, it''s as if we gave it a bunch
    of episodes of a TV show, recorded on a bunch of Blu-ray discs, and it takes all
    of them and lines them up properly. Webpack figures out the correct place for
    each of these modules, and then bundles them up and serves them to the `dist`
    folder. If you look at your project''s file structure again, you''ll see that
    now there''s a new addition: the `dist` folder. If we inspect the contents of
    the `dist` folder, this is what we''ll see:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If we inspect the `main.js` file, we'll see that there is a lot of stuff that
    webpack adds. Even on a tiny project like ours, the output gets to be about 100
    lines long.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'The first few lines of our `main.js` file look like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Let's run our `npm run webpack` command again to see how it will affect the
    output in `main.js`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'If we inspect `main.js`, we will see that now we have only a single line of
    code, beginning with the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: What this means is that webpack uglifies and minifies our code when run in production
    mode.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, this affects the file size too. While the bundled `main.js` file
    has the file size of 3.81 KB in development mode, when bundled in production mode,
    it has just 944 bytes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to avoid seeing the warning message, we can update our scripts entry
    in `package.json` to this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: At this point, we can start using webpack with Vue. However, we won't be using
    the Vue CLI. Instead, we'll see how to set everything up manually. This is not
    the best way to do things, but it will help us better understand why things are
    done the way they are in the Vue ecosystem.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Vue project via NPM and using webpack with it
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll build a new project with NPM, then add webpack to it,
    and finally add a Vue single file component to it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s make a new directory by taking the following steps. We''ll call
    our project `npm-vue-webpack`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Git Bash and add a new folder as follows:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Initialize `npm` as follows:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Next, install Vue and webpack into our new project as follows:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Once the NPM installation is complete, we can verify the folders and the contents
    of `package.json` as we did earlier in the chapter.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the source and output folders our project will use as follows:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Open our new project in VS Code as follows:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, we can add two new files right from the VS Code editor. We''ll call the
    first file `source.js`, and we''ll call the second file `output.js`. Make sure
    you have added and saved these two empty files in your project at this stage:
    `source.js` in the `src` folder, and `output.js` in the `dist` folder.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Adding our Vue component as a JavaScript module
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s add our Vue component:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add this code to `source.js` as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: On the first line, we're importing a file called `CustomArticle.js`.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's make a new file inside the `src` folder. We'll call this file `CustomArticle.js`.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And add the following code to it:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As we can see, we're using the ESM syntax to export and import a JS module.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Compiling JavaScript modules with webpack
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are almost ready now to compile our `source.js` to `output.js` with the
    help of webpack. However, before we do it, we still need to update the `scripts`
    section of our `package.json` as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, we can run the following command inside Git Bash:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As expected, we see the output in the console, together with the warning about
    setting the mode option. We now know what this means, so it's not important to
    deal with it at this time.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'If we inspect the contents of `output.js`, we''ll see that it''s empty, and
    that, by default, webpack minified and obfuscated our output code to the default
    `main.js` file as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: So, how do we make webpack output to a different file, other than the default
    `main.js`? We use the webpack configuration file!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Adding options with the help of the webpack configuration file
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the webpack configuration file, we can add various options to the way
    our apps get bundled with webpack. Here is how:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new file to the root of our project. We''ll call this `webpack.config.js`
    file. Here is the code:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, run our command again as follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This time it outputs to the correct file.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as we can specify the output file, we can also specify the input file as
    follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We still need to render our Vue component somewhere on the screen. We need an
    HTML file for that.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Adding an HTML file so that we can render our Vue component
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add a new HTML file, we''ll call it `index.html`, to our `dist` folder as
    follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Just as we discussed at the very beginning of this chapter, we are adding scripts
    directly to our HTML in the *old-school* way, by just stacking `script` tags at
    the bottom of our HTML file. The first `script` tag we're using is fetching Vue
    from a CDN, and the second `script` tag fetches our `output.js` file from the
    `dist` folder.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: If you're using VS Code, you can now right-click on your new `dist/index.html`
    file, and click the Open in default browser command.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the following sentence on the web page that opens:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Our own custom article component!
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to give webpack the ability to output an HTML file. For that, we'll
    need to use the `html-webpack-plugin`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Giving webpack the ability to output an HTML file
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll see how to output an HTML file using a webpack plugin
    by taking the following steps:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `html-webpack-plugin` via NPM as follows:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Our `devDependencies` of `package.json` have updated accordingly as follows:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, update our `webpack.config.js`, as follows:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Before we continue, delete the `index.html` file that we had in our `dist` folder.
    Don't worry about deleting it, though, since webpack will soon recreate it.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, let''s run the webpack script again as follows:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Webpack just created a new `index.html` file for us! Here''s the contents of
    the file:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This is all great, but obviously, our file is not the same. We have lost our
    entry point for the Vue component we had. Also, we need to update our Vue code
    so that it works as a single file component.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Adding a .vue file as a JavaScript module
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s update the `source.js` file, to the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We can now also rename our `CustomArticle.js` to `CustomArticle.vue`, and add
    the following code to it:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Unfortunately, webpack doesn't work with `.vue` files out of the box. To fix
    the issue at hand, we need to use a **webpack loader**. A webpack loader helps
    webpack understand the files it's working with. There are many loaders out there,
    but for now, we need to work with Vue.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Adding a webpack loader to work with .vue files
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To work with `.vue` files, take the following steps:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'Install a webpack loader called `vue-loader` via NPM as follows:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now that we''ve saved it, we need to use it, and we''ll do that by updating
    the webpack configuration as follows:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Try running webpack now as follows. Spoiler alert: it will fail:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The error message we get reads as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'To fix this error, we need to add a rule for our Vue loader, by updating our
    `webpack.config.js` file to the following:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `test` key inside the array in the `rules` option receives a regex as a
    value. This regex is checking for the presence of a file with a `vue` file extension.
    If it matches, that is, if it finds a `vue` file, it will use the `vue-loader`
    module on it.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run our webpack script again as follows:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This will throw another error as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'There are more errors logged out to the console, but this is the one that we
    need to fix by adding another NPM package, as follows:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `devDependencies` entry inside `package.json` just received another update, as
    follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'So, now we can run webpack again as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: After webpack ran, if you opened `output.js` at this time, you'll see that it
    has the full Vue library inside of it, along with our `CustomArticle` at the very
    end. This all compiled without any errors.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the issue with our index.html file
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We still have the issue of the `index.html` file in the `dist` folder. It''s
    an easy fix! We''ll just add our own `index.html` file to the `src` folder, with
    the following contents:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Note that we have now removed our own `script` tags, since webpack will be
    adding them. Also, make sure to delete the `index.html` file inside the `dist`
    folder. Now, run the `npm run webpack` command again, and you''ll get this output
    in `dist/index.html` as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Why is this not working?
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: It is not working because we need to update both the JS files to be output,
    as well as the HTML files. Currently, we are only updating the JS files, but we
    still need to do it for our `index.html` file. Luckily, we already have `html-webpack-plugin`
    to help out.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Delivering HTML files via webpack with the help of html-webpack-plugin
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll begin by updating the `html-webpack-plugin` in the `webpack.config.js`
    file as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'What we did in the plugins section was, we passed an `options` object to our
    `HtmlWebpackPlugin()` call. Inside this `options` object, we specified our template:
    `./src/index.html`.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Before we run the webpack script again, we need to make sure to add the `meta`
    tag with `charset` set to `utf-8`. Otherwise, we'll get an error in our console
    when we open `dist/index.html` in the browser.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now run `npm run webpack` again. This time, everything works! We get
    our humble looking sentence on the screen:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Our own custom article component!
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! Although it is humble looking, you have successfully added
    a Vue app to an NPM-powered project, running on webpack.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll learn about HMR, and how it helps us in our Vue development.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Hot Module Replacement in Vue
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HMR has become a sort of a buzzword in the past couple of years. What's the
    big deal? In this section, we'll discuss how HMR works.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we''ll build another default simple app, just like we did in [Chapter
    1](081bc26f-96a8-4cb0-8e73-d7c6e67f409b.xhtml), *Introducing Vue CLI 3, *as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'After a while, once it''s done, we''ll go into our app''s directory as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Let''s open the project''s folder in VS Code as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Now, we can see the entire contents of our `second-default-project`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can serve the app as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Of course, our app is now serving in our browser.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: To view your app, visit `localhost:8080` in your browser.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at HMR updates happening in real time.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Observing HMR updates
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the browser window is active, let''s press the *F12* key to turn on the
    developer tools. Let''s also make sure that our the Elements panel is the active
    tab inside the dev tools, so that we can see the **Document Object Model** (**DOM**)
    structure, like in the following zoomed-in screenshot from the browser:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/555e8cdc-a628-43eb-870d-45c51239a104.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: The welcome screen of second-default-app with the Elements panel
    open in dev tools'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see HMR in action. Ideally, to see this in action, you'd need to
    use two monitors. Thus, you could, for example, move your VS Code window to the
    left monitor, and your browser with the app served to the right monitor. Alternatively,
    you can use a single monitor and view both apps side by side (with each one taking
    up half the screen width). The point of this exercise is to be able to see at
    the same time your VS Code window, your Vue app browser window, and your Elements
    panel inside your browser's dev tools.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, inside VS Code, open the `App.vue` file (inside the `src` folder of your
    project). Look at line 4, which currently reads as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We'll soon change that line to something else. Before you change the line, pay
    attention to how these changes reflect in the browser serving your app. Will the
    browser refresh?
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you''re focused on tracking changes in browser, let''s update line
    4 in `App.vue` as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Pay attention to the browser while you're saving changes to `App.vue` in VS
    Code. The best way to do this is to have VS Code in focus, but watch the browser
    window, specifically the Elements panel. With VS Code in focus, you can save changes
    with the shortcut key *Ctrl* + *S*.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: If you pay close attention, and if you're using Chrome, you'll notice a flash
    of purple color inside the Elements panel. That's the Chrome browser notifying
    us of the changes that happened to the DOM of our Vue app. If you pay close attention,
    you'll notice that there is a flash on the `head` element, as well as the `h1`
    element and it's child text node, `HMR is cool`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Also, you might notice that there was no refresh on the browser. Neither webpack,
    our app's code, or we ourselves forced the browser to refresh. What's the conclusion
    here? Webpack is actually not forcing a page refresh with HMR! Instead, it just
    injects an HMR.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'While the change on the `h1` element is obvious (as it is the immediately visible
    consequence of us changing the text inside the `App.vue` file), the update that
    happens in the `head` element is both more obscure and more helpful. To see what
    is happening, let''s twirl open the head tag by clicking on the little black triangle
    to the left of the `head` tag inside the Elements panel, as shown in the following
    screenshot:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/495be8e0-9fbb-415a-ac5e-e73a101235f3.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Twirl-open the head tag inside Elements panel in dev tools'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll need to scroll all the way down to the closing `</head>` tag.
    Right above it, there will be a `script` tag that reads something similar to this:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Let''s keep close attention on this section of the DOM tree in the Elements
    panel, while we make another change to `App.vue`. Let''s update our `msg` attribute
    on line 4 to this:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'If you observed the `script` tag, you''ll notice it change as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Did you notice that Vue injected another script above the closing `</head>`
    tag? That injected script is HMR in action, right there.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s inspect the very first line of the appended script file as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: How does this whole process work? Webpack simply runs our changes, bundles an
    update to our app, and, since it is already running, injects the new code using
    Vue loader.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: So, as we've just seen, HMR is just a feature of webpack that helps us do things
    more smoothly, without the need to worry about refreshing our apps.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we discussed the evolution of the JS language and its ecosystem,
    and how this evolution lead to the appearance of module bundlers. We also looked
    at webpack, the module bundler of choice of Vue CLI 3.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: We looked at how to plug in a very basic Vue-powered app, running on single
    file Vue templates. Alongside this mini-project, we also looked at a number of
    important webpack concepts. We finished the chapter by observing HMR on a Vue
    project.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the very basics of how webpack works, in the chapters that
    follow, we'll discuss some other related technologies and we'll build on our knowledge
    of webpack and Vue CLI 3\. The next topic we'll be closely examining is Babel.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
