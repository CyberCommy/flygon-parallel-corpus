- en: Webpack in Vue CLI 3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue CLI 3中的Webpack
- en: 'In the previous chapter, we saw how to start using Vue CLI via both the command
    line and the UI. In this chapter, we will cover webpack basics from the viewpoint
    of Vue CLI 3\. We will begin with an overview of what webpack is. We''ll look
    at concepts behind module bundling, tree shaking, webpack loaders and output,
    webpack plugins, **Hot Module Replacement** (**HMR**), code coverage and code
    splitting, and then we''ll look at how these concepts fit in with Vue CLI 3 as
    follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何通过命令行和UI开始使用Vue CLI。在本章中，我们将从Vue CLI 3的角度介绍webpack的基础知识。我们将首先概述webpack是什么。我们将研究模块捆绑、摇树、webpack加载器和输出、webpack插件、**热模块替换**（**HMR**）、代码覆盖和代码拆分的概念，然后我们将看看这些概念如何与Vue
    CLI 3配合，如下所示：
- en: The evolution of the **JavaScript** (**JS**) language from the script tag to
    module bundlers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从脚本标签到模块捆绑器的JavaScript（JS）语言的演变
- en: The script tag
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本标签
- en: '**Immediately Invoked Function Expressions** (**IIFEs**), what problems they
    solve, and what problems they don''t'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**立即调用函数表达式**（**IIFEs**），它们解决了什么问题，以及它们没有解决的问题'
- en: How **Node Package Manager** (**NPM**) helps teams share third-party libraries
    in their code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node Package Manager** (**NPM**)如何帮助团队在他们的代码中共享第三方库'
- en: The role of JS task runners and NPM scripts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JS任务运行器和NPM脚本的作用
- en: What the CommonJS specification is and how modules work in JavaScript and Node.js
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CommonJS规范是什么，以及它如何在JavaScript和Node.js中工作
- en: What module bundlers are and how they bridge the gap between Node.js and the
    browser
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块捆绑器是什么，以及它们如何弥合Node.js和浏览器之间的差距
- en: What webpack, and how it works
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: webpack是什么，以及它是如何工作的
- en: How to run webpack on a project
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在项目中运行webpack
- en: Bundling assets with webpack using production and development modes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生产和开发模式使用webpack捆绑资产
- en: Adding a Vue project via NPM and using webpack with it
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过NPM添加Vue项目并使用webpack
- en: Understanding exactly how webpack works is crucial to understanding the magic
    that Vue CLI 3 performs. If you are familiar with webpack, you still might find
    some sections of this chapter useful. If you feel you are a webpack pro, you can
    probably just skip this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 准确理解webpack的工作原理对于理解Vue CLI 3的魔力至关重要。如果您熟悉webpack，您可能仍然会发现本章的某些部分有用。如果您觉得自己是webpack专家，您可能可以直接跳过本章。
- en: Before getting into what is webpack and to properly understand the issues that
    webpack solves, we need to look back at a bit of history of changes that happened
    to the JS language in the last decade.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解webpack是什么以及正确理解webpack解决的问题之前，我们需要回顾一下过去十年中JS语言发生的一些变化。
- en: The evolution of the JS language
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JS语言的演变
- en: 'Looking from the vantage point of webpack, here is the chronological list of
    approaches, techniques, best practices, and patterns that were added to the JS
    ecosystem, which led to the current state of things:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从webpack的角度来看，以下是JS生态系统中添加的方法、技术、最佳实践和模式的时间顺序列表，这些方法、技术、最佳实践和模式导致了当前的状态：
- en: The `script` tag as the answer to adding interactivity to web pages
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`script`标签作为向网页添加交互性的答案'
- en: Immediately invoked function expressions as the answer to modularizing libraries
    and avoiding code collisions
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即调用函数表达式作为模块化库和避免代码冲突的答案
- en: The problem with IIFEs
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IIFEs的问题
- en: Sharing third-party libraries in a team environment with NPM
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NPM在团队环境中共享第三方库
- en: JS task runners and NPM scripts
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JS任务运行器和NPM脚本
- en: Modules in JS
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JS中的模块
- en: Let's look at each one of these solutions in more detail.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些解决方案中的每一个。
- en: The script tag
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本标签
- en: Initially, adding JS to your web page meant that you would need to add some
    `script` tags directly in your HTML. For quick prototypes, this is still a valid
    way of doing things even to this day. Very often, third-party libraries get added
    via the `src` attribute inside a `script` tag (which usually gets placed right
    above the closing `body` tag in our HTML).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, you usually need more than one `script` tag inside your HTML.
    And regardless of whether you add your JS code directly to your page, you add
    it from another file in your project, or you add it from a remote location (such
    as from a **content delivery network** (**CDN**) using the `src` attribute), ultimately,
    all these scripts are added to the global JS scope. This means one thing, collision.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: To avoid collisions, a clever approach was taken, the use of IIFEs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Immediately Invoked Function Expressions
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are IIFEs all about? IIFEs simply exploit the fact that in JS, *parentheses
    can't contain statements*. This fact alone allowed JS developers to put in anonymous
    functions that they could immediately invoke, without getting any errors from
    the parser, by simply wrapping them in parentheses.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: An IIFE is essentially a quirk of the JS language, but a very useful one; with
    an IIFE, all the code is scoped to the function, and thus your code is safe from
    anything else that is outside of it. In other words, using IIFEs is a simple way
    to avoid collisions, that is, the accidental overwriting of variables or functions.
    Thus, at one point, many popular libraries started wrapping their own code into
    IIFEs. For example, if you open the code for the jQuery library ([https://code.jquery.com](https://code.jquery.com)),
    or for the Chart.js library ([https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.3/Chart.bundle.js](https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.3/Chart.bundle.js)),
    or for many other popular JS libraries, you'd find that they use the IIFE pattern.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Thus, with IIFEs, we could add different scripts to our pages, without the worry
    that code collisions might happen.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The problem with IIFEs
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unfortunately, simply using IIFEs does not fix all our problems. To illustrate
    the issue at hand, let''s quote Joe Armstrong, creator of Erlang:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '"You wanted a banana, but what you got is the gorilla holding the banana, and
    the entire jungle."'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that in this quote, Mr. Armstrong was discussing a problem with
    object-oriented languages, but the underlying issue is applicable in JS code modularization.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Basically, our problem with IIFEs is that we can't cherry-pick specific functionality
    that we'd like to use from a JS library. With the IIFE pattern, we *must* use
    everything that is wrapped up in an IIFE, even if we are only using just a small
    piece of a specific library's codebase. Of course, to be honest, IIFEs are not
    the ones to blame for this. JS, the language, for a long time simply did not have
    the ability to cherry-pick any kind of code functionality, because in JS, it was
    simply impossible to split your code into modules.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Another major pain point of JS was the issue of reusing third-party code across
    teams.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Sharing third-party libraries in a team environment with NPM
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IIFEs solved the problem of code collisions, but they didn't solve the problem
    of code reuse. What if a developer on my team has a different, updated version
    of a library, with breaking changes? What if I decide to update the dependencies
    on my computer? How will my other team members deal with that? Besides using source
    version control, are there any other options for faster collaboration?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '**Node Package Manager** (**NPM**) was the answer to these problems. Node is
    just a Google V8 JS engine that can run on a server. NPM simply allows a developer
    to install new libraries into a project, regardless of whether it is to be used
    on the frontend or the backend of an app. So, effectively, NPM is the JS package
    manager, similar to what we have in Ruby (gems ([https://rubygems.org/](https://rubygems.org/))),
    C# (NuGet ([https://www.nuget.org/](https://www.nuget.org/))), or in Linux (`apt-get`,
    `yum`).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's say we wanted to install Vue via NPM. If we have Node installed
    on our machine, we'll have NPM too, since NPM comes bundled with a Node installation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create a new directory. Let''s change this directory''s name
    to `vue-from-npm`, and point our command-line console to it. We can then follow
    it up with this command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Running the preceding command will create a `package.json` file. The `-y` flag
    accepts all the default answers that you'd be prompted with in the console.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'If we looked at the newly created `package.json` file inside our project directory,
    we''d see the following contents:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that the `npm init` command only adds a `package.json` file to an empty
    directory. That's all that it does!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding Vue is then as simple as running this command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding command will do a few things, namely:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: It will add the `node_modules` directory.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will put the entire Vue library inside the `node_modules` directory.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will create the `package-lock.json` file in the root of our project.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will update the `package.json` file in the root of our project.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The updated `package.json` file now looks like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If it is not obvious, the file has been updated with a new entry: `dependencies`.
    This entry lists all the dependencies included in the project. Specifically, we
    have added Vue (version 2.6.7 or above) to our project.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'A great thing about NPM is that we can add any other library to our project,
    just as easily as we did with Vue. For example, to update our project with accounting.js,
    we just run this command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once the installation is complete, let''s again inspect the `node_modules`
    directory as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that for the sake of brevity, we are only showing the second level of folders
    and files inside the `accounting-js` folder. The `is-string`, `object-assign`,
    and `vue` folders are shown collapsed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'What this shows us is that sometimes other NPM modules come bundled with the
    actual libraries that we installed. In the case of `accounting-js`, we also got
    the `is-string` and `object-assign` NPM modules. Let''s also inspect the updated
    `package.json` file in the root of our directory as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we can see, the root `package.json` file has been updated with the proper
    version of `accounting-js`. Let's locate another `package.json` file, this time
    inside the `node_modules/accounting-js` folder. If you opened that file, it holds
    a lot more information, in just a bit over 100 lines of code. This information
    is specific to the actual NPM module, `accounting-js`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: OK, so now our project is ready for collaboration. The way to do it? Let's see
    how a colleague of ours, let's call him `John`, would add the project we just
    created, and all the project dependencies, on his own computer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we'll create a new folder, let's call it `johns-computer`, and let's
    just copy the root level `package.json` from our `vue-from-npm` folder into our
    `johns-computer` folder.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s simply run this command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Running the preceding command will install all the projects and dependencies
    that we had in the `vue-from-npm` folder.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript task runners and NPM scripts
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Around the same time during which NPM was gaining popularity, another frontend
    technology was also on the rise: task runners. Task runners are simple tools;
    they run repetitive tasks. Sometimes, task runners are referred to as build tools
    because they act as intermediaries between updates that a developer makes to a
    codebase, and what the production ready code ends up being. This is what''s known
    as a *build step*, a part of the software development process in which something
    happens to your code *after* you''ve written it.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, new features that get added to CSS3 usually start off as *vendor
    prefixes* (also known as *browser prefixes*). In other words, before a new CSS
    functionality is available in all browsers, it gets implemented in an experimental
    stage in individual browsers, using browser-specific prefixes as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this alphabetically ordered list of browser prefixes, we can see browser
    prefixes for Microsoft browsers, Mozilla, old versions of Opera, and finally,
    all the webkit-based browsers (Chrome, Safari, newer Opera, and so on).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping track of updates to browser prefixes is kind of difficult. It is probably
    not the best use of a developer''s time to monitor for changes to CSS implementations,
    and then update their code accordingly. For example, at a certain point in the
    past, it was necessary to use the following browser prefixes on the CSS `transition`
    property:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Obviously, today we simply use the `transition` property in our CSS declarations,
    without any browser prefixes, because the `transition` property is widely supported
    in all modern browsers.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Having to deal with the constantly shifting landscape of changes to the CSS
    specification and its implementations in various browsers led to a solution in
    the form of a task runner. Instead of having to manually add vendor prefixes to
    their CSS code, frontend developers could now simply add a plugin to their task
    runner and it would do the dirty work for them: add vendor prefixes where needed.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, what we saw previously was just one example of what task runners
    are used for. Some other examples include: minifying CSS and JS files, transpiling
    from ES6 to ES5, compiling CSS from SASS, removing unused CSS, reloading the browser
    whenever a file is saved in your project, and so on.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, there are a number of different tools that help us to effectively automate
    some tasks in our development process. Three tools stand out: Grunt, Gulp, and
    NPM scripts.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'While Grunt and Gulp are standalone task runners that you can install via NPM,
    NPM scripts are an interesting alternative for the following few reasons:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: You are using NPM anyway, so why not get more familiar with a tool you are already
    using?
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using NPM scripts instead of the aforementioned task runners will streamline
    your development further.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using NPM, you avoid the complexity of having to use a task runner plugin
    for tasks that can be automated straight in NPM.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Up until this point, we've looked back at the history and the evolution of the
    JS ecosystem. We've seen how IIFEs were used to take care of accidental scope
    leaks. We've also seen how NPM takes care of code sharing. We've further looked
    at how some repetitive tasks can be automated with the help of task runners, and
    how NPM can be used to remove an unnecessary layer of abstraction by keeping our
    tasks inside NPM scripts.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: However, we still haven't looked at ways to solve the problem of code modularization
    in JS. So, let's look at that next.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Modules in JavaScript
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any programming language, a module is a self-contained piece of functionality. You
    can think of them as different episodes of a TV show. They can be looked at independently.
    They can stand on their own, although they are a part of a greater whole.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: And just like an episode in a TV show has a season and a number, so that we
    know *where it fits* in the bigger plot, a module also holds the information that
    tells us what other modules it relies on (the *module dependencies*), and what
    functionality it adds to the entire app; this is what's known as a *module's interface*,
    the API that's exposed to other modules.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: We've seen how in the beginning, JS did not have modules at all. This changed
    with the introduction of Node.js. Node.js is actually an implementation of CommonJS,
    a project that was started in 2009 by Mozilla's Kevin Dangoor.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'CommonJS project''s purpose was to define a standard library that would provide
    JS APIs to be used outside of the browser. This included a module specification,
    which resulted in developers being able to use code like this in Node.js:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Working with modules in Node.js
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s require and use some modules in Node.js:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: To begin, we'll create a new directory. Let's call it `module-practice`. Let's
    point our Git Bash to this folder.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once inside it, let''s create two new files. Let''s call these files `main.js`
    and `whatever.js` as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, let''s open this entire folder in VS Code as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s add some code to `whatever.js` as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is as simple as a piece of code in JS can get.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see how can we make it available in our `main.js` file. We''ll just
    need to require `whatever.js` as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that it is required, we can use it, so let''s update `main.js` to this:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s now run this code with the following:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What will happen now is, we will see the word `whatever` printed inside Git
    Bash.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take our experiment a step further. Here''s our updated `whatever.js`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Consequently, we need to update `main.js` too as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we have already seen, the `require` keyword imports a module's code and makes
    it available in another file; in our example, the `main.js` file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'The `exports` keyword lets us make the code available to other files, with
    one caveat. It also allows us to choose what parts of our module we want to make
    available to other files. As we see, the `module.exports` is an object. The contents
    of this object is what will be returned when our `whatever` module is required
    by `main.js`. This allows us to expose only certain sections of our code, and
    enables the setup of a module''s interface. In other words, `module.exports` is
    what enables us to keep parts of our code private. Consider this update to `whatever.js`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We don't need to make any changes to `main.js`. If we ran it from Git Bash,
    we'd still get the word `whatever` output to console. But we have made parts of
    `whatever.js` not directly accessible.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, notice that in the preceding code, the function syntax of ES3
    and ES5 are used alongside one another. The section of code that defines the `returnSomething`
    function is using newer syntax, which lets us write function definitions without
    having to use the `function` keyword.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Module bundlers, a way to use modules in the browser
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, you can't just use the `require` keyword, as we just saw, straight
    in the browser. The `require` keyword is not a part of JS's browser API. It is
    important to note here that Node.js has the ability to read from and to the filesystem
    of your computer. Thus, if you installed any NPM package in a project, using Node.js,
    you would be able to require such a module as explained previously.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'However, JS in the browser does not have access to the file system of your
    OS, and thus this leaves us with a conundrum: how do we use the JS module syntax
    inside the browser?'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer: we have a tool for that, and it''s called a **module bundler**.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Today, in 2019, there are a number of different module bundlers available, such
    as webpack ([http://webpack.github.io/](http://webpack.github.io/)), FuseBox ([https://fuse-box.org/](https://fuse-box.org/)),
    Parcel ([https://parceljs.org/](https://parceljs.org/)), rollup.js ([https://rollupjs.org/guide/en](https://rollupjs.org/guide/en)),
    or Browserify ([http://browserify.org/](http://browserify.org/)).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'What is a module bundler? Here is a quote from the Browserify home page, which
    puts it succinctly:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '"Browserify lets you require (''modules'') in the browser by bundling up all
    of your dependencies."'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Besides bundling all the dependencies that get required through modules in your
    project, module bundlers also solve issues such as cyclical dependencies; that
    is, they use algorithms that resolve the order in which all the project's dependencies
    should be bundled in your project.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: We have almost finished our overview of the JS ecosystem. Next, we'll look at
    one particular flavor of a module bundler, and that is webpack.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Once we know just what exactly webpack is and how it works under the hood, we'll
    be able to fully comprehend where it fits within Vue CLI.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: What is webpack?
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Webpack is a module bundler for the web. Some people also refer to it as an
    asset compiler for web applications.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'According to webpack''s GitHub page:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '"It packs many modules into a few bundled assets and so on. Modules can be
    CommonJs, AMD, ES6 modules, CSS, images, JSON, CoffeeScript, LESS, and so on,
    and your custom stuff."'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in this chapter, in the section titled *Working with modules in Node.js*,
    we barely scratched the surface of how modules get exported and required in Node
    apps. What we did not mention is that there are all kinds of different module
    syntaxes that we can use. As already mentioned, Node.js works with the CommonJS
    module syntax. Besides CommonJS, there is also **Asynchronous Module Definition**
    (**AMD**). Alongside AMD, you can use ESM modules. With ESM modules, the syntax
    is a bit different from what we saw earlier.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite the `whatever` module using ESM syntax by taking the following
    steps, and use it in `main.js`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep things easy, let''s also create a new folder as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s point our Git Bash by using the `cd` command (the *change directory*
    command) as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s add our two files as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s open our folder with VS Code as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, let''s add the code for `main2.mjs` as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, let''s follow it up with code for `whatever2.mjs` as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As we can see, we needed to save the files as ESM modules, using the `mjs`
    file extension. Node.js supports ESM modules experimentally, so you need to run
    the following command in Git Bash:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Upon running the preceding command, this is the output you''ll see in the console:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As we can see, besides receiving the expected output in the console, we also
    got the `ExperimentalWarning` message. Hopefully, this demonstration of two different
    kinds of module syntaxes helps us understand what webpack will do for us. Among
    other things, it will *level the playing field*, so that we can use various standard
    and non-standard ways to work with modules in our projects.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Basically, what webpack does is, it takes our modules with dependencies (including
    our project's assets such as `.png`, `.jpeg`, and `.scss` files), and it outputs
    static assets (`.js`, `.css`, and `.image` files).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: How webpack works
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen how to use the CommonJS and ESM module syntax. Again, CommonJS is
    the syntax used for Node.js modules. This means that all the dependencies in a
    Node.js module are described using the `require` command. Contrary to this, a
    webpack module's dependency can be described in a wide variety of syntaxes. For
    example, if your module's dependency was an SCSS partial, you'd use an `@import`
    statement. If you were importing an AMD module's dependency, you'd be using it's
    own `require` and `define` syntax.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: What this means is, that basically, *webpack modules accept all the different
    syntaxes for importing various dependencies* of a module. Even the `src` attribute
    (for the `img` HTML element) is considered a webpack module's dependency.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Building a new project and running webpack on it
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now build a project and integrate webpack bundling into our workflow
    by taking the following steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a new directory. Let''s run a command that doesn''t exist as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The console will return the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Great! Now, let''s use the *repeat last command* shortcut, the double exclamation
    mark, as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Running the preceding command will create our `new-project-with-webpack` folder,
    and will `cd` into this new directory. The double ampersand command (`&&`) is
    just a way to run multiple commands one after another, rather than having to type
    them out one by one. The double exclamation mark command (`!!`) means *repeat
    the previous line*, so the preceding command actually means the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, let''s add our `package.json`, and accept all the defaults (using the
    `-y` flag) as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s inspect the contents of our folder in VS Code as follows:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once VS Code is running on our screen, we can double-click the `package.json`
    file and verify it''s contents as follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let''s add webpack to our project as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once done, let''s go back to VS Code and review our `package.json` again as
    follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As we can see, a new key has been added: `devDependencies`. Inside it, we have
    the `webpack` and the `webpack-cli` development dependencies. These `devDependencies`
    are the dependencies that you will be using only while building your project,
    and webpack is a perfect example of such a dependency: you will not need webpack
    in production. That''s why we''ve used the `--save-dev` flag when we installed
    webpack via NPM.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the file structure of our project, we can now see the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you open the `node_modules` folder, you see over 300 folders inside. This
    huge list of dependencies begins with a `.bin` folder. Contrast this with one
    of our previous examples, `vue-from-npm`, where we had only four subfolders inside
    the `node_modules` folder, even though we installed both the `vue` and `accounting-js` NPM
    packages. Note also that inside the `vue-from-npm` folder, there is no `.bin`
    folder. This is the case regardless of whether you install it with the `--save`
    or the `--save-dev` flag when running `npm install`. While this might be obvious
    to more experienced developers, it might be important for better understanding
    to those developers who do not have enough experience with Node.js and NPM ecosystem.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: So, what is this `.bin` folder? It just stores the compiled native binaries
    (that is, executable files) of a Node module that you installed using `npm install`.
    Not all NPM modules have these compiled native binaries and this is why you won't
    always see the `.bin` folder inside the `node_modules` folder. Inside this `.bin`
    folder, there are many different Node modules. These are all necessary for webpack
    to work properly.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our project, let''s now add two files to it: `index.js`, and `whatever.js` as
    follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Currently, we won't be adding any code to either of those files. Right now,
    we'll focus on running webpack in our project.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Running webpack on a project
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go back to our `new-project-with-webpack` folder, and examine the contents
    of `package.json` again, with the focus on the `scripts` key as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Use the following command in Git Bash to run `test` script:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will throw an error, with `exit code 1`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make some changes to it as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Let's run the test again with `npm run test`. This time the output in the console
    will not be as ghastly, because we removed the `exit 1` command, and we altered
    the wording of what will be echoed when running the `test` command.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try something else entirely as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we get no errors, because our `index.js` is empty. Let''s add something
    to it as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Save changes to `index.js`, run `npm run test` again, and this time the output
    in Git Bash will be number `4` printed to the screen.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: What does this tell us? It tells us that we are in complete control of what
    our scripts are going to do! So, initially we had a script that was named test.
    This script would echo out a message and throw an error with `exit code 1`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'And just as we can give our scripts any arbitrary key name, such as `test`,
    we can also give them any arbitrary value. Of course, `console.log(2+2)` is a
    silly value to give to a script key. We can give our scripts keys much better
    values, for example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, when we run an NPM script with the value of webpack, this script will
    then run the webpack executable. Let''s try it out as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This returns an error, but out of all the information that gets logged out,
    the following two lines are the most important:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The reason we got this error is because webpack looks for an entry point to
    get started on. By default, this entry point is set to `./src/index.js`. So, let''s
    add this `src` folder, and move our `index.js` into it as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let''s run webpack from the command line again as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This time we''ll get a much better output. However, there is no syntax highlighting
    in Git Bash by default. This can be fixed really fast. Since we are already using
    VS Code, simply type the keyboard shortcut of *Ctrl* + *~*. If you''re not familiar
    with this symbol, it''s called a *tilde*, and it''s located right under the *Esc*
    key, and above the *Tab* key. Pressing this keyboard shortcut will open up a terminal
    window inside VS Code, and if you execute the `npm run webpack` command again,
    you''d get nicely formatted and color highlighted output, like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3d6cb640-cf6b-4d45-8781-a79d20bdb165.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Webpack logging out information to console in VS CodeAs a side
    note, your screen''s colors might look different, depending on the color scheme
    you are using in your VS Code. To access the color themes, use the following keyboard
    shortcut: *Ctrl + K* *Ctrl + T*.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the message that was output to the console, we can see that it can
    be grouped in two sections: the one with the actual information (hash, version,
    time, built at, entrypoint, and so on) and the warning. The warning reads that
    we haven''t set the `mode` option.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'If unset, the `mode` option defaults to production. However, we can also set
    it to `development`, which is optimized for faster builds. This means that we
    can add another script in our `scripts` section of `package.json`, and this script
    can then be used for the development build of our project. This is the updated
    `scripts` section:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we can run the development mode in webpack, with the following command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here is the complete output in the console:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As we can see, it took webpack `108ms` to bundle my project in the development
    mode. When I ran it in production mode (the default `npm run webpack` command
    in my setup), it took `447ms`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'What does actually happen when we run this command? What does webpack do in
    the background? It builds a dependency graph of all the module dependencies. To
    go back to our analogy from earlier in the chapter, it''s as if we gave it a bunch
    of episodes of a TV show, recorded on a bunch of Blu-ray discs, and it takes all
    of them and lines them up properly. Webpack figures out the correct place for
    each of these modules, and then bundles them up and serves them to the `dist`
    folder. If you look at your project''s file structure again, you''ll see that
    now there''s a new addition: the `dist` folder. If we inspect the contents of
    the `dist` folder, this is what we''ll see:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If we inspect the `main.js` file, we'll see that there is a lot of stuff that
    webpack adds. Even on a tiny project like ours, the output gets to be about 100
    lines long.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'The first few lines of our `main.js` file look like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Let's run our `npm run webpack` command again to see how it will affect the
    output in `main.js`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'If we inspect `main.js`, we will see that now we have only a single line of
    code, beginning with the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: What this means is that webpack uglifies and minifies our code when run in production
    mode.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, this affects the file size too. While the bundled `main.js` file
    has the file size of 3.81 KB in development mode, when bundled in production mode,
    it has just 944 bytes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to avoid seeing the warning message, we can update our scripts entry
    in `package.json` to this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: At this point, we can start using webpack with Vue. However, we won't be using
    the Vue CLI. Instead, we'll see how to set everything up manually. This is not
    the best way to do things, but it will help us better understand why things are
    done the way they are in the Vue ecosystem.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Vue project via NPM and using webpack with it
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll build a new project with NPM, then add webpack to it,
    and finally add a Vue single file component to it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s make a new directory by taking the following steps. We''ll call
    our project `npm-vue-webpack`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Git Bash and add a new folder as follows:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Initialize `npm` as follows:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Next, install Vue and webpack into our new project as follows:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Once the NPM installation is complete, we can verify the folders and the contents
    of `package.json` as we did earlier in the chapter.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the source and output folders our project will use as follows:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Open our new project in VS Code as follows:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, we can add two new files right from the VS Code editor. We''ll call the
    first file `source.js`, and we''ll call the second file `output.js`. Make sure
    you have added and saved these two empty files in your project at this stage:
    `source.js` in the `src` folder, and `output.js` in the `dist` folder.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Adding our Vue component as a JavaScript module
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s add our Vue component:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add this code to `source.js` as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: On the first line, we're importing a file called `CustomArticle.js`.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's make a new file inside the `src` folder. We'll call this file `CustomArticle.js`.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And add the following code to it:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As we can see, we're using the ESM syntax to export and import a JS module.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Compiling JavaScript modules with webpack
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are almost ready now to compile our `source.js` to `output.js` with the
    help of webpack. However, before we do it, we still need to update the `scripts`
    section of our `package.json` as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, we can run the following command inside Git Bash:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As expected, we see the output in the console, together with the warning about
    setting the mode option. We now know what this means, so it's not important to
    deal with it at this time.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'If we inspect the contents of `output.js`, we''ll see that it''s empty, and
    that, by default, webpack minified and obfuscated our output code to the default
    `main.js` file as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: So, how do we make webpack output to a different file, other than the default
    `main.js`? We use the webpack configuration file!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Adding options with the help of the webpack configuration file
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the webpack configuration file, we can add various options to the way
    our apps get bundled with webpack. Here is how:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new file to the root of our project. We''ll call this `webpack.config.js`
    file. Here is the code:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, run our command again as follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This time it outputs to the correct file.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as we can specify the output file, we can also specify the input file as
    follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We still need to render our Vue component somewhere on the screen. We need an
    HTML file for that.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Adding an HTML file so that we can render our Vue component
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add a new HTML file, we''ll call it `index.html`, to our `dist` folder as
    follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Just as we discussed at the very beginning of this chapter, we are adding scripts
    directly to our HTML in the *old-school* way, by just stacking `script` tags at
    the bottom of our HTML file. The first `script` tag we're using is fetching Vue
    from a CDN, and the second `script` tag fetches our `output.js` file from the
    `dist` folder.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: If you're using VS Code, you can now right-click on your new `dist/index.html`
    file, and click the Open in default browser command.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the following sentence on the web page that opens:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Our own custom article component!
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to give webpack the ability to output an HTML file. For that, we'll
    need to use the `html-webpack-plugin`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Giving webpack the ability to output an HTML file
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll see how to output an HTML file using a webpack plugin
    by taking the following steps:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `html-webpack-plugin` via NPM as follows:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Our `devDependencies` of `package.json` have updated accordingly as follows:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, update our `webpack.config.js`, as follows:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Before we continue, delete the `index.html` file that we had in our `dist` folder.
    Don't worry about deleting it, though, since webpack will soon recreate it.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, let''s run the webpack script again as follows:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Webpack just created a new `index.html` file for us! Here''s the contents of
    the file:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This is all great, but obviously, our file is not the same. We have lost our
    entry point for the Vue component we had. Also, we need to update our Vue code
    so that it works as a single file component.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Adding a .vue file as a JavaScript module
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s update the `source.js` file, to the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We can now also rename our `CustomArticle.js` to `CustomArticle.vue`, and add
    the following code to it:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Unfortunately, webpack doesn't work with `.vue` files out of the box. To fix
    the issue at hand, we need to use a **webpack loader**. A webpack loader helps
    webpack understand the files it's working with. There are many loaders out there,
    but for now, we need to work with Vue.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Adding a webpack loader to work with .vue files
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To work with `.vue` files, take the following steps:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'Install a webpack loader called `vue-loader` via NPM as follows:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now that we''ve saved it, we need to use it, and we''ll do that by updating
    the webpack configuration as follows:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Try running webpack now as follows. Spoiler alert: it will fail:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The error message we get reads as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'To fix this error, we need to add a rule for our Vue loader, by updating our
    `webpack.config.js` file to the following:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `test` key inside the array in the `rules` option receives a regex as a
    value. This regex is checking for the presence of a file with a `vue` file extension.
    If it matches, that is, if it finds a `vue` file, it will use the `vue-loader`
    module on it.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run our webpack script again as follows:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This will throw another error as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'There are more errors logged out to the console, but this is the one that we
    need to fix by adding another NPM package, as follows:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `devDependencies` entry inside `package.json` just received another update, as
    follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'So, now we can run webpack again as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: After webpack ran, if you opened `output.js` at this time, you'll see that it
    has the full Vue library inside of it, along with our `CustomArticle` at the very
    end. This all compiled without any errors.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the issue with our index.html file
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We still have the issue of the `index.html` file in the `dist` folder. It''s
    an easy fix! We''ll just add our own `index.html` file to the `src` folder, with
    the following contents:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Note that we have now removed our own `script` tags, since webpack will be
    adding them. Also, make sure to delete the `index.html` file inside the `dist`
    folder. Now, run the `npm run webpack` command again, and you''ll get this output
    in `dist/index.html` as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Why is this not working?
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: It is not working because we need to update both the JS files to be output,
    as well as the HTML files. Currently, we are only updating the JS files, but we
    still need to do it for our `index.html` file. Luckily, we already have `html-webpack-plugin`
    to help out.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Delivering HTML files via webpack with the help of html-webpack-plugin
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll begin by updating the `html-webpack-plugin` in the `webpack.config.js`
    file as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'What we did in the plugins section was, we passed an `options` object to our
    `HtmlWebpackPlugin()` call. Inside this `options` object, we specified our template:
    `./src/index.html`.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Before we run the webpack script again, we need to make sure to add the `meta`
    tag with `charset` set to `utf-8`. Otherwise, we'll get an error in our console
    when we open `dist/index.html` in the browser.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now run `npm run webpack` again. This time, everything works! We get
    our humble looking sentence on the screen:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Our own custom article component!
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! Although it is humble looking, you have successfully added
    a Vue app to an NPM-powered project, running on webpack.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll learn about HMR, and how it helps us in our Vue development.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Hot Module Replacement in Vue
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HMR has become a sort of a buzzword in the past couple of years. What's the
    big deal? In this section, we'll discuss how HMR works.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we''ll build another default simple app, just like we did in [Chapter
    1](081bc26f-96a8-4cb0-8e73-d7c6e67f409b.xhtml), *Introducing Vue CLI 3, *as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'After a while, once it''s done, we''ll go into our app''s directory as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Let''s open the project''s folder in VS Code as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Now, we can see the entire contents of our `second-default-project`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can serve the app as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Of course, our app is now serving in our browser.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: To view your app, visit `localhost:8080` in your browser.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at HMR updates happening in real time.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Observing HMR updates
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the browser window is active, let''s press the *F12* key to turn on the
    developer tools. Let''s also make sure that our the Elements panel is the active
    tab inside the dev tools, so that we can see the **Document Object Model** (**DOM**)
    structure, like in the following zoomed-in screenshot from the browser:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/555e8cdc-a628-43eb-870d-45c51239a104.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: The welcome screen of second-default-app with the Elements panel
    open in dev tools'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see HMR in action. Ideally, to see this in action, you'd need to
    use two monitors. Thus, you could, for example, move your VS Code window to the
    left monitor, and your browser with the app served to the right monitor. Alternatively,
    you can use a single monitor and view both apps side by side (with each one taking
    up half the screen width). The point of this exercise is to be able to see at
    the same time your VS Code window, your Vue app browser window, and your Elements
    panel inside your browser's dev tools.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, inside VS Code, open the `App.vue` file (inside the `src` folder of your
    project). Look at line 4, which currently reads as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We'll soon change that line to something else. Before you change the line, pay
    attention to how these changes reflect in the browser serving your app. Will the
    browser refresh?
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you''re focused on tracking changes in browser, let''s update line
    4 in `App.vue` as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Pay attention to the browser while you're saving changes to `App.vue` in VS
    Code. The best way to do this is to have VS Code in focus, but watch the browser
    window, specifically the Elements panel. With VS Code in focus, you can save changes
    with the shortcut key *Ctrl* + *S*.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: If you pay close attention, and if you're using Chrome, you'll notice a flash
    of purple color inside the Elements panel. That's the Chrome browser notifying
    us of the changes that happened to the DOM of our Vue app. If you pay close attention,
    you'll notice that there is a flash on the `head` element, as well as the `h1`
    element and it's child text node, `HMR is cool`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Also, you might notice that there was no refresh on the browser. Neither webpack,
    our app's code, or we ourselves forced the browser to refresh. What's the conclusion
    here? Webpack is actually not forcing a page refresh with HMR! Instead, it just
    injects an HMR.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'While the change on the `h1` element is obvious (as it is the immediately visible
    consequence of us changing the text inside the `App.vue` file), the update that
    happens in the `head` element is both more obscure and more helpful. To see what
    is happening, let''s twirl open the head tag by clicking on the little black triangle
    to the left of the `head` tag inside the Elements panel, as shown in the following
    screenshot:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/495be8e0-9fbb-415a-ac5e-e73a101235f3.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Twirl-open the head tag inside Elements panel in dev tools'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll need to scroll all the way down to the closing `</head>` tag.
    Right above it, there will be a `script` tag that reads something similar to this:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Let''s keep close attention on this section of the DOM tree in the Elements
    panel, while we make another change to `App.vue`. Let''s update our `msg` attribute
    on line 4 to this:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'If you observed the `script` tag, you''ll notice it change as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Did you notice that Vue injected another script above the closing `</head>`
    tag? That injected script is HMR in action, right there.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s inspect the very first line of the appended script file as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: How does this whole process work? Webpack simply runs our changes, bundles an
    update to our app, and, since it is already running, injects the new code using
    Vue loader.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: So, as we've just seen, HMR is just a feature of webpack that helps us do things
    more smoothly, without the need to worry about refreshing our apps.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we discussed the evolution of the JS language and its ecosystem,
    and how this evolution lead to the appearance of module bundlers. We also looked
    at webpack, the module bundler of choice of Vue CLI 3.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: We looked at how to plug in a very basic Vue-powered app, running on single
    file Vue templates. Alongside this mini-project, we also looked at a number of
    important webpack concepts. We finished the chapter by observing HMR on a Vue
    project.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the very basics of how webpack works, in the chapters that
    follow, we'll discuss some other related technologies and we'll build on our knowledge
    of webpack and Vue CLI 3\. The next topic we'll be closely examining is Babel.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
