- en: Wi-Fi Sniffing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding Wi-Fi devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding SSIDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing hidden SSIDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionary attack on hidden SSIDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fake access points with Scapy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned to use the Scapy module in Python. Now we can utilize the Scapy
    module for sniffing access points and their MAC addresses. Before that, it would
    be useful to have an idea of SSIDs. A **Service Set Identifier** (**SSID**) is
    the name of the wireless network that helps to separate the multiple signals in
    the same network. We can use the SSID to identify and connect to a network.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Wi-Fi devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of joining a Wi-Fi network is simple. The devices can listen for
    other devices to identity them. These identifiers are broadcast continuously and
    are known as **beacons**. These types of unique beacons are broadcast by the devices,
    which act as access points. These beacons include an SSID that acts as the name
    of that access point. Every SSID broadcasts its own unique beacon frame to notify
    any listening device that this SSID is available and it has particular capabilities.
    We can sniff the packets in the Wi-Fi interface to get the Wi-Fi devices available
    in the area by listening to these beacons broadcast by the access points. Here
    we use Scapy to analyze the packets captured by the interface to extract the beacons.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have to sniff the packets from the interface, we require a Wi-Fi card
    capable of sniffing the Wi-Fi signals with the Monitor Mode. So we have to make
    sure the card is capable of sniffing. Then we have to set the interface to the
    Monitor Mode which is different for different operating systems. As Scapy has
    some limitations in the Windows systems, we have to run this recipe in a Linux
    or macOS environment.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start coding, we have to get an idea about the Wi-Fi packets. As with
    the other packets, Wi-Fi packets also have a structure. According to the specification
    802.11, each beacon frame from the access point contains a lot of information
    about the specific SSID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the frame format for an 802.11 mgmt beacon frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'From this, we can get an idea of the content of the beacon frame. The really
    important items in the beacon frame are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SSID name**: This is a 1-32 character name of the WLAN network and is present
    in all beacons. The Wireshark capture will display the SSID tag as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**BSSID**: This is a unique layer 2 MAC address of the SSID. Here is what it
    looks like in the Wireshark capture:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Timestamp**: This represents the time on the access point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security capabilities**: This item refers to the security capabilities of
    the access point, such as open, WEP, WPA, WPA2, personal (passphrase) versus enterprise
    (802.1x with RADIUS server). Here is what it looks like in the Wireshark capture:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Channel**: This indicates the specific frequency that the SSID on this AP
    is operating on. Here is it what it looks like in the Wireshark capture:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Channel width**: This indicates the width of the channel, such as 20, 40,
    80, and 160 mbps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Country**: This provides a list of all the supported channels and corresponding
    channel settings. Each country has its own regulatory bodies that decide the channels
    or power levels allowed in their regulatory domain. This tag defines the country
    of operation and the allowed channels and the allowed maximum transmit limit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Beacon interval**: This indicates how often the AP broadcasts this beacon
    frame. Here is what it looks like in the Wireshark capture:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enable the Monitor Mode in the network interface. This is different for different
    operating systems. Also, not all network cards support the Monitor Mode. We have
    to use a terminal command to do this as it is not possible through Python script.
    This will put the network card Interface as wlan0 into the Monitor Mode.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the steps to enable Monitor Mode in a Linux environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done with the `airmon-ng` package. Please make sure you install
    the `airmon-ng` package for this. Also, make sure you provide the correct interface
    as the parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be done with the following networking commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To disable the Monitor Mode, we can use the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the steps to enable Monitor Mode in a macOS environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the airport utility command to enable the Monitor Mode in macOS.
    As this is a binary command in the library, we can `symlink` this to `usr/local/bin/`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can select the channel to sniff with `airport` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can start sniffing with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will `sniff` the interface `en0` and save to a pcap file inside a `tmp/`
    folder such as this: `/tmp/airportSniffXXXXXX.pcap.` We can analyze this file
    with Scapy.'
  prefs: []
  type: TYPE_NORMAL
- en: Now create a `wifi-sniff.py` file and open it in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As usual, load the required modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can define the required variable. Here we will create a list for the
    access points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can define the callback function to parse the packets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the captured Wi-Fi packets. The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For the 802.11 packet layer, the main variables are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type=0`: This indicates that the frame is a management frame (type 0)'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subtype=8`: This indicates the management frame''s subtype is a beacon (type
    8)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addr1`: Destination MAC address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addr2`: Source MAC address of the sender'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addr3`: MAC address of the access point'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From the preceding details, we can update the parser function to get the Wi-Fi
    MAC address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now call the `sniff` function and pass the packets to the `callback` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the script and call with the `sudo` permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Finding SSIDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get the SSID, we need to update the previous recipe and parse the SSID from
    the packets.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following are the steps to write a SSID sniffer script with `scapy` module:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `sniff-ssid.py` file and open it in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the module required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a function to parse the SSID from the packet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now run the `sniff` and call the parse function on the callback.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run this script with the `sudo` permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Exposing hidden SSIDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can modify the previous recipe to get the hidden SSIDs. With Scapy, we can
    identify probe answers and requests to extract the hidden SSIDs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the steps to write a script to expose hidden SSIDs:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `sniff-hidden-ssid.py` file and open it in the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `scapy` module and create a dictionary for the identified SSIDs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create the function to parse the hidden SSIDs from the packets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here it checks for the probe response and request to extract the BSSID and SSID
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `sniff` the packet and pass it to the `callback` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run this script with the root permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary attack on hidden SSIDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With hidden SSIDs, we could run a dictionary attack to identify the hidden SSIDs.
    For that, we will iterate through a list of SSIDs and send a broadcast packet
    with a particular SSID. If the SSID exists, the access point will respond with
    a packet. So, we could start the SSID sniffer we created in the previous recipe
    and wait for the response from the access point while running the brute force
    attack with the SSIDs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to write a script that can be used to run a dictionary attack
    on SSIDs:'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, create a new `dictionary-attack-ssid.py` file and open it in an editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Load all the required modules, and initialize the variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we iterate through the SSIDs in the list and send a `RadioTap()` packet
    with the SSID set as the parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now start the sniffer script in one terminal window and wait for the response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, start the dictionary attack script with the `sudo` permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Fake access points with Scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can create fake Wi-Fi access points by injecting beacon frames with Scapy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try creating a fake SSID with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `fake-access-point.py` file and open it in the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Load the required modules for the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here we use the `scapy` and `random` modules for creating random MAC IDs
  prefs: []
  type: TYPE_NORMAL
- en: 'Then define the access point name and the interface to broadcast:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can craft the packet with the `beacon` frame as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can broadcast the access point with the `sendp()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the script with the required permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will broadcast an access point with the provided SSID
  prefs: []
  type: TYPE_NORMAL
