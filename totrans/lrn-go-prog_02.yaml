- en: Chapter 2. Go Language Essentials
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。Go语言基础
- en: In the previous chapter, we established the elemental characteristics that make
    Go a great language with which to create modern system programs. In this chapter,
    we dig deeper into the language's syntax to explore its components and features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们确定了使Go成为一个用于创建现代系统程序的优秀语言的基本特征。在本章中，我们将深入探讨语言的语法，以探索其组件和特性。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: The Go source file
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go源文件
- en: Identifiers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符
- en: Variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量
- en: Constants
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量
- en: Operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符
- en: The Go source file
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go源文件
- en: 'We have seen, in [Chapter 1](ch01.html "Chapter 1. A First Step in Go"), *A
    First Step in Go*, some examples of Go programs. In this section, we will examine
    the Go source file. Let us consider the following source code file (which prints
    `"Hello World"` greetings in different languages):'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](ch01.html "第1章。Go的第一步")中看到了一些Go程序的例子。在本节中，我们将研究Go源文件。让我们考虑以下源代码文件（它以不同的语言打印了`"Hello
    World"`问候）：
- en: '![The Go source file](img/B03676_02_Helloworld2-source.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![Go源文件](img/B03676_02_Helloworld2-source.jpg)'
- en: golang.fyi/ch02/helloworld2.go
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch02/helloworld2.go
- en: 'A typical Go source file, such as the one listed earlier, can be divided into
    three main sections, illustrated as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的Go源文件，比如前面列出的那个，可以分为三个主要部分，如下所示：
- en: 'The **Package Clause**:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包声明**：'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The **Import Declaration**:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导入声明**：'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The **Source Body**:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源代码主体**：'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The **package** clause indicates the name of the package this source file belongs
    to (see [Chapter 6](ch06.html "Chapter 6. Go Packages and Programs"), Go *Packages
    and Programs* for a detailed discussion on package organization). The **import**
    declaration lists any external package that the source code wishes to use. The
    Go compiler strictly enforces package declaration usage. It is considered an error
    (compilation) to include an unused package in your source file. The last portion
    of the source is considered the body of your source file. It is where you declare
    variables, constants, types, and functions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**包**声明指示了这个源文件所属的包的名称（参见[第6章](ch06.html "第6章。Go包和程序")，Go *包和程序*中对包组织的详细讨论）。**导入**声明列出了源代码希望使用的任何外部包。Go编译器严格执行包声明的使用。在你的源文件中包含一个未使用的包被认为是一个错误（编译）。源文件的最后部分被认为是源文件的主体。在这里你声明变量、常量、类型和函数。'
- en: All Go source files must end with the `.go` suffix. In general, you can name
    a Go source file whatever you want. Unlike Java, for instance, there is no direct
    association between a Go file name and the types it declared in its content. It
    is, however, considered good practice to name your file something indicative of
    its content.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的Go源文件都必须以`.go`后缀结尾。一般来说，你可以随意命名一个Go源文件。与Java不同，例如，Go文件名和其内容中声明的类型之间没有直接关联。然而，将文件命名为与其内容相关的名称被认为是一个良好的做法。
- en: Before we explore Go's syntax in greater detail, it is important to understand
    some basic structural elements of the language. While some of these elements are
    syntactically bolted into the language, others are simple idioms and conventions
    that you should be aware of to make your introduction to Go simple and enjoyable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更详细地探讨Go的语法之前，了解语言的一些基本结构元素是很重要的。虽然其中一些元素在语法上被固定在语言中，但其他一些只是简单的习惯和约定，你应该了解这些以使你对Go的介绍简单而愉快。
- en: Optional semicolon
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选的分号
- en: 'You may have noticed that Go does not require a semicolon as a statement separator.
    This is a trait borrowed from other lighter and interpreted languages. The following
    two programs are functionally equivalent. The first program uses idiomatic Go
    and omits the semicolons:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，Go不需要分号作为语句分隔符。这是从其他更轻量级和解释性语言中借鉴来的特点。以下两个程序在功能上是等价的。第一个程序使用了典型的Go，并省略了分号：
- en: '![Optional semicolon](img/B03736_02_Helloworld-snippet1.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![可选的分号](img/B03736_02_Helloworld-snippet1.jpg)'
- en: 'The second version of the program, shown as follows, uses superfluous semicolons
    to explicitly terminate its statements. While the compiler may thank you for your
    help, this is not idiomatic in Go:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第二个版本，如下所示，使用了多余的分号来显式终止其语句。虽然编译器可能会感谢你的帮助，但这在Go中并不是惯用法：
- en: '![Optional semicolon](img/B03676_02_Helloworld-snippet2-1.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![可选的分号](img/B03676_02_Helloworld-snippet2-1.jpg)'
- en: 'Although semicolons in Go are optional, Go''s formal grammar still requires
    them as statement terminators. So, the Go compiler will insert semicolons at the
    end of source code lines that end with the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Go中的分号是可选的，但Go的正式语法仍要求它们作为语句终止符。因此，Go编译器会在以下以以下结尾的源代码行末尾插入分号：
- en: An identifier
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标识符
- en: A literal value for string, Boolean, numeric, or complex
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串、布尔、数字或复数的文字值
- en: A control flow directive such as break, continue, or return
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制流指令，比如break、continue或return
- en: A closing parenthesis or bracket such as `)`, `}`, or `]`
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个闭括号，比如`)`、`}`或`]`
- en: The increment `++` or the decrement `--` operator
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增量`++`或减量`--`运算符
- en: 'Due to these rules, the compiler enforces strict syntactical forms that heavily
    influence source code style in Go. For instance, all code blocks must start with
    an open curly `{` brace on the same line as its preceding statement. Otherwise,
    the compiler may insert the semicolon in a location that breaks the code, as shown
    in the following `if` statement:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些规则，编译器强制执行严格的语法形式，这严重影响了Go中源代码的风格。例如，所有的代码块必须以与其前一个语句相同行的开放大括号`{`开始。否则，编译器可能会在破坏代码的位置插入分号，如下面的`if`语句所示：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Moving the curly brace to the next line causes the compiler to insert the semicolon
    prematurely, which will result in the following syntax error:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将大括号移到下一行会导致编译器过早地插入分号，这将导致以下语法错误：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is because the compiler inserted the semicolon after the `if` statement
    (`if "a"=="a";`), using the semicolon insertion rules discussed in this section.
    You can verify this by manually inserting a semicolon after the `if` condition
    statement; you will get the same error. This is an excellent place to transition
    into the next section, to discuss trailing commas in code blocks.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Multiple lines
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Breaking up expressions into multiple lines must follow the semi-colon rules
    discussed in the previous section. Mainly, in a multi-line expression, each line
    must end with a token that prevents the premature insertion of a semi-colon, as
    illustrated in the following table. It should be noted that rows in the table
    with an invalid expression will not compile:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Valid** |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '| Yes, the `+` operator prevents a premature semi-colon from being inserted.
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '| No, a semi-colon will be inserted after the first line, semantically breaking
    the line. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '| Yes, the comma properly breaks the expression. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '| Yes, the compiler inserts a semi-colon only after the last line. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '| No, the `Fri` line causes a premature semi-colon to be inserted. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '| Yes, the `Fri` line contains a trailing comma, which causes compiler to insert
    a semi-colon at the next line. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| `weekDays1 := []string{``"Mon", "Tue",``"Wed", "Thr",``"Fri"}` | Yes, the
    semi-colon is inserted after the line with the closing bracket. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: You may wonder why the Go compiler puts the onus on the developer to provide
    line-break hints to indicate the end of a statement. Surely, Go designers could
    have devised an elaborate algorithm to figure this out automatically. Yes, they
    could have. However, by keeping the syntax simple and predictable, the compiler
    is able to quickly parse and compile Go source code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Go toolchain includes the gofmt tool, which can be used to consistently
    apply proper formatting rules to your source code. There is also the `govet` tool,
    which goes much further by analyzing your code for structural problems with code
    elements.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Go identifiers
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go identifiers are used to name program elements including packages, variables,
    functions, and types. The following summarizes some attributes about identifiers
    in Go:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Identifiers support the Unicode character set
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first position of an identifier must be a letter or an underscore
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Idiomatic Go favors mixed caps (camel case) naming
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package-level identifiers must be unique across a given package
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifiers must be unique within a code block (functions, control statements)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The blank identifier
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Go compiler is particularly strict about the use of declared identifiers
    for variables or packages. The basic rule is: *you declare it, you must use it*.
    If you attempt to compile code with unused identifiers such as variables or named
    packages, the compilers will not be pleased and will fail compilation.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Go allows you to turn off this behavior using the blank identifier, represented
    by the `_` (underscore) character. Any declaration or assignment that uses the
    blank identifier is not bound to any value and is ignored at compile time. The
    blank identifier is usually used in two contexts, as listed in the following subsections.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Muting package imports
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a package declaration is preceded by an underscore, the compiler allows
    the package to be declared without any further referenced usage:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the previous code snippet, the package `log` will be muted without any further
    reference in the code. This can be a handy feature during active development of
    new code, where developers may want to try new ideas without constantly having
    to comment out or delete the declarations. Although a package with a blank identifier
    is not bound to any reference, the Go runtime will still initialize it. [Chapter
    6](ch06.html "Chapter 6. Go Packages and Programs"), *Go Packages and Programs*,
    discusses the package initialization lifecycle.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Muting unwanted function results
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a Go function call returns multiple values, each value in the return list
    must be assigned to a variable identifier. In some cases, however, it may be desirable
    to mute unwanted results from the return list while keeping others, as shown in
    the following call:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当Go函数调用返回多个值时，返回列表中的每个值都必须分配给一个变量标识符。然而，在某些情况下，可能希望消除返回列表中不需要的结果，同时保留其他结果，如下所示：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The previous call to the function `filepath.Split("/opt/data/bigdata.txt")`
    takes a path and returns two values: the first is the parent path (`/opt/data`)
    and the second is the file name (`bigdata.txt`). The first value is assigned to
    the blank identifier and is, therefore, unbounded to a named identifier, which
    causes it to be ignored by the compiler. In future discussions, we will explore
    other uses of this idiom''s other contexts, such as error-handling and `for` loops.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 先前对函数`filepath.Split("/opt/data/bigdata.txt")`的调用接受一个路径并返回两个值：第一个是父路径（`/opt/data`），第二个是文件名（`bigdata.txt`）。第一个值被分配给空白标识符，因此未绑定到命名标识符，这导致编译器忽略它。在未来的讨论中，我们将探讨这种习惯用法在其他上下文中的其他用途，比如错误处理和`for`循环。
- en: Built-in identifiers
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置标识符
- en: Go comes with a number of built-in identifiers. They fall into different categories,
    including types, values, and built-in function.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Go带有许多内置标识符。它们属于不同的类别，包括类型、值和内置函数。
- en: Types
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型
- en: 'The following identifiers are used for Go''s built-in types:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标识符用于Go的内置类型：
- en: '| **Category** | **Identifier** |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **标识符** |'
- en: '| Numeric | `byte`, `int`, `int8`, `int16`, `int32`, `int64`, `rune`, `uint`,
    `uint8`, `uint16`, `uint32`, `uint64`, `float32`, `float64`, `complex64`, `complex128`,
    `uintptr` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 数字 | `byte`，`int`，`int8`，`int16`，`int32`，`int64`，`rune`，`uint`，`uint8`，`uint16`，`uint32`，`uint64`，`float32`，`float64`，`complex64`，`complex128`，`uintptr`
    |'
- en: '| String | `string` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | `string` |'
- en: '| Boolean | `bool` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 布尔 | `bool` |'
- en: '| Error | `error` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 错误 | `error` |'
- en: Values
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值
- en: 'These identifiers have preassigned values:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标识符具有预分配的值：
- en: '| **Category** | **Identifier** |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **标识符** |'
- en: '| Boolean constants | `true`, `false` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 布尔常量 | `true`，`false` |'
- en: '| Constant counter | `iota` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 常量计数器 | `iota` |'
- en: '| Uninitialized value | `nil` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 未初始化值 | `nil` |'
- en: Functions
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: 'The following functions are available as part of Go''s built-in pre-declared
    identifiers:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数作为Go的内置预声明标识符的一部分可用：
- en: '| **Category** | **Identifier** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **标识符** |'
- en: '| Initialization | `make()`, `new()` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 初始化 | `make()`，`new()` |'
- en: '| Collections | `append()`, `cap()`, `copy()`, `delete()` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | `append()`，`cap()`，`copy()`，`delete()` |'
- en: '| Complex numbers | `complex()`, `imag()`, `real()` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 复数 | `complex()`，`imag()`，`real()` |'
- en: '| Error Handling | `panic()`, `recover()` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 错误处理 | `panic()`，`recover()` |'
- en: Go variables
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go变量
- en: Go is a strictly typed language, which implies that all variables are named
    elements that are bound to both a value and a type. As you will see, the simplicity
    and flexibility of its syntax make declaring and initializing variables in Go
    feel more like a dynamically-typed language.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Go是一种严格类型的语言，这意味着所有变量都是绑定到值和类型的命名元素。正如你将看到的，它的语法的简单性和灵活性使得在Go中声明和初始化变量更像是一种动态类型的语言。
- en: Variable declaration
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量声明
- en: 'Before you can use a variable in Go, it must be declared with a named identifier
    for future reference in the code. The long form of a variable declaration in Go
    follows the format shown here:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中使用变量之前，必须使用命名标识符声明它以便在代码中将来引用。在Go中变量声明的长格式遵循以下格式：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `var` keyword is used to declare one or more variable identifiers followed
    by the type of the variables. The following source code snippet shows an abbreviated
    program with several variables declared outside of the function `main()`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`关键字用于声明一个或多个变量标识符，后面跟着变量的类型。以下源代码片段显示了一个缩写程序，其中声明了几个变量，这些变量在`main()`函数之外声明：'
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: golang.fyi/ch02/vardec1.go
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch02/vardec1.go
- en: The zero-value
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 零值
- en: The previous source code shows several examples of variables being declared
    with a variety of types. Then the variables are assigned a value inside the function
    `main()`. At first glance, it would appear that these declared variables do not
    have an assigned value when they are declared. This would contradict our previous
    assertion that all Go variables are bound to a type and a value.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的源代码显示了使用各种类型声明变量的几个示例。然后在`main()`函数内为变量赋值。乍一看，这些声明的变量在声明时似乎没有被赋值。这将与我们先前的断言相矛盾，即所有Go变量都绑定到类型和值。
- en: How can we declare a variable and not bind a value to it? During declaration
    of a variable, if a value is not provided, Go will automatically bind a default
    value (or a zero-value) to the variable for proper memory initialization (we see
    how to do both declaration and initialization in one expression later).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何声明一个变量而不将值绑定到它？在变量声明期间，如果没有提供值，Go将自动将默认值（或零值）绑定到变量以进行适当的内存初始化（我们稍后将看到如何在一个表达式中进行声明和初始化）。
- en: 'The following table shows Go types and their default zero-values:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了Go类型及其默认零值：
- en: '| **Type** | **Zero-Value** |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **零值** |'
- en: '| `string` | `""` (empty string) |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `string` | `""`（空字符串） |'
- en: '| Numeric - Integers: `byte`, `int`, `int8`, `int16`, `int32`, `int64`, `rune`,
    `uint`, `uint8`, `uint16`, `uint32`, `uint64`, `uintptr` | 0 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 数字 - 整数：`byte`，`int`，`int8`，`int16`，`int32`，`int64`，`rune`，`uint`，`uint8`，`uint16`，`uint32`，`uint64`，`uintptr`
    | 0 |'
- en: '| Numeric - Floating point: `float32`, `float64` | 0.0 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 数字 - 浮点数：`float32`，`float64` | 0.0 |'
- en: '| `bool` | false |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | false |'
- en: '| `Array` | Each index position has a zero-value corresponding to the array''s
    element type. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `Array` | 每个索引位置都有一个与数组元素类型相对应的零值。 |'
- en: '| `Struct` | An empty `struct` with each member having its respective zero-value.
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `Struct` | 一个空的`struct`，每个成员都具有其相应的零值。 |'
- en: '| Other types: Interface, function, channel, slice, map, and pointer | nil
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 其他类型：接口、函数、通道、切片、映射和指针 | nil |'
- en: Initialized declaration
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化声明
- en: 'As hinted earlier, Go also supports the combination of both variable declaration
    and initialization as one expression using the following format:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Go还支持使用以下格式将变量声明和初始化组合为一个表达式：
- en: '*var <identifier list> <type> = <value list or initializer expressions>*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*var <标识符列表> <类型> = <值列表或初始化表达式>*'
- en: 'This declaration format has the following properties:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这种声明格式具有以下特性：
- en: An identifier list provided on the left-hand side of the equal sign (followed
    by a type)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等号左侧提供的标识符列表（后跟类型）
- en: A matching comma-separated value list on the right-hand side
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右侧有匹配的逗号分隔值列表
- en: Assignment occurs in the respective order of identifiers and values
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值按标识符和值的相应顺序进行
- en: Initializer expressions must yield a matching list of values
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化表达式必须产生匹配的值列表
- en: 'The following abbreviated example shows the declaration and initialization
    combination at work:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是声明和初始化组合的简化示例：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: golang.fyi/ch02/vardec2.go
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch02/vardec2.go
- en: Omitting variable types
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 省略变量类型
- en: 'So far, we have discussed what is called the long form of Go''s variable declaration
    and initialization. To make the language feel closer to its dynamically-typed
    cousins, the type specification can be omitted, as shown in the following declaration
    format:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了Go的变量声明和初始化的长格式。为了使语言更接近其动态类型的表亲，可以省略类型规范，如下所示：
- en: '*var <identifier list> = <value list or initializer expressions>*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*var <标识符列表> = <值列表或初始化表达式>*'
- en: During compilation, the compiler infers the type of the variable based on the
    assigned value or the initializer expression on the right-hand side of the equal
    sign, as shown in the following example.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译期间，编译器根据等号右侧的赋值或初始化表达式推断变量的类型，如下例所示。
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: golang.fyi/ch02/vardec3.go
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch02/vardec3.go
- en: 'As stated earlier, when a variable is assigned a value, it must receive a type
    along with that value. When the type of the variable is omitted, the type information
    is deduced from the assigned value or the returned value of an expression. The
    following table shows the type that is inferred given a literal value:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当变量被赋值时，必须同时接收一个类型和该值。当省略变量的类型时，类型信息是从分配的值或表达式的返回值中推断出来的。以下表格显示了给定文字值时推断出的类型：
- en: '| **Literal value** | **Inferred type** |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| **文字值** | **推断类型** |'
- en: '| Double- or single-quoted (raw) text: `"Planet Mars"``"All planets revolve
    around the Sun."` | `string` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: 双引号或单引号（原始）文本：`"火星行星"``"所有行星都围绕太阳运转。"` | `string` |
- en: '| Integers:`-76`0`1244``1840` | `int` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: 整数：`-76`0`1244``1840` | `int` |
- en: '| Decimals:`-0.25``4.0``3.1e4``7e-12` | `float64` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: 小数：`-0.25``4.0``3.1e4``7e-12` | `float64` |
- en: '| Complex numbers:`-5.0i``3i``(0+4i)` | `complex128` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: 复数：`-5.0i``3i``(0+4i)` | `complex128` |
- en: '| Booleans:`true``false` | `bool` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: 布尔值：`true``false` | `bool` |
- en: '| Array values:`[2]int{-76, 8080}` | The `array` type defined in the literal
    value. In this case it is: `[2]int` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: 数组值：`[2]int{-76, 8080}` | 在文字值中定义的`数组`类型。在这种情况下是：`[2]int` |
- en: '| Map values:`map[string]int{``  "Sun": 685800,``  "Earth": 6378,``  "Mars":
    3396,``}` | The map type defined in the literal value. In this case it is: `map[string]int`
    |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '映射值：`map[string]int{``  "Sun": 685800,``  "Earth": 6378,``  "Mars": 3396,``}`
    | 在文字值中定义的映射类型。在这种情况下是：`map[string]int` |'
- en: '| Slice values:`[]int{-76, 0, 1244, 1840}` | The `slice` type defined in the
    literal value:`[]int` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: 切片值：`[]int{-76, 0, 1244, 1840}` | 在文字值中定义的`切片`类型：`[]int` |
- en: '| Struct values:`struct{``  name string``  diameter int}``{``  "Mars", 3396,``}`
    | A `struct` type as defined in the literal value. In this case the type is:`struct{name
    string; diameter int}` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: 结构值：`struct{``  name string``  diameter int}``{``  "Mars", 3396,``}` | 在文字值中定义的`结构`类型。在这种情况下，类型是：`struct{name
    string; diameter int}` |
- en: '| Function values:`var sqr = func (v int)   int {``  return v * v``}` | The
    function type defined in the function definition literal. In this `case`, `variable``sqr`
    will have type:`func (v int) int` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: 函数值：`var sqr = func (v int)   int {``  return v * v``}` | 在函数定义文字中定义的函数类型。在这种情况下，变量`sqr`的类型将是：`func
    (v int) int` |
- en: Short variable declaration
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 短变量声明
- en: 'Go can further reduce the variable declaration syntax using the *short variable
    declaration* format. In this format, the declaration loses the var keyword and
    the type specification, and uses an assignment operator `:=` (colon-equal), as
    shown:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Go可以进一步减少变量声明语法，使用*短变量声明*格式。在这种格式中，声明不再使用var关键字和类型规范，而是使用赋值运算符`:=`（冒号等于），如下所示：
- en: '*<identifier list> := <value list or initializer expressions>*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*<标识符列表> := <值列表或初始化表达式>*'
- en: 'This is a simple and uncluttered idiom that is commonly used when declaring
    variables in Go. The following code sample shows usage of the short variable declarations:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单而清晰的习惯用语，在Go中声明变量时通常使用。以下代码示例显示了短变量声明的用法：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: golang.fyi/ch02/vardec4.go
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch02/vardec4.go
- en: Notice the keyword `var` and variable types have been omitted in the declaration.
    Short variable declaration uses the same mechanism to infer the type of the variable
    discussed earlier.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，关键字`var`和变量类型在声明中被省略。短变量声明使用了先前讨论的相同机制来推断变量的类型。
- en: Restrictions for short variable declaration
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 短变量声明的限制
- en: 'For convenience, the short form of the variable declaration does come with
    several restrictions that you should be aware of to avoid confusion:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，变量声明的简短形式确实带有一些限制，您应该注意以避免混淆：
- en: Firstly, it can only be used within a function block
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它只能在函数块内使用
- en: The assignment operator `:=`, declares variable and assign values
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值运算符`:=`，声明变量并赋值
- en: '`:=` cannot be used to update a previously declared variable'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:=`不能用于更新先前声明的变量'
- en: Updates to variables must be done with an equal sign
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的更新必须使用等号
- en: While these restrictions may have their justifications rooted in the simplicity
    of Go's grammar, they are generally viewed as a source of confusion for newcomers
    to the language. For instance, the colon-equal operator cannot be used with package-level
    variables assignments. Developers learning Go may find it compelling to use the
    assignment operator as a way to update a variable, but that would cause a compilation
    error.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Variable scope and visibility
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go uses lexical scoping based on code blocks to determine the visibility of
    variables within a package. Depending on the location where a variable is declared,
    within the source text, will determine its scope. As a general rule, a variable
    is only accessible from within the block where it is declared and visible to all
    nested sub-blocks.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates the scope of several variables declared
    within a source text. Each variable declaration is marked with its scope (`package`,
    `function`, `for` loop, and `if...else` block):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![Variable scope and visibility](img/B036376_02_01.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: golang.fyi/ch02/makenums.go
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: As explained earlier, variable visibility works top-down. Variables with package
    scope, such as `mapFile` and `numbersFile`, are globally visible to all other
    elements in the package. Moving down the scope ladder, function-block variables
    such as `data` and `err` are visible to all elements in the function and including
    sub-blocks. Variables `i` and `b` in the inner `for` loop block are only visible
    within that block. Once the loop is done, `i` and `b` would go out of scope.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One source of confusion to newcomers to Go is the visibility of package-scoped
    variables. When a variable is declared at package level (outside of a function
    or method block), it is globally visible to the entire package, not just to the
    source file where the variable is declared. This means a package-scoped variable
    identifier can only be declared once in a group of files that make up a package,
    a fact that may not be obvious to developers starting out with Go. Refer to [Chapter
    6](ch06.html "Chapter 6. Go Packages and Programs"), *Go Packages and Programs*,
    for details on package organization.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Variable declaration block
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go''s syntax allows the declaration of top-level variables to be grouped together
    into blocks for greater readability and code organization. The following example
    shows a rewrite of one of the previous examples using the variable declaration
    block:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: golang.fyi/ch02/vardec5.go
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Go constants
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Go, a constant is a value with a literal representation such as a string
    of text, Boolean, or numbers. The value for a constant is static and cannot be
    changed after initial assignment. While the concept they represent is simple,
    constants, however, have some interesting properties that make them useful, especially
    when working with numeric values.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Constant literals
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Constants are values that can be represented by a text literal in the language.
    One of the most interesting properties of constants is that their literal representations
    can either be treated as typed or untyped values. Unlike variables, which are
    intrinsically bound to a type, constants can be stored as untyped values in memory
    space. Without that type constraint, numeric constant values, for instance, can
    be stored with great precision.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'The followings are examples of valid constant literal values that can be expressed
    in Go:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Typed constants
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go constant values can be bound to named identifiers using a constant declaration.
    Similar to a variable declaration, Go uses the `const` keyword to indicate the
    declaration of a constant. Unlike variables, however, the declaration must include
    the literal value to be bound to the identifier, as shown in the following format:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '*const <identifier list> type = <value list or initializer expressions>*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Constants cannot have any dependency that requires runtime resolution. The compiler
    must be able to resolve the value of a constant at compile time. This means all
    constants must be declared and initialized with a value literal (or an expression
    that results to a constant value).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows some typed constants being declared:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: golang.fyi/ch02/const.go
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Notice in the previous source snippet that each declared constant identifier
    is explicitly given a type. As you would expect, this implies that the constant
    identifier can only be used in contexts that are compatible with its types. However,
    the next section explains how this works differently when the type is omitted
    in the constant declaration.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Untyped constants
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Constants are even more interesting when they are untyped. An untyped constant
    is declared as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '*const <identifier list> = <value list or initializer expression>*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, the keyword `const` is used to declare a list of identifiers as
    constants along with their respective bounded values. However, in this format,
    the type specification is omitted in the declaration. As an untyped entity, a
    constant is merely a blob of bytes in memory without any type precision restrictions
    imposed. The following shows some sample declarations of untyped constants:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: golang.fyi/ch02/const.go
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: From the previous code snippet, the untyped constant `m2` is assigned a long
    decimal value (truncated to fit on the printed page as it goes another 17 digits).
    Constant `m4` is assigned a much larger number of `m3 x 1.0e+400`. The entire
    value of the resulting constant is stored in memory without any loss in precision.
    This can be an extremely useful tool for developers interested in computations
    where a high level of precision is important.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Assigning untyped constants
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Untyped constant values are of limited use until they are assigned to variables,
    used as function parameters, or are part of an expression assigned to a variable.
    In a strongly-typed language like Go, this means there is a potential for some
    type adjustment to ensure that the value stored in the constant can be properly
    assigned to the target variable. One advantage of using untyped constants is that
    the type system relaxes the strict application of type checking. An untyped constant
    can be assigned to different, though compatible, types of different precision
    without any complaint from the compiler, as shown in the following example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The previous snippet shows the untyped constant `m2` being assigned to two variables
    of different floating-point precisions, `u1` and `u2`, and to an untyped variable,
    `u3`. This is possible because constant `m2` is stored as a raw untyped value
    and can therefore be assigned to any variable compatible with its representation
    (a floating point).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'While the type system will accommodate the assignment of `m2` to variables
    of different precision, the resulting assignment is adjusted to fit the variable
    type, as noted in the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'What about variable `u3`, which is itself an untyped variable? Since `u3` does
    not have a specified type, it will rely on type inference from the constant value
    to receive a type assignment. Recall from the discussion in the section *Omitting
    Variable Types* earlier, that constant literals are mapped to basic Go types based
    on their textual representations. Since constant `m2` represents a decimal value,
    the compiler will infer its default to be a `float64`, which will be automatically
    assigned to variable `u3`, as shown:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, Go's treatment of untyped raw constant literals increases the
    language's usability by automatically applying some simple, but effective, type
    inference rules without sacrificing type-safety. Unlike other languages, developers
    do not have to explicitly specify the type in the value literal or perform some
    sort of typecast to make this work.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Constant declaration block
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you may have guessed, constant declarations, can be organized as code blocks
    to increase readability. The previous example can be rewritten as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经猜到的那样，常量声明可以组织为代码块以增加可读性。前面的示例可以重写如下：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: golang.fyi/ch02/const2.go
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch02/const2.go
- en: Constant enumeration
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量枚举
- en: 'One interesting usage of constants is to create enumerated values. Using the
    declaration block format (shown in the preceding section), you can easily create
    numerically increasing enumerated integer values. Simply assign the pre-declared
    constant value `iota` to a constant identifier in the declaration block, as shown
    in the following code sample:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 常量的一个有趣用法是创建枚举值。使用声明块格式（在前面的部分中显示），您可以轻松地创建数字递增的枚举整数值。只需将预先声明的常量值“iota”分配给声明块中的常量标识符，如下面的代码示例所示：
- en: '[PRE26]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: golang.fyi/ch02/enum0.go
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch02/enum0.go
- en: 'The compiler will then automatically do the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后编译器会自动执行以下操作：
- en: Declare each member in the block as an untyped integer constant value
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将块中的每个成员声明为无类型整数常量值
- en: Initialize `iota` with a value of zero
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用值0初始化`iota`
- en: Assign `iota`, or zero, to the first constant member (`StarHyperGiant`)
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`iota`或零分配给第一个常量成员（`StarHyperGiant`）
- en: Each subsequent constant is assigned an `int` value increased by one
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个后续常量都被分配一个增加了一的`int`值
- en: 'So the previous list of constants would be assigned a sequence of values going
    from zero to nine. Whenever `const` appears as a declaration block, it resets
    the counter to zero. In the following snippet, each set of constants is enumerated
    from zero to four separately:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以前的常量列表将被分配一个从零到九的值序列。每当`const`出现为声明块时，它将计数器重置为零。在下面的代码片段中，每组常量都分别从零到四进行枚举：
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: golang.fyi/ch02/enum1.go
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch02/enum1.go
- en: Overriding the default enumeration type
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖默认枚举类型
- en: 'By default, an enumerated constant is declared as an untyped integer value.
    However, you can override the default type of the enumerated values by providing
    an explicit numeric type for your enumerated constants, as shown in the following
    code sample:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，枚举常量被声明为无类型整数值。但是，您可以通过为枚举常量提供显式数字类型来覆盖枚举值的默认类型，如下面的代码示例所示：
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can specify any numeric type that can represent integers or floating point
    values. For instance, in the preceding code sample, each constant will be declared
    as type `byte`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以指定可以表示整数或浮点值的任何数字类型。例如，在前面的代码示例中，每个常量将被声明为类型`byte`。
- en: Using iota in expressions
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在表达式中使用iota
- en: 'When `iota` appears in an expression, the same mechanism works as expected.
    The compiler will apply the expression for each successive increasing value of
    `iota`. The following example assigns even numbers to the enumerated members of
    the constant declaration block:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当“iota”出现在表达式中时，相同的机制会按预期工作。编译器将对每个递增的“iota”值应用表达式。以下示例将偶数分配给常量声明块的枚举成员：
- en: '[PRE29]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: golang.fyi/ch02/enum2.go
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch02/enum2.go
- en: 'As you may expect, the previous example assigns an even value to each enumerated
    constants, starting with 0, as shown in the following output:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所期望的那样，前面的示例为每个枚举常量分配了一个偶数值，从0开始，如下面的输出所示：
- en: '[PRE30]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Skipping enumerated values
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳过枚举值
- en: 'When working with enumerated constants, you may want to throw away certain
    values that should not be part of the enumeration. This can be accomplished by
    assigning iota to the blank identifier at the desired position in the enumeration.
    For instance, the following skips the values 0 and `64`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用枚举常量时，您可能希望丢弃不应成为枚举一部分的某些值。这可以通过将iota分配给枚举中所需位置的空白标识符来实现。例如，以下内容跳过了值0和`64`：
- en: '[PRE31]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: golang.fyi/ch02/enum3.go
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch02/enum3.go
- en: 'Since we skip `iota` position `0`, the first assigned constant value is at
    position `1`. This results in expression `1 << iota` resolving to `1 << 1 = 2`.
    The same is done at the sixth position, where expression `1 << iota` returns `64`.
    That value will be skipped and not assigned to any constant, as shown in the following
    output:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们跳过了“iota”位置“0”，第一个分配的常量值位于位置“1”。这导致表达式`1 << iota`解析为`1 << 1 = 2`。在第六个位置也是同样的情况，表达式`1
    << iota`返回`64`。该值将被跳过，不会被分配给任何常量，如下面的输出所示：
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Go operators
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go运算符
- en: Staying true to its simplistic nature, operators in Go do exactly what you would
    expect, mainly, they allow operands to be combined into expressions. There are
    no hidden surprise behaviors with Go operators as there is no support for operator-overloading
    as found in C++ or Scala. This was a deliberate decision from the designers to
    keep the semantics of the language simple and predictable.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 忠实于其简单的本质，Go中的运算符确切地执行您所期望的操作，主要是允许操作数组合成表达式。与C++或Scala中发现的运算符重载不同，Go运算符没有隐藏的意外行为。这是设计者故意做出的决定，以保持语言的语义简单和可预测。
- en: This section explores the most common operators that you will encounter as you
    start with Go. Other operators are covered throughout other chapters of the book.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了您在开始使用Go时会遇到的最常见的运算符。其他运算符将在本书的其他章节中介绍。
- en: Arithmetic operators
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算符
- en: The following table summarizes the arithmetic operators supported in Go.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表总结了Go中支持的算术运算符。
- en: '| **Operator** | **Operation** | **Compatible types** |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **操作** | **兼容类型** |'
- en: '| `*`, `/`, `-` | Multiplication, division, and subtraction | Integers, floating
    points, and complex numbers |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '`*`，`/`，`-` | 乘法，除法和减法 | 整数，浮点数和复数 |'
- en: '| `%` | Remainder | Integers |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '`%` | 余数 | 整数 |'
- en: '| `+` | Addition | Integers, floating points, complex numbers, and strings
    (concatenation) |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: 加法 | 整数，浮点数，复数和字符串（连接） |
- en: Note that the addition operator, `+`, can be applied to strings such as in the
    expression `var i = "G is" + " for Go"`. The two string operands are concatenated
    to create a new string that is assigned to variable `i`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，加法运算符`+`可以应用于字符串，例如表达式`var i = "G is" + " for Go"`。这两个字符串操作数被连接以创建一个新的字符串，该字符串被分配给变量`i`。
- en: The increment and decrement operators
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增量和减量运算符
- en: 'As with other C-like languages, Go supports the `++` (increment) and the `--`
    (decrement) operators. When applied, these operators increase, or decrease, the
    operand''s value by one, respectively. The following shows a function that uses
    the decrement operator to traverse the letters in string s in the reverse order:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类似C的语言一样，Go支持`++`（增量）和`--`（减量）运算符。当应用时，这些运算符分别增加或减少操作数的值。以下是一个使用减量运算符以相反顺序遍历字符串s中的字母的函数示例：
- en: '[PRE33]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It is important to note that the increment and decrement operators are statements,
    not expressions, as shown in the following snippets:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，增量和减量运算符是语句，而不是表达式，如下面的示例所示：
- en: '[PRE34]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the preceding examples, it is worth noting that the increment and decrement
    statements only support the postfix notation. The following snippet would not
    compile because of statement -`i`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，值得注意的是增量和减量语句只支持后缀表示法。以下代码段不会编译，因为有语句-`i`：
- en: '[PRE35]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Go assignment operators
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go赋值运算符
- en: '| **Operator** | **Description** |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** |'
- en: '| `=` | The simple assignment works as expected. It updates the left operand
    with the value of the right. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `=` | 简单赋值按预期工作。它使用右侧的值更新左侧的操作数。'
- en: '| `:=` | The colon-equal operator declares a new variable, the left-side operator,
    and assigns it the value (and type) of the operand on the right. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `:=` | 冒号等号运算符声明一个新变量，左侧操作数，并将其赋值为右侧操作数的值（和类型）。'
- en: '| `+=`, `-=`, `*=`, `/=`, `%=` | Apply the indicated operation using the left
    and the right operator and store the result in the left operator. For instance,
    `a *= 8` implies `a = a * 8`. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `+=`, `-=`, `*=`, `/=`, `%=` | 使用左操作数和右操作数应用指定的操作，并将结果存储在左操作数中。例如，`a *= 8`意味着`a
    = a * 8`。'
- en: Bitwise operators
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位运算符
- en: 'Go includes full support for manipulating values at their most elemental forms.
    The following summarizes bitwise operators supported by Go:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Go包括对操作值的最基本形式的完全支持。以下总结了Go支持的位运算符：
- en: '| **Operator** | **Description** |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** |'
- en: '| `&` | Bitwise AND |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `&` | 位与 |'
- en: '| `&#124;` | Bitwise OR |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 位或 |'
- en: '| `a ^ b` | Bitwise XOR |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `a ^ b` | 位异或 |'
- en: '| `&^` | Bitwise AND NOT |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `&^` | 位清空 |'
- en: '| `^a` | Unary bitwise complement |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `^a` | 一元位补码'
- en: '| `<<` | Left-shift |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `<<` | 左移 |'
- en: '| `>>` | Right-shift |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: 右移
- en: The right operand, in a shift operation, must be an unsigned integer or be able
    to be converted to an unsigned value. When the left operand is an untyped constant
    value, the compiler must be able to derive a signed integer type from its value
    or it will fail compilation.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在移位操作中，右操作数必须是无符号整数或能够转换为无符号值。当左操作数是无类型常量值时，编译器必须能够从其值中推导出有符号整数类型，否则将无法通过编译。
- en: The shift operators in Go also support both arithmetic and logical shifts. If
    the left operand is unsigned, Go automatically applies logical shift, whereas
    if it is signed, Go will apply an arithmetic shift.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的移位运算符也支持算术和逻辑移位。如果左操作数是无符号的，Go会自动应用逻辑移位，而如果它是有符号的，Go将应用算术移位。
- en: Logical Operators
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'The following is a list of Go logical operations on Boolean values:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于布尔值的Go逻辑操作的列表：
- en: '| **Operator** | **Operation** |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **操作** |'
- en: '| `&&` | Logical AND |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `&&` | 逻辑与 |'
- en: '| `&#124;&#124;` | Logical OR |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;&#124;` | 逻辑或 |'
- en: '| `!` | Logical NOT |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `!` | 逻辑非 |'
- en: Comparison operators
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较运算符
- en: 'All Go types can be tested for equality, including basic and composite types.
    However, only string, integer, and floating-point values can be compared using
    ordering operators, as is summarized in the following table:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Go类型都可以进行相等性测试，包括基本类型和复合类型。然而，只有字符串、整数和浮点值可以使用排序运算符进行比较，如下表所总结的：
- en: '| **Operator** | **Operation** | **Supported type** |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **操作** | **支持的类型** |'
- en: '| `==` | Equal | String, numeric, Boolean, interface, pointer, and struct types
    |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `==` | 相等 | 字符串、数字、布尔、接口、指针和结构类型 |'
- en: '| `!=` | Not Equal | String, numeric, Boolean, interface, pointer, and struct
    types |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `!=` | 不等 | 字符串、数字、布尔、接口、指针和结构类型 |'
- en: '| `<`, `<=`, `>`, `>=` | Ordering operators | String, integers, and floating
    points |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `<`, `<=`, `>`, `>=` | 排序运算符 | 字符串、整数和浮点数 |'
- en: Operator precedence
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符优先级
- en: 'Since Go has fewer operators than are found in its counterparts such as C or
    Java, its operator precedence rules are far simpler. The following table lists
    Go''s operator precedence echelon, starting with the highest:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Go的运算符比C或Java等语言中的运算符要少，因此其运算符优先级规则要简单得多。以下表格列出了Go的运算符优先级，从最高开始：
- en: '| **Operation** | **Precedence** |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **优先级** |'
- en: '| Multiplicative | `*`, `/`, `%`, `<<`, `>>`, `&`, `&^` |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 乘法 | `*`, `/`, `%`, `<<`, `>>`, `&`, `&^` |'
- en: '| Additive | `+`, `-`, `&#124;`, `^` |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| 加法 | `+`, `-`, `&#124;`, `^` |'
- en: '| Comparative | `==`, `!=`, `<`, `<=`, `>`, `>=` |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 比较 | `==`, `!=`, `<`, `<=`, `>`, `>=` |'
- en: '| Logical AND | `&&` |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑与 | `&&` |'
- en: '| Logical OR | `&#124;&#124;` |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑或 | `&#124;&#124;` |'
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered a lot of ground around the basic constructs of the Go language.
    It started with the structure of Go's source code text file and progressed to
    cover variable identifiers, declarations, and initializations. The chapter also
    provided extensive coverage of Go constants, constant declaration, and operators.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了Go语言的基本构造的许多内容。它从Go源代码文本文件的结构开始，并逐步介绍了变量标识符、声明和初始化。本章还广泛介绍了Go常量、常量声明和运算符。
- en: At this point, you may feel a bit overwhelmed by so much pedestrian information
    about the language and its syntax. The good news is that you don't have to know
    all of these details to be productive with the language. In the following chapters,
    we will continue to explore some of the more interesting bits about Go, including
    data types, functions, and packages.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能会对语言及其语法的如此多的基本信息感到有些不知所措。好消息是，您不必了解所有这些细节才能有效地使用该语言。在接下来的章节中，我们将继续探讨关于Go的一些更有趣的部分，包括数据类型、函数和包。
