- en: Nitty-Gritty Grammar
  prefs: []
  type: TYPE_NORMAL
- en: When comparing two programming languages, there are bound to be structural and
    grammatical differences. The good news is that both Python and JavaScript are
    very human-readable languages, so the context switch from Python to JavaScript
    and Node.js shouldn't be too taxing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Style is a good question, though: tabs or spaces? Semicolons or not? Many stylistic
    questions that arise when writing in any programming languages have been answered
    by the dicta contained within Python''s PEP-8 style guide. While JavaScript doesn''t
    have an official style guide, don''t worry—it''s not the Wild West out there.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we can write JavaScript, we must know what it is to be able to read it
    and understand it. All programming languages vary from one to another, and using
    your Python knowledge to learn a new language will require a bit of reframing
    of your thoughts. For example, what does JavaScript look like when we want to
    declare variables? How is it constructed so that the computer understands it?
    What do we need to watch out for as we progress?
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is the key to unlocking what JavaScript can do and how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A history of style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grammar rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Punctuation and readability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The elephant in the room – whitespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Existing standards – linting to the rescue!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To code along with the examples in this chapter, you have a few choices:'
  prefs: []
  type: TYPE_NORMAL
- en: Code directly in the JavaScript console in your browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code in the Node command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a web editor, such as [jsfiddle.net](https://jsfiddle.net) or [codepen.io](https://codepen.io)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a web editor may be preferable as you can easily save your progress. You
    should familiarize yourself with bringing up the JavaScript console in the browser
    anyway, as we'll be using it for debugging output. This is usually in the View menu
    in your browser; consult your browser's documentation for how to find it if it's
    not immediately obvious, as some browsers require turning on Developer mode in Preferences.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-3/Linting](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-3/Linting).
  prefs: []
  type: TYPE_NORMAL
- en: A history of style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every programming language has its own style, designed to ease legibility and
    comprehension of each line of code. Some languages are stricter than others; JavaScript
    in its vanilla form is one of the looser languages in adhering to style. *The
    Elements of Programming Style* by Brian W. Kernighan and P. J. Plauger, first
    published in 1974, has a number of aphorisms that have helped shape not only coding
    standards but also programming languages themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be familiar with the PEP-20 aphorisms from *The* *Zen of Python*:'
  prefs: []
  type: TYPE_NORMAL
- en: Beautiful is better than ugly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit is better than implicit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple is better than complex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex is better than complicated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flat is better than nested.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sparse is better than dense.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readability counts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special cases aren't special enough to break the rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although practicality beats purity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Errors should never pass silently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unless explicitly silenced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the face of ambiguity, refuse the temptation to guess.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There should be one—and preferably only one—obvious way to do it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although that way may not be obvious at first unless you're Dutch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now is better than never.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although never is often better than *right* now.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the implementation is hard to explain, it's a bad idea.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the implementation is easy to explain, it may be a good idea.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces are one honking great idea—let's do more of those!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tongue-in-cheek qualities aside, many of these aphorisms are inspired by the
    principles written and experiences gained before Python was developed. First released
    in 1991, Python from the start had an emphasis on code readability and has some
    strict guidelines in place, from PEP-8 to PEP-20.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take, for example, two aphorisms:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **The Elements of Programming Style, 1974** | **The Zen of Python, 1999**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Write clearly—don''t be too clever. | Explicit is better than implicit. |'
  prefs: []
  type: TYPE_TB
- en: Similar ideas are being expressed here. I think most software engineers would
    agree with the statement that being clear, explicit, and legible are good qualities
    to strive for as you develop your program.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one idea to keep strongly in mind, however, as you keep advancing
    in your JavaScript learning: since JavaScript''s syntax is *designed* to be looser
    than that of some other languages, you may find that different companies have
    an in-house style to use for JavaScript code. This is not unique to JavaScript—many
    languages also have style guides in a company to enforce code consistency across
    employees. It also helps the greater ecosystem of the language to have consistently
    readable code. However, this does lead to differences from one code base to another
    in terms of style.'
  prefs: []
  type: TYPE_NORMAL
- en: As with any language, we need to know our grammar to know how we're going to
    write JavaScript. As with Python, the machine expects properly formatted code
    before it does its work, and this is your job. On to grammar.
  prefs: []
  type: TYPE_NORMAL
- en: Grammar rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like with any other programming language, JavaScript has grammar rules
    that are to be followed in order for the computer to understand what our code
    is trying to tell it. These rules are fairly straightforward and range from capitalizing
    and punctuating your code, which enhances the readability, to using specific structures
    within your code and avoiding common words that can confuse meaning. The rules
    of JavaScript syntax are fairly simple and straightforward; they include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Capitalization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reserved words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logic structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Punctuation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capitalization counts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with most programming languages, capitalization makes a difference. The `myNode`
    and `mynode` variables will be interpreted as completely different variables.
    That is, the computer will absolutely see the relationship between `myNode` and `mynode`
    because they are capitalized differently.
  prefs: []
  type: TYPE_NORMAL
- en: Reserved words
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a good number of words reserved in JavaScript that cannot be used
    for variable names. Here is a list of most of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `abstract` `arguments`'
  prefs: []
  type: TYPE_NORMAL
- en: '`await`'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean`'
  prefs: []
  type: TYPE_NORMAL
- en: '`break`'
  prefs: []
  type: TYPE_NORMAL
- en: '`byte`'
  prefs: []
  type: TYPE_NORMAL
- en: '`case`'
  prefs: []
  type: TYPE_NORMAL
- en: '`catch`'
  prefs: []
  type: TYPE_NORMAL
- en: '`char`'
  prefs: []
  type: TYPE_NORMAL
- en: '`class`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const`'
  prefs: []
  type: TYPE_NORMAL
- en: '`continue`'
  prefs: []
  type: TYPE_NORMAL
- en: '`debugger`'
  prefs: []
  type: TYPE_NORMAL
- en: '`default`'
  prefs: []
  type: TYPE_NORMAL
- en: '`delete`'
  prefs: []
  type: TYPE_NORMAL
- en: '`do` | `double` `else`'
  prefs: []
  type: TYPE_NORMAL
- en: '`enum`'
  prefs: []
  type: TYPE_NORMAL
- en: '`eval`'
  prefs: []
  type: TYPE_NORMAL
- en: '`export`'
  prefs: []
  type: TYPE_NORMAL
- en: '`extends`'
  prefs: []
  type: TYPE_NORMAL
- en: '`false`'
  prefs: []
  type: TYPE_NORMAL
- en: '`final`'
  prefs: []
  type: TYPE_NORMAL
- en: '`finally`'
  prefs: []
  type: TYPE_NORMAL
- en: '`float`'
  prefs: []
  type: TYPE_NORMAL
- en: '`for`'
  prefs: []
  type: TYPE_NORMAL
- en: '`function`'
  prefs: []
  type: TYPE_NORMAL
- en: '`goto`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if`'
  prefs: []
  type: TYPE_NORMAL
- en: '`implements`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import` | `in` `instanceof`'
  prefs: []
  type: TYPE_NORMAL
- en: '`int`'
  prefs: []
  type: TYPE_NORMAL
- en: '`interface`'
  prefs: []
  type: TYPE_NORMAL
- en: '`let`'
  prefs: []
  type: TYPE_NORMAL
- en: '`long`'
  prefs: []
  type: TYPE_NORMAL
- en: '`native`'
  prefs: []
  type: TYPE_NORMAL
- en: '`new`'
  prefs: []
  type: TYPE_NORMAL
- en: '`null`'
  prefs: []
  type: TYPE_NORMAL
- en: '`package`'
  prefs: []
  type: TYPE_NORMAL
- en: '`private`'
  prefs: []
  type: TYPE_NORMAL
- en: '`protected`'
  prefs: []
  type: TYPE_NORMAL
- en: '`public`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return`'
  prefs: []
  type: TYPE_NORMAL
- en: '`short`'
  prefs: []
  type: TYPE_NORMAL
- en: '`static` | `super` `switch`'
  prefs: []
  type: TYPE_NORMAL
- en: '`synchronized`'
  prefs: []
  type: TYPE_NORMAL
- en: '`this`'
  prefs: []
  type: TYPE_NORMAL
- en: '`throw`'
  prefs: []
  type: TYPE_NORMAL
- en: '`throws`'
  prefs: []
  type: TYPE_NORMAL
- en: '`transient`'
  prefs: []
  type: TYPE_NORMAL
- en: '`true`'
  prefs: []
  type: TYPE_NORMAL
- en: '`try`'
  prefs: []
  type: TYPE_NORMAL
- en: '`typeof`'
  prefs: []
  type: TYPE_NORMAL
- en: '`var`'
  prefs: []
  type: TYPE_NORMAL
- en: '`void`'
  prefs: []
  type: TYPE_NORMAL
- en: '`volatile`'
  prefs: []
  type: TYPE_NORMAL
- en: '`while`'
  prefs: []
  type: TYPE_NORMAL
- en: '`with`'
  prefs: []
  type: TYPE_NORMAL
- en: '`yield` |'
  prefs: []
  type: TYPE_NORMAL
- en: These are always in lowercase, and if you were to attempt to use one of these
    words as a variable name, the program would show an error.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In JavaScript, it's best practice to declare variables before using them. This
    declaration can happen at the time of assignment to a value, or you can define
    a variable without a value.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike some other languages, JavaScript is *loosely typed*, so you don't need
    to declare what type of variable you're creating. By convention, variables in
    JavaScript start with a lowercase letter and follow camel-casing, rather than
    snake-casing. So, `myAge` is preferable to `my_age` or `MyAge`. Variables cannot
    start with a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three keywords used to declare variables in JavaScript: `const`, `let`,
    and `var`.'
  prefs: []
  type: TYPE_NORMAL
- en: const
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A **const**, short for **constant**, is a variable that is not expected to
    change in value over the course of the program. They''re useful for enforcing
    values that you don''t want to change. Prior to the sixth edition of ECMAScript,
    ES2015 (often called ES6), it was possible to mutate the value of any variable,
    so mistakes such as using an assignment operator (`=`) instead of a comparison
    operator (`==` or `===`) were common:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Sure, Captain Picard *could* change his name, but that doesn't seem very likely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we want to declare a variable as a hard constant, such as pi or
    an API key. These use cases are, in general, the only exception to the naming
    standards, in that they are often all uppercase and sometimes have underscores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have examples of two data types: **strings** and **numbers**. JavaScript
    doesn''t have a concept of *float* versus *int* versus *long*; they''re all numbers.
    If you noticed, we can also declare strings with single or double quotes. Some
    libraries and frameworks have a preference for one over the other, but for standard
    JavaScript, it''s OK to use either. It''s best practice to be consistent in your
    usage, however.'
  prefs: []
  type: TYPE_NORMAL
- en: let
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When declaring a variable using `let`, we explicitly state that we expect or
    allow the value of the variable to change over the course of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Captain Picard can be transferred to another ship at any time, so we want our
    program to allow changes in value.
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The oldest way of defining a variable in JavaScript is with the `var` keyword.
    Declaring with `var` does not place any restrictions on the value of the variable;
    it can be changed.
  prefs: []
  type: TYPE_NORMAL
- en: The use of `var` is still supported but considered legacy and was deprecated
    in ES6\. However, with decades of existing programs and examples, it's important
    to at least be familiar with `var`.
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though JavaScript is loosely typed, it's important to know about the data
    types available to us, as we will need to know them for issues such as comparisons
    and reassignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a rough mapping of the base Pythonic variables to base JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python** | **JavaScript** |'
  prefs: []
  type: TYPE_TB
- en: '| Number | Number |'
  prefs: []
  type: TYPE_TB
- en: '| String | String |'
  prefs: []
  type: TYPE_TB
- en: '| List | Array |'
  prefs: []
  type: TYPE_TB
- en: '| Dictionary | Object |'
  prefs: []
  type: TYPE_TB
- en: '| Set | Set |'
  prefs: []
  type: TYPE_TB
- en: 'This covers the base types you''re likely to use. Let''s examine other, more
    nuanced JavaScript data types. Some have equivalents in Python and some don''t:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python** | **JavaScript Semi-Equivalent** | **Reason for Difference** |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `boolean` | While the data types are identical in practice, Python''s
    `bool` data type inherits from `int`. While `1` and `0` can be used in JavaScript
    to represent `True` and `False`, they will not be recognized as the `boolean`
    type. |'
  prefs: []
  type: TYPE_TB
- en: '| `None` | `null` | Technically, `None` is an object in and of itself, whereas
    `null` is a falsy value. |'
  prefs: []
  type: TYPE_TB
- en: '|  | `undefined` | In JavaScript, a variable that has not been declared with
    a value still has a pseudovalue: the singleton of the `undefined` value. |'
  prefs: []
  type: TYPE_TB
- en: '|  | `object` | Both Python and JavaScript are object-oriented languages, but
    their use of objects is a bit different. The base use of an object in JavaScript
    is a key-value store. Objects are not primitives and can store multiple types
    of data. |'
  prefs: []
  type: TYPE_TB
- en: '|  | `symbol` | Symbols are a new data type in ES6\. While the uses are nuanced,
    they''re worth mentioning. They are used to create unique identifiers for objects.
    |'
  prefs: []
  type: TYPE_TB
- en: Now, we need to find out a bit more about types before we can use them, including
    how to compare them and work with them.
  prefs: []
  type: TYPE_NORMAL
- en: typeof and equality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Even though variable types are mutable, it''s often useful to know what data
    type a variable is at that moment. The `typeof` operator helps us do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the return values are strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'When comparing variables, there are two equality operators: loose and strict
    equality. Let''s take a look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If we were to run this comparison, we would have the result of `true`. However,
    we can see that `myAge` is a number, while `age` is a string. The reason the result
    is `true` is that when using the loose equality operator (the double-equals),
    JavaScript uses *type coercion* in an attempt to be helpful. When comparing variables
    of different types, the values are loosely compared, so while `38` and `"38"`
    are different types, the result of the comparison is truthy because of their values.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can imagine, this can have some unexpected behavior. To ask JavaScript
    to include the type in the comparison, use the *strict equality* operator: the
    triple-equals.'
  prefs: []
  type: TYPE_NORMAL
- en: With our preceding example, we can try `myAge === age` and will get the result
    of `false` because they are different data types. It's usually considered best
    practice to use strict equality to avoid type coercion unless you have a specific
    need to use loose equality.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays and objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Arrays and objects are not primitives and can contain mixed types. Here are
    a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`officers` is an **array**, as we can see with the square brackets. One of
    the interesting facts about arrays is that even though we usually declare them
    as a const, the values *inside* the array can be changed. `.push()` and `.pop()`
    are two useful methods for manipulating arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the values in the array are not ordered in any way; we can get
    `Riker` by accessing the array with bracket notation: `officers[0]`. However,
    if we were to try to completely reassign the array, we would still get an error
    when reassigning a declared const. Arrays can hold any combination of data types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One very handy property of arrays that we''ll be using is `.length`. Since
    it''s a property, it does not use parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that even though arrays are zero-indexed, the `length` property is not.
    There *are* four elements in the array, with *indices* from 0 to 3.
  prefs: []
  type: TYPE_NORMAL
- en: We'll discuss methods and properties more throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Objects** are a very strong foundational component of JavaScript. In fact,
    technically (almost) everything in JavaScript *is* an object! Our array methods
    can be accessed via dot notation specifically because an array is technically
    a type of object. We can''t, however, access the *values *of an array with dot
    notation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at `captain`, we can see three different data types: string, number,
    and array. Objects can have nested objects as well. As part of their function
    as key-value stores, the key should be a string. To access a value, we use dot
    notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can access parts of an object with dot notation, which is similar to a **dict**
    in Python, but not quite! The nuances will become more clear as we work with objects
    since they are fundamental to what makes JavaScript unique.
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at an `if`/`else` statement written in two ways in both
    Python and JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python** | **JavaScript** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'In both columns, the code is doing the same thing: a simple test to see whether `a`
    is less than `b` and then assigning the smaller value to the `min` variable. The
    first row is a full `if`/`else` statement and the second row uses the ternary
    structure. There are a few grammar rules to note in these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`min` must be declared before use, as a best practice. In strict mode, this
    would actually throw an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `if` clause is encapsulated with parentheses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `if`/`else` statements are encapsulated with curly braces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The keywords and operators in the ternary are significantly different (and a
    bit more cryptic) than in Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we wanted to use what we now know about `typeof`, we can use strict equality
    to understand our variables a bit more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are four main types of loops in JavaScript: `for`, `while`, `do`/`while`,
    and `for..in`. (There are a couple of other ways to structure a loop, but these
    are the main ones.) Their use cases shouldn''t be much of a surprise.'
  prefs: []
  type: TYPE_NORMAL
- en: for loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use an iterator to execute code a specified number of times:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python** | **JavaScript** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you may be wondering, "if JavaScript has a `for..in` loop, why aren''t
    we using it?". As it turns out, `for/in` of Python and `for..in` of JavaScript
    are *false cognates*: their names look alike but are very different in use. We''ll
    discuss JavaScript''s `for..in` loop shortly. Also, note how we needed to have
    three clauses in our `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a869732b-aee6-483a-80d5-041b081918d6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 - Declaration, Condition, and Execution stages of a `for` loop
  prefs: []
  type: TYPE_NORMAL
- en: The **declaration** will either define an iterator or use an existing mutable
    variable. Note that it should be a mutable number!
  prefs: []
  type: TYPE_NORMAL
- en: Our **condition** is what we're testing. We want our loop to run while `i` is
    less than `names.length`. Since `name.length` is `3`, we will run our loop three
    times, or until `i` equals `4`, which no longer meets our condition.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of every iteration of our loop, we **execute** something; usually
    a simple incrementing of our declaration. Now, notice the semicolons in between
    each of our clauses…unlike in other parts of JavaScript, these are *not* optional.
    There isn't one placed after the execution portion.
  prefs: []
  type: TYPE_NORMAL
- en: while loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The JavaScript `while` loop is identical in use to its Pythonic equivalent,
    minus a little grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python** | **JavaScript** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: do/while loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the name implies, the `do`/`while` loop executes the `do` code when a given
    condition equals `true`. Take a look at the JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: for..in loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, I promised to explain why Python's `for..in` is different from JavaScript's
    usage. The difference is that JavaScript's `for..in` is used to iterate over keys
    in an object, whereas Python's `for..in` is used as a loop over a discrete set
    of entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: What do you think `myString` now equals? Since the purpose of `for..in` in *JavaScript* is
    to go over each *key* in the object, it's `Jean-Luc Picard 62 SP 937-215 NCC 1701-D
    Riker,Data,Worf`.
  prefs: []
  type: TYPE_NORMAL
- en: for..of loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is one more `for` loop: `for..of`, which differs from `for..in`. The `for..of`loop
    iterates through values of any iterable, such as arrays, strings, sets, and similar.
    If we want to iterate over `officers` and log out each name, we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Next up, we'll discuss functions!
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ah, functions. We love them because they''re the key to modular, **don''t-repeat-yourself**
    (**DRY**) programs. The use cases in JavaScript and Python are the same: blocks
    of code intended to be called more than once, usually with varying parameters.
    Parameters are the variables that a function will take in order to execute its
    code on a mutable dataset. Arguments are what we pass when we call a function.
    They''re the same thing in essence, but have different words depending on where
    and when they''re used: are they the abstraction, or are they the actual data?
    Let''s take a look at a side-by-side comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python** | **JavaScript** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't already brought up the JavaScript console in your browser, you
    should do that now to see our output of `6`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that the structure is fairly similar, with our parameter being
    passed in parentheses. As noted before, we prefer camel-case in JavaScript and
    encapsulate with curly braces. Calling the function with our argument of `5` is
    the same. For conciseness, we can increment `val` with the `++` operator on the
    left before `return` executes. Such shortcuts are common in JavaScript, but remember
    to use them judiciously: "Write clearly—don''t be too clever."'
  prefs: []
  type: TYPE_NORMAL
- en: However, JavaScript actually has two different ways to declare a function, plus
    a newer syntax introduced in ES6.
  prefs: []
  type: TYPE_NORMAL
- en: Function declarations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`addOne()` in the preceding code is an example of a *function declaration*.
    It uses the function keyword to declare our functionality. Its anatomy is just
    as simple as it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Function expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s an example of `addOne()`, constructed as a function expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Function expressions should use `const` in the expression, though it is not
    syntactically incorrect to use `var` or `let`.
  prefs: []
  type: TYPE_NORMAL
- en: What's the difference between declarations and expressions? The core difference
    is that a function *declaration* can be used anywhere in your program because
    it's *hoisted* to the top. As JavaScript is interpreted top-down; this is a major
    exception to that paradigm. So, conversely, using an *expression* must occur after
    the expression is written.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ES6 introduced the arrow syntax of writing function expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To further complicate matters, we can omit the parentheses around `val` because
    there''s only one parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The main difference between arrow functions and expressions is centered around
    *lexical scoping*. We touched on scope with *hoisting*, and we'll discuss it in
    more detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with any language, comments are important. There are two ways to declare
    comments in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we can start a comment with `//` and write text until the end of the line.
    We can have a full-line comment with `//` and we can also have a multiline comment
    with `/*`, ending with `*/`. Additionally, you may encounter comments in the JSDoc
    style, used for inline documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: More information on JSDoc is included in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Methods and properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we've seen `.push()` and `.pop()` as methods of array instances. In
    JavaScript, a **method** is simply a function inherent to its data type that operates
    on the data and properties of a variable. I mentioned before that nearly everything
    in JavaScript is an object, and that is not an exaggeration. From functionality
    and syntax to structure and usage, there are many similarities between the raw
    data type of an *object* and any other variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part of our understanding of the syntax of JavaScript is everyone''s
    favorite: punctuation. While it may seem trivial, it''s very important for the
    interpretation, by both humans and computers, of the code.'
  prefs: []
  type: TYPE_NORMAL
- en: Punctuation and readability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with every language, JavaScript has conventions on punctuation and how spacing
    affects readability. Let''s take a look at a few ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**Java**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**C++**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '**JavaScript**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In JavaScript, the conventions of the preceding example are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: No space between the function name and the parentheses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single space before the curly brace, which is on the same line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The closing curly brace is on its own line, aligned with the opening statement
    of `function`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There''s also one more modern point to make here about JavaScript and the examples
    we''ll be using in this book versus what you may encounter in the field and examples
    online: **semicolons**.'
  prefs: []
  type: TYPE_NORMAL
- en: With few exceptions, in modern JavaScript, semicolons at the end of statements
    are *optional*. It used to be a best practice to always terminate statement lines
    with semicolons, and you'll see a lot of semicolons in existing code. This is
    a question of style from company to company, project to project, and library to
    library. There are some standards in place, as we'll discuss shortly with linting,
    but for the purposes of this book, we will *not* be using semicolons to terminate
    statements, except in such cases as required by syntax (such as we saw in our
    loops).
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also important to note that nested lines should be indented by two spaces.
    Two versus four is a style question, also, but in this book, we''ll be using **two
    spaces**. One way to help maintain consistency is to configure your code editor
    to translate tabs into two spaces (or four, as desired). That way, you just hit
    *Tab* instead of worrying about how many times you mashed the space bar. I won''t
    expound on the importance of proper indentation, but remember: the more your code
    adheres to styles and best practices, the more legible it will be to those who
    maintain your code—and to your future self!'
  prefs: []
  type: TYPE_NORMAL
- en: The elephant in the room – whitespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OK, OK, we know that Python is whitespace-delimited: tabs matter! However,
    JavaScript really *doesn''t* care about whitespace in most cases. As we saw before,
    indentation and whitespace is a matter of *style*, not *syntax*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So here''s the thing: when I was first learning Python, the idea of a language
    that was whitespace-dependent was abhorrent. "How could a language that could
    break with an improper IDE setting survive?", I thought. My opinions aside, the
    good news is that indentation in Python is parallel to indentation plus curly
    braces in JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python** | **JavaScript** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: If you notice, our `if` statement inside our Python function is indented in
    the same way that this JavaScript example is indented, albeit without the curly
    braces. So yay! Your adherence to Pythonic indentation dicta actually comes *quite*
    in handy in JavaScript! While it's not required to include whitespace *à la* Python,
    it does definitely improve legibility.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the day, JavaScript likes indentation as much as Python because
    it makes for more readable code, though it's not required for your program to
    run.
  prefs: []
  type: TYPE_NORMAL
- en: Existing standards – linting to the rescue!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve looked at JavaScript''s conventions and norms, but most rules have a
    caveat that "this could vary" or "this isn''t technically required." So, how do
    we make sense of our code in a malleable, opinion-driven environment? One answer:
    *linting*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply put, **linting** refers to the process of running your code through
    predefined rules to ensure that not only is it syntactically correct, but it also
    adheres to proper style rules. This isn''t a practice limited to JavaScript; you
    may have linted your Python code, too. In modern JavaScript, linting has come
    to be seen as a best practice to ensure your code is consistent. Two of the main
    style guides in the community are AirBnB ([https://github.com/airbnb/javascript](https://github.com/airbnb/javascript)) and
    Google ([https://google.github.io/styleguide/jsguide.html](https://google.github.io/styleguide/jsguide.html)).
    Your code editor probably supports using a linter, but we won''t go into using
    them in practice right now, as each editor varies in setup. Here''s a quick look
    at what it can look like in Atom:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7dd21500-86c8-4ab5-84c7-58bf85c03d90.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 - Linting error in Atom
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, know that standards do exist, though they may vary from style
    guide to style guide. You can clone a repository demonstrating linting from [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-3/Linting](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-3/Linting).
  prefs: []
  type: TYPE_NORMAL
- en: There are several popular linting tools available, such as ESLint and Prettier.
    The tool you choose can be customized to the style guide you choose to work with.
  prefs: []
  type: TYPE_NORMAL
- en: OK, that's a lot for one chapter! Let's wrap up.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript has a rich grammar and syntax, developed over years of use and refinement.
    Using ES6, we have a whole host of data types, methods of declaring functions,
    and code standards. While writing JavaScript can seem to be playing very loose
    and fast, there are best practices, and the fundamentals of the language are as
    robust as other languages. Remember that capitalization counts; don't use reserved
    words for variable names; use `const` or `let` to declare your variables; even
    though JavaScript is loosely typed, data types are important; and conditionals,
    loops, and functions all help structure the logic of your code.
  prefs: []
  type: TYPE_NORMAL
- en: A mastery of the grammar and syntax of JavaScript is vital to understanding
    how to use this robust language, so take your time familiarizing yourself with
    the details and intricacies. Moving forward, we will presume you have fluency
    in JavaScript's style as we get into more difficult material.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will get our hands dirty with data and understanding
    how JavaScript works with and models data.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try your hand at answering the following questions to test your knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following is not a valid JavaScript variable declaration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`var myVar = ''hello'';`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`const myVar = "hello"`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`String myVar = "hello";`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`let myVar = "hello"`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of these starts a function declaration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`function`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`const`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`func`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`def`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of these is not a basic loop type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`for..in`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`for`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`while`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`map`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false – JavaScript *requires* line delineation with semicolons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false – whitespace *never* counts in JavaScript.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: B. W. Kernighan and P. J. Plauger, *The Elements of Programming Style 2nd Edition*,
    McGraw Hill, New York, 1978\. ISBN 0-07-034207-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PEP-8 – *A Style Guide for Python Code*: [https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PEP-20 – *The Zen of Python*: [https://www.python.org/dev/peps/pep-0020/](https://www.python.org/dev/peps/pep-0020/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JSDoc: [http://usejsdoc.org/](http://usejsdoc.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
