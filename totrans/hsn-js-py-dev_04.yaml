- en: Nitty-Gritty Grammar
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: When comparing two programming languages, there are bound to be structural and
    grammatical differences. The good news is that both Python and JavaScript are
    very human-readable languages, so the context switch from Python to JavaScript
    and Node.js shouldn't be too taxing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Style is a good question, though: tabs or spaces? Semicolons or not? Many stylistic
    questions that arise when writing in any programming languages have been answered
    by the dicta contained within Python''s PEP-8 style guide. While JavaScript doesn''t
    have an official style guide, don''t worry—it''s not the Wild West out there.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Before we can write JavaScript, we must know what it is to be able to read it
    and understand it. All programming languages vary from one to another, and using
    your Python knowledge to learn a new language will require a bit of reframing
    of your thoughts. For example, what does JavaScript look like when we want to
    declare variables? How is it constructed so that the computer understands it?
    What do we need to watch out for as we progress?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is the key to unlocking what JavaScript can do and how to do it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: A history of style
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grammar rules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Punctuation and readability
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The elephant in the room – whitespace
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Existing standards – linting to the rescue!
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To code along with the examples in this chapter, you have a few choices:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Code directly in the JavaScript console in your browser
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code in the Node command line
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a web editor, such as [jsfiddle.net](https://jsfiddle.net) or [codepen.io](https://codepen.io)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a web editor may be preferable as you can easily save your progress. You
    should familiarize yourself with bringing up the JavaScript console in the browser
    anyway, as we'll be using it for debugging output. This is usually in the View menu
    in your browser; consult your browser's documentation for how to find it if it's
    not immediately obvious, as some browsers require turning on Developer mode in Preferences.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-3/Linting](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-3/Linting).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: A history of style
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every programming language has its own style, designed to ease legibility and
    comprehension of each line of code. Some languages are stricter than others; JavaScript
    in its vanilla form is one of the looser languages in adhering to style. *The
    Elements of Programming Style* by Brian W. Kernighan and P. J. Plauger, first
    published in 1974, has a number of aphorisms that have helped shape not only coding
    standards but also programming languages themselves.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be familiar with the PEP-20 aphorisms from *The* *Zen of Python*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Beautiful is better than ugly.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit is better than implicit.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple is better than complex.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex is better than complicated.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flat is better than nested.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sparse is better than dense.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readability counts.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special cases aren't special enough to break the rules.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although practicality beats purity.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Errors should never pass silently.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unless explicitly silenced.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the face of ambiguity, refuse the temptation to guess.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There should be one—and preferably only one—obvious way to do it.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although that way may not be obvious at first unless you're Dutch.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now is better than never.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although never is often better than *right* now.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the implementation is hard to explain, it's a bad idea.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the implementation is easy to explain, it may be a good idea.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces are one honking great idea—let's do more of those!
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tongue-in-cheek qualities aside, many of these aphorisms are inspired by the
    principles written and experiences gained before Python was developed. First released
    in 1991, Python from the start had an emphasis on code readability and has some
    strict guidelines in place, from PEP-8 to PEP-20.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take, for example, two aphorisms:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '| **The Elements of Programming Style, 1974** | **The Zen of Python, 1999**
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| Write clearly—don''t be too clever. | Explicit is better than implicit. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: Similar ideas are being expressed here. I think most software engineers would
    agree with the statement that being clear, explicit, and legible are good qualities
    to strive for as you develop your program.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one idea to keep strongly in mind, however, as you keep advancing
    in your JavaScript learning: since JavaScript''s syntax is *designed* to be looser
    than that of some other languages, you may find that different companies have
    an in-house style to use for JavaScript code. This is not unique to JavaScript—many
    languages also have style guides in a company to enforce code consistency across
    employees. It also helps the greater ecosystem of the language to have consistently
    readable code. However, this does lead to differences from one code base to another
    in terms of style.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: As with any language, we need to know our grammar to know how we're going to
    write JavaScript. As with Python, the machine expects properly formatted code
    before it does its work, and this is your job. On to grammar.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Grammar rules
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like with any other programming language, JavaScript has grammar rules
    that are to be followed in order for the computer to understand what our code
    is trying to tell it. These rules are fairly straightforward and range from capitalizing
    and punctuating your code, which enhances the readability, to using specific structures
    within your code and avoiding common words that can confuse meaning. The rules
    of JavaScript syntax are fairly simple and straightforward; they include the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Capitalization
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reserved words
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable syntax
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data types
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logic structures
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Punctuation
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capitalization counts
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with most programming languages, capitalization makes a difference. The `myNode`
    and `mynode` variables will be interpreted as completely different variables.
    That is, the computer will absolutely see the relationship between `myNode` and `mynode`
    because they are capitalized differently.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Reserved words
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a good number of words reserved in JavaScript that cannot be used
    for variable names. Here is a list of most of them:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '| `abstract` `arguments`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '`await`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '`break`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '`byte`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '`case`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '`catch`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '`char`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '`class`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '`const`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '`continue`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '`debugger`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '`default`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '`delete`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '`do` | `double` `else`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '`enum`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '`eval`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '`export`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '`extends`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '`false`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '`final`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '`finally`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '`float`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '`for`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '`function`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '`goto`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '`if`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '`implements`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '`import` | `in` `instanceof`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '`int`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '`interface`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '`let`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '`long`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '`native`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '`new`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '`null`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '`package`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '`private`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '`protected`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '`public`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '`return`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '`short`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '`static` | `super` `switch`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '`synchronized`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '`this`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '`throw`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '`throws`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '`transient`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '`true`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '`try`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '`typeof`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '`var`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '`void`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '`volatile`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '`while`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '`with`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '`yield` |'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: These are always in lowercase, and if you were to attempt to use one of these
    words as a variable name, the program would show an error.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Declaring variables
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In JavaScript, it's best practice to declare variables before using them. This
    declaration can happen at the time of assignment to a value, or you can define
    a variable without a value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Unlike some other languages, JavaScript is *loosely typed*, so you don't need
    to declare what type of variable you're creating. By convention, variables in
    JavaScript start with a lowercase letter and follow camel-casing, rather than
    snake-casing. So, `myAge` is preferable to `my_age` or `MyAge`. Variables cannot
    start with a number.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three keywords used to declare variables in JavaScript: `const`, `let`,
    and `var`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: const
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A **const**, short for **constant**, is a variable that is not expected to
    change in value over the course of the program. They''re useful for enforcing
    values that you don''t want to change. Prior to the sixth edition of ECMAScript,
    ES2015 (often called ES6), it was possible to mutate the value of any variable,
    so mistakes such as using an assignment operator (`=`) instead of a comparison
    operator (`==` or `===`) were common:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Sure, Captain Picard *could* change his name, but that doesn't seem very likely.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we want to declare a variable as a hard constant, such as pi or
    an API key. These use cases are, in general, the only exception to the naming
    standards, in that they are often all uppercase and sometimes have underscores:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So far, we have examples of two data types: **strings** and **numbers**. JavaScript
    doesn''t have a concept of *float* versus *int* versus *long*; they''re all numbers.
    If you noticed, we can also declare strings with single or double quotes. Some
    libraries and frameworks have a preference for one over the other, but for standard
    JavaScript, it''s OK to use either. It''s best practice to be consistent in your
    usage, however.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: let
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When declaring a variable using `let`, we explicitly state that we expect or
    allow the value of the variable to change over the course of the program:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Captain Picard can be transferred to another ship at any time, so we want our
    program to allow changes in value.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: var
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The oldest way of defining a variable in JavaScript is with the `var` keyword.
    Declaring with `var` does not place any restrictions on the value of the variable;
    it can be changed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The use of `var` is still supported but considered legacy and was deprecated
    in ES6\. However, with decades of existing programs and examples, it's important
    to at least be familiar with `var`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though JavaScript is loosely typed, it's important to know about the data
    types available to us, as we will need to know them for issues such as comparisons
    and reassignment.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a rough mapping of the base Pythonic variables to base JavaScript:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python** | **JavaScript** |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| Number | Number |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| String | String |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| List | Array |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '| Dictionary | Object |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '| Set | Set |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: 'This covers the base types you''re likely to use. Let''s examine other, more
    nuanced JavaScript data types. Some have equivalents in Python and some don''t:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python** | **JavaScript Semi-Equivalent** | **Reason for Difference** |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `boolean` | While the data types are identical in practice, Python''s
    `bool` data type inherits from `int`. While `1` and `0` can be used in JavaScript
    to represent `True` and `False`, they will not be recognized as the `boolean`
    type. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| `None` | `null` | Technically, `None` is an object in and of itself, whereas
    `null` is a falsy value. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '|  | `undefined` | In JavaScript, a variable that has not been declared with
    a value still has a pseudovalue: the singleton of the `undefined` value. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '|  | `object` | Both Python and JavaScript are object-oriented languages, but
    their use of objects is a bit different. The base use of an object in JavaScript
    is a key-value store. Objects are not primitives and can store multiple types
    of data. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '|  | `symbol` | Symbols are a new data type in ES6\. While the uses are nuanced,
    they''re worth mentioning. They are used to create unique identifiers for objects.
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: Now, we need to find out a bit more about types before we can use them, including
    how to compare them and work with them.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: typeof and equality
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Even though variable types are mutable, it''s often useful to know what data
    type a variable is at that moment. The `typeof` operator helps us do that:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that the return values are strings.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'When comparing variables, there are two equality operators: loose and strict
    equality. Let''s take a look at some examples:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If we were to run this comparison, we would have the result of `true`. However,
    we can see that `myAge` is a number, while `age` is a string. The reason the result
    is `true` is that when using the loose equality operator (the double-equals),
    JavaScript uses *type coercion* in an attempt to be helpful. When comparing variables
    of different types, the values are loosely compared, so while `38` and `"38"`
    are different types, the result of the comparison is truthy because of their values.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can imagine, this can have some unexpected behavior. To ask JavaScript
    to include the type in the comparison, use the *strict equality* operator: the
    triple-equals.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: With our preceding example, we can try `myAge === age` and will get the result
    of `false` because they are different data types. It's usually considered best
    practice to use strict equality to avoid type coercion unless you have a specific
    need to use loose equality.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Arrays and objects
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Arrays and objects are not primitives and can contain mixed types. Here are
    a few examples:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`officers` is an **array**, as we can see with the square brackets. One of
    the interesting facts about arrays is that even though we usually declare them
    as a const, the values *inside* the array can be changed. `.push()` and `.pop()`
    are two useful methods for manipulating arrays:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice that the values in the array are not ordered in any way; we can get
    `Riker` by accessing the array with bracket notation: `officers[0]`. However,
    if we were to try to completely reassign the array, we would still get an error
    when reassigning a declared const. Arrays can hold any combination of data types.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'One very handy property of arrays that we''ll be using is `.length`. Since
    it''s a property, it does not use parentheses:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that even though arrays are zero-indexed, the `length` property is not.
    There *are* four elements in the array, with *indices* from 0 to 3.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: We'll discuss methods and properties more throughout this chapter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**Objects** are a very strong foundational component of JavaScript. In fact,
    technically (almost) everything in JavaScript *is* an object! Our array methods
    can be accessed via dot notation specifically because an array is technically
    a type of object. We can''t, however, access the *values *of an array with dot
    notation.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at `captain`, we can see three different data types: string, number,
    and array. Objects can have nested objects as well. As part of their function
    as key-value stores, the key should be a string. To access a value, we use dot
    notation:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can access parts of an object with dot notation, which is similar to a **dict**
    in Python, but not quite! The nuances will become more clear as we work with objects
    since they are fundamental to what makes JavaScript unique.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at an `if`/`else` statement written in two ways in both
    Python and JavaScript:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python** | **JavaScript** |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'In both columns, the code is doing the same thing: a simple test to see whether `a`
    is less than `b` and then assigning the smaller value to the `min` variable. The
    first row is a full `if`/`else` statement and the second row uses the ternary
    structure. There are a few grammar rules to note in these examples:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '`min` must be declared before use, as a best practice. In strict mode, this
    would actually throw an error.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `if` clause is encapsulated with parentheses.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `if`/`else` statements are encapsulated with curly braces.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The keywords and operators in the ternary are significantly different (and a
    bit more cryptic) than in Python.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we wanted to use what we now know about `typeof`, we can use strict equality
    to understand our variables a bit more:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Loops
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are four main types of loops in JavaScript: `for`, `while`, `do`/`while`,
    and `for..in`. (There are a couple of other ways to structure a loop, but these
    are the main ones.) Their use cases shouldn''t be much of a surprise.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: for loops
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use an iterator to execute code a specified number of times:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python** | **JavaScript** |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you may be wondering, "if JavaScript has a `for..in` loop, why aren''t
    we using it?". As it turns out, `for/in` of Python and `for..in` of JavaScript
    are *false cognates*: their names look alike but are very different in use. We''ll
    discuss JavaScript''s `for..in` loop shortly. Also, note how we needed to have
    three clauses in our `for` loop:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a869732b-aee6-483a-80d5-041b081918d6.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 - Declaration, Condition, and Execution stages of a `for` loop
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The **declaration** will either define an iterator or use an existing mutable
    variable. Note that it should be a mutable number!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Our **condition** is what we're testing. We want our loop to run while `i` is
    less than `names.length`. Since `name.length` is `3`, we will run our loop three
    times, or until `i` equals `4`, which no longer meets our condition.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: At the end of every iteration of our loop, we **execute** something; usually
    a simple incrementing of our declaration. Now, notice the semicolons in between
    each of our clauses…unlike in other parts of JavaScript, these are *not* optional.
    There isn't one placed after the execution portion.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: while loops
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The JavaScript `while` loop is identical in use to its Pythonic equivalent,
    minus a little grammar:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python** | **JavaScript** |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: do/while loops
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the name implies, the `do`/`while` loop executes the `do` code when a given
    condition equals `true`. Take a look at the JavaScript:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: for..in loops
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, I promised to explain why Python's `for..in` is different from JavaScript's
    usage. The difference is that JavaScript's `for..in` is used to iterate over keys
    in an object, whereas Python's `for..in` is used as a loop over a discrete set
    of entities.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What do you think `myString` now equals? Since the purpose of `for..in` in *JavaScript* is
    to go over each *key* in the object, it's `Jean-Luc Picard 62 SP 937-215 NCC 1701-D
    Riker,Data,Worf`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: for..of loops
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is one more `for` loop: `for..of`, which differs from `for..in`. The `for..of`loop
    iterates through values of any iterable, such as arrays, strings, sets, and similar.
    If we want to iterate over `officers` and log out each name, we can do this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next up, we'll discuss functions!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ah, functions. We love them because they''re the key to modular, **don''t-repeat-yourself**
    (**DRY**) programs. The use cases in JavaScript and Python are the same: blocks
    of code intended to be called more than once, usually with varying parameters.
    Parameters are the variables that a function will take in order to execute its
    code on a mutable dataset. Arguments are what we pass when we call a function.
    They''re the same thing in essence, but have different words depending on where
    and when they''re used: are they the abstraction, or are they the actual data?
    Let''s take a look at a side-by-side comparison:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python** | **JavaScript** |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't already brought up the JavaScript console in your browser, you
    should do that now to see our output of `6`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that the structure is fairly similar, with our parameter being
    passed in parentheses. As noted before, we prefer camel-case in JavaScript and
    encapsulate with curly braces. Calling the function with our argument of `5` is
    the same. For conciseness, we can increment `val` with the `++` operator on the
    left before `return` executes. Such shortcuts are common in JavaScript, but remember
    to use them judiciously: "Write clearly—don''t be too clever."'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: However, JavaScript actually has two different ways to declare a function, plus
    a newer syntax introduced in ES6.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Function declarations
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`addOne()` in the preceding code is an example of a *function declaration*.
    It uses the function keyword to declare our functionality. Its anatomy is just
    as simple as it looks:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Function expressions
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s an example of `addOne()`, constructed as a function expression:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Function expressions should use `const` in the expression, though it is not
    syntactically incorrect to use `var` or `let`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: What's the difference between declarations and expressions? The core difference
    is that a function *declaration* can be used anywhere in your program because
    it's *hoisted* to the top. As JavaScript is interpreted top-down; this is a major
    exception to that paradigm. So, conversely, using an *expression* must occur after
    the expression is written.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ES6 introduced the arrow syntax of writing function expressions:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To further complicate matters, we can omit the parentheses around `val` because
    there''s only one parameter:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The main difference between arrow functions and expressions is centered around
    *lexical scoping*. We touched on scope with *hoisting*, and we'll discuss it in
    more detail in the next chapter.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with any language, comments are important. There are two ways to declare
    comments in JavaScript:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So, we can start a comment with `//` and write text until the end of the line.
    We can have a full-line comment with `//` and we can also have a multiline comment
    with `/*`, ending with `*/`. Additionally, you may encounter comments in the JSDoc
    style, used for inline documentation:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: More information on JSDoc is included in the *Further reading* section.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Methods and properties
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we've seen `.push()` and `.pop()` as methods of array instances. In
    JavaScript, a **method** is simply a function inherent to its data type that operates
    on the data and properties of a variable. I mentioned before that nearly everything
    in JavaScript is an object, and that is not an exaggeration. From functionality
    and syntax to structure and usage, there are many similarities between the raw
    data type of an *object* and any other variable.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part of our understanding of the syntax of JavaScript is everyone''s
    favorite: punctuation. While it may seem trivial, it''s very important for the
    interpretation, by both humans and computers, of the code.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Punctuation and readability
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with every language, JavaScript has conventions on punctuation and how spacing
    affects readability. Let''s take a look at a few ideas:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**:'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Java**:'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**C++**:'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**JavaScript**:'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In JavaScript, the conventions of the preceding example are as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: No space between the function name and the parentheses.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single space before the curly brace, which is on the same line.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The closing curly brace is on its own line, aligned with the opening statement
    of `function`.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There''s also one more modern point to make here about JavaScript and the examples
    we''ll be using in this book versus what you may encounter in the field and examples
    online: **semicolons**.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: With few exceptions, in modern JavaScript, semicolons at the end of statements
    are *optional*. It used to be a best practice to always terminate statement lines
    with semicolons, and you'll see a lot of semicolons in existing code. This is
    a question of style from company to company, project to project, and library to
    library. There are some standards in place, as we'll discuss shortly with linting,
    but for the purposes of this book, we will *not* be using semicolons to terminate
    statements, except in such cases as required by syntax (such as we saw in our
    loops).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also important to note that nested lines should be indented by two spaces.
    Two versus four is a style question, also, but in this book, we''ll be using **two
    spaces**. One way to help maintain consistency is to configure your code editor
    to translate tabs into two spaces (or four, as desired). That way, you just hit
    *Tab* instead of worrying about how many times you mashed the space bar. I won''t
    expound on the importance of proper indentation, but remember: the more your code
    adheres to styles and best practices, the more legible it will be to those who
    maintain your code—and to your future self!'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: The elephant in the room – whitespace
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OK, OK, we know that Python is whitespace-delimited: tabs matter! However,
    JavaScript really *doesn''t* care about whitespace in most cases. As we saw before,
    indentation and whitespace is a matter of *style*, not *syntax*.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'So here''s the thing: when I was first learning Python, the idea of a language
    that was whitespace-dependent was abhorrent. "How could a language that could
    break with an improper IDE setting survive?", I thought. My opinions aside, the
    good news is that indentation in Python is parallel to indentation plus curly
    braces in JavaScript.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python** | **JavaScript** |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: If you notice, our `if` statement inside our Python function is indented in
    the same way that this JavaScript example is indented, albeit without the curly
    braces. So yay! Your adherence to Pythonic indentation dicta actually comes *quite*
    in handy in JavaScript! While it's not required to include whitespace *à la* Python,
    it does definitely improve legibility.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the day, JavaScript likes indentation as much as Python because
    it makes for more readable code, though it's not required for your program to
    run.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Existing standards – linting to the rescue!
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve looked at JavaScript''s conventions and norms, but most rules have a
    caveat that "this could vary" or "this isn''t technically required." So, how do
    we make sense of our code in a malleable, opinion-driven environment? One answer:
    *linting*.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply put, **linting** refers to the process of running your code through
    predefined rules to ensure that not only is it syntactically correct, but it also
    adheres to proper style rules. This isn''t a practice limited to JavaScript; you
    may have linted your Python code, too. In modern JavaScript, linting has come
    to be seen as a best practice to ensure your code is consistent. Two of the main
    style guides in the community are AirBnB ([https://github.com/airbnb/javascript](https://github.com/airbnb/javascript)) and
    Google ([https://google.github.io/styleguide/jsguide.html](https://google.github.io/styleguide/jsguide.html)).
    Your code editor probably supports using a linter, but we won''t go into using
    them in practice right now, as each editor varies in setup. Here''s a quick look
    at what it can look like in Atom:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7dd21500-86c8-4ab5-84c7-58bf85c03d90.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 - Linting error in Atom
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, know that standards do exist, though they may vary from style
    guide to style guide. You can clone a repository demonstrating linting from [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-3/Linting](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-3/Linting).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: There are several popular linting tools available, such as ESLint and Prettier.
    The tool you choose can be customized to the style guide you choose to work with.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: OK, that's a lot for one chapter! Let's wrap up.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript has a rich grammar and syntax, developed over years of use and refinement.
    Using ES6, we have a whole host of data types, methods of declaring functions,
    and code standards. While writing JavaScript can seem to be playing very loose
    and fast, there are best practices, and the fundamentals of the language are as
    robust as other languages. Remember that capitalization counts; don't use reserved
    words for variable names; use `const` or `let` to declare your variables; even
    though JavaScript is loosely typed, data types are important; and conditionals,
    loops, and functions all help structure the logic of your code.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: A mastery of the grammar and syntax of JavaScript is vital to understanding
    how to use this robust language, so take your time familiarizing yourself with
    the details and intricacies. Moving forward, we will presume you have fluency
    in JavaScript's style as we get into more difficult material.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will get our hands dirty with data and understanding
    how JavaScript works with and models data.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try your hand at answering the following questions to test your knowledge:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试回答以下问题来测试你的知识：
- en: Which of the following is not a valid JavaScript variable declaration?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个不是有效的JavaScript变量声明？
- en: '`var myVar = ''hello'';`'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`var myVar = ''hello'';`'
- en: '`const myVar = "hello"`'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`const myVar = "hello"`'
- en: '`String myVar = "hello";`'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`String myVar = "hello";`'
- en: '`let myVar = "hello"`'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`let myVar = "hello"`'
- en: Which of these starts a function declaration?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个开始了函数声明？
- en: '`function`'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`function`'
- en: '`const`'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`const`'
- en: '`func`'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`func`'
- en: '`def`'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`def`'
- en: Which of these is not a basic loop type?
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个不是基本循环类型？
- en: '`for..in`'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`for..in`'
- en: '`for`'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`for`'
- en: '`while`'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`while`'
- en: '`map`'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`map`'
- en: True or false – JavaScript *requires* line delineation with semicolons.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假 - JavaScript *需要*使用分号进行行分隔。
- en: 'True'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真
- en: 'False'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假
- en: True or false – whitespace *never* counts in JavaScript.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假 - 空格在JavaScript中*从不*计数。
- en: 'True'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真
- en: 'False'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假
- en: Further reading
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: B. W. Kernighan and P. J. Plauger, *The Elements of Programming Style 2nd Edition*,
    McGraw Hill, New York, 1978\. ISBN 0-07-034207-5
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B. W. Kernighan和P. J. Plauger，*编程风格的要素第二版*，McGraw Hill，纽约，1978年。 ISBN 0-07-034207-5
- en: 'PEP-8 – *A Style Guide for Python Code*: [https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP-8 - *Python代码风格指南*：[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)
- en: 'PEP-20 – *The Zen of Python*: [https://www.python.org/dev/peps/pep-0020/](https://www.python.org/dev/peps/pep-0020/)'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP-20 - *Python之禅*：[https://www.python.org/dev/peps/pep-0020/](https://www.python.org/dev/peps/pep-0020/)
- en: 'JSDoc: [http://usejsdoc.org/](http://usejsdoc.org/)'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSDoc：[http://usejsdoc.org/](http://usejsdoc.org/)
