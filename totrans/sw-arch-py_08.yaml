- en: Chapter 8. Python – Architectural Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Architectural patterns are the highest level of patterns in the pantheon of
    patterns in software. Architectural patterns allow the architects to specify the
    fundamental structure of an application. The architectural pattern chosen for
    a given software problem governs the rest of its activities, such as the design
    of systems involved, communication between different parts of the system, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of architectural patterns to choose from depending upon the
    problem at hand. Different patterns solve different classes or families of problems,
    creating their own style or class of architecture. For example, a certain class
    of patterns solves the architecture of client/server systems, certain others help
    to build distributed systems, and a third helps to design highly decoupled peer-to-peer
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss and focus on a few architectural patterns that
    are encountered often in the Python world. Our pattern of discussion in the chapter
    will be to take a well-known architectural pattern, and explore one or two popular
    software applications or frameworks that implement it, or a variation of it.
  prefs: []
  type: TYPE_NORMAL
- en: We will not discuss a lot of code in this chapter—the usage of code will be
    limited to those patterns where an illustration using a program is absolutely
    essential. On the other hand, most of the discussion will be on the architectural
    details, participating subsystems, variations in the architecture implemented
    by the chosen application/framework, and the like.
  prefs: []
  type: TYPE_NORMAL
- en: There are any number of architecture patterns that we can look at. In this chapter,
    we will focus on MVC and its related patterns, Event-driven programming architectures,
    Microservices architectures, and Pipes and Filters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Introducing MVC:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model View Template – Django
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask Microframework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Event driven Programming:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chat server and client using select
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event-driven versus Concurrent programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Twisted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Twisted Chat Server and Client
  prefs: []
  type: TYPE_NORMAL
- en: Eventlet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eventlet Chat Server
  prefs: []
  type: TYPE_NORMAL
- en: Greenlets and gevent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gevent Chat Server
  prefs: []
  type: TYPE_NORMAL
- en: 'Microservices Architecture:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservice frameworks in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservice example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservice advantages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pipe and Filter Architecture:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipe and Filter in Python – examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Model View Controller or MVC is a well known and popular architectural pattern
    for building interactive applications. MVC splits the application into three components:
    the Model, the View, and the Controller.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing MVC](../Images/image00489.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Model-View-Controller (MVC) Architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'The three components perform the following responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: The model contains the core data and logic of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: The view(s) form the output of the application to the user. They
    display information to the user. Multiple views of the same data are possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: The controller receives and processes user input such as keyboard
    clicks or mouse clicks/movements, and converts them into change requests for the
    model or the view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separation of concerns using these three components avoids tight coupling between
    the data of the application and its representation. It allows for multiple representations
    (views) of the same data (model), which can be computed and presented according
    to user input received via the controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MVC pattern allows the following interactions:'
  prefs: []
  type: TYPE_NORMAL
- en: A model can change its data depending upon inputs received from the controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The changed data is reflected on the views, which are subscribed to changes
    in the model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Controllers can send commands to update the model's state, such as when making
    changes to a document. Controllers can also send commands to modify the presentation
    of a view without any change to the model, such as zooming in on a graph or chart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The MVC pattern implicitly includes a change propagation mechanism to notify
    each component of changes on the other dependent components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A number of web applications in the Python world implement MVC or a variation
    of it. We will look at a couple of them, namely Django and Flask, in the coming
    sections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Model Template View (MTV) – Django
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Django project is one of the most popular web application frameworks in
    the Python world. Django implements something like an MVC pattern, but with some
    subtle differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Django (core) component architecture is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Model Template View (MTV) – Django](../Images/image00490.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Django Core Component Architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'The core components of the Django framework are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An **Object Relational Mapper** (**ORM**), which acts as a mediator between
    data models (Python) and the database (RDBMS)—this can be thought of as the **Modle**
    layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of callback functions in Python, which renders the data to the user interface
    for a specific URL—this can be thought of as the **VIEW** layer. The view focuses
    on building and transforming the content rather than on its actual presentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of HTML templates to render content in different presentations. The view
    delegates to a specific template, which is responsible for how the data is presented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A regular expression-based **URL DISPATCHER**, which connects relative paths
    on the server to specific views and their variable arguments. This can be thought
    of as a rudimentary **Controller**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Django, since the presentation is performed by the **TEMPLATE** layer and
    only the content mapping done by the **VIEW** layer, Django is often described
    as implementing the **Model Template View** (**MTV**) framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Controller in Django is not very well defined – it can be thought of as
    the entire framework itself – or limited to the **URL DISPATCHER** layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django admin – automated model-centric views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most powerful components of the Django framework is its automatic
    admin system, which reads metadata from the Django models, and generates quick,
    model-centric admin views, where administrators of the system can view and edit
    data models via simple HTML forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'For illustration, the following is an example of a Django model that describes
    a term that is added to a website as a `glossary` term (A glossary is a list or
    index of words that describes the meaning of words related to a specific subject,
    text, or dialect):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is combined with an admin system that registers a model for an automated
    admin view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an image of the automated admin view (HTML form) for adding
    a glossary term via the Django admin interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Django admin – automated model-centric views](../Images/image00491.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Django Automated Admin View (HTML form) for adding a glossary term
  prefs: []
  type: TYPE_NORMAL
- en: A quick observation tells you how the Django admin is able to generate the correct
    field type for the different data fields in the model, and generate a form for
    adding the data. This is a powerful pattern that is present in Django, which allows
    one to generate automated admin views for adding/editing models with almost zero
    coding effort.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now look at another popular Python web application framework, namely,
    Flask.
  prefs: []
  type: TYPE_NORMAL
- en: Flexible Microframework – Flask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Flask is a micro web framework, which uses a minimalistic philosophy for building
    web applications. Flask relies on just two libraries: the Werkzeug ([http://werkzeug.pocoo.org/](http://werkzeug.pocoo.org/))
    WSGI tool kit and the Jinja2 templating framework.'
  prefs: []
  type: TYPE_NORMAL
- en: Flask comes with simple URL routing via decorators. The *micro* word in Flask
    indicates that the core of the framework is small. Support for databases, forms,
    and others is provided by multiple extensions that the Python community has built
    around Flask.
  prefs: []
  type: TYPE_NORMAL
- en: The core Flask can thus be thought of as an MTV framework minus the M (View
    Template), since the core does not implement support for models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an approximate schematic diagram of the Flask component architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flexible Microframework – Flask](../Images/image00492.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Schematic diagram of Flask components
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple Flask application using templates looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can find a few components of the MVC pattern right here:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@app.route` decorator routes requests from the browser to the `index` function.
    The application router can be thought of as the controller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `index` function returns the data, and renders it using a template. The
    `index` function can be thought of as generating the view or the view component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask uses templates like Django to keep the content separate from the presentation.
    This can be thought of as the template component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no specific model component in Flask core. However, this can be added
    on with the help of additional plugins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask uses a plugin architecture to support additional features. For example,
    models can be added on by using Flask-SQLAlchemy, RESTful API support using Flask-RESTful,
    serialization using Flask-marshmallow, and others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event-driven programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Event-driven programming is a paradigm of system architecture where the logic
    flow within the program is driven by events such as user actions, messages from
    other programs, or hardware (sensor) inputs.
  prefs: []
  type: TYPE_NORMAL
- en: In Event-driven architectures, there is usually a main event loop, which listens
    for events, and then triggers callback functions with specific arguments when
    an event is detected.
  prefs: []
  type: TYPE_NORMAL
- en: In modern operating systems like Linux, support for events on input file descriptors
    such as sockets or opened files are implemented by system calls such as `select`,
    `poll`, and `epoll`.
  prefs: []
  type: TYPE_NORMAL
- en: Python provides wrappers to these system calls via its `select` module. It is
    not very difficult to write a simple Event-driven program using the `select` module
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: The following set of programs together implement a basic chat server and client
    in Python using the power of the select module.
  prefs: []
  type: TYPE_NORMAL
- en: Chat server and client using I/O multiplexing with the select module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our chat server uses the `select` system call via the `select` module to create
    channels where clients can connect to and talk with each other. It handles the
    events (sockets) that are input ready–if the event is a client connecting to the
    server, it connects and performs a handshake; if the event is data to be read
    from standard input, the server reads the data, or else it passes the data received
    from one client to the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our chat server:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the code of the chat server is big, we are only including the main function,
    namely the serve one here showing how the server uses select-based I/O multiplexing.
    A lot of code in the `serve` function has also been trimmed to keep the printed
    code small.
  prefs: []
  type: TYPE_NORMAL
- en: The complete source code can be downloaded from the code archive of this book
    from the book's website.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The chat server can be stopped by sending a single line of empty input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chat client also uses the `select` system call. It uses a socket to connect
    to the server, and then waits for events on the socket plus the standard input.
    If the event is from the standard input, it reads the data. Otherwise, it sends
    the data to the server via the socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The chat client can be stopped by pressing *Ctrl* + *C* on the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to send data to and fro via sockets, both these scripts use a third
    module named `communication`, which has a `send` and a `receive` function. This
    module uses pickle to serialize and deserialize data in the `send` and `receive`
    functions, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are some images of the server running and two clients that are
    connected to each other via the chat server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the image of client #1 named `andy` connected to the chat server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chat server and client using I/O multiplexing with the select module](../Images/image00493.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Chat session of chat client #1 (client name: andy)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, here is a client named `betty` who is connected to the chat server
    and is talking to `andy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chat server and client using I/O multiplexing with the select module](../Images/image00494.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Chat session of chat client #2 (client name: betty)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some interesting points of program are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: See how the clients are able to see each other's messages. This happens because
    the server sends the data sent by one client to all the other connected clients.
    Our chat server prefixes the messages with a hash `#` to indicate that this message
    is from another client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how the server sends connection and disconnection information of a client
    to all other clients. This informs the clients when another client is connected
    to or disconnected from the session.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The server echoes messages when a client disconnects saying that the client
    *hung up*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding chat server and client example is a minor variation of the author's
    own Python recipe in the ASPN Cookbook at [https://code.activestate.com/recipes/531824](https://code.activestate.com/recipes/531824).
  prefs: []
  type: TYPE_NORMAL
- en: The simple select-based multiplexing is taken to the next level by libraries
    such as Twisted, Eventlet, and Gevent in order to build systems that provide high
    level event-based programming routines to the programmer, typically based on a
    core event loop very similar to the loop of our chat server example.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the architecture of these frameworks in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven programming versus Concurrent programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example we saw in the previous section uses the technique of asynchronous
    events as we saw in the chapter on concurrency. This is different from true concurrent
    or parallel programming.
  prefs: []
  type: TYPE_NORMAL
- en: Event programming libraries also work on the technique of asynchronous events.
    There is only a single thread of execution in which tasks are interleaved one
    after another based on the events received.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, consider a truly parallel execution of three tasks
    by three threads or processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Event-driven programming versus Concurrent programming](../Images/image00495.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Parallel execution of three tasks using three threads
  prefs: []
  type: TYPE_NORMAL
- en: 'Contrast this with what happens when the tasks are executed via Event-driven
    programming as depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Event-driven programming versus Concurrent programming](../Images/image00496.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Asynchronous execution of three tasks in a single thread
  prefs: []
  type: TYPE_NORMAL
- en: In the asynchronous model, there is only one single thread of execution with
    tasks executing in an interleaved fashion. Each task gets its own slot of processing
    time in the event loop of the asynchronous processing server, but only one task
    executes at a given time. Tasks yield control back to the loop so that it can
    schedule a different task in the next time slice from the task that is being executed
    currently. As we have seen in [Chapter 5](part0040.xhtml#aid-164MG1 "Chapter 5. Writing
    Applications That Scale"), *Writing Applications that Scale*, this is a kind of
    cooperative multitasking.
  prefs: []
  type: TYPE_NORMAL
- en: Twisted
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Twisted is an Event-driven networking engine with support for multiple protocols,
    such as DNS, SMTP, POP3, IMAP, and so on. It also comes with support for writing
    SSH clients and servers, and to build messaging and IRC clients and servers.
  prefs: []
  type: TYPE_NORMAL
- en: Twisted also provides a set of patterns (styles) to write common servers and
    clients, such as Web Server/Client (HTTP), Publish/Subscribe patterns, Messaging
    Clients and Servers (SOAP/XML-RPC), and others.
  prefs: []
  type: TYPE_NORMAL
- en: It uses the Reactor design pattern, which multiplexes and dispatches events
    from multiple sources to their event handlers in a single thread.
  prefs: []
  type: TYPE_NORMAL
- en: It receives messages, requests, and connections coming from multiple concurrent
    clients, and processes these posts sequentially using event handlers without requiring
    concurrent threads or processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reactor pseudo-code looks, approximately, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Twisted uses callbacks to call event handlers as and when an event happens.
    To handle a specific event, a callback is registered for that event. Callbacks
    can be used for regular processing, and also for managing exceptions (errbacks).
  prefs: []
  type: TYPE_NORMAL
- en: Like the `asyncio` module, Twisted uses an object such as futures in order to
    wrap the results of a task execution, whose actual results are still not available.
    In Twisted, these objects are called **Deferreds**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deferred objects have a pair of callback chains: one for processing results
    (callbacks) and one for managing errors (errbacks). When the result of an execution
    is obtained, a Deferred object is created, and its callbacks and/or errbacks are
    called in the order in which they were added.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an architecture diagram of Twisted, showing the high-level components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Twisted](../Images/image00497.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Twisted – Core Components
  prefs: []
  type: TYPE_NORMAL
- en: Twisted – a simple web client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is a simple example of a web HTTP client using Twisted, fetching
    a given URL and saving its contents to a specific filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, the `getPage` method returns a deferred,
    and not the data of the URL. To the deferred, we add two callbacks: one for processing
    the data (the `save_page` function) and another for handling errors (the `handle_error`
    function). The `addBoth` method of the deferred adds a single function as both
    callback and errback.'
  prefs: []
  type: TYPE_NORMAL
- en: The event processing is started by running the reactor. In the `finish_processing`
    callback, which is called at the end, the reactor is stopped. Since event handlers
    are called in the order that they are added, this function will be called only
    at the very end.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the reactor is run the following events happen:'
  prefs: []
  type: TYPE_NORMAL
- en: The page is fetched and the deferred is created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The callbacks are called in order on the deferred. First the `save_page` function
    is called, which saves contents of the page to the `content.html` file. Then a
    `handle_error` event handler is called, which prints any error string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `finish_processing` is called, which stops the reactor and the event
    processing ends, exiting the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing, Twisted is not yet available for Python3, so the preceding
    code is written for Python2.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the code, you will see that the following output is produced:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Chat Server using Twisted
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's now see how we can write a simple chat server in Twisted on lines similar
    to our chat server using the `select` module.
  prefs: []
  type: TYPE_NORMAL
- en: In Twisted, servers are built by implementing protocols and protocol factories.
    A protocol class typically inherits from the Twisted `Protocol` class.
  prefs: []
  type: TYPE_NORMAL
- en: A factory is nothing but a class that serves as a factory pattern for protocol
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this, here is our chat server using Twisted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Our chat server is a bit more sophisticated than the one before as it performs
    the following additional steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It has a separate handshake protocol using the special `<handshake>` message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a client connects, it is broadcast to other clients informing them of the
    client's name and connection details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a client disconnects, other clients are informed about this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The chat client also uses Twisted and uses two protocols – namely a `ChatClientProtocol`
    for communication with the server and a `StdioClientProtocol` for reading data
    from standard input and echoing data received from the server to the standard
    output.
  prefs: []
  type: TYPE_NORMAL
- en: The latter protocol also connects the former one to its input, so that any data
    that is received on the standard input is sent to the server as a chat message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some screenshots of the two clients `andy` and `betty` communicating
    using this chat server and client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chat Server using Twisted](../Images/image00498.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Chat client using Twisted chat server – session for client #1 (andy)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the second session, for the client betty:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chat Server using Twisted](../Images/image00499.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Chat client using Twisted chat server – session for client #2 (betty)'
  prefs: []
  type: TYPE_NORMAL
- en: You can follow the flow of the conversation by alternately looking at the screenshots.
  prefs: []
  type: TYPE_NORMAL
- en: Note the connection and disconnection messages sent by the server when user
    betty connects and user andy disconnects respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Eventlet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Eventlet is another well known networking library in the Python world that allows
    one to write Event-driven programs using the same concept of asynchronous execution.
  prefs: []
  type: TYPE_NORMAL
- en: Eventlet uses co-routines for this purpose with the help of a set of so-called
    *green threads*, which are light-weight user-space threads that perform cooperative
    multitasking.
  prefs: []
  type: TYPE_NORMAL
- en: Eventlet uses an abstraction over a set of green threads, the `Greenpool` class,
    in order to perform its tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The `Greenpool` class runs a predefined set of `Greenpool` threads (default
    is `1000`), and provides ways to map functions and callables to the threads in
    different ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the multiuser chat server rewritten using Eventlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This server can be used with the Twisted chat client that we've seen in the
    previous example, and behaves in exactly the same way. Hence, we will not show
    running examples of this server.
  prefs: []
  type: TYPE_NORMAL
- en: The Eventlet library internally uses `greenlets`, a package that provides green
    threads on Python runtime. We will see greenlet and a related library, Gevent,
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Greenlets and Gevent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Greenlet is a package that provides a version of green or microthreads on top
    of the Python interpreter. It is inspired by Stackless, a version of CPython that
    supports microthreads called stacklets. However, greenlets are able to run on
    the standard CPython runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Gevent is a Python networking library providing high-level synchronous API on
    top of `libev`, the event library written in C.
  prefs: []
  type: TYPE_NORMAL
- en: Gevent is inspired by gevent, but it features a more consistent API and better
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Like Eventlet, gevent does a lot of monkey patching on system libraries to provide
    support for cooperative multitasking. For example, gevent comes with its own sockets,
    just like Eventlet does.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Eventlet, gevent also requires explicit monkey patching to be done by
    the programmer. It provides a method to do this on the module itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without further ado, let us look at how the multiuser chat server using gevent
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The code for the gevent-based chat server is almost the same as the one using
    Eventlet. The reason for this is that both work in very similar ways by handling
    control to a callback function when a new connection is made. In both cases the
    callback function is named `new_chat_channel`, which has the same functionality
    and hence very similar code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The differences between the two are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: gevent provides its own TCP server class—`StreamingServer`–so we use that instead
    of listening on the module directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the gevent server, for every connection the `new_chat_channel` handler is
    invoked, hence the participant set is managed there
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the gevent server has its own event loop, there is no need to create a
    while loop for listening for incoming connections as we had to do with Eventlet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This example works exactly the same as the previous ones and works with the
    Twisted chat client.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservice architecture is an architectural style of developing a single application
    as a suite of small independent services, each running in its own process and
    communicating via light-weight mechanisms—typically, using HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices are independently deployable components, and usually, have zero
    or minimalistic central management or configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices can be thought of as a specific implementation style for **Service
    Oriented Architectures** (**SOA**), where, instead of building a monolith application
    top-down, the application is built as a dynamic group of mutually interacting,
    independent services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, enterprise applications were built in a monolithic pattern,
    typically consisting of these three layers:'
  prefs: []
  type: TYPE_NORMAL
- en: A client-side User Interface (UI) layer consisting of HTML and JavaScript.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A server-side application consisting of the business logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A database and data access layer, which holds the business data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the other hand, a microservices architecture will split this layer into multiple
    services. For example, the business logic, instead of being in a single application,
    will be split into multiple component services, whose interactions define the
    logic flow inside the application. The services might query a single database
    or independent local databases with the latter configuration being more common.
  prefs: []
  type: TYPE_NORMAL
- en: Data in microservices architectures are usually processed and returned in the
    form of document objects – typically encoded in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following schematic diagram illustrates the difference of a monolithic
    architecture from a microservices one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservice architecture](../Images/image00500.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Monolithic (left) vs Microservices (right) Architecture
  prefs: []
  type: TYPE_NORMAL
- en: Microservice frameworks in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With microservices being more of a philosophy or style of architecture, there
    are no distinct classes of software frameworks that one can say is the right fit
    for them. However, one can still make a few educated projections for the properties
    that a framework should have for it being a good choice for building a microservices
    architecture for your web application in Python. These properties include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: The component architecture should be flexible. The framework should not be rigid
    in the component choices that it stipulates to make the different parts of the
    system work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core of the framework should be lightweight. This makes sense, since if
    we start off with, say, a lot of dependencies for the microservices framework
    itself, the software starts feeling heavy right in the beginning. This may cause
    issues in deployment, testing, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The framework should support zero or minimalistic configuration. Microservices
    architectures are usually configured automatically (zero configuration) or with
    a minimal set of configuration inputs that are available at one place. Usually
    the configuration is itself available as a microservice for other services to
    query and make the sharing of configuration easy, consistent, and scalable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should make it very easy to take an existing piece of business logic, say
    coded as a class or a function, and turn it into an HTTP or RCP service. This
    allows reuse and smart refactoring of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you use these principles and look around in the Python software ecosystem,
    you will figure out that a few web application frameworks fit the bill, whereas
    a few don't.
  prefs: []
  type: TYPE_NORMAL
- en: For example, Flask and its single-file counterpart Bottle are good candidates
    for a microservices framework due to their minimal footprint, small core, and
    simple configuration.
  prefs: []
  type: TYPE_NORMAL
- en: A framework such as Pyramid can also be used for a microservices architecture
    since it promotes flexibility of choice of components and eschews tight integration.
  prefs: []
  type: TYPE_NORMAL
- en: A more sophisticated web framework such as Django makes a poor choice for a
    microservices framework due to exactly the opposite reasons–tight vertical integration
    of components, lack of flexibility in choosing components, complex configuration,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Another framework that is written specifically for implementing microservices
    in Python is Nameko. Nameko is geared towards testability of the application,
    and it provides support for different protocols for communication such as HTTP,
    RPC (over AMQP)—a Pub-Sub system, and a Timer service.
  prefs: []
  type: TYPE_NORMAL
- en: We will not be going into details of these frameworks. On the other hand, we
    will take a look at architecting and designing a real-life example of a web application
    using microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices example – restaurant reservation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us take a real-life example for a Python web application, and try and design
    it as a set of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Our application is a restaurant reservation app that helps users make a reservation
    for a certain number of people at a specific time in a restaurant close to their
    current location. Assume that reservations are only done for the same day.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application needs to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Return a list of restaurants open for business at the time for which the user
    wants to make the reservation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a given restaurant, return enough meta information, such as cuisine choices,
    rating, pricing, and so on, and allow the user to filter the hotels based on their
    criteria.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the user has made a choice, allow them to make a reservation on the selected
    restaurant for a certain number of people for a given time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each of these requirements is granular enough to have their own microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, our application will be designed with the following set of microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: A service that uses the user's location, and returns a list of restaurants open
    for business, and which support the online reservation API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A second service that retrieves metadata for a given hotel, given the restaurant
    ID. The application can use this metadata to compare against the user's criteria
    to see if it's a match.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A third service, which, given a restaurant ID, the user's information, the number
    of seats required, and the time of reservation, uses the reservation API to make
    a reservation for seats, and returns the status.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core parts of the application logic now fit these three microservices. Once
    they are implemented, the plumbing—in terms of calling these services and performing
    a reservation—will happen in the application logic directly.
  prefs: []
  type: TYPE_NORMAL
- en: We will not be showing any code for this application as that is a project in
    its own, but we will show the reader how the microservices look like in terms
    of their APIs and return data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservices example – restaurant reservation](../Images/image00501.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Architecture of restaurant reservation application using microservices
  prefs: []
  type: TYPE_NORMAL
- en: 'A microservice usually returns data in the form of JSON. For example, our first
    service that returns a list of restaurants would return a JSON similar to the
    one that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The second service, which returns restaurant metadata, would mostly return
    a JSON like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the interaction for the third one, which does a booking given the restaurant
    ID:'
  prefs: []
  type: TYPE_NORMAL
- en: Since this service needs the user to provide information for the reservation,
    it needs a JSON payload with the details of booking. Hence, this is best done
    as an HTTP POST call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The service in this case will use the following given payload as the POST data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It will return a JSON like the following as a response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With this design in place, it is not very difficult to implement the application
    in a framework of your choice, whether it be Flask, Bottle, Nameko, or anything
    else.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices – advantages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So what are the advantages of using microservices over a monolithic application?
    Let us take a look at some of the important ones:'
  prefs: []
  type: TYPE_NORMAL
- en: Microservices enhance separation of concern by splitting the application logic
    into multiple services. This improves cohesion, and decreases coupling. There
    is no need for a top-down, upfront design of the system, since the business logic
    is not in a single place. Instead, the architect can focus on the interplay and
    communication between the microservices and the application, and let the design
    and architecture of the microservices itself emerge iteratively through refactoring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices improve testability, since now each part of the logic is independently
    testable as a separate service, and hence, is easy to isolate from other parts,
    and test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teams can be organized around the business capabilities rather than around tiers
    of the application or technology layers. Since each microservice includes logic,
    data, and deployment, companies using microservices encourage cross-functional
    roles. This helps to build a more agile organization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices encourage decentralized data. Usually, each service will have
    its own local database or data store instead of the central database that is preferred
    by monolithic applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices facilitate continuous delivery and integration, and fast deployments.
    Since a change to business logic might often need only a small change in one or
    a few services, testing and redeployment can be often done in tight cycles, and
    in most cases, can be fully automated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipe and Filter architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pipe and Filter is a simple architectural style, which connects a number of
    components that process a stream of data, each connected to the next component
    in the processing pipeline via a **Pipe**.
  prefs: []
  type: TYPE_NORMAL
- en: The Pipe and Filter architecture is inspired by the Unix technique of connecting
    the output of an application to the input of another via pipes on the shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Pipe and Filter architecture consists of one or more data sources. The
    data source is connected to data filters via pipes. Filters process the data they
    receive, passing them to other filters in the pipeline. The final data is received
    at a **Data Sink**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipe and Filter architectures](../Images/image00502.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Pipe and Filter Architecture
  prefs: []
  type: TYPE_NORMAL
- en: Pipe and filter are used commonly for applications that perform a lot of data
    processing such as data analytics, data transformation, metadata extraction, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: The filters can be running on the same machine, and they use actual Unix pipes
    or shared memory for communication. However, in large systems, these usually run
    on separate machines, and the pipes need not be actual pipes, but any kind of
    data channel such as sockets, shared memory, queues, and the like.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple filter pipelines can be connected together to perform complex data
    processing and data staging.
  prefs: []
  type: TYPE_NORMAL
- en: A very good example of a Linux application that works using this architecture
    is `gstreamer`—the multimedia processing library that can perform a number of
    tasks on multimedia video and audio including play, record, edit, and stream.
  prefs: []
  type: TYPE_NORMAL
- en: Pipe and Filter in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Python, we encounter pipes in their most pure form in the multiprocessing
    module. The multiprocessing module provides Pipes as a way to communicate from
    one process to another.
  prefs: []
  type: TYPE_NORMAL
- en: A pipe is created as a pair of parent and child connections. What is written
    on one side of the connection can be read on the other side and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to build very simple pipelines of data processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, on Linux, the number of words in a file can be computed by this
    series of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We will write a simple program that mimics this pipeline using the multiprocessing
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an analysis of the workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: A pipe is created, and two connections are obtained.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `read` function is executed as a process, passing one end of the pipe (child)
    and the filename to be read.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This process reads the file, writing the data to the connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `words` function is executed as a second process, passing the other end
    of the pipe to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When this function executes as a process, it reads the data from the connection,
    and prints the number of words.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of both the shell command and the
    preceding program on the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipe and Filter in Python](../Images/image00503.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Output of a shell command using pipes and its equivalent Python program
  prefs: []
  type: TYPE_NORMAL
- en: You do not need to use an object that looks like an actual pipe in order to
    create pipelines. On the other hand, generators in Python provide an excellent
    way to create a set of callables, which call each other, and consume and process
    each other's data, producing a pipeline of data processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the same example as the previous one, rewritten to use generators,
    and this time, to process all the files in the folder matching a particular pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a screenshot of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipe and Filter in Python](../Images/image00504.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Output of a pipeline using generators that print the word count of Python programs
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One can verify the output of a program such as the preceding one using this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another program that uses another couple of data filtering generators
    to build a program, which watches files matching a specific pattern and prints
    information about the most recent file—something similar to what is done by the
    watch program on Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The details of this last program should be self-explanatory to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output of our program on the console, watching over Python source
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipe and Filter in Python](../Images/image00505.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Output of the program that watches over recently modified Python source files
  prefs: []
  type: TYPE_NORMAL
- en: 'If we create an empty Python source file, say `example.py`, the output changes
    in two seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipe and Filter in Python](../Images/image00506.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Output of the watch program changes, always showing the most recently modified
    file
  prefs: []
  type: TYPE_NORMAL
- en: The underlying technique of using generators (co-routines) to build such pipelines
    is to connect the output of one generator to the input of the next. By connecting
    many such generators in a series, one can build data processing pipelines that
    vary in complexity from simple to complex.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, one can use a number of techniques for building pipelines apart from
    this. Some common choices are producer-consumer tasks connected using queues,
    which can use threads or processes. We have seen examples of this in the chapter
    on scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices can also build simple processing pipelines by connecting the input
    of one microservice to the output of another.
  prefs: []
  type: TYPE_NORMAL
- en: In the Python third-party software ecosystem, there are a number of modules
    and frameworks that allow you to build complex data pipelines. Celery, though
    a task queue, can be used to build simple batch processing workflows with limited
    pipeline support. Pipelining is not the strong feature of celery, but it has limited
    support for chaining tasks that can be used for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Luigi is another robust framework that is written for complex, long-running
    batch processing jobs that require a pipe and filter architecture. Luigi comes
    with built-in support for Hadoop jobs, so it makes it a good choice for building
    data analytics pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at some common architectural patterns of building
    software. We started with the Model View Controller architecture, and looked at
    examples in Django and Flask. You learned about the components of an MVC architecture,
    and learned that Django implements a variant of MVC using templates.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at Flask as an example of a micro framework that implements the minimal
    footprint of a web application by using a plugin architecture with additional
    services that can be added on.
  prefs: []
  type: TYPE_NORMAL
- en: We went on to discuss the Event-driven programming architecture, which is a
    kind of asynchronous programming using co-routines and events. We started with
    a multiuser chat example using the `select` module in Python. From there, we went
    on to discuss larger frameworks and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the architecture of Twisted and its components. We also discussed
    Eventlet and its close cousin gevent. For each of these frameworks, we saw an
    implementation of the multiuser chat server.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we took up microservices as an architecture, which builds scalable services
    and deployments by splitting the core business logic across multiple services.
    We designed an example of a restaurant reservation application using microservices,
    and briefly looked at the landscape of Python web frameworks, which can be used
    to build microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Towards the end of the chapter, we saw the architecture of using Pipes and Filters
    for serial and scalable data processing. We built a simple example of actual pipes
    using the multiprocessing module in Python, which mimicked a Unix pipe command.
    We then looked at the technique of building pipelines using generators, and saw
    couple of examples. We summarized techniques for building pipelines and frameworks
    available in the Python third-party software ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of the chapter on application architectures. In the
    next chapter, we will look at deployability - namely the aspect of deploying software
    to environments such as production systems.
  prefs: []
  type: TYPE_NORMAL
