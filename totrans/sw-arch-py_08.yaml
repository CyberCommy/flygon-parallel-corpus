- en: Chapter 8. Python – Architectural Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。Python - 架构模式
- en: Architectural patterns are the highest level of patterns in the pantheon of
    patterns in software. Architectural patterns allow the architects to specify the
    fundamental structure of an application. The architectural pattern chosen for
    a given software problem governs the rest of its activities, such as the design
    of systems involved, communication between different parts of the system, and
    so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 架构模式是软件模式体系中最高级别的模式。架构模式允许架构师指定应用程序的基本结构。为给定的软件问题选择的架构模式控制着其余的活动，例如所涉及系统的设计，系统不同部分之间的通信等等。
- en: There are a number of architectural patterns to choose from depending upon the
    problem at hand. Different patterns solve different classes or families of problems,
    creating their own style or class of architecture. For example, a certain class
    of patterns solves the architecture of client/server systems, certain others help
    to build distributed systems, and a third helps to design highly decoupled peer-to-peer
    systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 根据手头的问题，可以选择多种架构模式。不同的模式解决不同类或系列的问题，创造出自己的风格或架构类别。例如，某一类模式解决了客户端/服务器系统的架构，另一类模式帮助构建分布式系统，第三类模式帮助设计高度解耦的对等系统。
- en: In this chapter, we will discuss and focus on a few architectural patterns that
    are encountered often in the Python world. Our pattern of discussion in the chapter
    will be to take a well-known architectural pattern, and explore one or two popular
    software applications or frameworks that implement it, or a variation of it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论并专注于Python世界中经常遇到的一些架构模式。我们在本章中的讨论模式将是采用一个众所周知的架构模式，并探索一个或两个实现它的流行软件应用程序或框架，或者它的变体。
- en: We will not discuss a lot of code in this chapter—the usage of code will be
    limited to those patterns where an illustration using a program is absolutely
    essential. On the other hand, most of the discussion will be on the architectural
    details, participating subsystems, variations in the architecture implemented
    by the chosen application/framework, and the like.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会讨论大量的代码 - 代码的使用将仅限于那些绝对必要使用程序进行说明的模式。另一方面，大部分讨论将集中在架构细节，参与子系统，所选应用程序/框架实现的架构变化等方面。
- en: There are any number of architecture patterns that we can look at. In this chapter,
    we will focus on MVC and its related patterns, Event-driven programming architectures,
    Microservices architectures, and Pipes and Filters.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以研究任意数量的架构模式。在本章中，我们将重点关注MVC及其相关模式，事件驱动编程架构，微服务架构以及管道和过滤器。
- en: 'We will be covering the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: 'Introducing MVC:'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍MVC：
- en: Model View Template – Django
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型视图模板 - Django
- en: Flask Microframework
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask微框架
- en: 'Event driven Programming:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件驱动编程：
- en: Chat server and client using select
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用select的聊天服务器和客户端
- en: Event-driven versus Concurrent programming
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件驱动与并发编程
- en: Twisted
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扭曲
- en: Twisted Chat Server and Client
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 扭曲聊天服务器和客户端
- en: Eventlet
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eventlet
- en: Eventlet Chat Server
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Eventlet聊天服务器
- en: Greenlets and gevent
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Greenlets和gevent
- en: Gevent Chat Server
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Gevent聊天服务器
- en: 'Microservices Architecture:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构：
- en: Microservice frameworks in Python
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的微服务框架
- en: Microservice example
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务示例
- en: Microservice advantages
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务优势
- en: 'Pipe and Filter Architecture:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道和过滤器架构：
- en: Pipe and Filter in Python – examples
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的管道和过滤器 - 示例
- en: Introducing MVC
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍MVC
- en: 'Model View Controller or MVC is a well known and popular architectural pattern
    for building interactive applications. MVC splits the application into three components:
    the Model, the View, and the Controller.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 模型视图控制器或MVC是用于构建交互式应用程序的众所周知和流行的架构模式。MVC将应用程序分为三个组件：模型，视图和控制器。
- en: '![Introducing MVC](../Images/image00489.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![介绍MVC](../Images/image00489.jpeg)'
- en: Model-View-Controller (MVC) Architecture
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 模型-视图-控制器（MVC）架构
- en: 'The three components perform the following responsibilities:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个组件执行以下职责：
- en: '**Model**: The model contains the core data and logic of the application.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：模型包含应用程序的核心数据和逻辑。'
- en: '**View**: The view(s) form the output of the application to the user. They
    display information to the user. Multiple views of the same data are possible.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：视图形成应用程序向用户的输出。它们向用户显示信息。可以有同一数据的多个视图。'
- en: '**Controller**: The controller receives and processes user input such as keyboard
    clicks or mouse clicks/movements, and converts them into change requests for the
    model or the view.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：控制器接收和处理用户输入，如键盘点击或鼠标点击/移动，并将它们转换为对模型或视图的更改请求。'
- en: Separation of concerns using these three components avoids tight coupling between
    the data of the application and its representation. It allows for multiple representations
    (views) of the same data (model), which can be computed and presented according
    to user input received via the controller.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三个组件分离关注避免了应用程序的数据和其表示之间的紧密耦合。它允许同一数据（模型）的多个表示（视图），可以根据通过控制器接收的用户输入进行计算和呈现。
- en: 'The MVC pattern allows the following interactions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: MVC模式允许以下交互：
- en: A model can change its data depending upon inputs received from the controller.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模型可以根据从控制器接收的输入更改其数据。
- en: The changed data is reflected on the views, which are subscribed to changes
    in the model.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改的数据反映在视图上，这些视图订阅了模型的更改。
- en: Controllers can send commands to update the model's state, such as when making
    changes to a document. Controllers can also send commands to modify the presentation
    of a view without any change to the model, such as zooming in on a graph or chart.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器可以发送命令来更新模型的状态，例如在对文档进行更改时。控制器还可以发送命令来修改视图的呈现，而不对模型进行任何更改，例如放大图表或图表。
- en: The MVC pattern implicitly includes a change propagation mechanism to notify
    each component of changes on the other dependent components.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MVC模式隐含地包括一个变更传播机制，以通知其他依赖组件的变更。
- en: A number of web applications in the Python world implement MVC or a variation
    of it. We will look at a couple of them, namely Django and Flask, in the coming
    sections.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python世界中的许多Web应用程序实现了MVC或其变体。我们将在接下来的部分中看一些，即Django和Flask。
- en: Model Template View (MTV) – Django
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板视图（MTV） - Django
- en: The Django project is one of the most popular web application frameworks in
    the Python world. Django implements something like an MVC pattern, but with some
    subtle differences.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Django项目是Python世界中最受欢迎的Web应用程序框架之一。Django实现了类似MVC模式的东西，但有一些细微的差异。
- en: 'The Django (core) component architecture is illustrated in the following diagram:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Django（核心）组件架构如下图所示：
- en: '![Model Template View (MTV) – Django](../Images/image00490.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![Model Template View (MTV) – Django](../Images/image00490.jpeg)'
- en: Django Core Component Architecture
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Django核心组件架构
- en: 'The core components of the Django framework are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Django框架的核心组件如下：
- en: An **Object Relational Mapper** (**ORM**), which acts as a mediator between
    data models (Python) and the database (RDBMS)—this can be thought of as the **Modle**
    layer.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象关系映射器（ORM），充当数据模型（Python）和数据库（关系数据库管理系统）之间的中介 - 这可以被认为是模型层。
- en: A set of callback functions in Python, which renders the data to the user interface
    for a specific URL—this can be thought of as the **VIEW** layer. The view focuses
    on building and transforming the content rather than on its actual presentation.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的一组回调函数，将数据呈现给特定URL的用户界面 - 这可以被认为是VIEW层。视图侧重于构建和转换内容，而不是实际呈现。
- en: A set of HTML templates to render content in different presentations. The view
    delegates to a specific template, which is responsible for how the data is presented.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组HTML模板，用于以不同的方式呈现内容。视图委托给特定模板，该模板负责数据的呈现方式。
- en: A regular expression-based **URL DISPATCHER**, which connects relative paths
    on the server to specific views and their variable arguments. This can be thought
    of as a rudimentary **Controller**.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于正则表达式的URL DISPATCHER，将服务器上的相对路径连接到特定视图及其变量参数。这可以被认为是一个基本的控制器。
- en: In Django, since the presentation is performed by the **TEMPLATE** layer and
    only the content mapping done by the **VIEW** layer, Django is often described
    as implementing the **Model Template View** (**MTV**) framework.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Django中，由于呈现是由TEMPLATE层执行的，而只有VIEW层执行内容映射，因此Django经常被描述为实现Model Template View（MTV）框架。
- en: The Controller in Django is not very well defined – it can be thought of as
    the entire framework itself – or limited to the **URL DISPATCHER** layer.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django中的控制器并没有很好地定义 - 它可以被认为是整个框架本身 - 或者限于URL DISPATCHER层。
- en: Django admin – automated model-centric views
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django admin - 自动化的模型中心视图
- en: One of the most powerful components of the Django framework is its automatic
    admin system, which reads metadata from the Django models, and generates quick,
    model-centric admin views, where administrators of the system can view and edit
    data models via simple HTML forms.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Django框架最强大的组件之一是其自动管理员系统，它从Django模型中读取元数据，并生成快速的、以模型为中心的管理员视图，系统管理员可以通过简单的HTML表单查看和编辑数据模型。
- en: 'For illustration, the following is an example of a Django model that describes
    a term that is added to a website as a `glossary` term (A glossary is a list or
    index of words that describes the meaning of words related to a specific subject,
    text, or dialect):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，以下是一个描述将术语添加到网站作为“词汇”术语的Django模型的示例（词汇是描述与特定主题、文本或方言相关的词汇含义的列表或索引）：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is combined with an admin system that registers a model for an automated
    admin view:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这与一个注册模型以获得自动化管理员视图的管理员系统相结合：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is an image of the automated admin view (HTML form) for adding
    a glossary term via the Django admin interface:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通过Django admin界面添加术语词汇的自动化管理员视图（HTML表单）的图像：
- en: '![Django admin – automated model-centric views](../Images/image00491.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![Django admin – automated model-centric views](../Images/image00491.jpeg)'
- en: Django Automated Admin View (HTML form) for adding a glossary term
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Django自动管理员视图（HTML表单）用于添加词汇术语
- en: A quick observation tells you how the Django admin is able to generate the correct
    field type for the different data fields in the model, and generate a form for
    adding the data. This is a powerful pattern that is present in Django, which allows
    one to generate automated admin views for adding/editing models with almost zero
    coding effort.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 快速观察告诉您Django管理员如何为模型中的不同数据字段生成正确的字段类型，并生成添加数据的表单。这是Django中的一个强大模式，允许您以几乎零编码工作量生成自动化的管理员视图以添加/编辑模型。
- en: Let us now look at another popular Python web application framework, namely,
    Flask.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看另一个流行的Python Web应用程序框架，即Flask。
- en: Flexible Microframework – Flask
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 灵活的微框架 - Flask
- en: 'Flask is a micro web framework, which uses a minimalistic philosophy for building
    web applications. Flask relies on just two libraries: the Werkzeug ([http://werkzeug.pocoo.org/](http://werkzeug.pocoo.org/))
    WSGI tool kit and the Jinja2 templating framework.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Flask是一个微型Web框架，它使用了一种最小主义的哲学来构建Web应用程序。Flask仅依赖于两个库：Werkzeug（[http://werkzeug.pocoo.org/](http://werkzeug.pocoo.org/)）WSGI工具包和Jinja2模板框架。
- en: Flask comes with simple URL routing via decorators. The *micro* word in Flask
    indicates that the core of the framework is small. Support for databases, forms,
    and others is provided by multiple extensions that the Python community has built
    around Flask.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Flask通过装饰器提供了简单的URL路由。Flask中的“微”一词表明框架的核心很小。对数据库、表单和其他功能的支持是由Python社区围绕Flask构建的多个扩展提供的。
- en: The core Flask can thus be thought of as an MTV framework minus the M (View
    Template), since the core does not implement support for models.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Flask的核心可以被认为是一个MTV框架减去M（视图模板），因为核心不实现对模型的支持。
- en: 'Here is an approximate schematic diagram of the Flask component architecture:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Flask组件架构的近似示意图：
- en: '![Flexible Microframework – Flask](../Images/image00492.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![Flexible Microframework – Flask](../Images/image00492.jpeg)'
- en: Schematic diagram of Flask components
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Flask组件的示意图
- en: 'A simple Flask application using templates looks something like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can find a few components of the MVC pattern right here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The `@app.route` decorator routes requests from the browser to the `index` function.
    The application router can be thought of as the controller.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `index` function returns the data, and renders it using a template. The
    `index` function can be thought of as generating the view or the view component.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask uses templates like Django to keep the content separate from the presentation.
    This can be thought of as the template component.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no specific model component in Flask core. However, this can be added
    on with the help of additional plugins.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask uses a plugin architecture to support additional features. For example,
    models can be added on by using Flask-SQLAlchemy, RESTful API support using Flask-RESTful,
    serialization using Flask-marshmallow, and others.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event-driven programming
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Event-driven programming is a paradigm of system architecture where the logic
    flow within the program is driven by events such as user actions, messages from
    other programs, or hardware (sensor) inputs.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: In Event-driven architectures, there is usually a main event loop, which listens
    for events, and then triggers callback functions with specific arguments when
    an event is detected.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: In modern operating systems like Linux, support for events on input file descriptors
    such as sockets or opened files are implemented by system calls such as `select`,
    `poll`, and `epoll`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Python provides wrappers to these system calls via its `select` module. It is
    not very difficult to write a simple Event-driven program using the `select` module
    in Python.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The following set of programs together implement a basic chat server and client
    in Python using the power of the select module.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Chat server and client using I/O multiplexing with the select module
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our chat server uses the `select` system call via the `select` module to create
    channels where clients can connect to and talk with each other. It handles the
    events (sockets) that are input ready–if the event is a client connecting to the
    server, it connects and performs a handshake; if the event is data to be read
    from standard input, the server reads the data, or else it passes the data received
    from one client to the others.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our chat server:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the code of the chat server is big, we are only including the main function,
    namely the serve one here showing how the server uses select-based I/O multiplexing.
    A lot of code in the `serve` function has also been trimmed to keep the printed
    code small.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The complete source code can be downloaded from the code archive of this book
    from the book's website.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The chat server can be stopped by sending a single line of empty input.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'The chat client also uses the `select` system call. It uses a socket to connect
    to the server, and then waits for events on the socket plus the standard input.
    If the event is from the standard input, it reads the data. Otherwise, it sends
    the data to the server via the socket:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The chat client can be stopped by pressing *Ctrl* + *C* on the terminal.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to send data to and fro via sockets, both these scripts use a third
    module named `communication`, which has a `send` and a `receive` function. This
    module uses pickle to serialize and deserialize data in the `send` and `receive`
    functions, respectively:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following are some images of the server running and two clients that are
    connected to each other via the chat server:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the image of client #1 named `andy` connected to the chat server:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![Chat server and client using I/O multiplexing with the select module](../Images/image00493.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: 'Chat session of chat client #1 (client name: andy)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, here is a client named `betty` who is connected to the chat server
    and is talking to `andy`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![Chat server and client using I/O multiplexing with the select module](../Images/image00494.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: 'Chat session of chat client #2 (client name: betty)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Some interesting points of program are listed as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: See how the clients are able to see each other's messages. This happens because
    the server sends the data sent by one client to all the other connected clients.
    Our chat server prefixes the messages with a hash `#` to indicate that this message
    is from another client.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how the server sends connection and disconnection information of a client
    to all other clients. This informs the clients when another client is connected
    to or disconnected from the session.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The server echoes messages when a client disconnects saying that the client
    *hung up*:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding chat server and client example is a minor variation of the author's
    own Python recipe in the ASPN Cookbook at [https://code.activestate.com/recipes/531824](https://code.activestate.com/recipes/531824).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: The simple select-based multiplexing is taken to the next level by libraries
    such as Twisted, Eventlet, and Gevent in order to build systems that provide high
    level event-based programming routines to the programmer, typically based on a
    core event loop very similar to the loop of our chat server example.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the architecture of these frameworks in the following sections.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven programming versus Concurrent programming
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example we saw in the previous section uses the technique of asynchronous
    events as we saw in the chapter on concurrency. This is different from true concurrent
    or parallel programming.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Event programming libraries also work on the technique of asynchronous events.
    There is only a single thread of execution in which tasks are interleaved one
    after another based on the events received.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, consider a truly parallel execution of three tasks
    by three threads or processes:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![Event-driven programming versus Concurrent programming](../Images/image00495.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: Parallel execution of three tasks using three threads
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Contrast this with what happens when the tasks are executed via Event-driven
    programming as depicted in the following diagram:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![Event-driven programming versus Concurrent programming](../Images/image00496.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: Asynchronous execution of three tasks in a single thread
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: In the asynchronous model, there is only one single thread of execution with
    tasks executing in an interleaved fashion. Each task gets its own slot of processing
    time in the event loop of the asynchronous processing server, but only one task
    executes at a given time. Tasks yield control back to the loop so that it can
    schedule a different task in the next time slice from the task that is being executed
    currently. As we have seen in [Chapter 5](part0040.xhtml#aid-164MG1 "Chapter 5. Writing
    Applications That Scale"), *Writing Applications that Scale*, this is a kind of
    cooperative multitasking.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Twisted
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Twisted is an Event-driven networking engine with support for multiple protocols,
    such as DNS, SMTP, POP3, IMAP, and so on. It also comes with support for writing
    SSH clients and servers, and to build messaging and IRC clients and servers.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Twisted also provides a set of patterns (styles) to write common servers and
    clients, such as Web Server/Client (HTTP), Publish/Subscribe patterns, Messaging
    Clients and Servers (SOAP/XML-RPC), and others.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: It uses the Reactor design pattern, which multiplexes and dispatches events
    from multiple sources to their event handlers in a single thread.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: It receives messages, requests, and connections coming from multiple concurrent
    clients, and processes these posts sequentially using event handlers without requiring
    concurrent threads or processes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'The reactor pseudo-code looks, approximately, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Twisted uses callbacks to call event handlers as and when an event happens.
    To handle a specific event, a callback is registered for that event. Callbacks
    can be used for regular processing, and also for managing exceptions (errbacks).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Like the `asyncio` module, Twisted uses an object such as futures in order to
    wrap the results of a task execution, whose actual results are still not available.
    In Twisted, these objects are called **Deferreds**.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Deferred objects have a pair of callback chains: one for processing results
    (callbacks) and one for managing errors (errbacks). When the result of an execution
    is obtained, a Deferred object is created, and its callbacks and/or errbacks are
    called in the order in which they were added.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an architecture diagram of Twisted, showing the high-level components:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![Twisted](../Images/image00497.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: Twisted – Core Components
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Twisted – a simple web client
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is a simple example of a web HTTP client using Twisted, fetching
    a given URL and saving its contents to a specific filename:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see in the preceding code, the `getPage` method returns a deferred,
    and not the data of the URL. To the deferred, we add two callbacks: one for processing
    the data (the `save_page` function) and another for handling errors (the `handle_error`
    function). The `addBoth` method of the deferred adds a single function as both
    callback and errback.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The event processing is started by running the reactor. In the `finish_processing`
    callback, which is called at the end, the reactor is stopped. Since event handlers
    are called in the order that they are added, this function will be called only
    at the very end.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'When the reactor is run the following events happen:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The page is fetched and the deferred is created.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The callbacks are called in order on the deferred. First the `save_page` function
    is called, which saves contents of the page to the `content.html` file. Then a
    `handle_error` event handler is called, which prints any error string.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `finish_processing` is called, which stops the reactor and the event
    processing ends, exiting the program.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing, Twisted is not yet available for Python3, so the preceding
    code is written for Python2.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the code, you will see that the following output is produced:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Chat Server using Twisted
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's now see how we can write a simple chat server in Twisted on lines similar
    to our chat server using the `select` module.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: In Twisted, servers are built by implementing protocols and protocol factories.
    A protocol class typically inherits from the Twisted `Protocol` class.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: A factory is nothing but a class that serves as a factory pattern for protocol
    objects.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this, here is our chat server using Twisted:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our chat server is a bit more sophisticated than the one before as it performs
    the following additional steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: It has a separate handshake protocol using the special `<handshake>` message.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a client connects, it is broadcast to other clients informing them of the
    client's name and connection details.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a client disconnects, other clients are informed about this.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The chat client also uses Twisted and uses two protocols – namely a `ChatClientProtocol`
    for communication with the server and a `StdioClientProtocol` for reading data
    from standard input and echoing data received from the server to the standard
    output.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The latter protocol also connects the former one to its input, so that any data
    that is received on the standard input is sent to the server as a chat message.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here are some screenshots of the two clients `andy` and `betty` communicating
    using this chat server and client:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![Chat Server using Twisted](../Images/image00498.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: 'Chat client using Twisted chat server – session for client #1 (andy)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the second session, for the client betty:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![Chat Server using Twisted](../Images/image00499.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: 'Chat client using Twisted chat server – session for client #2 (betty)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: You can follow the flow of the conversation by alternately looking at the screenshots.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Note the connection and disconnection messages sent by the server when user
    betty connects and user andy disconnects respectively.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Eventlet
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Eventlet is another well known networking library in the Python world that allows
    one to write Event-driven programs using the same concept of asynchronous execution.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Eventlet uses co-routines for this purpose with the help of a set of so-called
    *green threads*, which are light-weight user-space threads that perform cooperative
    multitasking.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Eventlet uses an abstraction over a set of green threads, the `Greenpool` class,
    in order to perform its tasks.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The `Greenpool` class runs a predefined set of `Greenpool` threads (default
    is `1000`), and provides ways to map functions and callables to the threads in
    different ways.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the multiuser chat server rewritten using Eventlet:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This server can be used with the Twisted chat client that we've seen in the
    previous example, and behaves in exactly the same way. Hence, we will not show
    running examples of this server.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The Eventlet library internally uses `greenlets`, a package that provides green
    threads on Python runtime. We will see greenlet and a related library, Gevent,
    in the following section.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Greenlets and Gevent
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Greenlet is a package that provides a version of green or microthreads on top
    of the Python interpreter. It is inspired by Stackless, a version of CPython that
    supports microthreads called stacklets. However, greenlets are able to run on
    the standard CPython runtime.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Gevent is a Python networking library providing high-level synchronous API on
    top of `libev`, the event library written in C.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Gevent is inspired by gevent, but it features a more consistent API and better
    performance.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Like Eventlet, gevent does a lot of monkey patching on system libraries to provide
    support for cooperative multitasking. For example, gevent comes with its own sockets,
    just like Eventlet does.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Eventlet, gevent also requires explicit monkey patching to be done by
    the programmer. It provides a method to do this on the module itself.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Without further ado, let us look at how the multiuser chat server using gevent
    looks like:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The code for the gevent-based chat server is almost the same as the one using
    Eventlet. The reason for this is that both work in very similar ways by handling
    control to a callback function when a new connection is made. In both cases the
    callback function is named `new_chat_channel`, which has the same functionality
    and hence very similar code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'The differences between the two are as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: gevent provides its own TCP server class—`StreamingServer`–so we use that instead
    of listening on the module directly
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the gevent server, for every connection the `new_chat_channel` handler is
    invoked, hence the participant set is managed there
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the gevent server has its own event loop, there is no need to create a
    while loop for listening for incoming connections as we had to do with Eventlet
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This example works exactly the same as the previous ones and works with the
    Twisted chat client.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Microservice architecture
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservice architecture is an architectural style of developing a single application
    as a suite of small independent services, each running in its own process and
    communicating via light-weight mechanisms—typically, using HTTP protocol.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Microservices are independently deployable components, and usually, have zero
    or minimalistic central management or configuration.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Microservices can be thought of as a specific implementation style for **Service
    Oriented Architectures** (**SOA**), where, instead of building a monolith application
    top-down, the application is built as a dynamic group of mutually interacting,
    independent services.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, enterprise applications were built in a monolithic pattern,
    typically consisting of these three layers:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: A client-side User Interface (UI) layer consisting of HTML and JavaScript.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A server-side application consisting of the business logic.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A database and data access layer, which holds the business data.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the other hand, a microservices architecture will split this layer into multiple
    services. For example, the business logic, instead of being in a single application,
    will be split into multiple component services, whose interactions define the
    logic flow inside the application. The services might query a single database
    or independent local databases with the latter configuration being more common.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Data in microservices architectures are usually processed and returned in the
    form of document objects – typically encoded in JSON.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'The following schematic diagram illustrates the difference of a monolithic
    architecture from a microservices one:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservice architecture](../Images/image00500.jpeg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: Monolithic (left) vs Microservices (right) Architecture
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Microservice frameworks in Python
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With microservices being more of a philosophy or style of architecture, there
    are no distinct classes of software frameworks that one can say is the right fit
    for them. However, one can still make a few educated projections for the properties
    that a framework should have for it being a good choice for building a microservices
    architecture for your web application in Python. These properties include the
    following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The component architecture should be flexible. The framework should not be rigid
    in the component choices that it stipulates to make the different parts of the
    system work.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core of the framework should be lightweight. This makes sense, since if
    we start off with, say, a lot of dependencies for the microservices framework
    itself, the software starts feeling heavy right in the beginning. This may cause
    issues in deployment, testing, and so on.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The framework should support zero or minimalistic configuration. Microservices
    architectures are usually configured automatically (zero configuration) or with
    a minimal set of configuration inputs that are available at one place. Usually
    the configuration is itself available as a microservice for other services to
    query and make the sharing of configuration easy, consistent, and scalable.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should make it very easy to take an existing piece of business logic, say
    coded as a class or a function, and turn it into an HTTP or RCP service. This
    allows reuse and smart refactoring of code.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you use these principles and look around in the Python software ecosystem,
    you will figure out that a few web application frameworks fit the bill, whereas
    a few don't.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: For example, Flask and its single-file counterpart Bottle are good candidates
    for a microservices framework due to their minimal footprint, small core, and
    simple configuration.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: A framework such as Pyramid can also be used for a microservices architecture
    since it promotes flexibility of choice of components and eschews tight integration.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: A more sophisticated web framework such as Django makes a poor choice for a
    microservices framework due to exactly the opposite reasons–tight vertical integration
    of components, lack of flexibility in choosing components, complex configuration,
    and so on.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Another framework that is written specifically for implementing microservices
    in Python is Nameko. Nameko is geared towards testability of the application,
    and it provides support for different protocols for communication such as HTTP,
    RPC (over AMQP)—a Pub-Sub system, and a Timer service.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: We will not be going into details of these frameworks. On the other hand, we
    will take a look at architecting and designing a real-life example of a web application
    using microservices.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Microservices example – restaurant reservation
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us take a real-life example for a Python web application, and try and design
    it as a set of microservices.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Our application is a restaurant reservation app that helps users make a reservation
    for a certain number of people at a specific time in a restaurant close to their
    current location. Assume that reservations are only done for the same day.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'The application needs to do the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Return a list of restaurants open for business at the time for which the user
    wants to make the reservation.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a given restaurant, return enough meta information, such as cuisine choices,
    rating, pricing, and so on, and allow the user to filter the hotels based on their
    criteria.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the user has made a choice, allow them to make a reservation on the selected
    restaurant for a certain number of people for a given time.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each of these requirements is granular enough to have their own microservice.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, our application will be designed with the following set of microservices:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: A service that uses the user's location, and returns a list of restaurants open
    for business, and which support the online reservation API.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A second service that retrieves metadata for a given hotel, given the restaurant
    ID. The application can use this metadata to compare against the user's criteria
    to see if it's a match.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A third service, which, given a restaurant ID, the user's information, the number
    of seats required, and the time of reservation, uses the reservation API to make
    a reservation for seats, and returns the status.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core parts of the application logic now fit these three microservices. Once
    they are implemented, the plumbing—in terms of calling these services and performing
    a reservation—will happen in the application logic directly.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: We will not be showing any code for this application as that is a project in
    its own, but we will show the reader how the microservices look like in terms
    of their APIs and return data.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservices example – restaurant reservation](../Images/image00501.jpeg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: Architecture of restaurant reservation application using microservices
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'A microservice usually returns data in the form of JSON. For example, our first
    service that returns a list of restaurants would return a JSON similar to the
    one that follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The second service, which returns restaurant metadata, would mostly return
    a JSON like this one:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the interaction for the third one, which does a booking given the restaurant
    ID:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Since this service needs the user to provide information for the reservation,
    it needs a JSON payload with the details of booking. Hence, this is best done
    as an HTTP POST call.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The service in this case will use the following given payload as the POST data:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It will return a JSON like the following as a response:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With this design in place, it is not very difficult to implement the application
    in a framework of your choice, whether it be Flask, Bottle, Nameko, or anything
    else.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Microservices – advantages
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So what are the advantages of using microservices over a monolithic application?
    Let us take a look at some of the important ones:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Microservices enhance separation of concern by splitting the application logic
    into multiple services. This improves cohesion, and decreases coupling. There
    is no need for a top-down, upfront design of the system, since the business logic
    is not in a single place. Instead, the architect can focus on the interplay and
    communication between the microservices and the application, and let the design
    and architecture of the microservices itself emerge iteratively through refactoring.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices improve testability, since now each part of the logic is independently
    testable as a separate service, and hence, is easy to isolate from other parts,
    and test.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teams can be organized around the business capabilities rather than around tiers
    of the application or technology layers. Since each microservice includes logic,
    data, and deployment, companies using microservices encourage cross-functional
    roles. This helps to build a more agile organization.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices encourage decentralized data. Usually, each service will have
    its own local database or data store instead of the central database that is preferred
    by monolithic applications.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices facilitate continuous delivery and integration, and fast deployments.
    Since a change to business logic might often need only a small change in one or
    a few services, testing and redeployment can be often done in tight cycles, and
    in most cases, can be fully automated.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipe and Filter architectures
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pipe and Filter is a simple architectural style, which connects a number of
    components that process a stream of data, each connected to the next component
    in the processing pipeline via a **Pipe**.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: The Pipe and Filter architecture is inspired by the Unix technique of connecting
    the output of an application to the input of another via pipes on the shell.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'The Pipe and Filter architecture consists of one or more data sources. The
    data source is connected to data filters via pipes. Filters process the data they
    receive, passing them to other filters in the pipeline. The final data is received
    at a **Data Sink**:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipe and Filter architectures](../Images/image00502.jpeg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: Pipe and Filter Architecture
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Pipe and filter are used commonly for applications that perform a lot of data
    processing such as data analytics, data transformation, metadata extraction, and
    so on.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: The filters can be running on the same machine, and they use actual Unix pipes
    or shared memory for communication. However, in large systems, these usually run
    on separate machines, and the pipes need not be actual pipes, but any kind of
    data channel such as sockets, shared memory, queues, and the like.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Multiple filter pipelines can be connected together to perform complex data
    processing and data staging.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: A very good example of a Linux application that works using this architecture
    is `gstreamer`—the multimedia processing library that can perform a number of
    tasks on multimedia video and audio including play, record, edit, and stream.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Pipe and Filter in Python
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Python, we encounter pipes in their most pure form in the multiprocessing
    module. The multiprocessing module provides Pipes as a way to communicate from
    one process to another.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: A pipe is created as a pair of parent and child connections. What is written
    on one side of the connection can be read on the other side and vice versa.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to build very simple pipelines of data processing.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, on Linux, the number of words in a file can be computed by this
    series of commands:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will write a simple program that mimics this pipeline using the multiprocessing
    module:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is an analysis of the workflow:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: A pipe is created, and two connections are obtained.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `read` function is executed as a process, passing one end of the pipe (child)
    and the filename to be read.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This process reads the file, writing the data to the connection.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `words` function is executed as a second process, passing the other end
    of the pipe to it.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When this function executes as a process, it reads the data from the connection,
    and prints the number of words.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of both the shell command and the
    preceding program on the same file:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipe and Filter in Python](../Images/image00503.jpeg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
- en: Output of a shell command using pipes and its equivalent Python program
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: You do not need to use an object that looks like an actual pipe in order to
    create pipelines. On the other hand, generators in Python provide an excellent
    way to create a set of callables, which call each other, and consume and process
    each other's data, producing a pipeline of data processing.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the same example as the previous one, rewritten to use generators,
    and this time, to process all the files in the folder matching a particular pattern:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is a screenshot of the output:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipe and Filter in Python](../Images/image00504.jpeg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
- en: Output of a pipeline using generators that print the word count of Python programs
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One can verify the output of a program such as the preceding one using this
    command:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is another program that uses another couple of data filtering generators
    to build a program, which watches files matching a specific pattern and prints
    information about the most recent file—something similar to what is done by the
    watch program on Linux:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The details of this last program should be self-explanatory to the reader.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output of our program on the console, watching over Python source
    files:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipe and Filter in Python](../Images/image00505.jpeg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
- en: Output of the program that watches over recently modified Python source files
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'If we create an empty Python source file, say `example.py`, the output changes
    in two seconds:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipe and Filter in Python](../Images/image00506.jpeg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
- en: Output of the watch program changes, always showing the most recently modified
    file
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: The underlying technique of using generators (co-routines) to build such pipelines
    is to connect the output of one generator to the input of the next. By connecting
    many such generators in a series, one can build data processing pipelines that
    vary in complexity from simple to complex.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Of course, one can use a number of techniques for building pipelines apart from
    this. Some common choices are producer-consumer tasks connected using queues,
    which can use threads or processes. We have seen examples of this in the chapter
    on scalability.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Microservices can also build simple processing pipelines by connecting the input
    of one microservice to the output of another.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: In the Python third-party software ecosystem, there are a number of modules
    and frameworks that allow you to build complex data pipelines. Celery, though
    a task queue, can be used to build simple batch processing workflows with limited
    pipeline support. Pipelining is not the strong feature of celery, but it has limited
    support for chaining tasks that can be used for this purpose.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Luigi is another robust framework that is written for complex, long-running
    batch processing jobs that require a pipe and filter architecture. Luigi comes
    with built-in support for Hadoop jobs, so it makes it a good choice for building
    data analytics pipelines.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at some common architectural patterns of building
    software. We started with the Model View Controller architecture, and looked at
    examples in Django and Flask. You learned about the components of an MVC architecture,
    and learned that Django implements a variant of MVC using templates.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: We looked at Flask as an example of a micro framework that implements the minimal
    footprint of a web application by using a plugin architecture with additional
    services that can be added on.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: We went on to discuss the Event-driven programming architecture, which is a
    kind of asynchronous programming using co-routines and events. We started with
    a multiuser chat example using the `select` module in Python. From there, we went
    on to discuss larger frameworks and libraries.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the architecture of Twisted and its components. We also discussed
    Eventlet and its close cousin gevent. For each of these frameworks, we saw an
    implementation of the multiuser chat server.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Next, we took up microservices as an architecture, which builds scalable services
    and deployments by splitting the core business logic across multiple services.
    We designed an example of a restaurant reservation application using microservices,
    and briefly looked at the landscape of Python web frameworks, which can be used
    to build microservices.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Towards the end of the chapter, we saw the architecture of using Pipes and Filters
    for serial and scalable data processing. We built a simple example of actual pipes
    using the multiprocessing module in Python, which mimicked a Unix pipe command.
    We then looked at the technique of building pipelines using generators, and saw
    couple of examples. We summarized techniques for building pipelines and frameworks
    available in the Python third-party software ecosystem.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of the chapter on application architectures. In the
    next chapter, we will look at deployability - namely the aspect of deploying software
    to environments such as production systems.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
