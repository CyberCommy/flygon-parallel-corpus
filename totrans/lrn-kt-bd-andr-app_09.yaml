- en: Connecting the Outside World – Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We live in the era of digital communication. Handheld devices play a huge role
    in communication and impact the way people interact. In the previous chapter,
    we discussed one of the powerful functions of Android—identifying the location
    of the user and customizing services based on location. In this chapter, we will
    focus on one of the most useful and powerful features of the Android devices—networking
    and connecting to the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: While we will provide brief coverage on the important concepts of network connectivity
    and the Android framework support for networking, we will specifically focus on
    configuration and the usage of various built-in, third-party libraries. We will
    also learn how to load an image from a URL and display it in the sample app we
    create.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Network connectivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android framework support for networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage of built-in libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage of third-party libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network connectivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Understanding and identifying the status and type of network the user is connected
    to is very vital for delivering an enriching experience to our users. The Android
    framework provides us with a couple of classes that we can use to find the details
    of the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ConnectivityManager`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NetworkInfo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the `ConnectivityManager` provides information about the state of the
    network's connectivity and the changes it undergoes, `NetworkInfo` provides information
    on the type of network—mobile or Wi-Fi.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet helps to establish whether a network is indeed available
    and whether the device is connected to the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `isOnline()` method returns a `Boolean`—true or false based on the result
    returned by the `ConnectivityManager`. The `connMgr` instance is used along with `NetworkInfo` to
    find the information about the network.
  prefs: []
  type: TYPE_NORMAL
- en: Manifest permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Accessing the network and sending/receiving the data would require permission
    to access the internet and the network state. The following permissions must be
    defined in the manifest file for the app to take advantage of the network of the
    device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The internet permission allows the app to communicate by enabling network sockets
    while the access network state permission enables it to find information about
    available networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Android framework provides a default intent, `MANAGE_NETWORK_USAGE`, for
    the app to manage the network data. The activity for handling the intent can be
    implemented specific to the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Volley library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to communicate with web servers via an HTTP protocol and exchange
    information in the form of strings, JSON, and images makes an app much more interactive
    and provides users with a rich experience. Android has a built-in HTTP library
    called `Volley` that does this information exchange out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to making the information exchange easier, `Volley` also provides
    easier means for one to handle the entire lifecycle of a request viz schedule,
    cancel, prioritize, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '`Volley` is quite good for lightweight network operations and makes information
    exchange easier. For huge downloads and streaming operations, developers should
    use Download Manager.'
  prefs: []
  type: TYPE_NORMAL
- en: Sync adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping the data in the app in sync with the web server enables developers to
    provide a rich experience for users. The Android framework provides **sync adapters** that
    enable data sync to happen at a defined periodic interval.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to `Volley`, sync adapters have all the facilities to handle the life
    cycle of data transfer and provide a seamless means of data exchange.
  prefs: []
  type: TYPE_NORMAL
- en: Sync adapter implementation typically contains a stub authenticator, a stub
    content provider, and a sync adapter.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the built-in support of the Android framework, we do have quite
    a few third-party libraries available to handle network operations. Out of those,
    `Picasso` from Square and `Glide` from bumptech are widely used image downloading
    and caching libraries.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will focus on the implementation of these two libraries—`Picasso`
    and `Glide`—to load an image from a specific URL and display it in our sample
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Networking calls should **never** be done on the main thread. Doing so will
    result in the app becoming less responsive and create Application Not Responding
    conditions. Instead, we should create separate worker threads which handle such
    network calls and provide information as and when the request is attended to.
  prefs: []
  type: TYPE_NORMAL
- en: Picasso
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this sample project, let's understand how to use the `Picasso` library from
    Square and load an image from a specified URL.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a new Android project and call it ImageLoader. We need to ensure
    Kotlin support is checked.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the Image Loader sample, we can proceed by selecting Empty Activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a72a3ccd-c160-45d2-a4af-bea01c47a226.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let us name the activity `MainActivity`, the one appears by default and have
    the XML named as `activity_main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d26151dc-849d-4469-b1a2-b046f862eaf8.png)'
  prefs: []
  type: TYPE_IMG
- en: User interface – XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default XML code that gets generated would contain a `TextView`. We need
    to tweak the XML code a bit and replace the `TextView` with an `ImageView`. This
    `ImageView` will provide the placeholder for displaying the image that would be
    fetched from the URL using `Picasso`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The XML code that follows shows that the default XML contains `TextView`; we
    shall be replacing the `TextView` with `ImageView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The modified XML that has an `ImageView` looks like the one shown in the code
    block that follows. We can easily add this by dragging the `ImageView` from the
    widgets or by typing in the code in XML layout. In the `ImageView`, we have marked
    it to display the launcher icon as the placeholder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`ImageViewer` displays the launcher icon in the placeholder marked for display
    of image on loading from the URL. The launcher icon is displayed as soon as we
    make the change in the XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8f504cc-dd4f-4670-9f0d-f744a011a103.png)'
  prefs: []
  type: TYPE_IMG
- en: build.gradle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to add the implementation `com.square.picasso.picasso:2.71828` in the
    `build.gradle` dependencies. Version 2.71828 is the latest at the time of writing.
    To make sure we use the latest version, it is prudent to check [http://square.github.io/picasso/](http://square.github.io/picasso/) and
    use the latest version in the Gradle dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add the following line in the dependencies section of the `build.gradle`
    file to have `Picasso` available for our app:'
  prefs: []
  type: TYPE_NORMAL
- en: implementation `com.squareup.picasso:picasso:2.71828`
  prefs: []
  type: TYPE_NORMAL
- en: 'The modified `build.gradle` file should look like the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Kotlin code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default Kotlin code generated will have the class file named `MainActivity`.
    This class file extends `AppCompatActivity`, which provides the support library
    action bar features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code loads the XML defined in the `activity_main` during the `onCreate`
    method and displays it on load. The `setContentView` reads the XML content defined
    in `activity_main` and displays the `ImageView` on load:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have made changes to the XML already by replacing the default `TextView`
    with `ImageView`. We need to reflect those changes in our Kotlin code and also
    implement the loading of the image by using `Picasso`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add the `ImageView` and `Picasso` imports for our program to use
    these components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have already imported `Picasso` and ensured the dependencies were added,
    we should be able to load the date by a single line of code, `Picasso.get().load("URL").into(ImageView)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The final modified Kotlin class for Picasso image load should be as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Manifest permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to ensure our app has added the permission to access the internet. This
    is required as we are about to download the image from a specified URL and will
    have it displayed in our `ImageViewer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already covered the manifest permissions required in detail. Let us
    go ahead and add this permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The modified XML should look like the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that we are all set with the changes made to XML, the Kotlin Code, `build.gradle`,
    and the `AndroidManifest` file, it is time to launch our app and understand the
    seamless loading process of the image via `Picasso`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we run the app, we should be able to see our device load the page, display
    the app name ImageLoader and display the image shown here from the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d8a550f-cc50-454e-ac74-ec7f413f040f.png)'
  prefs: []
  type: TYPE_IMG
- en: Glide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Glide` from bumptech is another image loading library that is very popular.
    We shall look at using `Glide` and loading an image from a specific URL.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us go ahead and make the changes required for `Glide` in our `build.gradle`
    and other related files.
  prefs: []
  type: TYPE_NORMAL
- en: build.gradle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to add the plugin `kotlin-kapt` and add dependencies in our app's `build.gradle`
    file. Once we sync the changes made, we should be able to use `Glide` in our code
    and load the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Glide` library uses annotation processing. Annotation processing helps
    with the generation of boilerplate code and makes the code easier to understand.
    To observe the actual code that works at runtime, developers can check the generated
    code and understand the boilerplate code generated by the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `Glide` library talks about adding the annotation processor along with `Glide`
    in the dependencies. This is applicable for Java. For Kotlin, we need to add the `kapt`
    `Glide` compiler as shown in the code block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The modified `build.gradle` dependencies should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the project level `build.gradle` file, we need to add `mavenCentral()`in
    the `repositories` section, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We are done with changes to the `build.gradle` files; we should make the following
    additions to `proguard-rules.pro` file. The `proguard-rules.pro` file enables
    developers to shrink the APK size by removing references to unused and unwanted
    code in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to ensure the `Glide` module is **not** affected by proguard shrinking,
    we need to explicitly mention that app requires we **keep** references to `Glide`.
    The `*-*keep` command ensures that the reference to `Glide` and respective modules
    are retained in the build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Kotlin code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We define a separate class called `ImageLoaderGlideModule` which extends `AppGlideModule()`.
    The annotation `@GlideModule` on the class enables the app to have access to the
    `GlideApp` instance. The `GlideApp` instance can be used across various activities
    in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We need to make the following changes in the `MainActivity` Kotlin class to
    have the image loaded by `Glide` and display it when the app is launched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to `Picasso`, `Glide` also has a simple syntax for loading an image
    from a specified URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The modified `MainActivity` Kotlin class should look like the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We have done all the changes required for `Glide`—`build.gradle`, `Proguard.rules`,
    and the Kotlin class files. We should see the app load the image from the specified
    URL and display it in the `ImageView` as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc948b2a-1cd8-4fe7-8f7d-aa7e6516132b.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networking and connecting to the outside world is a very powerful feature of
    Android devices. We covered the basics of networking, checking for the status
    of the network, the type of network available, and the built-in capabilities provided
    by the Android framework to perform network operations.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed the third-party libraries `Picasso` and `Glide`, the image
    loading libraries in detail, and covered the implementation of those libraries
    in our app.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will work on developing a simple to-do list app and
    discuss various concepts such as listview, dialog, and so on, and learn how to
    use them in the app.
  prefs: []
  type: TYPE_NORMAL
