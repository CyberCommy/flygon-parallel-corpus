- en: Chapter 4. Texting and Driving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: A basic regular expression primer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching and mining "text" inside a file with grep
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Column-wise cutting of a file with cut
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining the frequency of words used in a given file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic sed primer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic awk primer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing strings from a text or file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compressing or decompressing JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating through lines, words, and characters in a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merging multiple files as columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing the nth word or column in a file or line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing text between line numbers or patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking palindrome strings with a script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing lines in the reverse order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing e-mail address and URLs from text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing a set number of lines before or after a pattern in a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing a sentence in a file containing a word
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing head, tail, and tac with awk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text slicing and parameter operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Shell Scripting language is packed with essential problem-solving components
    for UNIX/Linux systems. Bash can always provide some quick solutions to the problems
    in a UNIX environment. Text processing is one of the key areas where shell scripting
    is used. It comes with beautiful utilities such as sed, awk, grep, cut, and so
    on, which can be combined to solve text processing related problems. Most of the
    programming languages are designed to be generic, and hence it takes a lot of
    effort to write programs that can process text and produce the desired output.
    Since Bash is a language that is designed by also keeping text processing in mind,
    it has a lot of functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Various utilities help to process a file in fine detail as a character, line,
    word, column, row, and so on. Hence we can manipulate a text file in many ways.
    Regular expressions are the core of pattern matching techniques. Most of the text
    processing utilities come with regular expression support. By using suitable regular
    expression strings, we can produce the desired output such as filtering, stripping,
    replacing, searching, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter includes a collection of recipes, which walks through many contexts
    of problems based on text processing that will be helpful in writing real scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Basic regular expression primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regular expressions are the heart of the pattern-matching based text-processing
    techniques. For fluency in writing text-processing tools, one must have basic
    understanding of regular expressions. Regular expressions are a form of tiny,
    highly-specialized programming language used to match text. Using wild card techniques,
    the scope of matching text with patterns is very limited. This recipe is a walk
    through of basic regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regular expressions are the language used in most text processing utilities.
    Hence you will use the techniques learned in this recipe in many other recipes.
    `[a-z0-9_]+@[a-z0-9]+\.[a-z]+` is an example of regular expression for matching
    an e-mail address.
  prefs: []
  type: TYPE_NORMAL
- en: Does this seem weird? Don't worry, it is really simple once you understand the
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will go through regex, the POSIX character class, and meta
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first go through the basic components of regular expressions (regex).
  prefs: []
  type: TYPE_NORMAL
- en: '| regex | Description | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | The start of the line marker. | `^tux` matches a string that starts
    the line with `tux`. |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | The end of the line marker. | `tux$` matches strings of a line that
    ends with `tux`. |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | Matches any one character. | `Hack.` matches `Hack1`, `Hacki` but not
    `Hack12`, `Hackil`, only one additional character matches. |'
  prefs: []
  type: TYPE_TB
- en: '| `[]` | Matches any one of the characters enclosed in `[chars]`. | `coo[kl]`
    matches `cook` or `cool`. |'
  prefs: []
  type: TYPE_TB
- en: '| `[^]` | Matches any one of the characters EXCEPT those that are enclosed
    in `[^chars]`. | `9[^01]` matches `92`, `93` but not `91` or `90`. |'
  prefs: []
  type: TYPE_TB
- en: '| `[-]` | Matches any character within the range specified in `[]`. | `[1-5]`
    matches any digits from `1` to `5`. |'
  prefs: []
  type: TYPE_TB
- en: '| `?` | The preceding item must match one or zero times. | `colou?r` matches
    `color` or `colour` but not `colouur`. |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | The preceding item must match one or more times. | `Rollno-9+` matches
    `Rollno-99`, `Rollno-9` but not `Rollno-`. |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | The preceding item must match zero or more times. | `co*l` matches
    `cl`, `col`, `coool`. |'
  prefs: []
  type: TYPE_TB
- en: '| `()` | Creates a substring from the regex match. | `ma(tri)?x` matches `max`
    or `matrix`. |'
  prefs: []
  type: TYPE_TB
- en: '| `{n}` | The preceding item must match n times. | `[0-9]{3}` matches any three-digit
    number. `[0-9]{3}` can be expanded as:`[0-9][0-9][0-9]`. |'
  prefs: []
  type: TYPE_TB
- en: '| `{n,}` | Minimum number of times that the preceding item should match. |
    `[0-9]{2,}` matches any number, that is, two digits or more. |'
  prefs: []
  type: TYPE_TB
- en: '| `{n, m}` | Specifies the minimum and maximum number of times the preceding
    item should match. | `[0-9]{2,5}` matches any number that is having two digits
    to five digits. |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | Alternation—one of the items on either of sides of &#124; should
    match. | `Oct (1st &#124; 2nd)` matches `Oct 1st` or `Oct 2nd`. |'
  prefs: []
  type: TYPE_TB
- en: '| `\` | The escape character for escaping any of the special characters mentioned
    above. | `a\.b` matches `a.b` but not `ajb`. It ignores special meaning of `.`by
    prefexing `\`. |'
  prefs: []
  type: TYPE_TB
- en: 'A POSIX character class is a special meta sequence of the form `[:...:]` that
    can be used to match a range of specified characters. The POSIX classes are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Regex | Description | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `[:alnum:]` | Alphanumeric character | `[[:alnum:]]+` |'
  prefs: []
  type: TYPE_TB
- en: '| `[:alpha:]` | Alphabet character (lowercase and uppercase) | `[[:alpha:]]{4}`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[:blank:]` | Space and tab | `[[:blank:]]*` |'
  prefs: []
  type: TYPE_TB
- en: '| `[:digit:]` | Digit | `[[:digit:]]?` |'
  prefs: []
  type: TYPE_TB
- en: '| `[:lower:]` | Lowercase alphabet | `[[:lower:]]{5,}` |'
  prefs: []
  type: TYPE_TB
- en: '| `[:upper:]` | Uppercase alphabet | `([[:upper:]]+)?` |'
  prefs: []
  type: TYPE_TB
- en: '| `[:punct:]` | Punctuation | `[[:punct:]]` |'
  prefs: []
  type: TYPE_TB
- en: '| `[:space:]` | All whitespace characters including newline, carriage return,
    and so on. | `[[:space:]]+` |'
  prefs: []
  type: TYPE_TB
- en: Meta characters are a type of Perl-style regular expression that is supported
    by a subset of text processing utilities. Not all of the utilities will support
    the following notations. But the above character classes and regular expression
    are universally accepted.
  prefs: []
  type: TYPE_NORMAL
- en: '| Regex | Description | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `\b` | Word boundary | `\bcool\b` matches only `cool` not `coolant`. |'
  prefs: []
  type: TYPE_TB
- en: '| `\B` | Non-word boundary | `cool\B` matches `coolant` and not `cool`. |'
  prefs: []
  type: TYPE_TB
- en: '| `\d` | Single digit character | `b\db` matches `b2b` not `bcb`. |'
  prefs: []
  type: TYPE_TB
- en: '| `\D` | Single non-digit | `b\Db` matches `bcb` not `b2b`. |'
  prefs: []
  type: TYPE_TB
- en: '| `\w` | Single word character(alnum and _) | `\w` matches `1` or a not `&`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `\W` | Single non-word character | `\w` matches `&` not `1` or `a`. |'
  prefs: []
  type: TYPE_TB
- en: '| `\n` | Newline | `\n` Matches a new line. |'
  prefs: []
  type: TYPE_TB
- en: '| `\s` | Single whitespace | `x\sx` matches `xx` not `xx`. |'
  prefs: []
  type: TYPE_TB
- en: '| `\S` | Single non-space | `x\Sx` matches `xkx` not `xx`. |'
  prefs: []
  type: TYPE_TB
- en: '| `\r` | Carriage return | `\r` matches carriage return. |'
  prefs: []
  type: TYPE_TB
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tables seen in the previous section are the key element tables for regular
    expressions. By using the suitable keys from the tables, we can construct any
    suitable regular expression string to match text according to the context. regex
    is a generic language to match text. Therefore, we are not introducing any tools
    in this recipe. However, it follows in the other recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a few examples of text matching:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to match all words in a given text, we can write the regex as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '"?" is the notation for optional space that precedes and follows a word. The
    `[a-zA-Z]+` notation represents one or more alphabet characters (a-z and A-Z).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To match an IP address, we can write the regex as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We know that an IP address is in the form 192.168.0.2\. It is in the form of
    four integers (each from 0-255) separated by dots (for example, 192.168.0.2).
  prefs: []
  type: TYPE_NORMAL
- en: '`[0-9]`or`[:digit:]` represents a match for digits 0-9\. `{1,3}` matches one
    to three digits and `\.`matches ".".'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's see how the special meanings of certain characters are specified in the
    regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Treatment of special characters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regular expressions use some characters such as `$`, `^`, `.`, `*`, `+`, `{`,
    and `}` as special characters. But what if we want to use these characters as
    non-special characters (a normal text character)? Let's see an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'regex: `[a-z]*.[0-9]`'
  prefs: []
  type: TYPE_NORMAL
- en: How is this interpreted?
  prefs: []
  type: TYPE_NORMAL
- en: It can be zero or more [a-z] `([a-z]*)`, then any one character (`.`), and then
    one character in the set`[0-9]` such that it matches `abcdeO9`.
  prefs: []
  type: TYPE_NORMAL
- en: It can also be interpreted as one of `[a-z]`, then a character `*`, then a character
    `.` (period), and a digit such that it matches `x*.8`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to overcome this problem, we precede the character with a forward slash
    "\" (doing this is called "escaping the character"). Characters such as * that
    have multiple meanings are prefixed with "\" to make them into a special meaning
    or to make them non special. Whether special characters or non-special characters
    are to be escaped varies depending on the tool that you are using.
  prefs: []
  type: TYPE_NORMAL
- en: Searching and mining "text" inside a file with grep
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Searching inside a file is an important use case in text processing. We may
    need to search through thousands of lines in a file to find out some required
    data by using certain specifications. This recipe will help you learn how to locate
    data items of a given specification from a pool of data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `grep` command is the master UNIX utility for searching in the text. It
    accepts regular expressions and wild cards. We can produce output in various formats
    using the numerous interesting options that come with `grep`. Let's see how to
    do it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Search in a file for a word as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It will return lines of text that contain the given `match_pattern`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also read from `stdin` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform a search in multiple files using a single `grep` invocation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can highlight the word in the line by using the `--color` option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Usually, the `grep` command considers `match_text` as a wildcard. To use regular
    expressions as input arguments, the `-E` option should be added—which means extended
    regular expression. Or we can a use regular expression enabled `grep` command,
    `egrep`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to output only the matching portion of text in a file, use the `–o`
    option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to print all of the lines, except the line containing `match_pattern`,
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `–v` option added to `grep` inverts the match results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Count the number of lines in which a matching string or regex match appears
    in a file or text as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be noted that `-c` counts only the number of matching lines, not
    the number of times a match is made. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Even though there are 6 matching items, it prints `2` since there are only `2`
    matching lines. Multiple matches in a single line are counted only once.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to count the number of matching items in a file, use the following
    hack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the line number of the match string as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If multiple files are used, it will also print the filename with the result
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the character or byte offset at which a pattern matches as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The character offset for a string in a line is a counter from 0 starting with
    the first character. In the above example, "not" is at the seventh offset position
    (that is, `not` starts from the seventh character in the line (`gnu is not unix`).
  prefs: []
  type: TYPE_NORMAL
- en: The `–b` option is always used with `–o`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To search over many files and find out in which of the files a certain text
    matches use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The inverse of the `–l` argument is `–L`. The `-L` argument returns a list of
    non-matching files.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have used the basic usage examples for the `grep` command. But the `grep`
    command comes with rich features. Let's go through the different options available
    along with `grep`.
  prefs: []
  type: TYPE_NORMAL
- en: Recursively search many files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To recursively search for a text over many directories of descendants use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this command `"."` specifies the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`test_function()` exists in line number 16 of `miscutils/test.c`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is one of the most frequently used commands by developers. It is used to
    find the file of source code in which a certain text exists.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring case of pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `–i` argument helps match patterns to be evaluated without considering
    if the characters are uppercase or lowercase. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: grep by matching multiple patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Usually, we can specify single pattern for matching. However, we can use an
    argument `-e` to specify multiple patterns for matching as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also another way to specify multiple patterns. We can use a pattern
    file for reading patterns. Write patterns to match line by line and execute `grep`
    with a `-f` argument as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Include and exclude files (wild card pattern) in grep search
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`grep` can include or exclude files in which to search. We can specify include
    files or exclude files using wild card patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To search only `.c` and `.cpp` files recursively in a directory by excluding
    all other file types, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that `some{string1,string2,string3}` expands as `somestring1 somestring2
    somestring3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exclude all README files in the search as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To exclude directories use the `--exclude-dir` option.
  prefs: []
  type: TYPE_NORMAL
- en: To read a list of files to exclude from a file use `--exclude-from FILE`.
  prefs: []
  type: TYPE_NORMAL
- en: Using grep with xargs with zero-byte suffix
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `xargs` command is often used to provide a list of file names as a command-line
    argument to another command. When filenames are used as command-line arguments,
    it is recommended to use a zero-byte terminator for the file names instead of
    a space terminator. Some of the file names can contain a space character and it
    will be misinterpreted as a terminator and a single file name may be broken into
    two file names (for example, `New file.txt` can be interpreted as two filenames
    `New` and `file.txt`). This problem can be avoided by using a zero-byte suffix.
    We use `xargs` so as to accept `stdin` text from commands like `grep`, `find`,
    and so on. Such commands can output text to the `stdout` with a zero-byte suffix.
    In order to specify that the input terminator for filenames is zero byte (`\0`),
    we should use `–0` with `xargs.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Create some test files as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following command sequence, `grep` outputs filenames with a zero byte
    terminator (`\0`). It is specified by using the `–Z` option with `grep`. `xargs
    -0` reads the input and separates file names with a zero byte terminator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Usually, `-Z` is used along with `-l`.
  prefs: []
  type: TYPE_NORMAL
- en: Silent output for grep
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previously mentioned usages of `grep` return output in different formats.
    There are some cases when we need to know whether a file contains the specified
    text or not. We have to perform a test condition that returns true or false. It
    can be performed using the quiet condition (`-q`). In quiet mode, the `grep` command
    does not write any output to the standard output. Instead it runs the command
    and returns exit status based on success or failure.
  prefs: []
  type: TYPE_NORMAL
- en: We know that a command returns 0 if success and non-zero if failure.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go through a script that makes uses of `grep` in quiet mode for testing
    whether a match text appears in a file or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `silent_grep.sh` script can be run as follows by providing a match word
    (`Student`) and a filename (`student_data.txt`) as the command argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Print lines before and after text matches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Context-based printing is a one of the nice features of `grep`. Suppose a matching
    line for a given match text is found, `grep` usually prints only the matching
    lines. But we may need "n" lines after the matching lines or "n" lines before
    the matching line or both. It can be performed using context line control in `grep`.
    Let's see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to print three lines after a match, use the `-A` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to print three lines before the match, use the `-B` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Print three lines after and before the match, use the `-C` option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are multiple matches, each section is delimited by a line "--":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Column-wise cutting of a file with cut
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We may need to cut text by column rather than row. Let's assume that we have
    a text file containing student reports with columns, such as `No`, `Name`, `Mark`,
    and `Percentage`. We need to extract only the name of students to another file
    or any n-th column in the file or extract two or more columns. This recipe will
    illustrate how to perform this task.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`cut` is a small utility that often comes to our help for cutting in column
    fashion. It can also specify the delimiter that separates each column. In `cut`
    terminology, each column is known as a field.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to extract the first field or column, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`FIELD_LIST` is a list of columns that are to be displayed. The list consists
    of column numbers delimited by commas. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, the second and the third columns are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '`cut` can also read input text from `stdin`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tab is the default delimiter for fields or columns. If lines without delimiters
    are found, they are also printed. To avoid printing lines that do not have delimiter
    characters, attach the `-s` option along with `cut`. An example of using the `cut`
    command for columns is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Extract multiple fields as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: To print multiple columns, provide a list of column numbers separated by commas
    as argument to `-f`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also complement the extracted fields using the `--complement` option.
    Suppose you have many fields and you want to print all the columns except the
    third column, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To specify the delimiter character for the fields, use the `-d` option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `cut` command has more options to specify the character sequences to be
    displayed as columns. Let's go through the additional options available with `cut`.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying range of characters or bytes as fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose that we don't rely on delimiters, but we need to extract fields such
    that we need to define a range of characters (counting from 0 as start of line)
    as a field, such extractions are possible with `cut`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what notations are possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '| N- | from N-th byte, character or field, to end of line |'
  prefs: []
  type: TYPE_TB
- en: '| N-M | from N-th to M-th (included) byte, character or field |'
  prefs: []
  type: TYPE_TB
- en: '| -M | from first to M-th (included) byte, character or field |'
  prefs: []
  type: TYPE_TB
- en: 'We use the above notations to specify fields as range of bytes or characters
    with the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-b` for bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-c` for characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f` for defining fields'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You can print the first to fifth characters as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two characters can be printed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Replace `-c` with `-b` to count in bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can specify output delimiter while using with `-c`, `-f` and `-b` as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'When multiple fields are extracted with `-b` or `-c`, `--output-delimiter`
    is a must. Else, you cannot distinguish between fields if it is not provided.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Frequency of words used in a given file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finding the frequency of words used in a file is an interesting exercise to
    apply the text processing skills. It can be done in many different ways. Let's
    see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use associative arrays, awk, sed, grep, and so on to solve this problem
    in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Words are alphabetic characters delimited by space and dot. First we should
    parse all the words in the given file. Hence the count of each word needs to be
    found out. Words can be parsed by using regex with any of the tools such as sed,
    awk, or grep.
  prefs: []
  type: TYPE_NORMAL
- en: To find out the count of each word, we can have a different approach. One way
    of doing it is to loop through each word, and then use another loop to go through
    the words and check if they are equal. If they are equal, increment a count and
    print it at the end of file. This is an inefficient method. In an associative
    array, we use the word as the array index and count as the array value. We will
    only need one loop to achieve this by looping through each word. `array[word]
    = array[word] + 1` while initially its value is set `0`. Hence we can get an array
    containing the counts for each word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s do it. Create the shell script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here `egrep -o "\b[[:alpha:]]+\b" $filename` is used to output only words. The
    `-o` option will print the matching character sequence delimited by a newline
    character. Hence we receive words in each line.
  prefs: []
  type: TYPE_NORMAL
- en: '`\b` is the word boundary character. `[:alpha:]` is a character class for alphabets.'
  prefs: []
  type: TYPE_NORMAL
- en: The `awk` command is used to avoid the iteration through each word. Since `awk`,
    by default, executes the statements in the `{ }` block for each row, we don't
    need a specific loop for doing that. Hence the count is incremented as `count[$0]++`
    using the associative array. Finally, in the `END{}` block, we print the words
    and their count by iterating through the words.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Arrays and associative arrays* of[Chapter 1](ch01.html "Chapter 1. Shell Something
    Out"), explains the arrays in Bash'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Basic awk primer*, explains the awk command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic sed primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: sed stands for stream editor. It is a very essential tool for text processing.
    It is a marvelous utility that can play around regular expressions. A well-known
    usage of the `sed` command is for text replacement. This recipe will cover most
    of the frequently used `sed` techniques.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`sed` can be used to replace occurrences of a string with another string in
    a given text. It can be matched using regular expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This command reads from `stdin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To save the changes along with the substitutions to the same file, use the
    -i option. Most of the users follow multiple redirections to save the file after
    making a replacement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it can be done in just one line, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The previously seen `sed` commands will replace the first occurrence of the
    pattern in each line. But in order to replace every occurrence, we need to add
    the `g` parameter at the end as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `/g` suffix means that it will substitute every occurrence. However, sometimes
    we need not replace the first "N" occurrences, but only the rest of them. There
    is a built-in option to ignore the first "N" occurrences and replace from the"N+1th"occurrence
    onwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Place `/Ng` when it needs to start the replacement from the N-th occurrence.
  prefs: []
  type: TYPE_NORMAL
- en: '`/` in `sed` is a delimiter character. We can use any delimiter characters
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'When the delimiter character appears inside the pattern, we have to escape
    it using `\` prefix as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '`\|` is a delimiter appearing in the pattern replaced with escape.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `sed` command comes with numerous options for text manipulation. By combining
    the options available with `sed` in logical sequences, many complex problems can
    be solved in one line. Let's see some different options available with `sed`.
  prefs: []
  type: TYPE_NORMAL
- en: Removing blank lines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Removing blank lines is a simple technique using `sed` to remove blank lines.
    Blanks can be matched with regular expression `^$`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '`/pattern/d` will remove lines matching the pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: For blank lines, the line end marker appears next to the line start marker.
  prefs: []
  type: TYPE_NORMAL
- en: Matched string notation (&)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In `sed` we can use `&` as the matched string for the substitution pattern such
    that we can use the matched string in replacement string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here the regex `\w\+` matches every word. Then we replace it with `[&]`. `&`
    corresponds to the word that is matched.
  prefs: []
  type: TYPE_NORMAL
- en: Substring match notation (\1)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '& is a string which corresponds to match string for the given pattern. But
    we can also match the substrings of the given pattern. Let''s see how to do it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'It replaces `digit 7` with `7`. The substring matched is `7`. `\(pattern\)`is
    used to match the substring. The pattern is enclosed in `()` and is escaped with
    slashes. For the first substring match, the corresponding notation is `\1`, for
    the second it is `\2`, and so on. Go through the following example with multiple
    matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`([a-z]\+\)` matches the first word and `\([A-Z]\+\)`matches the second word.
    `\1` and `\2` are used for referencing them. This type of referencing is called
    back referencing. In the replacement part, their order is changed as `\2 \1` and
    hence it appears in reverse order.'
  prefs: []
  type: TYPE_NORMAL
- en: Combination of multiple expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The combination of multiple `sed` using a pipe can be replaced as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Which is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Quoting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually, it is seen that the `sed` expression is quoted using single quotes.
    But double-quotes can also be used. Double-quotes expand the expression by evaluating
    it. Using double-quotes is useful when we want to use some variable string in
    a `sed` expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '`$text` is evaluated as "hello".'
  prefs: []
  type: TYPE_NORMAL
- en: Basic awk primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`awk` is a tool designed to work with data streams. It is very interesting
    as it can operate on columns and rows. It supports many inbuilt functionalities
    such as arrays, functions, and so on, as in the C programming language. Flexibility
    is the greatest advantage of it.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The structure of an `awk` script looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The `awk` command can read from `stdin` also.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `awk` script usually consists of three parts: `BEGIN`, `END`, and a common
    statements block with the pattern match option. The three of them are optional
    and any of them can be absent in the script. The script is usually enclosed in
    single-quotes or double-quotes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, alternately, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `awk` command works in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: Execute the statements in the `BEGIN { commands }`block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read one line from the file or `stdin`, and execute `pattern { commands }`.
    Repeat this step until the end of the file is reached.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the end of the input stream is reached, execute the `END { commands }`
    block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `BEGIN` block is executed before `awk` starts reading lines from the input
    stream. It is an optional block. The statements such as variable initialization,
    printing the output header for an output table, and so on are common statements
    that are written in the `BEGIN` block.
  prefs: []
  type: TYPE_NORMAL
- en: The `END` block is similar to the `BEGIN` block. The `END` block gets executed
    when `awk` has completed reading all the lines from the input stream. The statements
    like printing results after analyzing all the values calculated for all the lines
    or printing the conclusion are the commonly-used statements in the `END` block
    (for example, after comparing all the lines, print the maximum number from a file).
    This is an optional block.
  prefs: []
  type: TYPE_NORMAL
- en: The most important block is the common commands with the pattern block. This
    block is also optional. If this block is not provided, by default `{ print }`
    gets executed so as to print each of the lines read. This block gets executed
    for each line read by `awk`.
  prefs: []
  type: TYPE_NORMAL
- en: It is like a while loop for line read with provided statements inside the body
    of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: When a line is read, it checks whether the provided pattern matches the line.
    The pattern can be a regular expression match, conditions, range of lines match,
    and so on. If the current read line matches with the pattern, it executes the
    statements enclosed in `{ }`.
  prefs: []
  type: TYPE_NORMAL
- en: The pattern is optional. If pattern is not used, all the lines are matched and
    statements inside `{ }` are executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: When `print` is used without an argument, it will print the current line. There
    are two important things to be kept in mind about `print`. When the arguments
    of the print are separated by commas, they are printed with a space delimiter.
    Double-quotes are used as the concatenation operator in the context of `print`
    in `awk`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement will print the values of the variables as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The `echo` command writes a single line into the standard output. Hence the
    statements in the `{ }` block of `awk` are executed once. If standard input to
    `awk` contains multiple lines, the commands in `awk` will be executed multiple
    times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Concatenation can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '`{ }` is like a block in a loop iterating through each line of a file.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually, we place initial variable assignments, such as `var=0;` and statements
    to print the file header in the `BEGIN` block. In the `END{}` block, we place
    statements such as printing results and so on.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `awk` command comes with lot of rich features. In order to master the art
    of awk programming you should be familiar with the important `awk` options and
    functionalities. Let's go through the essential functionalities of `awk`.
  prefs: []
  type: TYPE_NORMAL
- en: Special variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some special variables that can be used with `awk` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NR`: It stands for number of records and corresponds to current line number
    under execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NF`: It stands for number of fields and corresponds to number of fields in
    the current line under execution (Fields are delimited by space).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$0`: It is a variable that contain the text content of current line under
    execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$1`: It is a variable that holds the text of the first field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$2`: It is the variable that holds the test of the second field text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We can print last field of a line as `print $NF`, last but second as `$(NF-1)`and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: '`awk` provides the `printf()`function with same syntax as in C. We can also
    use that instead of print.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's see some basic `awk` usage examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Print the second and third field of every line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to count the number of lines in a file, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Here we only use the `END` block. `NR` will be updated on entering each line
    by `awk` with its line number. When it reaches the end line it will have the value
    of last line number. Hence, in the `END` block `NR` will have the value of last
    line number.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can sum up all the numbers from each line of field 1 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Passing a variable value from outside to awk
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By using the `-v` argument, we can pass external values (other than from `stdin`)
    to `awk` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a flexible alternate method to pass many variable values from outside
    `awk`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'When input is given through a file rather than standard input, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: In the above method, variables are specified as key-value pairs separated by
    space (`v1=$var1 v2=$var2`) as command arguments to awk soon after the BEGIN,
    { } and END blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a line explicitly using getline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually, `grep` reads all lines in a file by default. If you want to read one
    specific line, you can use the `getline` function. Sometimes we may need to read
    the first line from the `BEGIN` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is: `getline var`'
  prefs: []
  type: TYPE_NORMAL
- en: The variable `var` will contain the content for the line.
  prefs: []
  type: TYPE_NORMAL
- en: If the `getline` is called without an argument, we can access the content of
    the line by using `$0`, `$1`, and `$2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Filtering lines processed by awk with filter patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can specify some conditions for lines to be processed. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Setting delimiter for fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, the delimiter for fields is space. We can explicitly specify a
    delimiter using `-F "delimiter"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: We can set the output fields separator by setting `OFS="delimiter"` in the `BEGIN`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: Reading command output from awk
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following code, `echo` will produces a single blank line. The `cmdout`
    variable will contain output of command `grep root /etc/passwd` and it will print
    the line containing `root`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for reading out of the ''command'' in a variable ''output'' is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: By using `getline` we can read the output of external shell commands in a variable
    called `cmdout`.
  prefs: []
  type: TYPE_NORMAL
- en: '`awk` supports associative arrays, which can use text as the index.'
  prefs: []
  type: TYPE_NORMAL
- en: Using loop inside awk
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `for` loop is available in `awk`. It has the format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '`awk` comes with many built-in string manipulation functions. Let''s have a
    look at a few of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length(string)`: It returns the string length.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index(string, search_string)`: It returns the position at which the `search_string`
    is found in the string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`split(string, array, delimiter)`: It stores the list of strings generated
    by using the delimiter in the array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`substr(string, start-position, end-position)`: It returns the substring created
    from the string by using start and end character offets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sub(regex, replacement_str, string)`: It replaces the first occurring regular
    expression match from the string with `replacment_str`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gsub(regex, replacment_str, string`: It is similar to `sub()`. But it replaces
    every regular expression match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`match(regex, string)`: It returns the result of whether a regular expression
    (regex) match is found in the string or not. It returns non-zero if match is found,
    else it returns zero. Two special variables are associated with `match()`. They
    are `RSTART` and `RLENGTH`. The `RSTART` variable contains the position at which
    the regular expression match starts. The `RLENGTH` variable contains the length
    of the string matched by the regular expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing strings from a text or file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: String replacement is a frequently-used text-processing task. It can be done
    easily with regular expressions by matching the required text.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we hear the term 'replace', every system admin will recall sed. `sed` is
    the universal tool under UNIX-like systems to make replacements in text or in
    a file. Let's see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `sed` primer recipe contains most of the usages of `sed`. You can replace
    a string or pattern as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use double quote (") instead of single quote (''). When double
    quote (") is used, we can specify variables inside the `sed` pattern and replacement
    strings. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: We can also use it without `g` in `sed`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Then it will replace the occurrence of `PATTERN` first time it appears only.
    `/g` stands for global. That means, it will replace every occurrence of `PATTERN`
    in the file.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen basic text replacement with `sed`. Let's see how to save the replaced
    text in the source file itself.
  prefs: []
  type: TYPE_NORMAL
- en: Making replacement saved in the file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a filename is passed to `sed`, it''s output will be available to `stdout`.
    Instead of sending the output stream into `stdout`, to make changes saved in the
    file, use the `–i` option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, replace all three-digit numbers with another specified number
    in a file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The above one-liner replaces three-digit numbers only.`\b[0-9]\{3\}\b` is the
    regular expression used to match three-digit numbers. [0-9] is the range of digits,
    that is, from 0 to 9\. {3} is used for matching the preceding character thrice.
    `\` in `\{3\}` is used to give a special meaning for `{` and `}`. `\b` is the
    word boundary marker.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Basic sed primer*, explains the sed command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compressing or decompressing JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is widely used in designing websites. While writing JavaScript code,
    we use several white spaces, comments, and tabs for readability and maintenance
    of code. But the use of a lot of white spaces and tabs in JavaScript causes the
    file size to increase. As the file size increases, it increases page load times.
    Hence most of the professional websites use compressed JavaScripts for fast loading.
    Compression is mostly squeezing white spaces and newline characters. Once JavaScript
    is compressed, it can be decompressed by adding enough white space and newline
    characters, which makes it readable. Usually, obfuscated code also can be made
    readable by inserting white space and newlines. This recipe is an attempt to hack
    similar capabilities in the shell.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to write a JavaScript compressor or obfuscation tool. Also a decompressing
    tool can be designed. We are going to get our hands dirty using text and character
    replacement tools `tr` and `sed`. Let's see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go through the logical sequences and the code required for compressing
    and decompressing the JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the tasks we need to perform for compressing the JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove newline and tab characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Squeeze spaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace comments /* content */.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the following with substitutions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '"{ " with "{"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '" }" with "}"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '" (" with "("'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '") " with ")"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '", " with ","'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '" ; " with ";" (we need to remove all extra spaces)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To decompress or to make the JavaScript more readable, we can use the following
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Replace ";" with ";\n".
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace "{" with "{\n" and "}" with "\n}".
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s compress the JavaScript by performing these tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the''\n'' and ''\t'' characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove extra spaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove comments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '`:` is used as a sed delimiter to avoid the need of escaping `/` since we need
    to use `/*` and `*/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` in the sed is escaped as `\*`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.*` is used to match all text in between `/*` and `*/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove all spaces preceding and suffixing the `{`,`}`,`(`,`)`,`;`,`:`, and comma.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The above `sed` statement can be parsed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/ \?\([{}();,:]\) \?/` in the `sed` code is the match part and `/\1 /g` is
    the replacement part.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\([{}();,:]\)` is used to match any one character in the set `[ { }( ) ; ,
    : ]` (inserted spaces for readability). `\(` and `\)` are group operators used
    to memorize the match and back reference in the replacement part. `(` and `)`
    are escaped to give them a special meaning as a group operator. `\?` precedes
    and follows the group operators. It is to match the space character that may precede
    or follow any of the characters in the set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the replacement part, the match string (that is, the combination of `:` a
    space (optional), a character from the set, and again optional space) is replaced
    with the character matched. It uses a back reference to the character matched
    and memorized using the group operator `()`. Back-referenced characters refer
    to a group match by using the `\1` symbol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Combine the above tasks using a pipe as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a decompression script for making obfuscated code readable as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`s/;/;\n/g` replaces `;` with `\n;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s/{/{\n\n/g` replaces `{` with `{\n\n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s/}/\n\n}/g` replaces `}` with `\n\n}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Translating with tr* of[Chapter 2](ch02.html "Chapter 2. Have a Good Command"),
    explains the tr command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Basic sed primer*, explains the sed command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating through lines, words, and characters in a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Iterating through character, word, and lines in a file is a frequently required
    script element while writing different text processing and file operation scripts.
    Even though it is simple to perform, we make simple mistakes and it gets erroneous
    without getting the expected output. This recipe will help you out to learn how
    to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Iteration with a simple loop and redirection from `stdin` or file are basic
    components of performing the mentioned tasks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we discuss about performing three tasks of iterating through
    line, word, and characters. Let's see how each of these tasks can be performed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Iterate through each line in a file:**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use a `while` loop to read from standard input. Hence it will read a
    line in each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use file redirection to `stdin` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Use subshell as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Here `cat file.txt` can be replaced with the output of any command sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '**Iterate through each word in a line**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can use a `while` loop to iterate through words in a line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '**Iterate through each character in a word**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use a `for` loop to iterate a variable `i` from `0` to the length of
    string. A character can be extracted from the string in each iteration using the
    special notation `${string:start_position:No_of_characters}`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reading lines of a file and reading words in a line are direct ways. But reading
    a character of a word is a little hack. We use the substring extraction technique.
  prefs: []
  type: TYPE_NORMAL
- en: '`${word:start_position:no_of_characters}` returns a substring of a string held
    in variable `word`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`${#word}` returns the length of the variable `word`.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Field separators and iterators* of[Chapter 1](ch01.html "Chapter 1. Shell
    Something Out"), explains different loops in Bash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Text slicing and parameter operations*, explains extracting characters from
    a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merging multiple files as columns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different cases when we require to concatenate files in columns. We
    may need each file's content to appear in separate columns. Usually, the `cat`
    command concatenates in a line- or row-wise fashion.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`paste` is the command that can be used for column-wise concatenation. The
    `paste` command can be used with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ paste file1 file2 file3 …`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try an example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The default delimiter is Tab. We can also explicitly specify the delimiter
    using `–d`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Column-wise cutting of a file with cut*, explains extracting data from text
    files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing the nth word or column in a file or line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We may get a file having a number of columns and only a few will actually be
    useful. In order to print only relevant columns or fields, we filter it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most widely-used method is to use `awk` for doing this task. It can be also
    done using `cut`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To print the fifth column use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: We can also print multiple columns and we can insert our custom string in between
    columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to print the permission and filename of each file in the current
    directory, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Basic awk primer*, explains the awk command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Column-wise cutting of a file with cut*, explains extracting data from text
    files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing text between line numbers or patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We may require to print certain section of text lines based on conditions such
    as a range of line numbers, range matched by start and end pattern and so on.
    Let's see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use utilities such as awk, grep, and sed to perform the printing of a
    section based on conditions. Still I found `awk` to be the simplest one to understand.
    Let's do it using `awk`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to print lines of text in a range of line numbers, M to N, use the
    following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, it can take `stdin` input as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace `M` and `N` with numbers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'To print lines of text in a section with `start_pattern` and `end_pattern`,
    use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: The patterns used in `awk` are regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Basic awk primer*, explains the awk command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking palindrome strings with a script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Checking whether a string is palindrome is one of the first lab exercises in
    a C programming course. However, here we have included this recipe to give you
    an idea of how to solve similar problems in which pattern matching can be extended
    in a way that previously occurring patterns repeat in the text.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `sed` command has the capability to remember a previously-matched sub pattern.
    It is called back referencing. We can solve palindrome problems by using back
    referencing. We can solve this using multiple ways in Bash.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`sed` can remember previously matched regular expression patterns, thereby
    we can identify whether duplicates of a character exists in a string. This capability
    to remember and reference previously matched patterns is called back-reference.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can apply back-referencing in a simpler manner to solve the
    problem. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '`\(.\)` corresponds to memorize the one sub string inside ( ). Here it is .
    (period) which is also sed''s single character wildcard character.'
  prefs: []
  type: TYPE_NORMAL
- en: '`\1` corresponds to the memory of the first match inside (). `\2` corresponds
    to the second match. Hence we can memorize many blocks enclosed in `()`. `()`
    appears as `\( \)` to give `(` and `)` special meaning rather than just a character.'
  prefs: []
  type: TYPE_NORMAL
- en: The previous `sed` statement will print any pattern matching two exactly the
    same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of all palindrome words is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Even number of characters and a sequence of characters concatenated with same
    characters in reverse order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Odd number of characters with a sequence of characters concatenated with reverse
    of same characters, but a common character in between the first sequence and its
    reverse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, for matching both, we can keep an optional character in between while
    writing the regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `sed` regex matching a three-letter palindrome word will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: We can place an extra character (`.`) in between the character sequence and
    its reverse sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a script that can match a palindrome string of any length as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the dictionary file as the input file to get a list of palindrome words
    of a given string length. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The working of the above script is simple. Most of the work is done to generate
    the `sed` script for a regular expression and a back-reference string generation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go through its working with the help of some worked out examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to match the character and back-reference it, we use `\(.\)` to
    match one character and `\1` to reference it. Hence, in order match a two letter
    palindrome and print it, we use:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Now, to specify that match string from the beginning of the line, we add line-begin
    market ^ so that it will become `sed'/^\(.\)\1/p'`. `/p` is used to print the
    match.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to match four character palindrome, we use:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: We have used two `\(.\)` to match two characters and remember them. Anything
    enclosed within `\(` and `\)` will be remembered by `sed` and can be back-referenced.
    `\2\1` is used to back-reference in the reverse order of the matched characters.
  prefs: []
  type: TYPE_NORMAL
- en: In the above script, we have a variable called `basepattern`, which contains
    the `sed` script.
  prefs: []
  type: TYPE_NORMAL
- en: The pattern is generated using a `for` loop based on the number of characters
    in the palindrome string.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, basepattern is initialized as `basepattern='/^\(.\)'`, which corresponds
    to a one-character match. A `for` loop is used to concatenate `\(.\)` with `basepattern`
    for half the number of times of the length of palindrome string. Again a `for`
    loop is used to concatenate back-references in the reverse order (like `'\4\3\2\1'`)
    half the number of times the length of palindrome string. Finally, in order to
    support palindrome strings with odd length an optional character (`.`) is enclosed
    between match regex and back-references.
  prefs: []
  type: TYPE_NORMAL
- en: Thus the `sed` palindrome match pattern is crafted. This crafted string is used
    to find out the palindrome strings from the dictionary file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the above script, we have used `sed` pattern generation using `for` loops.
    Actually there is no need to generate pattern separately. The `sed` command has
    its own loop implementation using labels and goto. `sed` is a vast language. Palindrome
    check can be done in a single line using a complex `sed` script. It is hard to
    explain it from scratch. Just try out the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are interested in deep scripting with `sed`, refer to the complete `sed`
    and `awk` reference book: *sed & awk*, Second Edition by Dale Dougherty and Arnold
    Robbins.'
  prefs: []
  type: TYPE_NORMAL
- en: Try to parse the above one-line `sed` script to test the palindrome using the
    book.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let's see some other options, or possibly some pieces of general information
    that are relevant to this task.
  prefs: []
  type: TYPE_NORMAL
- en: Simplest and direct method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest method to check whether a string is a palindrome is by using the
    rev command.
  prefs: []
  type: TYPE_NORMAL
- en: The `rev` command takes a file or `stdin` as input and prints the reversed string
    of every line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rev` command can be used along with other commands to solve different
    problems. Let''s look at an interesting example to reverse the words in a sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: In the above one-liner, the characters are reversed first using the `rev` command.
    Then the words are separated into a word per line by replacing space with the
    `\n` character by using the `tr` command. Now the lines are reversed in order
    using the `tac` command. Again, lines are merged into a line using `tr`. Now `rev`
    is again applied so that a line with words is in the reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Basic sed primer*, explains the sed command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Comparisons and tests* of [Chapter 1](ch01.html "Chapter 1. Shell Something
    Out"), explains the string comparison operators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing lines in the reverse order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a simple recipe. It may not seem very useful but it can be used to emulate
    the stack data structure in Bash. This is something interesting. Let's print the
    lines of text in a file in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A little hack with `awk` can do the task. However, there is a direct command
    `tac` to do the same as well. `tac` is the reverse of `cat`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s do it with `tac` first. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also read from `stdin` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: In `tac`, `\n` is the line separator. But we can also specify our own separator
    by using the `-s` "separator" option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do it in `awk` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '`\` in the shell script is used to conveniently break a single line command
    sequence into multiple lines.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `awk` script is very simple. We store each of the lines into an associative
    array with the line number as array index (NR gives line number). In the end,
    `awk` executes the `END` block. In order to get last line number `lno=NR` is used
    in the { } block. Hence it iterates from the last line number to `0` and prints
    the lines stored in the array in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Implementing head, tail, and tac with awk*, explains writing tac using awk'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing e-mail addresses and URLs from text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parsing required text from a given file is a common task that we encounter in
    text processing. Items such as e-mail, URL, and so on can be found out with the
    help of correct regex sequences. Mostly, we need to parse e-mail addresses from
    a contact list of a e-mail client which is composed of many unwanted characters
    and words or from a HTML web page.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This problem can be solved with utilities egrep.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The regular expression pattern to match an e-mail address is:'
  prefs: []
  type: TYPE_NORMAL
- en: egrep regex:`[A-Za-z0-9.]+@[A-Za-z0-9.]+\.[a-zA-Z]{2,4}`
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The `egrep regex` pattern for an HTTP URL is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The regular expressions are really easy to design part by part. In the e-mail
    regex, we all know that an e-mail address takes the form `name@domain.some_2-4_letter`.
    Here the same is written in regex language as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '`[A-Za-z0-9.]+` means that some combination of characters in the `[]` block
    should appear one or more times (that is the meaning of `+`) before a literal
    `@` character appears. Then `[A-Za-z0-9.]` also should appear one or more times
    (`+`). The pattern `\.`means that a literal period should appear and finally the
    last part should be of length 2 to 4 alphabetic characters.'
  prefs: []
  type: TYPE_NORMAL
- en: The case of an HTTP URL is similar to that of an e-mail address but without
    the `name@` match part of e-mail regex.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Basic sed primer*, explains the sed command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Basic regular expression primer*, explains how to use regular expressions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing n lines before or after a pattern in a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Printing a section of text by pattern matching is frequently used in text processing.
    Sometimes we may need the lines of text before a pattern or after a pattern appears
    in a text. For example, consider that there is a file containing the rating of
    film actors where each line corresponds to a film actor's details, and we need
    to find out the rating of an actor along with the details of actors who are nearest
    to them in rating. Let's see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`grep` is the best tool for searching and finding text in a file. Usually,
    `grep` prints a matching line or matching text for a given pattern. But the context
    line control options in `grep` enables it to print before, after, and before-after
    lines around the line of pattern match.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This technique can be better explained with a film actor list. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to print three lines after the match "Cameron Diaz" along with the
    matching line, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to print the matched line and the preceding three lines, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the matched line and the two lines before and after the matched line
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Are you wondering where I got this ranking from?
  prefs: []
  type: TYPE_NORMAL
- en: 'I parsed a website having full of images and HTML content just using basic
    sed, awk, and grep commands. See the chapter: *Tangled Web? Not at all*.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Searching and mining "text" inside a file with grep*, explains the grep command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing a sentence in a file containing a word
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Removing a sentence containing a word is a simple task when a correct regular
    expression is identified. This is just an exercise on solving similar problems.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`sed` is the best utility for making substitutions. Hence let''s use `sed`
    to replace the matched sentence with a blank.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a file with some text to carry out the substitutions. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'We will remove the sentence containing the words "mobile phones". Use the following
    `sed` expression for this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's evaluate the `sed` regex`'s/ [^.]*mobile phones[^.]*\.//g'`.
  prefs: []
  type: TYPE_NORMAL
- en: It has the format `'s/substitution_pattern/replacement_string/g`.
  prefs: []
  type: TYPE_NORMAL
- en: It replaces every occurrence of `substitution_pattern` with the replacement
    string.
  prefs: []
  type: TYPE_NORMAL
- en: Here the substitution pattern is the regex for a sentence. Every sentence is
    delimited by "." and the first character is a space. Therefore, we need to match
    the text that is in the format "space" some text MATCH_STRING some text "dot".
    A sentence may contain any characters except a "dot", which is the delimiter.
    Hence we have used [^.]. [^.]* matches a combination of any characters except
    dot. In between the text match string "mobile phones" is placed. Every match sentence
    is replaced by `//` (nothing).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Basic sed primer*, explains the sed command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Basic regular expression primer*, explains how to use regular expressions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing head, tail, and tac with awk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mastering text-processing operations comes with practice. This recipe will help
    us practice incorporating some of the commands that we have just learned with
    some that we already know.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The commands `head`, `tail`, `uniq`, and `tac` operate line by line. Whenever
    we need line by line processing, we can always use `awk`. Let's emulate these
    commands with `awk`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's see how different commands can be emulated with different basic text processing
    commands, such as head, tail, and tac.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `head` command reads the first ten lines of a file and prints them out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tail` command prints the last ten lines of a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tac` command prints the lines of input file in reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the implementation of `head` using `awk`, we print the lines in the input
    stream having a line number less than or equal to `10`. The line number is available
    using the special variable `NR`.
  prefs: []
  type: TYPE_NORMAL
- en: In the implementation of the `tail` command a hashing technique is used. The
    buffer array index is determined by a hashing function `NR % 10`, where `NR` is
    the variable that contains the Linux number of current execution. `$0` is the
    line in the text variable. Hence `%` maps all the lines having the same remainder
    in the hash function to a particular index of an array. In the `END{}` block,
    it can iterate through ten index values of an array and print the lines stored
    in a buffer.
  prefs: []
  type: TYPE_NORMAL
- en: In the `tac` command emulation, it simply stores all the lines in an array.
    When it appears in the `END{}` block, `NR` will be holding the line number of
    the last line. Then it is decremented in a `for` loop until it reaches `1` and
    it prints the lines stored in each iteration statement.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Basic awk primer*, explains the awk command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*head and tail - printing the last or first 10 lines* of[Chapter 3](ch03.html
    "Chapter 3. File In, File Out"), explains the commands head and tail'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Sorting, unique and duplicates* of [Chapter 2](ch02.html "Chapter 2. Have
    a Good Command"), explains the uniq command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Printing lines in reverse order*, explains the tac command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text slicing and parameter operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe walks through some of the simple text replacement techniques and
    parameter expansion short hands available in Bash. A few simple techniques can
    often help us avoid having to write multiple lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replacing some text from a variable can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '`line` is replaced with `REPLACED`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can produce a sub-string by specifying the start position and string length,
    by using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'To print from the fifth character onward use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'To print eight characters starting from the fifth character, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: The index is specified by counting the start letter as `0`. We can also specify
    counting from last letter as `-1`. It is but used inside a parenthesis. `(-1)`
    is the index for the last letter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Iterating through lines, words, and characters in a file*, explains slicing
    of a character from a word'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
