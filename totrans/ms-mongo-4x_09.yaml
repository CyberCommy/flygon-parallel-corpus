- en: Indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will explore one of the most important properties of any database:
    indexing. Similar to book indexes, database indexes allow for quicker data retrieval.
    In the RDBMS world, indexes are widely used (and sometimes abused) to speed up
    data access. In MongoDB, indexes play an integral part in schema and query design.
    MongoDB supports a wide array of indexes that you will learn about in this chapter,
    including single field, compound, multi-key, geospatial, hashed, partial, and
    many more. In addition to reviewing the different types of indexes, we will show
    you how to build and manage indexes for single-server deployments, as well as
    complex sharded environments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Index internals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and managing indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficient usage of indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Index internals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most cases, indexes are variations of the B-tree data structure. Invented
    by Rudolf Bayer and Ed McCreight in 1971, while they were working at Boeing research
    labs, the **B-tree** data structure allows for searches, sequential access, inserts,
    and deletes to be performed in logarithmic time. The **logarithmic time** property
    stands for both the average case performance and the worst possible performance,
    and it is a great property when applications cannot tolerate unexpected variations
    in performance behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further illustrate how important the logarithmic time part is, we will show
    you the Big-O complexity chart, which is from [http://bigocheatsheet.com/](http://bigocheatsheet.com/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e0681d3-c53a-4ad0-a009-75717d94b0ee.png)'
  prefs: []
  type: TYPE_IMG
- en: In this diagram, you can see logarithmic time performance as a flat line, parallel
    to the *x* axis of the diagram. As the number of elements increases, constant
    time (**O(n)**) algorithms perform worse, whereas quadratic time algorithms (**O(n^2)**)
    go off the chart. For an algorithm that we rely on to get our data back to us
    as quickly as possible, time performance is of the utmost importance.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting property of a B-tree is that it is self-balancing, meaning
    that it will self-adjust to always maintain these properties. Its precursor and
    closest relative is the binary search tree, a data structure that only allows
    two children for each parent node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Schematically, a B-tree looks like the following diagram, which can also be
    seen at [https://commons.wikimedia.org/w/index.php?curid=11701365](https://commons.wikimedia.org/w/index.php?curid=11701365):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/481c69b3-7abe-4924-a3d8-5682382bdf01.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we have a parent node with the values **7** and 16,
    pointing to three child nodes.
  prefs: []
  type: TYPE_NORMAL
- en: If we search for the value **9**, knowing that it's greater than **7** and smaller
    than **16**, we'll be directed to the middle child node that contains the value
    straight away.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to this structure, we are approximately halving our search space with
    every step, ending in a *log n* time complexity. Compared to sequentially scanning
    through every element, halving the number of elements with each and every step
    increases our gains exponentially as the number of elements we have to search
    through increases.
  prefs: []
  type: TYPE_NORMAL
- en: Index types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB offers a vast array of index types for different needs. In the following
    sections, we will identify the different types, and the needs that each one of
    them fulfills.
  prefs: []
  type: TYPE_NORMAL
- en: Single field indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common and simple type of index is the single field index. An example
    of a single field and key index is the index on `ObjectId` (`_id`), which is generated
    by default in every MongoDB collection. The `ObjectId` index is also unique, preventing
    a second document from having the same `ObjectId` in a collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'An index on a single field, based on the `mongo_book` database that we used
    throughout the previous chapters, is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we create an index on the field name in ascending order of index creation.
    For a descending order, the same index would be created like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The ordering for index creation is important if we expect our queries to favor
    values on the first documents stored in our index. However, due to the extremely
    efficient time complexity that indexes have, this will not be a consideration
    for the most common use cases.
  prefs: []
  type: TYPE_NORMAL
- en: An index can be used for exact match queries or range queries on a field value.
    In the former case, the search can stop as soon as our pointer reaches the value
    after *O(log n)* time.
  prefs: []
  type: TYPE_NORMAL
- en: In range queries, due to the fact that we are storing values in order in our
    B-tree index, once we find the border value of our range query in a node of our
    B-tree, we will know that all of the values in its children will be part of our
    result set, allowing us to conclude our search.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fe86237-0faf-44c8-b1e1-603416cc5b3e.png)'
  prefs: []
  type: TYPE_IMG
- en: Dropping indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dropping an index is as simple as creating it. We can reference the index by
    its name or by the fields it is composed from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Indexing embedded fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a document database, MongoDB supports embedding fields and whole documents
    in nested complex hierarchies inside of the same document. Naturally, it also
    allows us to index these fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `books` collection example, we can have documents like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `meta_data` field is a document itself, with `page_count` and `average_customer_review` fields.
    Again, we can create an index on `page_count`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This can answer queries on equality and range comparisons around the `meta_data.page_count`
    field, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To access embedded fields, we use dot notation, and we need to include quotes
    (`""`) around the field's name.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing embedded documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also index the embedded document as a whole, similar to indexing embedded
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are indexing the whole document, expecting queries against its entirety,
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The key difference is that when we index embedded fields, we can perform range
    queries on them using the index, whereas when we index embedded documents, we
    can only perform comparison queries using the index.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `db.books.find({"meta_data.average_customer_review": { $gte: 4.8}, "meta_data.page_count":
    { $gte: 200 } })` command will not use our `meta_data` index, whereas `db.books.find({"meta_data":
    {"page_count":256, "average_customer_review":4.8}})` will use it.'
  prefs: []
  type: TYPE_NORMAL
- en: Background indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Indexes can be created in the foreground, blocking all of the operations in
    the collection until they are built, or they can be created in the background,
    allowing for concurrent operations. Building an index in the background is done
    by passing in the `background: true` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Background indexes have some limitations that we will revisit in the last section
    of this chapter, *Building and managing indexes*.
  prefs: []
  type: TYPE_NORMAL
- en: Compound indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compound indexes are a generalization of single-key indexes, allowing for multiple
    fields to be included in the same index. They are useful when we expect our queries
    to span multiple fields in our documents, and also for consolidating our indexes
    when we start to have too many of them in our collection.
  prefs: []
  type: TYPE_NORMAL
- en: Compound indexes can have as many as 31 fields. They cannot have a hashed index
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'A compound index is declared similarly to single indexes, by defining the fields
    that we want to index and the order of indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Sorting with compound indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The order of indexing is useful for sorting results. In single field indexes,
    MongoDB can traverse the index both ways, so it doesn't matter which order we
    define.
  prefs: []
  type: TYPE_NORMAL
- en: 'In multi-field indexes, however, ordering can determine whether we can use
    this index to sort. In the preceding example, a query matching the sort direction
    of our index creation will use our index as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It will also use a `sort` query with all of the `sort` fields reversed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this query, since we negated both of the fields, MongoDB can use the same
    index, traversing it from the end to the start.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other two sorting orders are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: They cannot be traversed using the index, as the `sort` order that we want is
    not present in our index's B-tree data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing compound indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important attribute of compound indexes is that they can be used for multiple
    queries on prefixes of the fields indexed. This is useful when we want to consolidate
    indexes that pile up in our collections over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the compound (multi-field) index that we created previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be used for queries on `name` or `{name, isbn}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The order of the fields in our query doesn't matter; MongoDB will rearrange
    the fields to match our query.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the order of the fields in our index does matter. A query just for
    the `isbn` field cannot use our index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The underlying reason is that our fields' values are stored in the index as
    secondary, tertiary, and so on; each one is embedded inside of the previous ones,
    just like a **matryoshka**, the Russian nesting doll. This means that when we
    query on the first field of our multi-field index, we can use the outermost doll
    to find our pattern, whereas when we are searching for the first two fields, we
    can match the pattern on the outermost doll, and then dive into the inner one.
  prefs: []
  type: TYPE_NORMAL
- en: This concept is called **prefix indexing**, and along with index intersection,
    it is the most powerful tool for index consolidation, as you will see later in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Multikey indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Indexing scalar (single) values was explained in the preceding sections. However,
    one of the advantages that we get from using MongoDB is the ability to easily
    store vector values in the form of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: In the relational world, storing arrays is generally frowned upon, as it violates
    the normal forms. In a document-oriented database such as MongoDB, it is frequently
    a part of our design, as we can store and query easily on complex structures of
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing arrays of documents is achieved by using the multikey index. A multikey
    index can store both arrays of scalar values and arrays of nested documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a multikey index is the same as creating a regular index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Assume that we have created a document in our `books` collection, using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Our new index will be a multikey index, allowing us to find documents with
    any of the tags stored in our array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can also create compound indexes with a multikey index, but we can have,
    at the most, one array in each and every index document. Given that in MongoDB
    we don't specify the type of each field, this means that creating an index with
    two or more fields with an array value will fail at creation time, and trying
    to insert a document with two or more fields as arrays will fail at insertion
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a compound index on `tags`, `analytics_data` will fail to be created
    if we have the following document in our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Consequently, if we first create the index on an empty collection and try to
    insert this document, the insert will fail, with the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Hashed indexes cannot be multikey indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Another limitation that we will likely run into when trying to fine-tune our
    database is that multikey indexes cannot entirely cover a query. Covering a query
    with the index means that we can get our result data entirely from the index,
    without accessing the data in our database at all. This can result in dramatically
    increased performance, as indexes are most likely to be stored in RAM.
  prefs: []
  type: TYPE_NORMAL
- en: Querying for multiple values in multikey indexes will result in a two-step process,
    from the index's perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first step, index will be used to retrieve the first value of the array,
    and then a sequential scan will run through the rest of the elements in the array;
    an example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will first search for all entries in multikey `index` tags that have a
    `mongodb` value, and will then sequentially scan through them to find the ones
    that also have the `index`, `cheatsheet`, and `new` tags.
  prefs: []
  type: TYPE_NORMAL
- en: A multikey index cannot be used as a shard key. However, if the shard key is
    a prefix index of a multikey index, it can be used. We will cover more on this
    in [Chapter 13](1c075020-a2e9-41f5-89b8-4ccd8f8d6fef.xhtml), *Sharding*.
  prefs: []
  type: TYPE_NORMAL
- en: Special types of indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from the generic indexes, MongoDB supports indexes for special use cases.
    In this section, we will identify and explore how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Text indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Text indexes are special indexes on string value fields, used to support text
    searches. This book is based on version 3 of the text index functionality, available
    since version 3.2.
  prefs: []
  type: TYPE_NORMAL
- en: 'A text index can be specified similarly to a regular index, by replacing the
    index sort order (`-1`, `1`) with the word `text`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: A collection can have one text index, at the most. This text index can support
    multiple fields, text or not. It cannot support other special types, such as multikey
    or geospatial. Text indexes cannot be used for sorting results, even if they are
    only a part of a compound index.
  prefs: []
  type: TYPE_NORMAL
- en: Since we only have one text index per collection, we need to choose the fields
    wisely. Reconstructing this text index can take quite some time, and having only
    one of them per collection makes maintenance quite tricky, as you will see toward
    the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, this index can also be a compound index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: A compound index with `text` fields follows the same rules of sorting and prefix
    indexing that we explained earlier in this chapter. We can use this index to query
    on `available`, or the combination of `available` and `meta_data.page_count`,
    or sort them if the sort order allows for traversing our index in any direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also blindly index each and every field in a document that contains
    strings as `text`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This can result in unbounded index sizes, and should be avoided; however, it
    can be useful if we have unstructured data (for example, coming straight from
    application logs wherein we don't know which fields may be useful, and we want
    to be able to query as many of them as possible).
  prefs: []
  type: TYPE_NORMAL
- en: Text indexes will apply stemming (removing common suffixes, such as plural `s`/`es`
    for English language words) and remove stop words (`a`, `an`, `the`, and so on)
    from the index.
  prefs: []
  type: TYPE_NORMAL
- en: Text indexing supports more than 20 languages, including Spanish, Chinese, Urdu,
    Persian, and Arabic. Text indexes require special configurations to correctly
    index in languages other than English.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some interesting properties of text indexes are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Case-insensitivity and diacritic insensitivity**: A text index is case- and
    diacritic-insensitive. Version 3 of the text index (the one that comes with version
    3.4) supports common *C*, simple *S*, and the special *T* case folding, as described
    in **Unicode Character Database** (**UCD**) 8.0 case folding. In addition to case-insensitivity,
    version 3 of the text index supports diacritic insensitivity. This expands insensitivity
    to characters with accents in both small and capital-letter form. For example, *e*, *è*,
    *é*, *ê*, *ë*, and their capital letter counterparts, can all result into being
    equal when comparing using a text index. In the previous versions of the text
    index, these were treated as different strings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tokenization delimiters: **Version 3 of the text index supports the tokenization
    delimiters, defined as `Dash`, `Hyphen`, `Pattern_Syntax`, `Quotation_Mark`, `Terminal_Punctuation`,
    and `White_Space`, as described in UCD 8.0 case folding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashed indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A hashed index contains `hashed` values of the indexed field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will create a hashed index on the name of each book of our `books` collection.
    A hashed index is ideal for equality matches, but it cannot work with range queries.
    If we want to perform a range of queries on fields, we can create a regular index
    (or a compound index containing the field), and also a hashed index for equality
    matches. Hashed indexes are used internally by MongoDB for hash-based sharding,
    as we will discuss in [Chapter 13](1c075020-a2e9-41f5-89b8-4ccd8f8d6fef.xhtml),
    *Sharding*. Hashed indexes truncate floating point fields to integers. Floating
    points should be avoided for hashed fields wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Time to live indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Time to live** (**TTL**) indexes are used to automatically delete documents
    after an expiration time. Their syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `created_at_date` field values have to be either a date or an array of dates
    (the earliest one will be used). In this example, the documents will get deleted
    one day (`86400` seconds) after `created_at_date`.
  prefs: []
  type: TYPE_NORMAL
- en: If the field does not exist or the value is not a date, the document will not
    expire. In other words, a TTL index silently fails, not returning any errors when
    it does.
  prefs: []
  type: TYPE_NORMAL
- en: Data gets removed by a background job that runs every 60 seconds. As a result,
    there is no explicit accuracy guarantee as to how much longer documents will persist
    past their expiration dates.
  prefs: []
  type: TYPE_NORMAL
- en: 'A TTL index is a regular single field index. It can be used for queries like
    a regular index. A TTL index cannot be a compound index, operate on a capped collection,
    or use the `_id` field. The `_id` field implicitly contains a timestamp of the
    created time for the document, but is not a `Date` field. If we want each document
    to expire at a different, custom date point, we have to set `{expireAfterSeconds:
    0}`, and set the TTL index `Date` field manually to the date on which we want
    the document to expire.'
  prefs: []
  type: TYPE_NORMAL
- en: Partial indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A partial index on a collection is an index that only applies to the documents
    that satisfy the `partialFilterExpression` query.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use our familiar `books` collection, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Using this, we can have an index for just the books that have a price greater
    than `30`. The advantage of partial indexes is that they are more lightweight
    in creation and maintenance, and use less storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `partialFilterExpression` filter supports the following operators:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Equality expressions (that is, `field: value`, or using the `$eq` operator)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `$exists: true` expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `$gt`, `$gte`, `$lt`, and `$lte` expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$type` expressions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `$and` operator, at the top level only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partial indexes will only be used if the query can be satisfied as a whole by
    the partial index.
  prefs: []
  type: TYPE_NORMAL
- en: If our query matches or is more restrictive than the `partialFilterExpression`
    filter, then the partial index will be used. If the results may not be contained
    in the partial index, then the index will be totally ignored.
  prefs: []
  type: TYPE_NORMAL
- en: '`partialFilterExpression` does not need to be a part of the sparse index fields.
    The following index is a valid sparse index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To use this partial index, however, we need to query for both `name` and `price` equal
    to or greater than `30`.
  prefs: []
  type: TYPE_NORMAL
- en: Prefer partial indexes to sparse indexes. Sparse indexes offer a subset of the
    functionality offered by partial indexes. Partial indexes were introduced in MongoDB
    3.2, so if you have sparse indexes from earlier versions, it may be a good idea
    to upgrade them. The `_id` field cannot be a part of a partial index. A shard
    key index cannot be a partial index. `partialFilterExpression` cannot be combined
    with the `sparse` option.
  prefs: []
  type: TYPE_NORMAL
- en: Sparse indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A sparse index is similar to a partial index, preceding it by several years
    (it has been available since version 1.8).
  prefs: []
  type: TYPE_NORMAL
- en: 'A `sparse` index only indexes values that contain the following field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It will only create an index with the documents that contain a `price` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some indexes are always sparse, due to their nature:'
  prefs: []
  type: TYPE_NORMAL
- en: '`2d`, `2dsphere` (version 2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`geoHaystack`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sparse and unique index will allow for multiple documents missing the index
    key. It will not allow for documents with the same index field values. A sparse
    and compound index with geospatial indexes (`2d`, `2dsphere`, and `geoHaystack`)
    will index the document as long as it has the `geospatial` field.
  prefs: []
  type: TYPE_NORMAL
- en: A sparse and compound index with the `text` field will index the document as
    long as it has the `text` field. A sparse and compound index without any of the
    two preceding cases will index the document as long as it has at least one of
    the fields.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid creating new sparse indexes in the latest versions of MongoDB; use partial
    indexes instead.
  prefs: []
  type: TYPE_NORMAL
- en: Unique indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A unique index is similar to an RDBMS unique index, forbidding duplicate values
    for the indexed field. MongoDB creates a unique index by default on the `_id`
    field for every inserted document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This will create a `unique` index on a book's `name`. A unique index can also
    be a compound embedded field or an embedded document index.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a compound index, the uniqueness is enforced across the combination of values
    in all of the fields of the index; for example, the following will not violate
    the unique index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is because even though the name is the same, our index is looking for the
    unique combination of `name` and `isbn`, and the two entries differ in `isbn`.
  prefs: []
  type: TYPE_NORMAL
- en: Unique indexes do not work with hashed indexes. Unique indexes cannot be created
    if the collection already contains duplicate values of the indexed field. A unique
    index will not prevent the same document from having multiple values.
  prefs: []
  type: TYPE_NORMAL
- en: If a document is missing the indexed field, it will be inserted. If a second
    document is missing the indexed field, it will not be inserted. This is because
    MongoDB will store the missing field value as null, only allowing one document
    to be missing in the field.
  prefs: []
  type: TYPE_NORMAL
- en: Indexes that are a combination of unique and partial will only apply unique
    indexes after a partial index has been applied. This means that there may be several
    documents with duplicate values, if they are not a part of partial filtering.
  prefs: []
  type: TYPE_NORMAL
- en: Case-insensitive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Case-sensitivity is a common problem with indexing. We may store our data in
    mixed caps and need our index to ignore case when looking for our stored data.
    Until version 3.4, this was dealt with at the application level by creating duplicate
    fields with all lowercase characters and indexing all lowercase field to simulate
    a case-insensitive index.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `collation` parameter, we can create case-insensitive indexes, and
    even collections that behave as case-insensitive.
  prefs: []
  type: TYPE_NORMAL
- en: In general, `collation` allows users to specify language-specific rules for
    string comparisons. A possible (but not the only) usage is for case-insensitive
    indexes and queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using our familiar `books` collection, we can create a case-insensitive index
    on a name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `strength` parameter is one of the collation parameters: the defining parameter
    for case-sensitivity comparisons. Strength levels follow the **International Components
    for Unicode** (**ICU**) comparison levels. The values that it accepts are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Strength Value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `1a` | Primary level of comparison. Comparison based on string values, ignoring
    any other differences, such as case and diacritics. |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | Secondary level of comparison, which is the comparison based on the
    primary level and if this is equal then compare diacritics (that is, accents).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `3` (default) | Tertiary level of comparison. Same as level *2*, adding case
    and variants. |'
  prefs: []
  type: TYPE_TB
- en: '| `4` | Quaternary level. Limited for specific use cases to consider the punctuation
    when levels 1-3 ignore punctuation, or for processing Japanese text. |'
  prefs: []
  type: TYPE_TB
- en: '| `5` | Identical level. Limited for specific use cases: a tie breaker. |'
  prefs: []
  type: TYPE_TB
- en: 'Creating the index with `collation` is not enough to get back case-insensitive
    results. We need to specify `collation` in our query, as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we specify the same level of `collation` in our query as our index, then
    the index will be used. We could specify a different level of `collation`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, we cannot use the index, as our index has `collation` level 1, and our
    query looks for `collation` level `2`.
  prefs: []
  type: TYPE_NORMAL
- en: If we don't use any `collation` in our queries, we will get results defaulting
    to level 3, that is, case-sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: Indexes in collections that were created using a different `collation` from
    the default will automatically inherit this `collation` level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we create a collection with `collation` level 1, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following index will also have collation `name: 1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Default queries to this collection will be collation `strength: 1`, case-sensitive.
    If we want to override this in our queries, we need to specify a different level
    of `collation` in our queries, or ignore the `strength` part altogether. The following
    two queries will return case-insensitive, default `collation` level results in
    our `case_sensitive_books` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Collation is a pretty strong and relatively new concept in MongoDB, so we will
    keep exploring it throughout the different chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Geospatial indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Geospatial indexes were introduced early on in MongoDB, and the fact that Foursquare
    was one of the earliest customers and success stories for MongoDB (then 10gen
    Inc.) is probably no coincidence. There are three distinct types of geospatial
    indexes that we will explore in this chapter, and they will be covered in the
    following sections.
  prefs: []
  type: TYPE_NORMAL
- en: 2d geospatial indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `2d` geospatial index stores geospatial data as points on a two-dimensional
    plane. It is mostly kept for legacy reasons, for coordinate pairs created before
    MongoDB 2.2, and in most cases, it should not be used with the latest versions.
  prefs: []
  type: TYPE_NORMAL
- en: 2dsphere geospatial indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `2dsphere` geospatial index supports queries calculating geometries in an
    earth-like plane. It is more accurate than the simplistic `2d` index, and can
    support both GeoJSON objects and coordinate pairs as input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its current version, since MongoDB 3.2, is version 3\. It is a sparse index
    by default, only indexing documents that have a `2dsphere` field value. Assuming
    that we have a location field in our `books` collection, tracking the home address
    of the main author of each book, we could create an index on this field as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `location` field needs to be a GeoJSON object, like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'A `2dsphere` index can also be a part of a compound index, as the first field
    or otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: geoHaystack indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`geoHaystack` indexes are useful when we need to search for geographical-based
    results in a small area. Like searching for a needle in a haystack, with a `geoHaystack`
    index, we can define buckets of geolocation points and get back all of the results
    that belong in this area.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a `geoHaystack` index, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This will create buckets of documents within `2` units of latitude or longitude
    from each document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, with the preceding example `location`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the `bucketSize: 2`, every document with the `location` `[49.5876..53.5876,
    -2.1643..2.1643]` will belong in the same bucket as our location.'
  prefs: []
  type: TYPE_NORMAL
- en: A document can appear in multiple buckets. If we want to use spherical geometry, `2dsphere`
    is a better solution. `geoHaystack` indexes are sparse, by default.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to calculate the nearest document to our location and it is outside
    of our `bucketSize` (that is, greater than 2 units of latitude/longitude, in our
    example), queries will be inefficient, and possibly inaccurate. Use a `2dsphere`
    index for such queries.
  prefs: []
  type: TYPE_NORMAL
- en: Building and managing indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Indexes can be built using the MongoDB shell or any of the available drivers.
    By default, indexes are built in the foreground, blocking all other operations
    in the database. This is faster, but is often undesirable, especially in production
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also build indexes in the background by adding the `{background: true}`
    parameter in our index commands in the shell. Background indexes will only block
    the current connection/thread. We can open a new connection (that is, using `mongo`
    in the command line) to connect to the same database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Background index building can take significantly more time than foreground index
    building, especially if the indexes can't fit into the available RAM.
  prefs: []
  type: TYPE_NORMAL
- en: Index early and revisit indexes regularly for consolidation. Queries won't see
    partial index results. Queries will start getting results from an index only after
    it is completely created.
  prefs: []
  type: TYPE_NORMAL
- en: Do not use the main application code to create indexes, as it can impose unpredictable
    delays. Instead, get a list of indexes from the application, and mark these for
    creation during maintenance windows.
  prefs: []
  type: TYPE_NORMAL
- en: Forcing index usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can force MongoDB to use an index by applying the `hint()` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from `createIndex` notifies us that the index was created (`"ok"
    : 1`), no collection was automatically created as a part of index creation (`"createdCollectionAutomatically"
    : false`), the number of indexes before this index creation was `8`, and now there
    are nine indexes for this collection, in total.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we try to search for a book by `isbn`, we can use the `explain()` command
    to see the `winningPlan` sub-document, where we can find which query plan was
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that an index with `isbn` is `1` and `name` is `1` was used instead
    of our newly created index. We can also view our index in the `rejectedPlans`
    sub-document of the output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This is, in fact, correct, as MongoDB is trying to reuse an index that is more
    specific than a generic one.
  prefs: []
  type: TYPE_NORMAL
- en: We may not be sure though in cases where our `isbn_1` index is performing better
    than the `isbn_1_name_1` one.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can force MongoDB to use our newly created index, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `winningPlan` sub-document contains our index, `isbn_1`, and there
    are no `rejectedPlans` elements. It's an empty array in the result set.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot use `hint()` with the special type of text indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Hint and sparse indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By design, sparse indexes do not include some documents in the index, based
    on the presence/absence of a field. Queries that may include documents that are
    not present in the index will not use a sparse index.
  prefs: []
  type: TYPE_NORMAL
- en: Using `hint()` with a sparse index may result in incorrect counts, since it
    is forcing MongoDB to use an index that may not include all of the results that
    we want.
  prefs: []
  type: TYPE_NORMAL
- en: Older versions of `2dsphere`, `2d`, `geoHaystack`, and text indexes are sparse,
    by default. `hint()` should be used with caution, and after careful consideration
    of its implications.
  prefs: []
  type: TYPE_NORMAL
- en: Building indexes on replica sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In replica sets, if we issue a `createIndex()` command, secondaries will begin
    to create the index after the primary server has finished creating it. Similarly,
    in sharded environments, primaries will start to build indexes, and secondaries
    will start after the primary for each shard that is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recommended approaches to building indexes in replica sets are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Stop one secondary from the replica set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restart it as a standalone server in a different port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build the index from the shell as a standalone index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restart the secondary in the replica set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow for the secondary to catch up with the primary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to have a large enough oplog size in the primary to make sure that the
    secondary will be able to catch up once it's reconnected. The oplog size is defined
    in MB in the configuration, and it defines how many operations will be kept in
    the log in the primary server. If the oplog size can only hold up to the last
    100 operations happening in the primary, and 101 or more operations happen, this
    means that the secondary will not be able to sync with the primary. This is a
    consequence of the primary not having enough memory to keep track of its operations
    and inform the secondary of them. Building indexes in replica sets is a manual
    process, involving several steps for each primary and secondary server.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach can be repeated for each secondary server in the replica set.
    Then, for the primary server, we can do either of these things:'
  prefs: []
  type: TYPE_NORMAL
- en: Build the index in the background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step down the primary by using `rs.stepDown()`, and repeat the preceding process
    with the server as a secondary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using approach number two, when the primary steps down, there will be a brief
    period when our cluster won't be taking any writes. Our application shouldn't
    timeout during this (usually less than) 30-60 second period.
  prefs: []
  type: TYPE_NORMAL
- en: Building an index in the background in the primary will build it in the background
    for the secondaries too. This may impact writes in our servers during index creation,
    but on the plus side, it has no manual steps. It is always a good idea to have
    a staging environment that mirrors production, and dry run operations that affect
    the live cluster in staging, in order to avoid surprises.
  prefs: []
  type: TYPE_NORMAL
- en: Managing indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to give human-friendly names to your indexes,
    as well as some special considerations and limitations that we have to keep in
    mind for indexing.
  prefs: []
  type: TYPE_NORMAL
- en: Naming indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, index names are assigned by MongoDB automatically, based on the
    fields indexed and the direction of the index (`1`, `-1`). If we want to assign
    our own `name`, we can do so at creation time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a new index called `international_standard_book_number_index`,
    instead of what MongoDB would have named it (`"isbn_1"`).
  prefs: []
  type: TYPE_NORMAL
- en: We can view all of the indexes in our `books` collection by using `db.books.getIndexes()`.
    A fully qualified index name has to be less than or equal to 128 characters. That
    also includes `database_name`, `collection_name`, and the dots separating them.
  prefs: []
  type: TYPE_NORMAL
- en: Special considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are a few limitations to keep in mind concerning indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: Index entries have to be less than 1,024 bytes. This is mostly an internal consideration,
    but we can keep it in mind if we run into issues with indexing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A collection can have up to 64 indexes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A compound index can have up to 31 fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special indexes cannot be combined in queries. This includes special query operators
    that have to use special indexes, such as `$text` for text indexes and `$near`
    for geospatial indexes. This is because MongoDB can use multiple indexes to fulfill
    a query, but not in all cases. There will be more about this issue in the *Index
    intersection* section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multikey and geospatial indexes cannot cover a query. This means that index
    data alone will not be enough to fulfill the query, and the underlying documents
    will need to be processed by MongoDB to get back the complete set of results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexes have a unique constraint on fields. We cannot create multiple indexes
    on the same fields, differing only in options. This is a limitation for sparse
    and partial indexes, as we cannot create multiple variations of these indexes
    that differ only in the filtering query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using indexes efficiently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating indexes is a decision that should not be taken lightly. As easy as
    it is to create indexes via the shell, it can create problems down the line if
    we end up with too many, or inadequately efficient, indexes. In this section,
    you will learn how to measure the performance of existing indexes, some tips for
    improving performance, and how we can consolidate the number of indexes so that
    we have better-performing indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning how to use the `explain()` command will help you in both optimizing
    and understanding the performance of an index. The `explain()` command, when used
    in conjunction with a query, will return the query plan that MongoDB would use
    for this query, instead of the actual results.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is invoked by chaining it at the end of our query, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'It can take three options: `queryPlanner` (the default), `executionStats`,
    and `allPlansExecution`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the most verbose output, `allPlansExecution`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can get information for both the winning query plan and some partial
    information about query plans that were considered during the planning phase,
    but were rejected because the query planner considered them slower. The `explain()`
    command returns a rather verbose output anyway, allowing for deep insights into
    how the query plan works to return our results.
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, we need to focus on whether the indexes that should be used
    are being used, and if the number of scanned documents matches the number of returned
    documents as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: For the first one, we can inspect the `stage` field and look for `IXSCAN`, which
    means that an index was used. Then, in the sibling `indexName` field, we should
    see the name of our expected index.
  prefs: []
  type: TYPE_NORMAL
- en: For the second one, we need to compare `keysExamined` with the `nReturned` fields.
    We ideally want our indexes to be as selective as possible with regard to our
    queries, meaning that to return 100 documents, these would be the 100 documents
    that our index examines.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is a trade-off as indexes increase in number and size in our
    collection. We can have a limited number of indexes per collection, and we definitely
    have a limited amount of RAM to fit these indexes, so we must balance the trade-off
    between having the best available indexes, and these indexes not fitting into
    our memory and getting slowed down.
  prefs: []
  type: TYPE_NORMAL
- en: Improving performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we get comfortable with measuring the performance of the most common and
    important queries for our users, we can start to try to improve them.
  prefs: []
  type: TYPE_NORMAL
- en: The general idea is that we need indexes when we expect (or already have) repeatable
    queries that are starting to run slowly. Indexes do not come for free, as they
    impose a performance penalty in creation and maintenance, but they are more than
    worth it for frequent queries, and can reduce the lock percentage in our database,
    if designed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recapping on our suggestions from the previous section, we want our indexes
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Fit in the RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure selectivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be used to sort our query results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be used in our most common and important queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fitting in the RAM can be ensured by using `getIndexes()` in our collections
    and making sure that we are not creating large indexes by inspecting the system
    level available RAM and if swap is being used.
  prefs: []
  type: TYPE_NORMAL
- en: Selectivity, as mentioned previously, is ensured by comparing `nReturned` with
    `keysExamined` in each `IXSCAN` phase of our queries. We want these two numbers
    to be as close as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that our indexes are used to sort our query results is a combination
    of using compound indexes (which will be used as a whole, and also for any prefix-based
    query) and declaring the direction of our indexes to be in accordance with our
    most common queries.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, aligning indexes with our query is a matter of application usage patterns,
    which can uncover that queries are used most of the time, and then by using `explain()`
    on these queries to identify the query plan that is being used each time.
  prefs: []
  type: TYPE_NORMAL
- en: Index intersection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Index intersection refers to the concept of using more than one index to fulfill
    a query. This was added fairly recently, and is not perfect yet; however we can
    exploit it to consolidate our indexes.
  prefs: []
  type: TYPE_NORMAL
- en: We can verify whether an index intersection happened in a query by using `explain()`
    on the query and witnessing an `AND_SORTED` or `AND_HASH` stage in the executed
    query plan.
  prefs: []
  type: TYPE_NORMAL
- en: Index intersection can happen when we use `OR` (`$or`) queries, by using a different
    index for each `OR` clause. Index intersection can happen when we use `AND` queries,
    and we have either complete indexes for each `AND` clause or index prefixes for
    some (or all) of the clauses.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider a query on our `books` collection, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, with two indexes (one on `isbn` and the other on `price`), MongoDB can
    use each index to get the related results, and then intersect on the index results
    to get the result set.
  prefs: []
  type: TYPE_NORMAL
- en: With compound indexes, as you learned previously in this chapter, we can use
    index prefixing to support queries that contain the first *1…n-1* fields of an
    *n *field compound index.
  prefs: []
  type: TYPE_NORMAL
- en: What we cannot support with compound indexes are queries that are looking for
    fields in the compound index, missing one or more of the previously defined fields.
  prefs: []
  type: TYPE_NORMAL
- en: The order matters in compound indexes.
  prefs: []
  type: TYPE_NORMAL
- en: To satisfy these queries, we can create indexes on the individual fields, which
    will then use index intersection and fulfill our needs. The down side to this
    approach is that as the number of fields (*n*) increases, the number of indexes
    that we have to create grows exponentially, thus increasing our need for storage
    and memory.
  prefs: []
  type: TYPE_NORMAL
- en: Index intersection will not work with `sort()`. We can't use one index for querying
    and a different index for applying `sort()` to our results.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we have an index that can fulfill a part for the whole of our query
    and the `sort()` field, then this index will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following links for further references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bigocheatsheet.com/](http://bigocheatsheet.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://commons.wikimedia.org/](https://commons.wikimedia.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.mongodb.com/manual/core/index-intersection/](https://docs.mongodb.com/manual/core/index-intersection/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the foundations of indexing and index internals.
    We then explored how to use the different index types available in MongoDB, such
    as single field, compound, and multikey, as well as some special types, such as
    text, hashed, TTL, partial, parse, unique, case-insensitive, and geospatial.
  prefs: []
  type: TYPE_NORMAL
- en: In the next part of the chapter, you learned how to build and manage indexes
    using the shell, which is a basic part of administration and database management,
    even for NoSQL databases. Finally, we discussed how to improve our indexes, at
    a high level, and also how we can use index intersection in practice, in order
    to consolidate the number of indexes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how we can monitor our MongoDB cluster
    and keep consistent backups. You will also learn how to handle security in MongoDB.
  prefs: []
  type: TYPE_NORMAL
