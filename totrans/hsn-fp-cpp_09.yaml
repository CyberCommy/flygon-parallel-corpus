- en: Removing Duplication with Functional Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key principle in software design is reducing code duplication. Functional
    constructs provide additional opportunities for reducing code duplication through
    currying and functional composition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How and why to avoid repeating code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to identify code similarities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using currying to remove certain types of code similarities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using composition to remove certain types of code similarities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using lambdas or composition to remove certain types of code similarities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a compiler that supports C++ 17\. I used GCC 7.3.0.
  prefs: []
  type: TYPE_NORMAL
- en: The code can be found on GitHub at [https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp](https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp),
    in the `Chapter07` folder. It includes and uses `doctest`, which is a single header
    open source unit testing library. You can find it on its GitHub repository at [https://github.com/onqtam/doctest](https://github.com/onqtam/doctest).
  prefs: []
  type: TYPE_NORMAL
- en: Removing duplication with functional operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintaining code over long periods of time is much easier when we only need
    to change the code in one place, and when we can recombine existing pieces of
    code. One of the most effective ways to move toward this ideal is to identify
    and to remove duplication from code. The operations from functional programming—partial
    application, currying, and functional composition—offer many opportunities to
    make code cleaner and with limited duplication.
  prefs: []
  type: TYPE_NORMAL
- en: But first, let's understand what duplication is and why we need to reduce it.
    First, we'll look at the **Don't Repeat Yourself** (**DRY**) principle, and then
    at the relationship between duplication and code similarity. Finally, we'll look
    at ways to remove code similarity.
  prefs: []
  type: TYPE_NORMAL
- en: The DRY principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The number of core books in software development is unexpectedly low. Sure,
    there are many books on details and on helping people understand the ideas better,
    but books on core ideas are remarkably few and old. Being on the list of core
    books is an honor for authors, as well as a hint that the topic is extremely important.
    Many programmers would place the book *Pragmatic Programmer*, by Andrew Hunt and
    David Thomas, on such a list. This book, published in 1999, details one principle
    that makes a lot of sense to anyone who's been working with large code bases for
    long periods of time—DRY.
  prefs: []
  type: TYPE_NORMAL
- en: At its core, the DRY principle operates on the understanding that code is a
    way to store knowledge. Every function and every data member represents knowledge
    about a problem. Ideally, we would like to avoid having knowledge duplicated around
    the system. In other words, whatever you're looking for should only be in one
    place. Unfortunately, most of the code bases are **WET** (an acronym for either
    **write everything twice**, **we enjoy typing**, or **waste everyone's time**),
    rather than DRY.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of removing duplication is older, however. It was previously mentioned
    by Kent Beck in the 1990s as part of the **extreme programming** (**XP**) practices.
    Kent Beck described the four elements of simple design, a thinking tool for obtaining
    or improving software design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple design means that it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Passes the tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reveals intention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduces duplication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has fewer elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I learned these rules from J.B. Rainsberger, who also worked on simplifying
    these rules. He taught me that in most situations, it's enough to focus on three
    things—testing the code, improving names, and reducing duplication.
  prefs: []
  type: TYPE_NORMAL
- en: But that's not the only place where removing duplication is mentioned. The principle
    has appeared in various ways in the Unix design philosophy, in the **domain-driven
    design** (**DDD**) techniques, as a help to **test-driven development** (**TDD**)
    practice, and many others. It's safe to say it's a universal principle of good
    software design, and it makes sense to use it whenever we talk about structuring
    the code within a module.
  prefs: []
  type: TYPE_NORMAL
- en: Duplication and similarity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Later in my journey toward learning good software design, I realized that the
    term **duplication** is very useful for expressing the philosophy of what we're
    trying to accomplish, but it's hard to understand how to put it in practice. I
    found a better name for the things I search for when trying to improve design—I
    look for **code similarities**. Once I find similarities, I ask whether they show
    a deeper duplication, or whether they're simply an accident.
  prefs: []
  type: TYPE_NORMAL
- en: 'I also noticed in time that I look for a few specific types of similarities.
    Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Similar names, either full names or names embedded inside longer names of functions,
    parameters, methods, variables, constants, classes, modules, namespaces, and so
    on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar lists of parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar function calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different code trying to achieve similar results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In general, I follow these two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, notice similarities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Second, decide whether to remove the similarity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When unsure if the similarity says something deeper about the design, it's best
    to keep it. It's also best to start removing similarities once you've seen them
    around three times; this way, you know for sure that it violates the DRY principle
    rather than being just an accident.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at a few types of similarities that we can remove through
    functional operations.
  prefs: []
  type: TYPE_NORMAL
- en: Addressing parameter similarities with partial application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our previous chapters, you have seen situations when a function is called
    multiple times with the same value for one of the parameters. See, for example,
    the code in our Tic-Tac-Toe result problem; we had one function responsible for
    checking whether a line is filled with a token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Tic-Tac-Toe uses two tokens, `X` and `O`, it''s clear that we will have
    a repeated call of this function where `tokenToCheck` is either `X` or `O`. The
    usual way to remove this kind of similarity is to implement two new functions,
    `lineFilledWithX` and `lineFilledWithO`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a viable solution, but it still requires us to write a separate function
    and three lines of code. As we have seen, we have another option in functional
    programming; we can simply use partial application to obtain the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I prefer to use partial application when possible because this type of code
    is just plumbing, and the fewer lines of plumbing I need to write, the better.
    However, you need to be careful when using partial application in a team. Every
    team member should be familiar with partial application and proficient in understanding
    this type of code. Otherwise, the use of partial application will just make the
    code more difficult to understand for the development team.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the call function on the output of another function similarity with
    functional composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may have noticed the pattern shown in the following code in the past:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Often, if you look hard enough, you will find another function in your code
    base that does something similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There seems to be a deeper reason for this type of similarity, due to the way
    applications grow in complexity over time. We often start by implementing a simple
    flow that goes through multiple steps. We then implement variations of the same
    flow, with a few steps that repeat and others that change. Sometimes, a variation
    of the flow involves either changing the order of the steps, or adjusting a few
    of the steps.
  prefs: []
  type: TYPE_NORMAL
- en: In our implementation, the steps transform into functions that are combined
    in various ways within other functions. But if we use the output of the previous
    step and feed it into the next step, we have a similarity in the code that doesn't
    depend on what each of the steps does.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove this similarity, we would traditionally extract the similar parts
    of the code and pass the result, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: However, the code often becomes more difficult to understand and more difficult
    to change when extracting functions, as shown in the previous code. Extracting
    the common part of the function doesn't take into account the fact that the code
    is, in reality, a chain call.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this visible, I tend to reformat this pattern of code to a single statement,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'While not everyone likes this format, the similarity and the difference between
    the two calls is clearer. It''s also quite obvious that we have a solution using
    functional composition—we just need to compose `f3` with `f2`, and compose the
    result with either `f1` or `f1Prime` to get the result we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is a very powerful mechanic! We can create countless combinations of chain
    calls just through functional composition, in a few lines of code. We can replace
    the hidden plumbing masquerading as the order of statements in a function with
    a few composition statements expressing the true nature of our code.
  prefs: []
  type: TYPE_NORMAL
- en: However, as we've seen in [Chapter 4](d361a3f0-acc7-4e77-9387-2b563fac2f09.xhtml),
    *The Idea of Functional Composition*, this is not necessarily an easy task in
    C++, since we need to write our own `compose` functions that work for our specific
    situations. Until C++ offers better support for functional composition, we are
    forced to keep this mechanic to a minimum, and only use it where the similarity
    is not only obvious, but where we expect it to increase over time.
  prefs: []
  type: TYPE_NORMAL
- en: Removing structural similarity with higher-level functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's been a pattern in our discussion until now—functional programming helps
    us to remove the plumbing from our code and express the true structure of the
    code. Imperative programming uses a sequence of statements as a fundamental structure;
    functional programming reduces the sequences and focuses on the interesting play
    of the functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is most visible when we discuss structural similarity. A widespread pattern,
    structural similarity refers to the situations when the structure of code repeats,
    although not necessarily through calling the same functions or using the same
    parameters. To see it in action, let''s start from a very interesting similarity
    in our Tic-Tac-Toe code. This is code that we wrote in [Chapter 6](0b87d535-3c52-44cd-a6df-ba6d03fc37cf.xhtml),
    *Thinking in Functions – from Data in to Data out*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `xWins` and `oWins` functions look very similar, as they both call the
    same function as the first parameter, and a variation on the `lineFilledWith`
    function as their second parameter. Let''s remove their similarity. First, let''s
    remove `lineFilledWithX` and `lineFilledWithO`, and replace them with their `lineFilledWith`
    equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the similarity is obvious, we can easily extract a common function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We also notice that `xWins` and `oWins` are just partial applications of `tokenWins`,
    so let''s make this explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s focus on `tokenWins`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we notice that the lambda we pass into `any_of_collection` is a partial
    application with a fixed token parameter, so let''s replace it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is quite a small function now, packing a lot of power due to our partial
    applications. However, we can already extract a higher-level function that would
    allow us to create more similar functions without writing any code. I don''t know
    what to call it yet, so I''ll just call it `foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `foo` function shows the structure of the code, but it''s quite unreadable,
    so let''s name things better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We've introduced a higher level of abstraction, which can make code more difficult
    to understand. On the other hand, we've enabled the creation of functions of the `f(g(first),
    bind(h, _1, second))` form in one line of code.
  prefs: []
  type: TYPE_NORMAL
- en: Is the code better? That's up to context, your judgment, and how familiar you
    and your colleagues are with higher-level functions. Remember, however—abstractions,
    while very powerful, come with a price. An abstraction is more difficult to understand,
    but if you *speak* in abstractions, you can combine them in very powerful ways.
    Using these higher-level functions is like building a language from scratch—it
    enables you to communicate on a different level, but it also creates a barrier
    of entry for other people. Use abstractions with caution!
  prefs: []
  type: TYPE_NORMAL
- en: Removing hidden loops using higher-level functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A particular example of structural duplication is often encountered in code,
    and I ended up calling it **hidden loops**. The idea of hidden loops is that we
    use the same code structure multiple times in a sequence. The trick, though, is
    that the functions called or the parameters don't have to be the same; since the
    basic idea of functional programming is that functions are data as well, we can
    see these structures as loops over data structures that might also store the functions
    that we call.
  prefs: []
  type: TYPE_NORMAL
- en: 'I usually see this pattern in a series of `if` statements. In fact, I started
    seeing them while facilitating hands-on sessions using the Tic-Tac-Toe result
    problem. The usual solution to the problem, in an **object-oriented programming**
    (**OOP**) or imperative language, looks something like what is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, the `enum` token contains three values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Board` class looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementations of `anyLineFilledWith`, `anyColumnFilledWith`, `anyDiagonalFilledWith`,
    and `notFilledYet` are quite similar; a very simplistic implementation of `anyLineFilledWith`,
    assuming a 3 x 3 board, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We are less interested in the underlying implementation however, and more interested
    in the similarities in the preceding winner function. First, the condition in
    the `if` statement repeats with a different parameter. But, more interestingly,
    there''s a structure that repeats as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you saw a structure like this that uses data instead of different functions,
    you would immediately notice that it's a hidden loop. When function calls are
    involved, we don't notice this type of repetition since we're not trained to see
    functions as data. But that's exactly what they are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we remove that similarity, let''s simplify the conditions. I will make
    all conditions functions without parameters, through the magic of partial function
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next step is to remove the variation between the four different conditions,
    and replace the similarity with a loop. We just need to have a list of pairs of
    *(lambda, result)* and use a higher-level function such as `find_if` to do the
    loop for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The last piece of the puzzle is ensuring that our code returns `Draw` if nothing
    else works. Since `find_if` returns the first element that fits the rule, we just
    need to have `Draw` at the end, associated with a function that always returns
    `true`. I named this function, appropriately, `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'How''s this code working for us? Well, it has a few advantages. First, we can
    easily add a new pair of conditions and results, for example, if we ever get the
    request to implement variations of Tic-Tac-Toe in multiple dimensions or with
    more players. Second, the code is shorter. Third, with a few changes, we obtain
    a simple, albeit quite general, rule engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The only particular code in the previous sample is the list of rules. Everything
    else is quite general and can be reused on multiple problems.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, there's a price to pay for going to a higher level of abstraction.
    We took the time to name things as clearly as possible, and I believe this code
    is very easy to read. However, it might not be familiar to many people.
  prefs: []
  type: TYPE_NORMAL
- en: Another possible issue is memory usage. The initial version of the code, while
    repeating the same code structure, doesn't need to allocate memory for a list
    of pairs of function and results; however, it's important to measure these things,
    since even the initial code will require some process memory for the extra instructions.
  prefs: []
  type: TYPE_NORMAL
- en: This example shows us how repeated structures can be turned into loops through
    a very simple code sample. This is just scratching the surface; this pattern is so
    widespread that I'm sure you'll notice it in your code once you start looking.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at different types of code similarities and how we
    can reduce them through various functional programming techniques. From repeated
    parameters that can be replaced with partial application, to chained calls that
    can be turned into functional composition, all the way to the wonderfully complex
    world of structural similarities that can be removed through higher-level functions,
    you are now well armed to notice and reduce similarity in any code base you work
    with.
  prefs: []
  type: TYPE_NORMAL
- en: As you have noticed, we started to discuss code structures and software design.
    This leads us to another core principle of design—high cohesion and low coupling.
    How do we increase cohesion using functions? It turns out that that's where classes
    are very useful and this is what we will discuss in the next chapter.
  prefs: []
  type: TYPE_NORMAL
