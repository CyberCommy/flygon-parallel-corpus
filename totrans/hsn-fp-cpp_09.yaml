- en: Removing Duplication with Functional Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key principle in software design is reducing code duplication. Functional
    constructs provide additional opportunities for reducing code duplication through
    currying and functional composition.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: How and why to avoid repeating code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to identify code similarities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using currying to remove certain types of code similarities
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using composition to remove certain types of code similarities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using lambdas or composition to remove certain types of code similarities
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a compiler that supports C++ 17\. I used GCC 7.3.0.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The code can be found on GitHub at [https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp](https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp),
    in the `Chapter07` folder. It includes and uses `doctest`, which is a single header
    open source unit testing library. You can find it on its GitHub repository at [https://github.com/onqtam/doctest](https://github.com/onqtam/doctest).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Removing duplication with functional operations
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintaining code over long periods of time is much easier when we only need
    to change the code in one place, and when we can recombine existing pieces of
    code. One of the most effective ways to move toward this ideal is to identify
    and to remove duplication from code. The operations from functional programming—partial
    application, currying, and functional composition—offer many opportunities to
    make code cleaner and with limited duplication.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: But first, let's understand what duplication is and why we need to reduce it.
    First, we'll look at the **Don't Repeat Yourself** (**DRY**) principle, and then
    at the relationship between duplication and code similarity. Finally, we'll look
    at ways to remove code similarity.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The DRY principle
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The number of core books in software development is unexpectedly low. Sure,
    there are many books on details and on helping people understand the ideas better,
    but books on core ideas are remarkably few and old. Being on the list of core
    books is an honor for authors, as well as a hint that the topic is extremely important.
    Many programmers would place the book *Pragmatic Programmer*, by Andrew Hunt and
    David Thomas, on such a list. This book, published in 1999, details one principle
    that makes a lot of sense to anyone who's been working with large code bases for
    long periods of time—DRY.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: At its core, the DRY principle operates on the understanding that code is a
    way to store knowledge. Every function and every data member represents knowledge
    about a problem. Ideally, we would like to avoid having knowledge duplicated around
    the system. In other words, whatever you're looking for should only be in one
    place. Unfortunately, most of the code bases are **WET** (an acronym for either
    **write everything twice**, **we enjoy typing**, or **waste everyone's time**),
    rather than DRY.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The idea of removing duplication is older, however. It was previously mentioned
    by Kent Beck in the 1990s as part of the **extreme programming** (**XP**) practices.
    Kent Beck described the four elements of simple design, a thinking tool for obtaining
    or improving software design.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple design means that it does the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Passes the tests
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reveals intention
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduces duplication
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has fewer elements
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I learned these rules from J.B. Rainsberger, who also worked on simplifying
    these rules. He taught me that in most situations, it's enough to focus on three
    things—testing the code, improving names, and reducing duplication.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: But that's not the only place where removing duplication is mentioned. The principle
    has appeared in various ways in the Unix design philosophy, in the **domain-driven
    design** (**DDD**) techniques, as a help to **test-driven development** (**TDD**)
    practice, and many others. It's safe to say it's a universal principle of good
    software design, and it makes sense to use it whenever we talk about structuring
    the code within a module.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Duplication and similarity
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Later in my journey toward learning good software design, I realized that the
    term **duplication** is very useful for expressing the philosophy of what we're
    trying to accomplish, but it's hard to understand how to put it in practice. I
    found a better name for the things I search for when trying to improve design—I
    look for **code similarities**. Once I find similarities, I ask whether they show
    a deeper duplication, or whether they're simply an accident.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'I also noticed in time that I look for a few specific types of similarities.
    Here are a few examples:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Similar names, either full names or names embedded inside longer names of functions,
    parameters, methods, variables, constants, classes, modules, namespaces, and so
    on
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar lists of parameters
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar function calls
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different code trying to achieve similar results
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In general, I follow these two steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: First, notice similarities.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Second, decide whether to remove the similarity.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When unsure if the similarity says something deeper about the design, it's best
    to keep it. It's also best to start removing similarities once you've seen them
    around three times; this way, you know for sure that it violates the DRY principle
    rather than being just an accident.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at a few types of similarities that we can remove through
    functional operations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Addressing parameter similarities with partial application
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our previous chapters, you have seen situations when a function is called
    multiple times with the same value for one of the parameters. See, for example,
    the code in our Tic-Tac-Toe result problem; we had one function responsible for
    checking whether a line is filled with a token:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since Tic-Tac-Toe uses two tokens, `X` and `O`, it''s clear that we will have
    a repeated call of this function where `tokenToCheck` is either `X` or `O`. The
    usual way to remove this kind of similarity is to implement two new functions,
    `lineFilledWithX` and `lineFilledWithO`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is a viable solution, but it still requires us to write a separate function
    and three lines of code. As we have seen, we have another option in functional
    programming; we can simply use partial application to obtain the same result:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I prefer to use partial application when possible because this type of code
    is just plumbing, and the fewer lines of plumbing I need to write, the better.
    However, you need to be careful when using partial application in a team. Every
    team member should be familiar with partial application and proficient in understanding
    this type of code. Otherwise, the use of partial application will just make the
    code more difficult to understand for the development team.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the call function on the output of another function similarity with
    functional composition
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may have noticed the pattern shown in the following code in the past:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Often, if you look hard enough, you will find another function in your code
    base that does something similar:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There seems to be a deeper reason for this type of similarity, due to the way
    applications grow in complexity over time. We often start by implementing a simple
    flow that goes through multiple steps. We then implement variations of the same
    flow, with a few steps that repeat and others that change. Sometimes, a variation
    of the flow involves either changing the order of the steps, or adjusting a few
    of the steps.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: In our implementation, the steps transform into functions that are combined
    in various ways within other functions. But if we use the output of the previous
    step and feed it into the next step, we have a similarity in the code that doesn't
    depend on what each of the steps does.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove this similarity, we would traditionally extract the similar parts
    of the code and pass the result, as shown in the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, the code often becomes more difficult to understand and more difficult
    to change when extracting functions, as shown in the previous code. Extracting
    the common part of the function doesn't take into account the fact that the code
    is, in reality, a chain call.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this visible, I tend to reformat this pattern of code to a single statement,
    as shown in the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'While not everyone likes this format, the similarity and the difference between
    the two calls is clearer. It''s also quite obvious that we have a solution using
    functional composition—we just need to compose `f3` with `f2`, and compose the
    result with either `f1` or `f1Prime` to get the result we want:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a very powerful mechanic! We can create countless combinations of chain
    calls just through functional composition, in a few lines of code. We can replace
    the hidden plumbing masquerading as the order of statements in a function with
    a few composition statements expressing the true nature of our code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: However, as we've seen in [Chapter 4](d361a3f0-acc7-4e77-9387-2b563fac2f09.xhtml),
    *The Idea of Functional Composition*, this is not necessarily an easy task in
    C++, since we need to write our own `compose` functions that work for our specific
    situations. Until C++ offers better support for functional composition, we are
    forced to keep this mechanic to a minimum, and only use it where the similarity
    is not only obvious, but where we expect it to increase over time.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Removing structural similarity with higher-level functions
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's been a pattern in our discussion until now—functional programming helps
    us to remove the plumbing from our code and express the true structure of the
    code. Imperative programming uses a sequence of statements as a fundamental structure;
    functional programming reduces the sequences and focuses on the interesting play
    of the functions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'This is most visible when we discuss structural similarity. A widespread pattern,
    structural similarity refers to the situations when the structure of code repeats,
    although not necessarily through calling the same functions or using the same
    parameters. To see it in action, let''s start from a very interesting similarity
    in our Tic-Tac-Toe code. This is code that we wrote in [Chapter 6](0b87d535-3c52-44cd-a6df-ba6d03fc37cf.xhtml),
    *Thinking in Functions – from Data in to Data out*:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `xWins` and `oWins` functions look very similar, as they both call the
    same function as the first parameter, and a variation on the `lineFilledWith`
    function as their second parameter. Let''s remove their similarity. First, let''s
    remove `lineFilledWithX` and `lineFilledWithO`, and replace them with their `lineFilledWith`
    equivalent:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that the similarity is obvious, we can easily extract a common function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also notice that `xWins` and `oWins` are just partial applications of `tokenWins`,
    so let''s make this explicit:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let''s focus on `tokenWins`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'First, we notice that the lambda we pass into `any_of_collection` is a partial
    application with a fixed token parameter, so let''s replace it:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is quite a small function now, packing a lot of power due to our partial
    applications. However, we can already extract a higher-level function that would
    allow us to create more similar functions without writing any code. I don''t know
    what to call it yet, so I''ll just call it `foo`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Our `foo` function shows the structure of the code, but it''s quite unreadable,
    so let''s name things better:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We've introduced a higher level of abstraction, which can make code more difficult
    to understand. On the other hand, we've enabled the creation of functions of the `f(g(first),
    bind(h, _1, second))` form in one line of code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了更高级的抽象层次，这可能会使代码更难理解。另一方面，我们使得能够在一行代码中创建`f(g(first), bind(h, _1, second))`形式的函数成为可能。
- en: Is the code better? That's up to context, your judgment, and how familiar you
    and your colleagues are with higher-level functions. Remember, however—abstractions,
    while very powerful, come with a price. An abstraction is more difficult to understand,
    but if you *speak* in abstractions, you can combine them in very powerful ways.
    Using these higher-level functions is like building a language from scratch—it
    enables you to communicate on a different level, but it also creates a barrier
    of entry for other people. Use abstractions with caution!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 代码变得更好了吗？这取决于上下文、你的判断以及你和同事对高级函数的熟悉程度。然而，请记住——抽象虽然非常强大，但是也是有代价的。抽象更难理解，但如果你能够用抽象进行交流，你可以以非常强大的方式组合它们。使用这些高级函数就像从头开始构建一种语言——它使你能够在不同的层次上进行交流，但也为其他人设置了障碍。谨慎使用抽象！
- en: Removing hidden loops using higher-level functions
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高级函数消除隐藏的循环
- en: A particular example of structural duplication is often encountered in code,
    and I ended up calling it **hidden loops**. The idea of hidden loops is that we
    use the same code structure multiple times in a sequence. The trick, though, is
    that the functions called or the parameters don't have to be the same; since the
    basic idea of functional programming is that functions are data as well, we can
    see these structures as loops over data structures that might also store the functions
    that we call.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 结构重复的一个特殊例子经常在代码中遇到，我称之为**隐藏的循环**。隐藏的循环的概念是我们在一个序列中多次使用相同的代码结构。然而，其中的技巧在于被调用的函数或参数并不一定相同；因为函数式编程的基本思想是函数也是数据，我们可以将这些结构视为对可能也存储我们调用的函数的数据结构的循环。
- en: 'I usually see this pattern in a series of `if` statements. In fact, I started
    seeing them while facilitating hands-on sessions using the Tic-Tac-Toe result
    problem. The usual solution to the problem, in an **object-oriented programming**
    (**OOP**) or imperative language, looks something like what is shown in the following
    code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常在一系列`if`语句中看到这种模式。事实上，我在使用井字棋结果问题进行实践会话时开始看到它们。在**面向对象编程**（**OOP**）或命令式语言中，问题的通常解决方案大致如下所示：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the previous example, the `enum` token contains three values:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`enum`标记包含三个值：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `Board` class looks something like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Board`类大致如下：'
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The implementations of `anyLineFilledWith`, `anyColumnFilledWith`, `anyDiagonalFilledWith`,
    and `notFilledYet` are quite similar; a very simplistic implementation of `anyLineFilledWith`,
    assuming a 3 x 3 board, is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`anyLineFilledWith`、`anyColumnFilledWith`、`anyDiagonalFilledWith`和`notFilledYet`的实现非常相似；假设一个3
    x 3的棋盘，`anyLineFilledWith`的非常简单的实现如下：'
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We are less interested in the underlying implementation however, and more interested
    in the similarities in the preceding winner function. First, the condition in
    the `if` statement repeats with a different parameter. But, more interestingly,
    there''s a structure that repeats as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们对底层实现不太感兴趣，更感兴趣的是前面的winner函数中的相似之处。首先，`if`语句中的条件重复了，但更有趣的是，有一个重复的结构如下：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you saw a structure like this that uses data instead of different functions,
    you would immediately notice that it's a hidden loop. When function calls are
    involved, we don't notice this type of repetition since we're not trained to see
    functions as data. But that's exactly what they are.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到一个使用数据而不是不同函数的结构，你会立刻注意到这是一个隐藏的循环。当涉及到函数调用时，我们并没有注意到这种重复，因为我们没有接受将函数视为数据的训练。但这确实就是它们的本质。
- en: 'Before we remove that similarity, let''s simplify the conditions. I will make
    all conditions functions without parameters, through the magic of partial function
    application:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们消除相似之前，让我们简化条件。我将通过部分函数应用使所有条件成为无参数函数：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Our next step is to remove the variation between the four different conditions,
    and replace the similarity with a loop. We just need to have a list of pairs of
    *(lambda, result)* and use a higher-level function such as `find_if` to do the
    loop for us:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是消除四种不同条件之间的差异，并用循环替换相似之处。我们只需要有一对*(lambda, result)*的列表，并使用`find_if`这样的高级函数来为我们执行循环：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The last piece of the puzzle is ensuring that our code returns `Draw` if nothing
    else works. Since `find_if` returns the first element that fits the rule, we just
    need to have `Draw` at the end, associated with a function that always returns
    `true`. I named this function, appropriately, `True`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一块拼图是确保我们的代码在没有其他情况适用时返回`Draw`。由于`find_if`返回符合规则的第一个元素，我们只需要在最后放上`Draw`，并与一个总是返回`true`的函数关联。我将这个函数恰如其分地命名为`True`。
- en: 'How''s this code working for us? Well, it has a few advantages. First, we can
    easily add a new pair of conditions and results, for example, if we ever get the
    request to implement variations of Tic-Tac-Toe in multiple dimensions or with
    more players. Second, the code is shorter. Third, with a few changes, we obtain
    a simple, albeit quite general, rule engine:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码对我们有什么作用呢？首先，我们可以轻松地添加新的条件和结果对，例如，如果我们曾经收到要在多个维度或更多玩家的情况下实现井字棋变体的请求。其次，代码更短。第三，通过一些改变，我们得到了一个简单但相当通用的规则引擎：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The only particular code in the previous sample is the list of rules. Everything
    else is quite general and can be reused on multiple problems.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面示例中唯一特殊的代码是规则列表。其他所有内容都是相当通用的，可以在多个问题上重复使用。
- en: As usual, there's a price to pay for going to a higher level of abstraction.
    We took the time to name things as clearly as possible, and I believe this code
    is very easy to read. However, it might not be familiar to many people.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，提升抽象级别是需要付出代价的。我们花时间尽可能清晰地命名事物，我相信这段代码非常容易阅读。然而，对许多人来说可能并不熟悉。
- en: Another possible issue is memory usage. The initial version of the code, while
    repeating the same code structure, doesn't need to allocate memory for a list
    of pairs of function and results; however, it's important to measure these things,
    since even the initial code will require some process memory for the extra instructions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的问题是内存使用。尽管初始版本的代码重复了相同的代码结构，但它不需要为函数和结果对的列表分配内存；然而，重要的是要测量这些东西，因为即使初始代码也需要一些额外指令的处理内存。
- en: This example shows us how repeated structures can be turned into loops through
    a very simple code sample. This is just scratching the surface; this pattern is so
    widespread that I'm sure you'll notice it in your code once you start looking.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子向我们展示了如何通过一个非常简单的代码示例将重复的结构转换为循环。这只是皮毛；这种模式是如此普遍，我相信一旦你开始寻找，你会在你的代码中注意到它。
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at different types of code similarities and how we
    can reduce them through various functional programming techniques. From repeated
    parameters that can be replaced with partial application, to chained calls that
    can be turned into functional composition, all the way to the wonderfully complex
    world of structural similarities that can be removed through higher-level functions,
    you are now well armed to notice and reduce similarity in any code base you work
    with.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了不同类型的代码相似之处，以及如何通过各种函数式编程技术来减少它们。从可以用部分应用替换的重复参数，到可以转换为函数组合的链式调用，一直到可以通过更高级别的函数移除的结构相似之处，你现在已经有能力注意并减少任何代码库中的相似之处了。
- en: As you have noticed, we started to discuss code structures and software design.
    This leads us to another core principle of design—high cohesion and low coupling.
    How do we increase cohesion using functions? It turns out that that's where classes
    are very useful and this is what we will discuss in the next chapter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经注意到的，我们开始讨论代码结构和软件设计。这将我们引向设计的另一个核心原则——高内聚和低耦合。我们如何使用函数来增加内聚？原来这正是类非常有用的地方，这也是我们将在下一章讨论的内容。
