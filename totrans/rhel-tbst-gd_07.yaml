- en: Chapter 7. Filesystem Errors and Recovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 5](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 5. Network Troubleshooting"), *Network Troubleshooting*, and [Chapter
    6](part0037_split_000.html#1394Q1-8ae10833f0c4428b9e1482c7fee089b4 "Chapter 6. Diagnosing
    and Correcting Firewall Issues"), *Diagnosing and Correcting Firewall Issues*,
    we used quite a few tools to troubleshoot network connectivity issues due to misconfigured
    routes and firewalls. Network related issues are very common and the two example
    issues are also frequent scenarios. In this chapter, we will be focusing on hardware-related
    issues and start that with troubleshooting filesystem errors.
  prefs: []
  type: TYPE_NORMAL
- en: Much like the other chapters, we will start with a discovered error and troubleshoot
    the issue until we find the cause and solution. Along the way, we will discover
    many of the different commands and logs necessary for troubleshooting filesystem
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: Diagnosing filesystem errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike earlier chapters where end users were reporting the issue to us, this
    time around we have found an issue for ourselves. While performing some daily
    tasks on the database server we attempted to create a database backup and received
    the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This error is interesting because it is not necessarily from the `mysqldump`
    command, but rather from the bash redirect that writes to the `/data/backups/wordpress.sql`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the error it is very specific, the filesystem we were attempting
    to write the backup to, is `Read-only`. What does `Read-only` mean?
  prefs: []
  type: TYPE_NORMAL
- en: Read-only filesystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When defining and mounting filesystems on Linux you have many options, but there
    are two options that define the filesystem's accessibility best. Those two options
    are `rw` for read and write, and **ro** for read-only. When a filesystem is mounted
    with the read and write option, this means that the contents of the filesystem
    can be read and the users with appropriate permissions can write new files/directories
    to the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: When the filesystem is mounted in the read-only mode, it means that while users
    can read the filesystem, new write requests will be denied.
  prefs: []
  type: TYPE_NORMAL
- en: Using the mount command to list mounted filesystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since the error we received specifically states that the filesystem is read-only,
    our next logical step is to look at the filesystems mounted on this server. To
    do this, we will use the `mount` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `mount` command is a very useful command when dealing with filesystems.
    Not only can it be used to display the mounted filesystems (as seen in the preceding
    command), but it can also be used to attach (or mount) and un-attach (unmount)
    filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: A mounted filesystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Calling a filesystem a mounted filesystem is a common way of saying that the
    filesystem is *attached* to the server. With filesystems, they generally have
    two statuses, either they are attached (mounted) and the contents are accessible
    to users, or they are un-attached (unmounted) and inaccessible to the users. Later
    in this chapter, we will cover mounting and unmounting filesystems with the `mount`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mount` command is not the only way to see what filesystems are mounted
    or not mounted. Another way to do this is to simply read the `/proc/mounts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, the contents of the `/proc/mounts` file are extremely close to the
    output of the `mount` command, with the main difference being the two numbered
    columns at the end of each line. To get a better understanding of this file and
    the output of the `mount` command, let''s take a better look at the `/boot` filesystem''s
    entry within `/proc/mounts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `/proc/mounts` file has data in six columns—**device**, **mount point**,
    **filesystem type**, **options**, and two unused columns that exist for backwards
    compatibility. For a better understanding of these values, let's get a better
    understanding of the columns.
  prefs: []
  type: TYPE_NORMAL
- en: The first column `device`, specifies the device to use for the filesystem. In
    the preceding example, the device that the `/boot` filesystem lives on is `/dev/sda1`.
  prefs: []
  type: TYPE_NORMAL
- en: From the name of the device (`sda1`), we can identify a critical piece of information.
    This device is a partition of another device, which we can identify by the fact
    that the device name has a number at the end.
  prefs: []
  type: TYPE_NORMAL
- en: The device, which by the name appears to be a physical drive (assuming it's
    a hard drive) and is named `/dev/sda`; this drive has at least one partition,
    which has a device name of `/dev/sda1`. Whenever a drive has partitions on it,
    the partitions are created as their own device, each device getting assigned a
    number; in this case 1, which means that it is the first partition.
  prefs: []
  type: TYPE_NORMAL
- en: Using fdisk to list available partitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can verify this by looking at the `/dev/sda` device that is using the `fdisk`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `fdisk` command might be familiar because it is a cross-platform command
    used to create disk partitions. It can however also be used to list partitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding command, we used the `–l` (list) flag to list the partitions
    followed by the device we wanted to look at—`/dev/sda`. However, the `fdisk` command
    shows us much more than the partitions available on this drive. It also shows
    us how large the disk is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see this in the first line being printed from the `fdisk` command, according
    to this line our device `/dev/sda` is `42.9 GB` in size. If we look towards the
    bottom of the output, we can also see the partitions created on this disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding list, it appears that `/dev/sda` has two partitions, `/dev/sda1`
    and `/dev/sda2`. Using `fdisk`, we have been able to identify quite a few details
    about this filesystem''s physical device. If we continue to look at the details
    from `/proc/mounts`, we should be able to identify some other very useful information,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The second column *mount point* in the preceding line notates the path that
    this filesystem is mounted to. In this case, the path is `/boot`; `/boot` by itself
    is nothing more than a directory on the `/` (root) filesystem. However, once the
    filesystem that exists on the device `/dev/sda1` is mounted `/boot` is now its
    own filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand this concept, we will use the `mount` and `umount` commands
    to attach and detach the `/boot` filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we perform a simple `ls` command on the `/boot` path, we can see quite a
    few files within this directory. From the `/proc/mounts` file and the `mount`
    command, we know that there is a filesystem attached to `/boot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to un-attach or unmount this filesystem, we can use the `umount` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `umount` command has a pretty simple task, it unmounts mounted filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding commands are examples that unmounting a filesystem can be dangerous.
    In general, you should first verify that the filesystem is not actively being
    accessed before unmounting it.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `/boot` filesystem is now unmounted, what happens when we perform
    our `ls` command?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The path `/boot` is still valid. However, it is now just an empty directory.
    This is due to the fact that the filesystem on `/dev/sda1` is not mounted; therefore,
    any files that existed on that filesystem are not currently accessible on this
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use the `mount` command to remount the filesystem, we will see the files
    reappear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, when the `mount` command is given a path argument, the command
    will attempt to `mount` that filesystem. However, when given no arguments the
    `mount` command will simply display what filesystems are currently mounted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later in this chapter, we will explore using `mount` and how it understands
    where and how filesystems should be mounted; for now, let''s take a look at the
    next column in the `/proc/mounts` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The third column filesystem type denotes the type of filesystem being used.
    In many operating systems, especially Linux, there is often more than one type
    of filesystem that can be used. In the preceding case, our boot filesystem is
    set to `xfs`, which as of Red Hat Enterprise Linux 7, is the new default file
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to `xfs`, older versions of Red Hat defaulted to either the `ext3` or
    `ext4` filesystems. The `ext3/4` filesystems and others are still supported by
    Red Hat, so there could be a number of different filesystem types listed in the
    `/proc/mounts` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `/boot` filesystem, knowing the filesystem type is not immediately
    useful; however, knowing how to look up the underlying type of filesystem might
    be required as we dig deeper into this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The fourth column options shows the options the filesystem has been mounted
    with.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a filesystem is mounted, that filesystem can be given specific options
    in order to change the default behavior of the filesystem. In the preceding example,
    there are quite a few options provided; let''s break down this list to better
    understand what is being specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**inode64**`**: This enables the filesystem to create inode numbers greater
    than 32 bits in length**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****noquota**: This disables disk quotas and enforcement for this filesystem**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**As we can see from the descriptions, these options can greatly change the
    way the filesystem behaves. They are also very important to look at when troubleshooting
    any filesystem issues:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**The last two columns of the `/proc/mounts` output, which are represented
    as `0 0` are actually not used in `/proc/mounts`. These columns are in fact only
    added for backwards capability with `/etc/mtab`, which is a similar file, however
    is not considered up-to-date like `/proc/mounts`.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The difference between these two files is specifically in their usage. The
    `/etc/mtab` file is designed for users or applications to read and utilize where
    the `/proc/mounts` file is used by the kernel itself. For this reason, the `/proc/mounts`
    file is considered the most authoritative version.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Back to troubleshooting**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**If we go back to our issue at hand, we received an error when writing a backup
    to the `/data/backups` directory. Using the `mount` command, we can identify which
    filesystem that directory exists on:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '**Now that we understand the format of the `mount` command better, we can identify
    some key information from the preceding command line. We can see that the device
    for this filesystem is set to (`192.168.33.13:/nfs`), the `mount` point (`path`
    to attach as) is set to (`/data`), the filesystem type of is (`nfs4`), and the
    filesystem has quite a few options set.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**# NFS – Network Filesystem'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the `/data` filesystem we can see that the filesystem type is set
    to `nfs4`. This filesystem type means that the filesystem is a **Network Filesystem**
    (**NFS**).
  prefs: []
  type: TYPE_NORMAL
- en: NFS is a service that allows a server to share an exported directory with other
    remote servers. The `nfs4` filesystem type is a special filesystem that allows
    the remote servers to access this service as if it was a standard filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: The `4` in the filesystem type denotes the version to use, which means the remote
    server is to use Version 4 of the NFS protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, the most popular versions for NFS are versions 3 and 4, with 4 being
    the default for Red Hat Enterprise Linux 6 and 7\. There are quite a few differences
    between version 3 and version 4; however, none of those differences are enough
    to make a difference in our troubleshooting methodology. If you find yourself
    running into issues with NFS Version 3, then you can most likely follow the same
    types of steps that we will follow in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have identified that the filesystem is an NFS filesystem, let''s
    take a look at the options it is mounted with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: From the error we received, the filesystem appears to be `Read-Only`, but if
    we look at the options the first option listed is `rw`. This means that the NFS
    filesystem itself has been mounted as `Read-Write`; which should allow writes
    to this filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test whether the issue is with the path `/data/backups` or the mounted filesystem
    `/data`, we can use the `touch` command to test creating a file within this filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Even the `touch` command is not able to create a new file on this filesystem.
    This is a clear indication that there is a problem with the filesystem; the only
    question is what is causing the issue.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the options this filesystem is mounted with, there is nothing
    that would cause the filesystem to be `Read-Only`; this means that the issue is
    most likely not with how the filesystem is mounted, but with something else.
  prefs: []
  type: TYPE_NORMAL
- en: Since the issue does not appear to be related to how the NFS filesystem is mounted
    and this filesystem is network based, a valid next step would be to verify network
    connectivity to the NFS server.
  prefs: []
  type: TYPE_NORMAL
- en: NFS and network connectivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as with the network troubleshooting, our first test will be to ping the
    NFS server to see if we get a response; but the question is: *What server should
    we ping?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is in the device name that the filesystem is mounted with (`192.168.33.13:/nfs`).
    When mounting an NFS filesystem, the device is in the format of `<nfs server>:<shared
    directory>`. For our example, this means that our `/data` filesystem is mounting
    the `/nfs` directory from the server `192.168.33.13`. To test connectivity, we
    can simply `ping` the IP `192.168.33.13`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: From the `ping` results, it appears that the NFS server is up; but what about
    the NFS service? We can validate connectivity to the NFS service by using the
    `curl` command to `telnet` to the NFS port. First, however, we need to identify
    which port we should connect to.
  prefs: []
  type: TYPE_NORMAL
- en: 'While troubleshooting the database connectivity in earlier chapters, we were
    mostly using well-known ports; since NFS uses several ports, which are a little
    less common; we will need to identify which port to connect to:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to do this is to search for the ports in the `/etc/services`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `/etc/services` file is a static file that is included with many Linux
    distributions. It is used as a lookup to map network ports to a simple human readable
    name. From the preceding output, we can see that the `nfs` name is mapped to TCP
    port `2049`; this is the default port for the NFS service. We can utilize this
    port to test connectivity, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `telnet` seems successful; we can further validate it by using the `netstat`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It seems that connectivity is not an issue, and if our issue is not connectivity
    related, maybe it is in how the NFS share is configured.
  prefs: []
  type: TYPE_NORMAL
- en: We can actually validate the NFS share's settings and network connectivity in
    one command—`showmount`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the showmount command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `showmount` command can be used to display the directories being exported
    via the `-e` (that shows exports) flag. This command works by querying the NFS
    service on the specified host.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our issue, we will be querying the NFS service at `192.168.33.13`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The format of the `showmount` command uses two columns. The first column is
    the directory being shared. The second is the network or hostnames the directory
    is being shared with.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we can see that the directory being shared from this
    host is the `/nfs` directory. This matches the directory listed in the device
    name `192.168.33.13:/nfs` as well.
  prefs: []
  type: TYPE_NORMAL
- en: The network that the `/nfs` directory is being shared with is the `192.166.33.0/24`
    network, which, as we learned in our networking chapter, is short for `192.168.33.0`
    through `192.168.33.255`. We already know from previous troubleshooting that the
    database server we are on is within that network.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see this hasn''t changed since the `netstat` command was executed
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The fourth column of the `netstat` command shows the local IP address being
    used in the `ESTABLISHED` TCP connection. With the preceding output, we can see
    the `192.168.33.12` address is the IP of our database server (as seen in previous
    chapters).
  prefs: []
  type: TYPE_NORMAL
- en: So far everything about this NFS share looks correct, from here we will need
    to log in to the NFS server to continue troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: NFS server configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once logged into the NFS server, the first thing we should check is whether
    or not the NFS service is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Using `systemctl`, we can simply look at the service status; which from the
    preceding output looks normal. This is to be expected since we were able to both
    `telnet` to the NFS service and use the `showmount` command to query it.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring /etc/exports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since the NFS service is running and healthy, the next step is to check the
    configuration that defines which directories are exported and how they are exported;
    the `/etc/exports` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The format of this file is actually similar to the output of the `showmount`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: The first column is the directory to be shared and the second column is the
    network to share it with. However, in this file there is additional information
    after the network definition.
  prefs: []
  type: TYPE_NORMAL
- en: The network/subnet column is followed by a set of parenthesis with various `NFS`
    options within it. These options work very similar to the mount options we saw
    in the `/proc/mounts` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Could these options be the root cause of our `Read-Only` file system? Quite
    possibly. Let''s break down these two options to get a better understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rw`: This allows both reads and writes to be performed on the shared directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no_root_squash`: This disables `root_squash`; `root_squash` is a system that
    maps the root user to an anonymous user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, neither of these options would force the filesystem to be in
    the `Read-Only` mode. In fact, based on the description of these options they
    seem to suggest this NFS share should be in the `Read-Write` mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'One interesting fact has surfaced while performing an `ls` on the `/etc/exports`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `/etc/exports` file has been modified recently. Could it be that our shared
    filesystem is actually shared as `Read-Only` but someone has recently changed
    the `/etc/exports` file to export the filesystem as `Read-Write`.
  prefs: []
  type: TYPE_NORMAL
- en: This scenario is entirely possible, and in fact is actually a common issue with
    NFS. The NFS service is not constantly reading the `/etc/exports` file looking
    for changes. In fact, this file is only read when the service is starting.
  prefs: []
  type: TYPE_NORMAL
- en: Any changes to the `/etc/exports` file will not take effect until after either
    the service is reloaded or the exported filesystems is refreshed using the `exportfs`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the current exports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A very common scenario is where someone makes a change to this file and simply
    forgets to run the commands to refresh the exported filesystems. We can identify
    whether this is the case by using the `exportfs` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When given the `–s` (show current exports) flag, the `exportfs` command will
    simply list the existing shared directories, including the options that the directories
    are shared with.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the preceding output, we can see that this filesystem is shared with
    quite a few options that are not listed in `/etc/exports`. The reason for this
    is because all directories shared through NFS have a default list of options that
    govern how the directory is shared. The options specified in `/etc/exports` are
    essentially used to override the default settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a better understanding of these options, let''s break them down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rw`: This allows both reads and writes to be performed on the shared directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wdelay`: This causes NFS to hold a write request if it suspects another write
    is incoming from another client. This is designed to reduce write conflicts when
    multiple clients are connected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no_root_squash`: This disables `root_squash`, which is a system that maps
    the root user to an anonymous user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no_subtree_check`: This disables `subtree` checking; subtree checking essentially
    ensures that requests to a directory where a subdirectory is also exported will
    honor the subdirectory''s more restrictive policy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sec=sys`: This tells NFS to use the user ID and group ID values for permissions
    and authorization of file access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`secure`: This ensures that NFS only honors requests where the clients port
    is lower than 1024, essentially requiring it to be from a privileged NFS mount.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no_all_squash`: This disables `all_squash`, which is used to force all permissions
    to be mapped to the anonymous user and group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It seems that these options also do not explain the `Read-Only` file system.
    This is an issue that seems to be very tricky to troubleshoot, especially when
    the NFS service seems to be configured correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Testing NFS from another client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the NFS server's configuration seems correct and the client (database
    server) also appears correct, we will need to narrow down whether the issue is
    at the client side or the server side.
  prefs: []
  type: TYPE_NORMAL
- en: One way we can do this is by mounting the filesystem on another client and attempting
    the same write request. From the configuration, it appears we simply need another
    server in the `192.168.33.0/24` network to perform this test. Perhaps our blog
    server from earlier chapters is a good client to use?
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some environments, the answer to this question would be `no`, as a web server
    is often considered less secure than a database server. However, since this is
    simply a test environment for this book, it will be OK.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have logged into the blog server, we can test whether or not we can
    even see the mount with the `showmount` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This answers two questions. The first is whether the NFS client software is
    installed; since the `showmount` command is present, the answer is likely `yes`.
  prefs: []
  type: TYPE_NORMAL
- en: The second is whether the NFS service is accessible from the blog server, which
    also appears to be yes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the mount, we will simply use the `mount` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the `mount` command to mount a filesystem the syntax is: `mount –t <filesystem
    type> <device> <mount point>`. In the example above we simply mounted the `192.168.33.13:/nfs`
    device to the `/mnt` directory with the filesystem type as `nfs`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While running the command, we did not receive any errors but to ensure that
    the filesystem is mounted properly, we can use the `mount` command just as we
    did before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: From the output of the `mount` command, it appears that the `mount` request
    was successful and in the `Read-Write` mode, which means the `mount` options are
    similar to the options used on the database server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can test the filesystem by attempting to create a file with the `touch`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It appears that the issue is not with the client's configuration, as even our
    new client is having issues writing to this filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a tip, in the preceding example, I mounted the `/nfs` share to `/mnt`. The
    `/mnt` directory is used as a generic mount point and is generally considered
    OK for use. However, it is always a best practice to ensure nothing else is mounted
    to `/mnt` before hand.
  prefs: []
  type: TYPE_NORMAL
- en: Making mounts permanent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, even though we mounted the NFS share with the `mount` command, this
    mounted filesystem is not considered persistent. The next time this system reboots,
    the NFS mount will not be remounted.
  prefs: []
  type: TYPE_NORMAL
- en: That is because as a system boots up, part of the boot process is to read the
    `/etc/fstab` file and `mount` any filesystems defined within it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand how this works, let''s look at the `/etc/fstab` file on
    the database server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The contents of the `/etc/fstab` file are actually very similar to the contents
    of the `/proc/mounts` file. The first column in the `/etc/fstab` file is used
    to specify the device to be mounted, the second column is the `path` or `mount`
    point to mount to, the third column is simply the filesystem type, and the fourth
    column is the options to `mount` the filesystem with.
  prefs: []
  type: TYPE_NORMAL
- en: The last two columns, however, are where these files differ, within the `/etc/fstab`
    file. These last two columns actually have a meaning. Within the `fstab` file,
    the fifth column is used by the `dump` command.
  prefs: []
  type: TYPE_NORMAL
- en: The `dump` command is a simple backup utility which reads the `/etc/fstab` to
    determine which filesystems to backup. Any filesystem with a `0` value set will
    not be in scope for a backup, when the dump utility is executed.
  prefs: []
  type: TYPE_NORMAL
- en: While this utility is not heavily used these days, this column in the `/etc/fstab`
    file is maintained for backwards capability.
  prefs: []
  type: TYPE_NORMAL
- en: The sixth and final column in the `/etc/fstab` file is very relevant to today's
    systems. This column is used to denote the order in which a filesystem check or
    `fsck` is performed during the boot process (generally after a failure).
  prefs: []
  type: TYPE_NORMAL
- en: A filesystem check or `fsck` is a process that runs periodically, checking the
    filesystem for errors and attempts to correct them. This is a process we will
    cover a bit further in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Unmounting the /mnt filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we do not want the NFS shared filesystem to stay mounted on the `/mnt`
    path of the blog server, we will need to unmount the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this in the same way we did with the `/boot` filesystem earlier;
    with the `umount` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: From the blog server, we simply used `umount` followed by the `mount` point
    of `/mnt` to `unmount` the NFS `mount` from the client. Now that we have, we can
    go back to the NFS server to continue troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting the NFS server, again
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we identified that even new clients cannot write to the `/nfs` share,
    we have at this point narrowed down that the issue is likely on the server side
    and not the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, while troubleshooting the NFS server, we checked almost everything
    that there is to check about NFS. We validated that the service is in fact running,
    accessible by the clients, that the data in `/etc/exports` is correct, and that
    the currently exported directories match what is in `/etc/exports`. At this point,
    there is only one place left to check: the `log` files.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the NFS service does not have its own log file like Apache or MariaDB.
    Instead, this service on the RHEL systems utilizes the `syslog` facility; which
    means our logs will be within `/var/log/messages`.
  prefs: []
  type: TYPE_NORMAL
- en: The `messages` log is a very frequently used log file for Red Hat Enterprise
    Linux based Linux distributions. In fact, by default, outside of cron jobs and
    authentication, every syslog message above the info log level is sent to `/var/log/messages`
    on RHEL based systems.
  prefs: []
  type: TYPE_NORMAL
- en: Since the NFS service sends its log messages to the local `syslog` service,
    its messages are also included in the `messages` log.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the NFS log messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if we didn't know that NFS logs were sent to the `/var/log/messages` log
    file? There is a pretty simple trick to identify which log file contains NFS log
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, on Linux systems, all system services have their log files located
    within `/var/log`. Since we know the default location of majority of logs on the
    system, we can simply take a quick look through those files to identify which
    ones might have the NFS log messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `grep` command recursively (`-r`) searches each file for the string "`nfs`"
    and outputs the filename along with a count (`-c`) of the number of lines where
    the string is found.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding output, there are two log files that contain the highest amount
    of instances of the string "`nfs`". The first is the `maillog`, which is the system
    log for e-mail messages; this is not likely related to the NFS service.
  prefs: []
  type: TYPE_NORMAL
- en: The second is the `messages` log file which, as we know, is the system default
    log file.
  prefs: []
  type: TYPE_NORMAL
- en: Even without prior knowledge of a specific system's logging methods, if you
    are familiar with Linux in general and tricks as in the preceding example, you
    can often find which logs contain the data required.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the log file we are looking for, let's take a look through
    the `/var/log/messages` log.
  prefs: []
  type: TYPE_NORMAL
- en: Reading /var/log/messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since this `log` file can be quite large, we will use the `tail` command with
    the `-100` flag, which causes the tail to only display the last `100` lines of
    the specified file. By limiting the output to `100` lines, we should only see
    the most relevant data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Since even `100` lines can be quite tedious to go through, I have truncated
    the output to only the relevant lines. This shows quite a few messages with the
    string "`nfs`"; however, not every one of these are messages from the NFS service.
    Since our NFS server's hostname is set to `nfs`, each log entry from this system
    has the string "`nfs`".
  prefs: []
  type: TYPE_NORMAL
- en: 'However, even with that, we do still see a few messages related to the `NFS`
    service, specifically the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The interesting thing about these log entries is that one of them specifically
    states that the service `rpc.mountd` was not able to open a file due to the filesystem
    being `Read-only`. However, the file it was trying to open `/var/lib/nfs/.xtab.lock`
    is not part of our NFS share.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this filesystem is not part of our NFS, let''s take a quick look at the
    mounted filesystems on this server. We can do this again, with the `mount` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Like the other server there are quite a bit of mounted filesystems, we however
    are not interested in all of them; only a small subset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding three lines are the lines that we should be interested in. These
    three mounted filesystems are persistent filesystems defined for our system. If
    we look at these three persistent filesystems, we can identify some interesting
    information.
  prefs: []
  type: TYPE_NORMAL
- en: The `/` or root filesystem exists on the device `/dev/mapper/md0-root`. This
    filesystem is actually incredibly important to our system, as it appears that
    this server is configured to have the entire operating system installed under
    the root filesystem (`/`), a somewhat common setup. This filesystem includes the
    file in question, the `/var/lib/nfs/.xtab.lock` file.
  prefs: []
  type: TYPE_NORMAL
- en: The `/boot` filesystem exists on the device `/dev/md127` which judging by the
    name is most likely a raided device using Linux's software raid system. The `/boot`
    filesystem is just as important as the root filesystem as `/boot` contains all
    of the necessary files for the server to boot up. Without the `/boot` filesystem,
    this system would most likely not restart and would simply kernel panic on the
    next system restart.
  prefs: []
  type: TYPE_NORMAL
- en: The last filesystem `/nfs` uses the `/dev/mapper/md0-nfs` device. From our earlier
    troubleshooting, we identified this filesystem as an exported filesystem via the
    NFS service.
  prefs: []
  type: TYPE_NORMAL
- en: Read-only filesystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we look back at the error and the output of `mount`, we will start to identify
    some interesting errors on this system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The error is reporting that the filesystem where the .`xtab.lock` file is located
    is `Read-Only`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: From the `mount` command, we can see that the filesystem in question is the
    `/` filesystem. After looking at the options for the `/` or root filesystem we
    can see that this filesystem is in fact mounted with the `ro` option.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, if we look at the three filesystems' options, we can see that `/`,
    `/boot`, and `/nfs` are all mounted with the `ro` option. Where `rw` mounts a
    filesystem as `Read-Write`, the `ro` option mounts a filesystem as `Read-Only`.
    This means that currently, these filesystems cannot be written to by any user.
  prefs: []
  type: TYPE_NORMAL
- en: 'For all three of the defined filesystems to be mounted in the `Read-Only` mode
    is quite an unusual configuration. To see whether this is the desired configuration,
    we can check the `/etc/fstab` file, which is the same file that was used to identify
    persistent filesystems earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: From the contents of the `/etc/fstab` file, it appears that these filesystems
    are not configured to be mounted in the `Read-Only` mode. Rather, these filesystems
    are mounted with "default" options.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Linux, the "default" option for the `xfs` filesystem mounts the filesystem
    in the `Read-Write` mode, not `Read-Only`. We validate this behavior if we look
    at the `/etc/fstab` file on the database server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'On the database server, we can see the `/` or root filesystem also has the
    filesystem options set to "defaults". However, when we use the `mount` command
    to look at the filesystem options, we can see the `rw` option as well as some
    others default options being applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This confirms that the `Read-Only` status of the three persistent filesystems
    is not the desired configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying disk issues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the `/etc/fstab` filesystem is specifically configured so that a filesystem
    is mounted as `Read-Write` and the `mount` command is showing that the filesystem
    is mounted in `Read-Only` mode. This is a clear indication that the filesystems
    in question might have been remounted after they were initially mounted as part
    of the boot process.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed earlier, when a Linux system boots, it reads the `/etc/fstab`
    file and mounts all of the defined filesystems. However, the process of mounting
    filesystems stops there. There is no process that continuously monitors the `/etc/fstab`
    file for changes and mounts or unmounts the modified filesystems, at least not
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: In fact it is quite common to see a newly created filesystem not mounted but
    specified in the `/etc/fstab` file because someone simply forgot to `mount` it
    with the `mount` command after editing the `/etc/fstab` file.
  prefs: []
  type: TYPE_NORMAL
- en: It is not very common however to see a filesystem be mounted as `Read-Only`
    but for the `fstab` to be changed afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact for our scenario, that would not be very easy to accomplish as `/etc/fstab`
    would not be accessible since the `/` filesystem is `Read-Only`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This means that our filesystems being `Read-Only`, was performed after these
    filesystems were mounted initially.
  prefs: []
  type: TYPE_NORMAL
- en: 'The culprit of this state is actually in the log messages that we were looking
    through earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: From the `/var/log/messages` log file, we can actually see that at some point,
    there was an issue with the software raid (`md`) that marked the disk `/dev/sdb1`
    as failed.
  prefs: []
  type: TYPE_NORMAL
- en: By default with Linux if a physical disk drive fails or otherwise becomes unavailable
    to the kernel, the Linux kernel will remount the filesystems that live on that
    physical disk in the `Read-Only` mode. As in the preceding error message, it seems
    likely that the failure of the `sdb1` physical disk and the `md127` raid device
    are the root cause of the filesystems being `Read-Only`.
  prefs: []
  type: TYPE_NORMAL
- en: Since software raid and hardware issues are the topic for the next chapter,
    we will defer troubleshooting the raid and disk issues for [Chapter 8](part0051_split_000.html#1GKCM1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 8. Hardware Troubleshooting"), *Hardware Troubleshooting*.
  prefs: []
  type: TYPE_NORMAL
- en: Recovering the filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know why the filesystem is in the `Read-Only` mode, we can resolve
    it. Forcing the filesystem to go from `Read-Only` to `Read-Write` is actually
    pretty easy. However, because we don't know all of the circumstances around the
    failure that caused the filesystem to go into the `Read-Only` mode, we must be
    careful.
  prefs: []
  type: TYPE_NORMAL
- en: Recovering from filesystem errors can be extremely tricky; if not done properly,
    we could easily find ourselves in a situation where we have corrupted the filesystem
    or in other ways caused partial or even full data loss.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have multiple filesystems in the `Read-Only` mode, we will first start
    with the `/boot` filesystem. The reason we are starting with the `/boot` filesystem
    is because this is technically the best filesystem to experience data loss. Since
    the `/boot` filesystem is only used during the server boot process, we can simply
    ensure that we do not reboot this server before the `/boot` filesystem can be
    recovered.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever possible, it is always best to back up the data before taking any action.
    In the next steps, we are going to assume that the `/boot` filesystem is backed
    up periodically.
  prefs: []
  type: TYPE_NORMAL
- en: Unmounting the filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To recover this filesystem, we will perform three steps. In the first step,
    we will unmount the `/boot` filesystem. By unmounting the filesystem before taking
    any additional steps, we will ensure that the filesystem is not being actively
    written to. This step will greatly reduce the chances of filesystem corruption
    during this recovery process.
  prefs: []
  type: TYPE_NORMAL
- en: However, before unmounting the filesystem, we need to make sure that no applications
    or services are trying to write to the filesystem we are attempting to recover.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure this, we can use the `lsof` command. The `lsof` command is used to
    list open files; we can look through this list to identify if any files in the
    `/boot` filesystem are open.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we simply run `lsof` with no options, it will print all of the current open
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding the `–r` (repeat) flag to `lsof`, we are telling it to run in a repetitive
    mode. We can then pipe this output to the `grep` command where we can filter the
    output for files that are open on the `/boot` filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If the preceding command does not produce any output for a while, it is safe
    to proceed with unmounting the filesystem. If the command does print any open
    files, it is best to find the appropriate processes reading/writing to the filesystem
    and stop them before unmounting the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our example has no open files on the `/boot` filesystem, we can proceed
    with unmounting the `/boot` filesystem. To do this, we will use the `umount` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Luckily the `umount` command finished with no errors. If files were actively
    being written we might have received an error when unmounting. Generally, this
    error consists of a message that states that the **device is busy**. To validate
    that the filesystem was successfully unmounted, we can use the `mount` command
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now that the `/boot` filesystem is unmounted, we can perform the second step
    in our recovery process. We can now check and repair the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem checks with fsck
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linux has a very useful filesystem check command that can be used to check and
    repair filesystems. This command is called `fsck`.
  prefs: []
  type: TYPE_NORMAL
- en: The `fsck` command, however, is not actually just one command. Each filesystem
    type has its own methods of checking consistency and repairing issues. The `fsck`
    command is simply a wrapper that calls the appropriate commands for the filesystem
    in question.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when the `fsck` command is run against an `ext4` filesystem, the
    command being executed is actually `e2fsck`. The `e2fsck` command is used for
    the `ext2` through `ext4` filesystem types.
  prefs: []
  type: TYPE_NORMAL
- en: We can call `e2fsck` in two ways, either directly or indirectly via the `fsck`
    command. In this example, we will use the `fsck` method, as this can be used for
    almost all filesystems supported by Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `fsck` command to simply check the filesystem for consistency, we
    can run it with no flags and specify the disk device to be checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we can see that the filesystem did not identify any
    errors. If it did, we would have been asked if we wanted the `e2fsck` utility
    to correct those errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to, we could have `fsck` automatically repair the issues found
    by passing it the `–y` (yes) flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the `e2fsck` command will attempt to correct any errors it finds.
    Luckily from our example, the errors were able to be corrected; however, there
    are occasions where this is not the case.
  prefs: []
  type: TYPE_NORMAL
- en: The fsck and xfs filesystems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When the `fsck` command is run against an `xfs` filesystem; the outcome is
    actually quite different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `xfs` filesystem is different from the `ext2/3/4` family of filesystems,
    in that a consistency check is performed each time the filesystem is mounted.
    This does not mean that you cannot check and repair the filesystem manually. To
    check an `xfs` filesystem, we can use the `xfs_repair` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: When executed with the `–n` (no modify) flag followed by the device to check,
    the `xfs_repair` utility will only validate the consistency of the filesystem.
    When run in this mode it simply will not attempt to repair the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run `xfs_repair` in a mode that will repair the filesystem simply omit the
    `–n` flag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: From the output of the preceding `xfs_repair` command it seems our `/boot` filesystem
    did not require any repair process.
  prefs: []
  type: TYPE_NORMAL
- en: How do these tools repair a filesystem?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might think that it was quite easy to repair this filesystem with tools
    such as `fsck` and `xfs_repair`. The reason for that is simply due to the design
    of filesystems such as `xfs` and `ext2/3/4`. Both `xfs` and the `ext2/3/4` family
    are journaling filesystems; what this means is that these types of filesystems
    will keep a log of changes being made to filesystem objects (such as files, directories,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: These changes will be kept in this log until the changes are committed to the
    main filesystem. The `xfs_repair` utility simply looks through this log and replays
    the last changes that were not committed to the main filesystem. These filesystem
    journals allow the filesystem to be very resilient in cases such as unexpected
    power loss or a reboot of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, sometimes the filesystem's journal and tools such as `xfs_repair`
    are not enough to correct the situation.
  prefs: []
  type: TYPE_NORMAL
- en: In cases like these, there are some more options such as running the repair
    in a forceful mode. However, these options should always be reserved for a last
    ditch effort as they can sometimes in themselves cause filesystem corruption.
  prefs: []
  type: TYPE_NORMAL
- en: If you do find yourself with a corrupted and unrepairable filesystem, it might
    simply be best to recreate the filesystem and restore backups, if you have backups
    that is...
  prefs: []
  type: TYPE_NORMAL
- en: Mounting the filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the `/boot` filesystem has been checked and repaired, we can simply
    remount it to validate that the data is correct. To do this, we can simply run
    the `mount` command followed by `/boot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: When a filesystem is defined in the `/etc/fstab` file, the `mount` and `umount`
    commands can be called with just the `mount` point. This will cause these two
    commands to `mount` or `unmount` the filesystem according to it's definition within
    the `/etc/fstab` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'It appears from the output of `mount` that our `/boot` filesystem is now `Read-Write`
    rather than `Read-Only`. If we perform an `ls` command, we should also still see
    our original data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: It appears that our recovery steps were a success! Now that we have tested them
    with the `/boot` filesystem, we can move to repairing the `/nfs` filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Repairing the other filesystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The steps to repair the `/nfs` filesystem are actually going to be the same
    as the `/boot` filesystem with only one major difference, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'When checking for open files on the `/nfs` filesystem with `lsof`, we might
    not see the NFS service processes. However, there is a high likelihood that the
    NFS service will attempt to access files within this shared filesystem after the
    `lsof` command is stopped. To prevent this scenario, it is always best (when possible)
    to stop the NFS service when performing any changes to a shared filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the NFS service is stopped, the rest of the steps are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the filesystem has been repaired, we can simply remount it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: After remounting the `/nfs` filesystem, we can see the options show `rw`, which
    means it is `Read-Writable`.
  prefs: []
  type: TYPE_NORMAL
- en: Recovering the / (root) filesystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `/` or `root` filesystem is a little different. It is different because
    it is the top-level filesystem that contains the majority of the Linux packages,
    binaries, and commands. This means that we cannot simply unmount this filesystem
    without losing the tools necessary to remount it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, we will actually use the `mount` command to remount the `/`
    filesystem without having to unmount it first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to tell the `mount` command to unmount and then remount the filesystem,
    we simply need to pass the `–o` (options) flag followed by the option `remount`.
    The `–o` flag allows you to pass filesystem options such as `rw` or `ro` from
    the command line. When we remount the / filesystem, we are simply passing the
    remount filesystem option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: If we use the `mount` command to show the mounted filesystems, we can validate
    that the `/` filesystem has been remounted with `Read-Write` access. Since the
    filesystem type is `xfs`, the remount should have caused the filesystem to perform
    a consistency check and repair. If we have any doubts of the integrity of the
    `/` filesystem, our next step should be to simply reboot the NFS server.
  prefs: []
  type: TYPE_NORMAL
- en: If the server is unable to mount the `/` filesystem, the `xfs_repair` utility
    will be called automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we can see that the NFS server''s filesystems issues have been
    recovered. We should now validate that our NFS client is able to write to the
    NFS share. But before we do that, we should also first restart the NFS service
    we stopped earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the NFS service is started, we can test from the client using the `touch`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: It appears that we have successfully corrected our issue.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, if we noticed that requests to the NFS share were taking a long
    time, It might be necessary to unmount and mount the NFS share on the client side.
    This is a common issue if the NFS client has not identified that the NFS server
    has been restarted.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a rather deep dive into how filesystems are mounted,
    how NFS is configured and what to do in case of filesystems going into the `Read-Only`
    mode. We even took that a step further and manually repaired a filesystem where
    the physical disk device was having issues.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take this same issue further by troubleshooting
    hardware failures. This means looking at logs for hardware messages, troubleshooting
    hard drive RAID sets, and many other hardware-related troubleshooting steps.**
  prefs: []
  type: TYPE_NORMAL
