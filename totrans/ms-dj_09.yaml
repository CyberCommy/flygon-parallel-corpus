- en: Chapter 9. Advanced Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.xhtml "Chapter 4. Models"), *Models*, we presented an introduction
    to Django's database layer-how to define models and how to use the database API
    to create, retrieve, update and delete records. In this chapter, we'll introduce
    you to some more advanced features of this part of Django.
  prefs: []
  type: TYPE_NORMAL
- en: Related objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recall our book models from [Chapter 4](ch04.xhtml "Chapter 4. Models"), *Models*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As we explained in [Chapter 4](ch04.xhtml "Chapter 4. Models"), *Models*, accessing
    the value for a particular field on a database object is as straightforward as
    using an attribute. For example, to determine the title of the book with ID 50,
    we''d do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: But one thing we didn't mention previously is that related objects-fields expressed
    as either a `ForeignKey` or `ManyToManyField`-act slightly differently.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing ForeignKey values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you access a field that''s a `ForeignKey`, you''ll get the related model
    object. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With `ForeignKey` fields, it works the other way, too, but it''s slightly different
    due to the non-symmetrical nature of the relationship. To get a list of books
    for a given publisher, use `publisher.book_set.all()`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Behind the scenes, `book_set` is just a `QuerySet` (as covered in [Chapter
    4](ch04.xhtml "Chapter 4. Models"), *Models*), and it can be filtered and sliced
    like any other `QuerySet`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The attribute name `book_set` is generated by appending the lower case model
    name to `_set`.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing many-to-many values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many-to-many values work like foreign-key values, except we deal with `QuerySet`
    values instead of model instances. For example, here''s how to view the authors
    for a book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It works in reverse, too. To view all of the books for an author, use `author.book_set`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, as with `ForeignKey` fields, the attribute name `book_set` is generated
    by appending the lower case model name to `_set`.
  prefs: []
  type: TYPE_NORMAL
- en: Managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the statement `Book.objects.all()`, `objects` is a special attribute through
    which you query your database. In [Chapter 4](ch04.xhtml "Chapter 4. Models"),
    *Models*, we briefly identified this as the model's manager. Now it's time to
    dive a bit deeper into what managers are and how you can use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, a model''s manager is an object through which Django models perform
    database queries. Each Django model has at least one manager, and you can create
    custom managers in order to customize database access. There are two reasons you
    might want to create a custom manager: to add extra manager methods, and/or to
    modify the initial `QuerySet` the manager returns.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding extra manager methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding extra manager methods is the preferred way to add table-level functionality
    to your models. (For row-level functionality-that is, functions that act on a
    single instance of a model object-use model methods, which are explained later
    in this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's give our `Book` model a manager method `title_count()` that
    takes a keyword and returns the number of books that have a title containing that
    keyword. (This example is slightly contrived, but it demonstrates how managers
    work.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some notes about the code:'
  prefs: []
  type: TYPE_NORMAL
- en: We've created a `BookManager` class that extends `django.db.models.Manager`.
    This has a single method, `title_count()`, which does the calculation. Note that
    the method uses `self.filter()`, where `self` refers to the manager itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've assigned `BookManager()` to the `objects` attribute on the model. This
    has the effect of replacing the default manager for the model, which is called
    `objects` and is automatically created if you don't specify a custom manager.
    We call it `objects` rather than something else, so as to be consistent with automatically
    created managers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this manager in place, we can now do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, this is just an example-if you typed this in at your interactive
    prompt, you will likely get different return values.
  prefs: []
  type: TYPE_NORMAL
- en: Why would we want to add a method such as `title_count()`? To encapsulate commonly
    executed queries so that we don't have to duplicate code.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying initial manager QuerySets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A manager's base `QuerySet` returns all objects in the system. For example,
    `Book.objects.all()` returns all books in the book database. You can override
    a manager's base `QuerySet` by overriding the `Manager.get_queryset()` method.
    `get_queryset()` should return a `QuerySet` with the properties you require.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the following model has two managers-one that returns all objects,
    and one that returns only the books by Roald Dahl.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With this sample model, `Book.objects.all()` will return all books in the database,
    but `Book.dahl_objects.all()` will only return the ones written by Roald Dahl.
    Note that we explicitly set `objects` to a vanilla `Manager` instance, because
    if we hadn''t, the only available manager would be `dahl_objects`. Of course,
    because `get_queryset()` returns a `QuerySet` object, you can use `filter()`,
    `exclude()` and all the other `QuerySet` methods on it. So these statements are
    all legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This example also pointed out another interesting technique: using multiple
    managers on the same model. You can attach as many `Manager()` instances to a
    model as you''d like. This is an easy way to define common filters for your models.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This example allows you to request `Person.men.all()`, `Person.women.all()`,
    and `Person.people.all()`, yielding predictable results. If you use custom `Manager`
    objects, take note that the first `Manager` Django encounters (in the order in
    which they're defined in the model) has a special status. Django interprets this
    first `Manager` defined in a class as the default `Manager`, and several parts
    of Django (though not the admin application) will use that `Manager` exclusively
    for that model.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, it's often a good idea to be careful in your choice of default
    manager, in order to avoid a situation where overriding of `get_queryset()` results
    in an inability to retrieve objects you'd like to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Model methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Define custom methods on a model to add custom row-level functionality to your
    objects. Whereas managers are intended to do table-wide things, model methods
    should act on a particular model instance. This is a valuable technique for keeping
    business logic in one place-the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example is the easiest way to explain this. Here''s a model with a few custom
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The model instance reference in [Appendix A](apa.xhtml "Appendix A. Model Definition
    Reference"), *Model Definition Reference*, has a complete list of methods automatically
    given to each model. You can override most of these (see below) but there are
    a couple that you''ll almost always want to define:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__str__()`: A Python *magic method* that returns a Unicode representation
    of any object. This is what Python and Django will use whenever a model instance
    needs to be coerced and displayed as a plain string. Most notably, this happens
    when you display an object in an interactive console or in the admin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll always want to define this method; the default isn't very helpful at
    all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_absolute_url()`: This tells Django how to calculate the URL for an object.
    Django uses this in its admin interface, and any time it needs to figure out a
    URL for an object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any object that has a URL that uniquely identifies it should define this method.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding predefined model methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There''s another set of model methods that encapsulate a bunch of database
    behavior that you''ll want to customize. In particular, you''ll often want to
    change the way `save()` and `delete()` work. You''re free to override these methods
    (and any other model method) to alter behavior. A classic use-case for overriding
    the built-in methods is if you want something to happen whenever you save an object.
    For example, (see `save()` for documentation of the parameters it accepts):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also prevent saving:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It's important to remember to call the superclass method-that's that `super(Blog,
    self).save(*args, **kwargs)` business-to ensure that the object still gets saved
    into the database. If you forget to call the superclass method, the default behavior
    won't happen and the database won't get touched.
  prefs: []
  type: TYPE_NORMAL
- en: It's also important that you pass through the arguments that can be passed to
    the model method-that's what the `*args, **kwargs` bit does. Django will, from
    time to time, extend the capabilities of built-in model methods, adding new arguments.
    If you use `*args, **kwargs` in your method definitions, you are guaranteed that
    your code will automatically support those arguments when they are added.
  prefs: []
  type: TYPE_NORMAL
- en: Executing raw SQL queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the model query APIs don''t go far enough, you can fall back to writing
    raw SQL. Django gives you two ways of performing raw SQL queries: you can use
    `Manager.raw()` to perform raw queries and return model instances, or you can
    avoid the model layer entirely and execute custom SQL directly.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should be very careful whenever you write raw SQL. Every time you use it,
    you should properly escape any parameters that the user can control by using `params`
    in order to protect against SQL injection attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Performing raw queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `raw()` manager method can be used to perform raw SQL queries that return
    model instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a raw SQL query, executes it, and returns a `django.db.models.query.RawQuerySet`
    instance. This `RawQuerySet` instance can be iterated over just like a normal
    `QuerySet` to provide object instances. This is best illustrated with an example.
    Suppose you have the following model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You could then execute custom SQL like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this example isn't very exciting-it's exactly the same as running
    `Person.objects.all()`. However, `raw()` has a bunch of other options that make
    it very powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Model table names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Where'd the name of the `Person` table come from in the preceding example? By
    default, Django figures out a database table name by joining the model's app label-the
    name you used in `manage.py startapp`-to the model's class name, with an underscore
    between them. In the example we've assumed that the `Person` model lives in an
    app named `myapp`, so its table would be `myapp_person`.
  prefs: []
  type: TYPE_NORMAL
- en: For more details, check out the documentation for the `db_table` option, which
    also lets you manually set the database table name.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No checking is done on the SQL statement that is passed in to `raw()`. Django
    expects that the statement will return a set of rows from the database, but does
    nothing to enforce that. If the query does not return rows, a (possibly cryptic)
    error will result.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping query fields to model fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`raw()` automatically maps fields in the query to fields on the model. The
    order of fields in your query doesn''t matter. In other words, both of the following
    queries work identically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Matching is done by name. This means that you can use SQL''s `AS` clauses to
    map fields in the query to model fields. So if you had some other table that had
    `Person` data in it, you could easily map it into `Person` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as the names match, the model instances will be created correctly.
    Alternatively, you can map fields in the query to model fields using the `translations`
    argument to `raw()`. This is a dictionary mapping names of fields in the query
    to names of fields on the model. For example, the preceding query could also be
    written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Index lookups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`raw()` supports indexing, so if you need only the first result you can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the indexing and slicing are not performed at the database level.
    If you have a large number of `Person` objects in your database, it is more efficient
    to limit the query at the SQL level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Deferring model fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fields may also be left out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Person` objects returned by this query will be deferred model instances
    (see `defer()`). This means that the fields that are omitted from the query will
    be loaded on demand. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: From outward appearances, this looks like the query has retrieved both the first
    name and last name. However, this example actually issued 3 queries. Only the
    first names were retrieved by the raw() query-the last names were both retrieved
    on demand when they were printed.
  prefs: []
  type: TYPE_NORMAL
- en: There is only one field that you can't leave out-the primary key field. Django
    uses the primary key to identify model instances, so it must always be included
    in a raw query. An `InvalidQuery` exception will be raised if you forget to include
    the primary key.
  prefs: []
  type: TYPE_NORMAL
- en: Adding annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also execute queries containing fields that aren''t defined on the
    model. For example, we could use PostgreSQL''s `age()` function to get a list
    of people with their ages calculated by the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Passing parameters into raw()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need to perform parameterized queries, you can pass the `params` argument
    to `raw()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`params` is a list or dictionary of parameters. You''ll use `%s` placeholders
    in the query string for a list, or `%(key)s` placeholders for a dictionary (where
    `key` is replaced by a dictionary key, of course), regardless of your database
    engine. Such placeholders will be replaced with parameters from the `params` argument.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Do not use string formatting on raw queries!**'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s tempting to write the preceding query as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`>>> query = ''SELECT * FROM myapp_person WHERE last_name = %s'' % lname` `Person.objects.raw(query)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Don''t.**'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `params` argument completely protects you from SQL injection attacks,
    a common exploit where attackers inject arbitrary SQL into your database. If you
    use string interpolation, sooner or later you'll fall victim to SQL injection.
    As long as you remember to always use the `params` argument you'll be protected.
  prefs: []
  type: TYPE_NORMAL
- en: Executing custom SQL directly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes even `Manager.raw()` isn''t quite enough: you might need to perform
    queries that don''t map cleanly to models, or directly execute `UPDATE`, `INSERT`,
    or `DELETE` queries. In these cases, you can always access the database directly,
    routing around the model layer entirely. The object `django.db.connection` represents
    the default database connection. To use the database connection, call `connection.cursor()`
    to get a cursor object. Then, call `cursor.execute(sql, [params])` to execute
    the SQL and `cursor.fetchone()` or `cursor.fetchall()` to return the resulting
    rows. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if you want to include literal percent signs in the query, you have
    to double them in the case you are passing parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using more than one database, you can use `django.db.connections`
    to obtain the connection (and cursor) for a specific database. `django.db.connections`
    is a dictionary-like object that allows you to retrieve a specific connection
    using its alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the Python DB API will return results without their field names,
    which means you end up with a `list` of values, rather than a `dict`. At a small
    performance cost, you can return results as a `dict` by using something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of the difference between the two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Connections and cursors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`connection` and `cursor` mostly implement the standard Python DB-API described
    in PEP 249 (for more information visit, [https://www.python.org/dev/peps/pep-0249](https://www.python.org/dev/peps/pep-0249)),
    except when it comes to transaction handling. If you''re not familiar with the
    Python DB-API, note that the SQL statement in `cursor.execute()` uses placeholders,
    "`%s`", rather than adding parameters directly within the SQL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use this technique, the underlying database library will automatically
    escape your parameters as necessary. Also note that Django expects the "`%s`"
    placeholder, not the `?` placeholder, which is used by the SQLite Python bindings.
    This is for the sake of consistency and sanity. Using a cursor as a context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Adding extra Manager methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding extra `Manager` methods is the preferred way to add table-level functionality
    to your models. (For row-level functionality-that is, functions that act on a
    single instance of a model object-use Model methods, not custom `Manager` methods.)
    A custom `Manager` method can return anything you want. It doesn't have to return
    a `QuerySet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this custom `Manager` offers a method `with_counts()`, which returns
    a list of all `OpinionPoll` objects, each with an extra `num_responses` attribute
    that is the result of an aggregate query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: With this example, you'd use `OpinionPoll.objects.with_counts()` to return that
    list of `OpinionPoll` objects with `num_responses` attributes. Another thing to
    note about this example is that `Manager` methods can access `self.model` to get
    the model class to which they're attached.
  prefs: []
  type: TYPE_NORMAL
- en: What's next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next chapter, we'll show you Django's generic views framework, which
    lets you save time in building websites that follow common pattern
  prefs: []
  type: TYPE_NORMAL
