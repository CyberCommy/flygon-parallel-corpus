- en: Penetration Testing of EC2 Instances using Kali Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](12c0f5b9-216d-4b5e-bae0-c6960ed5087d.xhtml), *Exploitation on
    the Cloud using Kali Linux*, we learned how to perform a penetration test on a
    vulnerable machine running on AWS. This chapter aims to help the reader set up
    a vulnerable lab for advanced penetration tests and more real-life scenarios.
    This lab will give an insight into common security misconfigurations that DevOps
    engineers make in the **continuous integration and continuous delivery** (**CI/CD**) pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focuses on setting up a vulnerable Jenkins installation on a Linux
    **virtual machine** (**VM**) and then performing a penetration test using the
    techniques that we learned in [Chapter 3](12c0f5b9-216d-4b5e-bae0-c6960ed5087d.xhtml),
    *Exploitation on the Cloud using Kali Linux*. Also, we will take a look at some
    more techniques for scanning and information gathering to aid our penetration
    testing. And finally, once we have compromised our target, we will learn techniques
    to pivot and gain access to internal networks in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a vulnerable Jenkins server in our virtual lab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring and securing the virtual lab to prevent unintended access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing a penetration test on the vulnerable machine and learning more scanning
    techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compromising our target and then performing post-exploitation activities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following tools will be used in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Nexpose (needs manual installation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nmap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metasploit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing a vulnerable service on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jenkins is a very important component of the CI/CD pipeline in a DevOps environment
    and mainly works as an automation server. The primary task of Jenkins is to provide
    continuous integration and facilitate continuous delivery in the software development
    process. Jenkins can be integrated with version management systems such as GitHub.
    In a typical scenario, Jenkins would fetch code uploaded to GitHub, build it,
    and then deploy it in a production environment. To learn more about Jenkins, see [https://www.cloudbees.com/jenkins/about.](https://www.cloudbees.com/jenkins/about)
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins offers options to provide custom build commands and arguments within
    its build console. These commands are sent directly to the shell of the **operating
    system** (**OS**). In such a scenario, we can inject malicious code into the build
    commands to compromise the server running Jenkins, getting access to the target
    network.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by launching a Windows Server 2008 instance (you may choose any
    tier; however, the free tier should be enough). For this tutorial, the default
    storage would be enough. Let the EC2 instance spin up.
  prefs: []
  type: TYPE_NORMAL
- en: We will be configuring the instance to be vulnerable. Hence, in the incoming/outgoing
    rules section, ensure only port `3389` is open to the external network. Also,
    in order to ensure our Kali machine is able to access the Jenkins server, allow
    incoming connections from your Kali machine's IP and nowhere else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your firewall rules for the Jenkins machine should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3fba5ef-db5a-4a09-9e2d-4e03f2032ec4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Firewall rules for the Jenkins machine
  prefs: []
  type: TYPE_NORMAL
- en: Here, All traffic is allowed only from the security group of the Kali machine.
    This is just a safety measure to ensure no one else can access our vulnerable
    Jenkins machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the instance is up, it is time to set up a vulnerable Jenkins service
    on our target machine. RDP into the machine you just created and follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the Jenkins installation package from [http://mirrors.jenkins.io/windows/latest](http://mirrors.jenkins.io/windows/latest):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Simply double-click on the Jenkins installation file. Follow the onscreen instructions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3211c65f-99ca-4401-9c26-9f854a7581cc.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Installing Jenkins
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep the install location default and click Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/903c6b6e-5f38-46b9-a6ff-fcf65c79b0fe.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Destination folder
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, click on Install:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d2db135d-b7c0-4e50-8a51-85f43c21968b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once your installation finishes, the browser will open automatically and prompt
    you to configure the Jenkins installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/badf4e62-5872-4f66-87b1-873d456aafd3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: During the installation, the Jenkins installer creates an initial 32-character
    long alphanumeric password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `initialAdminPassword` file, located at `C:\Program Files (x86)\Jenkins\secrets\`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/24b756d0-05e2-48f2-aa2a-fbb7d65dc34a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Copy the password inside the file, paste it into the Administrator password
    field, and click Continue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e3d93c27-e6cf-4339-8f78-3282cd4b7529.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the next screen, the setup wizard will ask you whether you want to Install
    suggested plugins or select specific plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Install suggested plugins box and the installation process will
    start immediately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ccc0df8f-2da3-4d36-b5af-3385cac7ae17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once the plugins are installed, you will be prompted to set up the first `admin`
    user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it a vulnerable instance, we are setting up the account with the username
    `admin` and the password also `admin`. Fill out all the other required information
    and click on Save and Continue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5c9aa1b1-51e7-4a05-8925-5a5add2ac906.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want our Jenkins service to be available on the `Local Area Connection`interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the IP address of your Windows Server 2008 EC2 instance using the `ipconfig`
    command in Command Prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ccb0b2b4-4f74-40c5-aa77-7688ee805bad.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note the IPv4 address and fill in the IP on the Jenkins configuration page
    while configuring the URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bd5dcb78-9dfe-41e7-b946-2ee7eaf41c18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on Save and Finish and then on start using Jenkins. At this point, you've
    successfully installed Jenkins on your system. You will be redirected to the Jenkins
    dashboard after login.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To test if the Jenkins login is reachable from the Kali machine, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an SSH tunnel to the Kali machine using PuTTY
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Port-forward local port `8080` to the Jenkins machine''s port `8080`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3c7f5fce-e92f-4759-ae85-b655ee5d4f9a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Open a browser and point to `http://localhost:8080`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll be presented with the Jenkins login page. This means our Jenkins machine
    is accessible from the Kali machine.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a target machine behind the vulnerable Jenkins machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to simulate a machine that is inside an internal network or in another
    subnet, we'll set up an Ubuntu machine and make it only accessible from the Jenkins
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to visualise what our network should look like in the end, refer to
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2837350a-c2c7-4ffa-baf5-5565c56051d9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have already set up our **AWS Jenkins Machine**; now, we only need to set
    up the internal machine and isolate it from the **AWS Kali Machine**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Ubuntu EC2 instance
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Security Groups settings, edit the inbound rules and only allow all traffic
    from the security ID of the Jenkins machine
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure the SSH port is accessible to all so that you can log in to the instance
    if required:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e621f0e6-d5a7-40ad-954b-79250dadd46b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, our network has been set up. The network looks exactly as we had visualized.
    In the next section, we will install Nexpose for vulnerability scanning.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Nexpose vulnerability scanner on our Kali machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3,](12c0f5b9-216d-4b5e-bae0-c6960ed5087d.xhtml) *Exploitation on
    the Cloud using Kali Linux*, we saw how to set up Nessus on our Kali instance
    remotely. Setting up Nexpose remotely is the same. Why do we need Nexpose in addition
    to Nessus? Automated vulnerability scanners identify vulnerabilities by matching
    service version numbers and OS signatures. However, this may sometime lead to
    false positives, or worse, false negatives. In order to double check and get a
    more comprehensive vulnerability assessment result, it is always a good idea to
    use more than one vulnerability scanner:'
  prefs: []
  type: TYPE_NORMAL
- en: Start off by visiting [https://www.rapi](https://www.rapid7.com/products/insightvm/download/)[d7.com/products/insightvm/download/](https://www.rapid7.com/products/insightvm/download/)[ and
    sign up for a license. The license will be sent to the email address that you
    provide.](https://www.rapid7.com/products/insightvm/download/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Nexpose installer can be downloaded from [https://www.rapid7.com/products/insightvm/download/thank-you/](https://www.rapid7.com/products/insightvm/download/thank-you/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will be downloading the Linux 64-bit installer. You can either download
    it to your machine and then transfer it via SCP, as we did in [Chapter 3](12c0f5b9-216d-4b5e-bae0-c6960ed5087d.xhtml),
    *Exploitation on the Cloud using Kali Linux*, or you can simply do a `wget` from
    the Kali instance''s Terminal, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The file we received is a POSIX shell script executable. We need to give it
    execute permissions and then run it. Simply run the following commands as `sudo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Follow the instructions on the screen. When prompted for which components to
    install, make sure you select Security Console with local Scan Engine [1, Enter]. Let
    the rest of the configurations be left to default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter your details when prompted by the installer and ensure you set up credentials
    for your account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb7a635b-cad7-4f26-98dc-aaeb7ebd60e1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, in order to be able to login to the Security Console, we need to create
    a profile with a username and password. When prompted on the Terminal, enter a
    username and password. With that, the installation will be complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3304992f-e158-4010-bc79-0c1c70c1044c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can either choose to initialize and start the service right after installation.
    Or you can do it manually, later on, with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once the installation is finished, set up an SSH port forward from your local
    port `3780` to port `3780` on the Kali machine and point your browser to port
    `localhost:3780`. You will see the login page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in and then enter the license key on the next page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8680186-0c9a-4c2d-a01b-793806a8197e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once it has been activated, we can proceed with our scanning.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning and reconnaissance using Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at scanning subnets, and performing recon of a
    network using Nmap. Nmap is the Swiss army knife of recon, discovery, and identification
    of hosts and services in a network. Before we go in and run scans, let's take
    a look at how Nmap works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ping sweeps are very handy when it comes to discovering live hosts in a network.
    This type of scan involves sending an **ICMP ECHO** **Request** to each host in
    the network and then identifying which ones are alive based on the responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06e01d2a-c079-4159-8aa1-dcdc9a045a21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the diagram, we can see that some hosts responded with an **ICMP ECHO Reply**,
    whereas some did not. Based on which hosts replied, we can identify which hosts
    are alive.
  prefs: []
  type: TYPE_NORMAL
- en: In a ping sweep scan, we provide Nmap with a network range, typically, a network
    address and its subnet in CIDR form. Our AWS machines are hosted in the default
    subnet of AWS. The subnet is designated as `172.31.0.0/20`. This means the network
    address is `172.31.0.0` and `20` is the CIDR value. In other words, the network's
    subnet mask is `255.255.255.240` and can hold a total of `4094` IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and perform a ping sweep inside our network. In order to do
    so, we will use the `-sn` flag of `nmap`. The `-sn` flag instructs `nmap` to perform
    a ping scan and the `172.31.0.0/20` input tells `nmap` that it is a network range.
    SSH into the Kali machine and issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6dec2127-d7e7-404f-bbd8-d7998dec0f32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From the output, we can see `nmap` has identified five hosts that are alive.
    Not including the `172.31.0.1` and the `172.31.0.2` addresses, we can see there
    are three hosts in the network that are alive: our Kali machine, the vulnerable
    Windows machine, and the Ubuntu machine.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll learn how to scan for open ports and identify services on a particular
    host.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying and fingerprinting open ports and services using Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuing from the previous section, we will now scan a host for open ports
    and then try to identify services running on our target. For this exercise, we
    will be using the Nmap **SYN** scan `-sS` flag. This is the default and most popularly-used
    scanning technique. Why? It's because the scan is quick and can be performed without
    any hampering by the firewall. The scan is also stealthy as it does not complete
    the TCP handshake. The scan can produce distinct and accurate results between
    open, closed, and filtered ports. So how does this scan work? Let's take a look.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **SYN** scan uses a half-open TCP connection to determine whether the port
    is open or closed. The **SYN** scan process can be visualized by the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/203ec61b-2fb9-4bc8-922d-8e67268f5c17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each port scan starts with Nmap sending a **SYN** packet to the designated port.
    If the port is open, the target would respond with a **SYN-ACK** packet as a response.
    Nmap would then flag the port as open and then immediately close the connection
    by sending an **RST** packet.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of a closed port, when Nmap sends the **SYN** packet, the target
    responds with an **RST** packet; Nmap would then flag the port as closed as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8b5719c-08a5-4578-bfdc-6a895649fbdc.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When Nmap sends a **SYN** packet to a port and does not get any response, it
    performs a retry. If there is still no response, the port is then flagged as filtered;
    that is, it''s protected by a firewall. Another case where the port is marked
    filtered, is if Nmap receives an ICMP unreachable error, instead of no response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57efa254-12af-467c-875b-77774c41ca71.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start by making a simple `nmap` scan on the Jenkins machine. Issue the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/0535829c-28c5-47d4-afbc-7785ab835244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, we are presented with a list of ports that `nmap` found open.
    However, we have only scanned the default list of ports. This leaves out a number
    of ports that have not been checked. It is crucial that all open ports are identified,
    so let's see what other ports are open.
  prefs: []
  type: TYPE_NORMAL
- en: 'Issue the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`-T4` is used for multiple threads so as to speed things up a little. The `-p-` flag
    tells `nmap` to scan all `65535` ports. You can optionally add the `-v` flag to
    make the output more verbose and print out more information about the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83e34671-2a97-4a72-a178-d2aa2487de1a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, we did miss out one open port in our earlier scan, port `5985/tcp`.
    This demonstrates why it is important to scan all of the `65535` ports to look
    for open ports.
  prefs: []
  type: TYPE_NORMAL
- en: Our next step is to identify which services are running on these open ports.
    So how does Nmap identify what services are running on these ports? Nmap performs
    a full TCP handshake and then waits for the service running on the port to return
    its service banner. Nmap has its own database of probes to query services and
    match the responses to parse which service is running. Nmap will then try to identify
    the protocol, the service, and the underlying OS, based on the information received.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram explains how the handshake and data exchange happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a7c4358-9eac-41f3-9edd-c6f9ff82697d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to identify all the services running on these ports. Issue
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this command, we specified that ports `135`, `139`, `445`, `3389`, `5985`,
    `8080`, and `49154` are to be scanned, since they are the only ones open. We can
    specify any particular port or range of ports that are to be scanned using the
    `-p` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89d0b381-7d8b-45e6-a9be-db7ea3289b23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Nmap prints out a bunch of information from the scan result. We can see all
    the open ports have been scanned for running services. Out of these, we are interested
    in 2 ports. Notice port `445/tcp`—Nmap has identified the service as SMB, as well
    as identified that the target machine is a server running either Windows Server
    2008 R2 or 2012\. This is paramount in order to determine what OS our target is
    running, and hence, plan our next steps accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The OS can also be determined by using the `-O` flag. Nmap can identify the
    OS either by the response received from services, by using CPE fingerprint, or
    by analyzing network packets to identify the target OS.
  prefs: []
  type: TYPE_NORMAL
- en: Performing an automated vulnerability assessment using Nexpose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous *Setting up Nexpose Vulnerability Scanner on our Kali Machine* section,we
    learned how we can set up the Nexpose scanner on our Kali attacker machine. In
    this section, we will take a look at how we can use Nexpose to perform automated
    vulnerability scans on a target machine.
  prefs: []
  type: TYPE_NORMAL
- en: But first, how does Nexpose identify vulnerabilities in a target?
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is very similar to what Nmap does during service discovery. However,
    Nexpose works on a much bigger scale than just identifying the service running
    on a specific port. The entire process can be summarized in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Host discovery**: Nexpose sends out ICMP packets to identify if a host is
    alive or not. Based on the response, targets are marked alive.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Port scanning**: Once a host is confirmed as alive, Nexpose sends out a flood
    of TCP packets to identify open ports that are listening on TCP. Simultaneously,
    it sends out UDP traffic to identify ports that are listening on UDP only. Nexpose
    can either send traffic to all ports, or to a list of ports predefined in the
    scan template. Scan responses and network packets are analyzed to identify the
    type of OS running on the target, as well.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Service discovery**: Nexpose then interacts with the open ports on TCP as
    well as UDP to identify the running services.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**OS fingerprinting**: Data from both port and service scans are analyzed to
    identify the OS of the target system. This is not always very accurate and so
    Nexpose uses a scoring system to represent how certain the scan results are.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Vulnerability checks**: Finally, the identified services are scanned for
    unconfirmed and confirmed vulnerabilities. To check for any unconfirmed vulnerability,
    Nexpose identifies the patch and version from the service banner. This information
    is then matched for any known vulnerabilities that may affect that particular
    version of the software. For example, if Nexpose finds Apache HTTP 2.4.1 is running
    on port 80 of a target, Apache will take this information and cross-reference
    its vulnerability database to identify if there are any known vulnerabilities
    for version 2.4.1\. Based on that, it will come up with a list of **common vulnerabilities
    and exposures** (**CVEs**) that are assigned to that particular vulnerability.
    However, these are unconfirmed and therefore need to be tested manually to confirm
    if the vulnerability exists. Confirmed vulnerabilities, on the other hand, would
    be something similar to some software shipping with a default password. Nexpose
    would then check if the software has been left running on that default password,
    attempt to log in, and only report it as a vulnerability if it succeeds in the
    login.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Brute force attacks**: Nexpose''s scan templates are by default set to test
    services such as SSH, Telnet, and FTP for default username and password combinations
    such as `''admin'':''admin''` or maybe `''cisco'':''cisco''`. Any such finding
    is added to the report.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Policy check**: As an added bonus, Nexpose checks the configurations of target
    machines to verify whether they are in line with baselines such as PCI DSS, HIPAA,
    and so on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Report**: Finally, all the findings are put into a report and displayed on
    the screen.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To summarise the entire process, here is a waterfall model of the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89a0bc79-a909-45f2-8139-1f8123d64951.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Nexpose can optionally be configured to perform web scans, discover web services,
    check for vulnerabilities such as SQLi and XSS, and perform web spidering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start our scanning of the target server:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an SSH tunnel to your Kali machine with local port `3780` forwarded to
    port `3780` on the Kali machine
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the Nexpose service isn''t running, you can start it by issuing the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Point your browser to `https://localhost:3780`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the initialization is complete, we''re welcomed by the Nexpose home screen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we need to click on Create New Site to start a new scan on the Jenkins
    target that we set up earlier. Give the site any name you want:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5354f206-9cb1-4153-b9e0-7b23e71e92b4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now add your target IP address. The target IP addresses can be a range of IPs,
    individual IPs separated by a comma, or an entire subnet with its CIDR value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/343efe13-5957-4a78-9c49-41b63e0475b4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Set scan type to Exhaustive. There are a number of scan types available. We
    are using the Exhaustive scan so that Nexpose checks all ports to find any open
    ports, both TCP and UDP. Each individual scan type can be used for a given use
    case. **Discovery Scan**, for example, can be used to only discover hosts in a
    network, whereas **HIPAA ****compliance** will only check configuration and policies
    of a target to see if they align with the HIPAA baseline. Start the scan and wait
    for it to finish:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/92ce890b-87b4-4ebe-8552-6cef0aa09c61.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As with Nessus in [Chapter 3](12c0f5b9-216d-4b5e-bae0-c6960ed5087d.xhtml),
    *Exploitation on the Cloud using Kali Linux*, Nexpose comes up with a bunch of
    information, including the services running on our target:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71c10889-bd77-4378-9eca-cb6e40ac865e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also see a few vulnerabilities it has identified:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68ce9363-f512-4ed3-9975-2268fd0500db.png)'
  prefs: []
  type: TYPE_IMG
- en: It has, however, failed to detect our vulnerable Jenkins service. Typically,
    a Jenkins service would have to be brute-forced to find a valid set of credentials.
    However, we have taken the liberty of assuming that we already have the login
    credentials. In the next section, we'll see how we can exploit such a vulnerable
    service and own the target server.
  prefs: []
  type: TYPE_NORMAL
- en: Using Metasploit for automated exploitation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this demonstration, we will use Metasploit to exploit the Jenkins server
    and get a meterpreter shell on it. Jenkins has its own script console where a
    user can type in and run arbitrary code. This is dangerous if the user's credentials
    are stolen, as anyone can then run arbitrary code using the script console. The
    Metasploit module we will be using, takes advantage of this and attempts to run
    code that would create a connection to the remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how the exploitation is done:'
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH into the Kali machine and load the Metasploit framework by issuing the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will search Metasploit for any exploits related to Jenkins:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fa513aa-0421-4b58-9913-1d1737280445.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are presented with a number of modules that are related to Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `jenkins_script_console` exploit in this case. Issue the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s set up the exploit and configure our target server. Issue the following
    commands, one by one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `target 0` indicates this is a Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see a list of all the payloads available, issue the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A list of all the payloads will be listed for our perusal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24bf09e8-22df-4bfd-8210-d987c81d7698.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll use a reverse TCP payload for this exploit. Since our Windows machine
    is 64 bit, we''ll choose the 64-bit payload to be delivered. Following that, set
    your `LHOST` to your Kali IP address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is all done, you can issue the `show options` command to check if
    all required data have been filled in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f1d1528-907e-4aef-bf6d-1e863d609eb4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, simply run the exploit. You will drop into a meterpreter shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/68a6af0b-7820-4675-84b3-925576ae7ab9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have successfully gained shell access to our target machine. In the next
    section, we will see how to perform privilege escalation and pivoting, as well
    as make our backdoor persistent.
  prefs: []
  type: TYPE_NORMAL
- en: Using Meterpreter for privilege escalation, pivoting, and persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now comes the second phase of our exercise. Once we have the meterpreter shell,
    we will attempt to perform privilege escalation and get the highest possible privilege
    on this target server.
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, let''s learn more about our target server. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b081a36a-ff9e-4f4e-9e7e-3ecf6e12f41e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are presented with a bunch of information, such as which version of Windows
    this machine is running, the domain, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it is time to perform privilege escalation, issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If successful, you should typically get a response such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This means our privilege escalation was successful. To verify that, we can
    issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are the highest privileged user, we should get a response of `Server
    username: NT AUTHORITY\SYSTEM`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have completely owned the server, let''s start looking for machines
    on the internal network. For this, we will be pivoting our meterpreter session
    and creating a bridge to the internal network from our Kali Machine:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by backgrounding your meterpreter shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the route of the `target` and `session` IDs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, to verify we have pivoted, we will try to perform a port scan on the
    hidden Ubuntu machine using Metasploit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f53dd1f8-1773-4cc4-9dfd-50122717f12e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the scan result, we can see there are a number of ports open. This means
    we have successfully pivoted our compromised machine. We can conclude so, since
    only port `22` (SSH) had been made public; a scan from any other machine would
    only show port `22` open. Once the pivoting is successful, we can perform a plethora
    of attacks inside the internal network through our compromised Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now comes the final leg of this exercise—how do we ensure we have persistent
    access to our compromised machine? We can do so using post-exploitation modules.
    First, we need to create a malicious `.exe` file that will connect back to our
    Kali machine. To that end, we will use another tool from the Metasploit suite
    called `msfvenom`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Background the meterpreter session if you are inside it, and issue the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Using `msfvenom`, we have created an `exe` file that now needs to be transferred
    to the victim machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back into the meterpreter session and issue the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ef86d02-f685-4f04-a6c6-74888a38a4d1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s check whether our persistence is working. To verify this, from within
    the meterpreter session, reboot the target server and exit the meterpreter session.
    Issue the following command from the meterpreter session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Exit the meterpreter session by running the `exit` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we set up Metasploit to listen for incoming connections. Issue the following
    commands, one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We get a new incoming connection from our target server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed93de70-06b1-4c42-a553-fb803690bd74.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Thus, we have successfully created a backdoor to our compromised server and
    created persistent access. This concludes our exercise. This persistent access
    can now be used for lateral movement, and allows us to compromise other machines
    in the network.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter walked you through how to set up a vulnerable EC2 environment,
    simulate a restricted network, and then perform a penetration test on it. We learned
    how a Jenkins server can be configured in a vulnerable way. Subsequently, we learned
    how to set up the Nexpose vulnerability scanner and then performed a vulnerability
    scan on our vulnerable Jenkins server. Further, we learned how to perform automated
    exploitation of Jenkins using Metasploit and use a meterpreter payload to pivot
    a host and perform lateral movement inside a restricted network.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of the fifth chapter. In the next chapter, we will
    learn about EBS volumes, disk encryption, and volume snapshots. Further, we will
    learn how to perform for forensic analysis and recover lost data from an EBS volume.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/networking-and-servers/mastering-metasploit](https://www.packtpub.com/networking-and-servers/mastering-metasploit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://nexpose.help.rapid7.com/docs/security-console-quick-start-guide](https://nexpose.help.rapid7.com/docs/security-console-quick-start-guide)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://jenkins.io/doc/tutorials/](https://jenkins.io/doc/tutorials/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
