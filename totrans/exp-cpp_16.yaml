- en: Graphical User Interface with Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ doesn't provide **Graphical User Interface** (**GUI**) programming out of
    the box. First, we should understand that a GUI is strongly tied to a specific
    **Operating System**(**OS**). You can program GUI applications in Windows using
    the Windows API, or in Linux using the Linux-specific API, and so on. Each OS
    has its own specific forms of Windows and GUI components.
  prefs: []
  type: TYPE_NORMAL
- en: We touched on the different platforms and their differences in [Chapter 1](2297d785-7242-4149-8b31-f9af1fcdd833.xhtml),
    *Building C++ Applications*. When discussing GUI programming, the difference between
    platforms is even more daunting. Cross-platform development had become a big pain
    in GUI developer's lives. They had to focus on a specific OS. Implementing the
    same application for other platforms took almost the same amount of work again.
    That's an unreasonably huge waste of time and resources. Languages such as *Java*
    provide a smart model of running applications in the virtual environment. This
    allows developers to focus on one language and one project since the environment
    takes care of running the application on different platforms. One of the main
    disadvantages of this approach is forcing the user to install a virtual machine
    and the slow execution time compared to platform-specific applications.
  prefs: []
  type: TYPE_NORMAL
- en: To solve these problems, the Qt framework was created. In this chapter, we'll
    find out how the Qt framework supports cross-platform GUI application development.
    To do this, you will need to become familiar with Qt and its key features. This
    will allow you to develop GUI applications using your favorite programming language
    – C++. We will start by understanding Qt's approach to GUI development, and then
    we will cover its concepts and features, such as signals and slots, and Model/View
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentals of cross-platform GUI programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt core components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Qt widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a network application using Qt Network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to install the latest Qt framework to run the examples in this
    chapter. We suggest using Qt Creator as the IDE for your projects. To download
    Qt, along with the corresponding tools, visit the [qt.io](https://www.qt.io/)
    website and choose the open source version of the framework. The code for this
    chapter could be found at: [https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Understanding cross-platform GUI programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each OS has its own API. It relates to the GUI in particular. When companies
    plan to design, implement, and ship desktop applications, they should decide what
    platform to focus on. A team of developers working on one platform will spend
    almost the same amount of time writing the same application for the other platform.
    The biggest reason for this is the different approaches and APIs provided by OS.
    The complexity of the API may also play a big role in implementing applications
    on time. For example, the following snippet from the official documentation shows
    how to create a button in Windows using C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tackling Windows GUI programming requires you to work with `HWND`, `HINSTACNCE`,
    and many other weirdly named and confusing components.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Framework made a drastic improvement to Windows GUI programming. If you
    want to support OS other than Windows, you have to think twice before using .NET
    Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, to support multiple OS, you still have to dive into APIs to implement
    the same application to cover all OS users out there. The following code shows
    an example of creating a button in Linux using the *Gtk+* GUI toolkit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Compared to the Windows API, it seems a bit easier to understand. However, you
    should dive into `GtkWidgets` and other components with *Gtk* prefixes to find
    out more about them.
  prefs: []
  type: TYPE_NORMAL
- en: As we have already mentioned, cross-platform languages such as Java and .NET
    Core use virtual machines to run the code on different platforms. The Qt framework
    supports cross-platform GUI programming using a platform-based compilation approach.
    Let's discuss both approaches with regard to the C++ language.
  prefs: []
  type: TYPE_NORMAL
- en: Using C++ as Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Languages such as Java or C# have different compilation models. The first chapter
    of this book introduced the C++ compilation model. First of all, we consider C++
    as a fully compilable language, while Java maintains a hybrid model. It compiles
    the source code into a middle representation called **bytecode**, and then the
    virtual machine runs it by translating it into the machine code for the specific
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts the differences between the C++ and Java compilation
    models:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0552bd5-d588-48b5-b7ec-9491231fbe30.png)'
  prefs: []
  type: TYPE_IMG
- en: The **Java virtual machine** (**JVM**) serves as a middle tier. It has a unique
    implementation for each platform. Users need to install the specific implementation
    of the virtual machine before running Java programs. The installation process
    only happens once. On the other hand, C++ programs are translated into machine
    code, which is run without a middle-tier environment such as the JVM. That's one
    of the reasons why C++ applications are generally faster. When we compile C++
    programs on a certain platform, the compiler outputs an executable file consisting
    of instructions in a format that's specific to that platform. When we move the
    application to another platform, it just can't run.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other platform cannot recognize its format, nor its instructions (although
    they might be similar in some way). The Java approach works by presenting some
    bytecode that is the same for all the implementations of virtual machines. But
    virtual machines know exactly which instruction they should generate for the bytecode
    that''s been provided as their input. The same bytecode can be run on many computers
    if they have the virtual machine installed. The following diagram demonstrates
    the Java application compilation model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4395de50-bc9b-4255-a882-8203041b2429.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the source code is compiled into bytecode that can be run on
    every OS. However, each OS must be provided with its own virtual machine implementation.
    This means we can run a Java application on any OS if we have installed a JVM
    specifically implemented for that OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although C++ is a cross-platform language, meaning that we don''t modify the
    code to compile it in other platforms, the language doesn''t support GUI programming
    out of the box. To program GUI applications, as we mentioned previously, we need
    to access the OS API directly from the code. This makes C++ GUI applications platform-dependent
    because you need to modify the code base to compile it on the other platform.
    The following diagram shows how GUIs spoil the cross-platform nature of the language:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cba1673-03ed-49cd-89b0-123652d0f46b.png)'
  prefs: []
  type: TYPE_IMG
- en: Though the application logic, name, and mission might be the same, it now has
    three different implementations with three different executables. To ship the
    application to the end user, we need to discover their OS and ship the correct
    executable. You might have encountered a similar scenario when downloading applications
    on the web. They offer download applications based on the OS. This is where Qt
    comes to the rescue. Let's see how.
  prefs: []
  type: TYPE_NORMAL
- en: Qt's cross-platform model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Qt is a popular widget toolkit for creating GUI applications. It also allows
    us to create cross-platform applications that run on various systems. Qt consists
    of the following modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Qt Core**: Core classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt** **GUI**: Base classes for GUI components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Widgets**: Classes to extend the Qt GUI with C++ widgets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Multimedia**: Classes for audio, video, radio, and camera functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Multimedia Widgets**: Classes for implementing multimedia functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Network**: Classes for network programming (we will use them in this chapter)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Modeling Language** (**QML**): A declarative framework for building applications
    with custom user interfaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt SQL**: Classes for database integration using SQL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Quick family of modules**: A list of QML-related modules that won''t be
    discussed in this book'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Test**: Classes for unit testing Qt applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Every module that we use in the program is attached to the compiler via a project
    file that has the `.pro` extension. This file describes everything that `qmake`
    needs to build the application. *qmake* is a tool aimed to simplify the build
    process. We describe the project components (sources, Qt modules, libraries, and
    so on) in the `.pro` file of the project. For example, a project that uses Qt
    Widgets and Qt Network and consists of `main.cpp` and `test.cpp` files will have
    the following content for the `.pro` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can specify platform-specific sources in the `.pro` file too, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When we build the application in a Windows environment, the `windows_specific.cpp` file
    will take part in the build process. Contrary to that, when building in a Unix
    environment, the `linux_world.cpp` file will be included while the `windows_specific.cpp` file
    will be ignored. With that, we've come to the compilation model of Qt applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole point of Qt''s powerful abilities to provide cross-platform programming
    is meta-compiling the source code; that is, before the code is passed to the C++
    compiler, the Qt compiler cleans it up by introducing or replacing platform-specific
    components. For example, when we use a button component (`QPushButton`), it will
    be replaced by a Windows-specific button component if compiled in a Windows environment.
    That''s why the `.pro` file also can contain platform-specific modifications for
    the project. The following diagram depicts this compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea855027-5cfa-4dbb-861e-3c3c908077f2.png)'
  prefs: []
  type: TYPE_IMG
- en: The meta-compiler is usually referred to as a **Meta-Object Compiler** (**MOC**).
    The beauty of this approach is that the produced output represents the same machine
    code that we run without a virtual machine. We can ship that executable right
    away. The downside of this approach is that we, again, have different executables
    for different platforms. However, we only write one application – there's no need
    to use different languages, dive into OS-specific APIs, or study OS-specific GUI
    component class names. As Qt says, *Write once, compile everywhere*. Now, let's
    move on to building a simple GUI application.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a simple application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We won''t discuss all the modules we mentioned previously in this book, simply
    because this would require a whole new book. You can refer to the books listed
    at the end of this chapter, in the *Further reading* section, for more information.
    The  `main` function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the various components we used in the code. The first
    one is the `QtWidgets` header file. It contains widget components that we can
    use to build a fine-grained GUI for our application. Next, there''s the `QPushButton`
    class, which represents a wrapper for a clickable button. We''re intentionally
    introducing it as a wrapper here so that we can explain it when we discuss the
    compilation process of Qt programs later in this chapter. Here''s the result of
    running the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10a68757-4e71-4c70-a722-b05add3fda63.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we only declared the `QPushButton` class, but it appeared as
    a window with the close and minimize buttons that are standard to the OS (in the
    example, this is macOS). The reason for this is because `QPushButton` indirectly
    inherits from `QWidget`, which is a widget with a frame; that is, a window. The
    button took almost all the space of the window. We can resize the window and see
    how the button resizes along with it. We will discuss widgets in more detail later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The GUI builds when we run `app.exec()`. Pay attention to the type of the `app`
    object. It's a `QApplication` object. This is the starting point of Qt applications.
    When we call the `exec()` function, we start Qt's event loop. Our perception of
    program execution should be changed a bit to understand the GUI application life
    cycle. Redefining the perception of program construction and execution shouldn't
    be surprising for you after [Chapter 7](decf1d72-ca4f-4954-85cb-860fbbf33580.xhtml),
    *Functional Programming*. It's not that hard this time. The main thing to know
    here is that GUI applications have an additional entity running along with the
    main program. This entity is called an **event loop**.
  prefs: []
  type: TYPE_NORMAL
- en: Recall the event loop, which we discussed in [Chapter 11](0e28887e-1a43-4510-a8ef-b3ad7531868d.xhtml),
    *Designing a Strategy Game Using Design Patterns*. The game represents a program
    with visual components that the user intensively interacts with. The same relates
    to regular GUI applications with buttons, labels, and other graphical components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user interacts with the application and each user action is interpreted
    as an event. Each event is then pushed to the queue. The event loop processes
    those events one by one. Processing an event means calling a special handler function
    attached to the event. For example, whenever a button is clicked, the `keyPressedEvent()`
    function is invoked. It''s a virtual function, so we can override it when designing
    custom buttons, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The only argument of the event is a pointer to `QKeyEvent`, a subtype of `QEvent`.
    `QEvent` is the base class of all event classes in Qt. Note the weird `Q_OBJECT`
    placed right after the opening block of the class. It's a Qt-specific macro that
    should be placed in the first line of your custom classes if you tend to make
    them discoverable by Qt's MOC.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will introduce the mechanism of signals and slots that
    are specific to Qt objects. To make our custom objects support that mechanism,
    we place the `Q_OBJECT` macro in the class definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s build something bigger than a simple button. The following example
    creates a window with the title `Mastering C++`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what we get by executing the preceding program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d9f3077-f55d-4e9d-969c-943ce57ae816.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The title is cut; we can see only the Mast... part of Mastering C++. Now, if
    we manually resize it or change the source code so that it has a larger value
    for the second parameter for the `resize()` function, we get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e176177a-de4c-4ab2-8043-e63400a3a368.png)'
  prefs: []
  type: TYPE_IMG
- en: The `window` object is of the `QWidget` type. `QWidget` is the central class
    for all user interface objects. Whenever you want to create a custom widget or
    extend an existing one, you directly or indirectly inherit from `QWidget`. It
    has a lot of functions for every use case. You can move it through the screen
    using the `move()` function, you can make the window full screen by calling `showFullScreen()`,
    and so on. In the preceding code, we called the `resize()` function, which takes
    the width and height to resize the widget. Also, note the `setWindowTitle()` function,
    which does exactly what it says on the tin – it sets the passed string argument
    as the title of the window. Its good practice to use the `QApplication::translate()`
    function when using string values in code. It makes program localization much
    easier because when the language setting is changed, Qt automatically replaces
    the text with the right translation. Almost the same functionality is provided
    by `QObject::tr()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`QObject` is the base class of all Qt types. In languages such as Java or C#,
    every object is directly or indirectly inherited from a generic type, mostly named
    `Object`. C++ doesn''t incorporate a common base class. Qt, on the other hand,
    introduces `QObject`, which comes with the base functionality that all objects
    should support.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've touched on the basics of Qt application development, let's dive
    a little bit deeper into the framework and discover its key features.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt evolved over time and at the time of writing this book, its version is 5.14\.
    Its first public prerelease version was announced in 1995\. More than two decades
    have passed and now Qt has a lot of powerful features that are used in almost
    all platforms, including mobile systems such as Android and iOS. With few exceptions,
    we can confidently write fully-featured GUI applications in C++ and Qt for all
    platforms. This is a big game-changer because companies hire smaller teams that
    specialize in one technology rather than having several teams for each specific
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to Qt, it is strongly recommended that you get familiar with
    it as much as you can (go to the end of this chapter for book references). Besides
    the regular components that GUI frameworks provide, Qt also introduces several
    concepts that are new or neatly implemented in the framework. One such concept
    is the communication between objects using signals and slots.
  prefs: []
  type: TYPE_NORMAL
- en: Grasping signals and slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt introduced the concept of signals and slots as a flexible communication mechanism between
    objects. The concept of signals and slots and their implementation mechanism is
    one of the features that sets Qt aside from other GUI frameworks. In previous
    chapters, we discussed the Observer pattern. The main idea of this pattern is
    to have an object that notifies other objects (subscribers) of an event. The mechanism
    of signals and slots is similar to the Observer pattern's implementation. It's
    a way for an object to notify another object about its change. Qt provides a generic
    interface that can be used to connect objects together by tying a signal from
    one object to the slot of another. Both signals and slots are regular member functions
    of objects. The signal is the function that is invoked on a specified action for
    the object. The slot is another function that serves as the subscriber. It is
    invoked by the signal function.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned previously, Qt introduced us to the base type for all objects,  `QObject`.
    The basic functionality for supporting signals and slots is implemented in `QObject`.
    Any object that you declare in your code, `QWidget`, `QPushButton`, and others
    all inherit from `QObject`, so all of them support signals and slots. QObject
    provides us with two functions for managing object communication. These objects
    are `connect()` and `disconnect()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `connect()` function takes the `receiver` and `sender`
    objects as arguments. Also, it takes the names of the signal and the slot. `signal`
    is associated with the sender, while `slot` is what the receiver provides. The
    following diagram shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2583b4a4-6b3d-4aa9-b879-885fcb19b63b.png)'
  prefs: []
  type: TYPE_IMG
- en: When programming Qt applications, operating with signals and slots will become
    natural and sooner or later, you would think that every other framework will support signals
    and slots because of their convenience. Also, note that the signal and the slot
    are processed as strings in the `connect()` and `disconnect()` functions. To specify
    the signal and the slot when connecting objects, we use two other macros, `SIGNAL()`
    and `SLOT()`, respectively. No more macros will be introduced from now on – we
    promise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we connect two objects together. Let''s say we want to change the
    text of a label (an instance of `QLabel`) so that it receives a signal when the
    button is clicked. To achieve this, we connect the `clicked()` signal of `QPushButton`
    to the slot of `QLabel`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code might look a bit verbose, but you will get used to it. Consider
    it as the price for a convenient mechanism for signals and slots. However, the
    preceding example won''t give us the required results; that is, it won''t set
    the text of the label to state that it received a signal. We should somehow pass
    that string to the label''s slot. The `clicked()` signal doesn''t do that for
    us. One of the ways to achieve this is by extending `QLabel` so that it implements
    a custom slot that sets the text to `received a signal`. Here''s how we can do
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To declare a slot, we specify the section, just like we did in the preceding
    code. Signals are declared almost the same way: by specifying a section with `signals:`.
    The only difference is that signals cannot be private or protected. We just declare
    them as-is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we should only update the preceding code in order to change the signal
    of the label (as well as the type of the label object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We say that the slot will be called when the signal is emitted. You can declare
    and emit signals from within your objects as well. An important detail related
    to signals and slots is that they are independent of the GUI event loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a signal is emitted, the connected slot is executed immediately. However,
    we can specify the type of connection by passing one of `Qt::ConnectionType` as
    the fifth argument of the `connect()` function. It comprises the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AutoConnection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DirectConnection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QueuedConnection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BlockingQueuedConnection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UniqueConnection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `DirectConnection`, the slot is invoked immediately when the signal is emitted.
    On the other hand, when `QueuedConnection` is used, the slot is invoked when execution
    returns to the event loop of the receiver object's thread. `BlockingQueuedConnection`
    is similar to `QueuedConnection`, except that the signaling thread is blocked
    until the slot returns a value. `AutoConnection` can be either `DirectConnection`
    or `QueuedConnection`. The type is determined when the signal is emitted. If the
    receiver and the emitter are in the same thread, `DirectConnection` is used; otherwise,
    the connection goes with `QueuedConnection`. Finally, `UniqueConnection` is used
    with any of the connection types described previously. It is combined with one
    of them using the bitwise OR. Its sole purpose is for the `connect()` function
    to fail if the connection has already been established between the signal and
    the thread.
  prefs: []
  type: TYPE_NORMAL
- en: Signals and slots form a powerful mechanism that makes Qt an outstanding framework
    in GUI programming. The next mechanism that we introduce is popular among frameworks
    and relates to the way we manipulate data in applications.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Model/View programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Model/View programming has its roots in the **Model View Controller** (**MVC**)
    design pattern. The main idea behind the pattern is to decompose your problem
    into three loosely coupled components, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The Model, which is responsible for storing and manipulating data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The View, which is responsible for rendering and visualizing the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Controller, which is responsible for additional business logic and providing
    data from the model to the view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Through its evolution, we now have a simplified and more convenient approach
    to programming called **Model/View programming**. It''s similar to the MVC pattern,
    except it omits the Controller by making the View and the Model more concerned
    about the functionality at hand. We can say that the View and the Controller are
    combined together in the Model/View architecture. Take a look at the following
    architecture diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f039425a-e465-49bd-81db-34ca31d2918f.png)'
  prefs: []
  type: TYPE_IMG
- en: The model represents the data, which communicates with its source and provides
    a convenient interface for the other components in the architecture. The model's
    implementation and its communication with other components is based on the type
    of data at hand.
  prefs: []
  type: TYPE_NORMAL
- en: The view gets references to data items by obtaining so-called model indexes.
    The view can retrieve and supply data to the model. The point is, the data item
    can be edited using the view, and the delegate plays the role of communicating
    with the model to keep data synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the introduced components – model, view, and delegate – are defined
    by abstract classes that provide common interfaces. In some cases, classes also
    provide default implementations of features. To write specialized components,
    we subclass from abstract classes. And of course, models, views, and delegates
    communicate using signals and slots, which we introduced in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: When the model encounters changes in the data, it informs the view. On the other
    hand, user interactions with rendered data items are informed by signals from
    the view. Finally, signals from the delegate inform the model and view about the
    state of data editing.
  prefs: []
  type: TYPE_NORMAL
- en: Models are based on the `QAbstractItemModel` class, which defines an interface
    that's used by views and delegates. Qt provides a set of existing model classes
    that we can use without modifications; however, if you need to create new models,
    you should inherit your class from `QAbstractItemModel`. For example, the `QStringListModel`,
    `QStandardItemModel`, and `QFileSystemModel` classes are ready-made to handle
    data items. `QStringListModel` is used to store a list of string items (represented
    as `QString` objects). Also, there are convenient model classes for working with
    SQL databases. `QSqlQueryModel`, `QSqlTableModel`, and `QSqlRelationalTableModel` allow
    us to access relational databases in the context of model/view conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Views and delegates also have corresponding abstract classes, that is, `QAbstractItemView`
    and `QAbstractItemDelegate`. Qt provides existing views that can be used right
    away, such as `QListView`, `QTableView`, and `QTreeView`. These are the basic
    types of views that most applications deal with. `QListView` displays a list of
    items, `QTableView` displays data in a table, and `QTreeView` displays data in
    a hierarchical list. If you want to work with those view classes, Qt suggests
    inheriting your custom models from `QAbstractListModel` or `QAbstractTableModel`
    instead of subclassing `QAbstractItemModel`.
  prefs: []
  type: TYPE_NORMAL
- en: '`QListView`, `QTreeView`, and `QTableView` are considered core and low-level
    classes. There are more convenient classes that provide better usability to novice
    Qt programmers – `QListWidget`, `QTreeWidget`, and `QTableWidget`. We will look
    at examples of using widgets in the next section of this chapter. Before that,
    let''s look at a simple example of a `QListWidget` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the ways to add items to the list widget is by creating them, which
    we can do by setting the list widget as its owner. In the following code, we''re
    declaring three `QListWidgetItem` objects, each holding a name and associated
    with the list widget we declared preceding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can declare an item and then insert it into the list widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter of the `insertItem()` member function is the number of `row`
    to insert the item in. We placed the `Sveta` item in the first position of the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve touched on the concept of the row, we should get back to models
    and their indexes. The model encapsulates the data as a collection of data items.
    Each item in the model has a unique index specified by a `QModelIndex` class.
    This means that every item in the model can be accessed by the associated model
    index. To obtain the model index, we need to use the `index()` function. The following
    diagram depicts a model that organizes its data in a table-like structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/394f992b-dd5a-4d0b-a1cf-ad364cf58851.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Views use this convention to access data items in the model. However, note
    that views are not restricted in terms of how they present the data to the user.
    It''s up to the view implementation to render and present the data in a way that''s
    convenient to the user. The following diagram shows how the data is organized
    within a model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cadf899-4035-46fc-9457-dc68738f5099.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s how we can access a specific data item at row 1, column 2 using the
    model index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s declare a view and set a model to it to see model/view programming
    in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We will continue this example in the next section, once we become familiar with
    the various widgets provided by Qt.
  prefs: []
  type: TYPE_NORMAL
- en: Using Qt widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Widgets are visual GUI components. If a widget doesn''t have a parent, it is
    treated as a window, otherwise known as a **top-level widget**. Earlier in this
    chapter, we created the simplest possible window in Qt, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `window` object doesn''t have a parent. The thing is, the
    constructor of `QWidget` takes another `QWidget` as the parent of the current
    one. So, when we declare a button and want it to be a child of our `window` object,
    we do so in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Observe the second argument of the `QPushButton` constructor. We passed a reference
    to the `window` object as its parent. When a parent object is destroyed, its children
    are automatically destroyed. There are many other widgets supported by Qt; let's
    have a look at some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Common Qt widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we introduced the `QPushButton` class and stated that
    it indirectly inherits the `QWidget` class. To create a window, we used the `QWidget`
    class. As it turns out, QWidget represents the capability to render to the screen,
    and it''s the basic class that all widgets inherit from. It has a lot of properties
    and functions, such as `enabled`, a boolean property that''s true if the widget
    is enabled. To access it, we use the `isEnabled()` and `setEnabled()` functions.
    To control the size of the widget, we use its `height` and `width`, which represent
    the height and width of the widget. To get their values, we call `height()` and
    `width()`, respectively. To set a new height and width, we should use the `resize()`
    function, which takes two arguments – the width and the height. You can also control
    the minimum and maximum size of the widget using the `setMinimumWidth()`, `setMinimumHeight()`,
    `setMaximumWidth()`, and `setMaximumHeight()` functions. This might come in useful
    when you set up widgets in layouts (see the next section). Besides properties
    and functions, we are mainly interested in the public slots of QWidget, which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`close()`: Closes the widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hide()`: Equivalent to `setVisible(false)`, this function hides the widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lower()` and `raise()`: Move the widget through the parent widget''s stack
    (to the bottom or to the top). Each widget can have a parent widget. A widget
    without a parent widget becomes an independent window. We can set a title and
    an icon for this window using the `setWindowTitle()` and `setWindowIcon()` functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`style`: The property holds the style of the widget. To modify it, we use the
    `setStyleSheet()` function by passing a string describing the style of the widget. Another
    way to do this is by calling the `setStyle()` function and passing an object of
    the `QStyle` type that encapsulates style-related properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Qt widgets have almost all the necessary properties out there to use out of
    the box. You rarely encounter situations where you have to build your own widget.
    However, some teams create an entire set of custom widgets for their software.
    That''s fine if you are planning to have a custom look and feel for your programs.
    For example, you can incorporate flat-styled widgets, which means you have to
    modify the style of the default widgets provided by the framework. Custom widgets
    should inherit from `QWidget` (or any of its descendants), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want the widget to expose signals and slots, you need to use the `Q_OBJECT`
    macro at the beginning of the class declaration. The definition of the updated
    `MyWidget` class will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As you have probably already guessed, signals don''t have an access modifier,
    while slots can be separated into public, private, and protected sections. As
    we mentioned previously, Qt provides enough widgets out of the box. To go over
    the set of widgets, Qt provides a set of examples that compose widgets together.
    If you have installed Qt Creator (the IDE for developing Qt applications), you
    should be able to go over the examples in a single click. Here''s what it looks
    like in the Qt Creator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/477bcb65-d63d-444f-b137-11aa76371cd2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Configuring and running the Address Book example will give us the following
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0e7b66e-749a-4d36-9520-e04b702e354a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking the Add button will open a dialog so that we can add a new entry to
    the address book, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5bd497c5-53ec-4f80-8c12-1b1143f90e84.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After adding a couple of entries, the main window shows the entries in a table,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91bc9193-20c4-4f05-8660-b43300552cd6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding screenshots show a wide range of widgets composed together in
    one application. Here are some of the most common widgets that we regularly use
    in GUI application development:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QCheckBox`: Represents a checkbox with a text label.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QDateEdit`: Represents a widget that you can use to input the date. You can
    also use `QDateTimeEdit` if want to input the time as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QLabel` : Text display. Also used to display images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QLineEdit`: A single-line edit box.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QProgressBar`: Renders a vertical or horizontal progress bar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QTabWidget`: As stack of tabbed widgets. This is one of the many organizer
    widgets. Some of the other organizers are `QButtonGroup`, `QGroupBox`, and `QStackedWidget`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding list is not final, but it gives a basic idea of Qt's capabilities.
    The address book example we used here uses many of these widgets. `QTabWidget`
    represents an organizing widget. It groups several widgets together. Another way
    to organize widgets is using layouts. In the next section, we will introduce you
    to how to organize widgets together.
  prefs: []
  type: TYPE_NORMAL
- en: Composing widgets using layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt provides us with a flexible and simple platform where we can use the widgets
    arrangement mechanism in the form of layouts. This helps us ensure the space inside
    the widget is used both efficiently and provides a friendly user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets look at the basic usage of layout management classes. The advantage of
    using layout management classes is that they automatically resize and position
    widgets when the container widget changes its size. Another advantage of Qt''s
    layout classes is that they allow us to arrange the widgets by writing code rather
    than using a UI composer. While Qt Creator provides a great way of composing widgets
    by hand (dragging and dropping widgets on the screen), most programmers feel more
    comfortable when they actually write code that arranges the look and feel of their
    widgets. Assuming you like the latter approach as well, we are going to introduce
    the following layout classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QHBoxLayout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QVBoxLayout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QGridLayout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QFormLayout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these classes inherit from `QLayout`, the base class for geometry management.
    `QLayout` is an abstract base class that inherits from `QObject`. It doesn''t
    inherit from `QWidget` because it doesn''t have anything to do with rendering;
    instead, it takes care of organizing widgets that should be rendered on the screen.
    You probably won''t need to implement your own layout manager, but if you do,
    you should inherit your class from `QLayout` and provide implementations for the
    following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addItem()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sizeHint()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setGeometry()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`itemAt()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`takeAt()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minimumSize()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The classes listed here are more than enough to compose widgets of almost any
    complexity. And what''s more important is that we can place one layout into another,
    resulting in a more flexible organization of widgets. Using `QHBoxLayout`, we
    can organize widgets horizontally from left to right, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41c40a4b-c3e7-48f1-b380-1e50488376d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To achieve the preceding organization, we need to use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the line where we call the `setLayout()` function on the widget.
    Each widget can be assigned a layout. A layout itself doesn''t do much without
    a container, so we need to set it to a widget that serves as a container for organized
    widgets (buttons, in our case). `QHBoxLayout` inherits from `QBoxLayout`, which
    has another descendant that we listed previously – `QVBoxLayout`. It''s similar
    to `QHBoxLayout` but organizes widgets vertically, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a74e6782-1f0b-4911-a676-6caff1a6e7cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The only thing that we need to do in the preceding code is replace `QHBoxLayout`
    with `QVBoxLayout`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`GridLayout` allows us to organize widgets into a grid, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76ec7f99-4a11-45e6-938a-9693af4e5f5f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And here''s the corresponding code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Finally, similar to `QGridLayout`, `QFormLayout` is more helpful when it comes
    to designing input forms because it lays out widgets in a two-column descriptive
    style.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned previously, we can compose a layout into another one. To do
    so, we need to use the `addItem()` function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Layout managers are flexible enough to build complex user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are new to Qt, this chapter will have served as a general introduction
    to the framework. We touched on the basics of GUI application development and
    compared the Java approach with Qt's approach. One of the biggest pros of using
    Qt is its support for cross-platform development. While Java does the same, Qt
    goes beyond that by producing executables that are native to the platform. This
    makes applications written in Qt much faster compared to alternatives that incorporate
    virtual machines.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed Qt's signals and slots as a flexible mechanism for inter-object
    communication. By using this, you are able to design complex communication mechanisms
    in your GUI applications. Although we looked at rather simple examples in this
    chapter, you are free to experiment with various ways of using signals and slots.
    We also became familiar with common Qt widgets and the mechanism of layout management.
    You now have a fundamental understanding that allows you to design even the most
    complex GUI layouts. This means you're free to implement a complex Qt application
    by applying the techniques and widgets that were introduced in this chapter. In
    the next chapter, we are going to discuss a popular topic nowadays – artificial
    intelligence and machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why doesn't Qt need a virtual machine?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `QApplication::exec()` function do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you change the title of a top-level widget?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given the `m` model, how would you access an item at row 2 and column 3?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given the `wgt` widget, how would you change its width to 400 and height to
    450?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which functions should you implement when inheriting from `QLayout` to create
    your own layout manager class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you connect a signal to a slot?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Qt5 C++ GUI Programming Cookbook* by Lee Zhi Eng: [https://www.packtpub.com/application-development/qt5-c-gui-programming-cookbook-second-edition](https://www.packtpub.com/application-development/qt5-c-gui-programming-cookbook-second-edition)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mastering Qt5* by Guillaume Lazar, Robin Penea: [https://www.packtpub.com/web-development/mastering-qt-5-second-edition](https://www.packtpub.com/web-development/mastering-qt-5-second-edition)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
