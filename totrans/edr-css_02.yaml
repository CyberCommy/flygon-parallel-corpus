- en: Chapter 2. The Problems of CSS at Scale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we talked about the scenario which gave rise to the ECSS
    methodology. A large, CSS codebase that developers found difficult to reason about,
    cumbersome to work with and was littered with poorly commented and redundant code.
    However, no CSS codebase starts this way.
  prefs: []
  type: TYPE_NORMAL
- en: In most projects, the CSS starts out with some simple rules. At the outset,
    you'd have to be doing something fairly daft to make maintenance of the CSS problematic.
  prefs: []
  type: TYPE_NORMAL
- en: However, as the project grows, so too does the CSS. Requirements become more
    complicated. More authors get involved writing the styles. Edge cases and browser
    workarounds need to be authored and factored in. It's easy for things to get unruly
    fast.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the growing demands on a humble widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '*When the widget is in the sidebar, can we reduce the font size?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*When we''re on the home page, can the widget have a different background colour?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Can we have the things inside the widget stacked vertically at larger viewports?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*When the widget is in the sidebar on the product page, the font colour needs
    to change*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before long we need to write a whole raft of overrides to a key selector. Let''s
    consider the selectors we might need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There's some basic authoring problems there if this was CSS that we wanted to
    scale. Let's consider some of the more obvious problems in those rules now.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The term *key selector* is used to describe the right most selector in any CSS
    rule. It's the selector you are attempting to affect change on.
  prefs: []
  type: TYPE_NORMAL
- en: Specificity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first major problem when trying to scale CSS is the problem of specificity.
    Ordinarily, specificity is a useful thing. It allows us to introduce some form
    of logic in the CSS. Styles that are more specific than others get applied in
    the browser. Our example above demonstrates this: different rules will be applied
    in different eventualities (for example, when in the sidebar, we want to override
    the default styles).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, CSS selectors can be made up of ID, class, attribute & type selectors and
    any combination of those. With responsive designs you can throw media queries
    into the mix too.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, not all selectors are created equal. The W3C describes how specificity
    is calculated here: [http://www.w3.org/TR/css3-selectors/#specificity](http://www.w3.org/TR/css3-selectors/#specificity).
    Here is the most relevant section:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A selector''s specificity is calculated as follows: count the number of ID
    selectors in the selector (= a) count the number of class selectors, attributes
    selectors, and pseudo-classes in the selector (= b) count the number of type selectors
    and pseudo-elements in the selector (= c) ignore the universal selector Selectors
    inside the negation pseudo-class are counted like any other, but the negation
    itself does not count as a pseudo-class. Concatenating the three numbers a-b-c
    (in a number system with a large base) gives the specificity.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'One important thing missing there is the style attribute. Information on that
    *elsewhere* ([https://www.w3.org/TR/css-style-attr/](https://www.w3.org/TR/css-style-attr/))
    tells us that:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The declarations in a style attribute apply to the element to which the attribute
    belongs. In the cascade, these declarations are considered to have author origin
    and a specificity higher than any selector.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So, a style applied in a style attribute on an element is going to be more specific
    than an equivalent rule in a CSS file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless, the biggest takeaway here is that ID selectors are infinitely more
    specific than class based selectors. This makes overriding any selector containing
    an ID based selector far more difficult. For example, with a widget in the sidebar
    this won''t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this instance we would be applying a HTML class (`class-on-sidebar`) on the
    sidebar element (the aside element with the ID of sidebar) and then selecting
    that in the CSS lower down than the ID based selector. However, the rule still
    won't be applied.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing what we know about specificity from the W3C specifications we can calculate
    the specificity of these rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the numbers. Left to right, the numbers after the selectors below
    relate to: number of inline styles, number of ID selectors, number of class selectors,
    and finally the number of type selectors.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **selector** | ** inline ** | **ID** | **  class  ** | **  type  ** |'
  prefs: []
  type: TYPE_TB
- en: '| `.widget` | 0 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `aside#sidebar .widget` | 0 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `.class-on-sidebar .widget` | 0 | 0 | 2 | 0 |'
  prefs: []
  type: TYPE_TB
- en: So you can see here that the middle selector has a greater specificity than
    the last. Bummer.
  prefs: []
  type: TYPE_NORMAL
- en: On a single or smaller file, this isn't that much of a big deal. We just create
    a more specific rule. However, if the CSS of your codebase is split across many
    smaller partial CSS files, finding a rule that is preventing your override from
    working can become an unwanted burden. Now, the problem isn't specific to ID selectors.
    It's more of a problem with unequally weighted selectors in the style sheets.
    Think of it like a heavyweight boxer pitted against a flyweight. It's not a fair
    contest. Creating a level playing field across the selectors used is more important
    than the actual selectors used.
  prefs: []
  type: TYPE_NORMAL
- en: This mis-matched soup of selectors is the crux of the specificity issue. As
    soon as you have a CSS codebase with hundreds of rules, any unneeded specificity
    starts to become a major hindrance to speedy development.
  prefs: []
  type: TYPE_NORMAL
- en: So, to conclude, specificity is a problem we need to address in an ever-growing
    CSS codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Markup structure tied to selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another practice to avoid when authoring CSS for scale is using type selectors;
    selectors that relate to specific markup. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this case we need to have an `a` tag inside an `li` which is a direct child
    of a `ul` inside an `aside` element with an ID of `sidebar` - phew!
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we want to apply those styles to a `div` somewhere else? Or
    any other markup structure?
  prefs: []
  type: TYPE_NORMAL
- en: We've just unnecessarily tied our rule to specific markup structure. It's often
    quite tempting to do this, as it can seem ridiculous to add a class to something
    as (seemingly) trivial as an `a` or `span` tag. However, I hope once you reach
    the end of this book you'll be convinced to avoid the practice.
  prefs: []
  type: TYPE_NORMAL
- en: We want CSS that is as loosely coupled to structure as possible. That way, should
    we need to introduce an override (a more specific selector for a particular instance)
    we can keep things as vague as possible to get the job done. Again, get used to
    the idea of introducing only as much specificity as is needed.
  prefs: []
  type: TYPE_NORMAL
- en: The cascade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, the cascade part of *Cascading Style Sheets* is useful. Even if specificity
    is very equal across the selectors used, the cascade allows equivalent rules further
    down the CSS to be applied over existing rules higher up.
  prefs: []
  type: TYPE_NORMAL
- en: However, in a large codebase, the cascade presents an undesirable temptation;
    the ability for developers to take a short cut of amending the existing CSS by
    simply writing more new code at the bottom of the existing CSS.
  prefs: []
  type: TYPE_NORMAL
- en: This temptation is both real and easy to identify with. It can be tempting for
    a number of reasons. As an example, authors more familiar with other languages
    that need to make changes to the CSS may lack the confidence or intimate knowledge
    of the CSS codebase to be able to confidently remove or amend the existing code.
    They therefore take the safest option and override existing rules using a more
    specific set of rules. At the time it seems like the responsible thing to do—just
    adding one or two rules as needed.
  prefs: []
  type: TYPE_NORMAL
- en: However, the problem with leaning on the cascade in this way is that over time
    and iteration, the CSS code becomes bloated with many redundant rules. The consumers
    of this CSS (the users) are downloading CSS full of cruft that their browser simply
    doesn't need and the maintainers of this code have more code to sift through every
    time they need to make sense of their codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we've taken a high-level view of some of the problems that are
    symptomatic of a CSS codebase struggling to cope at scale. Problems such as overly
    specific selectors, selectors tied to specific markup structure and the temptation
    of leaning on the cascade and the CSS bloat that leads too.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at the accepted wisdom and approaches of trying
    to tame large CSS codebases and consider any shortcomings they present.
  prefs: []
  type: TYPE_NORMAL
