- en: Goroutines - Basic Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about Unix signal handling as well as adding
    support for pipes and creating graphical images in Go.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: The subject of this really important chapter is goroutines. Go uses goroutines
    and **channels** in order to program concurrent applications in its own way while
    providing support for traditional concurrency techniques. Everything in Go is
    executed using goroutines; when a program starts its execution, its single goroutine
    automatically calls theÂ  `main()` function in order to begin the actual execution
    of the program.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will present the easy parts of goroutines using easy to
    follow code examples. However, in [Chapter 10](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml)*,*
    *Goroutines - Advanced Features*, that is coming next, we will talk about more
    important and advanced techniques related to goroutines and channels; so, make
    sure that you fully understand this chapter before reading the next one.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, this chapter will tell you about the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Creating goroutines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing goroutines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About channels and how to use them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing to channels
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using pipelines
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the Go code of the `wc.go` utility from [Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml),
    *File Input and Output*, in order to use goroutines in the new implementation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the goroutine version of `wc.go` even further
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About goroutines
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **goroutine** is the minimum Go entity that can be executed concurrently.
    Note that the use of the word *minimum* is very important here because goroutines
    are not autonomous entities. Goroutines live in threads that live in Unix processes.
    Putting it simply, processes can be autonomous and exist on their own, whereas
    both goroutines and threads cannot. So, in order to create a goroutine, you will
    need to have a process with at least one thread. The good thing is that goroutines
    are lighter than threads, which are lighter than processes. Everything in Go is
    executed using goroutines, which makes perfect sense since Go is a concurrent
    programming language by design. As you have just learned, when a Go program starts
    its execution, its single goroutine calls the `main()` function, which starts
    the actual program execution.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: You can define a new goroutine using the `go` keyword followed by a function
    name or the full definition of an anonymous function. The `go` keyword starts
    the function argument to it in a new goroutine and allows the invoking function
    to continue on by itself.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: However, as you will see, you cannot control or make any assumptions about the
    order your goroutines are going to get executed because this depends on the scheduler
    of the operating system as well as the load of the operating system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency and parallelism
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very common misconception is that **concurrency** and **parallelism** refer
    to the same thing, which is far from true! Parallelism is the simultaneous execution
    of multiple things, whereas concurrency is a way of structuring your components
    so that they can be independently executed when possible.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Only when you build things concurrently you can safely execute them in parallel:
    when and if your operating system and your hardware permit it. The Erlang programming
    language did this a long time ago, long before CPUs had multiple cores and computers
    had lots of RAM.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: In a valid concurrent design, adding concurrent entities makes the whole system
    run faster because more things can run in parallel. So, the desired parallelism
    comes from a better concurrent expression and implementation of the problem. The
    developer is responsible for taking concurrency into account during the design
    phase of a system and benefit from a potential parallel execution of the components
    of the system. So, the developer should not think about parallelism, but about
    breaking things into independent components that solve the initial problem when
    combined.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Even if you cannot run your functions in parallel on a Unix machine, a valid
    concurrent design will still improve the design and the maintainability of your
    programs. In other words, concurrency is better than parallelism!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The sync Go packages
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sync` Go package contains functions that can help you synchronize goroutines;
    the most important functions of `sync` are `sync.Add`, `sync.Done`, and `sync.Wait`.
    The synchronization of goroutines is a mandatory task for every programmer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Note that the synchronization of goroutines has nothing to do with shared variables
    and shared state. Shared variables and shared state have to do with the method
    you want to use for performing concurrent interactions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: A simple example
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this subsection, we will present a simple program that creates two goroutines.
    The name of the sample program will be `aGoroutine.go` and will be presented in
    three parts; the first part is the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Apart from the expected `package` and `import` statements, you can see the implementation
    of a function named `namedFunction()` that sleeps for a while before printing
    a message on the screen.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `aGoroutine.go` contains the following Go code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, you create a goroutine that executes the `namedFunction()` function.
    The last part of this naive program is the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, you create another goroutine that executes an anonymous function that
    contains a single `fmt.Println()` statement.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, goroutines that run this way are totally isolated from each
    other and cannot exchange any kind of data, which is not always the operational
    style that is desired.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: If you forget to call the `time.Sleep()` function in the `main()` function,
    or if `time.Sleep()` sleeps for a small amount of time, then `main()` will finish
    too early and the two goroutines will not have enough time to start and therefore
    finish their jobs; as a result, you will not see all the expected output on your
    screen!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `aGoroutine.go` will generate the following output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating multiple goroutines
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This subsection will show you how to create many goroutines and the problems
    that arise from having to handle more goroutines. The name of the program will
    be `moreGoroutines.go` and will be presented in three parts.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `moreGoroutines.go` is the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The second part of the program has the following Go code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This time, the anonymous function takes a parameter named `x`, which has the
    value of the `i` variable. The `for` loop that uses the `i` variable creates ten
    goroutines, one by one.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the program is the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once again, if you put a smaller value as the parameter to `time.Sleep()`, you
    will see different results when you execute the program.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `moreGoroutines.go` will generate a somehow strange output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'However, the big surprise comes when you execute `moreGoroutines.go` multiple
    times:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, all previous outputs of the program are different from the first
    one! So, not only the output is not coordinated and there is not always enough
    time for all goroutines to get executed; you cannot be sure about the order the
    goroutines will get executed. However, although you cannot do anything about the
    latter problem because the order that goroutines get executed depends on various
    parameters that the developer cannot control, the next subsection will teach you
    how to synchronize goroutines and give them enough time to finish without having
    to call `time.Sleep()`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for goroutines to finish their jobs
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This subsection will demonstrate to you the correct way to make a calling function
    that wait for its goroutines to finish their jobs. The name of the program will
    be `waitGR.go` and will be presented in four parts; the first part is the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There is nothing special here apart from the absence of the `time` package and
    the addition of the `sync` package.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part has the following Go code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, you create a new variable with a type of `sync.WaitGroup`, which waits
    for a group of goroutines to finish. The number of goroutines that belong to that
    group is defined by one or multiple calls to the `sync.Add()` function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Calling `sync.Add()` before the Go statement in order to prevent race conditions
    is important.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `sync.Add(10)` call tells our program that we will wait for
    ten goroutines to finish.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the program is the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, you create the desired number of goroutines using a `for` loop, but you
    could have used multiple sequential Go statements. When each goroutine finishes
    its job, the `sync.Done()` function is executed: the use of the `defer` keyword
    right after the function definition tells the anonymous function to automatically
    call `sync.Done()` just before it finishes.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `waitGR.go` is the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The good thing here is that there is no need to call `time.Sleep()` because
    `sync.Wait()` does the necessary waiting for us.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, it should be noted here that you should not make any assumptions
    about the order the goroutines will get executed in which is also verified by
    the following output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you call `waitGroup.Add()` more times than needed, you will get the following
    error message when you execute `waitGR.go`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This happens because when you tell your program to wait for n+1 goroutines by
    calling `sync.Add(1)` n+1 times, your program cannot have only n goroutines (or
    less)! Putting it simply, this will make `sync.Wait()` to wait indefinitely for
    one or more goroutines to call `sync.Done()` without any luck, which is obviously
    a deadlock situation that prevents your program from finishing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dynamic number of goroutines
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This time, the number of goroutines that will be created will be given as a
    command-line argument: the name of the program will be `dynamicGR.go` and will
    be presented in four parts.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `dynamicGR.go` is the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The second part of `dynamicGR.go` contains the following Go code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, the `waitGroup.Add(1)` statement is called just before you create
    a new goroutine.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the Go code of `dynamicGR.go` is the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding part, each simplistic goroutine is created.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the program is the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, you just tell the program to wait for all goroutines to finish using the
    `waitGroup.Wait()` statement.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'The execution of `dynamicGR.go` requires an integer parameter, which is the
    number of goroutines you want to create:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can imagine, the more goroutines you want to create, the more diverse
    outputs you will have because there is no way to control the order that the goroutines
    of a program are going to be executed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: About channels
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **channel**, putting it simply, is a communication mechanism that allows goroutines
    to exchange data. However, some rules exist here. First, each channel allows the
    exchange of a particular data type, which is also called the **element type**
    of the channel, and second, for a channel to operate properly, you will need to
    use some Go code to receive what is sent via the channel.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: You should declare a new channel using the `chan` keyword and you can close
    a channel using the `close()` function. Additionally, as each channel has its
    own type, the developer should define it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Last, a very important detail: when you are using a channel as a function parameter,
    you can specify its direction, that is, whether it will be used for writing or
    reading. In my opinion, if you know the purpose of a channel in advance, use this
    capability because it will make your program more robust as well as safer: otherwise,
    just do not define the purpose of the channel function parameter. As a result,
    if you declare that a channel function parameter will be used for reading only
    and you try to write to it, you will get an error message that will most likely
    save you from nasty bugs.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The error message you will get when you try to read from a write channel will
    be similar to the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Writing to a channel
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this subsection, you will learn how to write to a channel. The presented
    program will be called `writeChannel.go` and you will see it in three parts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part has the expected preamble:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can understand, the use of channels does not require any extra Go packages.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `writeChannel.go` is the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Although the `writeChannel()` function writes to the channel, the data will
    be lost because currently nobody reads the channel in the program.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the program contains the following Go code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, you can see the definition of a channel variable named `c` with the help
    of the `chan` keyword that is used for the `int` data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `writeChannel.go` will create the following output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is not what you expected to see! The cause of this unpredicted output
    is that the second `fmt.Println(x)` statement was not executed. The reason for
    this is pretty simple: the `c <- x` statement is blocking the execution of the
    rest of the `writeChannel()` function because nobody is reading from the `c` channel.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Reading from a channel
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This subsection will improve the Go code of `writeChannel.go` by allowing you
    to read from a channel. The presented program will be called `readChannel.go`
    and be presented in four parts.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The second part of `readChannel.go` has the following Go code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once again, note that if nobody collects the data written to a channel, the
    function that sent it will stall while waiting for someone to read its data. However,
    in [Chapter 10](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml)*,* *Goroutines - Advanced
    Features*, you will see a very pretty solution to this problem.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part has the following Go code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, the `<-c` statement in the `fmt.Println()` function is used for reading
    a single value from the channel: the same statement can be used for storing the
    value of a channel into a variable. However, if you do not store the value you
    read from a channel, it will be lost.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `readChannel.go` is the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, you see a technique that allows you to find out whether the channel that
    you want to read from is closed or not. However, if the channel was open, the
    presented Go code will discard the read value of the channel because of the use
    of the `_` character in the assignment.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `readChannel.go` will create the following output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Explaining h1s.go
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 8](defd267a-724b-4983-a51f-7cda6bba93aa.xhtml)*,* *Processes and
    Signals*, you saw how Go handles Unix signals using many examples including `h1s.go`.
    However, now that you understand more about goroutines and channels, it is time
    to explain the Go code of `h1s.go` a little more.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: As you already know that `h1s.go` uses channels and goroutines, it should be
    clear now that the anonymous function that is executed as a goroutine reads from
    the `sigs` channel using an infinite `for` loop. This means that each time there
    is a signal that interests us, the goroutine will read it from the `sigs` channel
    and handle it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Pipelines
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go programs rarely use a single channel. One very common technique that uses
    multiple channels is called a **pipeline**. So, a pipeline is a method for connecting
    goroutines so that the output of a goroutine becomes the input of another with
    the help of channels. The benefits of using pipelines are as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits you get from using pipelines is that there is a constant
    flow in your program because nobody waits for everything to be completed in order
    to start the execution of goroutines and channels of the program
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, you are using less variables and therefore less memory space because
    you do not have to save everything
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last, the use of pipelines simplifies the design of the program and improves
    its maintainability
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code of `pipelines.go`, which works with a pipeline of integers, will be
    presented in five parts; the first part is the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The second part contains the following Go code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, you define a function that takes three arguments: two integers and one
    output channel. The output channel will be used for writing data that will be
    read in another function: this is how a pipeline is created.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the program is the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This time, the function takes two arguments that are both channels. However,
    `out` is an output channel, whereas `in` is an input channel used for reading
    data.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part contains the definition of another function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The last function of `pipelines.go` takes just one argument, which is a channel
    used for reading data.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `pipelines.go` is the implementation of the `main()` function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, the `main()` function firstly reads its two command-line arguments and
    creates the necessary channel variables (`naturals` and `squares`). Then, it calls
    the functions of the pipeline: note that the last function of the channel is not
    being executed as a goroutine.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows a graphical representation of the pipeline used
    in `pipelines.go` in order to the way this particular pipeline works:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6d2874d-12a1-4441-b5a1-f2af5c0056fe.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: A graphical representation of the pipeline structure used in pipelines.go
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `pipelines.go` generates the following output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: A better version of wc.go
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we talked about in [Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml)*,*
    *File Input and Output*, in this chapter, you will learn how to create a version
    of `wc.go` that uses goroutines. The name of the new utility will be `dWC.go`
    and will be presented in four parts. Note that the current version of `dWC.go`
    considers each command-line argument as a file.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the utility is the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The second part has the following Go code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `count()` function does all the processing without returning any information
    to the `main()` function: it just prints the lines, words, and characters of its
    input file and exits. Although the current implementation of the `count()` function
    does the desired job, it is not the correct way to design a program because there
    is no way to control its output of the program.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the utility is the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The last part of `dWC.go` is the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, each input file is being processed by a different goroutine.
    As expected, you cannot make any assumptions about the order the input files will
    be processed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `dWC.go` will generate the following output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, you can see that although the `doesnotExist` filename is the last command-line
    argument, it is the first one in the output of `dWC.go`!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Although `dWC.go` uses goroutines, there is no cleverness in it because goroutines
    run without communicating with each other and without performing any other tasks.
    Additionally, the output might get scrambled because there is no guarantee that
    the `fmt.Printf()` statements of the `count()` function will not get interrupted.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the forthcoming section as well as some of the techniques that
    will be presented in [Chapter 10](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml)*,*
    *Goroutines - Advanced Features*, will improve `dWC.go`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Calculating totals
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The current version of `dWC.go` cannot calculate totals, which can be easily
    solved by processing the output of `dWC.go` with `awk`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Still, this is far from being perfect and elegant!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The main reason that the current version of `dWC.go` cannot calculate totals
    is that its goroutines have no way of communicating with each other. This can
    be easily solved with the help of channels and pipelines. The new version of `dWC.go`
    will be called `dWCtotal.go` and will be presented in five parts.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `dWCtotal.go` is the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, a new `struct` type is defined. The new structure is called `File` and
    has four fields and an additional field for keeping error messages. This is the
    correct way for a pipeline to circulate multiple values. One might argue that
    a better name for the `File` structure would have been `Counts`, `Results`, `FileCounts`,
    or `FileResults`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of the program is the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: A better name of the `process()` function would have been `beginProcess()` or
    `processResults()`. You can try to make that change on your own throughout the
    `dWCtotal.go` program.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `dWCtotal.go` has the following Go code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Although the `count()` function still calculates the counts, it does not print
    them. It just sends the counts of lines, words, and characters as well as the
    filename to another channel using a `struct` variable of the `File` type.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'There exists one very important detail here, which is the last statement of
    the `count()` function: in order to properly end a pipeline, you should close
    all involved channels, starting from the first one. Otherwise, the execution of
    the program will fail with an error message similar to the following one:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: However, as far as closing the channels of a pipeline is concerned, you should
    also be careful about closing channels too early, especially when there are splits
    in a pipeline.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part of the program contains the following Go code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'There is nothing special here: the `calculate()` function does the dirty job
    of printing the output of the program.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `dWCtotal.go` is the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Since the `files` channel is only used for passing around filenames, it could
    have been a `string` channel instead of a `File` channel. However, this way the
    code is more consistent.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Now `dWCtotal.go` automatically generates totals even if it has to process
    just one file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Note that both `dWCtotal.go` and `dWC.go` implement the same core functionality,
    which is counting the words, characters, and lines of a file: it is the way the
    information is handled that is different because `dWCtotal.go` uses a pipeline
    and not isolated goroutines.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 10](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml)*,* *Goroutines - Advanced
    Features*, will use other techniques to implement the functionality of `dWCtotal.go`.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Doing some benchmarking
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will compare the performance of `wc.go` from [Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml)*,*
    *File Input and Output**,* with the performance of `wc(1)`, `dWC.go` and `dWCtotal.go`.
    In order for the results to be more accurate, all three utilities will process
    relatively big files:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'So, the `time(1)` utility will measure the following commands:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following figure shows a graphical representation of the real field from
    the output of the `time(1)` utility when used to measure the aforementioned commands:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de995173-8729-4a8b-8960-775d6436074c.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: Plotting the real field of the time(1) utility
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The original `wc(1)` utility is by far the fastest of all. Additionally, `dWC.go`
    is faster than both `dWCtotal.go` and `wc.go`. Apart from `dWC.go`, the remaining
    two Go versions have the same performance.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a pipeline that reads text files, finds the number of occurrences of
    a given word, and calculates the total number of occurrences of the word in all
    files.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to make `dWCtotal.go` faster.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a simple Go program that plays ping pong using channels. You should define
    the total number of pings and pongs using a command-line argument.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about creating and synchronizing goroutines as well
    as about creating and using pipelines and channels to allow goroutines to communicate
    with each other. Additionally, we developed two versions of the `wc(1)` utility
    that use goroutines to process their input files.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you fully understand the concepts of this chapter before continuing
    with the next chapter because in the next chapter, we will talk about more advanced
    features related to goroutines and channels including shared memory, buffered
    channels, the `select` keyword, the `GOMAXPROCS` environment variable, and signal
    channels.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: å¨ç»§ç»­ä¸ä¸ç« ä¹åï¼è¯·ç¡®ä¿æ¨ååçè§£æ¬ç« çæ¦å¿µï¼å ä¸ºå¨ä¸ä¸ç« ä¸­ï¼æä»¬å°è®¨è®ºä¸goroutinesåééç¸å³çæ´é«çº§ç¹æ§ï¼åæ¬å±äº«åå­ãç¼å²ééã`select`å³é®å­ã`GOMAXPROCS`ç¯å¢åéåä¿¡å·ééã
