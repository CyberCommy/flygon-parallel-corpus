- en: Goroutines - Basic Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about Unix signal handling as well as adding
    support for pipes and creating graphical images in Go.
  prefs: []
  type: TYPE_NORMAL
- en: The subject of this really important chapter is goroutines. Go uses goroutines
    and **channels** in order to program concurrent applications in its own way while
    providing support for traditional concurrency techniques. Everything in Go is
    executed using goroutines; when a program starts its execution, its single goroutine
    automatically calls theÂ  `main()` function in order to begin the actual execution
    of the program.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will present the easy parts of goroutines using easy to
    follow code examples. However, in [Chapter 10](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml)*,*
    *Goroutines - Advanced Features*, that is coming next, we will talk about more
    important and advanced techniques related to goroutines and channels; so, make
    sure that you fully understand this chapter before reading the next one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, this chapter will tell you about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating goroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing goroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About channels and how to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing to channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the Go code of the `wc.go` utility from [Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml),
    *File Input and Output*, in order to use goroutines in the new implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the goroutine version of `wc.go` even further
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About goroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **goroutine** is the minimum Go entity that can be executed concurrently.
    Note that the use of the word *minimum* is very important here because goroutines
    are not autonomous entities. Goroutines live in threads that live in Unix processes.
    Putting it simply, processes can be autonomous and exist on their own, whereas
    both goroutines and threads cannot. So, in order to create a goroutine, you will
    need to have a process with at least one thread. The good thing is that goroutines
    are lighter than threads, which are lighter than processes. Everything in Go is
    executed using goroutines, which makes perfect sense since Go is a concurrent
    programming language by design. As you have just learned, when a Go program starts
    its execution, its single goroutine calls the `main()` function, which starts
    the actual program execution.
  prefs: []
  type: TYPE_NORMAL
- en: You can define a new goroutine using the `go` keyword followed by a function
    name or the full definition of an anonymous function. The `go` keyword starts
    the function argument to it in a new goroutine and allows the invoking function
    to continue on by itself.
  prefs: []
  type: TYPE_NORMAL
- en: However, as you will see, you cannot control or make any assumptions about the
    order your goroutines are going to get executed because this depends on the scheduler
    of the operating system as well as the load of the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency and parallelism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very common misconception is that **concurrency** and **parallelism** refer
    to the same thing, which is far from true! Parallelism is the simultaneous execution
    of multiple things, whereas concurrency is a way of structuring your components
    so that they can be independently executed when possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Only when you build things concurrently you can safely execute them in parallel:
    when and if your operating system and your hardware permit it. The Erlang programming
    language did this a long time ago, long before CPUs had multiple cores and computers
    had lots of RAM.'
  prefs: []
  type: TYPE_NORMAL
- en: In a valid concurrent design, adding concurrent entities makes the whole system
    run faster because more things can run in parallel. So, the desired parallelism
    comes from a better concurrent expression and implementation of the problem. The
    developer is responsible for taking concurrency into account during the design
    phase of a system and benefit from a potential parallel execution of the components
    of the system. So, the developer should not think about parallelism, but about
    breaking things into independent components that solve the initial problem when
    combined.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you cannot run your functions in parallel on a Unix machine, a valid
    concurrent design will still improve the design and the maintainability of your
    programs. In other words, concurrency is better than parallelism!
  prefs: []
  type: TYPE_NORMAL
- en: The sync Go packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sync` Go package contains functions that can help you synchronize goroutines;
    the most important functions of `sync` are `sync.Add`, `sync.Done`, and `sync.Wait`.
    The synchronization of goroutines is a mandatory task for every programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the synchronization of goroutines has nothing to do with shared variables
    and shared state. Shared variables and shared state have to do with the method
    you want to use for performing concurrent interactions.
  prefs: []
  type: TYPE_NORMAL
- en: A simple example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this subsection, we will present a simple program that creates two goroutines.
    The name of the sample program will be `aGoroutine.go` and will be presented in
    three parts; the first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Apart from the expected `package` and `import` statements, you can see the implementation
    of a function named `namedFunction()` that sleeps for a while before printing
    a message on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `aGoroutine.go` contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you create a goroutine that executes the `namedFunction()` function.
    The last part of this naive program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, you create another goroutine that executes an anonymous function that
    contains a single `fmt.Println()` statement.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, goroutines that run this way are totally isolated from each
    other and cannot exchange any kind of data, which is not always the operational
    style that is desired.
  prefs: []
  type: TYPE_NORMAL
- en: If you forget to call the `time.Sleep()` function in the `main()` function,
    or if `time.Sleep()` sleeps for a small amount of time, then `main()` will finish
    too early and the two goroutines will not have enough time to start and therefore
    finish their jobs; as a result, you will not see all the expected output on your
    screen!
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `aGoroutine.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating multiple goroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This subsection will show you how to create many goroutines and the problems
    that arise from having to handle more goroutines. The name of the program will
    be `moreGoroutines.go` and will be presented in three parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `moreGoroutines.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of the program has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This time, the anonymous function takes a parameter named `x`, which has the
    value of the `i` variable. The `for` loop that uses the `i` variable creates ten
    goroutines, one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once again, if you put a smaller value as the parameter to `time.Sleep()`, you
    will see different results when you execute the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `moreGoroutines.go` will generate a somehow strange output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the big surprise comes when you execute `moreGoroutines.go` multiple
    times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all previous outputs of the program are different from the first
    one! So, not only the output is not coordinated and there is not always enough
    time for all goroutines to get executed; you cannot be sure about the order the
    goroutines will get executed. However, although you cannot do anything about the
    latter problem because the order that goroutines get executed depends on various
    parameters that the developer cannot control, the next subsection will teach you
    how to synchronize goroutines and give them enough time to finish without having
    to call `time.Sleep()`.
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for goroutines to finish their jobs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This subsection will demonstrate to you the correct way to make a calling function
    that wait for its goroutines to finish their jobs. The name of the program will
    be `waitGR.go` and will be presented in four parts; the first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing special here apart from the absence of the `time` package and
    the addition of the `sync` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, you create a new variable with a type of `sync.WaitGroup`, which waits
    for a group of goroutines to finish. The number of goroutines that belong to that
    group is defined by one or multiple calls to the `sync.Add()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Calling `sync.Add()` before the Go statement in order to prevent race conditions
    is important.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `sync.Add(10)` call tells our program that we will wait for
    ten goroutines to finish.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you create the desired number of goroutines using a `for` loop, but you
    could have used multiple sequential Go statements. When each goroutine finishes
    its job, the `sync.Done()` function is executed: the use of the `defer` keyword
    right after the function definition tells the anonymous function to automatically
    call `sync.Done()` just before it finishes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `waitGR.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The good thing here is that there is no need to call `time.Sleep()` because
    `sync.Wait()` does the necessary waiting for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, it should be noted here that you should not make any assumptions
    about the order the goroutines will get executed in which is also verified by
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you call `waitGroup.Add()` more times than needed, you will get the following
    error message when you execute `waitGR.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This happens because when you tell your program to wait for n+1 goroutines by
    calling `sync.Add(1)` n+1 times, your program cannot have only n goroutines (or
    less)! Putting it simply, this will make `sync.Wait()` to wait indefinitely for
    one or more goroutines to call `sync.Done()` without any luck, which is obviously
    a deadlock situation that prevents your program from finishing.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dynamic number of goroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This time, the number of goroutines that will be created will be given as a
    command-line argument: the name of the program will be `dynamicGR.go` and will
    be presented in four parts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `dynamicGR.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of `dynamicGR.go` contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `waitGroup.Add(1)` statement is called just before you create
    a new goroutine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the Go code of `dynamicGR.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding part, each simplistic goroutine is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, you just tell the program to wait for all goroutines to finish using the
    `waitGroup.Wait()` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The execution of `dynamicGR.go` requires an integer parameter, which is the
    number of goroutines you want to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can imagine, the more goroutines you want to create, the more diverse
    outputs you will have because there is no way to control the order that the goroutines
    of a program are going to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: About channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **channel**, putting it simply, is a communication mechanism that allows goroutines
    to exchange data. However, some rules exist here. First, each channel allows the
    exchange of a particular data type, which is also called the **element type**
    of the channel, and second, for a channel to operate properly, you will need to
    use some Go code to receive what is sent via the channel.
  prefs: []
  type: TYPE_NORMAL
- en: You should declare a new channel using the `chan` keyword and you can close
    a channel using the `close()` function. Additionally, as each channel has its
    own type, the developer should define it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last, a very important detail: when you are using a channel as a function parameter,
    you can specify its direction, that is, whether it will be used for writing or
    reading. In my opinion, if you know the purpose of a channel in advance, use this
    capability because it will make your program more robust as well as safer: otherwise,
    just do not define the purpose of the channel function parameter. As a result,
    if you declare that a channel function parameter will be used for reading only
    and you try to write to it, you will get an error message that will most likely
    save you from nasty bugs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The error message you will get when you try to read from a write channel will
    be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Writing to a channel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this subsection, you will learn how to write to a channel. The presented
    program will be called `writeChannel.go` and you will see it in three parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part has the expected preamble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can understand, the use of channels does not require any extra Go packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `writeChannel.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Although the `writeChannel()` function writes to the channel, the data will
    be lost because currently nobody reads the channel in the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the program contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see the definition of a channel variable named `c` with the help
    of the `chan` keyword that is used for the `int` data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `writeChannel.go` will create the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not what you expected to see! The cause of this unpredicted output
    is that the second `fmt.Println(x)` statement was not executed. The reason for
    this is pretty simple: the `c <- x` statement is blocking the execution of the
    rest of the `writeChannel()` function because nobody is reading from the `c` channel.'
  prefs: []
  type: TYPE_NORMAL
- en: Reading from a channel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This subsection will improve the Go code of `writeChannel.go` by allowing you
    to read from a channel. The presented program will be called `readChannel.go`
    and be presented in four parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of `readChannel.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Once again, note that if nobody collects the data written to a channel, the
    function that sent it will stall while waiting for someone to read its data. However,
    in [Chapter 10](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml)*,* *Goroutines - Advanced
    Features*, you will see a very pretty solution to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `<-c` statement in the `fmt.Println()` function is used for reading
    a single value from the channel: the same statement can be used for storing the
    value of a channel into a variable. However, if you do not store the value you
    read from a channel, it will be lost.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `readChannel.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, you see a technique that allows you to find out whether the channel that
    you want to read from is closed or not. However, if the channel was open, the
    presented Go code will discard the read value of the channel because of the use
    of the `_` character in the assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `readChannel.go` will create the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Explaining h1s.go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 8](defd267a-724b-4983-a51f-7cda6bba93aa.xhtml)*,* *Processes and
    Signals*, you saw how Go handles Unix signals using many examples including `h1s.go`.
    However, now that you understand more about goroutines and channels, it is time
    to explain the Go code of `h1s.go` a little more.
  prefs: []
  type: TYPE_NORMAL
- en: As you already know that `h1s.go` uses channels and goroutines, it should be
    clear now that the anonymous function that is executed as a goroutine reads from
    the `sigs` channel using an infinite `for` loop. This means that each time there
    is a signal that interests us, the goroutine will read it from the `sigs` channel
    and handle it.
  prefs: []
  type: TYPE_NORMAL
- en: Pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go programs rarely use a single channel. One very common technique that uses
    multiple channels is called a **pipeline**. So, a pipeline is a method for connecting
    goroutines so that the output of a goroutine becomes the input of another with
    the help of channels. The benefits of using pipelines are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits you get from using pipelines is that there is a constant
    flow in your program because nobody waits for everything to be completed in order
    to start the execution of goroutines and channels of the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, you are using less variables and therefore less memory space because
    you do not have to save everything
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last, the use of pipelines simplifies the design of the program and improves
    its maintainability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code of `pipelines.go`, which works with a pipeline of integers, will be
    presented in five parts; the first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you define a function that takes three arguments: two integers and one
    output channel. The output channel will be used for writing data that will be
    read in another function: this is how a pipeline is created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This time, the function takes two arguments that are both channels. However,
    `out` is an output channel, whereas `in` is an input channel used for reading
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part contains the definition of another function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The last function of `pipelines.go` takes just one argument, which is a channel
    used for reading data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `pipelines.go` is the implementation of the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `main()` function firstly reads its two command-line arguments and
    creates the necessary channel variables (`naturals` and `squares`). Then, it calls
    the functions of the pipeline: note that the last function of the channel is not
    being executed as a goroutine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows a graphical representation of the pipeline used
    in `pipelines.go` in order to the way this particular pipeline works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6d2874d-12a1-4441-b5a1-f2af5c0056fe.png)'
  prefs: []
  type: TYPE_IMG
- en: A graphical representation of the pipeline structure used in pipelines.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `pipelines.go` generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: A better version of wc.go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we talked about in [Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml)*,*
    *File Input and Output*, in this chapter, you will learn how to create a version
    of `wc.go` that uses goroutines. The name of the new utility will be `dWC.go`
    and will be presented in four parts. Note that the current version of `dWC.go`
    considers each command-line argument as a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the utility is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `count()` function does all the processing without returning any information
    to the `main()` function: it just prints the lines, words, and characters of its
    input file and exits. Although the current implementation of the `count()` function
    does the desired job, it is not the correct way to design a program because there
    is no way to control its output of the program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the utility is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of `dWC.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, each input file is being processed by a different goroutine.
    As expected, you cannot make any assumptions about the order the input files will
    be processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `dWC.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that although the `doesnotExist` filename is the last command-line
    argument, it is the first one in the output of `dWC.go`!
  prefs: []
  type: TYPE_NORMAL
- en: Although `dWC.go` uses goroutines, there is no cleverness in it because goroutines
    run without communicating with each other and without performing any other tasks.
    Additionally, the output might get scrambled because there is no guarantee that
    the `fmt.Printf()` statements of the `count()` function will not get interrupted.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the forthcoming section as well as some of the techniques that
    will be presented in [Chapter 10](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml)*,*
    *Goroutines - Advanced Features*, will improve `dWC.go`.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating totals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The current version of `dWC.go` cannot calculate totals, which can be easily
    solved by processing the output of `dWC.go` with `awk`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Still, this is far from being perfect and elegant!
  prefs: []
  type: TYPE_NORMAL
- en: The main reason that the current version of `dWC.go` cannot calculate totals
    is that its goroutines have no way of communicating with each other. This can
    be easily solved with the help of channels and pipelines. The new version of `dWC.go`
    will be called `dWCtotal.go` and will be presented in five parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `dWCtotal.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, a new `struct` type is defined. The new structure is called `File` and
    has four fields and an additional field for keeping error messages. This is the
    correct way for a pipeline to circulate multiple values. One might argue that
    a better name for the `File` structure would have been `Counts`, `Results`, `FileCounts`,
    or `FileResults`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: A better name of the `process()` function would have been `beginProcess()` or
    `processResults()`. You can try to make that change on your own throughout the
    `dWCtotal.go` program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `dWCtotal.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Although the `count()` function still calculates the counts, it does not print
    them. It just sends the counts of lines, words, and characters as well as the
    filename to another channel using a `struct` variable of the `File` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'There exists one very important detail here, which is the last statement of
    the `count()` function: in order to properly end a pipeline, you should close
    all involved channels, starting from the first one. Otherwise, the execution of
    the program will fail with an error message similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: However, as far as closing the channels of a pipeline is concerned, you should
    also be careful about closing channels too early, especially when there are splits
    in a pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part of the program contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing special here: the `calculate()` function does the dirty job
    of printing the output of the program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `dWCtotal.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Since the `files` channel is only used for passing around filenames, it could
    have been a `string` channel instead of a `File` channel. However, this way the
    code is more consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now `dWCtotal.go` automatically generates totals even if it has to process
    just one file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that both `dWCtotal.go` and `dWC.go` implement the same core functionality,
    which is counting the words, characters, and lines of a file: it is the way the
    information is handled that is different because `dWCtotal.go` uses a pipeline
    and not isolated goroutines.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 10](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml)*,* *Goroutines - Advanced
    Features*, will use other techniques to implement the functionality of `dWCtotal.go`.'
  prefs: []
  type: TYPE_NORMAL
- en: Doing some benchmarking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will compare the performance of `wc.go` from [Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml)*,*
    *File Input and Output**,* with the performance of `wc(1)`, `dWC.go` and `dWCtotal.go`.
    In order for the results to be more accurate, all three utilities will process
    relatively big files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the `time(1)` utility will measure the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows a graphical representation of the real field from
    the output of the `time(1)` utility when used to measure the aforementioned commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de995173-8729-4a8b-8960-775d6436074c.png)'
  prefs: []
  type: TYPE_IMG
- en: Plotting the real field of the time(1) utility
  prefs: []
  type: TYPE_NORMAL
- en: The original `wc(1)` utility is by far the fastest of all. Additionally, `dWC.go`
    is faster than both `dWCtotal.go` and `wc.go`. Apart from `dWC.go`, the remaining
    two Go versions have the same performance.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a pipeline that reads text files, finds the number of occurrences of
    a given word, and calculates the total number of occurrences of the word in all
    files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to make `dWCtotal.go` faster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a simple Go program that plays ping pong using channels. You should define
    the total number of pings and pongs using a command-line argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about creating and synchronizing goroutines as well
    as about creating and using pipelines and channels to allow goroutines to communicate
    with each other. Additionally, we developed two versions of the `wc(1)` utility
    that use goroutines to process their input files.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you fully understand the concepts of this chapter before continuing
    with the next chapter because in the next chapter, we will talk about more advanced
    features related to goroutines and channels including shared memory, buffered
    channels, the `select` keyword, the `GOMAXPROCS` environment variable, and signal
    channels.
  prefs: []
  type: TYPE_NORMAL
