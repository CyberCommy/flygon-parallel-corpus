- en: Understanding the Fundamentals of Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible is, at its heart, a simple framework that pushes a small program called
    an **Ansible module** to target nodes. Modules are at the heart of Ansible and
    are responsible for performing all of the automation''s hard work. The Ansible
    framework goes beyond this, however, and also includes plugins and dynamic inventory
    management, as well as tying all of this together with playbooks to automate infrastructure
    provisioning, configuration management, application deployment, network automation,
    and much more, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/075a1fbf-b62c-4730-8456-c81515ebb75c.png)'
  prefs: []
  type: TYPE_IMG
- en: Ansible only needs to be installed on the management node; from there, it distributes
    the required modules over the network's transport layer (usually SSH or WinRM)
    to perform tasks and deletes them once the tasks are complete. In this way, Ansible
    retains its agentless architecture and does not clutter up your target nodes with
    code that might be required for a one-off automation task.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn more about the composition of the Ansible framework
    and its various components, as well as how to use them together in playbooks written
    in YAML syntax. So, you will learn how to create automation code for your IT operations
    tasks and learn how to apply this using both ad hoc tasks and more complex playbooks.
    Finally, you will learn how Jinja2 templating allows you to repeatably build dynamic
    configuration files using variables and dynamic expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting familiar with the Ansible framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the configuration file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command-line arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Jinja2 filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you have successfully installed the latest version
    of Ansible (2.9, at the time of writing) onto a Linux node, as discussed in [Chapter
    1](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml), *Getting Started with Ansible*.
    It also assumes that you have at least one other Linux host to test automation
    code on; the more hosts you have available, the more you will be able to develop
    the examples in this chapter and learn about Ansible. SSH communication between
    the Linux hosts is assumed, as is a working knowledge of them.
  prefs: []
  type: TYPE_NORMAL
- en: The code bundle for this chapter is available at [https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%202](https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%202).
  prefs: []
  type: TYPE_NORMAL
- en: Getting familiar with the Ansible framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will understand how the Ansible framework fits into IT
    operations automation. We will explain how to start Ansible for the first time.
    Once you understand this framework, you will be ready to start learning more advanced
    concepts, such as creating and running playbooks with your own inventory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to run Ansible''s ad hoc commands via an SSH connection from your
    Ansible control machine to multiple remote hosts, you need to ensure you have
    the latest Ansible version installed on the control host. Use the following command
    to confirm the latest Ansible version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You also need to ensure SSH connectivity with each remote host that you will
    define in the inventory. You can use a simple, manual SSH connection on each of
    your remote hosts to test the connectivity, as Ansible will make use of SSH during
    all remote Linux-based automation tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, we will walk you through how Ansible works, starting with
    some simple connectivity testing. You can learn how the Ansible framework accesses
    multiple host machines to execute your tasks by following this simple procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create or edit your default inventory file, `/etc/ansible/hosts` (you can also
    specify the path with your own inventory file by passing options such as `–-inventory=/path/inventory_file`).
    Add some example hosts to your inventory—these must be the IP addresses or hostnames
    of real machines for Ansible to test against. The following are examples from
    my network, but you need to substitute these for your own devices. Add one hostname
    (or IP address) per line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'All hosts should be specified with a resolvable address—that is, a **Fully
    Qualified Domain Name** (**FQDN**)—if your hosts have DNS entries (or are in `/etc/hosts`
    on your Ansible control node). This can be IP addresses if you do not have DNS
    or host entries set up. Whatever format you choose for your inventory addresses,
    you should be able to successfully ping each host. See the following output as
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the automation process seamless, we''ll generate an SSH authentication
    key pair so that we don''t have to type in a password every time we want to run
    a playbook. If you do not already have an SSH key pair, you can generate one using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the `ssh-keygen` tool, you will see an output similar to the following.
    Note that you should leave the `passphrase` variable blank when prompted; otherwise,
    you will need to enter a passphrase every time you want to run an Ansible task,
    which removes the convenience of authenticating with SSH keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Although there are conditions that your SSH keys are automatically picked up
    with, it is recommended that you make use of `ssh-agent` as this allows you to
    load multiple keys to authenticate against a variety of targets. This will be
    very useful to you in the future, even if it isn''t right now. Start `ssh-agent` and
    add your new authentication key, as follows (note that you will need to do this
    for every shell that you open):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '4\. Before you can perform key-based authentication with your target hosts,
    you need to apply the public key from the key pair you just generated to each
    host. You can copy the key to each host, in turn, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '5\. With this complete, you should now be able to perform an Ansible `ping` command
    on the hosts you put in your inventory file. You will find that you are not prompted
    for a password at any point as the SSH connections to all the hosts in your inventory
    are authenticated with your SSH key pair. So, you should see an output similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This example output is generated with Ansible''s default level of verbosity.
    If you run into problems during this process, you can increase Ansible''s level
    of verbosity by passing one or more `-v` switches to the `ansible` command when
    you run it. For most issues, it is recommended that you use `-vvvv`, which gives
    you ample debugging information, including the raw SSH commands and the output
    from them. For example, assume that a certain host (such as `backend2.example.com`)
    can''t be connected to and you receive an error similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that even Ansible recommends the use of the `-vvvv` switch for debugging.
    This could potentially produce pages of output but will include many useful details,
    such as the raw SSH command that was used to generate the connection to the target
    host in the inventory, along with any error messages that may have resulted from
    that call. This can be incredibly useful when debugging connectivity or code issues,
    although the output might be a little overwhelming at first. However, with some
    practice, you will quickly learn to interpret it.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should have a good idea of how Ansible communicates with its clients
    over SSH. Let's proceed to the next section, where we will look in more detail
    at the various components that make up Ansible, as this will help us understand
    how to work with it better.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down the Ansible components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible allows you to define policies, configurations, task sequences, and orchestration
    steps in playbooks—the limit is really only your imagination. A playbook can be
    executed to manage your tasks either synchronously or asynchronously on a remote
    machine, although you will find that most examples are synchronous. In this section,
    you will learn about the main components of Ansible and understand how Ansible
    employs those components to communicate with remote hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand the various components, we first need an inventory to
    work from. Let''s create an example one, ideally with multiple hosts in it—this
    could be the same as the one you created in the previous section. As discussed
    in that section, you should populate the inventory with the hostnames or IP addresses
    of the hosts that you can reach from the control host itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To really understand how Ansible—as well as its various components—works, we
    first need to create an Ansible playbook. While the ad hoc commands that we have
    experimented with so far are just single tasks, playbooks are organized groups
    of tasks that are (usually) run in sequence. Conditional logic can be applied
    and in any other programming language, they would be considered your code. At
    the head of the playbook, you should specify the name of your play—although this
    is not mandatory, it is good practice to name all your plays and tasks as without
    this, it would be quite hard for someone else to interpret what the playbook does,
    or even for you to if you come back to it after a period of time. Let''s get started
    with building our first example playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specify the play name and inventory hosts to run your tasks against at the
    very top of your playbook. Also, note the use of `---`, which denotes the beginning
    of a YAML file (Ansible playbooks that are written in YAML):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we will tell Ansible that we want to perform all the tasks in this
    playbook as a superuser (usually `root`). We do this with the following statement
    (to aid your memory, think of `become` as shorthand for `become superuser`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After this header, we will specify a task block that will contain one or more
    tasks to be run in sequence. For now, we will simply create one task to update
    the version of Apache using the `yum` module (because of this, this playbook is
    only suitable for running against RHEL-, CentOS-, or Fedora-based hosts). We will
    also specify a special element of the play called a handler. Handlers will be
    covered in greater detail in [Chapter 4](2f8c4f41-8a8d-4f23-9df2-6979159e5992.xhtml),
    *Playbooks and Roles*, so don''t worry too much about them for now. Simply put,
    a handler is a special type of task that is called only if something changes.
    So, in this example, it restarts the web server, but only if it changes, preventing
    unnecessary restarts if the playbook is run several times and there are no updates
    for Apache. The following code performs these functions exactly and should form
    the basis of your first playbook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Congratulations, you now have your very first Ansible playbook! If you run
    this now, you should see it iterate through all the hosts in your inventory, as
    well as on each update in the Apache package, and then restart the service where
    the package was updated. Your output should look something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you examine the output from the playbook, you can see the value in naming
    not only the play but also each task that is executed, as it makes interpreting
    the output of the run a very simple task. You will also see that there are multiple
    possible results from running a task; in the preceding example, we can see two
    of these results—`ok` and `changed`. Most of these results are fairly self-explanatory,
    with `ok` meaning the task ran successfully and that nothing changed as a result
    of the run. An example of this in the preceding playbook is the `Gathering Facts`
    stage, which is a read-only task that gathers information about the target hosts.
    As a result, it can only ever return `ok` or a failed status, such as `unreachable`,
    if the host is down. It should never return `changed`.
  prefs: []
  type: TYPE_NORMAL
- en: However, you can see in the preceding output that all three hosts need to upgrade
    their Apache package and, as a result of this, the results from the `Update the
    latest of an Apache Web Server` task is `changed` for all the hosts. This `changed`
    result means that our `handler` variable is notified and the web server service
    is restarted.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the playbook a second time, we know that it is very unlikely that
    the Apache package will need upgrading again. Notice how the playbook output differs this
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can see that this time, the output from the `Update the latest of an Apache
    Web Server` task is `ok` for all three hosts, meaning no changes were applied
    (the package was not updated). As a result of this, our handler is not notified
    and does not run—you can see that it does not even feature in the preceding playbook
    output. This distinction is important—the goal of an Ansible playbook (and the
    modules that underpin Ansible) should be to only make changes when they need to
    be made. If everything is all up to date, then the target host should not be altered.
    Unnecessary restarts to services should be avoided, as should unnecessary alterations
    to files. In short, Ansible playbooks are (and should be) designed to be efficient
    and to achieve a target machine state.
  prefs: []
  type: TYPE_NORMAL
- en: This has very much been a crash course on writing your first playbook, but hopefully,
    it gives you a taste of what Ansible can do when you move from single ad hoc commands
    through to more complex playbooks. Before we explore the Ansible language and
    components any further, let's take a more in-depth look at the YAML language that
    playbooks are written in.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the YAML syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to write a YAML file with the correct syntax
    and best practices and tips for running a playbook on multiple remote machines. Ansible
    uses YAML because it is easier for humans to read and write than other common
    data formats, such as XML or JSON. There are no commas, curly braces, or tags
    to worry about, and the enforced indentation in the code ensures that it is tidy
    and easy on the eye. In addition, there are libraries available in most programming
    languages for working with YAML.
  prefs: []
  type: TYPE_NORMAL
- en: This reflects one of the core goals of Ansible—to produce easy-to-read (and
    write) code that described the target state of a given host. Ansible playbooks
    are (ideally) supposed to be self-documenting, as documentation is often an afterthought
    in busy technology environments—so, what better way to document than through the
    automation system responsible for deploying code?
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into YAML structure, a word on the files themselves. Files written
    in YAML can optionally begin with `---` (as seen in the example playbook in the
    previous section) and end with `...`. This applies to all files in YAML, regardless
    of whether it is employed by Ansible or another system, and indicates that the
    file is in the YAML language. You will find that most examples of Ansible playbooks
    (as well as roles and other associated YAML files) start with `---` but do not
    end with `...`—the header is sufficient to clearly denote that the file uses the
    YAML format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the YAML language through the example playbook we created in
    the preceding section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lists are an important construct in the YAML language—in fact, although it
    might not be obvious, the `tasks:` block of the playbook is actually a YAML list.
    A list in YAML lists all of its items at the same indentation level, with each
    line starting with `-`. For example, we updated the `httpd` package from the preceding
    playbook using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we could have specified a list of packages to be upgraded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, rather than passing a single value to the `name:` key, we pass a YAML-formatted
    list containing the names of two packages to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionaries are another important concept in YAML—they are represented by
    a `key: value` format, as we have already extensively seen, but all of the items
    in the dictionary are indented by one more level. This is easiest explained by
    an example, so consider the following code from our example playbook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example (from `handler`), the `service` definition is actually a dictionary
    and both the `name` and `state` keys are indented with two more spaces than the
    `service` key. This higher level of indentation means that the `name` and `state`
    keys are associated with the `service` key, therefore, in this case, telling the
    `service` module which service to operate on (`httpd`) and what to do with it
    (restart it).
  prefs: []
  type: TYPE_NORMAL
- en: Already, we have observed in these two examples that you can produce quite complicated
    data structures by mixing lists and dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you become more advanced at playbook design (we will see examples of this
    later on in this book), you may very well start to produce quite complicated variable
    structures that you will put into their own separate files to keep your playbook
    code readable. The following is an example of a `variables` file that provides
    the details of two employees of a company:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you can see that we have a dictionary containing the details
    of each employee. The employees themselves are list items (you can spot this because
    the lines start with `-`) and equally, the employee skills are denoted as list
    items. You will notice the `fullname`, `role`, `level`, and `skills` keys are
    at the same indentation level as `name` but do not feature `-` before them. This
    tells you that they are in the dictionary with the list item itself, and so they
    represent the details of the employee.
  prefs: []
  type: TYPE_NORMAL
- en: 'YAML is very literal when it comes to parsing the language and a new line always
    represents a new line of code. What if you actually need to add a block of text
    (for example, to a variable)? In this case, you can use a literal block scalar,
    `|`, to write multiple lines and YAML will faithfully preserve the new lines,
    carriage returns, and all the whitespace that follows each line (note, however,
    that the indentation at the beginning of each line is part of the YAML syntax):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'So, if we were to get Ansible to print the preceding contents to the screen,
    it would display as follows (note that the preceding two spaces have gone—they
    were interpreted correctly as part of the YAML language and not printed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the preceding is the folded block scalar, `>`, which does the same
    as the literal block scalar but does not preserve line endings. This is useful
    for very long strings that you want to print on a single line, but also want to
    wrap across multiple lines in your code for the purpose of readability. Take the
    following variation on our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we were to print this, we would see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We could add trailing spaces to the preceding example to stop the words from
    running into each other, but I have not done this here as I wanted to provide
    you with an easy-to-interpret example.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you review playbooks, variable files, and so on, you will see these structures
    used over and over again. Although simple in definition, they are very important—a
    missed level of indentation or a missing `-` instance at the start of a list item
    can cause your entire playbook to fail to run. As we discovered, you can put all
    of these various constructs together. One additional example is provided in the
    following code block of a `variables` file for you to consider, which shows the
    various examples we have covered all in one place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also express both dictionaries and lists in an abbreviated form, known
    as **flow collections**. The following example shows exactly the same data structure
    as our original `employees` variable file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this displays exactly the same data structure, you can see how difficult
    it is to read with the naked eye. Flow collections are not used extensively in
    YAML and I would not recommend you to make use of them yourself, but it is important
    to understand them in case you come across them. You will also notice that although
    we''ve started talking about variables in YAML, we haven''t expressed any variable
    types. YAML tries to make assumptions about variable types based on the data they
    contain, so if you want assign `1.0` to a variable, YAML will assume it is a floating-point
    number. If you need to express it as a string (perhaps because it is a version
    number), you need to put quotation marks around it, which causes the YAML parser
    to interpret it as a string instead, such as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This completes our look at the YAML language syntax. Now that's complete, in
    the next section, let's take a look at ways that you can organize your automation
    code to keep it manageable and tidy.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing your automation code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can imagine, if you were to write all of your required Ansible tasks
    in one massive playbook, it would quickly become unmanageable—that is to say,
    it would be difficult to read, difficult for someone else to pick up and understand,
    and—most of all—difficult to debug when things go wrong. Ansible provides a number
    of ways for you to divide your code into manageable chunks; perhaps the most important
    of these is the use of roles. Roles (for the sake of a simple analogy) behave
    like a library in a conventional high-level programming language. We will go into
    more detail about roles in [Chapter 4](2f8c4f41-8a8d-4f23-9df2-6979159e5992.xhtml),
    *Playbooks and Roles*.
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, other ways that Ansible supports splitting your code into
    manageable chunks, which we will explore briefly in this section as a precursor
    to the more in-depth exploration of roles later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build up a practical example. To start, we know that we need to create
    an inventory for Ansible to run against. In this instance, we''ll create four
    notional groups of servers, with each group containing two servers. Our hypothetical
    example will contain a frontend server and application servers for a fictional
    application, located in two different geographic locations. Our inventory file
    will be called `production-inventory` and the example contents are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, obviously, we could just write one massive playbook to address the required
    tasks on these different hosts, but as we have already discussed, this would be
    cumbersome and inefficient. Let''s instead break the task of automating these
    different hosts down into smaller playbooks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a playbook to run a connection test on a specific host group, such as `frontends_na_zone`.
    Put the following contents into the playbook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, try running this playbook against the hosts (note that we have configured
    it to connect to a remote user on the inventory system, called `danieloh`, so
    you will either need to create this user and set up the appropriate SSH keys or
    change the user in the `remote_user` line of your playbook). When you run the
    playbook after setting up the authentication, you should see an output similar
    to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s extend our simple example by creating a playbook that will only run
    on the application servers. Again, we will use the Ansible `ping` module to perform
    a connection test, but in a real-world situation, you would perform more complex
    tasks, such as installing packages or modifying files. Specify that this playbook
    is run against this host group from the `appservers_emea_zone` inventory. Add
    the following contents to the playbook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, you need to ensure you can access these servers, so either create
    the `danieloh` user and set up authentication to that account or change the `remote_user`
    line in the example playbook. Once you have done this, you should be able to run
    the playbook and you will see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good. However, we now have two playbooks that we need to run manually,
    which only addresses two of our inventory host groups. If we want to address all
    four groups, we need to create a total of four playbooks, all of which need to
    be run manually. This is hardly reflective of best automation practices. What
    if there was a way to take these individual playbooks and run them together from
    one top-level playbook? This would enable us to divide our code to keep it manageable,
    but also prevents a lot of manual effort when it comes to running the playbooks.
    Fortunately, we can do exactly that by taking advantage of the `import_playbook`
    directive in a top-level playbook that we will call `site.yml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you run this single playbook using the (by now, familiar) `ansible-playbook`
    command, you will see that the effect is the same as if we had actually run both
    playbooks back to back. In this way, even before we explore the concept of roles,
    you can see that Ansible supports splitting up your code into manageable chunks
    without needing to run each chunk manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There's much more that you can do with geographically diverse environments,
    such as our simple example here, as we have not even touched on things such as
    placing variables in your inventory (which, for example, associates different
    parameters with different environments). We will explore this in more detail in
    [Chapter 3](1bbd0c5e-1eb1-4521-b84d-16cc07083f64.xhtml), *Defining Your Inventory*.
  prefs: []
  type: TYPE_NORMAL
- en: However, hopefully that has armed with enough knowledge so that you can start
    making informed choices about how to organize the code for your playbooks. As
    you complete further chapters of this book, you will be able to establish whether
    you wish to make use of roles or the `import_playbook` directive (or perhaps even
    both) as part of your playbook organization.
  prefs: []
  type: TYPE_NORMAL
- en: Let's carry on with our crash course on Ansible, in the next section, with a
    look at the configuration file and some of the key directives that you might find
    valuable.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the configuration file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible's behavior is, in part, defined by its configuration file. The central
    configuration file (which impacts the behavior of Ansible for all users on the
    system) can be found at `/etc/ansible/ansible.cfg`. However, this is not the only
    place Ansible will look for its configuration; in fact, it will look in the following
    locations, from the top to the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first instance of the file is the configuration it will use; all of the
    others are ignored, even if they are present:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ANSIBLE_CONFIG`: The file location specified by the value of this environment
    variable, if set'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ansible.cfg`: In the current working directory'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`~/.ansible.cfg`: In the home directory of the user'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/etc/ansible/ansible.cfg`: The central configuration that we previously mentioned'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you installed Ansible through a package manager, such as `yum` or `apt`,
    you will almost always find a default configuration file called `ansible.cfg` in
    `/etc/ansible`. However, if you built Ansible from the source or installed it
    via `pip`, the central configuration file will not exist and you will need to
    create it yourself. A good starting point is to reference the example Ansible
    configuration file that is included with the source code, a copy of which can
    be found on GitHub at [https://raw.githubusercontent.com/ansible/ansible/devel/examples/ansible.cfg](https://raw.githubusercontent.com/ansible/ansible/devel/examples/ansible.cfg).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will detail how to locate Ansible's running configuration
    and how to manipulate it. Most people who install Ansible through a package find
    that they can get a long way with Ansible before they have to modify the default
    configuration, as it has been carefully designed to work in a great many scenarios.
    However, it is important to know a little about configuring Ansible in case you
    come across an issue in your environment that can only be changed by modifying
    the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, if you don''t have Ansible installed, there''s little point in exploring
    its configuration, so let''s just check whether you have Ansible installed and
    working by issuing a command such as the following (the output shown is from the
    latest version of Ansible at the time of writing, installed on macOS with Homebrew):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get started by exploring the default configuration that is provided
    with Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command in the following code block lists the current configuration parameters
    supported by Ansible. It is incredibly useful because it tells you both the environment
    variable that can be used to change the setting (see the `env` field) as well
    as the configuration file parameter and section that can be used (see the `ini`
    field). Other valuable information, including the default configuration values
    and a description of the configuration, is given (see the `default` and `description`
    fields, respectively). All of the information is sourced from `lib/constants.py`. Run
    the following command to explore the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of the kind of output you will see. There are,
    of course, many pages to it, but a snippet is shown here as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to see a straightforward display of all the possible configuration
    parameters, along with their current values (regardless of whether they are configured
    from environment variables or a configuration file in one of the previously listed
    locations), you can run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows all the configuration parameters (in an environment variable
    format), along with the current settings. If the parameter is configured with
    its default value, you are told so (see the `(default)` element after each parameter
    name):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the effect on this output by editing one of the configuration parameters.
    Let''s do this by setting an environment variable, as follows (this command has
    been tested in the `bash` shell, but may differ for other shells):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s re-run the `ansible-config` command, but this time get it to tell
    us only the parameters that have been changed from their default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that `ansible-config` tells us that we have only changed `ANSIBLE_FORCE_COLOR`
    from the default value, that it is set to `True`, and that we set it through an
    `env` variable. This is incredibly valuable, especially if you have to debug configuration
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with the Ansible configuration file itself, you will note that
    it is in INI format, meaning it has sections such as `[defaults]`, parameters
    in the format `key = value`, and comments beginning with either `#` or `;`. You
    only need to place the parameters you wish to change from their defaults in your
    configuration file, so if you wanted to create a simple configuration to change
    the location of your default inventory file, it might look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As discussed earlier, one of the possible valid locations for the `ansible.cfg`
    configuration file is in your current working directory. It is likely that this
    is within your home directory, so on a multi-user system, we strongly recommend
    you restrict access to the Ansible configuration file to your user account alone.
    You should take all the usual precautions when it comes to securing important
    configuration files on a multi-user system, especially as Ansible is normally
    used to configure multiple remote systems and so, a lot of damage could be done
    if a configuration file is inadvertently compromised!
  prefs: []
  type: TYPE_NORMAL
- en: Of course, Ansible's behavior is not just controlled by the configuration files
    and switches—the command-line arguments that you pass to the various Ansible executables
    are also of vital importance. In fact, we have already worked with one already—in
    the preceding example, we showed you how to change where Ansible looks for its
    inventory file using the `inventory` parameter in `ansible.cfg`. However, in many
    of the examples that we previously covered in this book, we overrode this with
    the `-i` switch when running Ansible. So, let's proceed to the next section to
    look at the use of command-line arguments when running Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Command-line arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you will learn about the use of command-line arguments for
    playbook execution and how to employ some of the more commonly used ones to your
    advantage. We are already very familiar with one of these arguments, the `--version`
    switch, which we use to confirm that Ansible is installed (and which version is
    installed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as we were able to learn about the various configuration parameters directly
    through Ansible, we can also learn about the command-line arguments. Almost all
    of the Ansible executables have a `--help` option that you can run to display
    the valid command-line parameters. Let''s try this out now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view all the options and arguments when you execute the `ansible` command
    line. Use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see a great deal of helpful output when you run the preceding command;
    an example of this is shown in the following code block (you might want to pipe
    this into a pager, such as `less`, so that you can read it all easily):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We could take one example from the preceding code to build on our previous
    use of `ansible`; so far, we have almost exclusively used it to run ad hoc tasks
    with the `-m` and `-a` parameters. However, `ansible` can also perform useful
    tasks such as telling us about the hosts in a group within our inventory. We could
    explore this using the `production-inventory` file we used earlier in this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this, you should see the members of the `appservers_emea_zone`
    inventory group listed. Although perhaps a little contrived, this example is incredibly
    valuable when you start working with dynamic inventory files and you can no longer
    just `cat` your inventory file to the terminal to view the contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The same is true for the `ansible-playbook` executable file, too. We have already
    seen a few of these in the previous examples of this book and there''s more that
    we can do. For example, earlier, we discussed the use of `ssh-agent` to manage
    multiple SSH authentication keys. While this makes running playbooks simple (as
    you don''t have to pass any authentication parameters to Ansible), it is not the
    only way of doing this. You can use one of the command-line arguments for `ansible-playbook`
    to specify the private SSH key file, instead, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, in the preceding section, we specified the `remote_user` variable
    for Ansible to connect with in the playbook. However, command-line arguments can
    also set this parameter for the playbook; so, rather than editing the `remote_user`
    line in the playbook, we could remove it altogether and instead have run it using
    the following command-line string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The ultimate aim of Ansible is to make your life simpler and to remove mundane
    day-to-day tasks from your list. As a result, there is no right or wrong way to
    do this—you can specify your private SSH key using a command-line argument or
    make it available using `ssh-agent`. Similarly, you can put the `remote_user`
    line in your playbook or user the `--user` parameter on the command line. Ultimately,
    the choice is yours, but it is important to consider that if you are distributing
    a playbook to multiple users and they all have to remember to specify the remote
    user on the command line, will they actually remember to do it? What will the
    consequences be if they don't? If the `remote_user` line is present in the playbook,
    will that make their lives easier and be less prone to error because the user
    account has been set in the playbook itself?
  prefs: []
  type: TYPE_NORMAL
- en: As with the configuration of Ansible, you will use a small handful of the command-line
    arguments frequently and there will be many that you may never touch. The important
    thing is that you know they are there and how to find out about them, and you
    can make informed decisions about when to use them. Let's proceed to the next
    section, where we will look in a bit more detail at ad hoc commands with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ad hoc commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen a handful of ad hoc commands so far in this book, but to
    recap, they are single commands you can run with Ansible, making use of Ansible
    modules without the need to create or save playbooks. They are very useful for
    performing quick, one-off tasks on a number of remote machines or for testing
    and understanding the behavior of the Ansible modules that you intend to use in
    your playbooks. They are both a great learning tool and a quick and dirty (because
    you never document your work with a playbook!) automation solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with every Ansible example, we need an inventory to run against. Let''s
    reuse our `production-inventory` file from before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s start with perhaps the quickest and dirtiest of ad hoc commands—running
    a raw shell command on a group of remote machines. Suppose that you want to check
    that the date and time of all the frontend servers in EMEA are in sync—you could
    do this by using a monitoring tool or by manually logging into each server in
    turn and checking the date and time. However, you can also use an Ansible ad hoc
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following ad hoc command to retrieve the current date and time from
    all of the `frontends_emea_zone` servers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that Ansible faithfully logs in to each machine in turn and runs
    the `date` command, returning the current date and time. Your output will look
    something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This command is run with the user account you are logged in to when the command
    is run. You can use a command-line argument (discussed in the previous section)
    to run as a different user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that the `danieloh` user account does not have the privileges
    required to successfully run the `pvs` command. However, we can fix this by adding
    the `--become` command-line argument, which tells Ansible to become `root` on
    the remote systems:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the command still fails because although `danieloh` is in `/etc/sudoers`,
    it is not allowed to run commands as `root` without entering a `sudo` password.
    Luckily, there''s a switch to get Ansible to prompt us for this at run time, meaning
    we don''t need to edit our `/etc/sudoers` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, if you don''t specify a module using the `-m` command-line argument,
    Ansible assumes you want to use the `command` module (see [https://docs.ansible.com/ansible/latest/modules/command_module.html](https://docs.ansible.com/ansible/latest/modules/command_module.html)).
    If you wish to use a specific module, you can add the `-m` switch to the command-line
    arguments and then specify the module arguments under the `-a` switch, as in the
    following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output not only shows that the copy was performed successfully
    to both hosts but also all the output values from the `copy` module. This, again,
    can be very helpful later when you are developing playbooks as it enables you
    to understand exactly how the module works and what output it produces in cases
    where you need to perform further work with that output. This is a more advanced
    topic, however, that is beyond the scope of this introductory chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You will also note that all arguments passed to the module must be enclosed
    in quotation marks (`"`). All arguments are specified as `key=value` pairs and
    no spaces should be added between `key` and `value` (for example, `key = value`
    is not acceptable). If you need to place quotation marks around one of your argument
    values, you can escape them using the backslash character (for example, `-a "src=/etc/yum.conf
    dest=\"/tmp/yum file.conf\""`)
  prefs: []
  type: TYPE_NORMAL
- en: All examples we have performed so far are very quick to execute and run, but
    this is not always the case with computing tasks. When you have to run an operation
    for a long time, say more than two hours, you should consider running it as a
    background process. In this instance, you can run the command asynchronously and
    confirm the result of that execution later.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to execute `sleep 2h` asynchronously in the background with a
    timeout of 7,200 seconds (`-B`) and without polling (`-P`), use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the output from this command gives a unique job ID for each task
    on each host. Let''s now say that we want to see how this task proceeds on the
    second frontend server. Simply issue the following command from your Ansible control
    machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that the job has started but not finished. If we now kill
    the `sleep` command that we issued and check on the status again, we can see the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see a `FAILED` status result because the `sleep` command was killed;
    it did not exit cleanly and returned a `-15` code (see the `rc` parameter). When
    it was killed, no output was sent to either `stdout` or `stderr`, but if it had
    been, Ansible would have captured it and displayed it in the preceding code, which
    would aid you in debugging the failure. Lots of other useful information is included,
    including how long the task actually ran for, the end time, and so on. Similarly,
    the useful output is returned when the task exits cleanly.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our look at ad hoc commands in Ansible. By now, you should have
    a fairly solid grasp of the fundamentals of Ansible, but there's one important
    thing we haven't looked at yet, even though we briefly touched on it—variables
    and how to define them. We'll proceed to look at this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Defining variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover the topic of variables and how they can be defined
    in Ansible. You will learn how variables should be defined step by step and understand
    how to work with them in Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Although automation removes much of the repetition from previously manual tasks,
    not every single system is identical. If two systems differ in some minor way,
    you could write two unique playbooks—one for each system. However, this would
    be inefficient and wasteful, as well as difficult to manage as time goes on (for
    example, if the code in one playbook is changed, how can you ensure that it is
    updated in the second variant?).
  prefs: []
  type: TYPE_NORMAL
- en: Equally, you might need to use a value from one system in another—perhaps you
    need to obtain the hostname of a database server and make it available to another.
    All of these issues can be addressed with variables as they allow the same automation
    code to run with parameter variations, as well as values to pass from one system
    to another (although this must be handled with some care).
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started with a practical look at defining variables in Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables in Ansible should have well-formatted names that adhere to the following
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the variable must only include letters, underscores, and numbers—spaces
    are not allowed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the variable can only begin with a letter—they can contain numbers,
    but cannot start with one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the following are good variable names:'
  prefs: []
  type: TYPE_NORMAL
- en: '`external_svc_port`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`internal_hostname_ap1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following examples are all invalid, however, and cannot be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`appserver-zone-na`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache server ip`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dbms.server.port`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`01appserver`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As discussed in the *Learning the YAML syntax* section, variables can be defined
    in a dictionary structure, such as the following. All values are declared in key-value
    pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to retrieve a specific field from the preceding dictionary structure,
    you can use either one of the following notations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some exceptions to this; for example, you should use `bracket notation`
    if the variable name starts and ends with two underscores (for example, `__variable__`)
    or contains known public attributes, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`as_integer_ratio`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symmetric_difference`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find more information on this at [https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#creating-valid-variable-names](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#creating-valid-variable-names).
  prefs: []
  type: TYPE_NORMAL
- en: 'This dictionary structure is valuable when defining host variables; although
    earlier in this chapter we worked with a fictional set of employee records defined
    as an Ansible `variables` file, you could use this to specify something, such
    as some `redis` server parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: These could then be applied through your playbook and one common playbook could
    be used for all `redis` servers, regardless of their configuration, as changeable
    parameters such as the `port` and `master` servers are all contained in the variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also pass set variables directly in a playbook, and even pass them
    to roles that you call. For example, the following playbook code calls four hypothetical
    roles and each assigns a different value to the `username` variable for each one.
    These roles could be used to set up various administration roles on a server (or
    multiple servers), with each passing a changing list of usernames as people come
    and go from the company:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'To access variables from within a playbook, you simply place the variable name
    inside quoted pairs of curly braces. Consider the following example playbook (based
    loosely on our previous `redis` example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define a variable in the playbook itself called `redis`. This variable
    is a dictionary, containing a number of parameters that might be important for
    our server. To access the contents of these variables, we use pairs of curly braces
    around them (as described previously) and the entire string is encased in quotation
    marks, which means we don''t have to individually quote the variables. If you
    run the playbook on a local machine, you should see an output that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Although we are accessing these variables here to print them in a debug message,
    you could use the same curly brace notation to assign them to module parameters,
    or for any other purpose that your playbook requires them for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible, just like many languages, has specially reserved variables that take
    on particular meaning in playbooks. In Ansible, these are known as magic variables
    and you can find a full list of them at [https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html](https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html).
    Needless to say, you should not attempt to use any magic variable names for your
    own variables. Some common magic variables you might come across are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`inventory_hostname`: The hostname for the current host that is iterated over
    in the play'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groups`: A dictionary of the host groups in the inventory, along with the
    host membership of each group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`group_names`: A list of the groups the current host (specified by `inventory_hostname`)
    is part of'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hostvars`: A dictionary of all the hosts in the inventory and the variables
    assigned to each of them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, the host variables for all the hosts can be accessed at any point
    in the playbook using `hostvars`, even if you are only operating on one particular
    host. Magic variables are surprisingly useful in playbooks and you will rapidly
    start to find yourself using them, so it is important to be aware of their existence.
  prefs: []
  type: TYPE_NORMAL
- en: You should also note that you can specify Ansible variables in multiple locations.
    Ansible has a strict order of variable precedence and you can take advantage of
    this by setting default values for variables in a place that has low precedence
    and then overriding them later in the play. This is useful for a variety of reasons,
    especially where an undefined variable could cause havoc when a playbook is run
    (or even when the playbook would fail as a result of this). We have not yet discussed
    all of the places that variables can be stored, so the full list of variable precedence
    order is not given here.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, it can change between Ansible releases, so it is important that
    you refer to the documentation when working with and understanding variable precedence—go
    to [https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable) for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our brief overview of variables in Ansible, although we will
    see them used again in later examples in this book. Let's now round off this chapter
    with a look at Jinja2 filters, which add a whole world of power to your variable
    definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Jinja2 filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Ansible is written in Python, it inherits an incredibly useful and powerful
    templating engine called Jinja2\. We will look at the concept of templating later
    in this book, so for now, we will focus on one particular aspect of Jinja2 known
    as filtering. Jinja2 filters provide an incredibly powerful framework that you
    can use to manipulate and transform your data. Perhaps you have a string that
    you need to convert to lowercase, for example—you could apply a Jinja2 filter
    to achieve this. You can also use it to perform pattern matching, search and replace
    operations, and much more. There are many hundreds of filters for you to work
    with and in this section, we hope to empower you with a basic understanding of
    Jinja2 filters and some practical knowledge about how to apply them, as well as
    show you where to get more information about them if you wish to explore the subject
    further.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that Jinja2 operations are performed on the Ansible control
    host and only the results of the filter operation are sent to the remote hosts.
    This is done by design, both for consistency and to reduce the workload on the
    individual nodes as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore this through a practical example. Suppose we have a YAML file
    containing some data that we want to parse. We can quite easily read a file from
    the machine filesystem and capture the result using the `register` keyword (`register`
    captures the result of the task and stores it in a variable—in the case of running
    the `shell` module, it captures all the output from the command that was run).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our YAML data file might look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we could create a playbook to read this file and register the result,
    but how can we actually turn it into a variable structure that Ansible can understand
    and work with? Let''s consider the following playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The `shell` module does not necessarily run from the directory that the playbook
    is stored in, so we cannot guarantee that it will find our `multiple-document-strings.yaml`
    file. The `copy` module does, however, source the file from the current directory,
    so it is useful to use it to copy it to a known location (such as `/tmp`) for
    the `shell` module to read the file from. The `debug` module is then run in a
    `loop` module. The `loop` module is used to iterate over all of the lines of `stdout`
    from the `shell` command, as we are using two Jinja2 filters—`from_yaml_all` and
    `list`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `from_yaml_all` filter parses the source document lines as YAML and then
    the `list` filter converts the parsed data into a valid Ansible list. If we run
    the playbook, we should see Ansible''s representation of the data structure from
    within our original file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have generated a list of dictionaries that in themselves
    contain the key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this data structure was already stored in our playbook, we could take this
    one step further and use the `items2dict` filter to turn the list into true `key:
    value` pairs, removing the `key` and `value` items from the data structure. For
    example, consider this second playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run this, we can see that our data is converted into a nice neat
    set of `key: value` pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Observe the warning at the top of the playbook. Ansible displays a warning if
    you attempt to use a reserved name for a variable, as we did here. Normally, you
    should not create a variable with a reserved name, but the example here demonstrates
    both how the filter works and how Ansible will attempt to warn you if you do something
    that might cause problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in this section, we used the `shell` module to read a file and used
    `register` to store the result in a variable. This is perfectly fine, if a little
    inelegant. Jinja2 contains a series of `lookup` filters that, among other things,
    can read the contents of a given file. Let''s examine the behavior of this following
    playbook::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this, we can see that Ansible has captured the contents of the
    `/etc/hosts` file for us, without us needing to resort to the `copy` and `shell`
    modules as we did earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many other filters that you might be interested in exploring and
    a full list can be found in the official Jinja2 documentation ([https://jinja.palletsprojects.com/en/2.11.x/](https://jinja.palletsprojects.com/en/2.11.x/)).
    The following are a handful of other examples that will give you an idea of the
    kinds of things that Jinja2 filters can achieve for you, from quoting strings
    to concatenating lists to obtaining useful path information for a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: That concludes our look at Jinja2 filtering. It is a massive topic that deserves
    a book all to itself, but, as ever, I hope that this practical guide has given
    you some pointers on how to get started and where to find information.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is a very powerful and versatile automation engine that can be used
    for a wide variety of tasks. Understanding the basics of how to work it is of
    paramount importance, before addressing the more complex challenges of playbook
    creation and large-scale automation. Ansible relies on a language called YAML,
    a simple-to-read (and write) syntax that supports the rapid development of easy-to-read
    and easy-to-maintain code and inherits a number of valuable features from the
    Python language that it is written in, including Jinja2 filtering.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned the fundamentals of working with various Ansible
    programs. You then learned about the YAML syntax and the ways that you can break
    down your code into manageable chunks to make it easier to read and maintain.
    We explored the use of ad hoc commands in Ansible, variable definition and structure,
    and how to make use of Jinja2 filters to manipulate the data in your playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a more in-depth look at Ansible inventories
    and explore some of the more advanced concepts of working with them that you may
    find useful.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which component of Ansible allows you to define a block to execute task groups
    as a play?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) `handler`
  prefs: []
  type: TYPE_NORMAL
- en: B) `service`
  prefs: []
  type: TYPE_NORMAL
- en: C) `hosts`
  prefs: []
  type: TYPE_NORMAL
- en: D) `tasks`
  prefs: []
  type: TYPE_NORMAL
- en: E) `name`
  prefs: []
  type: TYPE_NORMAL
- en: Which basic syntax from the YAML format do you use to start a file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) `###`
  prefs: []
  type: TYPE_NORMAL
- en: B) `---`
  prefs: []
  type: TYPE_NORMAL
- en: C) `%%%`
  prefs: []
  type: TYPE_NORMAL
- en: D) `===`
  prefs: []
  type: TYPE_NORMAL
- en: E) `***`
  prefs: []
  type: TYPE_NORMAL
- en: True or false – in order to interpret and transform output data in Ansible,
    you need to use Jinja2 templates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) True
  prefs: []
  type: TYPE_NORMAL
- en: B) False
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To find out about more configuration variables, go to [https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
