- en: Strings, Stream Classes, and Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will cover the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating, concatenating, and transforming strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trimming whitespace from the beginning and end of strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the comfort of `std::string` without the cost of constructing `std::string`
    objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading values from user input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting all words in a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting your output with I/O stream manipulators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing complex objects from file input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filling containers from `std::istream` iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic printing with `std::ostream` iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirect output to files for specific code sections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom string classes by inheriting from `std::char_traits`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tokenizing input with the regular expression library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comfortably pretty printing numbers differently per context on the fly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catching readable exceptions from `std::iostream` errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter is devoted to string handling, parsing, and printing of arbitrary
    data. For such jobs, STL provides its *I/O stream library*. The library basically
    consists of the following classes, which are each depicted in gray boxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11e3bdf6-16ba-4b13-a4f1-07d22b52f7b8.png)'
  prefs: []
  type: TYPE_IMG
- en: The arrows show the inheritance scheme of the classes. This might look very
    overwhelming at first, but we will get to use most of these classes in this chapter
    and get familiar with them class by class. When looking at those classes in the
    C++ STL documentation, we will not find them directly with these *exact* names.
    That is because the names in the diagram are what we see as application programmers,
    but they are really mostly just typedefs of classes with a `basic_` class name
    prefix (for example, we will have an easier job searching the STL documentation
    for `basic_istream` rather than `istream`). The `basic_*` I/O stream classes are
    templates that can be specialized for different character types. The classes in
    the diagram are specialized on `char` values. We will use these specializations
    throughout the book. If we prefix those class names with the `w` character, we
    get `wistream`, `wostream`, and so on--these are the specialization typedefs for
    `wchar_t` instead of `char`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the diagram, we see `std::ios_base`. We will basically never use
    it directly, but it is listed for completeness because all other classes inherit
    from it. The next specialization is `std::ios` which embodies the idea of an object
    which maintains a stream of data, that can be in *good* state, run *empty* of
    data state (EOF), or some kind of *fail* state.
  prefs: []
  type: TYPE_NORMAL
- en: The first specializations we are going to actually use are `std::istream` and
    `std::ostream`. The `"i"` and the `"o"` prefix stand for input and output. We
    have seen them in our earliest days of C++ programming in the simplest examples
    in form of the objects `std::cout` and `std::cin` (but also `std::cerr`). These
    are instances of those classes, which are always globally available. We do data
    output via `ostream` and input via `istream`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A class which inherits from both `istream` and `ostream` is `iostream`. It
    combines both input and output capabilities. When we understand how all classes
    from the trio consisting of `istream`, `ostream` and `iostream` can be used, we
    basically are ready to immediately put all following ones to use, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ifstream`, `ofstream` and `fstream` inherit from `istream`, `ostream` and
    `iostream` respectively, but lift their capabilities to redirect the I/O from
    and to files from the computer''s *filesystem*.'
  prefs: []
  type: TYPE_NORMAL
- en: The `istringstream`, `ostringstream` and `iostringstream` work pretty analogously.
    They help build strings in memory, and/or consuming data from them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating, concatenating, and transforming strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even C++ programmers from the very old days will know about `std::string`. While
    string handling is tedious and painful in C, especially when parsing, concatenating,
    copying them, and so on, `std::string` is a real step forward regarding simplicity
    and safety.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to C++11, we don't even need to copy strings when we want to transfer
    ownership to some other function or data structure anymore because we can *move*
    them. This way, there's not much overhead involved in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: The `std::string` got a few new features here and there over the last few standard
    increments. What is completely new in C++17 is `std::string_view`. We will play
    with both a bit (but there is another recipe, which concentrates more on `std::string_view`-only
    features) to get a feeling of them and how they work in the C++17 era.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create strings and string views and do basic concatenation and transformation
    with them in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we first include header files and declare that we use the `std`
    namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s first create string objects. The most obvious way is instantiating an
    object `a` of class `string`. We control its content by giving the constructor
    a C-style string (which will be embedded in the binary as a static array containing
    characters after compiling). The constructor will copy it and make it the content
    of string object `a`. Alternatively, instead of initializing it from a C-style
    string, we can use the string literal operator `""s`. It creates a string object
    on the fly. Using that to construct object `b`, we can even use automatic type
    deduction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The strings we just created are *copying* their input from the constructor
    argument into their own buffer. In order to not copy, but *reference* the underlying
    string, we can use `string_view` instances. This class does also have a literal
    operator, and it is called `""sv`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, now let''s play with our strings and string views. For both types, there
    are `operator<<` overloads for the `std::ostream` class, so they can be printed
    comfortably:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The string class overloads `operator+`, so we can *add* two strings and get
    their concatenation as a result. This way, `"a" + "b"` results in `"ab"`. Concatenating
    `a` and `b` this way is easy. With `a` and `c`, it is not that easy, because c
    is not a `string`, but a `string_view`. We have to get the string out of `c` first,
    and this can be done by constructing a new string from `c`, and then adding it
    to `a`. At this point one could ask, "Wait, why are you copying `c` into an intermediate
    string object just in order to add it to `a`? Can''t you avoid that copy by using
    `c.data()`?" That is a nice idea, but it has a flaw--`string_view` instances do
    not have to carry zero-terminated strings. And this is a problem that can lead
    to buffer overflows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a new string, which contains all of the strings and string views
    we just created. By using `std::ostringstream`, we can *print* any variable into
    a stream object that behaves exactly like `std::cout`, but it doesn''t print to
    the shell. Instead, it prints into a *string buffer*. After we streamed all the
    variables with some separating space between them using `operator<<`, we can construct
    and print a new string object from that with `o.str()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now also transform that new string by converting all its letters to
    upper case, for example. The C library function `toupper`, which maps lower-case
    characters to upper-case characters and leaves other characters unchanged, is
    already available and can be combined with `std::transform` because a string is
    basically also an iterable container object with `char` items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program leads to the following output, which is just
    what we expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Obviously, strings can be added with the `+` operator like numbers, but that
    has nothing to do with math but results in *concatenated* strings. In order to
    mix this with `string_view`, we need to convert to `std::string` first.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is really important to note that when mixing strings and string
    views in code, we must never assume that the underlying string behind a `string_view`
    is *zero terminated*! This is why we would rather write `"abc"s + string{some_string_view}`
    than `"abc"s + some_string_view.data()`. Aside from that, `std::string` provides
    a member function, `append`, which can handle `string_view` instances, but it
    alters the string instead of returning a new one with the string view content
    appended.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::string_view` is useful, but be cautious when mixing it with strings and
    string functions. We cannot assume that they are zero-terminated, which breaks
    things quickly in a standard string environment. Fortunately, there are often
    proper function overloads, which can deal with them the right way.'
  prefs: []
  type: TYPE_NORMAL
- en: If we want to do complex string concatenation with formatting and so on, we
    should however not do that piece by piece on string instances. The `std::stringstream`,
    `std::ostringstream`, and `std::istringstream` classes are much better suited
    for this, as they enhance the memory management while appending, and provide all
    the formatting features we know from streams in general. The `std::ostringstream`
    class is what we chose in this section because we were going to create a string
    instead of parsing it. An `std::istringstream` instance could have been instantiated
    from an existing string, which we could have then comfortably parsed into variables
    of other types. If we want to combine both, `std::stringstream` is the perfect
    all-rounder.
  prefs: []
  type: TYPE_NORMAL
- en: Trimming whitespace from the beginning and end of strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Especially when obtaining strings from user input, they are often polluted with
    unneeded white space. In another recipe, we removed excess whitespace that occurred
    between words.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now have a look at strings that are surrounded by whitespace and remove
    that. The `std::string` has some nice helper functions for getting this job done.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this recipe that shows how to do this with plain string objects,
    make sure to also read the following recipe. There we will see how to avoid unnecessary
    copies or data modifications with the new `std::string_view` class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will write a helper function that identifies surrounding
    white space in a string and returns a copy without that, and then we are going
    to test it briefly.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, the header includes and using directive come first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Our function to trim whitespace surrounding a string takes a const reference
    to an existing string. It will return a new string without any surrounding whitespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `std::string` provides two handy functions, which help us a lot. The first
    is `string::find_first_not_of`, which accepts a string containing all the characters
    we want to skip over. This is, of course, whitespace, meaning the characters space
    `'' ''`, tab `''t''`, and new line, `''n''`. It returns us the first non-whitespace
    character position. If there is only whitespace in the string, it returns `string::npos`.
    This means that there is only an empty string left if we trim whitespace from
    it. So, in such a case, let''s just return an empty string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We know now where the new string has to begin, but we don''t yet know where
    it has to end. Therefore, we use the other handy string function `string::find_last_not_of`.
    It will return us the last character position in the string which is no whitespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `string::substr`, we can now return the part of the string, which is
    surrounded by whitespace but without the white space. This function takes two
    parameters--a *position* in the string to begin with and the *number of characters*
    after this position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. Let''s write a main function in which we create a string that surrounds
    a text sentence with all kinds of whitespace, in order to trim it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We print the untrimmed and trimmed versions of the string. By surrounding the
    string with brackets, it''s more obvious which whitespace belonged to it prior
    to trimming:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program yields us the output we expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we used `string::find_first_not_of` and `string::find_last_not_of`.
    Both functions accept a C-style string, which acts as a list of characters that
    should be skipped while searching a different character. If we have a string instance
    that carries the string, `"foo bar"`, and we call `find_first_not_of("bfo ")`
    on it, it will return us the value `5`, because the `'a'` character is the first
    one that is not in the `"bfo "` string. The order of the characters in the argument
    string is not important.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same functions exist with inverted logic, although we did not use them
    in this recipe: `string::find_first_of` and `string::find_last_of`.'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to iterator based functions, we need to check if these functions return
    an actual position in the string or a value that denotes that they did *not* find
    a character position fulfilling the constraints. If they did not find one, they
    return `string::npos`.
  prefs: []
  type: TYPE_NORMAL
- en: From the character positions we retrieved from these functions in our helper
    function, we built us a substring without surrounding whitespace, using `string::substring`.
    This function accepts a relative offset and a string length and then returns a
    new string instance with its own memory, which contains only that substring. For
    example, `string{"abcdef"}.substr(2, 2)` will return us a new string `"cd"`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the comfort of std::string without the cost of constructing std::string
    objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::string` class is a really useful class because it simplifies dealing
    with strings so much. A flaw is that if we want to pass around a substring of
    it, we need to pass a pointer and a length variable, two iterators, or a copy
    of the substring. We did that in the previous recipe, where we removed the surrounding
    whitespace from a string by taking a copy of the substring range that does not
    contain the surrounding whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to pass a string or a substring to a library that does not even support
    `std::string`, we can only provide a raw string pointer, which is a bit disappointing,
    because it sets us back to the old C days. Just as with the substring problem,
    a raw pointer does not carry information about the string length with it. This
    way, one would have to implement a bundle of a pointer and a string length.
  prefs: []
  type: TYPE_NORMAL
- en: In a simplified way, this is exactly what `std::string_view` is. It is available
    since C++17 and provides a way to pair a pointer to some string together with
    that string's size. It embodies the idea of having a reference type for arrays
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: If we design functions which formerly accepted `std::string` instances as parameters,
    but did not change them in a way that would require the string instances to reallocate
    the memory that holds the actual string payload, we could now use `std::string_view`
    and be more compatible with libraries that are STL-agnostic. We could let other
    libraries provide a `string_view` view on the payload strings behind their complex
    string implementations and then use that in our STL code. This way, the `string_view`
    class acts as a minimal and useful interface, which can be shared among different
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Another cool thing is that `string_view` can be used as a non-copy reference
    to substrings of larger string objects. There are a lot of possibilities to use
    it profitably. In this section, we will play around with `string_view` in order
    to get a feeling for its ups and downs. We will also see how we can hide the surrounding
    whitespace from strings by adapting string views instead of modifying or copying
    the actual string. This method avoids unnecessary copying or data modification.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to implement a function that relies on some `string_view` features,
    and then, we see how many different types we can feed into it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The header includes and using directive come first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We implement a function that accepts a `string_view` as its only argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Before doing anything with the input string, we remove any leading and trailing
    whitespace. We are not going to change the string, but the *view* on the string
    by narrowing it down to the actual non-whitespace part of the string. The `find_first_not_of`
    function will find the first character in the string, which is not space (`''
    ''`), not a tab character (`''t''`), and not a newline character (`''n''`). With
    `remove_prefix`, we advance the internal `string_view` pointer to the first non-whitespace
    character. In case the string contains only whitespace, the `find_first_not_of`
    function returns the value `npos`, which is `size_type(-1)`. As `size_type` is
    an unsigned variable, this boils down to a very large number. So, we take the
    smaller one of both: `words_begin` or the string view''s size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We do the same with trailing whitespace. The `remove_suffix` shrinks down the
    view''s size variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can print the string view and its length:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In our main function, we play around with the new `print` function by feeding
    it with completely different argument types. First, we give it a runtime `char*`
    string from the `argv` pointer. At runtime, it contains the file name of our executable.
    Then, we give it an empty `string_view` instance. We then feed it with a C-style
    static character string, and with a `""sv` literal, which constructs us a `string_view`
    on the fly. And finally, we give it an `std::string`. The nice thing is that none
    of these arguments are modified or copied in order to call the `print` function.
    No heap allocations happen. For many and/or large strings, this is very efficient:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We did not test the whitespace removal feature. So, let''s give it a string
    that has a lot of leading and trailing whitespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Another cool feature is that the strings `string_view` gives us access to do
    not have to be *zero-terminated*. If we construct a string, such as `"abc"`, without
    a trailing zero, the `print` function can still safely handle it because `string_view`
    also carries the size of the string it points to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program yields the following output. All the strings
    are correctly handled. The string we filled with lots of leading and trailing
    whitespace is correctly filtered, and the `abc` string without zero termination
    is also correctly printed without any buffer overflows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just seen that we can call a function that accepts a `string_view` argument
    with basically anything that is string like in the sense that it stores characters
    in a contiguous way. *No copy* of the underlying string was made in any of our
    `print` calls.
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to note that in our `print(argv[0])` call, the string view
    automatically determined the string length because this is a zero-terminated string
    by convention. The other way around, one cannot assume that it is possible to
    determine a `string_view` instances's data length by counting the number of items
    until a zero terminator is reached. Because of this, we must always be careful
    about where we reach around a pointer to the string view data using `string_view::data()`.
    Usual string functions mostly assume zero termination and, thus, can buffer overflow
    very badly with raw pointers to the payload of a string view. It is always better
    to use interfaces that already expect a string view.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from that, we get a lot of the luxury interface we know from `std::string`
    already.
  prefs: []
  type: TYPE_NORMAL
- en: Use `std::string_view` for passing strings or substrings where you want to avoid
    copies or heap allocations, without losing the comfort of string classes. But
    be aware of the fact that `std::string_view` drops the assumption that strings
    are zero terminated.
  prefs: []
  type: TYPE_NORMAL
- en: Reading values from user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of recipes in this book read values from an input source, such as standard
    input or a file, and do something with it. This time we concentrate only on the
    reading and learn more about error handling, which becomes important if reading
    something from a stream did *not* go well and we need to handle it other than
    terminating the whole program.
  prefs: []
  type: TYPE_NORMAL
- en: We will only read from user input in this recipe, but as soon as we know how
    to do that, we also know how to read from any other stream. User input is read
    via `std::cin`, and that is essentially an input stream object, such as instances
    of `ifstream` and `istringstream` are.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to read user input into different variables,
    and see how to handle errors, as well as how to do a little bit more complex tokenizing
    of input into useful chunks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We only need `iostream` this time. So, let''s include this single header and
    declare that we use the `std` namespace by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s first prompt the user to enter two numbers. We will parse them into
    an `int` and a `double` variable. The user can separate them with white space.
    `1 2.3`, for example, is a valid input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Parsing and error checking is done at the same time in the condition part of
    our `if` branch. Only if both the numbers could be parsed are they meaningful
    to us and we print them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If the parsing did not succeed for any reason, we tell the user that the parsing
    did not go well. The `cin` stream object is now in a *fail state* and will not
    give us other input until we clear the fail state again. In order to be able to
    parse a new input afterward, we call `cin.clear()` and drop all input we received
    until now. The dropping is done with `cin.ignore`, where we specify that we are
    dropping the maximum number of characters until we finally see a newline character,
    which is also dropped. Everything after that is interesting input again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now ask for some other input. We let the user enter names. As names
    can consist multiple words separated by spaces, the space character is not a good
    separator any longer. Therefore, we use `std::getline`, which accepts a stream
    object, such as `cin`, a string reference where it will copy the input into, and
    a separating character. Let''s choose comma (`,`) as the separating character.
    By not just using `cin` alone and by using `cin >> ws` as a stream parameter for
    `getline` instead, we can make `cin` drop any leading whitespace before any name.
    In every loop step, we print the current name, but if a name is empty, we drop
    out of the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program leads to the following output, in which we
    assumingly entered only valid inputs. The numbers are `"1 2"`, which are parsed
    correctly, and then we enter some names which are then also listed correctly.
    An empty name input in the form of two consecutive commas quits the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When running the program again, while entering bad numbers in the beginning,
    we see that the program correctly takes the other branch, drops the bad input
    and correctly continues with the name listening. Play around with the `cin.clear()`
    and `cin.ignore(...)` lines to see how that tampers with the name reading code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We did some complex input retrieval in this section. The first noticeable thing
    is that we always did the retrieval and error checking at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The result of the expression `cin >> x` is again a reference to `cin`. This
    way, we can write `cin >> x >> y >> z >> ...`. At the same time, it is possible
    to convert it into a Boolean value by using it in a Boolean context such as `if`
    conditions. The Boolean value tells us if the last read was successful. That is
    why we were able to write `if (cin >> x >> y) {...}`.
  prefs: []
  type: TYPE_NORMAL
- en: If we, for example, try to read an integer, but the input contains `"foobar"`
    as the next token, then parsing this into the integer is not possible and the
    stream object enters a *fail state*. This is only critical for the parsing attempt
    but not for the whole program. It is okay to reset it and then to try anything
    else. In our recipe program, we tried to read a list of names after a potentially
    failing attempt to read two numbers. In the case of a failing attempt to read
    those numbers in, we used `cin.clear()` to put `cin` back into a working state.
    But then, its internal cursor was still on what we typed instead of numbers. In
    order to drop this old input and clear the pipe for the names input, we used the
    very long expression, `cin.ignore(std::numeric_limits<std::streamsize>::max(),
    'n');`. This is necessary to clear whatever is in the buffer at this point, because
    we want to start with a really fresh buffer when we ask the user for a list of
    names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following loop might look strange at first, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the conditional part of the `for` loop, we use `getline`. The `getline` function
    accepts an input stream object, a string reference as an output parameter, and
    a delimiter character. By default, the delimiter character is the newline symbol.
    Here, we defined it to be the comma (`,`) character, so all the names in a list,
    such as `"john, carl, frank"`, are read individually.
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good. But what does it mean to provide the `cin >> ws` function as
    a stream object? This makes `cin` first flush all the whitespace, which lead before
    the next non-whitespace character and after the last comma. Looking back at the
    `"john, carl, frank"` example, we would get the substrings `"john"`, `" carl"`,
    and `" frank"` without using `ws`. Notice the unnecessary leading space characters
    for `carl` and `frank`? These effectively vanish because of our `ws` pretreatment
    of the input stream.
  prefs: []
  type: TYPE_NORMAL
- en: Counting all words in a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say we read a text file and we want to count the number of words in the
    text. We define that one word is a range of characters between whitespace characters.
    How do we do it?
  prefs: []
  type: TYPE_NORMAL
- en: We could count the number of spaces, for example, because there must be spaces
    between words. In the sentence, `"John has a funny little dog."`, we have five
    space characters, so we could say there are six words.
  prefs: []
  type: TYPE_NORMAL
- en: What if we have a sentence with whitespace noise, such as `" John has t anfunny
    little dog ."`? There are way too many unnecessary spaces in this string, and
    it's not even only spaces. From the other recipes in this book, we already learned
    how we can remove such excess whitespace. So, we could first preprocess the string
    into a normal sentence form and then apply the strategy of counting space characters.
    Yes, that is doable, but there is a *much* easier way. Why shouldn't we use what
    the STL already provides us?
  prefs: []
  type: TYPE_NORMAL
- en: In addition to finding an elegant solution for this problem, we will let the
    user choose if we shall count the words from the standard input or a text file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will write a one-liner function that counts the words from
    an input buffer, and let the user choose where the input buffer reads from:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s include all the necessary headers first and declare that we use the
    `std` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `wordcount` function accepts an input stream, for example, `cin`. It creates
    an `std::input_iterator` iterator, which tokenizes the strings out of the stream
    and then feeds them to `std::distance`. The `distance` parameter accepts two iterators
    as arguments and tries to determine how many incrementing steps are needed in
    order to get from one iterator position to the other. For *random access* iterators,
    this is simple because they implement the mathematical difference operation (`operator-`).
    Such iterators can be subtracted from each other like pointers. An `istream_iterator`
    however, is a *forward* iterator and must be advanced until it equals the end
    iterator. Eventually, the number of steps needed is the number of words:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In our main function, we let the user choose if the input stream will be `std::cin`
    or an input file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user launches the program in the shell together with a file name (such
    as `$ ./count_all_words some_textfile.txt`), then we obtain that filename from
    the `argv` command-line parameter array and open it, in order to feed the new
    input file stream into `wordcount`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user launched the program without any parameter, we assume that the
    input comes from standard input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s already it, so we just print the number of words we saved in the variable
    `wc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile and run the program. First, we feed the program from standard
    input without any file parameter. We can either pipe an echo call with some words
    into it or launch the program and enter some words from the keyboard. In the latter
    case, we can stop the input by pressing *Ctrl*+*D*. This is how echoing some words
    into the program looks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When launching the program with its source code file as input, it will count
    how many words it consists of:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is not much left to say; most of it has been explained while implementing
    it as this program is very short. One thing we could elaborate on a bit is the
    fact that we used `std::cin` and an `std::ifstream` instance in a completely interchangeable
    way. The `cin` is of the `std::istream` type, and `std::ifstream` inherits from
    `std::istream`. Have a look at the class inheritance diagram at the beginning
    of this chapter. This way, they are completely interchangeable, even at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Keep your code modular by using stream abstractions. This helps decouple source
    code parts and makes your code easy to test because you can just inject any other
    matching type of stream.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting your output with I/O stream manipulators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many cases, just printing out strings and numbers is not enough. Sometimes,
    numbers need to be printed as decimal numbers, sometimes as hexadecimal, and sometimes
    even as octal. Sometimes we want to see a `"0x"` prefix in front of hexadecimal
    numbers, sometimes not.
  prefs: []
  type: TYPE_NORMAL
- en: When printing floating-point numbers, there are also a lot of things we may
    want to have an influence on. Should the decimal values always be printed with
    the same precision? Should they be printed at all? Or perhaps, we want a scientific
    notation?
  prefs: []
  type: TYPE_NORMAL
- en: Apart from scientific presentation and hexadecimal, octal, and so on, we also
    want to present the user output in a tidy form. Some output can be arranged in
    tables, for example, in order to make it as readable as possible.
  prefs: []
  type: TYPE_NORMAL
- en: All these things are, of course, possible with output streams. Some of these
    settings are also important when *parsing* values from input streams. In this
    recipe, we will get a feeling of such so-called **I/O manipulators** by playing
    around with them. Sometimes, they appear tricky, so we will also get into some
    details.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will print numbers with wildly varying format settings,
    in order to get familiar with I/O manipulators:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we include all the necessary headers and declare that we use the `std`
    namespace by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a helper function that prints a single integer value with different
    styles. It accepts a padding width and a filling character for padding, which
    is set to space `'' ''` by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'With `setw`, we can set the minimum number of characters output for printing
    a number. If we print `123` with a width of `6`, for example, we get `" 123"`,
    or `"123 "`. We can control on which side the padding occurs with `std::left`,
    `std::right`, and `std::internal`. When printing numbers in the decimal form,
    `internal` looks identical to `right`. But if we print the value `0x1`, for example,
    with a width of `6` and with `internal`, we get `"0x 6"`. The `setfill` manipulator
    defines the character that will be used for padding. We will try different styles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the main function, we start using the function we just implemented. At first,
    we print the value `12345`, with a width of `15`. We do this twice, but the second
    time, we use the `''_''` character for padding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterward, we print the value `0x123abc` with the same width as before. However,
    before doing this, we apply `std::hex` and `std::showbase` to tell the output
    stream object `cout` that it should print numbers in the hexadecimal format and
    that it should prepend `"0x"` to them so that it is obvious that they are to be
    interpreted as hex:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do the same with `oct`, which tells `cout` to use the octal system for
    printing numbers. The `showbase` is still active, so `0` will be prepended to
    every printed number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'With `hex` and `uppercase`, we get the `''x''` in `"0x"` printed upper case.
    The `''abc''` in `''0x123abc''` is also upper cased:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to print `100` in the decimal format again, we have to remember
    that we switched the stream to `hex` before. By using `dec`, we can put it back
    to normal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also configure how Boolean values are printed. By default, `true` is
    printed as `1` and `false` as `0`. With `boolalpha`, we can set it to a text representation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at floating-point variables of the `float` and `double`
    types. If we print a number such as `12.3`, it is printed as `12.3`, of course.
    If we have a number such as `12.0`, the output stream will just drop the decimal
    point, which we can change with `showpoint`. Using this, the decimal point is
    always displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The representation of a floating-point number can be scientific or fixed. `scientific`
    means that the number is *normalized* to such a form that the first digit is the
    only digit before the decimal point, and then the exponent is printed, which is
    needed to multiply the number back to its actual size. For example, the value
    `300.0` would be printed as `"3.0E2"`, because `300` equals `3.0 * 10^2`. `fixed`
    reverts back to the normal decimal point notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from the notation, we can also decide with what precision a floating-point
    number is printed. Let''s create a very small value and print it with 10 digits
    after the decimal point, and once with just one digit after the decimal point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program yields us the following lengthy output. Those
    four first blocks of output are from the print helper function that tampered around
    with the `setw` and `left`/`right`/`internal` modifiers. Afterward, we played
    with the casing of base representations, Boolean representation, and floating-point
    formatting. It is a good idea to play with each of these to get familiar with
    them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All these, sometimes pretty long, `<< foo << bar` stream expressions are really
    confusing if it is not clear to the reader what each of them does. Therefore,
    let''s have a look at a table of existing formatting modifiers. They are all to
    be placed in a `input_stream >> modifier` or `output_stream << modifier` expression
    and then affect the following input or output:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `setprecision(int n)` | Sets the precision parameter when printing or parsing
    floating-point values. |'
  prefs: []
  type: TYPE_TB
- en: '| `showpoint` / `noshowpoint` | Enables or disables the printing of the decimal
    point of floating-point numbers even if they do not have any decimal places. |'
  prefs: []
  type: TYPE_TB
- en: '| `fixed` / `scientific` / `hexfloat` / `defaultfloat` | Numbers can be printed
    in a fixed style (which is the most intuitive one) or scientific style. `fixed`
    and `scientific` stand for these modes. `hexfloat` activates both modes, which
    formats floating-point numbers in hexadecimal floating-point notation. `defaultfloat`
    deactivates both modes. |'
  prefs: []
  type: TYPE_TB
- en: '| `showpos` / `noshowpos` | Enable or disable printing a `''+''` prefix for
    positive floating-point values. |'
  prefs: []
  type: TYPE_TB
- en: '| `setw(int n)` | Read or write exactly `n` characters. When reading, this
    truncates the input. When printing, padding is applied if the output would be
    shorter than `n` characters. |'
  prefs: []
  type: TYPE_TB
- en: '| `setfill(char c)` | When applying padding (see `setw`), fill the output with
    character values, `c`. The default is space (`'' ''`). |'
  prefs: []
  type: TYPE_TB
- en: '| `internal` / `left` / `right` | `left` and `right` control where the padding
    for fixed-width prints (see `setw`) occurs. `internal` puts padding characters
    in the middle between integers and their negative sign, the hex prefix and a hexadecimally
    printed value, or monetary units and values. |'
  prefs: []
  type: TYPE_TB
- en: '| `dec` / `hex` / `oct` | Integral values can be printed and parsed in the
    decimal, hexadecimal, and octal base systems. |'
  prefs: []
  type: TYPE_TB
- en: '| `setbase(int n)` | This is the numeric synonymous function to `dec`/`hex`/`oct`,
    which are equivalent if used with the values `10`/`16`/`8`. Other values reset
    the base choice to `0`, which leads to decimal printing again, or parsing based
    on the prefix of the input. |'
  prefs: []
  type: TYPE_TB
- en: '| `quoted(string)` | Prints string in quotes or parse from quoted input, and
    then drops the quotes. `string` can be a String class instance or a C-style character
    array. |'
  prefs: []
  type: TYPE_TB
- en: '| `boolalpha` / `noboolalpha` | Prints or parses Boolean values as/from alphabetical
    representation rather than `1`/`0` strings. |'
  prefs: []
  type: TYPE_TB
- en: '| `showbase` / `noshowbase` | Enables or disables base-prefixes when printing
    or parsing numbers. For `hex`, this is `0x`; for `octal` it is `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `uppercase` / `nouppercase` | Enables or disables upper casing or alphabetical
    characters when printing floating-point and hexadecimal values. |'
  prefs: []
  type: TYPE_TB
- en: The best way to get familiar with those is studying their variety a bit and
    playing with them.
  prefs: []
  type: TYPE_NORMAL
- en: When playing with them, however, we might have noticed already that most of
    these modifiers appear to be *sticky* and a few of them, not so. Sticky means
    that once applied, they appear to influence the input/output *forever* until they
    are reset again. The only non-sticky ones from this table are `setw` and `quoted`.
    They only affect the next item in the input/output. This is important to know
    because if we print some output with certain formatting, we should tidy up our
    stream object formatting settings afterward, because the next output from unrelated
    code may otherwise look crazy. Same applies to input parsing, where things can
    break with the wrong I/O manipulator options.
  prefs: []
  type: TYPE_NORMAL
- en: 'We did not really use any of those because they do not have to do anything
    with formatting, but for the reason of completeness, we should also have a look
    at some other stream state manipulators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `skipws` / `noskipws` | Enables or disables the feature of input streams
    skipping whitespace |'
  prefs: []
  type: TYPE_TB
- en: '| `unitbuf` / `nounitbuf` | Enables or disables immediate output buffer flushing
    after any output operation |'
  prefs: []
  type: TYPE_TB
- en: '| `ws` | Can be used on input streams to skip any whitespace at the head of
    the stream |'
  prefs: []
  type: TYPE_TB
- en: '| `ends` | Writes a string-terminating `''''` character into a stream |'
  prefs: []
  type: TYPE_TB
- en: '| `flush` | Immediately flushes out whatever is in the output buffer |'
  prefs: []
  type: TYPE_TB
- en: '| `endl` | Inserts a `''n''` character into an output stream and flushes the
    output |'
  prefs: []
  type: TYPE_TB
- en: From these, only `skipws`/`noskipws` and `unitbuf`/`nounitbuf` appear sticky.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing complex objects from file input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reading in individual integers, floats, and word strings is really easy, because
    the `>>` operator of input stream objects is overloaded for all these types, and
    input streams conveniently drop all in-between whitespace for us.
  prefs: []
  type: TYPE_NORMAL
- en: But what if we have a more complex structure that we want to read from an input
    stream, and if we need to read strings that contain more than one word (as they
    would normally be chunked into single words because of the whitespace skipping)?
  prefs: []
  type: TYPE_NORMAL
- en: For any type, it is possible to provide another input stream `operator>>` overload,
    and we are going to see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll define a custom data structure and provide facilities
    to read such items from input streams as standard input:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to include some headers first and for comfort, we declare that we use
    the `std` namespace by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'As a complex object example, we define a `city` structure. A city shall have
    a name, a population count, and geographic coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to be able to read such a city from a serial input stream, we need
    to overload the stream function `operator>>`. In this operator, we first skip
    all the leading whitespace with `ws`, because we do not want whitespace to pollute
    the city name. Then, we read a whole line of text input. This implies that in
    the input file, there is a whole text line only carrying the name of a city object.
    Then, after a newline character, a whitespace-separated list of numbers follows,
    indicating the population, the geographic latitude, and the longitude:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In our main function, we create a vector that can hold a range of city items.
    We fill it using `std::copy`. The input of the copy call is an `istream_iterator`
    range. By giving it the `city` struct type as a template parameter, it will use
    the `operator>>` function overload, which we just implemented:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to see whether our city parsing went right, we print what we got in
    the list. The I/O formatting, `left << setw(15) <<`, leads to the city name being
    filled with whitespace, so we get our output in a nicely readable form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The text file from which we will feed our program looks like this. There are
    four example cities with their population count and geographical coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program yields the following output, which is what
    we expected. Try to tamper around with the input file by adding some unnecessary
    whitespace before the city names in order to see how it gets filtered out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was another short recipe again. The only thing we did was creating a new
    struct `city`, then we overloaded `std::istream` iterator's `operator>>` for this
    type and that's it. This already enabled us to deserialize city items from standard
    input using `istream_iterator<city>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There might be an open question left regarding error checking. For that, let''s
    have a look at the `operator>>` implementation again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We are reading a lot of different things. What happens if one of them fails
    and the next one doesn't? Does that mean that we are potentially reading all following
    items with a bad "offset" in the token stream? No, this cannot happen. As soon
    as one of these items cannot be parsed from the input stream, the input stream
    object enters an error state and refuses to parse anything further. This means
    that if for example `c.population` or `c.latitude` cannot be parsed, the remaining
    `>>` operands just "drop through", and we leave this operator function scope with
    a half-deserialized city object.
  prefs: []
  type: TYPE_NORMAL
- en: On the caller side, we are notified by this when we write `if (input_stream
    >> city_object)`. Such a streaming expression is implicitly converted to a bool
    value when used as a conditional expression. It returns `false` if the input stream
    object is in an error state. Knowing that we can reset the stream and do whatever
    is appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we did not write such `if` conditionals ourselves because we
    let `std::istream_iterator<city>` do the deserialization. The `operator++` implementation
    of this iterator class also checks for errors while parsing. If any errors occur,
    it will refuse iterating further. In this state, it returns `true` when it is
    compared to the end iterator, which makes the `copy` algorithm terminate. This
    way, we are safe.
  prefs: []
  type: TYPE_NORMAL
- en: Filling containers from std::istream iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last recipe, we learned how we can assemble compound data structures
    from an input stream and then fill lists or vectors with those.
  prefs: []
  type: TYPE_NORMAL
- en: This time, we make it a little bit harder by filling an `std::map` from standard
    input. The problem here is that we cannot just fill a single structure with values
    and push it back into a linear container like a list or a vector is because `map`
    divides its payload into key and value parts. It is, however, not completely different,
    as we will see.
  prefs: []
  type: TYPE_NORMAL
- en: After studying this recipe, we will feel comfortable with serializing and deserializing
    complex data structures from and to character streams.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to define another structure like in the last recipe, but this
    time we are going to fill it into a map, which makes it more complicated because
    this container maps from keys to values instead of just holding all values in
    a list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we include all the needed headers and declare that we use the `std`
    namespace by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to maintain a little Internet meme database. Let''s say a meme has
    a name, a description, and the year when it was born or invented. We will save
    them in an `std::map`, where the name is the key, and the other information is
    bunched up in a struct as the value associated with the key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s first ignore the key and just implement a stream `operator>>` function
    overload for `struct meme`. We assume that the description is surrounded by quotation
    marks, followed by the year. This would look like `"some description" 2017` in
    a text file. As the description is surrounded by quotation marks, it can contain
    whitespace because we know that everything between the quotation marks belongs
    to it. By reading with `is >> quoted(m.description)`, the quotation marks are
    automatically used as delimiters and dropped afterward. This is very convenient.
    Just after that, we read the year number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, now we take the meme''s name as the key for the map into account. In order
    to insert a meme into the map, we need an `std::pair<key_type, value_type>` instance.
    `key_type` is `string`, of course, and `value_type` is `meme`. The name is allowed
    to contain spaces too, so we use the same `quoted` wrapper as for the description.
    `p.first` is the name and `p.second` is the whole `meme` structure associated
    with it. It will be fed into the other `operator>>` implementation that we just
    implemented:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, that''s it. Let''s write a main function, which instantiates a map, and
    fill that map. Because we overloaded the stream function `operator>>`, `istream_iterator`
    can deal with this type directly. We let it deserialize our meme items from standard
    input and use an `inserter` iterator in order to pump them into the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we print what we have, let''s first find out what''s the *longest* meme
    name in the map. We use `std::accumulate` for this. It gets an initial value `0u`
    (`u` for unsigned) and will visit the map element-wise in order to *merge* them
    together. In terms of `accumulate`, merging usually means *adding*. In our case,
    we want no numeric *sum* of anything, but the largest string length. In order
    to get that, we provide `accumulate` a helper function, `max_func`, which takes
    the current maximum size variable (which must be `unsigned` because string lengths
    are unsigned) and compares it to the length of the current item''s meme name string,
    in order to take the maximum of both values. This will happen for each element.
    The `accumulate` function''s final return value is the maximum meme name length:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s quickly loop through the map and print each item. We use `<< left
    << setw(width)` to get a nice table-like printing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. We need a small Internet meme database file, so let''s fill a text
    file with some examples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program with the example meme database yields the
    following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There were three specialties in this recipe. One was that we did not fill a
    normal vector or a list from a serial character stream, but a more complex container
    like `std::map`. The other was that we used those magic `quoted` stream manipulators.
    And the last was the `accumulate` call, which finds out the largest key string
    size.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the `map` part. Our `struct meme` only contains a `description`
    field and `year`. The name of the Internet meme is not part of this structure
    because it is used as the key for the map. When we insert something into a map,
    we can provide an `std::pair` with a key type and a value type. This is what we
    did. We first implemented stream `operator>>` for `struct meme`, and then we did
    the same for `pair<string, meme>`. Then we used `istream_iterator<**pair<string,
    meme>**>{cin}` to get such items out of the standard input, and fed them into
    the map using `inserter(m, end(m))`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we deserialized meme items from the stream, we allowed the names and descriptions
    to contain whitespace. This was easily possible, although we only used one line
    per meme because we *quoted* those fields. An example of the line format is as
    follows: `"Name with spaces" "Description with spaces" 123`'
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with quoted strings both in input and output, `std::quoted` is
    a great help. If we have a string, `s`, printing it using `cout << quoted(s)`
    will put it in quotes. If we deserialize a string from a stream, for example,
    via `cin >> quoted(s)`, it will read the next quotation mark, fill the string
    with what is following, and continue until it sees the next quotation mark, no
    matter how many whitespace are involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last strange looking thing was `max_func` in our accumulate call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Apparently, `max_func` accepts a `size_t` argument and another `auto-`typed
    argument which turns out to be a `pair` item from the map. This looks really weird
    at first as most binary reduction functions accept arguments of identical types
    and then merge them together with some operation, just as `std::plus` does. In
    this case, it is really different because we are not merging actual `pair` items.
    We only pick the key string length from every pair, *drop* the rest, and then
    reduce the resulting `size_t` values with the `max` function.
  prefs: []
  type: TYPE_NORMAL
- en: In the accumulate call, the first call of `max_func` gets the `0u` value we
    initially provided as the left argument and a reference to the first pair item
    on the right side. This results in a `max(0u, string_length)` return value, which
    is the left argument in the *next* call with the next pair item as the right parameter,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Generic printing with std::ostream iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is pretty easy to print anything with output streams, as the STL is already
    shipped with many useful `operator<<` overloads for the most basic types. This
    way, data structures containing items of such types can easily be printed using
    the `std::ostream_iterator` class, which we've already done quite often in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will concentrate on how to do this with a custom type, and
    what else we can do to manipulate printing via template type choices without much
    code at the caller side.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will play with `std::ostream_iterator` by enabling for combination with
    a new custom class and have a look into its implicit conversion capabilities,
    which can help us with printing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The include files come first and then we declare that we use the `std` namespace
    by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement a transformation function, which maps numbers to strings.
    It shall return `"one"` for the value `1`, `"two"` for the value `2`, and so on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We fill a hash map with the mappings we need in order to access them later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can feed the hash map''s `find` function with the argument, `i`, and
    return what it finds. If it doesn''t find anything, because there is no translation
    for a given number, we return the string, `"unknown"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Another thing with which we will play later with is `struct bork`. It only
    contains an integer and is also implicitly constructible from an integer. It has
    a `print` function, which accepts an output stream reference and prints the `"bork"`
    string repeatedly, depending on the value of its member integer `borks`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to gain convenience with `bork::print` we overload `operator<<` for
    stream objects, so they automatically call `bork::print` whenever `bork` objects
    are streamed into an output stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can finally begin implementing the actual main function. We initially
    just create a vector with some example values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Objects of type `ostream_iterator` need a template parameter, which denotes
    which type of variables they can print. If we write `ostream_iterator<**T**>`,
    it will later use `ostream& operator(ostream&, const **T**&)` for printing. This
    is exactly what we implemented before for the `bork` type, for example. This time,
    we are just printing integers, so it is `ostream_iterator<**int**>`. It shall
    use `cout` for printing, so we provide it as the constructor parameter. We go
    through our vector in a loop and assign each item `i` to the dereferenced output
    iterator. This is how stream iterators are used by STL algorithms too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the iterator we just produced is fine, but it prints the number
    without any separator. If we want a bit of separating whitespace between all printed
    items, we can provide a custom spacing string as a second parameter of the output
    stream iterator''s constructor. This way, it prints `"1, 2, 3, 4, 5, "` instead
    of `"12345"`. Unfortunately, we cannot easily tell it to drop the comma-space
    string after the last number, because the iterator does not know of its end before
    it reaches it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Assigning items to an output stream iterator in order to print them is not
    a wrong way to use it, but this is not what they were invented for. The idea is
    to use them in combination with algorithms. The simplest one is `std::copy`. We
    can provide the begin and end iterators of the vector as an input range and the
    output stream iterator as the output iterator. It will print all the numbers of
    the vector. Let''s do that with both the output iterators and later compare the
    output with the loops we wrote before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember the function, `word_num`, which maps numbers to strings, as `1` to
    `"one"`, `2` to `"two"`, and so on? Yes, we can use those for printing too. We
    just need to use an output stream operator, which is template specialized on `string`
    because we are not printing integers any longer. And instead of `std::copy`, we
    use `std::transform` because it allows us to apply a transformation function to
    each item in the input range before copying it to the output range:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The last output line in this program finally puts `struct bork` to use. We
    could, but do not provide a transformation function to `std::transform`. Instead,
    we can just create an output stream iterator, which is specialized on the `bork`
    type in an `std::copy` call. This leads to the `bork` instances being *implicitly*
    created from the input range integers. That will give us some interesting output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program yields us the following output. The first
    two lines are completely identical to the next two lines, which is what we suspected.
    Then, we get nice, written-out number strings in a line, followed by a lot of
    `bork!` strings. These occur in multiple lines because we used a `"n"` separator
    string instead of spaces for those:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen that `std::ostream_iterator` is really just a *syntax hack,* which
    kind of squeezes the act of printing into the form and syntax of an iterator.
    Incrementing such an iterator does *nothing*. Dereferencing it only returns us
    a proxy object whose assignment operator forwards its argument to an output stream.
  prefs: []
  type: TYPE_NORMAL
- en: Output stream iterators that are specialized on a type `T` (as in `ostream_iterator<T>`)
    work with all types for which an `ostream& operator<<(ostream&, const T&)` implementation
    is provided.
  prefs: []
  type: TYPE_NORMAL
- en: '`ostream_iterator` always tries to call `operator<<` for the type it was specialized
    for, via its template parameter. It will try to implicitly convert types if the
    same is allowed. When we iterate over a range of `A`-typed items but we copy those
    items over to `output_iterator<B>` instances, this will work if `A` is implicitly
    convertible to `B`. We did exactly the same thing with `struct bork`: a `bork`
    instance is implicitly convertible from an integer value. That is why it was so
    easy to throw a lot of `"bork!"` strings onto the user shell.'
  prefs: []
  type: TYPE_NORMAL
- en: If implicit conversion is not possible, we can do that ourselves, using `std::transform`,
    which is what we did in combination with the `word_num` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note that it is, in general, *bad style* to allow implicit conversions for custom
    types because this is a common *source of bugs* that are really hard to find later.
    In our example use case, the implicit constructor is more useful than dangerous
    because the class is used for nothing else but printing.
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting output to files for specific code sections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::cout` provides a really nice way to print whatever we want, whenever
    we want because it is simple to use, easily extensible, and globally accessible.
    Even if we want to print special messages, such as error messages, which we want
    to isolate from normal messages, we can just use `std::cerr`, which is the same
    as `cout` but prints to the standard error channel instead of the standard output
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: We might have some more complicated desires for logging sometimes. Let's say,
    for example, we want to *redirect* the output of a function to a file, or we want
    to *mute* the output of a function, without changing the function at all. Perhaps,
    it is a library function we cannot access the source code of. Maybe, it was never
    designed to write to a file but we want its output in a file.
  prefs: []
  type: TYPE_NORMAL
- en: It is indeed possible to redirect the output of stream objects. In this recipe,
    we are going to see how to do that in a very simple and elegant way.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to implement a helper class that solves the problem of redirecting
    a stream and reverting that redirection again with constructor/destructor magic.
    And then we see how we can put it to use:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We only need the headers for input, output, and file streams this time. And
    we declare the `std` namespace as a default namespace for lookup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We implement a class, which holds a file stream object and a pointer to a stream
    buffer. The `cout` as a stream object has an internal stream buffer, which we
    can simply exchange. And while we exchange it, we can save what it was before,
    so we can *undo* any change later. We could look its type up in the C++ reference,
    but we can also use `decltype` to find out what type `cout.rdbuf()` returns. This
    is not generally good practice in all situations, but in this case, it''s just
    a pointer type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor of our class accepts a filename string as its only parameter.
    The filename is used to initialize the file stream member, `ofs`. After initializing
    it, we can feed it into `cout` as a new stream buffer. The same function that
    accepts the new buffer also returns a pointer to the old one, so we can save it
    in order to restore it later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The default constructor does the same as the other constructor. The difference
    is, that it does not open any file. Feeding a default-constructed file stream
    buffer into the `cout` stream buffer leads to `cout` being kind of *deactivated*.
    It will just *drop* its input we give it for printing. This can also be useful
    in some situations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The destructor just restores our change. When an object of this class runs
    out of scope, the stream buffer of `cout` is the old one again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s mock an *output-heavy* function, so we can play with it later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'In the main function, we first produce some completely normal output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re opening another scope, and the first thing we do in this scope is
    instantiating our new class with a text file parameter. File streams open files
    in read and write mode by default, so it creates this file for us. Any following
    output will now be redirected to this file, although we use `cout` for printing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'After leaving the scope, the file is closed and the output is redirected to
    the normal standard output again. Let''s now open another scope in which we instantiate
    the same class, but via its default constructor. This way the following printed
    line of text will not be visible anywhere. It will just be dropped:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'After leaving that scope also, our standard output is resurrected and the last
    line of text output will be readable in the shell again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program yields the output as we expected it. Only
    the very first and the very last lines of output are visible in the shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that a new file, `output.txt`, has been created and contains the
    output of the first scope. The output of the second scope vanishes completely:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every stream object has an internal buffer for which it acts as a front end.
    Such buffers are exchangeable. If we have a stream object, `s`, and want to save
    its buffer into a variable, `a`, and install a new buffer, `b`, this looks like
    the following: `a = s.rdbuf(b)`. Restoring it can be simply done with `s.rdbuf(a)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is exactly what we did in this recipe. Another cool thing is that we can
    *stack* those `redirect_cout_region` helpers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This works because objects are destructed in the opposite order of their construction.
    The concept behind this pattern that uses the tight coupling between construction
    and destruction of objects is called **Resource Acquisition Is Initialization**
    (**RAII**).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one really important thing that should be mentioned--the *initialization
    order* of the member variables of the `redirect_cout_region` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the member, `buf_backup`, is constructed from an expression that
    depends on `ofs`. This obviously means that `ofs` needs to be initialized before
    `buf_backup`. Interestingly, the order in which these members are initialized
    does *not* depend on the order of the initializer list items. The initialization
    order only depends on the order of the *member declarations*!
  prefs: []
  type: TYPE_NORMAL
- en: If one class member variable needs to be initialized after another member variable,
    they *must* also appear in that order in the class member declaration. The order
    of their appearance in the initializer list of the constructor is not critical.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom string classes by inheriting from std::char_traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::string` is extremely useful. However, as soon as people need a string
    class with slightly different semantics for string handling, some tend to write
    their *own* string class.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your own string class is rarely a good idea because safe string handling
    is hard. Fortunately, `std::string` is only a specializing typedef of the template
    class, `std::basic_string`. This class contains all the complicated memory handling
    stuff, but it does not impose any policy on how strings are copied, compared,
    and so on. This is something that is imported into `basic_string` by accepting
    a template parameter that contains a traits class.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to build our own trait classes and, this way,
    how to create custom strings without reimplementing anything.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to implement two different custom string classes: `lc_string`
    and `ci_string`. The first class constructs lower case strings from any string
    input. The other class does not transform any string, but it can do case-insensitive
    string comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s include the few necessary headers first and then declare that we use
    the `std` namespace by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we reimplement the `std::tolower` function, which is already defined in
    `<cctype>`. The already existing function is fine, but it is not `constexpr`.
    Some `string` functions are `constexpr` since C++17, however, and we want to be
    able to make use of that with our own custom string trait class. The function
    maps upper-case characters to lower case and leaves other characters unchanged:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The `std::basic_string` class accepts three template parameters: the underlying
    character type, a character traits class, and an allocator type. We are only changing
    the character traits class in this section because it defines the behavior of
    strings. In order to reimplement only what should differ from the ordinary strings,
    we are publicly inheriting from the standard traits class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Our class accepts input strings but transforms them to lower case. There is
    one function, which does this character-wise, so we can put our own `tolow` function
    here. This function is `constexpr`, which is why we reimplemented ourselves a
    `constexpr` `tolow` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The other function handles the copying of an entire string into its own memory.
    We use an `std::transform` call to copy all the characters from the source string
    to the internal destination string and, at the same time, map every character
    to its lower-case version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The other trait helps build a string class that effectively transforms strings
    to lower case. We are going to write another trait that leaves the actual string
    payload untouched but which is case insensitive when it comes to comparing strings.
    We inherit from the existing standard character traits class again, and this time,
    we redefine some other member functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The `eq` function tells whether two characters are equal. We do this too, but
    we compare their lower-case versions. This way `''A''` equals `''a''`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The `lt` function tells whether the value of `a` is less than the value of
    `b`. We apply the correct logical operator for that, just after lower-casing both
    the characters again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The last two functions worked on character-wise input and the next two functions
    work on string-wise input. The `compare` function works similar to the old-school
    `strncmp` function. It returns `0` if both the strings are equal within the length
    that `count` defines. If they differ, it returns a negative or positive number,
    which tells which input string is lexicographically smaller. Calculating the difference
    between both the characters at every position must, of course, be done on their
    lower-case versions. The nice thing is that this whole loop code has been part
    of a `constexpr` function since C++14:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The last function we need to implement for our case-insensitive string class
    is `find`. For a given input string, `p`, and length, `count`, it finds the position
    of a character, `ch`. Then, it returns a pointer to the first occurrence of that
    character, or it returns `nullptr` if there is none. The comparison in this function
    has to be done using the `tolow` "glasses" in order to make the search case-insensitive.
    Unfortunately, we cannot use `std::find_if`, because it is not `constexpr`, and
    must write a loop ourselves:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, that''s it for the traits. Since we have them in place now, we can define
    two new string class types. `lc_string` means *lower-case string*. `ci_string`
    means *case-insensitive string*. Both the classes only differ from `std::string`
    by their character traits class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make the output streams accept these new classes for printing,
    we quickly need to overload the stream `operator<<`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can finally begin implementing the actual program. Let''s instantiate
    a normal string, a lower-case string, and a case-insensitive string, and print
    them immediately. They should all look normal on the terminal, but the lower case
    strings should be all lower-cased:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to test the case-insensitive string, we can instantiate two strings
    that are basically equal but differ in the casing of some characters. When doing
    a really case-insensitive comparison, they should appear equal nevertheless:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s compare them and print that they match if they do:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program yields us the expected results. When we first
    printed the same string three times in different types, we got unchanged results,
    but the `lc_string` instance is all lower case. The comparison of the two strings
    that only differ in their character casing was indeed successful and yields us
    the right output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the subclassing, and function reimplementing we did will surely look a bit
    crazy for beginners. Where did all the function signatures come from, of which
    we *magically* knew that we need to reimplement?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first have a look where `std::string` really comes from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: The `std::string` is really an `std::basic_string<char>` and that expands to
    `std::basic_string<char, std::char_traits<char>, std::allocator<char>>`. Okay,
    that is a long type description, but what does it mean? The point of all of this
    is that it is possible to base a string not only on single-byte `char` items but
    also on other, larger, types. This enables for string types, which can handle
    more than the typical American ASCII character set. This is not something we will
    have a look into now.
  prefs: []
  type: TYPE_NORMAL
- en: The `char_traits<char>` class, however, contains algorithms that `basic_string`
    needs for its operation. The knows how to compare, find, and copy characters and
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: The `allocator<char>` class is also a traits class, but its special job is handling
    string allocation and deallocation. This is not important for us at this time
    as the default behavior satisfies our needs.
  prefs: []
  type: TYPE_NORMAL
- en: If we want a string class to behave differently, we can try to reuse as much
    as possible from what `basic_string` and `char_traits` already provide. And this
    is what we did. We implemented two `char_traits` subclasses called `case_insentitive`
    and `lower_caser` and configured two completely new string types with them by
    using them as substitutes for the standard `char_traits` type.
  prefs: []
  type: TYPE_NORMAL
- en: In order to explore what other possibilities there are to adapt `basic_string`
    to your own needs, look up the C++ STL documentation for `std::char_traits` and
    see what other functions it has that can be reimplemented.
  prefs: []
  type: TYPE_NORMAL
- en: Tokenizing input with the regular expression library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When parsing or transforming strings in complex ways or breaking them into chunks,
    *regular expressions* are a great help. In many programming languages, they are
    already built in because they are so useful and handy.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not know regular expressions yet, have a look at the *Wikipedia* article
    about them, for example. They will surely extend your horizon, as it is easy to
    see how useful they are when parsing any kind of text. Regular expressions can,
    for example, test whether an e-mail address string or an IP address string is
    valid, find and extract substrings out of large strings, which follow a complex
    pattern, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will extract all the links out of an HTML file and list them
    for the user. The code will be amazingly short because we have regular expression
    support built in the C++ STL since C++11.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to define a regular expression that detects links, and we apply
    it to an HTML file in order to pretty print all the links that occur in that file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first include all the necessary headers, and declare that we use the
    `std` namespace by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'We will later generate an iterable range, which consists of strings. These
    strings always occur in pairs of a link and a link description. Therefore, let''s
    write a little helper function, which pretty prints these:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'In each loop step, we increment the iterator twice and take copies of the link
    and the link description they contain. Between the two iterator dereferences,
    we add another guarding `if` branch that checks whether we prematurely reached
    the end of the iterable range, just for safety:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s print the link with its description in a nicely prettified form
    and that''s it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'In the main function, we are reading in everything that comes from standard
    input. To do this, we are constructing a string from the whole standard input
    via an input stream iterator. In order to prevent tokenizing, because we want
    the whole user input as-is, we use `noskipws`. This modifier deactivates whitespace
    skipping and tokenizing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to define a regular expression that describes how we assume an
    HTML link to look. The parentheses, `()`, within the regular expression define
    groups. These are the parts of the link we want to access--the URL it links to,
    and its description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sregex_token_iterator` class has the same look and feel as of `istream_iterator`.
    We give it the whole string as iterable input range and the regular expression
    we just defined. There is also a third parameter, `{1, 2}`, which is an initializer
    list of integer values. It defines that we want to iterate over the groups 1 and
    2 from the expressions it captures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have an iterator that will emit the links and link descriptions if it
    finds any. We provide it together with a default constructed iterator of the same
    type to the `print` function we implemented before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program gives us the following output. I ran the
    `curl` program on the ISO C++ homepage, which simply downloads an HTML page from
    the Internet. Of course, it would also be possible to write `cat some_html_file.html
    | ./link_extraction`. The regular expression we used is pretty much hardcoded
    to a fixed assumption of how links look in the HTML document. It may be exercised
    by you to make it more general:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regular expressions (or *regex* in short) are extremely useful. They can look
    really cryptic, but it is worth learning how they work. A short regex can spare
    us writing many lines of code if we did the matching manually.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we first instantiated an object of type regex. We fed its constructor
    with a string that describes a regular expression. A very simple regular expression
    is `"."`, which matches *every* character because a dot is the regex wildcard.
    If we write `"a"`, then this matches only on the `'a'` characters. If we write
    `"ab*"`, then this means "one `a`, and zero or arbitrarily many `b` characters".
    And so on. Regular expressions are another large topic, and there are great explanations
    on Wikipedia and other websites or literature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have another look at our regular expression that matches what we assume
    to be HTML links. A simple HTML link can look like `<a href="some_url.com/foo">A
    great link</a>`. We want the `some_url.com/foo` part, as well as `A great link`.
    So we came up with the following regular expression, which contains *groups* for
    matching substrings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6d75901-b27a-455d-bbb6-118f376bef15.png)'
  prefs: []
  type: TYPE_IMG
- en: The whole match itself is always **Group 0**. In this case, this is the full
    `<a href ..... </a>` string. The quoted `href`-part that contains the URL being
    linked to is **Group 1**. The `( )` parentheses in the regular expression define
    such a . The other one is the part between the `<a ...>` and `</a>`, which contains
    the link description.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various STL functions that accept regex objects, but we directly
    used a regex token iterator adapter, which is a high-level abstraction that uses
    `std::regex_search` under the hood in order to automate recurring matching work.
    We instantiated it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: The begin and end part denote our input string over which the regex token iterator
    shall iterate and match all links. The is, of course, the complex regular expression
    we implemented to match links. The `{1, 2}` part is the next complicated looking
    thing. It instructs the token iterator to stop on each full match and first yield
    Group 1, then after incrementing the iterator to yield Group 2, and after incrementing
    it again, it would finally search for the next match in the string. This somewhat
    intelligent behavior really spares us some code lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at another example to make sure we got the idea. Let''s
    imagine the regular expression, `"a(b*)(c*)"`. It will match strings that contain
    an `a` character, then none or arbitrarily many `b` characters, and then none
    or arbitrarily many `c` characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: There is also the `std::regex_iterator` class, which emits the substrings that
    are *between* regex matches.
  prefs: []
  type: TYPE_NORMAL
- en: Comfortably pretty printing numbers differently per context on the fly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last recipe, we learned how to format the output with output streams.
    And while doing the same, we realized two facts:'
  prefs: []
  type: TYPE_NORMAL
- en: Most I/O manipulators are *sticky*, so we have to revert their effect after
    use in order to not tamper with other unrelated code, which also prints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be very tedious and does not look very readable if we have to set up
    long chains of I/O manipulators in order to get only a few variables printed with
    specific formatting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lot of people do not like I/O streams for such reasons, and even in C++, they
    still use `printf` for formatting their strings.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to format types on the fly without too much
    I/O manipulator noise in our code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to implement a class, `format_guard`, which can automatically
    revert any format setting. Additionally, we add a wrapper type, which can contain
    any value, but when it is printed, it gets special formatting without burdening
    us with I/O manipulator noise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we include some headers and declare that we use the `std` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The helper class that tidies up our stream formatting states for us is called
    `format_guard`. Its constructor saves the formatting flags, which `std::cout`
    has set at the moment. Its destructor restores them to the state it had when the
    constructor was called. This effectively revokes any formatting settings that
    were applied in between:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Another little helper class is `scientific_type`. Because it''s a class template,
    it can wrap any payload type as a member variable. It basically does nothing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define completely custom formatting settings for any type that was wrapped
    into `scientific_type` before because if we overload the stream `operator>>` for
    it, the stream library executes completely different code when printing such types.
    This way, we can print scientific values in scientific floating-point notation,
    with uppercase formatting and explicit `+` prefix if they have positive values.
    We do also use our `format_guard` class in order to tidy up all our settings when
    leaving this function again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'In the main function, we will first play around with the `format_guard` class.
    We open a new scope, first get an instance of the class, and then we apply some
    wild formatting flags to `std::cout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'After we printed some numbers with many formatting flags enabled, we left the
    scope again. While this happened, the destructor of `format_guard` tidied the
    formatting up. In order to test this, we are printing exactly the same numbers
    *again*. They should appear different:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we put `scientific_type` to use. Let''s print three floating-point numbers
    in a row. We wrap the second number in `scientific_type`. This way, it is printed
    in our special scientific style, but the numbers before and after it get default
    formatting. At the same time, we avoid ugly formatting line *noise*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program yields us the following result. The first
    two numbers are printed with specific formatting. The next two numbers appear
    with default formatting, which shows us that our `format_guard` works just nicely.
    The three numbers in the last lines also look just as expected. Only the one in
    the middle has the formatting of `scientific_type`, the rest has default formatting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Catching readable exceptions from std::iostream errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *none* of the recipes in this chapter, we used *exceptions* to catch errors.
    While this is certainly possible, working on stream objects without exceptions
    is already very convenient. If we try to parse in 10 values, but this fails somewhere
    in the middle, the whole stream object sets itself into a fail state and stops
    further parsing. This way, we do not run into the danger of parsing variables
    from the wrong offset in the stream. We can just do the parsing in a conditional,
    such as `if (cin >> foo >> bar >> ...)`. If this fails, we handle it. It does
    not appear very advantageous to embrace parsing in a `try { ... } catch ...` block.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the C++ I/O stream library already existed before there were exceptions
    in C++. Exception support was added later, which might be an explanation why they
    are not a first-class supported feature in the stream library.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use exceptions in the stream library, we must configure each stream
    object individually to throw an exception, whenever it sets itself into a fail
    state. Unfortunately, the error explanations in the exception objects, which we
    can then catch later, are not thoroughly standardized. This leads to not really
    helpful error messages, as we will see in this section. If we really want to use
    exceptions with stream objects, we can *additionally* poll the C library for filesystem
    error states to get some additional information.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to write a program that can fail in different
    ways, handle those with exceptions, and see how to squeeze more information out
    of those afterward.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will implement a program that opens a file (which might fail), and then
    we''ll read an integer out of it (which might fail, too). We do this with activated
    exceptions and then we see how we can handle those:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we include some headers and declare that we use the `std` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to use stream objects with exceptions, we have to enable them first.
    In order to get a file stream object to throw an exception if the file we are
    letting it access does not exist, or if there are parsing errors, we need to set
    some fail bits in an exception mask. If we do something afterward that fails,
    it will trigger an exception. By activating `failbit` and `badbit`, we enable
    exceptions for filesystem errors and parsing errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can open a `try` block and access a file. If opening the file is successful,
    we try to read an integer from it. Only if both steps succeed, we print the integer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'In both the expected possibilities of an error, an instance of `std::ios_base::failure`
    is thrown. This object has a `what()` member function, which ought to explain
    what triggered the exception. Unfortunately, the standardization of this message
    was left out, and it does not give too much information. However, we can at least
    distinguish if there is a *filesystem* problem (because the file does not exist,
    for example) or a format *parsing* problem. The global variable, `errno`, has
    been there even before C++ was invented, and it is set to an error value, which
    we can check now. The `strerror` function translates from an error number to a
    human readable string. If `errno` is `0`, there is, at least, no filesystem error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling the program and running it in two different scenarios yields the
    following output. If the file to be opened does exist but parsing an integer from
    it was not possible, we get an `iostream_category` error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file does *not* exist, we will be notified about this with a different
    message from `strerror(errno)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen that we can enable exceptions per stream object, `s`, with `s.exceptions(s.failbit
    | s.badbit)`. This means, that there is no way to use, for example, the `std::ifstream`
    instance''s constructor for opening a file if we want to get an exception when
    opening that file is not possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: This is a pity because exceptions actually promise that they make error handling
    less clumsy compared to old-school C-style code, which is riddled with loads of
    `if` branches, which handle errors after every step.
  prefs: []
  type: TYPE_NORMAL
- en: If we played around trying to provoke various reasons for streams to fail, we
    would realize that there are no different exceptions being thrown. This way, we
    can only find out *when* we get an error, but not *what* specific error (This
    is, of course, *not* true for exception handling in *general*, but for the STL
    stream library). That is why we additionally consulted the value of `errno`. This
    global variable is an ancient construct, which has already been used in the old
    days when there were no C++ or exceptions in general.
  prefs: []
  type: TYPE_NORMAL
- en: If any system-related function has seen an error condition, it is able to set
    the `errno` variable to something other than `0` (`0` describes the absence of
    errors), and then the caller is able to read that error number and look up what
    its value means. The only problem with this is that when we have a multithreaded
    application, and all the threads use functions that can set this error variable,
    *whose* error value is it? If we read it even though there is no error, it could
    carry an error value because some *other* system function running in a *different
    thread* may have experienced an error. Luckily, this flaw has been gone since
    C++11, where every thread in a process sees its own `errno` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Without elaborating the ups and downs of an ancient error indication method,
    it can give us useful extra information when an exception is triggered on system-based
    things such as file streams. Exceptions tell us *when* it happened, and `errno`
    can tell us *what* happened if it happened at the system level.
  prefs: []
  type: TYPE_NORMAL
