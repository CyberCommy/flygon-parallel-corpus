- en: '*Chapter 8*: Mastering Angular Forms'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting user inputs is an integral part of almost any modern app that we use.
    Whether it is authenticating users, asking for feedback, or filling out business-critical
    forms, knowing how to implement and present forms to end users is always an interesting
    challenge. In this chapter, you'll learn about Angular forms and how you can create
    great user experiences using them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the recipes that we''re going to cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first template-driven Angular form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form validation with template-driven forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing template-driven forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first Reactive form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form validation with Reactive forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an asynchronous validator function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Reactive forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using debounce with Reactive form control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own custom form control using `ControlValueAccessor`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the recipes in this chapter, make sure you have **Git** and **NodeJS** installed
    on your machine. You also need to have the `@angular/cli` package installed, which
    you can do with `npm install -g @angular/cli` from your terminal. The code for
    this chapter can be found at [https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter08](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first template-driven Angular form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start getting familiar with Angular forms in this recipe. In this one,
    you'll learn about the basic concepts of template-driven forms and will create
    a basic Angular form using the template-driven forms API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project for this recipe resides in `chapter08/start_here/template-driven-forms`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab and you should see the following
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Template-driven forms app running on http://localhost:4200'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.1_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Template-driven forms app running on http://localhost:4200
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have an Angular app that already has a release log component and a bunch
    of things set up, such as the `ReleaseLog` class under the `src/app/classes` folder.
    So, in this recipe, we''ll create a template-driven form to allow the user to
    pick an app and submit a release version. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open the terminal in the project''s root and create a component for
    the release form as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The command should create a new component in the `src/app/components` folder
    named `ReleaseFormComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the newly created component to the template of `VersionControlComponent`
    and modify the `version-control.component.html` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's adjust some styles for the release form to be used within `VersionControlComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `version-control.component.scss` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We'll have two inputs in the `ReleaseFormComponent` template. One to select
    the app we want to release, and the second for the version we want to release.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the `release-form.component.ts` file to add the `Apps` enum as
    a local property that we can later use in the template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now add the template for our form. Modify the `release-form.component.html`
    file and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to integrate the template-driven form. Let''s add `FormsModule`
    to the `app.module.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now make our form work in the template. Let''s modify the `release-form.component.html`
    file to create a template variable for the form, named `#releaseForm`. We will
    also use the `[(ngModel)]` binding for both the inputs against appropriate values
    for the `newLog` property as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a method for when the form will be submitted. Modify the `release-form.component.ts`
    file to add a new method named `formSubmit`. When this method is called, we''ll
    emit a new instance of `ReleaseLog` using an Angular `@Output` emitter as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the template now to use the `formSubmit` method on the form''s submission
    and modify the `release-form.component.html` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to modify `VersionControlComponent` to be able to act on the new
    release log emitted. In order to do so, modify the `version-control.component.html`
    file to listen to the `newReleaseLog` output event from `ReleaseFormComponent`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Cool! Let''s create the `addNewReleaseLog` method in the `version-control.component.ts`
    file and add the `ReleaseLog` received to the `releaseLogs` array. Your code should
    look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! Within a few minutes, we were able to create our first template-driven
    form in Angular. If you refresh the app now and try creating some releases, you
    should see something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Template-driven forms app final output'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.2_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Template-driven forms app final output
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how the template-driven forms are created, let's see the next
    section to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key to using template-driven forms in Angular resides in `FormsModule`,
    the `ngForm` directive, by creating a **template variable** using the `ngForm`
    directive and using the `[(ngModel)]` two-way data binding along with the `name`
    attributes for inputs in the template. We began by creating a simple form with
    some inputs. Then, we added the `FormsModule`, which is necessary for using the
    `ngForm` directive and the `[(ngModel)]` two-way data binding. Once we added the
    module, we could use both the directive and the data binding with our newly created
    local property named `newLog` in the `ReleaseFormComponent`. Notice that it could
    be an instance of the `ReleaseLog` class, but we kept it as an object of the `IReleaseLog`
    type instead because we don't want the `ReleaseLog` class's `message` property
    as we don't use it. With the `[(ngModel)]` usages and the `#releaseForm` template
    variable in place, we could submit the form using the `ngSubmit` emitter of Angular's
    `<form>` directive. Notice that we pass the `releaseForm` variable to the `formSubmit`
    method, which makes it easier to test the functionality for us. Upon submitting
    the form, we use the form's value to create a new `ReleaseLog` item and we emit
    it using the `newReleaseLog` output emitter. Notice that if you provide an invalid
    `version` for the new release log, the app will throw an error and will not create
    a release log. This is because we validate the version in the `constructor` of
    the `ReleaseLog` class. Finally, when this `newReleaseLog` event is captured by
    `VersionControlComponent`, it calls the `addNewReleaseLog` method, which adds
    our newly created release log to the `releaseLogs` array. And since the `releaseLogs`
    array is passed as an `@Input()` to `ReleaseLogsComponent`, it immediately shows
    it right away.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Building a template-driven form in Angular: [https://angular.io/guide/forms#building-a-template-driven-form](https://angular.io/guide/forms#building-a-template-driven-form)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form validation with template-driven forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A great user experience is key to acquiring more users that love to use your
    applications. And using forms is one of those things that users don't really enjoy.
    To make sure that users spend the least amount of time filling in forms and are
    done with them faster, we can implement form validation to make sure that users
    enter the appropriate data a.s.a.p. In this recipe, we're going to look at how
    we can implement form validation in template-driven forms.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project for this recipe resides in `chapter08/start_here/tdf-form-validation`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab and you should see the app as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – TDF form validation app running on http://localhost:4200'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.3_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – TDF form validation app running on http://localhost:4200
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let's see the steps involved in this
    recipe in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now have the app from the previous recipe, a simple Angular app with one
    template-driven form using the `ngForm` and `ngModel` directives. The form is
    used to create release logs. In this recipe, we''re going to make this form better
    in terms of validating the input as the user types the input. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we''ll add some validators from the `@angular/forms` package
    that are part of the Reactive forms API. We''ll apply the **required** validation
    to both inputs and a **regex** validation on the version input. We need to create
    template variables for both our inputs. We will name them `nameInput` and `versionInput`,
    respectively. Modify the code in the `release-form.component.html` file so that
    it looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use the template variables to apply validations. Let''s start with
    the name input. In terms of validation, the name input shouldn''t be empty and
    an app should be selected from the select box. Let''s show a default Bootstrap
    alert when the input is invalid. Modify the code in the `release-form.component.html`
    file. It should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To validate the version name input, we need to apply the `SEMANTIC_VERSION`
    regex from our `src/app/constants/regexes.ts` file. Add the constant as a local
    property in the `ReleaseFormComponent` class to the `release-form.component.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, use `versionInputRegex` in the template to apply the validation and show
    the related error as well. Modify the `release-form.component.html` file so that
    the code looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Refresh the app and try to invalidate both inputs by selecting the first option
    named **--Choose--** from the **Select App** drop-down menu and by emptying the
    version input field. You should see the following errors:![Figure 8.4 – Displaying
    input errors using ngModel and validation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_8.4_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Displaying input errors using ngModel and validation
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''re going to add some styles to make our inputs more visual when it
    comes to validation. Let''s add some styles to the `release-form.component.scss`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s make the validation around the form submission. We''ll disable
    the **Submit** button if the inputs do not have valid values. Let''s modify the
    template in `release-form.component.html` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you refresh the app now, you'll see that the submit button is disabled whenever
    one or more inputs are invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Great! You just learned how to validate template-driven forms and to make the
    overall user experience with template-driven forms slightly better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core components of this recipe were the `ngForm` and `ngModel` directives.
    We could easily identify whether the submit button should be clickable (not disabled)
    or not based on whether the form is valid, that is, if all the inputs in the form
    have valid values. Note that we used the template variable created using the `#releaseForm="ngForm"`
    syntax on the `<form>` element. This is possible due to the ability of the `ngForm`
    directive to be exported into a template variable. Therefore, we were able to
    use the `releaseForm.invalid` property in the `[disabled]` binding of the submit
    button to conditionally disable it. We also showed the errors on individual inputs
    based on the condition that the input might be invalid. In this case, we show
    the Bootstrap `alert` element ( a `<div>` with the CSS class `alert`). We also
    use Angular's provided classes, `ng-valid` and `ng-invalid`, on the form inputs
    to highlight the input in a certain way depending on the validity of the input's
    value. What's interesting about this recipe is that we validated the app name's
    input by making sure it contains a non-falsy value where the first `<option>`
    of the `<select>` box has the value `""`. And what's even more fun is that we
    also validated the version name right when the user types it using the `[pattern]`
    binding on the input to a regex. Otherwise, we'd have to wait for the user to
    submit the form, and then it would have been validated. Thus, we're providing
    a great user experience by providing the errors as the user types the version.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Show and hide validation error messages (Angular Docs): [https://angular.io/guide/forms#show-and-hide-validation-error-messages](https://angular.io/guide/forms#show-and-hide-validation-error-messages)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NgForm docs: `https://angular.io/api/forms/NgForm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing template-driven forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make sure we build robust and bug-free forms for end users, it is a really
    good idea to have tests relating to your forms. It makes the code more resilient
    and less prone to errors. In this recipe, you'll learn how to test your template-driven
    forms using unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project for this recipe resides in `chapter08/start_here/testing-td-forms`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab and you should see the app as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – The Testing Template-Driven Forms app running on http://localhost:4200'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.5_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – The Testing Template-Driven Forms app running on http://localhost:4200
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let's see the steps involved in this
    recipe in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have the app from the previous recipe that contains a template-driven form
    used to create release logs. The form also has validations applied to the inputs.
    Let''s start looking into how we can test this form:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, run the following command to run the unit tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the command is run, you should see a new instance of the Chrome window
    being opened that runs the unit tests. One test out of the six we have has failed.
    You will probably see something like the following in the automated Chrome window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Unit tests with Karma and Jasmine running in an automated Chrome
    window'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.6_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – Unit tests with Karma and Jasmine running in an automated Chrome
    window
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ReleaseFormComponent > should create` test is failing because we don''t
    have `FormsModule` added to the tests. Notice the `Export of name ''ngForm'' not
    found` error. Let''s import `FormsModule` into the testing module''s configuration
    in `release-form.component.spec.ts` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the tests now, you should see all the tests passing as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – All tests pass after importing FormsModule into the appropriate
    test'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.7_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – All tests pass after importing FormsModule into the appropriate
    test
  prefs: []
  type: TYPE_NORMAL
- en: To test the form correctly, we'll add a couple of tests, one for successful
    input and one for each invalid input. For that, we need to access the form in
    our component since we're writing unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s access the `#releaseForm` in our component class using the `@ViewChild()`
    decorator in the `release-form.component.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a new test now. We''ll write a test that should validate the case
    for when both the inputs have valid values. Add the test to the `release-form.component.spec.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The new test is failing so far. Let''s try to fill the values in the form,
    submit the button, and make sure that our `@Output` emitter named `newReleaseLog`
    emits the correct value from `releaseForm`. The content of the test should look
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When you save the file, you should see the new test passing with the expected
    values. It should appear as follows in the Chrome tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – New test for successful form submission passing'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.8_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8 – New test for successful form submission passing
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a test for the case when we have an incorrect version provided in
    the form. The submit button should be disabled and we should have an error thrown
    by the `formSubmit` method. Add a new test to your `release-form.component.spec.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add our final test, which makes sure that the submit button is disabled
    when we have not selected an app for the release log. Add a new test to the `release-form.component.spec.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the Karma tests window, you should see all the new tests passing
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – All tests passing for the recipe'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.9_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.9 – All tests passing for the recipe
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! You now know a bunch of techniques for testing your template-driven
    forms. Some of these techniques might still require some explanation. See the
    next section to understand how it all works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing template-driven forms can be a bit of a challenge as it depends on
    how complex the form is, what use cases you want to test, and how complex those
    use cases are. In our recipe, the first thing we did was to include `FormsModule`
    in the imports of the test file for `ReleaseFormComponent`. This makes sure that
    the tests know the `ngForm` directive and do not throw relevant errors. For the
    test with all the successful inputs, we spied on the `newReleaseLog` emitter''s
    `emit` event defined in the `ReleaseFormComponent` class. This is because we know
    that when the inputs are correct, the user should be able to click the submit
    button, and as a result, inside the `formSubmit` method, the `emit` method of
    the `newReleaseLog` emitter will be called. Note that we''re using `fixture.whenStable()`
    in each of our tests. This is to make sure that Angular has done the compilation
    and our `ngForm`, named `#releaseForm`, is ready. For the `should disable the
    submit button when version is incorrect` test, we rely on `formSubmit` to throw
    an error. This is because we know that an invalid version will cause an error
    in the `constructor` of the `ReleaseLog` class when creating a new release log.
    One interesting thing in this test is that we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The interesting thing here is that we needed to call the `formSubmit` method
    ourselves with `releaseForm`. We couldn't just do it by writing `expect(component.formSubmit(component.releaseForm)).toThrowError(expectedError);`
    because that would rather call the function directly there and would result in
    the error. So, we need to pass an anonymous function here that Jasmine will call
    and would expect this anonymous function to throw an error. And finally, we make
    sure that our submit button is enabled or disabled by first getting the button
    using a `querySelector` on `fixture.nativeElement`. We then check the `disabled`
    attribute on the submit button using `submitButton.hasAttribute('disabled')`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing template-driven forms: [https://angular.io/guide/forms-overview#testing-template-driven-forms](https://angular.io/guide/forms-overview#testing-template-driven-forms)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first Reactive form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've learned about template-driven forms in the previous recipes and are now
    confident in building Angular apps with them. Now guess what? Reactive forms are
    even better. Many known engineers and businesses in the Angular community recommend
    using Reactive forms. The reason is their ease of use when it comes to building
    complex forms. In this recipe, you'll build your first Reactive form and will
    learn its basic usage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project for this recipe resides in `chapter08/start_here/reactive-forms`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done , run `ng serve -o`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the name of the first user and you should see the following view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.10 – The Reactive Form app running on http://localhost:4200'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.10_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.10 – The Reactive Form app running on http://localhost:4200
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let's see the steps involved in this
    recipe in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have an app that has `ReleaseLogsComponent`, which shows a bunch
    of release logs that we create. We also have `ReleaseFormComponent`, which has
    a form by means of which the release logs will be created. We now have to make
    our current form a Reactive form using the Reactive forms API. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to import `ReactiveFormsModule` into the imports of our
    `AppModule`. Let''s do it by modifying the `app.module.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the Reactive form now. We''ll create a `FormGroup` in our `ReleaseFormComponent`
    class with the required controls. Modify the `release-form.component.ts` file
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the form named `releaseForm` in place, let''s bind it to the
    form by using it in the template. Modify the `release-form.component.html` file
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Now that we have the form group bound, we can also bind the individual
    form controls so that when we finally submit the form, we can get the value out
    for each individual form control. Modify the `release-form.component.html` file
    further as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s decide what will happen when we submit this form. We''ll call a method
    named `formSubmit` in the template and pass `releaseForm` in it when the form
    is submitted. Modify the `release-form.component.html` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `formSubmit` method doesn''t yet exist. Let''s create it now in the `ReleaseFormComponent`
    class. We''ll also log the value on the console and emit the value using an `@Output`
    emitter. Modify the `release-form.component.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you refresh the app now, complete the form, and hit **Submit**, you should
    see a log on the console as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Log displaying the values submitted using the Reactive form'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.11_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.11 – Log displaying the values submitted using the Reactive form
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''ve emitted the value of the newly created release log via the `newReleaseLog`
    output emitter, we can listen to this event in the `version-control.component.html`
    file and add the new log accordingly. Let''s modify the file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Refresh the app and you should see the new release log being added to the release
    logs view. You should see the logs on the console as well, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.12 – New logs being added to the logs view on form submission'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.12_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.12 – New logs being added to the logs view on form submission
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! So, now you know how to create a basic Reactive form using the Reactive
    forms API. Refer to the next section to understand how it all works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipe begins with having a basic HTML form in our Angular app with no Angular
    magic bound to it. We first started importing `ReactiveFormsModule` in the `AppModule`.
    If you're using the Angular Language Service with the editor of your choice, you
    might see an error as you import `ReactiveFormsModule` into the app and don't
    bind it with a Reactive form, in other words, with a `FormGroup`. Well, that's
    what we did. We created a reactive form using the `FormGroup` constructor and
    created the relevant form controls using the `FormControl` constructor. We then
    listened to the `ngSubmit` event on the `<form>` element to extract the value
    of `releaseForm`. Once done, we emitted this value using the `@Ouput()` named
    `newReleaseLog`. Notice that we also defined the type of the value that this emitter
    will emit as `IReleaseLog`; it is good practice to define those. This emitter
    was required because `ReleaseLogsComponent` is a sibling of `ReleaseFormComponent`
    in the component's hierarchy. Therefore, we're communicating through the parent
    component, `VersionControlComponent`. Finally, we listen to the `newReleaseLog`
    event's emission in the `VersionControlComponent` template and add a new log to
    the `releaseLogs` array via the `addNewReleaseLog` method. And this `releaseLogs`
    array is being passed to `ReleaseLogsComponent`, which displays all the logs as
    they're added.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular''s guide to Reactive forms: [https://angular.io/guide/reactive-forms](https://angular.io/guide/reactive-forms)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form validation with Reactive forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, you learned how to create a Reactive form. Now, we're
    going to learn how to test them. In this recipe, you'll learn some basic principles
    of testing Reactive forms. We're going to use the same example from the previous
    recipe (the release logs app) and will implement a number of test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project that we are going to work with resides in `chapter08/start_here/validating-reactive-forms`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab and you should see it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – The Validating Reactive Forms  app running on http://localhost:4200'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.13_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.13 – The Validating Reactive Forms app running on http://localhost:4200
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let's see the steps involved in this
    recipe in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we''re using the Release Logs application that has the Reactive
    form implemented already, although we don''t have any sort of validation on the
    inputs so far. If you just select an app and submit the form, you''ll see an error
    on the console as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Error when submitting the Reactive form app without form validations'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.14_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.14 – Error when submitting the Reactive form app without form validations
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to incorporate some form validations to enhance the user experience
    and to make sure that the form can''t be submitted with invalid input. Let''s
    begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll first add some validations from the `@angular/forms` package, which
    are part of the Reactive Forms API. We''ll apply the `required` validator on both
    inputs and the `pattern` validator on the `version` form control. Update the `release-form.component.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll add the hints to the view to show the user errors when an invalid
    input is selected. Modify the `release-form.component.html` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also add some styles to show the errors with a better UI. Add the following
    styles to the `release-form.component.scss` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Refresh the app and you should see the inputs with red borders when the input
    values are wrong. The errors once you enter or select an invalid input will look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – Red borders shown on invalid input values'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.15_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.15 – Red borders shown on invalid input values
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s make the validation around the form submission. We''ll disable
    the **Submit** button if the inputs do not have valid values. Let''s modify the
    template in `release-form.component.html` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you refresh the app now, you'll see that the submit button is disabled whenever
    one or more inputs are invalid.
  prefs: []
  type: TYPE_NORMAL
- en: And that concludes the recipe. Let's look at the next section to see how it
    works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We started the recipe by adding the validators, and Angular has got a bunch
    of validators out of the box, including `Validators.email`, `Validators.pattern`,
    and `Validators.required`. We used the `required` validator with the `pattern`
    validator in our recipe for the inputs for the app name and the version, respectively.
    After that, to show the hints/errors for invalid inputs, we added some conditional
    styles to show a border-bottom on the inputs. We also added some `<div>` elements
    with `class="alert alert-danger"`, which are basically Bootstrap alerts to show
    the errors on invalid values for the form controls. Notice that we''re using the
    following pattern to hide the error elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We're using the condition with `.pristine` to make sure that as soon as the
    user selects the correct input and the input is modified, we hide the error again
    so that it doesn't show while the user is typing in the input or making another
    selection. Finally, we made sure that the form cannot even be submitted if the
    values of the form controls are invalid. We disabled the submit button using `[disabled]="releaseForm.invalid"`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular docs for validating Reactive forms: [https://angular.io/guide/reactive-forms#validating-form-input](https://angular.io/guide/reactive-forms#validating-form-input)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an asynchronous validator function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Form validations are pretty straightforward in Angular, the reason being the
    super-awesome validators that Angular provides out of the box. These validators
    are synchronous, meaning that as soon as you change the input, the validators
    kick in and provide you with information about the validity of the values right
    away. But sometimes, you might rely on some validations from a backend API, for
    instance. These situations would require something called asynchronous validators.
    In this recipe, you're going to create your first asynchronous validator.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project that we are going to work with resides in `chapter08/start_here/asynchronous-validator`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab and you should see something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Asynchronous validators app running on http://localhost:4200'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.16_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.16 – Asynchronous validators app running on http://localhost:4200
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running, let's see the steps involved in this recipe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have some things set up in the release logs app. We have a `data.json`
    file residing in the `src/assets` folder that holds the versions for each of our
    target apps for the release logs. We''ll create an async validator to make sure
    that the new releases for each of the applications have a greater version than
    that specified in the `data.json` file. Let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''re going to create the async validator function for the recipe.
    Let''s create a method named `versionValidator` in the `VersionService` class
    in the `version.service.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll now define the content of the validator function. Let''s modify the
    `versionValidator` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the validator function in place, let''s add that to the form
    control for the version number. Let''s modify the `release-form.component.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now use the validator to enhance the user''s experience of the form
    by modifying the `release-form.component.html` file. For ease of usage, let''s
    wrap the content inside an `<ng-container>` element using the `*ngIf` directive,
    and create a variable within the template for the version form control as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now add the error message. We''ll use our custom error, `newVersionRequired`,
    from the validator function to show the error when the specified version isn''t
    newer than the previous version. Modify the `release-form.component.html` file
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to select an app and add a lower version number and you should now see
    the error as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Error being shown when a lower version number is provided'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.17_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.17 – Error being shown when a lower version number is provided
  prefs: []
  type: TYPE_NORMAL
- en: 'One issue right now is that we are able to submit the form while the asynchronous
    validation is in progress. That''s because Angular, by default, marks the error
    as `null` until the validation is done. To tackle this, we can show a loading
    message instead of the **submit** button in the template. Modify the `release-form.component.html`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If you refresh the app, select an app, and type a valid version, you should
    see the **Please wait…** message as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18 – Loader message while async validation is in progress'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.18_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.18 – Loader message while async validation is in progress
  prefs: []
  type: TYPE_NORMAL
- en: 'We still have an issue where the user can type and press *Enter* quickly to
    submit the form. To prevent this from happening, let''s add a check in our `formSubmit`
    method in the `release-form.component.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have another issue to handle. If we select a valid version number
    and change the app, we can still submit the form with the entered version number
    although it is logically wrong. To handle this, we should update the validation
    of the `''version''` form control whenever the value of the `''app''` form control
    changes. To do that, modify the `release-form.component.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Cool! So, you now know how to create an asynchronous validator function in Angular
    for form validation within Reactive forms. Since you've finished the recipe, refer
    to the next section to see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular provides a really easy way to create async validator functions, and
    they're pretty handy too. In this recipe, we started by creating the validator
    function named `versionValidator`. Notice that we have an argument named `appNameControl`
    for the validator function. This is because we want to get the app name for which
    we are validating the version number. Also notice that we have the return type
    set to `AsyncValidatorFn`, which is required by Angular. The validator function
    is supposed to return an `AsyncValidatorFn`, which means it will return a function
    (let's call it the **inner function**), which receives an `AbstractControl` and
    returns an `Observable` of `ValidatorErrors`. Inside the inner function, we use
    the `getVersionLog()` method from `VersionService` to fetch the `data.json` file
    using the `HttpClient` service. Once we get the version from `data.json` for the
    specific app selected, we compare the version entered in the form with the value
    from `data.json` to validate the input. Notice that instead of just returning
    a `ValidationErrors` object with the `newVersionRequired` property set to `true`,
    we actually set it to `previousVersion` so that we can use it later to show it
    to the user.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the validator function, we attached it to the form control for
    the version name by using the `FormControl.setAsyncValidators()` method in the
    `ReleaseFormComponent` class. We then used the validation error named `newVersionRequired`
    in the template to show the error message, along with the version from the `data.json`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: We also needed to handle the case that while the validation is in progress,
    the form control is valid until the validation is finished. This allows us to
    submit the form while the validation for the version name was in progress. We
    handle it by hiding the submit button during the validation process by checking
    whether the value of `FormControl.status` is `'PENDING'`. We hide the submit button
    in that case and show the **Please wait…** message in the meantime. Note that
    we also add some logic in the `formSubmit` method of the `ReleaseFormComponent`
    class to check whether `FormControl.status` is `'PENDING'` for the version number,
    in which case, we just do a `return;`.
  prefs: []
  type: TYPE_NORMAL
- en: One more interesting thing in the recipe is that if we added a valid version
    number and changed the app, we could still submit the form. We handle that by
    adding a subscription to `.valueChanges` of the `'app'` form control, so whenever
    that happens, we trigger another validation on the `'version'` form control using
    the `.updateValueAndValidity()` method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'AsyncValidator Angular docs: [https://angular.io/api/forms/AsyncValidator#provide-a-custom-async-validator-directive](https://angular.io/api/forms/AsyncValidator#provide-a-custom-async-validator-directive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Reactive forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make sure we build robust and bug-free forms for end users, it is a really
    good idea to have tests around your forms. It makes the code more resilient and
    less prone to errors. In this recipe, you'll learn how to test your template-driven
    forms using unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project for this recipe resides in `chapter08/start_here/testing-reactive-forms`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab, and you should see the app as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19 – The Testing Reactive Forms app running on http://localhost:4200'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.19_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.19 – The Testing Reactive Forms app running on http://localhost:4200
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let's see the steps involved in this
    recipe in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have the Release Logs application that has a Reactive form implemented with
    some validations. In this recipe, we''re going to implement some tests for the
    forms. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, run the following command to run the unit tests in a separate
    terminal window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the command is run, you should see a new instance of the Chrome window
    being opened that runs the tests as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20 – Unit tests with Karma and Jasmine running in an automated Chrome
    window'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.20_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.20 – Unit tests with Karma and Jasmine running in an automated Chrome
    window
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add our first test for the case when all the inputs have a valid value.
    In this case, we should have the form submitted and the form''s value emitted
    through the emitter of the `newReleaseLog` output. Modify the `release-form.component.spec.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the tests now, you should the new test passing as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21 – Test case passing for the successful input'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.21_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.21 – Test case passing for the successful input
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a test for the case when we have an incorrect version provided in
    the form. The **submit** button should be disabled and we should have an error
    thrown by the `formSubmit` method. Add a new test to your `release-form.component.spec.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add our final test, which makes sure that the **submit** button is disabled
    when we have not selected an app for the release log. Add a new test to the `release-form.component.spec.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the Karma tests window, you should see all the new tests passing
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22 – All tests passing for the recipe'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.22_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.22 – All tests passing for the recipe
  prefs: []
  type: TYPE_NORMAL
- en: Great! You now know how to write some essential tests for Reactive forms. Refer
    to the next section to understand how it all works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing Reactive forms doesn''t even require importing `ReactiveFormsModule`
    into the test module as of Angular 10\. For all the tests in our recipe, we spied
    on the `newReleaseLog` emitter''s `emit` event defined in the `ReleaseFormComponent`
    class. This is because we know that when the inputs are correct, the user should
    be able to click the **submit** button, and as a result, inside the `formSubmit`
    method, the `emit` method of the `newReleaseLog` emitter will be called. For the
    test covering the validity of the `''version''` form control, we rely on `formSubmit`
    to throw an error. This is because we know that an invalid version will cause
    an error in the `constructor` of the `ReleaseLog` class when creating a new release
    log. One interesting thing in this test is that we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The interesting thing here is that we needed to call the `formSubmit` method
    ourselves with `releaseForm`. We couldn't just do it by writing `expect(component.formSubmit(component.releaseForm)).toThrowError(expectedError);`
    because that would rather call the function directly there and would result in
    an error. So we need to pass an anonymous function here that Jasmine will call
    and would expect this anonymous function to throw an error. And finally, we make
    sure that our **submit** button is enabled or disabled by first getting the button
    using `querySelector` on `fixture.nativeElement`. And then we check the `disabled`
    attribute on the **submit** button using `submitButton.hasAttribute('disabled')`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing Reactive forms: [https://angular.io/guide/forms-overview#testing-reactive-forms](https://angular.io/guide/forms-overview#testing-reactive-forms)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using debounce with Reactive form control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're building a medium-to large-scale Angular app with Reactive forms,
    you'll surely encounter a scenario where you might want to use a debounce on a
    Reactive form. It could be for performance reasons, or for saving HTTP calls.
    So, in this recipe, you're going to learn how to use debounce on a Reactive form
    control.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project that we are going to work with resides in `chapter08/start_here/using-debounce-with-rfc`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab and you should see it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.23 – The Using debounce with Reactive Form Control app running on
    http://localhost:4200'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.23_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.23 – The Using debounce with Reactive Form Control app running on http://localhost:4200
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, you''ll notice that for each character we type into the input, we
    send a new HTTP request to the API shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.24 – Multiple HTTP calls sent as we type in the input'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.24_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.24 – Multiple HTTP calls sent as we type in the input
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let's see the steps involved in this
    recipe in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we''re using an application that uses the RandomUser.me API
    to get users. As you see in *Figure 8.24*, we send a new HTTP call for every change
    in the input. Let''s begin with the recipe to avoid doing that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the debounce to the form is super easy. Let''s use the `debounceTime`
    operator in the `home.component.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Well, it's funny that this is it for the recipe as far as the task is concerned.
    But I do want to give you more out of this book. So we're going to write some
    interesting tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll add a test now to make sure that our `searchUsers` method isn''t called
    before `searchDebounceTime` has passed. Add the following test to the `home.component.spec.ts`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll add a test for the case when `searchDebounceTime` has passed and
    the `searchUsers()` method should have been called. Add a new test to the `home.component.spec.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If you refresh the Karma test Chrome window, you''ll see all the tests passing
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.25 – All tests passing for the recipe'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.25_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.25 – All tests passing for the recipe
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the `npm start` command to spin up the app again. Then, monitor the
    network calls while you type an input into the search box. You''ll see that the
    `debounceTime` operator causes only 1 call once you stop typing for 300 milliseconds,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.26 – Only one network call sent after a 300ms debounce'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.26_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.26 – Only one network call sent after a 300ms debounce
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! So, now you know how to use debounce with a Reactive form control and
    also how to write tests to check whether things work fine with the debounce. And
    that concludes the recipe. Let's refer to the next section to see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main task for the recipe was quite easy. We just used the `debounceTime`
    operator from the `rxjs` package and used it with our Reactive form control's
    `.valueChanges` Observable. Since we're using it within the `.pipe()` operator
    before the `.subscribe()` method, every time we change the value of the input,
    either by entering a value or by pressing the backspace key, it waits for `300ms`
    according to the `searchDebounceTime` property and then calls the `searchUsers()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also wrote some tests in this recipe. Notice that we spy on the `searchUsers()`
    method since that is what it''s supposed to be called whenever we change the value
    of the `''username''` form control. We''re wrapping the test functions inside
    the `fakeAsync` method so we can control the asynchronous behavior of the use
    cases in our tests. We then set the value of the form control using the `FormControl.setValue()`
    method, which should trigger the method provided as an argument to the `.subscribe()`
    method after the time according to `searchDebounceTime` has passed. We then used
    the `tick()` method with the value of `searchDebounceTime` so it simulates an
    asynchronous passage of time. Then we write our `expect()` block to check whether
    the `searchUsers()` method should or shouldn''t have been called. Finally, at
    the end of the tests, we use the `discardPeriodicTasks()` method. We use this
    method so that we don''t face the `Error: 1 periodic timer(s) still in the queue.`
    error and our tests work.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'RxJS DebounceTime operator: [https://rxjs-dev.firebaseapp.com/api/operators/debounceTime](https://rxjs-dev.firebaseapp.com/api/operators/debounceTime)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own custom form control using ControlValueAccessor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular forms are great. While they support the default HTML tags like input,
    textarea etc., sometimes, you would want to define your own components that take
    a value from the user. It would be great if the variables of those inputs were
    a part of the Angular form you're using already.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you'll learn how to create your own custom Form Control using
    the ControlValueAccessor API, so you can use the Form Control with both Template
    Driven forms and Reactive Forms.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project for this recipe resides in `chapter08/start_here/custom-form-control`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab and you should see the following
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.27 – Custom form control app running on http://localhost:4200'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.27_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.27 – Custom form control app running on http://localhost:4200
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let's see the steps involved in this
    recipe in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have a simple Angular app. It has two inputs and a **Submit** button. The
    inputs are for a review and they ask the user to provide a value for the rating
    of this imaginary item and any comments the user wants to provide. We''ll convert
    the Rating input into a custom Form Control using the ControlValueAccessor API.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a component for our custom form control. Open the terminal in
    the project root and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll now create the stars UI for the rating component. Modify the `rating.component.html`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the styles for the rating component to the `rating.component.scss` file
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to modify the `RatingComponent` class to introduce the necessary
    methods and properties. Let''s modify the `rating.component.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to use this rating component instead of the input that we already
    have in the `home.component.html` file. Modify the file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If you refresh the app now and hover on the stars, you can see the color changing
    as you hover over the stars. The selected rating is also highlighted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.28 – Rating component with hovered stars'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.28_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.28 – Rating component with hovered stars
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now implement the `ControlValueAccessor` interface for our rating component.
    It requires a couple of methods to be implemented and we''ll start with the `onChange()`
    and `onTouched()` methods. Modify the `rating.component.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll now add the required methods to disable the input when required and
    to set the value of the form control, in other words, the `setDisabledState()`
    and `writeValue()` methods. We''ll also add the `disabled` and `value` properties
    to our `RatingComponent` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to use the `disabled` property to prevent any UI changes when it is
    `true`. The value of the `value` variable shouldn''t be updated either. Modify
    the `rating.component.ts` file to do so as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make sure that we send the value of the `value` variable to `ControlValueAccessor`
    because that''s what we want to access later. Also, let''s set the `disabled`
    property back to `false`. Update the `selectRating` method in the `RatingComponent`
    class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to tell Angular that our `RatingComponent` class has a value accessor,
    otherwise using the `formControlName` attribute on the `<app-rating>` element
    will throw errors. Let''s add an `NG_VALUE_ACCESSOR` provider to the `RatingComponent`
    class''s decorator as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'If you refresh the app now, select a rating, and hit the **Submit** button,
    you should see the values being logged as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.29 – Form value logged using the custom form control'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.29_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.29 – Form value logged using the custom form control
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! You just learned how to create a custom form control using `ControlValueAccessor`.
    Refer to the next section to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We started the recipe by creating a component that we can use to provide a
    rating for the review we have to submit. We started off by adding the template
    and the styles for the rating component. Notice that we are using an `[ngClass]`
    directive on each of the star elements to add the `rating__star--active` class
    conditionally. Let''s discuss each condition now:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(isMouseOver && hoveredRating >= star)`: This condition relies on the `isMouseOver`
    and `hoveredRating` variables. The `isMouseOver` variable becomes `true` as soon
    as we mouse over any star and is turned back to `false` when we move away from
    the star. This means that it is only `true` when we''re hovering over a star.
    `hoveredRating` tells us which star we''re hovering over at the moment and is
    assigned the star''s value, in other words, a value from `1` to `5`. So, this
    condition is only true when we''re doing a mouseover, and the hovered star''s
    rating is greater than the value of the current star. So, if we''re hovering over
    the fourth star, all the stars from value `1` to `4` will be highlighted as they''ll
    have the `rating__star--active` class conditionally assigned to them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(!isMouseOver && value >= star)`: This condition relies on the `isMouseOver`
    variable that we discussed previously and the `value` variable. The `value` variable
    holds the value of the selected rating, which is updated when we click on a star.
    So, this condition is applied when we''re not doing a mouseover and we have the
    value of the `value` variable greater than the current star. This is especially
    beneficial when you have a greater value assigned to the `value` variable and
    try to hover over a star with a lesser value, in which case, all the stars with
    values greater than the hovered star will not be highlighted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then we used three events on each star: `mouseenter`, `mouseleave`, and `click`,
    and then used our `onRatingMouseEnter`, `onRatingMouseLeave`, and `selectRating`
    methods, respectively, for these events. All of this was designed to ensure that
    the entire UI is fluent and has a good user experience. We then implemented the
    `ControlValueAccessor` interface for our rating component. When we do that, we
    need to define the `onChange` and `onTouched` methods as empty methods, which
    we did as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we used the `registerOnChange` and `registerOnTouched` methods from `ControlValueAccessor`
    to assign our methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We registered these functions because whenever we do a change in our component
    and want to let `ControlValueAccessor` know that the value has changed, we need
    to call the `onChange` method ourselves. We do that in the `selectRating` method
    as follows, which makes sure that when we select a rating, we set the form control''s
    value to the value of the selected rating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The other way around is when we need to know when the form control''s value
    is changed from outside the component. In this case, we need to assign the updated
    value to the `value` variable. We do that in the `writeValue` method from the
    `ControlValueAccessor` interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: What if we don't want the user to provide a value for the rating? In other words,
    we want the rating form control to be disabled. For this, we did two things. First,
    we used the `disabled` property as an `@Input()`, so we can pass and control it
    from the parent component when needed. Secondly, we used the `setDisabledState`
    method from the `ControlValueAccessor` interface, so whenever the form control's
    `disabled` state is changed, apart from `@Input()`, we set the `disabled` property
    ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we wanted Angular to know that this `RatingComponent` class has a
    value accessor. This is so that we can use the Reactive forms API, specifically,
    the `formControlName` attribute with the `<app-rating>` selector, and use it as
    a form control. To do that, we provide our `RatingComponent` class as a provider
    to its `@Component` definition decorator using the `NG_VALUE_ACCESSOR` injection
    token as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we''re using the `useExisting` property with the `forwardRef()` method
    providing our `RatingComponent` class in it. We need to provide `multi: true`
    because Angular itself registers some value accessors using the `NG_VALUE_ACCESSOR`
    injection token, and there may also be third-party form controls.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve set everything up, we use `formControlName` on our rating component
    in the `home.component.html` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Custom form control in Angular by Thoughtram: [https://blog.thoughtram.io/angular/2016/07/27/custom-form-controls-in-angular-2.html](https://blog.thoughtram.io/angular/2016/07/27/custom-form-controls-in-angular-2.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ControlValueAccessor docs: [https://angular.io/api/forms/ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
