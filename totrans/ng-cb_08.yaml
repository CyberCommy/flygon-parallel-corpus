- en: '*Chapter 8*: Mastering Angular Forms'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting user inputs is an integral part of almost any modern app that we use.
    Whether it is authenticating users, asking for feedback, or filling out business-critical
    forms, knowing how to implement and present forms to end users is always an interesting
    challenge. In this chapter, you'll learn about Angular forms and how you can create
    great user experiences using them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the recipes that we''re going to cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first template-driven Angular form
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form validation with template-driven forms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing template-driven forms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first Reactive form
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form validation with Reactive forms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an asynchronous validator function
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Reactive forms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using debounce with Reactive form control
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own custom form control using `ControlValueAccessor`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the recipes in this chapter, make sure you have **Git** and **NodeJS** installed
    on your machine. You also need to have the `@angular/cli` package installed, which
    you can do with `npm install -g @angular/cli` from your terminal. The code for
    this chapter can be found at [https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter08](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter08).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first template-driven Angular form
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start getting familiar with Angular forms in this recipe. In this one,
    you'll learn about the basic concepts of template-driven forms and will create
    a basic Angular form using the template-driven forms API.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project for this recipe resides in `chapter08/start_here/template-driven-forms`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab and you should see the following
    view:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Template-driven forms app running on http://localhost:4200'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.1_B15150.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Template-driven forms app running on http://localhost:4200
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have an Angular app that already has a release log component and a bunch
    of things set up, such as the `ReleaseLog` class under the `src/app/classes` folder.
    So, in this recipe, we''ll create a template-driven form to allow the user to
    pick an app and submit a release version. Let''s get started:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open the terminal in the project''s root and create a component for
    the release form as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The command should create a new component in the `src/app/components` folder
    named `ReleaseFormComponent`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应在`src/app/components`文件夹中创建一个名为`ReleaseFormComponent`的新组件。
- en: 'Add the newly created component to the template of `VersionControlComponent`
    and modify the `version-control.component.html` file as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的组件添加到`VersionControlComponent`的模板中，并修改`version-control.component.html`文件如下：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, let's adjust some styles for the release form to be used within `VersionControlComponent`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们调整一些样式，以便在`VersionControlComponent`中使用发布表单。
- en: 'Modify the `version-control.component.scss` file as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`version-control.component.scss`文件如下：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We'll have two inputs in the `ReleaseFormComponent` template. One to select
    the app we want to release, and the second for the version we want to release.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ReleaseFormComponent`模板中，我们将有两个输入。一个用于选择我们要发布的应用程序，另一个用于我们要发布的版本。
- en: 'Let''s modify the `release-form.component.ts` file to add the `Apps` enum as
    a local property that we can later use in the template:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改`release-form.component.ts`文件，将`Apps`枚举添加为一个本地属性，以便我们稍后可以在模板中使用：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s now add the template for our form. Modify the `release-form.component.html`
    file and add the following code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们添加我们表单的模板。修改`release-form.component.html`文件，并添加以下代码：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We now need to integrate the template-driven form. Let''s add `FormsModule`
    to the `app.module.ts` file as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要集成模板驱动表单。让我们在`app.module.ts`文件中添加`FormsModule`，如下所示：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can now make our form work in the template. Let''s modify the `release-form.component.html`
    file to create a template variable for the form, named `#releaseForm`. We will
    also use the `[(ngModel)]` binding for both the inputs against appropriate values
    for the `newLog` property as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以让我们的表单在模板中工作。让我们修改`release-form.component.html`文件，为表单创建一个模板变量，命名为`#releaseForm`。我们还将使用`[(ngModel)]`绑定来针对`newLog`属性的适当值：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a method for when the form will be submitted. Modify the `release-form.component.ts`
    file to add a new method named `formSubmit`. When this method is called, we''ll
    emit a new instance of `ReleaseLog` using an Angular `@Output` emitter as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个当表单提交时将被调用的方法。修改`release-form.component.ts`文件，添加一个名为`formSubmit`的新方法。当调用此方法时，我们将使用Angular的`@Output`发射器发出`ReleaseLog`的新实例，如下所示：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Update the template now to use the `formSubmit` method on the form''s submission
    and modify the `release-form.component.html` file as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更新模板，使用表单提交上的`formSubmit`方法，并修改`release-form.component.html`文件如下：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We now need to modify `VersionControlComponent` to be able to act on the new
    release log emitted. In order to do so, modify the `version-control.component.html`
    file to listen to the `newReleaseLog` output event from `ReleaseFormComponent`
    as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要修改`VersionControlComponent`以便对新发布日志进行操作。为了这样做，修改`version-control.component.html`文件，以便监听来自`ReleaseFormComponent`的`newReleaseLog`输出事件，如下所示：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Cool! Let''s create the `addNewReleaseLog` method in the `version-control.component.ts`
    file and add the `ReleaseLog` received to the `releaseLogs` array. Your code should
    look as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太棒了！让我们在`version-control.component.ts`文件中创建`addNewReleaseLog`方法，并将接收到的`ReleaseLog`添加到`releaseLogs`数组中。您的代码应如下所示：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Awesome! Within a few minutes, we were able to create our first template-driven
    form in Angular. If you refresh the app now and try creating some releases, you
    should see something similar to the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！在几分钟内，我们就能够在Angular中创建我们的第一个模板驱动表单。如果现在刷新应用程序并尝试创建一些发布，您应该会看到类似以下内容的东西：
- en: '![Figure 8.2 – Template-driven forms app final output'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 - 模板驱动表单应用程序最终输出'
- en: '](image/Figure_8.2_B15150.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.2_B15150.jpg)'
- en: Figure 8.2 – Template-driven forms app final output
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 - 模板驱动表单应用程序最终输出
- en: Now that you know how the template-driven forms are created, let's see the next
    section to understand how it works.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何创建模板驱动表单，让我们看看下一节，了解它是如何工作的。
- en: How it works…
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The key to using template-driven forms in Angular resides in `FormsModule`,
    the `ngForm` directive, by creating a **template variable** using the `ngForm`
    directive and using the `[(ngModel)]` two-way data binding along with the `name`
    attributes for inputs in the template. We began by creating a simple form with
    some inputs. Then, we added the `FormsModule`, which is necessary for using the
    `ngForm` directive and the `[(ngModel)]` two-way data binding. Once we added the
    module, we could use both the directive and the data binding with our newly created
    local property named `newLog` in the `ReleaseFormComponent`. Notice that it could
    be an instance of the `ReleaseLog` class, but we kept it as an object of the `IReleaseLog`
    type instead because we don't want the `ReleaseLog` class's `message` property
    as we don't use it. With the `[(ngModel)]` usages and the `#releaseForm` template
    variable in place, we could submit the form using the `ngSubmit` emitter of Angular's
    `<form>` directive. Notice that we pass the `releaseForm` variable to the `formSubmit`
    method, which makes it easier to test the functionality for us. Upon submitting
    the form, we use the form's value to create a new `ReleaseLog` item and we emit
    it using the `newReleaseLog` output emitter. Notice that if you provide an invalid
    `version` for the new release log, the app will throw an error and will not create
    a release log. This is because we validate the version in the `constructor` of
    the `ReleaseLog` class. Finally, when this `newReleaseLog` event is captured by
    `VersionControlComponent`, it calls the `addNewReleaseLog` method, which adds
    our newly created release log to the `releaseLogs` array. And since the `releaseLogs`
    array is passed as an `@Input()` to `ReleaseLogsComponent`, it immediately shows
    it right away.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中使用模板驱动表单的关键在于`FormsModule`，`ngForm`指令，通过使用`ngForm`指令创建**模板变量**，并在模板中为输入使用`[(ngModel)]`双向数据绑定以及`name`属性。我们首先创建了一个带有一些输入的简单表单。然后，我们添加了`FormsModule`，这是必须的，用于使用`ngForm`指令和`[(ngModel)]`双向数据绑定。一旦我们添加了该模块，我们就可以在`ReleaseFormComponent`中使用该指令和数据绑定，使用新创建的本地属性命名为`newLog`。请注意，它可以是`ReleaseLog`类的实例，但我们将其保留为`IReleaseLog`类型的对象，因为我们不使用`ReleaseLog`类的`message`属性。通过使用`[(ngModel)]`和`#releaseForm`模板变量，我们可以使用Angular的`<form>`指令的`ngSubmit`发射器提交表单。请注意，我们将`releaseForm`变量传递给`formSubmit`方法，这样可以更容易地测试功能。提交表单时，我们使用表单的值创建一个新的`ReleaseLog`项目，并使用`newReleaseLog`输出发射器发射它。请注意，如果为新发布日志提供无效的`version`，应用程序将抛出错误并且不会创建发布日志。这是因为我们在`ReleaseLog`类的`constructor`中验证了版本。最后，当`VersionControlComponent`捕获到`newReleaseLog`事件时，它调用`addNewReleaseLog`方法，将我们新创建的发布日志添加到`releaseLogs`数组中。由于`releaseLogs`数组作为`@Input()`传递给`ReleaseLogsComponent`，因此它会立即显示出来。
- en: See also
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Building a template-driven form in Angular: [https://angular.io/guide/forms#building-a-template-driven-form](https://angular.io/guide/forms#building-a-template-driven-form)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular中构建模板驱动表单：[https://angular.io/guide/forms#building-a-template-driven-form](https://angular.io/guide/forms#building-a-template-driven-form)
- en: Form validation with template-driven forms
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板驱动表单进行表单验证
- en: A great user experience is key to acquiring more users that love to use your
    applications. And using forms is one of those things that users don't really enjoy.
    To make sure that users spend the least amount of time filling in forms and are
    done with them faster, we can implement form validation to make sure that users
    enter the appropriate data a.s.a.p. In this recipe, we're going to look at how
    we can implement form validation in template-driven forms.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的用户体验是获得更多喜欢使用您的应用程序的用户的关键。而使用表单是用户并不真正喜欢的事情之一。为了确保用户在填写表单上花费最少的时间，并且尽快完成，我们可以实现表单验证，以确保用户尽快输入适当的数据。在这个配方中，我们将看看如何在模板驱动表单中实现表单验证。
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter08/start_here/tdf-form-validation`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的项目位于`chapter08/start_here/tdf-form-validation`中：
- en: Open the project in Visual Studio Code.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行 `npm install` 来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab and you should see the app as
    follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器选项卡中打开应用程序，并且您应该看到应用程序如下所示：
- en: '![Figure 8.3 – TDF form validation app running on http://localhost:4200'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 - 运行在http://localhost:4200上的TDF表单验证应用程序'
- en: '](image/Figure_8.3_B15150.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.3_B15150.jpg)'
- en: Figure 8.3 – TDF form validation app running on http://localhost:4200
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 - 运行在http://localhost:4200上的TDF表单验证应用程序
- en: Now that we have the app running locally, let's see the steps involved in this
    recipe in the next section.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用程序，让我们在下一节中看看这个配方涉及的步骤。
- en: How to do it…
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We now have the app from the previous recipe, a simple Angular app with one
    template-driven form using the `ngForm` and `ngModel` directives. The form is
    used to create release logs. In this recipe, we''re going to make this form better
    in terms of validating the input as the user types the input. Let''s get started:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了上一个配方中的应用程序，一个简单的Angular应用程序，使用`ngForm`和`ngModel`指令创建一个模板驱动表单。该表单用于创建发布日志。在这个配方中，我们将在用户输入时使这个表单更好地验证输入。让我们开始吧：
- en: 'First of all, we''ll add some validators from the `@angular/forms` package
    that are part of the Reactive forms API. We''ll apply the **required** validation
    to both inputs and a **regex** validation on the version input. We need to create
    template variables for both our inputs. We will name them `nameInput` and `versionInput`,
    respectively. Modify the code in the `release-form.component.html` file so that
    it looks as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将从`@angular/forms`包中添加一些验证器，这些验证器是响应式表单API的一部分。我们将对两个输入应用**required**验证，并对版本输入应用**regex**验证。我们需要为我们的两个输入创建模板变量。我们将分别命名它们为`nameInput`和`versionInput`。修改`release-form.component.html`文件中的代码，使其如下所示：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can now use the template variables to apply validations. Let''s start with
    the name input. In terms of validation, the name input shouldn''t be empty and
    an app should be selected from the select box. Let''s show a default Bootstrap
    alert when the input is invalid. Modify the code in the `release-form.component.html`
    file. It should look as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用模板变量来应用验证。让我们从名称输入开始。在验证方面，名称输入不应为空，并且应从选择框中选择一个应用程序。当输入无效时，让我们显示一个默认的Bootstrap警报。修改`release-form.component.html`文件中的代码。它应该如下所示：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To validate the version name input, we need to apply the `SEMANTIC_VERSION`
    regex from our `src/app/constants/regexes.ts` file. Add the constant as a local
    property in the `ReleaseFormComponent` class to the `release-form.component.ts`
    file as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证版本名称输入，我们需要应用来自`src/app/constants/regexes.ts`文件的`SEMANTIC_VERSION`正则表达式。将常量添加为`ReleaseFormComponent`类中的本地属性，添加到`release-form.component.ts`文件中，如下所示：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, use `versionInputRegex` in the template to apply the validation and show
    the related error as well. Modify the `release-form.component.html` file so that
    the code looks as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在模板中使用`versionInputRegex`来应用验证并显示相关错误。修改`release-form.component.html`文件，使代码如下所示：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Refresh the app and try to invalidate both inputs by selecting the first option
    named **--Choose--** from the **Select App** drop-down menu and by emptying the
    version input field. You should see the following errors:![Figure 8.4 – Displaying
    input errors using ngModel and validation
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新应用程序，并尝试通过从“选择应用程序”下拉菜单中选择名为**--选择--**的第一个选项，并清空版本输入字段来使两个输入无效。您应该会看到以下错误：![图8.4
    - 使用ngModel和验证显示输入错误
- en: '](image/Figure_8.4_B15150.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.4_B15150.jpg)'
- en: Figure 8.4 – Displaying input errors using ngModel and validation
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 - 使用ngModel和验证显示输入错误
- en: 'Next, we''re going to add some styles to make our inputs more visual when it
    comes to validation. Let''s add some styles to the `release-form.component.scss`
    file as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一些样式，使我们的输入在验证时更加直观。让我们在`release-form.component.scss`文件中添加一些样式，如下所示：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, let''s make the validation around the form submission. We''ll disable
    the **Submit** button if the inputs do not have valid values. Let''s modify the
    template in `release-form.component.html` as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们围绕表单提交进行验证。如果输入值无效，我们将禁用**提交**按钮。让我们修改`release-form.component.html`模板如下：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you refresh the app now, you'll see that the submit button is disabled whenever
    one or more inputs are invalid.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在刷新应用程序，您会发现只要一个或多个输入无效，提交按钮就会被禁用。
- en: Great! You just learned how to validate template-driven forms and to make the
    overall user experience with template-driven forms slightly better.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！您刚学会了如何验证模板驱动表单，并使模板驱动表单的整体用户体验稍微好一些。
- en: How it works…
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The core components of this recipe were the `ngForm` and `ngModel` directives.
    We could easily identify whether the submit button should be clickable (not disabled)
    or not based on whether the form is valid, that is, if all the inputs in the form
    have valid values. Note that we used the template variable created using the `#releaseForm="ngForm"`
    syntax on the `<form>` element. This is possible due to the ability of the `ngForm`
    directive to be exported into a template variable. Therefore, we were able to
    use the `releaseForm.invalid` property in the `[disabled]` binding of the submit
    button to conditionally disable it. We also showed the errors on individual inputs
    based on the condition that the input might be invalid. In this case, we show
    the Bootstrap `alert` element ( a `<div>` with the CSS class `alert`). We also
    use Angular's provided classes, `ng-valid` and `ng-invalid`, on the form inputs
    to highlight the input in a certain way depending on the validity of the input's
    value. What's interesting about this recipe is that we validated the app name's
    input by making sure it contains a non-falsy value where the first `<option>`
    of the `<select>` box has the value `""`. And what's even more fun is that we
    also validated the version name right when the user types it using the `[pattern]`
    binding on the input to a regex. Otherwise, we'd have to wait for the user to
    submit the form, and then it would have been validated. Thus, we're providing
    a great user experience by providing the errors as the user types the version.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的核心组件是`ngForm`和`ngModel`指令。我们可以很容易地确定提交按钮是否应该可点击（未禁用），这取决于表单是否有效，也就是说，如果表单中的所有输入都具有有效值。请注意，我们在`<form>`元素上使用了使用`#releaseForm="ngForm"`语法创建的模板变量。这是由于`ngForm`指令能够导出为模板变量。因此，我们能够在提交按钮的`[disabled]`绑定中使用`releaseForm.invalid`属性来有条件地禁用它。我们还根据输入可能无效的条件显示单个输入的错误。在这种情况下，我们显示Bootstrap的`alert`元素（带有CSS类`alert`的`<div>`）。我们还在表单输入上使用Angular提供的类`ng-valid`和`ng-invalid`，以根据输入值的有效性以某种方式突出显示输入。这个教程有趣的地方在于，我们通过确保应用程序名称的输入包含一个非假值来验证它，其中`<select>`框的第一个`<option>`的值为`""`。更有趣的是，我们还通过在输入上绑定`[pattern]`到一个正则表达式来验证用户输入版本名称。否则，我们将不得不等待用户提交表单，然后才能进行验证。因此，我们通过在用户输入版本时提供错误信息来提供出色的用户体验。
- en: See also
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Show and hide validation error messages (Angular Docs): [https://angular.io/guide/forms#show-and-hide-validation-error-messages](https://angular.io/guide/forms#show-and-hide-validation-error-messages)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示和隐藏验证错误消息（Angular文档）：[https://angular.io/guide/forms#show-and-hide-validation-error-messages](https://angular.io/guide/forms#show-and-hide-validation-error-messages)
- en: 'NgForm docs: `https://angular.io/api/forms/NgForm`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NgForm文档：`https://angular.io/api/forms/NgForm`
- en: Testing template-driven forms
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试模板驱动表单
- en: To make sure we build robust and bug-free forms for end users, it is a really
    good idea to have tests relating to your forms. It makes the code more resilient
    and less prone to errors. In this recipe, you'll learn how to test your template-driven
    forms using unit tests.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们为最终用户构建健壮且无错误的表单，最好是对表单进行测试。这样可以使代码更具弹性，更不容易出错。在本教程中，您将学习如何使用单元测试来测试模板驱动表单。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter08/start_here/testing-td-forms`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的项目位于`chapter08/start_here/testing-td-forms`中。
- en: Open the project in Visual Studio Code.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`以安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab and you should see the app as
    follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器选项卡中打开应用程序，您应该会看到应用程序如下所示：
- en: '![Figure 8.5 – The Testing Template-Driven Forms app running on http://localhost:4200'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5 - 正在运行的Testing Template-Driven Forms应用程序，网址为http://localhost:4200'
- en: '](image/Figure_8.5_B15150.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.5_B15150.jpg)'
- en: Figure 8.5 – The Testing Template-Driven Forms app running on http://localhost:4200
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 - 正在运行的Testing Template-Driven Forms应用程序，网址为http://localhost:4200
- en: Now that we have the app running locally, let's see the steps involved in this
    recipe in the next section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用程序，让我们在下一节中看看这个配方涉及的步骤。
- en: How to do it…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We have the app from the previous recipe that contains a template-driven form
    used to create release logs. The form also has validations applied to the inputs.
    Let''s start looking into how we can test this form:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有来自上一个配方的应用程序，其中包含用于创建发布日志的模板驱动表单。该表单还对输入应用了验证。让我们开始研究如何测试这个表单：
- en: 'First of all, run the following command to run the unit tests:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，运行以下命令来运行单元测试：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once the command is run, you should see a new instance of the Chrome window
    being opened that runs the unit tests. One test out of the six we have has failed.
    You will probably see something like the following in the automated Chrome window:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，您应该看到打开一个新的Chrome窗口来运行单元测试。我们六个测试中的一个测试失败了。您可能会在自动化的Chrome窗口中看到类似以下内容：
- en: '![Figure 8.6 – Unit tests with Karma and Jasmine running in an automated Chrome
    window'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.6 - 使用Karma和Jasmine在自动化Chrome窗口中运行单元测试'
- en: '](image/Figure_8.6_B15150.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.6_B15150.jpg)'
- en: Figure 8.6 – Unit tests with Karma and Jasmine running in an automated Chrome
    window
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 - 使用Karma和Jasmine在自动化Chrome窗口中运行单元测试
- en: 'The `ReleaseFormComponent > should create` test is failing because we don''t
    have `FormsModule` added to the tests. Notice the `Export of name ''ngForm'' not
    found` error. Let''s import `FormsModule` into the testing module''s configuration
    in `release-form.component.spec.ts` as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ReleaseFormComponent > should create`测试失败了，因为我们没有将`FormsModule`添加到测试中。注意`Export
    of name ''ngForm'' not found`错误。让我们在`release-form.component.spec.ts`中的测试模块配置中导入`FormsModule`，如下所示：'
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you look at the tests now, you should see all the tests passing as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在查看测试，您应该看到所有测试都通过了，如下所示：
- en: '![Figure 8.7 – All tests pass after importing FormsModule into the appropriate
    test'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7 - 在适当的测试中导入FormsModule后，所有测试都通过了'
- en: '](image/Figure_8.7_B15150.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.7_B15150.jpg)'
- en: Figure 8.7 – All tests pass after importing FormsModule into the appropriate
    test
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 - 在适当的测试中导入FormsModule后，所有测试都通过了
- en: To test the form correctly, we'll add a couple of tests, one for successful
    input and one for each invalid input. For that, we need to access the form in
    our component since we're writing unit tests.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确测试表单，我们将添加一些测试，一个用于成功的输入，一个用于每个无效的输入。为此，我们需要访问我们组件中的表单，因为我们正在编写单元测试。
- en: 'Let''s access the `#releaseForm` in our component class using the `@ViewChild()`
    decorator in the `release-form.component.ts` file as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`release-form.component.ts`文件中使用`@ViewChild()`装饰器来访问我们组件类中的`#releaseForm`，如下所示：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s add a new test now. We''ll write a test that should validate the case
    for when both the inputs have valid values. Add the test to the `release-form.component.spec.ts`
    file as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们添加一个新的测试。我们将编写一个测试，用于验证当两个输入都具有有效值时的情况。将测试添加到`release-form.component.spec.ts`文件中，如下所示：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The new test is failing so far. Let''s try to fill the values in the form,
    submit the button, and make sure that our `@Output` emitter named `newReleaseLog`
    emits the correct value from `releaseForm`. The content of the test should look
    as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，新的测试失败了。让我们尝试填写表单中的值，提交按钮，并确保我们的`@Output`发射器命名为`newReleaseLog`从`releaseForm`中发射出正确的值。测试的内容应该如下所示：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When you save the file, you should see the new test passing with the expected
    values. It should appear as follows in the Chrome tab:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – New test for successful form submission passing'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.8_B15150.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8 – New test for successful form submission passing
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a test for the case when we have an incorrect version provided in
    the form. The submit button should be disabled and we should have an error thrown
    by the `formSubmit` method. Add a new test to your `release-form.component.spec.ts`
    file as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s add our final test, which makes sure that the submit button is disabled
    when we have not selected an app for the release log. Add a new test to the `release-form.component.spec.ts`
    file as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you look at the Karma tests window, you should see all the new tests passing
    as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – All tests passing for the recipe'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.9_B15150.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.9 – All tests passing for the recipe
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! You now know a bunch of techniques for testing your template-driven
    forms. Some of these techniques might still require some explanation. See the
    next section to understand how it all works.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing template-driven forms can be a bit of a challenge as it depends on
    how complex the form is, what use cases you want to test, and how complex those
    use cases are. In our recipe, the first thing we did was to include `FormsModule`
    in the imports of the test file for `ReleaseFormComponent`. This makes sure that
    the tests know the `ngForm` directive and do not throw relevant errors. For the
    test with all the successful inputs, we spied on the `newReleaseLog` emitter''s
    `emit` event defined in the `ReleaseFormComponent` class. This is because we know
    that when the inputs are correct, the user should be able to click the submit
    button, and as a result, inside the `formSubmit` method, the `emit` method of
    the `newReleaseLog` emitter will be called. Note that we''re using `fixture.whenStable()`
    in each of our tests. This is to make sure that Angular has done the compilation
    and our `ngForm`, named `#releaseForm`, is ready. For the `should disable the
    submit button when version is incorrect` test, we rely on `formSubmit` to throw
    an error. This is because we know that an invalid version will cause an error
    in the `constructor` of the `ReleaseLog` class when creating a new release log.
    One interesting thing in this test is that we use the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The interesting thing here is that we needed to call the `formSubmit` method
    ourselves with `releaseForm`. We couldn't just do it by writing `expect(component.formSubmit(component.releaseForm)).toThrowError(expectedError);`
    because that would rather call the function directly there and would result in
    the error. So, we need to pass an anonymous function here that Jasmine will call
    and would expect this anonymous function to throw an error. And finally, we make
    sure that our submit button is enabled or disabled by first getting the button
    using a `querySelector` on `fixture.nativeElement`. We then check the `disabled`
    attribute on the submit button using `submitButton.hasAttribute('disabled')`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing template-driven forms: [https://angular.io/guide/forms-overview#testing-template-driven-forms](https://angular.io/guide/forms-overview#testing-template-driven-forms)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first Reactive form
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've learned about template-driven forms in the previous recipes and are now
    confident in building Angular apps with them. Now guess what? Reactive forms are
    even better. Many known engineers and businesses in the Angular community recommend
    using Reactive forms. The reason is their ease of use when it comes to building
    complex forms. In this recipe, you'll build your first Reactive form and will
    learn its basic usage.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project for this recipe resides in `chapter08/start_here/reactive-forms`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done , run `ng serve -o`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the name of the first user and you should see the following view:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.10 – The Reactive Form app running on http://localhost:4200'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.10_B15150.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.10 – The Reactive Form app running on http://localhost:4200
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let's see the steps involved in this
    recipe in the next section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have an app that has `ReleaseLogsComponent`, which shows a bunch
    of release logs that we create. We also have `ReleaseFormComponent`, which has
    a form by means of which the release logs will be created. We now have to make
    our current form a Reactive form using the Reactive forms API. Let''s get started:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to import `ReactiveFormsModule` into the imports of our
    `AppModule`. Let''s do it by modifying the `app.module.ts` file as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s create the Reactive form now. We''ll create a `FormGroup` in our `ReleaseFormComponent`
    class with the required controls. Modify the `release-form.component.ts` file
    as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that we have the form named `releaseForm` in place, let''s bind it to the
    form by using it in the template. Modify the `release-form.component.html` file
    as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Great! Now that we have the form group bound, we can also bind the individual
    form controls so that when we finally submit the form, we can get the value out
    for each individual form control. Modify the `release-form.component.html` file
    further as follows:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s decide what will happen when we submit this form. We''ll call a method
    named `formSubmit` in the template and pass `releaseForm` in it when the form
    is submitted. Modify the `release-form.component.html` file as follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `formSubmit` method doesn''t yet exist. Let''s create it now in the `ReleaseFormComponent`
    class. We''ll also log the value on the console and emit the value using an `@Output`
    emitter. Modify the `release-form.component.ts` file as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you refresh the app now, complete the form, and hit **Submit**, you should
    see a log on the console as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Log displaying the values submitted using the Reactive form'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.11_B15150.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.11 – Log displaying the values submitted using the Reactive form
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''ve emitted the value of the newly created release log via the `newReleaseLog`
    output emitter, we can listen to this event in the `version-control.component.html`
    file and add the new log accordingly. Let''s modify the file as follows:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Refresh the app and you should see the new release log being added to the release
    logs view. You should see the logs on the console as well, as shown in the following
    screenshot:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.12 – New logs being added to the logs view on form submission'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.12_B15150.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.12 – New logs being added to the logs view on form submission
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! So, now you know how to create a basic Reactive form using the Reactive
    forms API. Refer to the next section to understand how it all works.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipe begins with having a basic HTML form in our Angular app with no Angular
    magic bound to it. We first started importing `ReactiveFormsModule` in the `AppModule`.
    If you're using the Angular Language Service with the editor of your choice, you
    might see an error as you import `ReactiveFormsModule` into the app and don't
    bind it with a Reactive form, in other words, with a `FormGroup`. Well, that's
    what we did. We created a reactive form using the `FormGroup` constructor and
    created the relevant form controls using the `FormControl` constructor. We then
    listened to the `ngSubmit` event on the `<form>` element to extract the value
    of `releaseForm`. Once done, we emitted this value using the `@Ouput()` named
    `newReleaseLog`. Notice that we also defined the type of the value that this emitter
    will emit as `IReleaseLog`; it is good practice to define those. This emitter
    was required because `ReleaseLogsComponent` is a sibling of `ReleaseFormComponent`
    in the component's hierarchy. Therefore, we're communicating through the parent
    component, `VersionControlComponent`. Finally, we listen to the `newReleaseLog`
    event's emission in the `VersionControlComponent` template and add a new log to
    the `releaseLogs` array via the `addNewReleaseLog` method. And this `releaseLogs`
    array is being passed to `ReleaseLogsComponent`, which displays all the logs as
    they're added.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular''s guide to Reactive forms: [https://angular.io/guide/reactive-forms](https://angular.io/guide/reactive-forms)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form validation with Reactive forms
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, you learned how to create a Reactive form. Now, we're
    going to learn how to test them. In this recipe, you'll learn some basic principles
    of testing Reactive forms. We're going to use the same example from the previous
    recipe (the release logs app) and will implement a number of test cases.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project that we are going to work with resides in `chapter08/start_here/validating-reactive-forms`
    inside the cloned repository:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab and you should see it as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – The Validating Reactive Forms  app running on http://localhost:4200'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.13_B15150.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.13 – The Validating Reactive Forms app running on http://localhost:4200
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let's see the steps involved in this
    recipe in the next section.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we''re using the Release Logs application that has the Reactive
    form implemented already, although we don''t have any sort of validation on the
    inputs so far. If you just select an app and submit the form, you''ll see an error
    on the console as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Error when submitting the Reactive form app without form validations'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.14_B15150.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.14 – Error when submitting the Reactive form app without form validations
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to incorporate some form validations to enhance the user experience
    and to make sure that the form can''t be submitted with invalid input. Let''s
    begin:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll first add some validations from the `@angular/forms` package, which
    are part of the Reactive Forms API. We''ll apply the `required` validator on both
    inputs and the `pattern` validator on the `version` form control. Update the `release-form.component.ts`
    file as follows:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we''ll add the hints to the view to show the user errors when an invalid
    input is selected. Modify the `release-form.component.html` file as follows:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We''ll also add some styles to show the errors with a better UI. Add the following
    styles to the `release-form.component.scss` file:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Refresh the app and you should see the inputs with red borders when the input
    values are wrong. The errors once you enter or select an invalid input will look
    as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – Red borders shown on invalid input values'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.15_B15150.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.15 – Red borders shown on invalid input values
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s make the validation around the form submission. We''ll disable
    the **Submit** button if the inputs do not have valid values. Let''s modify the
    template in `release-form.component.html` as follows:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you refresh the app now, you'll see that the submit button is disabled whenever
    one or more inputs are invalid.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: And that concludes the recipe. Let's look at the next section to see how it
    works.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We started the recipe by adding the validators, and Angular has got a bunch
    of validators out of the box, including `Validators.email`, `Validators.pattern`,
    and `Validators.required`. We used the `required` validator with the `pattern`
    validator in our recipe for the inputs for the app name and the version, respectively.
    After that, to show the hints/errors for invalid inputs, we added some conditional
    styles to show a border-bottom on the inputs. We also added some `<div>` elements
    with `class="alert alert-danger"`, which are basically Bootstrap alerts to show
    the errors on invalid values for the form controls. Notice that we''re using the
    following pattern to hide the error elements:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We're using the condition with `.pristine` to make sure that as soon as the
    user selects the correct input and the input is modified, we hide the error again
    so that it doesn't show while the user is typing in the input or making another
    selection. Finally, we made sure that the form cannot even be submitted if the
    values of the form controls are invalid. We disabled the submit button using `[disabled]="releaseForm.invalid"`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular docs for validating Reactive forms: [https://angular.io/guide/reactive-forms#validating-form-input](https://angular.io/guide/reactive-forms#validating-form-input)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an asynchronous validator function
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Form validations are pretty straightforward in Angular, the reason being the
    super-awesome validators that Angular provides out of the box. These validators
    are synchronous, meaning that as soon as you change the input, the validators
    kick in and provide you with information about the validity of the values right
    away. But sometimes, you might rely on some validations from a backend API, for
    instance. These situations would require something called asynchronous validators.
    In this recipe, you're going to create your first asynchronous validator.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project that we are going to work with resides in `chapter08/start_here/asynchronous-validator`
    inside the cloned repository:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab and you should see something
    like the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Asynchronous validators app running on http://localhost:4200'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.16_B15150.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.16 – Asynchronous validators app running on http://localhost:4200
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running, let's see the steps involved in this recipe
    in the next section.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have some things set up in the release logs app. We have a `data.json`
    file residing in the `src/assets` folder that holds the versions for each of our
    target apps for the release logs. We''ll create an async validator to make sure
    that the new releases for each of the applications have a greater version than
    that specified in the `data.json` file. Let''s begin:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''re going to create the async validator function for the recipe.
    Let''s create a method named `versionValidator` in the `VersionService` class
    in the `version.service.ts` file as follows:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We''ll now define the content of the validator function. Let''s modify the
    `versionValidator` method as follows:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now that we have the validator function in place, let''s add that to the form
    control for the version number. Let''s modify the `release-form.component.ts`
    file as follows:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We will now use the validator to enhance the user''s experience of the form
    by modifying the `release-form.component.html` file. For ease of usage, let''s
    wrap the content inside an `<ng-container>` element using the `*ngIf` directive,
    and create a variable within the template for the version form control as follows:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s now add the error message. We''ll use our custom error, `newVersionRequired`,
    from the validator function to show the error when the specified version isn''t
    newer than the previous version. Modify the `release-form.component.html` file
    as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Try to select an app and add a lower version number and you should now see
    the error as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Error being shown when a lower version number is provided'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.17_B15150.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.17 – Error being shown when a lower version number is provided
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'One issue right now is that we are able to submit the form while the asynchronous
    validation is in progress. That''s because Angular, by default, marks the error
    as `null` until the validation is done. To tackle this, we can show a loading
    message instead of the **submit** button in the template. Modify the `release-form.component.html`
    file as follows:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you refresh the app, select an app, and type a valid version, you should
    see the **Please wait…** message as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18 – Loader message while async validation is in progress'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.18_B15150.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.18 – Loader message while async validation is in progress
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'We still have an issue where the user can type and press *Enter* quickly to
    submit the form. To prevent this from happening, let''s add a check in our `formSubmit`
    method in the `release-form.component.ts` file as follows:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, we have another issue to handle. If we select a valid version number
    and change the app, we can still submit the form with the entered version number
    although it is logically wrong. To handle this, we should update the validation
    of the `''version''` form control whenever the value of the `''app''` form control
    changes. To do that, modify the `release-form.component.ts` file as follows:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Cool! So, you now know how to create an asynchronous validator function in Angular
    for form validation within Reactive forms. Since you've finished the recipe, refer
    to the next section to see how this works.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular provides a really easy way to create async validator functions, and
    they're pretty handy too. In this recipe, we started by creating the validator
    function named `versionValidator`. Notice that we have an argument named `appNameControl`
    for the validator function. This is because we want to get the app name for which
    we are validating the version number. Also notice that we have the return type
    set to `AsyncValidatorFn`, which is required by Angular. The validator function
    is supposed to return an `AsyncValidatorFn`, which means it will return a function
    (let's call it the **inner function**), which receives an `AbstractControl` and
    returns an `Observable` of `ValidatorErrors`. Inside the inner function, we use
    the `getVersionLog()` method from `VersionService` to fetch the `data.json` file
    using the `HttpClient` service. Once we get the version from `data.json` for the
    specific app selected, we compare the version entered in the form with the value
    from `data.json` to validate the input. Notice that instead of just returning
    a `ValidationErrors` object with the `newVersionRequired` property set to `true`,
    we actually set it to `previousVersion` so that we can use it later to show it
    to the user.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: After creating the validator function, we attached it to the form control for
    the version name by using the `FormControl.setAsyncValidators()` method in the
    `ReleaseFormComponent` class. We then used the validation error named `newVersionRequired`
    in the template to show the error message, along with the version from the `data.json`
    file.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: We also needed to handle the case that while the validation is in progress,
    the form control is valid until the validation is finished. This allows us to
    submit the form while the validation for the version name was in progress. We
    handle it by hiding the submit button during the validation process by checking
    whether the value of `FormControl.status` is `'PENDING'`. We hide the submit button
    in that case and show the **Please wait…** message in the meantime. Note that
    we also add some logic in the `formSubmit` method of the `ReleaseFormComponent`
    class to check whether `FormControl.status` is `'PENDING'` for the version number,
    in which case, we just do a `return;`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: One more interesting thing in the recipe is that if we added a valid version
    number and changed the app, we could still submit the form. We handle that by
    adding a subscription to `.valueChanges` of the `'app'` form control, so whenever
    that happens, we trigger another validation on the `'version'` form control using
    the `.updateValueAndValidity()` method.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'AsyncValidator Angular docs: [https://angular.io/api/forms/AsyncValidator#provide-a-custom-async-validator-directive](https://angular.io/api/forms/AsyncValidator#provide-a-custom-async-validator-directive)'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Reactive forms
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make sure we build robust and bug-free forms for end users, it is a really
    good idea to have tests around your forms. It makes the code more resilient and
    less prone to errors. In this recipe, you'll learn how to test your template-driven
    forms using unit tests.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project for this recipe resides in `chapter08/start_here/testing-reactive-forms`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab, and you should see the app as
    follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19 – The Testing Reactive Forms app running on http://localhost:4200'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.19_B15150.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.19 – The Testing Reactive Forms app running on http://localhost:4200
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let's see the steps involved in this
    recipe in the next section.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have the Release Logs application that has a Reactive form implemented with
    some validations. In this recipe, we''re going to implement some tests for the
    forms. Let''s get started:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, run the following command to run the unit tests in a separate
    terminal window:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Once the command is run, you should see a new instance of the Chrome window
    being opened that runs the tests as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20 – Unit tests with Karma and Jasmine running in an automated Chrome
    window'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.20_B15150.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.20 – Unit tests with Karma and Jasmine running in an automated Chrome
    window
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add our first test for the case when all the inputs have a valid value.
    In this case, we should have the form submitted and the form''s value emitted
    through the emitter of the `newReleaseLog` output. Modify the `release-form.component.spec.ts`
    file as follows:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you look at the tests now, you should the new test passing as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21 – Test case passing for the successful input'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.21_B15150.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.21 – Test case passing for the successful input
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a test for the case when we have an incorrect version provided in
    the form. The **submit** button should be disabled and we should have an error
    thrown by the `formSubmit` method. Add a new test to your `release-form.component.spec.ts`
    file as follows:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s add our final test, which makes sure that the **submit** button is disabled
    when we have not selected an app for the release log. Add a new test to the `release-form.component.spec.ts`
    file as follows:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you look at the Karma tests window, you should see all the new tests passing
    as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22 – All tests passing for the recipe'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.22_B15150.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.22 – All tests passing for the recipe
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Great! You now know how to write some essential tests for Reactive forms. Refer
    to the next section to understand how it all works.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing Reactive forms doesn''t even require importing `ReactiveFormsModule`
    into the test module as of Angular 10\. For all the tests in our recipe, we spied
    on the `newReleaseLog` emitter''s `emit` event defined in the `ReleaseFormComponent`
    class. This is because we know that when the inputs are correct, the user should
    be able to click the **submit** button, and as a result, inside the `formSubmit`
    method, the `emit` method of the `newReleaseLog` emitter will be called. For the
    test covering the validity of the `''version''` form control, we rely on `formSubmit`
    to throw an error. This is because we know that an invalid version will cause
    an error in the `constructor` of the `ReleaseLog` class when creating a new release
    log. One interesting thing in this test is that we use the following code:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The interesting thing here is that we needed to call the `formSubmit` method
    ourselves with `releaseForm`. We couldn't just do it by writing `expect(component.formSubmit(component.releaseForm)).toThrowError(expectedError);`
    because that would rather call the function directly there and would result in
    an error. So we need to pass an anonymous function here that Jasmine will call
    and would expect this anonymous function to throw an error. And finally, we make
    sure that our **submit** button is enabled or disabled by first getting the button
    using `querySelector` on `fixture.nativeElement`. And then we check the `disabled`
    attribute on the **submit** button using `submitButton.hasAttribute('disabled')`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing Reactive forms: [https://angular.io/guide/forms-overview#testing-reactive-forms](https://angular.io/guide/forms-overview#testing-reactive-forms)'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using debounce with Reactive form control
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're building a medium-to large-scale Angular app with Reactive forms,
    you'll surely encounter a scenario where you might want to use a debounce on a
    Reactive form. It could be for performance reasons, or for saving HTTP calls.
    So, in this recipe, you're going to learn how to use debounce on a Reactive form
    control.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project that we are going to work with resides in `chapter08/start_here/using-debounce-with-rfc`
    inside the cloned repository:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab and you should see it as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.23 – The Using debounce with Reactive Form Control app running on
    http://localhost:4200'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.23_B15150.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.23 – The Using debounce with Reactive Form Control app running on http://localhost:4200
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, you''ll notice that for each character we type into the input, we
    send a new HTTP request to the API shown as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.24 – Multiple HTTP calls sent as we type in the input'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.24_B15150.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.24 – Multiple HTTP calls sent as we type in the input
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let's see the steps involved in this
    recipe in the next section.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we''re using an application that uses the RandomUser.me API
    to get users. As you see in *Figure 8.24*, we send a new HTTP call for every change
    in the input. Let''s begin with the recipe to avoid doing that:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the debounce to the form is super easy. Let''s use the `debounceTime`
    operator in the `home.component.ts` file as follows:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Well, it's funny that this is it for the recipe as far as the task is concerned.
    But I do want to give you more out of this book. So we're going to write some
    interesting tests.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll add a test now to make sure that our `searchUsers` method isn''t called
    before `searchDebounceTime` has passed. Add the following test to the `home.component.spec.ts`
    file:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now we''ll add a test for the case when `searchDebounceTime` has passed and
    the `searchUsers()` method should have been called. Add a new test to the `home.component.spec.ts`
    file as follows:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If you refresh the Karma test Chrome window, you''ll see all the tests passing
    as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.25 – All tests passing for the recipe'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.25_B15150.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.25 – All tests passing for the recipe
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the `npm start` command to spin up the app again. Then, monitor the
    network calls while you type an input into the search box. You''ll see that the
    `debounceTime` operator causes only 1 call once you stop typing for 300 milliseconds,
    as shown in the following screenshot:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.26 – Only one network call sent after a 300ms debounce'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.26_B15150.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.26 – Only one network call sent after a 300ms debounce
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! So, now you know how to use debounce with a Reactive form control and
    also how to write tests to check whether things work fine with the debounce. And
    that concludes the recipe. Let's refer to the next section to see how it works.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main task for the recipe was quite easy. We just used the `debounceTime`
    operator from the `rxjs` package and used it with our Reactive form control's
    `.valueChanges` Observable. Since we're using it within the `.pipe()` operator
    before the `.subscribe()` method, every time we change the value of the input,
    either by entering a value or by pressing the backspace key, it waits for `300ms`
    according to the `searchDebounceTime` property and then calls the `searchUsers()`
    method.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'We also wrote some tests in this recipe. Notice that we spy on the `searchUsers()`
    method since that is what it''s supposed to be called whenever we change the value
    of the `''username''` form control. We''re wrapping the test functions inside
    the `fakeAsync` method so we can control the asynchronous behavior of the use
    cases in our tests. We then set the value of the form control using the `FormControl.setValue()`
    method, which should trigger the method provided as an argument to the `.subscribe()`
    method after the time according to `searchDebounceTime` has passed. We then used
    the `tick()` method with the value of `searchDebounceTime` so it simulates an
    asynchronous passage of time. Then we write our `expect()` block to check whether
    the `searchUsers()` method should or shouldn''t have been called. Finally, at
    the end of the tests, we use the `discardPeriodicTasks()` method. We use this
    method so that we don''t face the `Error: 1 periodic timer(s) still in the queue.`
    error and our tests work.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'RxJS DebounceTime operator: [https://rxjs-dev.firebaseapp.com/api/operators/debounceTime](https://rxjs-dev.firebaseapp.com/api/operators/debounceTime)'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own custom form control using ControlValueAccessor
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular forms are great. While they support the default HTML tags like input,
    textarea etc., sometimes, you would want to define your own components that take
    a value from the user. It would be great if the variables of those inputs were
    a part of the Angular form you're using already.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you'll learn how to create your own custom Form Control using
    the ControlValueAccessor API, so you can use the Form Control with both Template
    Driven forms and Reactive Forms.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project for this recipe resides in `chapter08/start_here/custom-form-control`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab and you should see the following
    view:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.27 – Custom form control app running on http://localhost:4200'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.27_B15150.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.27 – Custom form control app running on http://localhost:4200
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let's see the steps involved in this
    recipe in the next section.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have a simple Angular app. It has two inputs and a **Submit** button. The
    inputs are for a review and they ask the user to provide a value for the rating
    of this imaginary item and any comments the user wants to provide. We''ll convert
    the Rating input into a custom Form Control using the ControlValueAccessor API.
    Let''s get started:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a component for our custom form control. Open the terminal in
    the project root and run the following command:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We''ll now create the stars UI for the rating component. Modify the `rating.component.html`
    file as follows:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Add the styles for the rating component to the `rating.component.scss` file
    as follows:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We also need to modify the `RatingComponent` class to introduce the necessary
    methods and properties. Let''s modify the `rating.component.ts` file as follows:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now we need to use this rating component instead of the input that we already
    have in the `home.component.html` file. Modify the file as follows:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If you refresh the app now and hover on the stars, you can see the color changing
    as you hover over the stars. The selected rating is also highlighted as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.28 – Rating component with hovered stars'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.28_B15150.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.28 – Rating component with hovered stars
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now implement the `ControlValueAccessor` interface for our rating component.
    It requires a couple of methods to be implemented and we''ll start with the `onChange()`
    and `onTouched()` methods. Modify the `rating.component.ts` file as follows:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We''ll now add the required methods to disable the input when required and
    to set the value of the form control, in other words, the `setDisabledState()`
    and `writeValue()` methods. We''ll also add the `disabled` and `value` properties
    to our `RatingComponent` class as follows:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We need to use the `disabled` property to prevent any UI changes when it is
    `true`. The value of the `value` variable shouldn''t be updated either. Modify
    the `rating.component.ts` file to do so as follows:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s make sure that we send the value of the `value` variable to `ControlValueAccessor`
    because that''s what we want to access later. Also, let''s set the `disabled`
    property back to `false`. Update the `selectRating` method in the `RatingComponent`
    class as follows:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We need to tell Angular that our `RatingComponent` class has a value accessor,
    otherwise using the `formControlName` attribute on the `<app-rating>` element
    will throw errors. Let''s add an `NG_VALUE_ACCESSOR` provider to the `RatingComponent`
    class''s decorator as follows:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If you refresh the app now, select a rating, and hit the **Submit** button,
    you should see the values being logged as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.29 – Form value logged using the custom form control'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.29_B15150.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.29 – Form value logged using the custom form control
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! You just learned how to create a custom form control using `ControlValueAccessor`.
    Refer to the next section to understand how it works.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We started the recipe by creating a component that we can use to provide a
    rating for the review we have to submit. We started off by adding the template
    and the styles for the rating component. Notice that we are using an `[ngClass]`
    directive on each of the star elements to add the `rating__star--active` class
    conditionally. Let''s discuss each condition now:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '`(isMouseOver && hoveredRating >= star)`: This condition relies on the `isMouseOver`
    and `hoveredRating` variables. The `isMouseOver` variable becomes `true` as soon
    as we mouse over any star and is turned back to `false` when we move away from
    the star. This means that it is only `true` when we''re hovering over a star.
    `hoveredRating` tells us which star we''re hovering over at the moment and is
    assigned the star''s value, in other words, a value from `1` to `5`. So, this
    condition is only true when we''re doing a mouseover, and the hovered star''s
    rating is greater than the value of the current star. So, if we''re hovering over
    the fourth star, all the stars from value `1` to `4` will be highlighted as they''ll
    have the `rating__star--active` class conditionally assigned to them.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(!isMouseOver && value >= star)`: This condition relies on the `isMouseOver`
    variable that we discussed previously and the `value` variable. The `value` variable
    holds the value of the selected rating, which is updated when we click on a star.
    So, this condition is applied when we''re not doing a mouseover and we have the
    value of the `value` variable greater than the current star. This is especially
    beneficial when you have a greater value assigned to the `value` variable and
    try to hover over a star with a lesser value, in which case, all the stars with
    values greater than the hovered star will not be highlighted.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then we used three events on each star: `mouseenter`, `mouseleave`, and `click`,
    and then used our `onRatingMouseEnter`, `onRatingMouseLeave`, and `selectRating`
    methods, respectively, for these events. All of this was designed to ensure that
    the entire UI is fluent and has a good user experience. We then implemented the
    `ControlValueAccessor` interface for our rating component. When we do that, we
    need to define the `onChange` and `onTouched` methods as empty methods, which
    we did as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then we used the `registerOnChange` and `registerOnTouched` methods from `ControlValueAccessor`
    to assign our methods as follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We registered these functions because whenever we do a change in our component
    and want to let `ControlValueAccessor` know that the value has changed, we need
    to call the `onChange` method ourselves. We do that in the `selectRating` method
    as follows, which makes sure that when we select a rating, we set the form control''s
    value to the value of the selected rating:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The other way around is when we need to know when the form control''s value
    is changed from outside the component. In this case, we need to assign the updated
    value to the `value` variable. We do that in the `writeValue` method from the
    `ControlValueAccessor` interface as follows:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: What if we don't want the user to provide a value for the rating? In other words,
    we want the rating form control to be disabled. For this, we did two things. First,
    we used the `disabled` property as an `@Input()`, so we can pass and control it
    from the parent component when needed. Secondly, we used the `setDisabledState`
    method from the `ControlValueAccessor` interface, so whenever the form control's
    `disabled` state is changed, apart from `@Input()`, we set the `disabled` property
    ourselves.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we wanted Angular to know that this `RatingComponent` class has a
    value accessor. This is so that we can use the Reactive forms API, specifically,
    the `formControlName` attribute with the `<app-rating>` selector, and use it as
    a form control. To do that, we provide our `RatingComponent` class as a provider
    to its `@Component` definition decorator using the `NG_VALUE_ACCESSOR` injection
    token as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Note that we''re using the `useExisting` property with the `forwardRef()` method
    providing our `RatingComponent` class in it. We need to provide `multi: true`
    because Angular itself registers some value accessors using the `NG_VALUE_ACCESSOR`
    injection token, and there may also be third-party form controls.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve set everything up, we use `formControlName` on our rating component
    in the `home.component.html` file as follows:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: See also
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Custom form control in Angular by Thoughtram: [https://blog.thoughtram.io/angular/2016/07/27/custom-form-controls-in-angular-2.html](https://blog.thoughtram.io/angular/2016/07/27/custom-form-controls-in-angular-2.html)'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ControlValueAccessor docs: [https://angular.io/api/forms/ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor)'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
