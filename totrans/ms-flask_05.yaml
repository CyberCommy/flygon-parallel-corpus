- en: Chapter 5. Advanced Application Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application has gone from a very simple example to an extendable foundation
    on which powerful features can easily be built. However, having our application
    entirely resided in one file needlessly clutters our code. To make the application
    code clearer and more comprehensible, we will transform the entire code into a
    Python module and split the code into multiple files.
  prefs: []
  type: TYPE_NORMAL
- en: The project as a module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, your folder structure should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert our code to a module, our files will be converted to this folder
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We will create this folder structure step by step. The first change to make
    is to create a folder in your application that will hold the module. In this example,
    it will be called `webapp`, but can be called anything except a blog, because
    the controllers are called blogs. If there are two blog objects to import from,
    Python will not import objects correctly from the parent directory while importing
    inside the `blog.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: Next move `main.py` and `config.py`—the static and template folders, respectively—into
    your project folder and create a controllers folder as well. We will also need
    to create the files `forms.py` and `models.py` in the `project` folder, and a
    `blog.py` file in the controllers folder. Also, the `main.py` file will need to
    be renamed `__init__.py`.
  prefs: []
  type: TYPE_NORMAL
- en: The filename `__init__.py` looks odd, but it has a specific function. In Python,
    a folder can be marked as a module by placing a file named `__init__.py` inside
    it. This allows programs to import objects and variables from the Python files
    in the folder.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about organizing Python code in a module, refer to the official
    documentation at [https://docs.python.org/2/tutorial/modules.html#packages](https://docs.python.org/2/tutorial/modules.html#packages).
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's begin moving our SQLAlchemy code to the `models.py` file. Cut all the
    model declarations, the table of tags, and the database object from `__init__.py`
    and copy them to the `models.py` file along with the SQLAlchemy import. Also,
    our `db` object will no longer be initialized with the `app` object as a parameter
    because the `app` object is not present in the `models.py` file, and importing
    it would result in a cyclical import. Instead, we will have the app object added
    on to the `db` object after our models are initialized. This will be achieved
    later in our `__init__.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `models.py` file should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, the `CommentForm` object, along with all the WTForms imports, should be
    moved to the `forms.py` file. The `forms.py` file will hold all the WTForms objects
    in their own file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `forms.py` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `blog_blueprint` data function, all its routes, and the `sidebar_data` data
    function need to be moved to the `blog.py` file in the controllers folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `blog.py` file should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, whenever a new blueprint is made, a new file in the controllers folder
    can be made for it, breaking down the application code into logical groups. Also,
    we need an empty `__init__.py` file in the controllers folder in order to mark
    it as a module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we focus on our `__init__.py` file. All that should remain in the
    `__init__.py` file is the `app` object creation, the `index` route, and the `blog_blueprint`
    registration on the `app` object. However, there is one thing to add—the database
    initialization. With the `db.init_app()` function, we will add the `app` object
    to the `db` object after it''s imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two final things to fix before our new structure works if you are
    using SQLite—the SQLAlchemy database URL in `config.py` needs to be updated and
    the imports in `manage.py` need to be updated. Because the SQLAlchemy URL for
    a SQLite database is a relative file path, it has to be changed to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix the `manage.py` imports, replace the imports from `main.py` with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now if you run `manage.py` file, your app will run with the new structure.
  prefs: []
  type: TYPE_NORMAL
- en: Application factories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are using blueprints in a modular manner, however, there is another
    improvement we can make to our abstraction, which creates a **factory** for our
    application. The concept of a factory comes from the **object-oriented programming**
    (**OOP**) world, and it simply means a function or an object that creates another
    object. Our application factory will take one of our `config` objects, which we
    created at the beginning of the book and returned a Flask application object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The object factory design was popularized by the now famous book, *Design Patterns:
    Elements of Reusable Object-Oriented Software*, by the Gang of Four. To learn
    more about these design patterns and how they can help simplify a project''s code,
    look at [https://en.wikipedia.org/wiki/Structural_pattern](https://en.wikipedia.org/wiki/Structural_pattern).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a factory function for our application object has several benefits.
    First, it allows the context of the environment to change the configuration of
    the application. When your server creates the application object to serve, it
    can take into account any changes in the server necessary and change the configuration
    object given to the app accordingly. Second, it makes testing much easier because
    it allows differently configured applications to be tested quickly. Third, multiple
    instances of the same application using the same configuration can be created
    very easily. This is useful for situations where web traffic is balanced across
    several different servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the benefits of application factories are clear, let''s modify our
    `__init__.py` file to implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The change to the file is very simple; we contained our code in a function
    that takes a `config` object and returns an application object. We will need to
    modify our `manage.py` file in order to work with the `create_app` function as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When we created our configuration objects it was mentioned that the environment
    that the application is running in could change the configuration of the application.
    This code has a very simple example of that functionality where an environment
    variable is loaded and determines which `config` object to give to the `create_app`
    function. Environment variables are **global variables** in Bash that can be accessed
    by many different programs. They can be set in Bash with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To read a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also delete the variable easily as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: On your production server, you would set `WEBAPP_ENV` to `prod`. The true power
    of this setup will become clearer once you deploy to production in [Chapter 13](ch13.html
    "Chapter 13. Deploying Flask Apps"), *Deploying Flask Apps*, and when we get to
    [Chapter 12](ch12.html "Chapter 12. Testing Flask Apps"), *Testing Flask Apps*,
    which covers testing our project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have transformed our application into a much more manageable and scalable
    structure, which will save us a lot of headaches as we move further through the
    book and add more advanced features. In the next chapter, we will add a login
    and registration system to our application, and other features to make our site
    more secure.
  prefs: []
  type: TYPE_NORMAL
