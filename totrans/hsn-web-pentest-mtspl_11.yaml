- en: Pentesting CMSes - WordPress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CMS stands for content management system—a system used to manage and modify
    digital content. It supports the collaboration of multiple users, authors, and
    subscribers. There are a lot of CMSes being used over the internet and some of
    the major ones are WordPress, Joomla, PHPNuke, and **AEM **(**Adobe Experience
    Manager**). In this chapter, we will look into a well-known CMS, WordPress. We'll
    see how to perform penetration testing on this CMS.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to WordPress architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WordPress reconnaissance and enumeration using Metasploit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulnerability scanning for WordPress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WordPress exploitation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the Metasploit exploit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the prerequisites for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The Metasploit Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WordPress CMS installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database server configured (MySQL is recommended)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic knowledge of Linux commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to WordPress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WordPress is an open source CMS that uses PHP as the frontend and MySQL in the
    backend. It is mostly used for blogging but it supports forums, media galleries,
    and online stores as well. WordPress was released on May 27, 2003 by its founders
    Matt Mullenweg and Mike Little. It also includes a plugin architecture and template
    system. The WordPress plugin architecture allows users to extend the features
    and functionality of their website or blog. As of February 2019, WordPress.org
    has 54,402 free plugins available and 1,500+ premium plugins. WordPress users
    also have the freedom to create and develop their own custom themes as long as
    they follow WordPress standards.
  prefs: []
  type: TYPE_NORMAL
- en: Before looking into WordPress enumeration and exploitation, let's first understand
    the architecture on which WordPress runs.
  prefs: []
  type: TYPE_NORMAL
- en: WordPress architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The WordPress architecture can be divided into four major parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1056d453-80ca-47bc-8a3d-d62875c86981.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look into the individual sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Display**: This contains the HTML, CSS, and JavaScript files visible to the
    users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Theme/Templates**: This includes forms, theme files, different WordPress
    pages, and sections such as comments, headers, footers, and the error page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WP-Engine**: This engine is responsible for the core functions of the entire
    CMS, for example, RSS feeds, communicating with the database, setup, file management,
    media management, and caching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WP-Backend**: This includes the database, PHP mailers cron jobs, and the
    filesystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's look into the directory structure.
  prefs: []
  type: TYPE_NORMAL
- en: File/directory structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Browsing the WordPress directory will give us a file/folder structure, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c018ede2-5f94-4353-a2e3-b48d6dcd1588.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's quickly do a brief run through these folders and files.
  prefs: []
  type: TYPE_NORMAL
- en: Base folder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's refer to this as the root directory. This directory contains three folders,
    which are `wp-admin`, `wp-content`, and `wp-includes`, and a bunch of PHP files,
    including the most important one, `wp-config.php`.
  prefs: []
  type: TYPE_NORMAL
- en: The base folder contains all of the other PHP files and classes required for
    the core operations of WordPress.
  prefs: []
  type: TYPE_NORMAL
- en: wp-includes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The wp-includes folder contains all the other PHP files and classes that are
    used by the front-end and required by Wordpress Core.
  prefs: []
  type: TYPE_NORMAL
- en: wp-admin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This folder contains the files of the WordPress Dashboard, which is used to
    perform all of the administrative tasks such as writing posts, moderating comments,
    and installing plugins and themes. Only registered users are allowed to access
    the Dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: wp-content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `wp-content` folder contains all user-uploaded data and is again divided
    into three sub-folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`themes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`plugins`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uploads`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `themes` directory contains all of the themes that are installed on our
    WordPress website. By default, WordPress comes with two themes: Twenty Twelve
    and Twenty Thirteen.'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `plugins` folder is used to store all of the plugins installed
    on our WordPress website. All of the images (and other media files) that we've
    uploaded since the time we launched our website will be stored in the `uploads` directory.
    These are categorized by day, month, and year.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a basic understanding of the architecture and the file/directory
    structure in WordPress, let's start pen-testing.
  prefs: []
  type: TYPE_NORMAL
- en: WordPress reconnaissance and enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you start exploiting any plugin/theme/core vulnerability of WordPress,
    the first step is to confirm whether the site is on WordPress or not. As for detecting
    WordPress itself, there are various ways to detect the installation of a WordPress
    CMS:'
  prefs: []
  type: TYPE_NORMAL
- en: Search for a `wp-content` string in the HTML page source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look for the `/wp-trackback.php` or `/wp-links-opml.php` filenames—they return
    XML in the case of a WordPress installation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also try `/wp-admin/admin-ajax.php` and `/wp-login.php`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look for static files such as `readme.html` and `/wp-includes/js/colorpicker.js`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have confirmed that the site is running on WordPress, the next step
    is to know what version of WordPress is running on the target server. To achieve
    this, you need to know the different ways you can detect its version number. Why
    the version number? Because based on the version of WordPress that is installed
    on the target server, you can test for plugin-based or WordPress-core exploits
    that may or may not be publicly available.
  prefs: []
  type: TYPE_NORMAL
- en: Version detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every WordPress installation comes with a version number. In the latest WordPress
    versions, the version numbers were hidden by default, but we can still enumerate
    the version. In this section, you will learn some of the ways of identifying which
    version of WordPress is running.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the most common recon techniques are `Readme.html`, meta generator,
    feed (RDF, Atom, and RSS), plugins and themes (JS and CSS ver), and hash match.
  prefs: []
  type: TYPE_NORMAL
- en: Readme.html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the easiest technique. All we have to do is visit the `readme.html`
    page and it discloses the version number in the center. The original purpose of
    this file was to give information to first-time users of the CMS on how to move
    ahead with the installation and usage of WordPress. It is supposed to be deleted
    once the installation and setup are complete. When using any tools, including
    Metasploit, always check the version number for the WordPress installation before
    performing any kind of exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, make sure you know what version you''re trying to pen-test. You can see
    an example of `readme.html` in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47c8a71e-5612-43b5-94ea-6eec443de1b7.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will look at the meta generator.
  prefs: []
  type: TYPE_NORMAL
- en: Meta generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The meta tag with the `generator` name attribute is generally described as
    the software that is used to generate the document/webpage. The exact version
    number is disclosed in the `content` attribute of the meta tag. WordPress-based
    websites often have this tag in their source, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6fe34bc-d909-4a69-9e73-e81b5c9a5f73.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will see how to obtain the version via JavaScript and CSS files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the version via JavaScript and CSS files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way of finding the version number is to view the source code of the
    following files. The following files request the JS and CSS files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`wp-admin/install.php`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wp-admin/upgrade.php`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wp-login.php`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These disclose the exact version number in their `ver` parameter, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aafbf7e7-e25a-4244-9ac6-0b2c6359a66b.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will see how to obtain the version via the feed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the version via the feed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, version information may also be disclosed in the feeds of the website.
    The following file paths can be used to disclose version information:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/index.php/feed/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/index.php/feed/rss/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/index.php/feed/rss2/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/index.php/comments/feed/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/index.php/feed/rdf/` (the file is locally downloaded)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/index.php/feed/atom/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/?feed=atom`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/?feed=rss`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/?feed=rss2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/?feed=rdf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the version disclosure through the feeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/043846de-e277-4b4c-a10c-bb59af500c6f.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will look at OPML.
  prefs: []
  type: TYPE_NORMAL
- en: Using Outline Processor Markup Language (OPML)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OPML is an XML format for outlines (defined as *a tree where each node contains
    a set of named attributes with string values*). The following file allows WordPress
    to import links from other websites as long as they''re in OPML format, but visiting
    this file also discloses the version information (in between HTML comment tags)
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acd12498-2ab0-49ba-882b-3874a991c629.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will look at advanced fingerprinting.
  prefs: []
  type: TYPE_NORMAL
- en: Unique/advanced fingerprinting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is another way of fingerprinting WordPress to find out the exact version.
    As the name suggests, the technique is quite unique. It is done by calculating
    the hashes of static files and comparing them with the hashes of the same static
    files in the different versions of WordPress releases. You can do this by executing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c54f698d-13f1-42d6-9ba0-ba96b97f16c5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To compare the hashes, see the following GitHub repository, at: [https://github.com/philipjohn/exploit-scanner-hashes](https://github.com/philipjohn/exploit-scanner-hashes).'
  prefs: []
  type: TYPE_NORMAL
- en: WordPress reconnaissance using Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metasploit has a scanner module for WordPress to get the version number, `wordpress_scanner`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set the options for this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f98f065a-fd34-48b1-8a72-8398c6beb6b4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once everything is set, let''s run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9f00ebc-e06b-4eb0-8a18-9d6e4347162e.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a very simple scanner that tries to find the version number using the
    techniques mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the version numbers, you can refer to the following case studies
    on how to enumerate and exploit WordPress vulnerabilities. The vulnerabilities
    given are explained in detail.
  prefs: []
  type: TYPE_NORMAL
- en: WordPress enumeration using Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the attack surfaces where you can focus your enumeration
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: Usernames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Themes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the Metasploit module, `auxiliary/scanner/http/wordpress_login_enum`,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try to brute-force the username or you can enumerate the username:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a410ad68-667c-48f9-9d5d-d6ab51b0b52e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s set the options just to enumerate the username and run the module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ad5d19e6-ebeb-478d-a1fd-7d49a6e50ce0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can now try brute-forcing using a dictionary. The default options for the
    module enable it to perform a brute-force attack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/880e5de1-ccee-4f47-84ad-d23ab23c885c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s set the options now. We have set the username that we found from the
    preceding enumeration method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3c9a8662-7c8e-48b5-b2a8-da48490f11cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For a password dictionary, use the `set PASS_FILE <file>` command and run the
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/535be82d-a179-4cda-a41d-324305d50f11.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will look at vulnerability assessment scanning.
  prefs: []
  type: TYPE_NORMAL
- en: Vulnerability assessment for WordPress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metasploit does not have a module that can perform vulnerability assessment
    scanning. However, you can write a Metasploit module that acts as a wrapper for
    a third-party tool such as WPscan, which can be used for vulnerability assessment
    scanning.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have written a custom Metasploit module that, on execution, will run WPscan,
    parse the output, and print it. Though the module is just a rough wrapper code,
    you can further modify it according to your needs. The following is the sample
    code for the custom Metasploit module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by adding the required libraries as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add the Metasploit `Auxiliary` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the informational part of the module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will add the `options` section for the module, using which we can
    add the target URL for the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the `target_url` method that will store the user option, `TARGET_URL`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We also define `find_wpscan_path` method, which will look for the `wpscan`
    file in the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add the auxiliary module execution method, `run`, and check whether
    `wpscan` is installed on the system or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If `wpscan` is found, the module will start by creating a temporary file with
    random characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the `wpscan` execution block. A `wpscan` process will be created
    here with the user options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When the execution is completed, the module will read the temporary file containing
    the `wpscan` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we add the code block that will parse the JSON output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are looking for the `interesting_findings` array in the JSON output.
    We''ll use this array to print the details for the vulnerabilities found in the
    WordPress target site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the code block for checking the WordPress version by looking for the
    `version` array in the JSON output and parsing it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We parse the total number of vulnerabilities found by `wpscan` and print it
    (including references and CVE links):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the code block for checking the installed themes using `wpscan`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We also add the code block for enumerating the installed plugins using `wpscan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add the code block to look for the vulnerabilities found in the installed
    plugins and map it according to the CVEs and reference URLs (including `exploit-db`
    URLs):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once everything is done, delete the temporary file created by this module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the complete code for the WPscan auxiliary module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Following are the steps to run the custom module we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the module to `<path_to_metasploit>/modules/auxiliary/scanner/wpscan.rb`
    and start Metasploit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/644d4153-ce63-42a6-a54b-f815a2cee11c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Set the options and run the module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9d4414cc-b40d-40a1-bd8e-dd7699618f12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The module also parses the plugin information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/277f5e1e-edef-46f5-8528-6ab302a8446f.png)'
  prefs: []
  type: TYPE_IMG
- en: This module doesn't save the information in the database so you could customize
    it to do that if you wish. The sole purpose of this module is to enumerate plugins,
    themes, and WordPress versions and to find vulnerabilities. In the next section,
    we are going to cover exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: WordPress exploitation part 1 – WordPress Arbitrary File Deletion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have learned about how to identify WordPress versions, let's look
    at some ways of exploiting WordPress in detail. We will also discuss how the exploit
    process works.
  prefs: []
  type: TYPE_NORMAL
- en: We will first look at the *WordPress Arbitrary File Deletion* vulnerability.
    This vulnerability allows any authenticated user to delete a file from the server.
    This can be used by an attacker to execute commands. Let's look at how this exploit
    works and how to achieve command execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the WordPress blog running on our localhost:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ab04930-fc56-4664-af10-4b4a39aaa041.png)'
  prefs: []
  type: TYPE_IMG
- en: The vulnerability is actually a second-order file deletion where we upload and
    edit an image, then we put the path of our file in the metadata. When the image
    is deleted, WordPress calls the unlink function to automatically remove the metadata
    that contains a path to our file, so it is deleted as well. Let's look at the
    basic vulnerability flow.
  prefs: []
  type: TYPE_NORMAL
- en: Vulnerability flow and analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll dig deeper into the root cause of this vulnerability. Look at the following
    screenshot of the `wp-admin/post.php` file. Here, unsanitized input is taken from
    the user and stored in `$newmeta`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aee3e993-ad6e-49ed-9c92-3e693964d7ca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `wp-includes/post.php` file, the same input is passed to `wp_update_attachment_metadata()`
    to be stored in the database as a serialized value, `meta_key`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b9b3840-f22c-458b-9d9e-dc515fe82c13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When a user clicks on the delete media button, the following code asks for
    the input from the database and stores it in `$thumbfile`. Then, an unlink function
    is called to remove the specified file. The thumb link metadata gets deleted because
    it contains a path to `wp-config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d176a82-42bd-4132-9a70-39c6a17a9f36.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will exploit the vulnerability using Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting the vulnerability using Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Metasploit has a built-in exploit module that deletes any arbitrary file on
    the server. We will use an example of the `wp-config` file, as we will later discuss
    how to use this exploit as a way to upload the shell on to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: To use the module, we run the following command in msfconsole.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use `auxiliary/scanner/http/wp_arbitrary_file_deletion`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d2bc9cb7-fbaa-453f-860a-5b6740bd759e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding screenshot, we enter the RHOST, the WordPress username
    and password, and the path of the config file. Before we run the exploit, let''s
    also look at the current entries in the `wp_postmeta` table of our WordPress database,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53d389a6-a53a-41d0-a30b-303861c28093.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `wp-config.php` file also exists on the server for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c71c4646-2b73-4088-8a97-5f8b7ae09e8a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the module is executed, Metasploit authenticates it with WordPress and
    uploads a `.gif` file onto the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8295e6bb-88a1-44fa-aca8-787f83e9bf1d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Looking at the entry of the `wp_postmeta` table, again we see that an attachment
    now exists and the metadata of the attachment is stored in a serialized format.
    The metadata has details such as filename, width, height, and EXIF headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8592b189-e21d-403a-ba7e-c39773d91c55.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, the exploit will attempt to edit the attachment and set the thumb parameter
    as the path of the file we want to delete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1d6b1bc-00d6-47ad-98c8-a7a373467017.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This gives a `302` response and we are redirected back to the post page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30388210-f549-4906-b09f-e5cbed547012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see how the database has been updated after this request. Viewing the
    `wp_postmeta` table again, we will see that two new strings have been added to
    the serialized `meta_value` column. These values are a thumb and the path of the
    config file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fdd2fb65-0ea0-41b4-b5d7-0643178b8b6b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step for the exploit is to delete the uploaded attachment, which will
    force the `unlink()` function to be called, resulting in the deletion of the config
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9779c3d2-be73-4dc8-bf77-11eca91cd8f9.png)'
  prefs: []
  type: TYPE_IMG
- en: The next question that comes to mind is: **How does deleting a config file get
    us Remote Code Execution**(**RCE**) **on the server?**
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `wp-config.php` file gets deleted, WordPress will redirect the site
    to `setup-config.php`, that is, the default installation startup page, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/622632d9-a1e2-4f15-aceb-dbad9613365a.png)'
  prefs: []
  type: TYPE_IMG
- en: The idea is to create a database on our own server and to set up WordPress again
    with our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the SQL commands for creating a MySQL database
    on our own server. This server needs to be reachable by WordPress, so we have
    to ensure that MySQL is running and that it allows remote logins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/695bfe68-4adb-457d-a9fc-dcf6478e2819.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we click continue and provide the database connection details, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f940bd9a-ec22-46c0-af9a-05884504e7d3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once done, the next step is to create the WordPress user to log in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0cfd386-a692-4fdf-9780-25577512341b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now log in with the WordPress user we just created. The WordPress instance
    on the server is now connected and configured with our own database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eef9d31c-ac40-4ba6-915c-6a58eee3bafc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we have admin access to the WordPress CMS, we can use the Metasploit module
    to upload a shell on the site. This can be done using the following exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0538732-e8c9-4f71-98d3-fae3a60d06dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s set the options for this exploit to use, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/697f3f79-49d5-40b8-aabe-db873eac18b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s execute the module and wait for the magic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87e0f3c8-c573-40f6-aa19-eef1ebf98f1c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We now have meterpreter access on the server. Hence, RCE is achieved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/211ab09b-0a74-4abb-9452-e7c2d101253e.png)'
  prefs: []
  type: TYPE_IMG
- en: This was a pretty straightforward exploit. The hashes can then be further cracked
    to gain access to the admin panel, or once we get the plaintext password, we can
    use the WordPress shell upload module to get a meterpreter on the box. In the
    next section, we will look at an unauthenticated SQL injection in the Google Maps
    plugin.
  prefs: []
  type: TYPE_NORMAL
- en: WordPress exploitation part 2 – unauthenticated SQL injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at another case of SQL injection, which was discovered in the WordPress
    Google Maps plugin. Metasploit already has a built-in exploit module that extracts
    the `wp_users` table from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Before we run the module, let's look at the source code of the plugin and understand
    where the problem was.
  prefs: []
  type: TYPE_NORMAL
- en: Vulnerability flow and analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Looking at the source code of `class.rest-api.php`, we can see that the user
    input is passed as a `get` parameter named `fields` into the `explode` function.
    The `explode` function is used to *split a string by a specified string into pieces*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7896c1b7-2d14-47cf-b6e6-710917affa92.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, the input is stored in the `$imploded` variable, combined back using
    `implode()`, and passed directly into the `SELECT` query, as shown in the screenshot
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d450d07-01af-473d-af5f-69ae07fe2f80.png)'
  prefs: []
  type: TYPE_IMG
- en: The `$imploded` variable is the injection point here. This vulnerability can
    be exploited by using the Metasploit module as well.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting the vulnerability using Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running the exploit against a target will give us the data stored in the `wp_users`
    table, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f63e3b9-aa74-4a75-8f06-91ea0173e857.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will look at the third and final part of WordPress exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: WordPress exploitation part 3 – WordPress 5.0.0 Remote Code Execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at the RCE vulnerability, which existed in WordPress
    version 5.0.0 and below. This exploit chains two different vulnerabilities to
    achieve code execution (path traversal and local file inclusion). Metasploit already
    has a module for this exploit.
  prefs: []
  type: TYPE_NORMAL
- en: Vulnerability flow and analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first vulnerability is CVE-2019-8942, which overwrites the `post` meta
    entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79575cd5-bfee-4f91-88ba-54b9b2e272ff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The unsanitized user input is then passed onto `wp_update_post()`, which doesn''t
    check for non-allowed `post` meta fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05675fe4-d972-464d-bfc8-899e7e590d49.png)'
  prefs: []
  type: TYPE_IMG
- en: The attacker can overwrite the `_wp_attached_file` post meta-key to their malicious
    file. At this point, we have exploited CVE-2019-8942\. Now that we have control
    over what we can overwrite in the post meta entries, let's leverage the next vulnerability,
    CVE-2019-8943, a path traversal vulnerability. Using this vulnerability, we can
    change the path of our uploaded malicious file from the previously exploited vulnerability
    (CVE-2019-8942) to the path of our choice for RCE.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `wp_crop_image()` function calls the `get_attached_file()` function without
    any file path validation. So, the malicious image file uploaded on the server
    will be passed to the `get_attached_file()` function at the time the `wp_crop_image()`
    function is called (at the time of image crop):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/420d959f-dc5a-44f6-a353-c12ee2807714.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can exploit this vulnerability to change the path of our uploaded malicious
    file and save the cropped version of the image in the default themes directory,
    that is, `wp-content/themes/<default_theme>/<cropped-image>.jpg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c977730a-ad7d-4fbd-b74f-391c42dfdf80.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding screenshot, the malicious image is saved into
    the default theme folder. Now that our malicious image is in place, we can request
    for the post so that our PHP payload gets executed, resulting in RCE.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting the vulnerability using Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The module can be selected in the Metasploit console by using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9b86a32-cf35-4d2c-991a-09e693695a93.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We set the required options as shown in the following screenshot. We will need
    a low privilege account on the WordPress blog, as this vulnerability requires
    authentication as well as the privilege of uploading and editing media:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8e38b91-b9c5-498c-b172-8108bf3dfc80.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The exploitation happens in several steps. The first step that the Metasploit
    module does is check whether the `targeturi` provided is correct or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31153afb-0ed7-4a44-9ae1-90e84cef11a5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On getting a 200 HTTP response code, it confirms the `targeturi` path:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b78206a-09db-4e1c-a9ea-e4207e9b9fc8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The module continues to the next step—authentication. The username and password
    used for the module will get used in this step. While authenticating with the
    WordPress site, the module also requests for redirection to a non-existent page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ddfa5732-c0c0-4d37-934a-11ae67e1fccd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The HTTP response will be a redirection (302) to a page that doesn''t exist.
    This is done just to get the session cookies from the server. Everything after
    this step is accomplished using these cookies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af2d092a-076a-4d86-b548-40da3ec12963.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s confirm the database status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd522b3e-4e20-4737-a891-f1552e0b3160.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that the session is retrieved from the server, in the next step, the module
    requests the `media-new.php` page. This page is responsible for media uploads
    to the WordPress site:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b2c026a-c212-4aa9-80bb-45c770f1c9ac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The objective here is to upload an image with our payload embedded in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3640ee55-5e04-4fc6-b3c8-890c7eecb754.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The module then uploads the image embedded with our payload in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bca11c05-baf5-487c-a6a2-36d58b4bd234.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding screenshot, the payload embedded in the image
    is `<?=`$_GET[0]`;?>`. The reason we used such a compressed payload is that we
    don't have much space left for our payload to get executed. Also, notice that
    the payload is embedded in two different places—just after the scan header and
    in the EXIF metadata. The reason it's embedded twice is to make sure the payload
    gets executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'WordPress supports two image editing extensions for PHP: **GD** **Library**
    and **Imagick**. GD Library compresses the image and strips all EXIF metadata.
    Imagick won''t strip off any EXIF metadata. That is the reason the module embeds
    the payload twice.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The path and the post metadata at the time of upload are stored in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45360bc1-ee8b-40b9-a631-ce2f8835da76.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the malicious image is uploaded, an ID is allotted to the image with its
    full path in the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ef665c6-bf8f-4c54-929c-c3cc18bdea92.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The module checks whether the WordPress site is vulnerable to CVE-2019-8942
    and CVE-2019-8943 or not. It does this in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It confirms whether the image is uploaded or not by querying all of the attachments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It makes sure that the malicious image is saved with a size of 400 x 300\. (This
    will help when the fake crop is done.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It gets the updated `wp_nonce` and updated filename when editing the malicious
    image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It checks whether the POST metadata entry for the image can be overwritten from
    `.jpg` to `.jpg?/x` or not. If it's changed, it shows that the WordPress site
    is vulnerable to CVE-2019-8942.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It crops the image (a fake crop here) to check whether the WordPress site is
    vulnerable to CVE-2019-8943, a path traversal vulnerability.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the module confirms the vulnerability, it exploits CVE-2019-8942 by overwriting
    the POST metadata from `.jpg` to `.jpg?/../../../../themes/#{@current_theme}/#`{`@shell_name`}:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cd0c3186-7084-48ba-81fb-483fc174f2e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the updated value of the `meta_value` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57c237e9-7099-4975-9039-1d5cf665dacb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also see in the following screenshot that the default template has been
    changed to `cropped-zAdFmXvBCk.jpg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39360439-d3c9-4306-a03c-afa9d9bf9514.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The module then requests the default template with the post ID and appends
    the `0` parameter with the command to execute for RCE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/191b9e8b-b961-4cd0-9264-bc37f3921191.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The output for the command is in the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd4e6f35-a083-4f0d-8016-78723ce829a0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, the module does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It confirms whether the Base64 program exists in the system or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It converts the PHP meterpreter into Base64 and uploads it to the server using `echo
    <base64_of _PHP_meterpreter> | base64 -d > shell.php`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It requests the uploaded PHP shell to get meterpreter access.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the Base64 encoded meterpreter code being written
    into the PHP file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6e6c0812-0bc1-470a-bc29-36b8cf4bf95d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows a successful meterpreter connection from the
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/123bf68c-e1e1-4d7c-be49-0e7ad0a273d5.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will customize the Metasploit exploit.
  prefs: []
  type: TYPE_NORMAL
- en: Going the extra mile – customizing the Metasploit exploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the Metasploit module we used in the previous section, `exploit/multi/http/wp_crop_rce`,
    we need to have the username and password set for the module to work. But what
    if there''s a reCAPTCHA in place at the time of authentication? The module will
    surely fail because there''s no workaround for the module to get the session cookie:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the module so that it works with the `COOKIE` datastore as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ca7611b4-1b44-4b37-bf25-d9e214b9c3f8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see the updated module options in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d1b52a6-91b5-4726-a056-ebd8c6ff167a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s define a function for the `COOKIE` datastore:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/88b328c9-81f5-457f-bd52-48f1e13990c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We also need to validate the cookie based on the response code. So, let''s
    define a `validate_cookie()` function; this will validate the cookie with a 200
    HTTP response code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e980a39e-1194-4140-8b9f-85ed97c37b86.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, in the `exploit()` function, let''s include a `fail-safe fail_with()`
    method to ensure that if either the username or password is missing, the exploit
    will fail. This will also will be done if the cookie isn''t set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d97fd41b-955d-4a59-a6e6-9321257efaf2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the username and password are missing, the module will try to use `COOKIE`.
    Let''s update the module and set the `COOKIE` option for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0dd59fcf-afc4-4779-8b16-931841056b1b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s run the module and see the magic happen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/17ee4fc4-c9e4-4fdb-8ecb-ea27cd51970b.png)'
  prefs: []
  type: TYPE_IMG
- en: We've got meterpreter using `COOKIE`!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by discussing the architecture of WordPress, followed
    by the directory structure. Next, we learned how to perform manual and automated
    recon of WordPress. Later, we looked at examples of a few exploits and did a step-by-step
    walkthrough of the entire exploitation process manually as well as using Metasploit
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be learning about performing a penetration test on
    a Joomla-based **Content Management System** (**CMS**).
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Are the reconnaissance steps the same for all versions of WordPress?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I have located a `wp-admin` directory but the directory itself is inaccessible.
    What can I do in this situation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is WordPress free to download?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following links can be used to learn more about the exploitation methods
    for WordPress and the latest vulnerabilities being released:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://wpvulndb.com/](https://wpvulndb.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://wpsites.net/wordpress-tips/3-most-common-ways-wordpress-sites-are-exploited/](https://wpsites.net/wordpress-tips/3-most-common-ways-wordpress-sites-are-exploited/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.exploit-db.com/docs/english/45556-wordpress-penetration-testing-using-wpscan-and-metasploit.pdf?rss](https://www.exploit-db.com/docs/english/45556-wordpress-penetration-testing-using-wpscan-and-metasploit.pdf?rss)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
