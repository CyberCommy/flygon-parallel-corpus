- en: Geometric Problems
  prefs: []
  type: TYPE_NORMAL
- en: This chapter describes solutions to several problems concerning two-dimensional
    geometry. Geometry is a branch of mathematics concerned with the characteristics
    of points, lines, and other figures (shapes), the interaction between such figures,
    and the transformation of such figures. In this chapter, we'll focus on the characteristics
    of two-dimensional figures and the interactions between these objects.
  prefs: []
  type: TYPE_NORMAL
- en: There are several problems we must overcome when working with geometric objects
    in Python. The biggest hurdle is the problem of representation. Most geometric
    objects occupy a region in the two-dimensional plane, and as such, it is impossible
    to store every point that lies within the region. Instead, we have to find a more
    compact way to represent the region that can be stored as a relatively small number
    of points. For example, we might store a selection of points along the boundary
    of an object that we can reconstruct the boundary and the object itself from.
    Moreover, we reformulate geometric problems into questions that can be answered
    using the representative data.
  prefs: []
  type: TYPE_NORMAL
- en: The second biggest problem is converting purely geometric questions into a form
    that can be understood and solved using software. This can be relatively simple
    – for example, finding the point at which two straight lines intersect is a matter
    of solving a matrix equation – or it can be extremely complex, depending on the
    type of question being asked. A common technique that's used to solve these problems
    is to represent the figure in question using more simple objects and solve the
    (hopefully) easier problem using each of the simple objects. This should then
    give us an idea of the solution to the original problem.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by showing you how to visualize two-dimensional shapes, and then
    learn how to determine whether a point is contained within another figure. Then,
    we'll move on and look at edge detection, triangulation, and finding convex hulls.
    We'll conclude this chapter by constructing Bezier curves.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing two-dimensional geometric shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding interior points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding edges in an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triangulating planar figures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing convex hulls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing Bezier curves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, we will need the `numpy` package and the `matplotlib` package,
    as usual. We will also need the Shapely package and the `scikit-image` package,
    which can be installed using your favorite package manager, such as `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code for this chapter can be found in the `Chapter 08` folder of the GitHub
    repository at [https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2008](https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2008).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3hpeKEF](https://bit.ly/3hpeKEF).'
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing two-dimensional geometric shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The focus of this chapter is on two-dimensional geometry, so our first task
    is to learn how to visualize two-dimensional geometric figures. Some of the techniques
    and tools mentioned here might be applicable to three-dimensional geometric figures,
    but generally, this will require more specialized packages and tools.
  prefs: []
  type: TYPE_NORMAL
- en: A *geometric figure*, at least in the context of this book, is any point, line,
    curve, or closed region (including the boundary) whose boundary is a collection
    of lines and curves. Simple examples include points and lines (obviously), rectangles,
    polygons, and circles.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to visualize geometric figures using Matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we need the NumPy package imported as `np`, and the Matplotlib
    `pyplot` module imported as `plt`. We also need to import the `Circle` class from
    the Matplotlib `patches` module and the `PatchCollection` class from the Matplotlib
    `collections` module. This can be done with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We will also need the `swisscheese-grid-10411.csv` data file from the code repository
    for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps show you to visualize a two-dimensional geometric figure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we load the data from the `swisscheese-grid-10411.csv` file from this
    book''s code repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a new patch object that represents a region on a plot. This is going
    to be a circle (disk) with the center at the origin and a radius of `1`. We create
    a new set of axes and add this patch to them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a `PatchCollection` object from the data we loaded in *step
    1*, which contains centers and radii for a number of other circles. We then add
    this `PatchCollection` to the axes we created in *step 2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we set the *x-* and *y*-axis ranges so that the whole image is displayed
    and then turns the axes off:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting image is of a *Swiss Cheese*, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6aa2a020-6280-49a0-8606-c12f34d067ce.png)Figure 8.1: Plot of a Swiss
    cheese'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The keys to this recipe are the `Circle` and `PatchCollection` objects, which
    represent the regions of the plot area on Matplotlib `Axes`. In this case, we
    are creating one large circular patch, centered at the origin and with a radius
    of `1`, that has a black face color and uses `zorder=0` to place it behind other
    patches. This patch is added to the `Axes` object using the `add_patch` method.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to create an object that will render the circles represented
    by the data that we loaded from the CSV file in *step 1*. This data consisted
    of *x*, *y*, and *r* values for the center (*x*, *y*) and the radius, *r*, of
    the individual circles (10,411 in total). The `PatchCollection` object combines
    a sequence of patches into a single object that can be added to an `Axes` object.
    Here, we add one `Circle` for each row in our data, which is then added to the
    `Axes` object using the `add_collection` method. Notice that we have applied the
    face color to the whole collection, rather than to each individual `Circle` constituent.
    We set the face color to white (using the `facecolor="w"` argument), the edge
    color to black (using `ec="k"`), the line width (of the edge lines) to 0.2 (using
    `linewidth=0.2`), and the edge style to a continuous line. All of this, when put
    together, results in our image.
  prefs: []
  type: TYPE_NORMAL
- en: The image that we have created here is called a "Swiss Cheese". These were first
    used in rational approximation theory in 1938 by Alice Roth; they were subsequently
    rediscovered, and similar constructions have been used many times since. We used
    this example because it consists of one large individual part, plus a large collection
    of smaller individual parts. Roth's Swiss Cheese is an example of a set in the
    plane that has a positive area but no topological interior. (It is fairly amazing
    that such a set can even exist!) More importantly, there are continuous functions
    defined on this Swiss Cheese that cannot be approximated by rational functions.
    This property has made similar constructions useful in the theory of *uniform*
    *algebra*.
  prefs: []
  type: TYPE_NORMAL
- en: The `Circle` class is a subclass of the more general `Patch` class. There are
    numerous other `Patch` classes that represent different planar figures, such as
    `Polygon` and `PathPatch`, which represent the region bounded by a path (curve
    or collection of curves). These can be used to generate complex patches that can
    be rendered in a Matplotlib figure. Collections can be used to apply settings
    to a number of patch objects simultaneously, which can be especially useful if,
    as in this recipe, you have a large number of objects that will all be rendered
    in the same style.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many different patch types available in Matplotlib. In this recipe,
    we used the `Circle` patch class, which represents a circular region on the axes.
    There is also the `Polygon` patch class, which represents a polygon (regular or
    otherwise). There are also `PatchPath` objects, which are regions that are surrounded
    by a curve that does not necessarily consist of straight-line segments. This is
    similar to the way a shaded region can be constructed in many vector graphics
    software packages.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the single patch types in Matplotlib, there are a number of collection
    types that gather a number of patches together to be used as a single object.
    In this recipe, we used the `PatchCollection` class to gather a large number of
    `Circle` patches. There are more specialized patch collections that can be used
    to generate these internal patches automatically, rather than us generating them
    ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A more detailed history of Swiss Cheeses in mathematics can be found in the
    following biographical article: *Daepp,U., Gauthier, P., Gorkin, P. and Schmieder,
    G., 2005\. Alice in Switzerland: The life and mathematics of Alice Roth. The Mathematical
    Intelligencer, 27(1), pp.41-54*.'
  prefs: []
  type: TYPE_NORMAL
- en: Finding interior points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One problem with working with two-dimensional figures in a programming environment
    is that you can't possibly store all the points that lie within the figure. Instead,
    we usually store far fewer points that represent the figure in some way. In most
    cases, this will be a number of points (connected by lines) that describe the
    boundary of the figure. This is efficient in terms of memory and makes it easy
    to visualize them on screen using Matplotlib `Patches`, for example. However,
    this approach makes it more difficult to determine whether a point, or another
    figure, lies within a given figure. This is a crucial question in many geometric
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to represent geometric figures and determine
    whether a point lies within a figure or not.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will need to import the `matplotlib` package (as a whole)
    as `mpl` and the `pyplot` module as `plt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to import the `Point` and `Polygon` objects from the `geometry`
    module of the Shapely package. The Shapely package contains many routines and
    objects for representing, manipulating, and analyzing two-dimensional geometric
    figures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps show you how to create a Shapely representation of a polygon
    and then test whether a point lies within this polygon:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a sample polygon to test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we plot the polygon on a new figure. First, we need to convert the polygon
    into a Matplotlib `Polygon` patch that can be added to the figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to create two test points, one of which will be inside the polygon
    and one of which will be outside the polygon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We plot and annotate these two points on top of the polygon to show their positions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we test where each point lies within the polygon using the `contains`
    method, and then print the result to the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The results show that the first point, `p1`, is contained in the polygon, while
    the second point, `p2`, is not. This can also be seen in the following figure,
    which clearly shows that one point is contained within the shaded polygon, while
    the other point is not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/986dab1f-d3fe-4f7f-bd62-c1f3be844745.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Points inside and outside a polygonal region'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Shapely `Polygon` class is a representation of a polygon that stores its
    vertices as points. The region enclosed by the outer boundary – the five straight
    lines between the stored vertices – is obvious to us and easily identified by
    the eye, but the notion of being "inside" the boundary is difficult to define
    in a way that can be easily understood by a computer. It is not even straightforward
    to give a formal mathematical definition of what it means to lie "within" a given
    curve.
  prefs: []
  type: TYPE_NORMAL
- en: There are two main ways to determine whether a point lies within a simple closed
    curve – that is, a curve that starts and ends at the same place that does not
    contain any self-intersections. The first uses a mathematical concept called the
    *winding number*, which counts the number of times the curve "wraps around" a
    point, and the *ray crossing counting* method, where we count the number of times
    a ray from the point to a point at infinity crosses the curve. Fortunately, we
    don't need to compute these numbers ourselves since we can use the tools from
    the Shapely package to do this computation for us. This is what the `contains`
    method of a polygon does. (Under the hood, Shapely uses the GEOS library to perform
    this calculation.)
  prefs: []
  type: TYPE_NORMAL
- en: The Shapely `Polygon` class can be used to compute many quantities associated
    with these planar figures, including perimeter length and area. The `contains`
    method is used to determine whether a point, or a collection of points, lies within
    the polygon represented by the object. (There are some limitations regarding the
    kinds of polygons that can be represented by this class.) In fact, you can use
    the same method to determine whether one polygon is contained within another since,
    as we have seen in this recipe, a polygon is represented by a simple collection
    of points.
  prefs: []
  type: TYPE_NORMAL
- en: Finding edges in an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finding edges in images is a good way of reducing a complex image that contains
    a lot of noise and distractions to a very simple image containing the most prominent
    outlines. This can be useful as our first step of the analysis process, such as
    in image classification, or as the process of importing line outlines into computer
    graphics software packages.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the `scikit-image` package and the
    Canny algorithm to find the edges in a complex image.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will need to import the Matplotlib `pyplot` module as `plt`,
    the `imread` routine from the `skimage.io` module, and the `canny` routine from
    the `skimage.feature` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to use the `scikit-image` package to find edges
    in an image:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the image data from the source file. This can be found in the GitHub repository
    for this chapter. Crucially, we pass in `as_gray=True` to load the image in grayscale:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the original image, for reference. The set itself is shown
    by the white region and, as you can see, the boundary, indicated by the darker
    shades, is very complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6d107141-bb61-4843-8ca0-d1a230b5eac4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Plot of the Mandelbrot set generated using Python'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use the `canny` routine, which needs to be imported from the `features`
    module of the `scikit-image` package. The `sigma` value is set to 0.5 for this
    image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add the `edges` image to a new figure with a grayscale (reversed)
    colormap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The edges that have been detected can be seen in the following image. The edge-finding
    algorithm has identified most of the visible details of the boundary of the Mandelbrot
    set, although it is not perfect (this is an estimate, after all):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/347a3855-99bf-42f3-bcd7-19d0ec8fc398.png)Figure 8.4: The edges of
    the Mandelbrot set found using the scikit-image package''s Canny edge detection
    algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `scikit-image` package provides various utilities and types for manipulating
    and analyzing data derived from images. As the name suggests, the `canny` routine
    uses the Canny edge detection algorithm to find edges in an image. This algorithm
    uses the intensity gradients in the image to detect edges, where the gradient
    is larger. It also performs some filtering to reduce the noise in the edges it
    finds.
  prefs: []
  type: TYPE_NORMAL
- en: The `sigma` keyword value we provided is the standard deviation of the Gaussian
    smoothing that's applied to the image prior to calculating the gradients for edge
    detection. This helps us remove some of the noise from the image. The value we
    set (0.5) is smaller than the default (1), but it does give us better resolution
    in this case. A large value would obscure some of the finer details in the boundary
    of the Mandelbrot set.
  prefs: []
  type: TYPE_NORMAL
- en: Triangulating planar figures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in [Chapter 3](1a62e7c6-06f5-4ee3-8f63-5bb14f6db553.xhtml), *Calculus
    and Differential Equations*, we often need to break down a continuous region into
    smaller, simpler regions. In earlier recipes, we reduced an interval of real numbers
    into a collection of smaller intervals, each with a small length. This process
    is usually called **discretization**. In this chapter, we are working with two-dimensional
    figures, so we need a two-dimensional version of this process. For this, we'll
    break a two-dimensional figure (in this recipe, a polygon) into a collection of
    smaller and simpler polygons. The simplest of all polygons are triangles, so this
    is a good place to start for two-dimensional discretization. The process of finding
    a collection of triangles that "tiles" a geometric figure is called *triangulation*.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to triangulate a polygon (with a hole) using
    the Shapely package.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will need the NumPy package imported as `np`, the Matplotlib
    package imported as `mpl`, and the `pyplot` module imported as `plt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need the following items from the Shapely package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps show you how to triangulate a polygon with a hole using
    the Shapely package:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a `Polygon` object that represents the figure that
    we wish to triangulate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we should plot the figure so that we can understand the region that we
    will be working within:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This polygon can be seen in the following image. As we can see, the figure
    has a "hole" in it that must be carefully considered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/38ff179a-35af-43ac-bae1-da8027ddc87c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Sample polygon but with a hole'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `triangulate` routine to generate a triangulation of the polygon.
    This triangulation includes external edges, which is something we don''t want
    in this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove the triangles that lie outside the original polygon, we need to use
    the built-in `filter` routine, along with the `contains` method (seen earlier
    in this chapter):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To plot the triangles on top of the original polygon, we need to convert the
    Shapely triangles into Matplotlib `Patch` objects, which we store in a `PatchCollection`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add the collection of triangular patches to the figure we created
    earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The triangulation that''s been plotted on top of the original polygon can be
    seen in the following figure. Here, we can see that every vertex has been connected
    to two others to form a system of triangles that cover the entire original polygon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b0ca0510-f765-40e0-b147-23a9e82355b2.png)Figure 8.6: Triangulation
    of a sample polygon with a hole'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `triangulate` routine uses a technique called *Delaunay triangulation* to
    connect a collection of points to a system of triangles. In this case, the collection
    of points are the vertices of the polygon. The Delaunay method finds these triangles
    in such a way that none of the points are contained within the circumcircle of
    any of the triangles. This is a technical condition of the method, but it means
    that the triangles are chosen efficiently, in the sense that it avoids very long,
    thin triangles. The resulting triangulation makes use of the edges that are present
    in the original polygon and also connects some of the external edges.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the triangles that lie outside of the original polygon, we
    use the built-in `filter` routine, which creates a new iterable by removing the
    items that the criterion function fails under. This is used in conjunction with
    the `contains` method on Shapely `Polygon` objects to determine whether each triangle
    lies within the original figure. As we mentioned previously, we need to convert
    these Shapely items into Matplotlib patches before they can be added to the plot.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Triangulations are usually used to reduce a complex geometric figure into a
    collection of triangles, which are much simpler, for some kind of computational
    task. However, they do have other uses. One particularly interesting application
    of triangulations is to solve the "art gallery problem". This problem concerns
    finding the maximum number of guards that are necessary to "guard" an art gallery
    of a particular shape. Triangulations are an essential part of Fisk's simple proof
    of the art gallery theorem, which was originally proved by Chvátal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that the polygon from this recipe is the floor plan for an art gallery
    and that some guards need to be placed on the vertices. A small amount of work
    will show that you''ll need three guards to be placed at the polygon''s vertices
    for the whole museum to be covered. In the following image, we have plotted one
    possible arrangement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/267a0779-deb3-449c-b481-3cde9a5ce205.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: One possible solution to the art gallery problem where guards are
    placed on vertices.'
  prefs: []
  type: TYPE_NORMAL
- en: The guards are indicated by the dots, and their corresponding field of vision
    is shaded.
  prefs: []
  type: TYPE_NORMAL
- en: One guard is placed at each of the vertices with a circle, and their field is
    vision is denoted by the corresponding shaded area. Here, you can see that the
    whole polygon is covered by at least one color. The solution to the art gallery
    problem – which is actually a variation of the original problem – tells us that
    we need, at most, four guards.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'More information about the art gallery problem can be found in the classic
    book by O''Rourke: *ORourke, J. (1987). Art gallery theorems and algorithms. New
    York: Oxford University Press.*'
  prefs: []
  type: TYPE_NORMAL
- en: Computing convex hulls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A geometric figure is said to be *convex* if every pair of points within the
    figure can be joined using a straight line that is also contained within the figure.
    Simple examples of convex bodies include points, straight lines, squares, circles
    (disks), regular polygons, and so on. The geometric figure shown in *Figure 8.5*
    is not convex since the points on the opposite sides of the hole cannot be connected
    by a straight line that remains inside the figure.
  prefs: []
  type: TYPE_NORMAL
- en: Convex figures are simple from a certain perspective, which means they are useful
    in a variety of applications. One particular problem involves finding the smallest
    convex set that contains a collection of points. This smallest convex set is called
    the *convex hull* of the set of points.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll learn how to find the convex hull of a set of points using
    the Shapely package.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will need the NumPy package imported as `np`, the Matplotlib
    package imported as `mpl`, and the `pyplot` module imported as `plt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need a default random number generator from NumPy. We can import
    this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will need to import the `MultiPoint` class from Shapely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to find the convex hull of a collection of randomly generated
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we generate a two-dimensional array of random numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a new figure and plot these raw sample points on this figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'These randomly generated points can be seen in the following figure. The points
    are roughly spread over a square region:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a5d0f401-8381-489e-915c-cb61b0cf5d5f.png)Figure 8.8: A collection
    of points in the plane'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we construct a `MultiPoint` object that collects all these points and
    put them into a single object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we get the convex hull of this `MultiPoint` object using the `convex_hull`
    attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a Matplotlib `Polygon` patch that can be plotted on our figure
    to show the result of finding the convex hull:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add the `Polygon` patch to the figure to show the convex hull:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The convex hull of the randomly generated points can be seen in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1e11e76a-2124-4912-8fbb-b0b5b4ce95a8.png)Figure 8.9: The convex
    hull of a collection of points in the plane'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Shapely package is a Python wrapper around the GEOS library for geometric
    analysis. The `convex_hull` attribute of Shapely geometric objects calls the convex
    hull computation routine from the GEOS library, resulting in a new Shapely object.
    From this recipe, we can see that the convex hull of the collection of points
    is a polygon with vertices at the points that are farthest away from the "center".
  prefs: []
  type: TYPE_NORMAL
- en: Constructing Bezier curves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Bezier curves*, or *B-splines*, are a family of curves that are extremely
    useful in vector graphics – for instance, they are commonly used in high-quality
    font packages. This is because they are defined by a small number of points that
    can then be used to inexpensively calculate a large number of points along the
    curve. This allows detail to be scaled according to the needs of the user.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll learn how to create a simple class representing a Bezier
    curve and compute a number of points along it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will use the NumPy package imported as `np`, the Matplotlib
    `pyplot` module imported as `plt`, and the `comb` routine from the Python Standard
    Library `math` module, imported under the alias `binom`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to define a class that represents a Bezier curve that can
    be used to compute points along the curve:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to set up the basic class. We need to provide the control
    points (nodes) and some associated numbers to instance attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Still inside the `__init__` method, we generate the coefficients for the Bezier
    curve and store them in a list on an instance attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a `__call__` method to make the class callable. We load the
    number of nodes from the instance into a local variable for clarity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we reshape the input array so that it contains a single row:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we generate a list of arrays of values using each of the coefficients
    in the `coeffs` attribute for the instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we sum all the arrays that were constructed in *step 5* and return
    the resulting array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will test our class by means of an example. We''ll define four control
    points for this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set up a new figure for plotting and plot the control points with
    a dashed connecting line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a new instance of our `Bezier` class using the four points
    we defined in *step 7*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create an array of equally spaced points between 0 and 1 using `linspace`
    and compute the points along the Bezier curve:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we plot this curve on top of the control points that we plotted earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The Bezier curve that we''ve plotted can be seen in the following diagram.
    As you can see, the curve starts at the first point (0, 0) and finishes at the
    final point (1, 3):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c99f6f7e-92bd-41b2-ad90-1825adbf5281.png)Figure 8.10: Bezier curve
    of degree 3 constructed using four nodes'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Bezier curve is described by a sequence of control points, from which we
    construct the curve in a recursive manner. A Bezier curve with one point is a
    constant curve that stays at that point. A Bezier curve with two control points
    is a line segment between those two points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7831c8c4-15ee-4b9b-9510-6984e970b044.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we add a third control point, we take the line segment between the corresponding
    points on the Bezier curve of curves that are constructed with one less point.
    This means that we construct the Bezier curve with three control points using
    the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/073ba1c8-7fa9-44af-b3fd-ac9851a2c20f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This construction can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5a5c45d4-8528-4e6e-b677-9358fa883cf8.png)Figure 8.11: Construction
    of a quadratic Bezier curve using a recursive definition. The two linear Bezier
    curves are shown by the black dashed lines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The construction continues in this manner to define the Bezier curve on any
    number of control points. Fortunately, we don''t need to work with this recursive
    definition in practice because we can flatten the formulae into a single formula
    for the curve, which is given by the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9674263f-1838-4821-9319-4120c125c796.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, the **p**[*i*] elements are the control points, *t* is a parameter, and
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b65b100a-f769-42f8-bc75-dc5b79d02475.png)'
  prefs: []
  type: TYPE_IMG
- en: 'is the binomial coefficient. Remember that the *t* parameter is the quantity
    that is changing to generate the points of the curve. We can isolate the terms
    in the previous sum that involve *t* and those that do not. This defines the coefficients
    that we defined in *step 2*, each of which are given by the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We reshape each of the points, `p`, in this step to make sure it is arranged
    as a column vector. This means that each of the coefficients is a column vector
    (as a NumPy array) consisting of the control points scaled by the binomial coefficients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to specify how to evaluate the Bezier curve at various values
    of *t*. This is where we make use of the high-performance array operations from
    the NumPy package. We reshaped our control points as column vectors when forming
    our coefficients. In *step 4*, we reshaped the input, *t*, values to make a row
    vector. This means that we can use the matrix multiplication operator to multiply
    each coefficient by the corresponding (scalar) value, depending on the input,
    *t*. This is what happens in *step 5*, inside the list comprehension. In the following
    line, we multiply the *l × 1* array by the *1 × N* array to obtain an *l × N*
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We get one of these for each coefficient. We can then use the `np.sum` routine
    to sum each of these *l × N* arrays to get the values along the Bezier curve.
    In the example provided in this recipe, the top row of the output array contains
    the *x* values of the curve and the bottom row contains the *y* values of the
    curve. We have to be careful when specifying the `axis=0` keyword argument for
    the `sum` routine to make sure the sum takes over the list we created, and not
    the arrays that this list contains.
  prefs: []
  type: TYPE_NORMAL
- en: The class we defined is initialized using the control points for the Bezier
    curve, which are then used to generate the coefficients. The actual computation
    of the curve values is done using NumPy, so this implementation should have relatively
    good performance. Once a specific instance of this class has been created, it
    functions very much like a function, as you might expect. However, no type checking
    is done here, so we can only call this "function" with a NumPy array as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bezier curves are defined using an iterative construction, where the curve with
    *n* points is defined using the straight line connecting the curves defined by
    the first and last *n-1* points. Keeping track of the coefficient of each of the
    control points using this construction will quickly lead you to the equation we
    used to define the preceding curve. This construction also leads to interesting
    – and useful – geometric properties of Bezier curves.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in the introduction to this recipe, Bezier curves appear in
    many applications that involve vector graphics, such as fonts. They also appear
    in many common vector graphics software packages. In these software packages,
    it is common to see *quadratic Bezier curves*, which are defined by a collection
    of three points. However, you can also define a quadratic Bezier curve by supplying
    the two endpoints, along with the gradient lines, at those points. This is more
    common in graphics software packages. The resulting Bezier curve will leave each
    of the endpoints along the gradient lines and connect the curve smoothly between
    these points.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation we constructed here will have relatively good performance
    for small applications, but will not be sufficient for applications involving
    rendering curves with a large number of control points at a large number of *t*
    values. For this, it is best to use a low-level package written in a compiled
    language. For example, the `bezier` Python package uses a compiled Fortran backend
    for its computations and provides a much richer interface than the class we defined
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Bezier curves can, of course, be extended to higher dimensions in a natural
    way. The result is a Bezier surface, which makes them very useful general-purpose
    tools for high-quality, scalable graphics.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A description of some common algorithms from computation geometry can be found
    in the following book: *Press, W.H., Teukolsky, S.A., Vetterling, W.T., and Flannery,
    B.P., 2007\. Numerical recipes: the art of scientific computing**. 3rd ed. Cambridge:
    Cambridge University Press*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a more detailed account of some problems and techniques from computational
    geometry, check out the following book: *O''Rourke, J., 1994\. Computational geometry
    in C**. Cambridge: Cambridge University Press*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
