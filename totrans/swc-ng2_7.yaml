- en: Chapter 7. Explaining Pipes and Communicating with RESTful Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last chapter, we covered some very powerful features of the framework.
    However, we can go even deeper into the functionality of Angular''s forms module
    and router. In the next sections, we''ll explain how we can:'
  prefs: []
  type: TYPE_NORMAL
- en: Develop model-driven forms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define parameterized routes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define child routes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `Http` module for communication with RESTful APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transform data with custom pipes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will explore all these concepts in the process of extending the functionality
    of the "Coders repository" application. At the beginning of the previous chapter,
    we mentioned that we're going to allow import of developers from GitHub. But before
    we implement this feature, let's extend the functionality of the form.
  prefs: []
  type: TYPE_NORMAL
- en: Developing model-driven forms in Angular 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These are going to be the last steps in finishing the "Coders repository". You
    can build on top of the code at `ch6/ts/step-1/` (or `ch6/ts/step-2` depending
    on your previous work) in order to extend the application's functionality with
    the new concepts we're going to cover. The complete example is located at `ch7/ts/multi-page-model-driven`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the result that we are going to achieve by the end of this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing model-driven forms in Angular 2](../images/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, there are the following two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A form for importing existing users from GitHub that contains:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The input for the GitHub handle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A checkbox that points out whether we want to import the developer from GitHub
    or enter it manually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A form for entering new users manually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second form looks exactly the way we finished it in the last section. However,
    this time, its definition looks a little bit different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this time, we don't have the `submit` handler or the `#f="ngForm"`
    attribute. Instead, we use the `[ngFormModel]` attribute in order to bind to a
    property defined inside the component's controller. By using this attribute, we
    can bind to something called `ControlGroup`. As its name states, the `ControlGroup`
    class consists of a list of controls grouped together with the sets of validation
    rules associated with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to use a similar declaration to *import a developer* form. However,
    this time, we will provide a different value of the `[ngFormModel]` attribute,
    since we are going to define a different control group in the component''s controller.
    Place the following snippet above the form we introduced earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s declare the `importDevForm` and `addDevForm` properties in the
    component''s controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Initially, we imported the `ControlGroup` class from the `angular2` module and,
    later, declared the required properties in the controller. Let's also notice that
    we have one additional parameter of the constructor of `AddDeveloper` called `fb`
    of the type `FormBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: '`FormBuilder` provides a programmable API for the definition of `ControlGroups`
    where we can attach validation behavior to each control in the group. Let''s use
    the `FormBulder` instance for the initialization of the `importDevForm` and `addDevForm`
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `FormBuilder` instance has a method called `group` that allows us to define
    properties, such as the default values and the validators for the individual controls
    in a given form.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the preceding snippet, `importDevForm` has two fields that we
    introduced earlier: `githubHandle` and `fetchFromGitHub`. We declared that the
    value of the `githubHandle` control is required and set the default value of the
    control `fetchFromGitHub` to `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second form, `addDevForm`, we declare four controls. For the `realName`
    control as the default value, we set the empty string and use `Validators.requred`
    in order to introduce validation behavior (which is exactly what we did for the
    `githubHandle` control). As a validator for the e-mail input, we will use the
    `validateEmail` function and set its initial value to an empty string. The `validateEmail`
    function used for validation is the one we defined in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The last two controls we define here are the `technology` control, which value
    is required and has an empty string as its initial value, and the `popular` control
    with its initial value set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Using composition of control validators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We took a look at how we can apply a single validator to form controls. However,
    in some applications, the domain may require more complex validation logic. For
    example, if we want to apply both the required and the `validateEmail` validators
    to the e-mail control, we should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `compose` method of the `Validators` object accepts as an argument an array
    of validators and returns a new validator. The new validator's behavior is going
    to be a composition of the logic defined in the individual validators passed as
    an argument, and they are going to be applied in the same order as they were introduced
    in the array.
  prefs: []
  type: TYPE_NORMAL
- en: The property names in the object literal passed to the `group` method should
    match with the values that we set to the `ngControl` attributes of the inputs
    in the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the complete template of `importDevForm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding template, you can notice that once the flag submitted has the
    value `true`, so the form will be hidden from the user. Next to the first input
    element, we set the value of the `ngControl` attribute to `githubHandle`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the value of the `ngControl` attribute of the given input element
    must match the name we used for its corresponding control declaration in the definition
    of `ControlGroup` within the component's controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'With regard to the `githubHandle` control, we also set the disabled attribute
    to equal the result of the evaluation of the expression: `!fetchFromGitHub`. This
    way, when the `fetchFromGitHub` checkbox is unchecked, the `githubHandle` control
    will be disabled. Similarly, in case of the example in the previous sections,
    we used the `ControlErrors` component we defined previously. This time, we set
    a single error with the message **The GitHub handle is required**.'
  prefs: []
  type: TYPE_NORMAL
- en: The markup for the form `addDevForm` looks quite similar, so we won't describe
    it in detail here. If you're not completely sure of how to approach developing
    it, you can take a look at the complete implementation at `ch7/ts/multi-page-model-driven/add_developer.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the template we''re going to take a look at is the `Submit`
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Clicking on the button will invoke the `addDeveloper` method defined in the
    component's controller. In the expression set as value of the `[disabled]` attribute,
    we initially check which form is selected by using the value of the property bound
    to the checkbox, that is, we verify whether the user wants to add a new developer
    or import an existing one from GitHub. If the first option is selected (that is,
    if the checkbox is not checked), we verify whether the `ControlGroup` for adding
    a new developer is valid. If it is valid, then the button will be enabled, otherwise
    it will be disabled. We will do the same in cases when the user has checked the
    checkbox for importing a developer from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the HTTP module of Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, after we develop the forms for both importing existing and adding new developers,
    it is the time to implement the logic behind it in the controller of the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, we need to communicate with the GitHub API. Although we can
    do this directly from the component''s controller, by doing it this way, we can
    couple it with the RESTful API of GitHub. In order to enforce further separation
    of concerns, we can extract the logic for communication with GitHub into a separate
    service called `GitHubGateway`. Open a file called `github_gateway.ts` and enter
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Initially, we imported the `Http` class from the `angular2/http` module. All
    the HTTP-related functionality is externalized and is outside the Angular's core.
    Since `GitHubGateway` accepts a dependency, which needs to be injected through
    the DI mechanism of the framework, we will decorate it with the `@Injectable`
    decorator.
  prefs: []
  type: TYPE_NORMAL
- en: The only functionality from the GitHub's API we're going to use is the one for
    fetching users, so we will define a single method called `getUser`. As an argument,
    it accepts the GitHub handle of the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if you make more than 60 requests per day to the GitHub's API, you
    might get the error **GitHub API Rate limit exceeded**. This is due to the rate
    limits for requests without a GitHub API token. For further information, visit
    [https://github.com/blog/1509-personal-api-tokens](https://github.com/blog/1509-personal-api-tokens).
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `getUser` method, we use the instance of the `Http` service that
    we've received in the `constructor` function. The `Http` service's API stays as
    close to the HTML5 fetch API as possible. However, there are a couple of differences.
    The most significant one of them is that at the moment of writing this content,
    all the methods of the `Http` instances return `Observables` instead of `Promises`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Http` service instances have the following API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`request(url: string | Request, options: RequestOptionsArgs)`: Makes a request
    to the specified URL. The request can be configured using `RequestOptionsArgs`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`get(url: string, options?: RequestOptionsArgs)`: Makes a get request to the
    specified URL. The request headers and other options can be configured using the
    second argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post(url: string, options?: RequestOptionsArgs)`: Makes a post request to
    the specified URL. The request body, headers, and other options can be configured
    using the second argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`put(url: string, options?: RequestOptionsArgs)`: Makes a put request to the
    specified URL. The request headers and other options can be configured using the
    second argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`patch(url: string, options?: RequestOptionsArgs)`: Makes a patch request to
    the specified URL. The request headers and other options can be configured using
    the second argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete(url: string, options?: RequestOptionsArgs)`: Makes a delete request
    to the specified URL. The request headers and other options can be configured
    using the second argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`head(url: string, options?: RequestOptionsArgs)`: Makes a head request to
    the specified URL. The request headers and other options can be configured using
    the second argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Angular's HTTP module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s implement the logic for importing existing users from GitHub! Open
    the file `ch6/ts/step-2/add_developer.ts` and enter the following imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `HTTP_PROVIDERS` and `GitHubGateway` to the list of providers of the `AddDeveloper`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As the next step, we have to include the following parameters in the constructor
    of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This way, the `AddDeveloper` class' instances will have a private property called
    `githubAPI`.
  prefs: []
  type: TYPE_NORMAL
- en: The only thing left is to implement the `addDeveloper` method and allow the
    user to import existing developers by using the `GitHubGateway` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the user presses the **Add** button, we need to check whether we need
    to import an existing GitHub user or add a new developer. For this purpose, we
    can use the value of the `fetchFromGitHub` control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If it has a truthy value, then we can invoke the `getUser` method of the `githubAPI`
    property and pass the value of the `githubHandle` control as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `getUser` method, we delegate the call to the `Http` service''s `get`
    method, which returns an observable. In order to get the result that the observable
    is going to push, we need to pass a callback to its `subscribe` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we first establish the HTTP `get` request. After this,
    we'll get the observable that, in general cases, will emit a series of values
    (in this case, only a single one—the response of the request) and map them to
    the JSON representation of their bodies. If the response fails or its body is
    not a valid JSON string, then we will get an error.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that in order to reduce the size of RxJS, Angular''s core team has included
    only its core. In order to use the methods `map` and `catch`, you need to add
    the following imports at `add_developer.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s implement the body of the subscribe callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we set the properties of a new `Developer` instance.
    Here, we established the mapping between the object returned from GitHub's API
    and the developer's representation in our application. We also considered a developer
    as popular if she or he has above 1,000 followers.
  prefs: []
  type: TYPE_NORMAL
- en: The entire implementation of the `addDeveloper` method can be found at `ch7/ts/multi-page-model-driven/add_developer.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to handle failed requests, we can use the `catch` method of the observable
    instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Defining parameterized views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the next step, let''s dedicate a special page for each developer. Inside
    of it, we''ll be able to take a detailed look at his or her profile. Once the
    user clicks on the name of any of the developers on the home page of the application,
    he or she should be redirected to a page with a detailed profile of the selected
    developer. The end result will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining parameterized views](../images/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to do this, we need to pass an identifier of the developer to the
    component that shows developer''s detailed profile. Open `app.ts` and add the
    following import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We haven''t developed the `DeveloperDetails` component yet, so if you run the
    application, you will get an error. We will define the component in the next paragraph,
    but before this, let''s alter the `@RouteConfig` definition of the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We added a single route with the `DeveloperDetails` component associated with
    it, and as an alias, we used the string `"DeveloperDetails"`.
  prefs: []
  type: TYPE_NORMAL
- en: The value of the `component` property is a reference to the constructor of the
    component, which should handle the given route. Once the source code of the application
    gets minified for production, the component name may differ from the one we've
    entered. This will create problems when referencing the route within the templates
    using the `routerLink` directive. In order to prevent this from happening, the
    core team introduced the `name` property that, in this case, equals to the name
    of the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although in all the examples so far, we set the alias of the route to be the
    same as the name of the component''s controller, this is not required. This convention
    is used for simplicity, since it could be confusing to introduce two names: one
    for pointing to the route and another one for the controller associated with the
    given route.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `path` property, we declare that the route has a single parameter called
    `id`, and with `"..."`, we hint the framework that this route will have nested
    routes inside of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s pass the `id` of the current developer as a parameter to the `routerLink`
    directive. Open `home.html` in your working directory and replace the table cell
    where we display the developer''s `realName` property with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of the `routerLink` directive is an array with the following three
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''/DeveloperDetails''`: A string that shows the root route'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{ ''id'': dev.id }`: An object literal that declares the route parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''DeveloperBasicInfo''`: The name of a route that shows which component within
    the nested route in the component with the alias `DeveloperDetails` should be
    rendered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining nested routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s jump to the `DeveloperDetails` definition. In your working directory,
    create a file called `developer_details.ts` and enter the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we defined a component with controller called `DeveloperDetails`.
    You can notice that within the controller's constructor, through the DI mechanism
    of Angular 2, we injected a parameter associated with the `RouteParams` token.
    The injected parameter provides us access to the parameters visible by the current
    route. We can access them using the `params` property of the injected object and
    access the target parameter using its name as a key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the parameter we got from `routeParams.params[''id'']` is a string, we
    need to parse it to a number in order to get the developer associated with the
    given route. Now let''s define the routes associated with `DeveloperDetails`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, there is nothing new for us. The route definition
    follows the exact same rules we're already familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to the template of the component, let''s add links associated with the
    individual nested routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Within the template, we declare two relative to the current path links. The
    first one points to `DeveloperBaiscInfo`, which is the name of the first route
    defined within `@RouteConfig` of the `DeveloperDetails` component, and respectively,
    the second one points to `DeveloperAdvancedInfo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the implementations of both the components are quite similar, let''s
    take a look only at `DeveloperBasicInfo`. As an exercise, you can develop the
    second one or take a look at its implementation at `ch7/ts/multi-page-model-driven/developer_advanced_info.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we injected the parent component combining the `@Inject`
    parameter decorator with `@Host`. Inside of `@Inject`, we use `forwardRef`, since
    we have a circular dependency between the packages `developer_basic_info` and
    `developer_details` (inside `developer_basic_info`, we import `developer_details`,
    and within `developer_details`, we import `developer_basic_info`).
  prefs: []
  type: TYPE_NORMAL
- en: We need a reference to the instance of the parent component in order to get
    the instance of the current developer corresponding to the selected route.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming data with pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is time for the last building block that Angular 2 provides for the development
    of applications that we haven't covered in detail yet—the pipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the filters in AngularJS 1.x, pipes are intended to encapsulate all
    the data-transformation logic. Let''s take a look at the template of the home
    page of the application we just developed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, depending on the value of the `popular` property,
    we showed different data using the `NgSwitch` and `NgSwitchThen` directives. Although
    this works, it is redundant.
  prefs: []
  type: TYPE_NORMAL
- en: Developing stateless pipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s develop a pipe that transforms the value of the `popular` property and
    uses it in the place of `NgSwitch` and `NgSwitchThen`. The pipe will accept three
    arguments: a value that should be transformed, a string that should be displayed
    when the value is truthy, and another string that should be displayed in case
    of a falsy value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the use of an Angular 2 custom pipe, we will be able to simplify the template
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We could even use emojis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]ts'
  prefs: []
  type: TYPE_NORMAL
- en: We apply the pipe to the value the same way we do in AngularJS 1.x. The arguments
    we pass to the pipe should be separated by the colon (`:`) symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to develop an Angular 2 pipe, we need the following imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]ts'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Pipe` decorator can be used for adding metadata to the class that implements
    the data transformation logic. The `PipeTransform` is an interface with a single
    method called transform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]ts'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding snippet is the entire implementation of `BooleanPipe`. The name
    of the pipe determines the way it should be used in templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do before being able to use the pipe is to add the
    `BooleanPipe` class to the list of pipes used by the `Home` component (`BooleanPipe`
    already holds the metadata attached to it by the `@Pipe` decorator, so its name
    is attached to it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]ts'
  prefs: []
  type: TYPE_NORMAL
- en: Using Angular's built-in pipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular 2 provides the following set of built-in pipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CurrencyPipe`: This pipe is used for formatting currency data. As an argument,
    it accepts the abbreviation of the currency type (that is, `"EUR"`, `"USD"`, and
    so on). It can be used in the following way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]ts'
  prefs: []
  type: TYPE_NORMAL
- en: '`DatePipe`: This pipe is used for the transformation of dates. It can be used
    in the following way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]ts'
  prefs: []
  type: TYPE_NORMAL
- en: '`DecimalPipe`: This pipe is used for transformation of decimal numbers. The
    argument it accepts is of the following form: `"{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}"`.
    It can be used in the following way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]ts'
  prefs: []
  type: TYPE_NORMAL
- en: '`JsonPipe`: This transforms a JavaScript object into a JSON string. It can
    be used in the following way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]ts'
  prefs: []
  type: TYPE_NORMAL
- en: '`LowerCasePipe`: This transforms a string to lowercase. It can be used in the
    following way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]ts'
  prefs: []
  type: TYPE_NORMAL
- en: '`UpperCasePipe`: This transforms a string to uppercase. It can be used in the
    following way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]ts'
  prefs: []
  type: TYPE_NORMAL
- en: '`PercentPipe`: This transforms a number into a percentage. It can be used in
    the following way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]ts'
  prefs: []
  type: TYPE_NORMAL
- en: '`SlicePipe`: This returns a slice of an array. The pipe accepts the start and
    the end indexes of the slice. It can be used in the following way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]ts'
  prefs: []
  type: TYPE_NORMAL
- en: '`AsyncPipe`: This is a `stateful` pipe that accepts an observable or a promise.
    We''re going to take a look at it at the end of the chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing stateful pipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There was one common thing between all the pipes mentioned earlier—all of them
    return exactly the same result each time we apply them to the same value and pass
    them the same set of arguments. Such pipes that hold the referentially transparency
    property are called pure pipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Pipe` decorator accepts an object literal of the following type: `{ name:
    string, pure?: boolean }`, where the default value for the `pure` property is
    `true`. This means that when we decorate a given class using the `@Pipe` decorator,
    we can declare whether we want the pipe it implements the logic for to be either
    stateful or stateless. The pure property is important, because in case the pipe
    is stateless (that is, it returns the same result in case it is applied over the
    same value with the same set of arguments), the change detection can be optimized.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let's build a stateful pipe! Our pipe will make an HTTP `get` request to
    a JSON API. For this purpose, we will use the `angular2/http` module.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that having business logic in a pipe is not considered as a best practice.
    This type of logic should be extracted into a service. The example here is for
    learning purposes only.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the pipe needs to hold a different state depending on the status
    of the request (that is, whether it is pending or completed). We will use the
    pipe in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]ts'
  prefs: []
  type: TYPE_NORMAL
- en: This way, we apply the `fetchJson` pipe over the URL, and once we have response
    from the remote service and the promise for the request has been resolved, we
    can apply the `json` pipe over the object we got from the response. The example
    also shows how we can chain pipes with Angular 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, in case of the previous example, for the development of a stateless
    pipe, we have to import `Pipe` and `PipeTransform`. However, this time, because
    of the HTTP request functionality, we also need to import the `Http` and `Response`
    classes from the `''angular2/http''` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]ts'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time it happens to apply the `fetchJson` pipe to a different argument
    compared to the one we got in the previous invocation, we need to make a new HTTP
    `get` request. This means that as the state of the pipe, we need to keep at least
    the values of the response of the remote service and the last URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]ts'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only piece of logic left is the `transform` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]ts'
  prefs: []
  type: TYPE_NORMAL
- en: Inside of it, we initially compared the URL passed as an argument with the one
    we currently keep a reference to. If they are different, we initiate a new HTTP
    `get` request using the local instance of the `Http` class, which was passed to
    the `constructor` function. Once the request is completed, we parse the response
    to JSON and set the `data` property to the result.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's suppose the pipe has started an `Http get` request, and before it
    is completed, the change detection mechanism invokes the pipe again. In this case,
    we will compare the `prevUrl` property with the `url` parameter. In case they
    are the same, we won't perform a new `http` request, and we will immediately return
    the value of the `data` property. In case `prevUrl` has a different value from
    `url`, we will start a new request.
  prefs: []
  type: TYPE_NORMAL
- en: Using stateful pipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s use the pipe that we developed! The application that we are going
    to implement provides to the user a text input and a button. Once the user enters
    a value in the text input and presses the button, below the text input will appear
    the avatar corresponding to the GitHub user, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using stateful pipes](../images/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s develop a sample component, which will allow us to enter the GitHub
    user''s handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]ts'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we added `FetchJsonPipe` used by the `App` component.
    The only thing left is to show the GitHub avatar of the user. We can easily achieve
    this by altering the template of the preceding component with the following `img`
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]ts'
  prefs: []
  type: TYPE_NORMAL
- en: Initially, we appended the GitHub handle to the base URL used for fetching users
    from the API. Later, we applied the `fetchJson` filter over it, and from the returned
    result, we got the `avatar_url` property.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although the previous example works, it is unnatural to have business logic
    in your pipes. It will be far better to implement the logic for communication
    with the GitHub's API into a service or, at least, invoke the `get` method of
    the instance of the `Http` class in a component.
  prefs: []
  type: TYPE_NORMAL
- en: Using Angular's AsyncPipe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular''s `AsyncPipe` transform method accepts as an argument an observable
    or a promise. Once the argument pushes a value (that is, the promise has been
    resolved or the `subscribe` callback of the observable is invoked with a value),
    `AsyncPipe` will return it as a result. Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]ts'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we defined an Angular 2 component, which has two properties: `greetingPromise`
    of the type `Promise<string>` and `resolve` of the type `Function`. We initialized
    the `greetingPromise` property with a new `Promise<string>` instance, and as value
    of the `resolve` property, we set the `resolve` callback of the `promise`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor of the class, we start a timeout with the duration of 3,000
    ms, and inside of its callback, we resolve the promise. Once the promise is resolved,
    the value of the expression `{{ greetingPromise | async }}` will be evaluated
    to the string `Foobar!`. The end result that the user will see on the screen is
    the text **Hello Foobar!**.
  prefs: []
  type: TYPE_NORMAL
- en: The `async` pipe is extremely powerful when we combine it with an `Http` request
    or together with an observable, which pushes a sequence of values.
  prefs: []
  type: TYPE_NORMAL
- en: Using AsyncPipe with observables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''re already familiar with the concept of observables from the previous chapters.
    We can say that an observable object allows us to subscribe to the emission of
    a sequence of values, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]ts'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we subscribe to the observable, it will start emitting values each second,
    which are going to be printed in the console. Let''s combine this snippet with
    the component''s definition and implement a simple timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]ts'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing left in order to be able to use the timer component is to add
    its template. We can subscribe to the observable directly in our template by using
    the `async` pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This way, each second we will get the new value emitted by the observable, and
    the `date` pipe will transform it into a readable form.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a deep dive into the Angular 2 forms by developing
    a model-driven one and combining it with the `http` module in order to be able
    to add developers to our repository. We took a look at some advanced features
    of the new component-based router and saw how we can use and develop our customized
    stateful and stateless pipes.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be dedicated to how we can make our Angular 2 applications
    SEO-friendly by taking advantage of the server-side rendering that the module
    universal provides. We will also take a look at angular-cli and the other tools
    that make our experience as developers better.
  prefs: []
  type: TYPE_NORMAL
