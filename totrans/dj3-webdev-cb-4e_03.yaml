- en: Forms and Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an app with CRUDL functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving the author of a model instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a form layout with custom templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a form layout with django-crispy-forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with formsets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering object lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing paginated lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing class-based views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing Open Graph and Twitter Card data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing schema.org vocabularies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating PDF documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a multilingual search with Haystack and Whoosh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a multilingual search with Elasticsearch DSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While a database structure is defined in models, views provide the endpoints
    necessary to show content to users or to let them enter new and updated data.
    In this chapter, we will focus on views for managing forms, the list view, and
    views generating alternative outputs to HTML. In the simplest examples, we will
    leave the creation of URL rules and templates up to you.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To work with the code of this chapter, as before, you will need the latest stable
    version of Python, MySQL, or a PostgreSQL database, and a Django project with
    a virtual environment. Some recipes will require specific Python dependencies. In
    addition, for generating PDF documents, you will need the `cairo`, `pango`, `gdk-pixbuf`,
    and `libffi` libraries. For searches, you will need an Elasticsearch server. You
    will get more details about them later in the corresponding recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the templates in this chapter will use the Bootstrap 4 CSS framework
    for a nicer look and feel.
  prefs: []
  type: TYPE_NORMAL
- en: You can find all of the code for this chapter in the `ch03` directory of the
    GitHub repository at: [https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: Creating an app with CRUDL functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In computer science, the **CRUDL** acronym stands for **Create**, **Read**,
    **Update**, **Delete**, and **List** functions. Many Django projects with interactive
    functionality will need you to implement all of those functions to manage data
    on the website. In this recipe, we will see how to create URLs and views for these
    basic functions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a new app called `ideas` and put it in `INSTALLED_APPS` in the
    settings. Create the following `Idea` model with an `IdeaTranslations` model for
    translations inside of that app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using several concepts here from the previous chapter: we inherit from
    model mixins and utilize a model translation table. Read more about that in the
    *Using model mixins* and the *Working with model translation tables* recipes.
    We are going to use the `ideas` app and these models for all of the recipes in
    this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, create an analogous `categories` app with the `Category` and `CategoryTranslations`
    models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The CRUDL functionality in Django consists of forms, views, and URL rules.
    Let''s create them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `forms.py` file to the `ideas` app with the model form for adding
    and changing the instances of your `Idea` model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new `views.py` file to the `ideas` app with the views to manipulate the
    `Idea` model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `urls.py` file in the `ideas` app with the URL rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s plug in these URL rules to the project''s URL configuration. We
    will also include the accounts'' URL rules from the Django-contributed `auth`
    app, so that our `@login_required` decorator works properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now be able to create the following templates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`registration/login.html` with a form to log in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ideas/idea_list.html` with a list of ideas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ideas/idea_detail.html` with the details about an idea'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ideas/idea_form.html` with a form to add or change an idea'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ideas/idea_deleting_confirmation.html` with an empty form to confirm idea
    deletion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the templates, you can address the URLs of the `ideas` app via the namespace
    and path names as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you get stuck or want to save time, check the corresponding templates in
    the code files for this book, which you can find at [https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition/tree/master/ch03/myproject_virtualenv/src/django-myproject/myproject/templates/ideas](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition/tree/master/ch03/myproject_virtualenv/src/django-myproject/myproject/templates/ideas).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we are using a UUID field for the primary key of the `Idea`
    model. With this ID, each idea has an un-guessable unique URL. Alternatively,
    you can use slug fields for URLs, but then you have to make sure that each slug
    is populated and is unique throughout the website.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not recommended to use the default incremental IDs for URLs, for security
    reasons: users can figure out how many items you have in the database and try
    to access the next or previous item, although they might not have permission to
    do that.'
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we are using generic class-based views for the listing and reading
    ideas and function-based views for creating, updating, and deleting them. The
    views that change the records in the database require authenticated users with
    the `@login_required` decorator. It would be also perfectly fine to use class-based
    views or function-based views for all CRUDL functions.
  prefs: []
  type: TYPE_NORMAL
- en: After successfully adding or changing an idea, the user will be redirected to
    the detail view. After deleting an idea, the user will be redirected to the list
    view.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition, you can use the Django messages framework to display success messages
    at the top of the page after each successful addition, change, or delete.
  prefs: []
  type: TYPE_NORMAL
- en: You can read about them in the official documentation at: [https://docs.djangoproject.com/en/2.2/ref/contrib/messages/](https://docs.djangoproject.com/en/2.2/ref/contrib/messages/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using model mixins* recipe in [Chapter 2](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)*, Models
    and Database Structure*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with model translation tables* recipe in [Chapter 2](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)*, Models
    and Database Structure*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Saving the author of a model instance* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Arranging the base.html template* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving the author of a model instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first argument of every Django view is the `HttpRequest` object, which by
    convention is named `request`. It contains metadata about the request sent from
    a browser or other client, including such items as the current language code,
    user data, cookies, and session. By default, forms that are used by views accept
    the GET or POST data, files, initial data, and other parameters; however, they
    do not inherently have access to the `HttpRequest` object. In some cases, it is
    useful to additionally pass `HttpRequest` to the form, especially when you want
    to filter out the choices of form fields based on other request data or handle
    saving something such as the current user or IP in the form.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see an example of a form where, for added or changed
    ideas, the current user is saved as an author.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will build upon the example in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this recipe, execute the following two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `IdeaForm` model form as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the view to add or change the ideas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at the form. At first, we exclude the `author` field from
    the form because we want to handle it programatically. We overwrite the `__init__()`
    method to accept `HttpRequest` as the first parameter and store it in the form.
    The `save()` method of a model form handles the saving of the model. The `commit`
    parameter tells the model form to save the instance immediately or otherwise to
    create and populate the instance, but not save it yet. In our case, we get the
    instance without saving it, then assign the author from the current user. Finally,
    we save the instance if `commit` is `True`. We will call the dynamically added `save_m2m()`
    method of the form to save many-to-many relations, for example, categories.
  prefs: []
  type: TYPE_NORMAL
- en: In the view, we just pass the `request` variable to the form as the first parameter.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating an app with CRUDL functions* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Uploading images* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will take a look at the easiest way to handle image uploads.
    We will add a `picture` field to the `Idea` model, and we will create image versions
    of different dimensions for different purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For images with image versions, we will need the `Pillow` and `django-imagekit`
    libraries. Let''s install them with `pip` in your virtual environment (and include
    them in `requirements/_base.txt`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Then, add `"imagekit"` to `INSTALLED_APPS` in the settings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Execute these steps to complete the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `Idea` model to add a `picture` field and image version specifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Create a model form, `IdeaForm`, for the `Idea` model in `forms.py`, just like
    we did in the previous recipes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the view for adding or changing ideas, make sure to post `request.FILES`
    beside `request.POST` to the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the template, make sure to have encoding type set to `"multipart/form-data"`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you are using `django-crispy-form` as described in the *Creating a form layout
    with django-crispy-forms* recipe, the `enctype` attribute will be added to the
    form automatically.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django model forms are created dynamically from models. They provide the specified
    fields from the model so you don't need to redefine them manually in the form.
    In the preceding example, we created a model form for the `Idea` model. When we
    save the form, the form knows how to save each field in the database, as well
    as how to upload the files and save them in the media directory.
  prefs: []
  type: TYPE_NORMAL
- en: The `upload_to()` function in our example is used for saving the image to a
    specific directory and defining its name such that it wouldn't clash with filenames
    for other model instances. Each file will be saved under a path such as `ideas/2020/01/0422c6fe-b725-4576-8703-e2a9d9270986.jpg`,
    which consists of the year and month of the upload and the primary key of the
    `Idea` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Some filesystems (such as FAT32 and NTFS) have a limited amount of files available
    per directory; therefore, it is a good practice to divide them into directories
    by upload date, alphabet, or other criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are creating three image versions using `ImageSpecField` from django-imagekit:'
  prefs: []
  type: TYPE_NORMAL
- en: '`picture_social` is used for social sharing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`picture_large` is used for the detail view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`picture_thumbnail` is used for the list view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image versions are not linked in the database but just saved in the default
    file storage under a file path such as `CACHE/images/ideas/2020/01/0422c6fe-b725-4576-8703-e2a9d9270986/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the template, you can use the original or a specific image version, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: At the end of the `Idea` model definition, we overwrite the `delete()` method
    to delete the image versions and the picture from the disk just before deleting
    the instance of `Idea` itself.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a form layout with django-crispy-forms* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Arranging the base.html template* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Providing responsive images* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a form layout with custom templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In earlier versions of Django, all form rendering was handled exclusively in
    Python code, but since Django 1.11, template-based form widget rendering has been
    introduced. In this recipe, we will examine how to use custom templates for form
    widgets. We are going to use the Django administration form to illustrate how
    the custom widget templates can improve the usability of the fields.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create the default Django administration for the `Idea` model and its
    translations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you access the administration form for the ideas, it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d063e19c-516f-4966-bad8-b91d5a734cda.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete the recipe, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that the template system will be able to find customized templates by
    adding `"django.forms"` to `INSTALLED_APPS`, including the `APP_DIRS` flag as
    `True` at the templates configuration, and using the `"TemplatesSetting"` form
    renderer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `admin.py` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create a template for your picture field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you look at the administration form for ideas now, you will see something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50557bdd-bdfe-4d29-acb7-9e64af5eb808.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are two changes here:'
  prefs: []
  type: TYPE_NORMAL
- en: The category selection is now using a widget with multiple checkboxes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The picture field is now rendered with a specific template, showing a preview
    of the image and help text with preferred file types and dimensions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What we did here, was we overwrote the model form for the idea and modified
    the widget for the categories and the template for the picture field.
  prefs: []
  type: TYPE_NORMAL
- en: The default form renderer in Django is `"django.forms.renderers.DjangoTemplates"`,
    and it only searches for the templates in app directories. We changed it to `"django.forms.renderers.TemplatesSetting"`
    to also have a look in the templates under `DIRS` paths.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Working with model translation tables* recipe in [Chapter 2](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)*,
    Models and Database Structure*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Uploading images* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a form layout with django-crispy-forms* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a form layout with django-crispy-forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `django-crispy-forms` Django app allows you to build, customize, and reuse
    forms using one of the following CSS frameworks: Uni-Form, Bootstrap 3, Bootstrap
    4, or Foundation. The use of `django-crispy-forms` is somewhat analogous to fieldsets
    in the Django contributed administration; however, it is more advanced and customizable.
    You define form layout in the Python code and need not worry about how each field
    is presented in HTML. Moreover, if you need to add specific HTML attributes or
    wrapping, you can easily do that too. All of the markup used by `django-crispy-forms`
    is located in templates that can be overwritten for specific needs.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a nice layout for the frontend form to add or
    edit ideas using the Bootstrap 4, popular frontend framework for developing responsive,
    mobile-first web projects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start with the `ideas` app that we created in this chapter. Next, we''ll
    execute the following tasks one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have created a `base.html` template for your site. Learn more
    about this in the *Arranging the base.html template* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Integrate the Bootstrap 4 frontend framework CSS and JS files
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: from [https://getbootstrap.com/docs/4.3/getting-started/introduction/](https://getbootstrap.com/docs/4.3/getting-started/introduction/) into
    the `base.html` template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `django-crispy-forms` in your virtual environment with `pip` (and include
    it in `requirements/_base.txt`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that `"crispy_forms"` is added to `INSTALLED_APPS` in the settings,
    and then set `"bootstrap4"` as the template pack to be used in this project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the model form for the ideas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s create the `picture_guidelines.html` template with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s update the template for the form of ideas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the model form for ideas, we create a form helper with a layout consisting
    of a main fieldset, picture fieldset, categories fieldset, and submit button.
    Each fieldset consists of fields. Any fieldset, field, or button can have additional
    parameters that become the attributes of the field, for example,  `rows="3"` or
    `placeholder=_("Please enter a title")`. For HTML `class` and `id` attributes,
    there are specific parameters, `css_class` and `css_id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The page with the idea form will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/188283f1-62f5-40af-b4b8-5a1adc05995b.png)'
  prefs: []
  type: TYPE_IMG
- en: Just like in the previous recipe, we modify the widget for the categories field
    and add additional help text for the picture field.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For basic usage, the given example is more than necessary. However, if you need
    a specific markup for the forms in your project, you can still overwrite and modify
    templates of the `django-crispy-forms` app, as there is no markup hardcoded in
    the Python files, rather all of the generated markup is rendered through templates.
    Just copy the templates from the `django-crispy-forms` app to your project's template
    directory and change them as required.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating an app with CRUDL functions* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a form layout with custom templates* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Filtering object lists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Managing paginated lists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Composing class-based views* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Arranging the base.html template* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with formsets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides normal or model forms, Django has a concept of formsets. These are sets
    of forms of the same type that allow us to create or change multiple instances
    at once. Django formsets can be enriched with JavaScript, which allows us to add
    them to a page dynamically. That's exactly what we will work on in this recipe.
    We will extend the form of ideas to allow adding translations to different languages
    on the same page.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's continue working on `IdeaForm` from the previous recipe, *Creating a form
    layout with django-crispy-forms*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the form layout for `IdeaForm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s add `IdeaTranslationsForm` at the end of the same file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the view to add or change ideas, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s edit the `idea_form.html` template and add a reference to the `inlines.js`
    script file at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the template for the translation formsets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, add the JavaScript to manipulate the formsets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might know about formsets from the Django model administration. Formsets
    are used there in the mechanism of inlines for child models having foreign keys
    to a parent model.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we added formsets to the idea form using `django-crispy-forms`.
    The result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9685ebfb-8112-4d54-888d-0326cd58da3a.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we can insert the formsets not necessarily at the end of the
    form, but anywhere in between, where it makes sense. In our example, it makes
    sense to list out translations just after translatable fields.
  prefs: []
  type: TYPE_NORMAL
- en: The form layout for the translations forms has the main fieldset just like the
    layout of `IdeaForm`, but in addition, it has `id` and `DELETE` fields that are
    necessary for recognition of each model instance and the possibility to remove
    them from the list. The `DELETE` field is actually a checkbox that if checked,
    deletes the appropriate item from the database. Also, the form helper for the
    translation has `form_tag=False`, which doesn't generate the `<form>` tag, and
    `disable_csrf=True`, which doesn't include the CSRF token, because we have already
    defined these in the parent form, `IdeaForm`.
  prefs: []
  type: TYPE_NORMAL
- en: In the view, if the request is sent by the POST method and both the form and
    the formset are valid, then we save the form and create respective translation
    instances without saving them at first. This is done by the `commit=False` attribute.
    For each translation instance, we assign the idea and then save the translations
    to the database. Lastly, we check whether any forms in the formset were marked
    for deletion and delete them from the database.
  prefs: []
  type: TYPE_NORMAL
- en: In the `translations.html` template, we render each form in the formset and
    then we add an extra hidden empty form, which will be used by JavaScript to generate
    new forms of the formset to be added dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Each formset form has prefixes for all fields. For example, the `title` field
    of the first formset form will have an HTML field name, `"translations-0-title"`,
    and the `DELETE` field of the same formset form will have an HTML field name, `"translations-0-DELETE"`.
    The empty form has a word, `"__prefix__"`, instead of the index, for example,
    `"translations-__prefix__-title"`. This is abstracted at the Django level, but
    necessary to know for manipulating the formset forms with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `inlines.js` JavaScript does a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: For each existing formset form, it initializes its JavaScript-powered widgets
    (you could use tooltips, day or color pickers, maps, and so on) and creates a
    delete button, which is shown instead of the `DELETE` checkbox.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a delete button is clicked, it checks the `DELETE` checkbox and hides the
    formset form from the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the add button is clicked, it clones the empty form and replaces `"__prefix__"`
    with the next available index, adds the new form to the list, and initiates JavaScript-powered
    widgets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The JavaScript uses an array, `window.WIDGET_INIT_REGISTER`, which contains
    functions that should be called to initiate widgets with a given formset form.
    To register a new function in another JavaScript file, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This will apply tooltip functionality for all occurrences in the formset forms
    where the tags in the markup have `data-toggle="tooltip"` and `title` attributes,
    as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a form layout with django-crispy-forms* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Arranging the base.html template* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering object lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In web development, besides views with forms, it is typical to have object-list
    views and detail views. List views can simply list objects that are ordered, for
    example, alphabetically or by creation date; however, that is not very user-friendly
    with huge amounts of data. For the best accessibility and convenience, you should
    be able to filter the content by all possible categories. In this recipe, we will
    see the pattern that is used to filter list views by any number of categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we''ll be creating is a list view of ideas that can be filtered by author,
    category, or rating. It will look similar to the following with Bootstrap 4 applied
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0dc5a7c9-2254-4018-a314-e97c6be30a32.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the filtering example, we will use the `Idea` model with relation to the
    author and categories to filter by. It will also be possible to filter by ratings,
    which is `PositiveIntegerField` with choices. Let's use the ideas app with the
    models that we created in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete the recipe, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `IdeaFilterForm` with all of the possible categories to filter by:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `idea_list` view to list filtered ideas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same file, add the helper function, `filter_facets()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you haven't done so already, create a `base.html` template. You can do that
    according to the example provided in the *Arranging the base.html template* recipe
    in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*, Templates and JavaScript*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `idea_list.html` template with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s create the template for the filters. This template uses the `{%
    modify_query %}` template tag, described in the *Creating a template tag to modify
    request query parameters* recipe in [Chapter 5](c4fd2c24-3a56-4d2d-9ef3-c455e8a626ef.xhtml)*,
    Custom Template Filters and Tags*, to generate URLs for the filters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the categories will follow a common pattern in the filters sidebar,
    so we can create and include templates with the common parts. First, we have the
    filter heading, corresponding to `misc/includes/filter_heading.html`, as in the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And then each filter will contain a link to reset filtering for that category,
    represented by `misc/includes/filter_all.html` here. This template also uses the
    `{% modify_query %}` template tag, described in the *Creating a template tag to
    modify request query parameters* recipe in [Chapter 5](c4fd2c24-3a56-4d2d-9ef3-c455e8a626ef.xhtml)*,
    Custom Template Filters and Tags*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea list needs to be added to the URLs for the `ideas` app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are using the `facets` dictionary that is passed to the template context
    to know which filters we have and which filters are selected. To look deeper,
    the `facets` dictionary consists of two sections: the `categories` dictionary
    and the `selected` dictionary. The `categories` dictionary contains QuerySets
    or choices of all filterable categories. The `selected` dictionary contains the
    currently selected values for each category. In `IdeaFilterForm`, we make sure
    that only those categories and authors are listed that have at least one idea.'
  prefs: []
  type: TYPE_NORMAL
- en: In the view, we check whether the query parameters are valid in the form and
    then filter the QuerySet of objects based on the selected categories. Additionally,
    we set the selected values to the `facets` dictionary, which will be passed to
    the template.
  prefs: []
  type: TYPE_NORMAL
- en: In the template, for each categorization from the `facets` dictionary, we list
    all of the categories and mark the currently selected category as active. If nothing
    is selected for a given category, we mark the default "All" link as the active
    one.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Managing paginated lists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Composing class-based views* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Arranging the base.html template* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to modify request query parameters* recipe in [Chapter
    5](c4fd2c24-3a56-4d2d-9ef3-c455e8a626ef.xhtml)*, Custom Template Filters and Tags*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing paginated lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have dynamically changing lists of objects or their count is greater
    than 24 or so, you will likely need pagination to provide a good user experience.
    Instead of the full QuerySet, pagination provides a specific number of items in
    the dataset that corresponds to the appropriate size for one page. We also display
    links to allow users to access the other pages making up the complete set of data.
    Django has classes to manage paginated data, and we will see how to use them in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with the models, forms, and views of the `ideas` app from the *Filtering
    object lists* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add pagination to the list view of the ideas, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary pagination classes from Django into the `views.py` file.
    We will add pagination management to the `idea_list` view just after filtering.
    Also, we will slightly modify the context dictionary by assigning `page` to the
    `object_list` key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `idea_list.html` template as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the pagination widget template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you look at the results in the browser, you will see the pagination controls,
    similar to the follo wing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b53de7b4-5c07-4550-a0b0-c22c96e06655.png)'
  prefs: []
  type: TYPE_IMG
- en: How do we achieve this? When QuerySet is filtered out, we will create a paginator
    object passing QuerySet and the maximal amount of items that we want to show per
    page, which is 24 here. Then, we will read the current page number from the query
    parameter, `page`. The next step is to retrieve the current page object from the
    paginator. If the page number is not an integer, we get the first page. If the
    number exceeds the number of possible pages, the last page is retrieved. The page
    object has methods and attributes necessary for the pagination widget shown in
    the preceding screenshot. Also, the page object acts like QuerySet so that we
    can iterate through it and get the items from the fraction of the page.
  prefs: []
  type: TYPE_NORMAL
- en: The snippet marked in the template creates a pagination widget with the markup
    for the Bootstrap 4 frontend framework. We show the pagination controls only if
    there are more pages than the current one. We have the links to the previous and
    next pages, and the list of all page numbers in the widget. The current page number
    is marked as active. To generate URLs for the links, we use the `{% modify_query
    %}` template tag, which will be described later in the *Creating a template tag
    to modify request query parameters* recipe in [Chapter 5](c4fd2c24-3a56-4d2d-9ef3-c455e8a626ef.xhtml)*,
    Custom Template Filters and Tags*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Filtering object lists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Composing class-based views* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to modify request query parameters* recipe in [Chapter
    5](c4fd2c24-3a56-4d2d-9ef3-c455e8a626ef.xhtml)*, Custom Template Filters and Tags*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing class-based views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django views are callables that take requests and return responses. In addition
    to function-based views, Django provides an alternative way to define views as
    classes. This approach is useful when you want to create reusable modular views
    or combine views of the generic mixins. In this recipe, we will convert the previously
    shown function-based `idea_list` view into a class-based `IdeaListView` view.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create the models, form, and template similar to the previous recipes, *Filtering
    object lists* and *Managing paginated lists*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to execute the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our class-based view, `IdeaListView`, will inherit the Django `View` class
    and override the `get()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to create a URL rule in the URL configuration using the class-based
    view. You may have added a rule previously for the function-based `idea_list`
    view, which would have been similar. To include a class-based view in the URL
    rules, use the `as_view()` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the things happening in the `get()` method, which is called
    for HTTP GET requests:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create the `form` object, passing the `request.GET` dictionary-like
    object to it. The `request.GET` object contains all of the query variables that
    are passed using the GET method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, the `form` object is passed to the `get_queryset_and_facets()` method,
    which returns the associated values via a tuple containing two elements: QuerySet
    and the `facets` dictionary respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current request object and retrieved QuerySet are passed to the `get_page()`
    method, which returns the current page object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we create a `context` dictionary and render the response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we needed to support it, we could also provide a `post()` method, which is
    called for HTTP POST requests.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you see, the `get()` and `get_page()` methods are largely generic, so we
    could create a generic `FilterableListView` class with these methods in the `core`
    app. Then, in any app that requires a filterable list, we could create a class-based
    view that extends `FilterableListView` to handle such scenarios. This extending
    class would define only the `form_class` and `template_name` attributes and the
    `get_queryset_and_facets()` method. Such modularity and extensibility represent
    two of the key benefits of how class-based views work.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Filtering object lists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Managing paginated lists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing Open Graph and Twitter Card data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want the content of your website to be shared on social networks, you
    should at least implement Open Graph and Twitter Card meta tags. These meta tags
    define how the web page is represented in Facebook or Twitter feeds: what title
    and description will be shown, what image will be set, and what the URL is about.
    In this recipe, we will prepare the `idea_detail.html` template for social sharing.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's continue with the `ideas` app from previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to complete the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to have the `Idea` model created with the picture field and picture
    version specifications. See the *Creating an app with CRUDL functions* and *Uploading
    images* recipes for more information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure to have a detail view ready for ideas. See the *Creating an app with
    CRUDL functions* recipe for information on how to do that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plug the detail view into the URL configuration. How to do that is described
    in the *Creating an app with CRUDL functions* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the settings of your specific environment, define `WEBSITE_URL` and `MEDIA_URL`
    as full URLs of the media files, as in this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `core` app, create a context processor returning the `WEBSITE_URL` variable
    from the settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Plug in the context processor in the settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `idea_detail.html` template with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open Graph tags are meta tags with special names starting with `og:` and Twitter
    card tags are meta tags with special names starting with `twitter:`. These meta
    tags define the URL, title, description, and image of the current page, site name,
    author, and locale. It is important to provide full URLs there; the path alone
    would be not enough.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `picture_social` image version which has the optimal dimensions for
    social networks: 1024 × 512 px.
  prefs: []
  type: TYPE_NORMAL
- en: You can validate your Open Graph implementation at [https://developers.facebook.com/tools/debug/sharing/](https://developers.facebook.com/tools/debug/sharing/).
  prefs: []
  type: TYPE_NORMAL
- en: Twitter Card implementation can be validated at [https://cards-dev.twitter.com/validator](https://cards-dev.twitter.com/validator).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating an app with CRUDL functions* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Uploading images* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Providing schema.org vocabularies* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing schema.org vocabularies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to have semantic markup for **Search Engine Optimization** (**SEO**).
    But to improve search engine rankings even more, it is beneficial to provide structured
    data according to schema.org vocabularies. Many applications from Google, Microsoft,
    Pinterest, Yandex, and others use schema.org structures to create rich extensible
    experiences such as special consistent-looking cards in the search results for
    events, movies, authors, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: There are several encodings, including RDFa, Microdata, and JSON-LD, that can
    be used to create schema.org vocabularies. In this recipe, we will prepare structured
    data for the `Idea` model in JSON-LD format, which is preferred and recommended
    by Google.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s install the `django-json-ld` package into your project''s virtual environment (and
    include it in `requirements/_base.txt`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Put `"django_json_ld"` under `INSTALLED_APPS` in the settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to complete the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `structured_data` property with the following content to the `Idea`
    model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `idea_detail.html` template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `{% render_json_ld %}` template tag will render the script tag similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `structured_data` property returns a nested dictionary according to the
    schema.org vocabularies that are well understood by most popular search engines.
  prefs: []
  type: TYPE_NORMAL
- en: You can decide which vocabularies to apply to your models by checking the official
    documentation at [https://schema.org/docs/schemas.html](https://schema.org/docs/schemas.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a model mixin to take care of meta tags* recipe in [Chapter 2](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)*,
    Models and Database Structure*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating an app with CRUDL functions* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Uploading images* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Providing Open Graph and Twitter Card data* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating PDF documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django views allow you to create much more than just HTML pages. You can create
    files of any type. For example, in the *Exposing settings in JavaScript* recipe
    in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*, Templates and JavaScript*,
    our view provides its output as a JavaScript file rather than HTML. You can also
    create PDF documents for invoices, tickets, receipts, booking confirmations, and
    so on. In this recipe, we will show you how to generate handouts to print for
    each idea from the database. We are going to use the **WeasyPrint** library to
    make PDF documents out of HTML templates.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WeasyPrint depends on several libraries that you need to install on your computer.
    On macOS, you can install them with Homebrew using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can install WeasyPrint itself in the virtual environment of your
    project. Also, include it in `requirements/_base.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: For other operating systems, check the installation instructions at [https://weasyprint.readthedocs.io/en/latest/install.html](https://weasyprint.readthedocs.io/en/latest/install.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we''ll be using `django-qr-code` to generate a **QR code** linking back
    to the website for quick access. Let''s also install it in the virtual environment
    (and include it in `requirements/_base.txt`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `"qr_code"` to `INSTALLED_APPS` in the settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to complete the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the view that will generate the PDF document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Plug this view into the URL configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a template for the PDF document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, create the `base_pdf.html` template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WeasyPrint generates ready-to-print, pixel-perfect documents. Our example of
    a handout we could give out to an audience at presentations will look similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa351e86-8e13-4efb-8820-54e1db58e70f.png)'
  prefs: []
  type: TYPE_IMG
- en: The layout of the document is defined in markup and CSS. WeasyPrint has its
    own rendering engine. Read more about supported features in the official documentation
    at: [https://weasyprint.readthedocs.io/en/latest/features.html](https://weasyprint.readthedocs.io/en/latest/features.html).
  prefs: []
  type: TYPE_NORMAL
- en: You can use SVG images, which will be saved as vector graphics, not bitmaps,
    and therefore will be crispier in the printout. Inline SVGs are not yet supported,
    but you can use `<img>` tags with a data source or external URL there. In our
    example, we use SVG images for the QR code and for the logo in the footer.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get through the code of the view. We render the `idea_handout_pdf.html`
    template with the selected idea as an `html` string. Then, we create an `HttpResponse`
    object of PDF content type with the filename composed of the current date and
    slugified idea title. Then, we create WeasyPrint's HTML object with HTML content
    and write it to the response as if we would write to a file. In addition, we use
    the `FontConfiguration` object, which allows us to attach and use web fonts from
    CSS configuration in the layout. Lastly, we return the response object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating an app with CRUDL functions* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Uploading images* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Exposing settings in JavaScript* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a multilingual search with Haystack and Whoosh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main functionalities of content-driven websites is a full-text search.
    Haystack is a modular search API that supports the Solr, Elasticsearch, Whoosh,
    and Xapian search engines. For each model in your project that has to be findable
    in the search, you need to define an index that will read out the textual information
    from the models and place it into the backend. In this recipe, you will learn
    how to set up a search with Haystack and the Python-based Whoosh search engine
    for a multilingual website.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to use the previously defined `categories` and `ideas` apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you have installed `django-haystack` and `Whoosh` in your virtual
    environment (and include them in `requirements/_base.txt`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s set up a multilingual search with Haystack and Whoosh by executing the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `search` app that will contain `MultilingualWhooshEngine` and search
    indexes for our ideas. The search engine will live in the `multilingual_whoosh_backend.py`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the search indexes, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure the settings to use `MultilingualWhooshEngine`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a path to the URL rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need a template for the search form and search results, as given here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Add a pagination template at `misc/includes/pagination.html` just like in the *Managing
    paginated lists* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Call the `rebuild_index` management command to index the database data and
    prepare the full-text search to be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`MultilingualWhooshEngine` specifies two custom properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`backend` points to `MultilingualWhooshSearchBackend`, which ensures that the
    items will be indexed for each language given in the `LANGUAGES` setting and put
    under the associated Haystack index location defined in `HAYSTACK_CONNECTIONS`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`query` references `MultilingualWhooshSearchQuery`, whose responsibility is
    to ensure that, when searching for keywords, the Haystack connection specific
    to the current language will be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each index has a `text` field, where full text from a specific language of a
    model will be stored. The model for the index is determined by the `get_model()`
    method, the `index_queryset()` method defines what QuerySet to index, and the
    content to search within is defined as a newline-separated string in the `prepare_text()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: For the template, we have incorporated a few elements of Bootstrap 4 using the
    out-of-the-box rendering capabilities for forms. This might be enhanced using
    an approach such as explained in the *Creating a form layout with django-crispy-forms*
    recipe from earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final search page will have the form in the sidebar and the search results
    in the main columns and will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/675a5960-e419-4368-977e-e4cc65304211.png)'
  prefs: []
  type: TYPE_IMG
- en: The easiest way to update the search index regularly is to call the `rebuild_index`
    management command, perhaps by a cron job every night. To learn about it, check
    the *Setting up cron jobs for regular tasks* recipe in [Chapter 13](498be2b9-4d46-4b50-ab7a-27c535792ae6.xhtml)*,
    Maintenance*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a form layout with django-crispy-forms* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Managing paginated lists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Setting up cron jobs for regular tasks* recipe in [Chapter 13](498be2b9-4d46-4b50-ab7a-27c535792ae6.xhtml)*,
    Maintenance*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a multilingual search with Elasticsearch DSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Haystack with Whoosh is a good stable search mechanism that requires just some
    Python modules, but for better performance, we recommend using Elasticsearch.
    In this recipe, we'll show you how to use it for a multilingual search.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start with, let''s install the Elasticsearch server. On macOS, you can do
    that with Homebrew:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: At the time of writing, the latest stable version of Elasticsearch on Homebrew
    is 6.8.2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `django-elasticsearch-dsl` in your virtual environment (and include
    it in `requirements/_base.txt`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Note that it is important to install a matching `django-elasticsearch-dsl` version.
    Otherwise, you will get errors when trying to connect to the Elasticsearch server
    or building an index. You can see a version compatibility table at [https://github.com/sabricot/django-elasticsearch-dsl](https://github.com/sabricot/django-elasticsearch-dsl).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s set up a multilingual search with Elasticsearch DSL by executing the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the settings file and add `"django_elasticsearch_dsl"` to `INSTALLED_APPS`
    and set the `ELASTICSEARCH_DSL` setting as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `ideas` app, create a `documents.py` file with `IdeaDocument` for the
    idea search index, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `prepare_*` methods to `IdeaDocument` to prepare data for the index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some properties and methods to `IdeaDocument` to return translated content
    from the indexed documents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'One more thing to do in the `documents.py` file is to monkey-patch the `UUIDField` mappings
    because, by default, it is not yet supported by Django Elasticsearch DSL. To do
    that, insert this line just after the imports section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `IdeaSearchForm` under `forms.py` in your `ideas` app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the view for searching with Elasticsearch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `idea_search.html` template for the search form and search results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Add a pagination template at `misc/includes/pagination.html` just like in the
    *Managing paginated lists* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Call the `search_index --rebuild` management command to index the database
    data and prepare the full-text search to be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django Elasticsearch DSL documents are similar to model forms. There you define
    which fields of the model to save to the index that later will be used for the
    search queries. In our `IdeaDocument` example, we are saving the UUID, rating,
    author, categories, titles, contents, and URL paths in all languages and a picture
    thumbnail URL. The `Index` class defines the settings of the Elasticsearch index
    for this document. The `Django` class defines where to populate the index fields
    from. There is the `related_models` setting that tells after which model changes
    to also update this index. In our case, it is a `Category` model. Note that with
    `django-elasticsearch-dsl`, the indexes will be updated automatically whenever
    the models are saved. That is done using signals.
  prefs: []
  type: TYPE_NORMAL
- en: The `get_instances_from_related()` method tells how to retrieve the `Idea` model
    instances when a `Category` instance is changed.
  prefs: []
  type: TYPE_NORMAL
- en: The `prepare()` and `prepare_*()` methods of `IdeaDocument` tell where to take
    the data from and how to save the data for specific fields. For example, we are
    reading the data for `title_lt` from the `title` field of the `IdeaTranslations`
    model where the `language` field equals `"lt"`.
  prefs: []
  type: TYPE_NORMAL
- en: The last properties and methods of the `IdeaDocument` are there to use for retrieval
    of information from the index in the currently active language.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have a view with the search form. There is a query field in the form
    called `q`. When it is submitted, we are searching for the queried word in the
    title, content, or category's title field of the current language. Then, we wrap
    the search results with a lazily evaluated `SearchResults` class, so that we could
    use it with the default Django paginator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template of the view will have the search form in the sidebar and the search
    results in the main column, and it will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e41b1ce7-bc57-4f78-9cb0-74cb7b297949.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating an app with CRUDL functions* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing a multilingual search with Haystack and Whoosh* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a form layout with django-crispy-forms* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Managing paginated lists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
