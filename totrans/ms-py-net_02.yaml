- en: Low-Level Network Device Interactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](2bb48797-d649-4704-85fc-0f5244ed34fb.xhtml), *Review of TCP/IP
    Protocol Suite and Python*, we looked at the theories and specifications behind
    network communication protocols. We also took a quick tour of the Python language.
    In this chapter, we will start to dive deeper into the management of network devices
    using Python. In particular, we will examine the different ways in which we can
    use Python to programmatically communicate with legacy network routers and switches.
  prefs: []
  type: TYPE_NORMAL
- en: What do I mean by legacy network routers and switches? While it is hard to imagine
    any networking device coming out today without an **Application Program Interface**
    (**API**) for programmatic communication, it is a known fact that many of the
    network devices deployed in previous years did not contain API interfaces. The
    intended method of management for those devices was through **Command Line Interfaces**
    (**CLIs**) using terminal programs, which were originally developed with a human
    engineer in mind. The management relied on the engineer's interpretation of the
    data returned from the device for appropriate action. As the number of network
    devices and the complexity of the network grew, it became increasingly difficult
    to manually manage them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has two great libraries that can help with these tasks, Pexpect and
    Paramiko, as well as other libraries derived from them. This chapter will cover
    Pexpect first, then move on with examples from Paramiko. Once you understand the
    basics of Paramiko, it is easy to branch out to expanded libraries such as Netmiko.
    It is also worth mentioning that Ansible (covered in [Chapters 4](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml),
    *The Python Automation Framework – Ansible Basics*, and [Chapter 5](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml), *The
    Python Automation Framework – Beyond Basics*) relies heavily on Paramiko for its
    network modules. In this chapter, we will take a look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The challenges of the CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing a virtual lab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python Pexpect library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python Paramiko library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The downsides of Pexpect and Paramiko
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: The challenges of the CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the Interop expo in Las Vegas in 2014, *BigSwitch Networks''* CEO Douglas
    Murray displayed the following slide to illustrate what had changed in **Data
    Center Networking** (**DCN**) in the 20 years between 1993 to 2013:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2b428760-cc25-4349-a112-3ec3dd5e2f71.png)Data center networking
    changes (source: [https://www.bigswitch.com/sites/default/files/presentations/murraydouglasstartuphotseatpanel.pdf](https://www.bigswitch.com/sites/default/files/presentations/murraydouglasstartuphotseatpanel.pdf))'
  prefs: []
  type: TYPE_IMG
- en: 'His point was apparent: not much had changed in those 20 years in the way we
    manage network devices. While he might have been negatively biased toward the
    incumbent vendors when displaying this slide, his point is well taken. In his
    opinion, the only thing that had changed about managing routers and switches in
    20 years was the protocol changing from the less secure Telnet to the more secure SSH.'
  prefs: []
  type: TYPE_NORMAL
- en: It was right around the same time in 2014 that we started to see the industry
    coming to a consensus about the clear need to move away from manual, human-driven
    CLI toward an automatic, computer-centric automation API. Make no mistake, we
    still need to directly communicate with the device when making network designs,
    bringing up initial proof of concepts, and deploying the topology for the first
    time. However, once we have moved beyond the initial deployment, the requirement
    is to consistently make the same changes reliably, to make them error-free, and
    to repeat them over and over again without the engineer being distracted or feeling
    tired. This requirement sounds like an ideal job for computers and our favorite
    language, Python.
  prefs: []
  type: TYPE_NORMAL
- en: Referring back to the slide, the main challenge is the interaction between the
    router and the administrator. The router will output a series of information and
    will expect the administrator to enter a series of manual commands from the engineer's
    interpretation of the output. For example, you have to type in `enable` to get
    into a privileged mode, and upon receiving the returned prompt with the `#` sign,
    you then type in `configure terminal` in order to go into the configuration mode.
    The same process can further be expanded into the interface configuration mode
    and routing protocol configuration mode. This is in sharp contrast to a computer-driven,
    programmatic mindset. When the computer wants to accomplish a single task, say,
    put an IP address on an interface, it wants to structurally give all the information
    to the router at once, and it would expect a single `yes` or `no` answer from
    the router to indicate the success or failure of the task.
  prefs: []
  type: TYPE_NORMAL
- en: The solution, as implemented by both Pexpect and Paramiko, is to treat the interactive
    process as a child process and watch over the interaction between the process
    and the destination device. Based on the returned value, the parent process will
    decide the subsequent action, if any.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing a virtual lab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we dive into the packages, let''s examine the options of putting together
    a lab for the benefit of learning. As the old saying goes, *practice makes perfect*:
    we need an isolated sandbox to safely make mistakes, try out new ways of doing
    things, and repeat some of the steps to reinforce concepts that were not clear
    in the first try. It is easy enough to install Python and the necessary packages
    for the management host, but what about those routers and switches that we want
    to simulate?'
  prefs: []
  type: TYPE_NORMAL
- en: 'To put together a network lab, we basically have two options, each with its
    advantages and disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Physical device**: This option consists of physical devices that you can
    see and touch. If you are lucky enough, you might be able to put together a lab
    that is an exact replication of your production environment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advantages**: It is an easy transition from lab to production, easier to
    understand by managers and fellow engineers who can look at and touch the devices.
    In short, the comfort level with physical devices is extremely high because of
    familiarity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages**: It is relatively expensive to pay for a device that is only
    used in the lab. Devices require engineering hours to rack and stack and are not
    very flexible once constructed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Virtual devices**: These are emulations or simulations of actual network
    devices. They are either provided by the vendors or by the open source community:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advantages**: Virtual devices are easier to set up, relatively cheap, and
    can make changes to the topology quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages**: They are usually a scaled-down version of their physical
    counterpart. Sometimes there are feature gaps between the virtual and the physical
    device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, deciding on a virtual or physical lab is a personal decision derived
    from a trade-off between the cost, ease of implementation, and the risk of having
    a gap between lab and production. In some of the environments I have worked on,
    the virtual lab is used when doing an initial proof-of-concept while the physical
    lab is used when we move closer to the final design.
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, as more and more vendors decide to produce virtual appliances,
    the virtual lab is the way to proceed in a learning environment. The feature gap
    of the virtual appliance is relatively small and specifically documented, especially
    when the virtual instance is provided by the vendor. The cost of the virtual appliance
    is relatively small compared to buying physical devices. The time-to-build using
    virtual devices is quicker because they are usually just software programs.
  prefs: []
  type: TYPE_NORMAL
- en: For this book, I will use a combination of physical and virtual devices for
    concept demonstration with a preference for virtual devices. For the examples
    we will see, the differences should be transparent. If there are any known differences
    between the virtual and physical devices pertaining to our objectives, I will
    make sure to list them.
  prefs: []
  type: TYPE_NORMAL
- en: On the virtual lab front, besides images from various vendors, I am using a
    program from Cisco called **Virtual Internet Routing Lab** (**VIRL**), [https://learningnetworkstore.cisco.com/virtual-internet-routing-lab-virl/cisco-personal-edition-pe-20-nodes-virl-20](https://learningnetworkstore.cisco.com/virtual-internet-routing-lab-virl/cisco-personal-edition-pe-20-nodes-virl-20).
  prefs: []
  type: TYPE_NORMAL
- en: I want to point out that the use of this program is entirely optional for the
    reader. But it is strongly recommended that the reader have some lab equipment
    to follow along with the examples in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Cisco VIRL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I remember when I first started to study for my **Cisco Certified Internetwork
    Expert** (**CCIE**) lab exam, I purchased some used Cisco equipment from eBay
    to study with. Even at a discount, each router and switch cost hundreds of US
    dollars, so to save money, I purchased some really outdated Cisco routers from
    the 1980s (search for Cisco AGS routers in your favorite search engine for a good
    chuckle), which significantly lacked features and horsepower, even for lab standards.
    As much as it made for an interesting conversation with family members when I
    turned them on (they were really loud), putting the physical devices together
    was not fun. They were heavy and clunky, it was a pain to connect all the cables,
    and to introduce link failure, I would literally unplug a cable.
  prefs: []
  type: TYPE_NORMAL
- en: Fast-forward a few years. **Dynamip** was created and I fell in love with how
    easy it was to create different network scenarios. This was especially important
    when I tried to learn a new concept. All you need is the IOS images from Cisco,
    a few carefully constructed topology files, and you can easily construct a virtual
    network that you can test your knowledge on. I had a whole folder of network topologies,
    pre-saved configurations, and different version of images, as called for by the
    scenario. The addition of a GNS3 frontend gives the whole setup a beautiful GUI
    facelift. With GNS3, you can just click and drop your links and devices; you can
    even just print out the network topology for your manager right out of the GNS3
    design panel. The only thing that was lacking was the tool not being officially
    blessed by the vendor and the perceived lack of credibility because of it.
  prefs: []
  type: TYPE_NORMAL
- en: In 2015, the Cisco community decided to fulfill this need by releasing the Cisco
    VIRL. If you have a server that meets the requirements and you are willing to
    pay for the required annual license, this is my preferred method of developing
    and trying out much of the Python code, both for this book and my own production
    use.
  prefs: []
  type: TYPE_NORMAL
- en: As of January 1 2017, only the personal edition 20-Node license is available
    for purchase for USD $199.99 per year.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even at a monetary cost, in my opinion, the VIRL platform offers a few advantages
    over other alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ease of use**: All the images for IOSv, IOS-XRv, CSR100v, NX-OSv, and ASAv
    are included in a single download.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Official** (**kind of**): Although support is community-driven, it is a widely
    used tool internally at Cisco. Because of its popularity, the bugs get fixed quickly,
    new features are carefully documented, and useful knowledge is widely shared among
    its users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The cloud migration path**: The project offers a logical migration path when
    your emulation grows out of the hardware power you have, such as Cisco dCloud
    ([https://dcloud.cisco.com/](https://dcloud.cisco.com/)), VIRL on Packet ([http://virl.cisco.com/cloud/](http://virl.cisco.com/cloud/)),
    and Cisco DevNet ([https://developer.cisco.com/](https://developer.cisco.com/)).
    This is an important feature that sometimes gets overlooked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The link and control-plane simulation**: The tool can simulate latency, jitter,
    and packet loss on a per-link basis for real-world link characteristics. There
    is also a control-plane traffic generator for external route injection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Others**: The tool offers some nice features, such as VM Maestro topology
    design and simulation control, AutoNetkit for automatic config generation, and
    user workspace management if the server is shared. There are also open source
    projects such as virlutils ([https://github.com/CiscoDevNet/virlutils](https://github.com/CiscoDevNet/virlutils)),
    which are actively worked on by the community to enhance the workability of the
    tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will not use all of the features in VIRL in this book. But since this is
    a relatively new tool that is worth your consideration, if you do decide this
    is the tool you would like to use, I want to offer some of the setups I used.
  prefs: []
  type: TYPE_NORMAL
- en: Again, I want to stress the importance of having a lab, but it does not need
    to be the Cisco VIRL lab. The code examples provided in this book should work
    across any lab device, as long as they run the same software type and version.
  prefs: []
  type: TYPE_NORMAL
- en: VIRL tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The VIRL website ([http://virl.cisco.com/](http://virl.cisco.com/)) offers
    lots of guidance, preparation, and documentation. I also find that the VIRL user
    community generally offers quick and accurate help. I will not repeat information
    already offered in those two places; however, here are some of the setups I use
    for the lab in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: 'VIRL uses two virtual Ethernet interfaces for connections. The first interface
    is set up as NAT for the host machine''s internet connection, and the second is
    used for local management interface connectivity (VMnet2 in the following example).
    I use a separate virtual machine with a similar network setup in order to run
    my Python code, with the first primary Ethernet used for internet connectivity
    and the second Ethernet connection to Vmnet2 for lab device management network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/c82cd2d1-cdde-4f81-bc77-ae9d8fa0975c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'VMnet2 is a custom network created to connect the Ubuntu host with the VIRL
    virtual machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/85f2152f-11e7-4be2-918e-d6153657d2be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Topology Design option, I set the Management Network option to Shared
    flat network in order to use VMnet2 as the management network on the virtual routers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/02656522-3921-4e03-a513-4d10675cd081.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Under the node configuration, you have the option to statically configure the
    management IP. I try to statically set the management IP addresses instead of
    having them dynamically assigned by the software. This allows for more deterministic
    accessibility:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/ef2611d4-2e65-4fde-93d2-89b164515c8c.png)'
  prefs: []
  type: TYPE_IMG
- en: Cisco DevNet and dCloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cisco provides two other excellent, and, at the time of writing, free, methods
    for practicing network automation with various Cisco gears. Both of the tools
    require a **Cisco Connection Online (CCO)** login. They are both really good,
    especially for the price point (they are free!). It is hard for me to imagine
    that these online tools will remain free for long; it is my belief that, at some
    point, these tools will need to charge money for their usage or be rolled into
    a bigger initiative that requires a fee. However, we can take advantage of them
    while they are available at no charge.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first tool is the Cisco DevNet ([https://developer.cisco.com/](https://developer.cisco.com/))
    sandbox, which includes guided learning tracks, complete documentation, and sandbox
    remote labs, among other benefits. Some of the labs are always on, while others
    you need to reserve. The lab availability will depend on usage. It is a great
    alternative if you do not already have a lab at your own disposal. In my experience
    with DevNet, some of the documentation and links were outdated, but they can be
    easily retrieved for the most updated version. In a rapidly changing field such
    as software development, this is somewhat expected. DevNet is certainly a tool
    that you should take full advantage of, regardless of whether you have a locally
    run VIRL host or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/687289f1-0881-4d40-a9f9-b46cb69a31bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another online lab option for Cisco is [https://dcloud.cisco.com/](https://dcloud.cisco.com/).
    You can think of dCloud as running VIRL on other people''s servers without having
    to manage or pay for those resources. It seems that Cisco is treating dCloud as
    both a standalone product as well as an extension to VIRL. For example, in the
    use case of when you are unable to run more than a few IOX-XR or NX-OS instances
    locally, you can use dCloud to extend your local lab. It is a relatively new tool,
    but it is definitely worth a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9013d0ba-57bd-48e0-8d65-8278953469b5.png)'
  prefs: []
  type: TYPE_IMG
- en: GNS3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few other virtual labs that I use for this book and other purposes.
    The [GNS3](https://gns3.com/) tool is one of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/90c418fe-1abc-4b39-9bc3-38e5104ea653.png)'
  prefs: []
  type: TYPE_IMG
- en: As mentioned previously in this chapter, GNS3 is what a lot of us used to study
    for certification tests and to practice for labs. The tool has really grown up
    from the early days of the simple frontend for Dynamips into a viable commercial
    product. Cisco-made tools, such as VIRL, DevNet, and dCloud, only contain Cisco
    technologies. Even though they provide ways for virtual lab devices to communicate
    with the outside world, they are not as easy as just having multi-vendor virtualized
    appliances living directly in the simulation environment. GNS3 is vendor-neutral
    and can include a multi-vendor virtualized platform directly in the lab. This
    is typically done either by making a clone of the image (such as Arista vEOS) or
    by directly launching the network device image via other hypervisors (such as
    Juniper Olive emulation). Some might argue that GNS3 does not have the breadth
    and depth of the Cisco VIRL project, but since they can run different variation
    Cisco technologies, I often use it when I need to incorporate other vendor technologies
    into the lab.
  prefs: []
  type: TYPE_NORMAL
- en: Another multi-vendor network emulation environment that has gotten a lot of
    great reviews is the **Emulated Virtual Environment Next Generation (EVE-NG)**,
    [http://www.eve-ng.net/](http://www.eve-ng.net/). I personally do not have much
    experience with the tool, but many of my colleagues and friends in the industry
    use it for their network labs.
  prefs: []
  type: TYPE_NORMAL
- en: There are also other virtualized platforms, such as Arista vEOS ([https://eos.arista.com/tag/veos/](https://eos.arista.com/tag/veos/)),
    Juniper vMX ([http://www.juniper.net/us/en/products-services/routing/mx-series/vmx/](http://www.juniper.net/us/en/products-services/routing/mx-series/vmx/)),
    and vSRX ([http://www.juniper.net/us/en/products-services/security/srx-series/vsrx/](http://www.juniper.net/us/en/products-services/security/srx-series/vsrx/)),
    which you can use as a standalone virtual appliance during testing. They are great
    complementary tools for testing platform-specific features, such as the differences
    between the API versions on the platform. Many of them are offered as paid products
    on public cloud provider marketplaces for easier access. They are often offered
    the identical feature as their physical counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: Python Pexpect library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pexpect is a pure Python module for spawning child applications, controlling
    them, and responding to expected patterns in their output. Pexpect works like
    Don Libes' Expect. Pexpct allows your script to spawn a child application and
    control it as if a human were typing commands. Pexpect, Read the Docs: [https://pexpect.readthedocs.io/en/stable/index.html](https://pexpect.readthedocs.io/en/stable/index.html)
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the Python Pexpect library. Similar to the original Tcl
    Expect module by Don Libe, Pexpect launches or spawns another process and watches
    over it in order to control the interaction. The Expect tool was originally developed
    to automate interactive processes such as FTP, Telnet, and rlogin, and was later
    expanded to include network automation. Unlike the original Expect, Pexpect is
    entirely written in Python, which does not require TCL or C extensions to be compiled.
    This allows us to use the familiar Python syntax and its rich standard library
    in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Pexpect installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since this is the first package we will install, we will install both the `pip`
    tool with the `pexpect` package. The process is pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I am using `pip3` to install Python 3 packages, while using `pip` to install
    packages in the Python 2 environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do a quick to test to make sure the package is usable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Pexpect overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our first lab, we will construct a simple network with two IOSv devices
    connected back to back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8ae3d89a-e435-42d3-bab2-6835055f9cae.png)Lab topology'
  prefs: []
  type: TYPE_NORMAL
- en: 'The devices will each have a loopback address in the `192.16.0.x/24` range
    and the management IP will be in the `172.16.1.x/24` range. The VIRL topology
    file is included in the accommodated book downloadable files. You can import the
    topology to your own VIRL software. If you do not have VIRL, you can also view
    the necessary information by opening the topology file with a text editor. The
    file is simply an XML file with each node''s information under the `node` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/15ca7c31-52f3-4c40-a953-ea2b7a79cb45.png)Lab node information'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the devices ready, let''s take a look at how you would interact with the
    router if you were to Telnet into the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'I used VIRL AutoNetkit to automatically generate the initial configuration
    of the routers, which generated the default username `cisco`, and the password
    `cisco`. Notice that the user is already in privileged mode because of the privilege
    assigned in the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The auto-config also generated `vty` access for both Telnet and SSH:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see a Pexpect example using the Python interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Starting from Pexpect version 4.0, you can run Pexpect on a Windows platform.
    But, as noted in the Pexpect documentation, running Pexpect on Windows should
    be considered experimental for now.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous interactive example, Pexpect spawns off a child process and
    watches over it in an interactive fashion. There are two important methods shown
    in the example, `expect()` and `sendline()`. The `expect()` line indicates that
    the string the Pexpect process looks for as an indicator for when the returned
    string is considered done. This is the expected pattern. In our example, we knew
    the router had sent us all the information when the hostname prompt (`iosv-1#`) was
    returned. The `sendline()` method indicates which words should be sent to the
    remote device as the command. There is also a method called `send()` but `sendline()`
    includes a linefeed, which is similar to pressing the *Enter* key at the end of
    the words you sent in your previous telnet session. From the router's perspective,
    it is just as if someone typed in the text from a Terminal. In other words, we
    are tricking the routers into thinking they are interfacing with a human being
    when they are actually communicating with a computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `before` and `after` properties will be set to the text printed by the
    child application. The `before` properties will be set to the text printed by
    the child application up to the expected pattern. The `after` string will contain
    the text that was matched by the expected pattern. In our case, the `before` text
    will be set to the output between the two expected matches (`iosv-1#`), including
    the `show version` command. The `after` text is the router hostname prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What would happen if you expected the wrong term? For example, if you typed
    in `username` instead of `Username` after spawning the child application, then
    the Pexpect process would look for a string of `username` from the child process.
    In that case, the Pexpect process would just hang because the word `username`
    would never be returned by the router. The session would eventually timeout, or
    you could manually exit out via *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `expect()` method waits for the child application to return a given string,
    so in the previous example, if you wanted to accommodate both lowercase and uppercase
    `u`, you could use the following term:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The square bracket serves as an `or` operation that tells the child application
    to expect a lowercase or uppercase `u` followed by `sername` as the string. What
    we are telling the process is that we will accept either `Username` or `username` as
    the expected string.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on Python regular expressions, go to [https://docs.python.org/3.5/library/re.html](https://docs.python.org/3.5/library/re.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `expect()` method can also contain a list of options instead of just a
    single string; these options can also be regular expression themselves. Going
    back to the previous example, you can use the following list of options to accommodate
    the two different possible strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Generally speaking, use the regular expression for a single `expect` string
    when you can fit the different hostname in a regular expression, whereas use the
    possible options if you need to catch completely different responses from the
    router, such as a password rejection. For example, if you use several different
    passwords for your login, you want to catch `% Login invalid` as well as the device
    prompt.
  prefs: []
  type: TYPE_NORMAL
- en: One important difference between Pexpect regular expressions and Python regular
    expressions is that the Pexpect matching is non-greedy, which means they will
    match as little as possible when using special characters. Because Pexpect performs
    regular expression on a stream, you cannot look ahead, as the child process generating
    the stream may not be finished. This means the special dollar sign character `$` typically
    matching the end of the line is useless because `.+` will always return no characters,
    and the `.*` pattern will match as little as possible. In general, just keep this
    in mind and be as specific as you can be on the `expect` match strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Hmm... Something is not quite right here. Compare it to the Terminal output
    before; the output you expect would be `hostname iosv-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Taking a closer look at the expected string will reveal the mistake. In this
    case, we were missing the hash (`#`) sign behind the `iosv-1` hostname. Therefore,
    the child application treated the second part of the return string as the expected
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can see a pattern emerging from the usage of Pexpect after a few examples.
    The user maps out the sequence of interactions between the Pexpect process and
    the child application. With some Python variables and loops, we can start to construct
    a useful program that will help us gather information and make changes to network
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: Our first Pexpect program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first program, `chapter2_1.py`, extends what we did in the last section
    with some additional code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a nested dictionary in line 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The nested dictionary allows us to refer to the same device (such as `iosv-1`)
    with the appropriate IP address and prompt symbol. We can then use those values
    for the `expect()` method later on in the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output prints out the `show version | i V` output on the screen for each
    of the devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: More Pexpect features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at more Pexpect features that might come in handy
    when certain situations arise.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a slow or fast link to your remote device, the default `expect()`
    method timeout is 30 seconds, which can be increased or decreased via the `timeout`
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can choose to pass the command back to the user using the `interact()`
    method. This is useful when you just want to automate certain parts of the initial
    task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get a lot of information about the `child.spawn` object by printing
    it out in string format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The most useful debug tool for Pexpect is to log the output in a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Use `child.logfile = open('debug', 'w')` for Python 2\. Python 3 uses byte strings
    by default. For more information on Pexpect features, check out [https://pexpect.readthedocs.io/en/stable/api/index.html](https://pexpect.readthedocs.io/en/stable/api/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Pexpect and SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you try to use the previous Telnet example and plug it into an SSH session
    instead, you might find yourself pretty frustrated with the experience. You always
    have to include the username in the session, answering the `ssh` new key question,
    and much more mundane tasks. There are many ways to make SSH sessions work, but
    luckily, Pexpect has a subclass called `pxssh`, which specializes in setting up
    SSH connections. The class adds methods for login, log out, and various tricky
    things to handle the different situations in the `ssh` login process. The procedures
    are mostly the same, with the exception of `login()` and `logout()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `auto_prompt_reset=False` argument in the `login()` method. By default,
    `pxssh` uses the Shell prompt to synchronize the output. But since it uses the
    PS1 option for most of bash or CSH, they will error out on Cisco or other network
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: Putting things together for Pexpect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the final step, let's put everything you have learned so far about Pexpect
    into a script. Putting code into a script makes it easier to use in a production
    environment, as well as easier to share with your colleagues. We will write our
    second script, `chapter2_2.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the script from the book GitHub repository, [https://github.com/PacktPublishing/Mastering-Python-Networking-second-edition](https://github.com/PacktPublishing/Mastering-Python-Networking-second-edition),
    as well as looking at the output generated from the script as a result of the
    commands.Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The script further expands from our first Pexpect program with the following
    additional features:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses SSH instead of Telnet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports multiple commands instead of just one by making the commands into
    a list (line 8) and loops through the commands (starting at line 20)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It prompts the user for their username and password instead of hardcoding them
    in the script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It writes the output in two files, `iosv-1_output.txt`, and `ios-2_output.txt`,
    to be further analyzed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Python 2, use `raw_input()` instead of `input()` for the username prompt.
    Also, use `w` for the file mode instead of `wb`.
  prefs: []
  type: TYPE_NORMAL
- en: The Python Paramiko library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Paramiko is a Python implementation of the SSHv2 protocol. Just like the `pxssh`
    subclass of Pexpect, Paramiko simplifies the SSHv2 interaction between the host
    and the remote device. Unlike `pxssh`, Paramiko focuses only on SSHv2 with no
    Telnet support. It also provides both client and server operations.
  prefs: []
  type: TYPE_NORMAL
- en: Paramiko is the low-level SSH client behind the high-level automation framework
    Ansible for its network modules. We will cover Ansible in later chapters. Let's
    take a look at the Paramiko library.
  prefs: []
  type: TYPE_NORMAL
- en: Installation of Paramiko
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing Paramiko is pretty straightforward with Python `pip`. However, there
    is a hard dependency on the cryptography library. The library provides low-level,
    C-based encryption algorithms for the SSH protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The installation instruction for Windows, Mac, and other flavors of Linux can
    be found at [https://cryptography.io/en/latest/installation/](https://cryptography.io/en/latest/installation/).
  prefs: []
  type: TYPE_NORMAL
- en: We will show the Paramiko installation of our Ubuntu 16.04 virtual machine in
    the following output. The following output shows the installation steps, as well
    as Paramiko successfully imported into the Python interactive prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Python 2, please follow the steps below. We will try to import
    the library in the interactive prompt to make sure the library can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using Python 3,please refer the following command-lines for installing
    the dependencies. After installation, we will import the library to make sure
    it is correctly installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Paramiko overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a quick Paramiko example using the Python 3 interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `time.sleep()` function inserts a time delay to ensure that all the outputs
    were captured. This is particularly useful on a slower network connection or a
    busy device. This command is not required but is recommended depending on your
    situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if you are seeing the Paramiko operation for the first time, the beauty
    of Python and its clear syntax means that you can make a pretty good educated
    guess at what the program is trying to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first four lines create an instance of the `SSHClient` class from Paramiko.
    The next line sets the policy that the client should use when the SSH server''s
    hostname; in this case, `iosv-1`, is not present in either the system host keys
    or the application''s keys. In our scenario, we will automatically add the key
    to the application''s `HostKeys` object. At this point, if you log on to the router,
    you will see the additional login session from Paramiko:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The next few lines invoke a new interactive shell from the connection and a
    repeatable pattern of sending a command and retrieving the output. Finally, we
    close the connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some readers who have used Paramiko before might be familiar with the `exec_command()` method
    instead of invoking a shell. Why do we need to invoke an interactive shell instead
    of using `exec_command()` directly? Unfortunately, `exec_command()` on Cisco IOS
    only allows a single command. Consider the following example with `exec_command()`
    for the connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything works great; however, if you look at the number of sessions on the
    Cisco device, you will notice that the connection is dropped by the Cisco device
    without you closing the connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the SSH session is no longer active, `exec_command()` will return an
    error if you want to send more commands to the remote device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The Netmiko library by Kirk Byers is an open source Python library that simplifies
    SSH management to network devices. To read about it, check out this article, [https://pynet.twb-tech.com/blog/automation/netmiko.html,](https://pynet.twb-tech.com/blog/automation/netmiko.html) and
    the source code, [https://github.com/ktbyers/netmiko](https://github.com/ktbyers/netmiko).
  prefs: []
  type: TYPE_NORMAL
- en: 'What would happen if you did not clear out the received buffer? The output
    would just keep on filling up the buffer and would overwrite it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: For consistency of the deterministic output, we will retrieve the output from
    the buffer each time we execute a command.
  prefs: []
  type: TYPE_NORMAL
- en: Our first Paramiko program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first program will use the same general structure as the Pexpect program
    we have put together. We will loop over a list of devices and commands while using
    Paramiko instead of Pexpect. This will give us a good compare and contrast of
    the differences between Paramiko and Pexpect.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have not done so already, you can download the code, `chapter2_3.py`,
    from the book''s GitHub repository, [https://github.com/PacktPublishing/Mastering-Python-Networking-second-edition](https://github.com/PacktPublishing/Mastering-Python-Networking).
    I will list the notable differences here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We no longer need to match the device prompt using Paramiko; therefore, the
    device dictionary can be simplified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no sendline equivalent in Paramiko; instead, we manually include the
    newline break in each of the commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We include a new method to clear the buffer for sending commands, such as `terminal
    length 0` or `enable`, because we do not need the output for those commands. We
    simply want to clear the buffer and get to the execution prompt. This function
    will later be used in the loop, such as in line 25 of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the program should be pretty self-explanatory, similar to what
    we have seen in this chapter. The last thing I would like to point out is that
    since this is an interactive program, we place some buffer and wait for the command
    to be finished on the remote device before retrieving the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: After we clear the buffer, during the time between the execution of commands,
    we will wait two seconds. This will give the device adequate time to respond if
    it is busy.
  prefs: []
  type: TYPE_NORMAL
- en: More Paramiko features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will look at Paramiko a bit later in the book, when we discuss Ansible, as
    Paramiko is the underlying transport for many of the network modules. In this
    section, we will take a look at some of the other features of Paramiko.
  prefs: []
  type: TYPE_NORMAL
- en: Paramiko for servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Paramiko can be used to manage servers through SSHv2 as well. Let's look at
    an example of how we can use Paramiko to manage servers. We will use key-based
    authentication for the SSHv2 session.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I used another Ubuntu virtual machine on the same hypervisor
    as the destination server. You can also use a server on the VIRL simulator or
    an instance in one of the public cloud providers, such as Amazon AWS EC2.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will generate a public-private key pair for our Paramiko host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This command, by default, will generate a public key named `id_rsa.pub`, as
    the public key under the user home directory `~/.ssh` along with a private key
    named `id_rsa`. Treat the private key with the same attention as you would private
    passwords that you do not want to share with anybody else. You can think of the
    public key as a business card that identifies who you are. Using the private and
    public keys, the message will be encrypted by your private key locally and decrypted
    by the remote host using the public key. We should copy the public key to the
    remote host. In production, we can do this via out-of-band using a USB drive;
    in our lab, we can simply copy the public key to the remote host's `~/.ssh/authorized_keys`
    file. Open up a Terminal window for the remote server, so you can paste in the
    public key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the content of `~/.ssh/id_rsa` on your management host with Paramiko:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, paste it to the remote host under the `user` directory; in this case,
    I am using `echou` for both sides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You are now ready to use Paramiko to manage the remote host. Notice in this
    example that we will use the private key for authentication as well as the `exec_command()`
    method for sending commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the server example, we do not need to create an interactive session
    to execute multiple commands. You can now turn off password-based authentication
    in your remote host's SSHv2 configuration for more secure key-based authentication
    with automation enabled. Some network devices, such as Cumulus and Vyatta switches,
    also support key-based authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Putting things together for Paramiko
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are almost at the end of the chapter. In this last section, let''s make
    the Paramiko program more reusable. There is one downside of our existing script:
    we need to open up the script every time we want to add or delete a host, or whenever
    we need to change the commands we want to execute on the remote host. This is
    due to the fact that both the host and command information are statically entered
    inside of the script. Hardcoding the host and command has a higher chance of making
    mistakes. Besides, if you were to pass on the script to colleagues, they might
    not feel comfortable working in Python, Paramiko, or Linux.'
  prefs: []
  type: TYPE_NORMAL
- en: By making both the host and command files be read in as parameters for the script,
    we can eliminate some of these concerns. Users (and a future you) can simply modify
    these text files when you need to make host or command changes.
  prefs: []
  type: TYPE_NORMAL
- en: We have incorporated the change in the script named `chapter2_4.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of hardcoding the commands, we broke the commands into a separate `commands.txt`
    file. Up to this point, we have been using show commands; in this example, we
    will make configuration changes. In particular, we will change the logging buffer
    size to `30000` bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The device''s information is written into a `devices.json` file. We choose
    JSON format for the device''s information because JSON data types can be easily
    translated into Python dictionary data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the script, we made the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an abbreviated output from the script execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Do a quick check to make sure the change has taken place in both `running-config`
    and `startup-config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Looking ahead
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have taken a pretty huge leap forward in this chapter as far as automating
    our network using Python is concerned. However, the method we have used feels
    like somewhat of a workaround for automation. We attempted to trick the remote
    devices into thinking they were interacting with a human on the other end.
  prefs: []
  type: TYPE_NORMAL
- en: Downsides of Pexpect and Paramiko compared to other tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The biggest downside of our method so far is that the remote devices do not
    return structured data. They return data that is ideal to be fitted on a terminal
    to be interpreted by a human, not by a computer program. The human eye can easily
    interpret a space, while a computer only sees a return character.
  prefs: []
  type: TYPE_NORMAL
- en: We will take a look at a better way in the upcoming chapter. As a prelude to
    [Chapter 3](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml), *APIs and Intent-Driven
    Networking*, let's discuss the idea of idempotency.
  prefs: []
  type: TYPE_NORMAL
- en: Idempotent network device interaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **idempotency** has different meanings, depending on its context. But
    in this book's context, the term means that when a client makes the same call
    to a remote device, the result should always be the same. I believe we can all
    agree that this is necessary. Imagine a scenario where each time you execute the
    same script, you get a different result back. I find that scenario very scary.
    How can you trust your script if that is the case? It would render our automation
    effort useless because we need to be prepared to handle different returns.
  prefs: []
  type: TYPE_NORMAL
- en: Since Pexpect and Paramiko are blasting out a series of commands interactively,
    the chance of having a non-idempotent interaction is higher. Going back to the
    fact that the return results needed to be screen scraped for useful elements,
    the risk of difference is much higher. Something on the remote end might have
    changed between the time we wrote the script and the time when the script is executed
    for the 100th time. For example, if the vendor makes a screen output change between
    releases without us updating the script, the script might break.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to rely on the script for production, we need the script to be idempotent
    as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Bad automation speeds bad things up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bad automation allows you to poke yourself in the eye a lot faster, it is as
    simple as that. Computers are much faster at executing tasks than us human engineers.
    If we had the same set of operating procedures executed by a human versus a script,
    the script would finish faster than humans, sometimes without the benefit of having
    a solid feedback loop between procedures. The internet is full of horror stories
    of when someone pressed the *Enter* key and immediately regretted it.
  prefs: []
  type: TYPE_NORMAL
- en: We need to make sure the chances of bad automation scripts screwing things up
    are as small as possible. We all make mistakes; carefully test your script before
    any production work and small blast radius are two keys to making sure you can
    catch your mistake before it comes back and bites you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered low-level ways to communicate directly with network
    devices. Without a way to programmatically communicate and make changes to network
    devices, there is no automation. We looked at two libraries in Python that allow
    us to manage devices that were meant to be managed by the CLI. Although useful,
    it is easy to see how the process can be somewhat fragile. This is mostly due
    to the fact that the network gears in question were meant to be managed by human
    beings and not computers.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml), *APIs and Intent-Driven
    Networking*, we will look at network devices supporting API and intent-driven
    networking.
  prefs: []
  type: TYPE_NORMAL
