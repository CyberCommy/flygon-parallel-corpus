- en: '*Chapter 18*:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a developer (or software engineer), you must have skills in the testing field
    as well. For example, developers are responsible for writing the unit tests of
    their code (for example, using JUnit or TestNG). Most probably, a pull request
    that doesn't contain unit tests as well won't be accepted.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover unit testing interview problems that you may
    encounter if you apply for a position such as developer or software engineer.
    Of course, if you are looking for a tester (manual/automation) position, then
    this chapter may represent just another perspective of testing, so do not expect
    to see questions specific to manual/automation tester positions here. In this
    chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing in a nutshell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions and coding problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The codes used in this chapter can be found on GitHub on: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter18](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter18)'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of testing an application contains several layers of testing. One
    of these layers is the *unit testing* layer.
  prefs: []
  type: TYPE_NORMAL
- en: Mainly, an application is built by small functional parts called units (for
    example, a regular Java method can be considered a unit). Testing the functionality
    and correctness of these units under specific inputs/conditions/constraints is
    called unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: These unit tests are written by developers using the source code and the test
    plan. Ideally, every developer should be capable of writing unit tests that test/validate
    their code. Unit tests should be meaningful and provide accepted code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the unit tests fails, then the developer is responsible for fixing the issues
    and executing the unit tests again. The following diagram depicts this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.1 – Unit testing flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_18.1_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 18.1 – Unit testing flow
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing uses **unit test cases**. A *unit test case* is a pair of input
    data and expected output meant to shape a test for a certain functionality.
  prefs: []
  type: TYPE_NORMAL
- en: If you are in an interview where you are expected to know unit testing, don't
    be surprised if you are asked questions on functional testing and/or integration
    testing. Hence, it is advisable to be prepared with answers to these questions
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional testing** is about testing functional requirements based on the
    given input and a produced output (behavior) that needs to be compared with the
    expected output (behavior). Each functional test uses the functional specification
    to verify the correctness of the component (or a group of components) that represents
    the implementation of that functional requirement. This is explained in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.2 – Functional testing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_18.2_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 18.2 – Functional testing
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of **integration testing** is to find out the defects in the software
    components while they are being integrated in an iteratively incremental manner.
    In other words, the modules that have been unit tested are integrated (grouped
    together or aggregated) and tested by following the integration plan. This has
    been depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.3 – Integration testing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_18.3_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 18.3 – Integration testing
  prefs: []
  type: TYPE_NORMAL
- en: 'A question regarding unit and integration testing that is frequently put to
    interview candidates is about highlighting the main differences between these
    two. The following table will help you prepare an answer to this question:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.4 – Comparison between unit tests and integration tests'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_18.4_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 18.4 – Comparison between unit tests and integration tests
  prefs: []
  type: TYPE_NORMAL
- en: A good tester is capable of stressing and abusing the subject of testing without
    making any kinds of assumptions or constraints regarding the input. This applies
    to unit tests as well. Now that we have touched on unit testing, let's have a
    look at some coding challenges and questions on unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Questions and coding challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll cover 15 questions and coding challenges related to unit
    testing that are very popular in interviews. Let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 1 – AAA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What is AAA in unit testing?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: The **AAA** acronym stands for [**A**]rrange, [**A**]ct, [**A**]ssert,
    and it represents an approach to structuring tests to sustain clean code and readability.
    Today, AAA is a testing pattern that''s almost a standard across the industry.
    The following snippet of code speaks for itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Arrange** section: In this section, we prepare or set up the test. For example,
    in the preceding code, we prepared a stream of integers where the elements are
    1, 2, and 3.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Act** section: In this section, we perform the necessary actions to obtain
    the result of the test. For example, in the preceding code, we sum the elements
    of the stream and store the result in an integer variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Assert** section: In this section, we check whether the unit test''s result
    matches the expected results. This is done via assertions. For example, in the
    preceding code, we checked that the sum of the elements is equal to 6.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find this code in the application called *junit5/ArrangeActAssert*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 2 – FIRST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What is **FIRST** in unit testing?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Good testers use FIRST to avoid many of the pitfalls encountered
    in unit tests. The **FIRST** acronym stands for [**F**]ast, [**I**]solated, [**R**]epeatable,
    [**S**]elf-validating, [**T**]imely. Let''s see what each of them mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fast**: It is advisable to write unit tests that run fast. Fast is an arbitrary
    notion that depends on how many unit tests you have, how often you run them, and
    how long you are willing to wait for them to run. For example, if each unit test
    has an average completion time of 200 ms and you run 5,000 unit tests, then you''ll
    wait ~17 minutes. Commonly, unit tests are slow because they access external resources
    (for example, databases and files).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Isolated**: Ideally, you should be able to run any test at any time, in any
    order. This is possible if your unit tests are isolated and they focus on small
    snippets of code. Good unit tests don''t depend on other unit tests, but this
    is not always achievable. Nevertheless, strive to avoid chains of dependencies
    since they are evil when things go wrong, and you''ll have to debug.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Repeatable**: A unit test should be repeatable. This means that the unit
    test''s assertions should produce the same result every time you run it. In other
    words, the unit tests should not depend on anything that may introduce variable
    results to assertions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Self-validating**: Unit tests should be self-validating. This means that
    you shouldn''t manually verify the results of the tests. This is time-consuming
    and reveals that the assertions are not doing their job. Strive to write assertions
    so that they work as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Timely**: It is important to not postpone writing unit tests. The more you
    postpone, the more defects you''ll face. You''ll find out that you cannot find
    time to come back and write unit tests. Think of what''s happening if we constantly
    postpone taking out the trash. The more we postpone, the harder it will be to
    take it on, and we risk our health. Did I say anything about the smell? So, write
    the unit tests in a timely fashion. This is a good habit!'
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 3 – Test fixtures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What are test fixtures?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: By test fixtures, we mean any test data that lives outside that
    test and is used to set up the application so that it''s in a fixed state. Having
    a fixed state for the application allows the tests to be run against a constant
    and known environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 4 – Exception testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What are the common approaches for testing exceptions in JUnit?'
  prefs: []
  type: TYPE_NORMAL
- en: '`try`/`catch` idiom, the `expected` element of `@Test`, and via the `ExpectedException`
    rule.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `try`/`catch` idiom prevailed in JUnit 3.x and can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since `fail()`throws an `AssertionError`, it cannot be used to test this error
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with JUnit 4, we can use the `expected` element of the `@Test` annotation.
    The value of this element is the type of the expected exception (subclasses of
    `Throwable`). Check out the following example, which was written using `expected`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This approach is alright as long as you don't want to test the value of the
    exception message. Moreover, pay attention that the test passes if a `NoSuchElementException`
    is thrown by any line of code. You may expect this exception to be caused by a
    particular line of code, while it can, in fact, be caused by other code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach relies on the `ExpectedException` rule. This approach was
    deprecated starting with JUnit 4.13\. Let''s take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Via this approach, you can test the value of the exception message. These examples
    have been grouped into an application called *junit4/TestingExceptions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with JUnit5, there are two approaches we can use to test exceptions.
    Both of them rely on the `assertThrows()` method. This method allows us to assert
    that a given function call (passed in as a lambda expression or even as a method
    reference) results in the expected type of exception being thrown. The following
    example speaks for itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This example just validates the type of exception. However, since the exception
    has been thrown, we can assert more details of the thrown exception. For example,
    we can assert the value of the exception message as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Simply use the `ex` object to assert anything you consider useful from `Throwable`.
    Whenever you don't need to assert details about the exception, rely on `assertThrows()`,
    without capturing the return. These two examples have been grouped into an application
    called *junit5/TestingExceptions*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 5 – Developer or tester
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Who should use JUnit – the developer or the tester?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Commonly, JUnit is used by developers for writing unit tests
    in Java. Writing unit tests is a coding process that tests the application code.
    JUnit is not a testing process. However, many testers are open to learn and use
    JUnit for unit testing.'
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 6 – JUnit extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What useful JUnit extensions do you know/use?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: The most widely used JUnit extensions are JWebUnit (a Java-based
    testing framework for web applications), XMLUnit (a single JUnit extension class
    for testing XML), Cactus (a simple testing framework for testing server-side Java
    code), and MockObject (a mocking framework). You will need to say a few words
    about each of these.'
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 7 – @Before* and @After* annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`@Before*`/`@After*` annotation do you know about/use?'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Before`, `@BeforeClass`, `@After`, and `@AfterClass`.'
  prefs: []
  type: TYPE_NORMAL
- en: When executing a method before each test, we annotate it with the `@Before`
    annotation. This is useful for executing a common snippet of code before running
    a test (for example, we may need to perform some reinitializations before each
    test). To clean up the stage after each test, we annotate a method with the `@After`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: When executing a method only once before all tests, we annotate it with the
    `@BeforeClass` annotation. The method must be `static`. This is useful for global
    and expensive settings, such as opening a connection to a database. To clean up
    the stage after all the tests are done, we annotate a `static` method with the
    `@AfterClass` annotation; for example, closing a database connection.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a simple example under the name *junit4/BeforeAfterAnnotations*.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with JUnit5, we have `@BeforeEach` as the equivalent of `@Before` and
    `@BeforeAll` as the equivalent of `@BeforeClass`. Practically, `@Before` and `@BeforeClass`
    were renamed with more suggestive names to avoid confusion.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a simple example of this under the name *junit5/BeforeAfterAnnotations*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 8 – Mocking and stubbing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What is mocking and stubbing?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Mocking is a technique that''s used to create objects that emulate/mimic
    real objects. These objects can be pre-programmed (or preset or pre-configured)
    with expectations and we can check whether they have been called. Among the most
    widely used mocking frameworks available, we have Mockito and EasyMock.'
  prefs: []
  type: TYPE_NORMAL
- en: Stubbing is like mocking, except that we cannot check whether they have been
    called. Stubs are pre-configured to respond to particular inputs with particular
    outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 9 – Test suite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What is a test suite?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: A test suite is the concept of aggregating multiple tests divided
    among multiple test classes and packages so that they run together.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In JUnit4, we can define a test suite via the `org.junit.runners.Suite` runner
    and the `@SuiteClasses(...)` annotation. For example, the following snippet of
    code is a test suite that aggregates three tests (`TestConnect.class`, `TestHeartbeat.class`,
    and `TestDisconnect.class`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The complete code is called *junit4/TestSuite*.
  prefs: []
  type: TYPE_NORMAL
- en: In JUnit5, we can define a test suite via the `@SelectPackages` and `@SelectClasses`
    annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@SelectPackages` annotation is useful for aggregating tests from different
    packages. All we have to do is specify the names of the packages, as shown in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@SelectClasses` annotation is useful for aggregating tests via the names
    of their classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The complete code is called *junit5/TestSuite*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, filtering test packages, test classes, and test methods can be
    done via the following annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Filter packages: `@IncludePackages` and `@ExcludePackages`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Filter test classes: `@IncludeClassNamePatterns` and `@ExcludeClassNamePatterns`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Filter test methods: `@IncludeTags` and `@ExcludeTags`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding challenge 10 – Ignoring test methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: How can we ignore a test?'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Ignore` annotation. In JUnit5, we can do the same thing via the `@Disable`
    annotation.'
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring test methods can be useful when we have written some tests in advance
    and we want to run the current tests without running these particular tests.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 11 – Assumptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What are assumptions?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Assumptions are used to execute tests if the specified conditions
    have been met. They are commonly used to handle external conditions that are required
    for the test to execute properly, but that are not under our control and/or are
    not directly related to what is being tested.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In JUnit4, assumptions are `static` methods that can be found in the `org.junit.Assume`
    package. Among these assumptions, we have `assumeThat()`, `assumeTrue()`, and
    `assumeFalse()`. The following snippet of code exemplifies the usage of `assumeThat()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If `assumeThat()` doesn't meet the given condition, then the test is skipped.
    The complete application is called *junit4/Assumptions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JUnit5, assumptions are `static` methods that can be found in the `org.junit.jupiter.api.Assumptions`
    package. Among these assumptions, we have `assumeThat()`, `assumeTrue()`, and
    `assumeFalse()`. All three come in different flavors. The following snippet of
    code exemplifies the usage of `assumeThat()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the test method (`assertThat()`) will only execute if the assumption
    is met. Everything after the lambda will be executed, irrespective of the assumption's
    validity. The complete application is called *junit5/Assumptions*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 12 – @Rule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`@Rule`?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: JUnit provides a high degree of flexibility via so-called *rules*.
    Rules allows us to create and isolate objects (code) and reuse this code in multiple
    test classes. Mainly, we enhance tests with reusable rules. JUnit comes with built-in
    rules and with an API that can be used to write custom rules.'
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 13 – Method test return type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`void` from a JUnit test method?'
  prefs: []
  type: TYPE_NORMAL
- en: '`void` to something else, but JUnit will not recognize it as a test method,
    so it will be ignored during the test''s execution.'
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 14 – Dynamic tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Can we write dynamic tests (tests generated at runtime) in JUnit?'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Test` were static tests that were fully defined at compile time. JUnit5 introduced
    dynamic tests – a dynamic test is generated at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic tests are generated via a factory method, which is a method annotated
    with the `@TestFactory` annotation. Such a method can return `Iterator`, `Iterable`,
    `Collection`, or `Stream` of `DynamicTest` instances. A factory method is not
    annotated with `@Test`, and is not `private` or `static`. Moreover, dynamic tests
    cannot take advantage of life cycle callbacks (for example, `@BeforeEach` and
    `@AfterEach` are ignored).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s point out the main lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@TestFactory` annotation to instruct JUnit5 that this is a factory method
    for dynamic tests.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream<DynamicTest>`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**4**: The input for our tests is a list of integers. For each integer, we
    generate a dynamic test.'
  prefs: []
  type: TYPE_NORMAL
- en: '`List<DynamicTest>`. In this list, we add each generated test.'
  prefs: []
  type: TYPE_NORMAL
- en: '**8-12**: We generate a test for each integer. Each test has a name and a lambda
    expression containing the requisite assertion(s).'
  prefs: []
  type: TYPE_NORMAL
- en: '**13**: We store the generated test in the proper list.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream` of tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Running this test factory will produce five tests. The complete example is called
    *junit5/TestFactory*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 15 – Nested tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Can we write nested tests in JUnit5?'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Nested` annotation. Practically, we create a nested test class hierarchy.
    This hierarchy may contain the setup, teardown, and test methods. Nevertheless,
    there are some rules that we must respect, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Nested test classes are annotated with the `@Nested` annotation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested test classes are non-`static` inner classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A nested test class can contain one `@BeforeEach` method, one `@AfterEach` method,
    and test methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `static` members are not allowed in inner classes, which means that the
    `@BeforeAll` and `@AfterAll` methods cannot be used in nested tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The depth of the class hierarchy is unlimited.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some sample code for a nested test can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The complete example is called *junit5/NestedTests*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered several hot questions and coding challenges about
    unit testing via JUnit4 and JUnit5\. It is important to not neglect this topic.
    Most likely, in the last part of an interview for a Java developer or software
    engineer position, you'll get several questions related to testing. Moreover,
    those questions will be related to unit testing and JUnit.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss scaling and scaling-related interview questions.
  prefs: []
  type: TYPE_NORMAL
