- en: Chapter 5. Container Linking and Docker DNS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Verifying a host-based DNS configuration inside a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding the default name resolution settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring links for name and service resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging Docker DNS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Docker DNS aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’ve made a point in earlier chapters to point out that Docker does a lot of
    things for you in the network space. As we’ve already seen, having Docker manage
    IP allocations through IPAM is a huge benefit that’s not inherently obvious when
    you start using Docker. Another thing that Docker provides for you is DNS resolution.
    As we’ll see in this chapter, there are multiple levels of name and service resolution
    that Docker can provide. As Docker has matured, so have the options to provide
    these types of services. In this chapter, we’ll start to review basic name resolution
    and how a container knows which DNS server to use. We’ll then cover container
    linking and see how Docker can tell containers about other containers and the
    services they host. Finally, we’ll walk through some of the DNS enhancements that
    came along with the addition of user-defined networks.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying a host-based DNS configuration inside a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might not realize it but Docker, by default, is providing your containers
    a means to do basic name resolution. Docker passes name resolution options from
    the Docker host, directly into the container. The result is that a spawned container
    can natively resolve anything that the Docker host itself can. The mechanics used
    by Docker to achieve name resolution in a container are elegantly simple. In this
    recipe, we’ll walk through how this is done and how you can verify that it’s working
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll be demonstrating the configuration on a single Docker
    host. It is assumed that this host has Docker installed and that Docker is in
    its default configuration. We’ll be altering name resolution settings on the host,
    so you’ll need root-level access.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start a new container on our host `docker1` and examine how the container
    handles name resolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It would appear that the container has the ability to resolve DNS names. If
    we look at our local Docker host and run the same test, we should get similar
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, just like our Docker host, the container can also resolve local
    DNS records associated with the local domain `lab.lab`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You’ll notice that I didn’t need to specify a fully qualified domain name in
    order to resolve the host name `docker4` in the domain `lab.lab`. At this point,
    it’s safe to assume that the container is receiving some sort of intelligent update
    from the Docker host that provides it relevant information about the local DNS
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `resolv.conf` file is generally where you define a Linux system’s
    name resolution parameters. In many cases, it is altered automatically by configuration
    information from other places. However, regardless of how it’s altered, it should
    always be the source of truth for how the system handles name resolution.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what the container is receiving, let’s examine the container’s `resolv.conf`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the container has learned that the local DNS server is `10.20.30.13`
    and that the local DNS search domain is `lab.lab`. Where did it get this information?
    The solution is rather simple. When a container starts, Docker generates instances
    of the following three files for each container spawned and saves it with the
    container configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/etc/hostname`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/hosts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/resolv.conf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These files are stored as part of the container configuration and then mounted
    into the container. We can use the `findmnt` tool from within the container to
    examine the source of the mounts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So while the container thinks that it has local copies of the `hostname`, `hosts`,
    and `resolv.conf` file in its `/etc/` directory, the real files are actually located
    in the container's configuration directory (`/var/lib/docker/containers/`) on
    the Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you tell Docker to run a container, it does the following three things:'
  prefs: []
  type: TYPE_NORMAL
- en: It examines the Docker host’s `/etc/resolv.conf` file and places a copy of it
    in the containers directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It creates a `hostname` file in the container’s directory and assigns the container
    a unique `hostname`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It creates a `hosts` file in the container's directory and adds relevant records
    including localhost and a record referencing the host itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each time the container is restarted, the container’s `resolv.conf` file is
    updated based on the values found in the Docker host’s `resolv.conf` file. This
    means that any changes made to the `resolv.conf` file are lost each time the container
    is restarted. The `hostname` and `hosts` configuration files are also rewritten
    each time the container is restarted losing any changes made during the previous
    run.
  prefs: []
  type: TYPE_NORMAL
- en: 'To validate the configuration files a given container is using, we can inspect
    the container''s configuration for these variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As expected, these are the same mount paths we saw when we ran the `findmnt`
    command from within the container itself. These represent the exact mount path
    for each file into the containers `/etc/` directory for each respective file.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the default name resolution settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The method Docker uses to provide name resolution to containers works very well
    in most cases. However, there could be some instances where you want Docker to
    provide the containers with a DNS server other than the one the Docker host is
    configured to use. In these cases, Docker offers you a couple of options. You
    can tell the Docker service to provide a different DNS server for all the containers
    the service spawns. You can also manually override this setting at container runtime
    by providing a DNS server as an option to the `docker run` subcommand. In this
    recipe, we’ll show you your options for changing the default name resolution behavior
    as well as how to verify the settings worked.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll be demonstrating the configuration on a single Docker
    host. It is assumed that this host has Docker installed and that Docker is in
    its default configuration. We’ll be altering name resolution settings on the host,
    so you’ll need root-level access.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in the first recipe in this chapter, by default, Docker provides containers
    with the DNS server that the Docker host itself uses. This comes in the form of
    copying the host’s `resolv.conf` file and providing it to each spawned container.
    Along with the name server setting, this file also includes definitions for DNS
    search domains. Both of these options can be configured at the service level to
    cover any spawned containers as well as at the individual level.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purpose of comparison, let’s start by examining the Docker host’s DNS
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With this configuration, we would expect that any container spawned on this
    host would receive the same name server and DNS search domain. Let’s spawn a container
    named `web8` to verify that this is working as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the container receives the same configuration. Let’s now inspect
    the container and see if we see any DNS-related options defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Because we’re using the default configuration, there is no reason to configure
    anything specific within the container in regard to DNS server or search domain.
    Each time the container starts, Docker will apply the settings for the host’s
    `resolv.conf` file to the container's DNS configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we’d prefer to have Docker give containers a different DNS server or DNS
    search domain, we can do so through Docker options. In this case, the two we’re
    interested in are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--dns=<DNS Server>`: Specify a DNS server address that Docker should provide
    to the containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--dns-search=<DNS Search Domain>`: Specify a DNS search domain that Docker
    should provide to the containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s configure Docker to provide containers with a public DNS server (`4.2.2.2`)
    and a search domain of `lab.external`. We can do so by passing the following options
    to the Docker systemd drop-in file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the options are configured, reload the systemd configuration, restart
    the service to load the new options, and restart our container `web8`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You’ll note that, despite this container initially having the host's DNS server
    (`10.20.30.13`) and search domain (`lab.lab`), it now has the service-level DNS
    options we just specified. If you recall earlier, we saw that, when we inspected
    this container, it didn’t define a specific DNS server or search domain. Since
    none was specified, Docker now uses the settings from the Docker options that
    take priority. Although this provides some level of flexibility, it’s not yet
    truly flexible. At this point, any and all containers spawned on this server will
    be provided with the same DNS server and search domain. To be truly flexible,
    we should be able to have Docker alter the name resolution configuration on a
    per container level. As luck would have it, these options can also be provided
    directly at container runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](graphics/B05453_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding figure defines the priority Docker uses when deciding what name
    resolution settings to apply to a container when it’s started. As we’ve seen in
    earlier chapters, settings defined at container runtime always take priority.
    If the settings aren’t defined there, Docker then looks to see if they are configured
    at the service level. If the settings aren’t there, it falls back to the default
    method of relying on the Docker host’s DNS settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can launch a container named `web2` and provide different
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we inspect the container, we’ll see that we now have the `dns` and `dns-search`
    fields defined as part of the container configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This ensures that, if the container is restarted, it will still have the same
    DNS settings that were initially provided the first time the container was run.
    Let’s make some slight changes to the Docker service to verify the priority is
    working as expected. Let’s change our Docker options to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now restart the service and run the following container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Because we didn’t provide any DNS-related options at container runtime, the
    next place we’d check would be the service-level options. Our Docker service-level
    options include a DNS search domain of `lab.external`. We’d expect the container
    to receive that search domain. However, since we don’t have a DNS server defined,
    we’ll need to fall back to the one configured on the Docker host itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now examine its `resolv.conf` file to make sure things worked as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Configuring links for name and service resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Container linking provides a means for one container to easily communicate with
    another container on the same host. As we’ve seen in previous examples, most container-to-container
    communication has occurred through IP addresses. Container linking improves on
    this by allowing linked containers to communicate with each other by name. In
    addition to providing basic name resolution, it also provides a means to see what
    services a linked container is providing. In this recipe, we’ll review how to
    create container links as well as discuss some of their limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll be demonstrating the configuration on a single Docker
    host. It is assumed that this host has Docker installed and that Docker is in
    its default configuration. We’ll be altering name resolution settings on the host,
    so you’ll need root-level access.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The phrase *container linking* might imply to some that it involves some kind
    of network configuration or modification. In reality, container linking has very
    little to do with container networking. In the default mode, container linking
    provides a means for one container to resolve the name of another. For instance,
    let’s start two containers on our lab host `docker1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how, when I started the second container, I used a new flag named `--link`
    and referenced the container `web1`. We would now say that `web2` was linked to
    `web1`. However, they’re not really linked in any sort of way. A better description
    might be to say that `web2` is now aware of `web1`. Let’s connect to the container
    `web2` to show you what I mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It appears that the `web2` container is now able to resolve the container `web1`
    by name. This is because the linking process inserted records into the `web2`
    container''s `hosts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With this configuration, the `web2` container can reach the `web1` container
    either by the name we gave the container at runtime (`web1`) or the unique `hostname`
    Docker generated for the container (`88f9c8629668`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the `hosts` file being updated, `web2` also generates some new
    environmental variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll notice many new environmental variables. Docker will copy any environmental
    variables from the linked container that were defined as part of the container.
    This includes:'
  prefs: []
  type: TYPE_NORMAL
- en: Environmental variables described in the Docker image. More specifically, any
    `ENV` variables from the images Dockerfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environmental variables passed to the container at runtime through the `--env`
    or `-e` flag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, these three variables were defined as `ENV` variables in the
    image''s Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Because both container images have the same `ENV` variables defined, we’ll
    see the local variables as well as the same environmental variables from the container
    `web1` prefixed with `WEB1_ENV_`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, Docker also created six other environmental variables that describe
    the `web1` container as well as any of its exposed ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Linking also allows you to specify aliases. For instance, let’s stop, remove,
    and respawn container `web2` using a slightly different syntax for linking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, after the link definition, we inserted `a :webserver.` The name
    after the colon represents the alias for the link. In this case, I’ve specified
    an alias for the container `web1` as `webserver`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we examine the `web2` container, we’ll see that the alias is now also listed
    in the `hosts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Aliases also impact the environmental variables created during linking. Rather
    than using the container name, they’ll instead use the alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you might be wondering how dynamic this is. After all, Docker
    is providing this functionality by updating static files in each container. What
    happens if a container’s IP address changes? For instance, let’s stop the container
    `web1` and start a new container named `web3` using the same image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’ll recall from earlier, the container `web1` had an IP address of `172.17.0.2`
    allocated to it. Since I stopped the container, Docker will release that IP address
    reservation making it available to be reassigned to the next container we start.
    Let’s check the IP address assigned to the container `web3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, `web3` took the now open IP address of `172.17.0.2` that previously
    belonged to the `web1` container. We can also verify that the container `web2`
    still believes that this IP address belongs to the `web1` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we start the container `web1` once again, we should see that it will get
    a new IP address allocated to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we check the container `web2` again, we should see that Docker has updated
    it to reference the `web1` container’s new IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'However, while Docker takes care of updating the `hosts` file with the new
    IP address, it will not take care of updating any of the environmental variables
    to reflect the new IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, it should be pointed out that the link is only one way. That is,
    this link does not cause the container `web1` to become aware of the `web2` container.
    `Web1` will not receive the host records or the environmental variables referencing
    the `web2` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Another reason to provision links is when you use Docker **Inter-Container
    Connectivity** (**ICC**) mode set to `false`. As we’ve discussed previously, ICC
    prevents any containers on the same bridge from talking directly to each other.
    This forces them to talk to each other only though published ports. Linking provides
    a mechanism to override the default ICC rules. To demonstrate, let’s stop and
    remove all the containers on our host `docker1` and then add the following Docker
    option to the systemd drop-in file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now reload the systemd configuration, restart the service, and start the following
    containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'With ICC mode on, you’ll notice that containers can’t talk directly to each
    other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, `web2` is not able to access the web servers on `web1`.
    Now, let’s delete and recreate the `web2` container, this time linking it to `web1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We can see that, with the link in place, the communication is allowed as expected.
    Once again, just like the link, this access is allowed in one direction.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that linking works differently when using user-defined networks.
    In this recipe, we covered what are now being named **legacy links**. Linking
    with user-defined networks will be covered in the next two recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging Docker DNS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The introduction of user-defined networks signaled a big change in Docker networking.
    While the ability to provision custom networks was the big news, there were also
    major enhancements in name resolution. User-defined networks can benefit from
    what’s being named **embedded DNS**. The Docker engine itself now has the ability
    to provide name resolution to all of the containers. This is a marked improvement
    from the legacy solution where the only means for name resolution was external
    DNS or linking, which relied on the `hosts` file. In this recipe, we’ll walk through
    how to use and configure embedded DNS.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll be demonstrating the configuration on a single Docker
    host. It is assumed that this host has Docker installed and that Docker is in
    its default configuration. We’ll be altering name resolution settings on the host,
    so you’ll need root-level access.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned, the embedded DNS system only works on user-defined Docker networks.
    That being said, let’s provision a user-defined network and then start a simple
    container on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As we saw in an earlier recipe, by default, Docker pulls the name resolution
    configuration from the Docker host and provides it to the container. This behavior
    can be changed by providing different DNS servers or search domains either at
    the service level or at container runtime. In the case of containers connected
    to a user-defined network, the DNS settings provided to the container are slightly
    different. For instance, let’s look at the `resolv.conf` file for the container
    we just connected to the user-defined bridge `mybridge1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the name server for this container is now `127.0.0.11`. This IP address
    represents Docker’s embedded DNS server and will be used for any container, which
    is connected to a user-defined network. It is a requirement that any container
    connected to a user-defined network should use the embedded DNS server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Containers not initially started on a user-defined network will get updated
    the moment they connect to a user-defined network. For instance, let’s start another
    container named `web2` but have it use the default `docker0` bridge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now connect the `web2` container to our user-defined network, Docker
    will update the name server to reflect the embedded DNS server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Since both our containers are now connected to the same user-defined network,
    they can now reach each other by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll note that the name resolution is bidirectional, and it works inherently
    without the use of any links. That being said, with user-defined networks, we
    can still define links for the purpose of creating local aliases. For instance,
    let’s stop and remove both containers `web1` and `web2` and reprovision them as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The first interesting item to point out is that Docker lets us link to a container
    that did not yet exist. When we ran the container `web1`, we asked Docker to link
    it to the container `web2`. At that point, `web2` didn’t exist. This is a notable
    difference in how links work with the embedded DNS server. In legacy linking,
    Docker needed to know the target container information prior to making the link.
    This was because it had to manually update the source container''s host file and
    environmental variables. The second interesting item is that aliases are no longer
    listed in the container''s `hosts` file. If we look at the `hosts` file on each
    container, we’ll see that the linking no longer generates entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the resolution is now occurring in the embedded DNS server. This includes
    keeping track of defined aliases and their scope. So even without host records,
    each container is able to resolve the other containers alias through the embedded
    DNS server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The aliases created have a scope that is local to the container itself. For
    instance, a third container on the same user-defined network is not able to resolve
    the aliases created as part of the links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll recall that legacy linking also automatically created a set of environmental
    variables on the source container. These environmental variables referenced the
    target container and any ports it might be exposing. Linking in user-defined networks
    does not create these environmental variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As we saw in the previous recipe, keeping these variables up to date wasn’t
    achievable even with legacy links. That being said, it’s not a total surprise
    that the functionality doesn’t exist when dealing with user-defined networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to providing local container resolution, the embedded DNS server
    also handles any external requests. As we saw in the preceding example, the search
    domain from the Docker host (`lab.lab` in my case) was still being passed down
    to the containers and configured in their `resolv.conf` file. The name server
    learned from the host becomes a forwarder for the embedded DNS server. This allows
    the embedded DNS server to process any container name resolution requests and
    hand off external requests to the name server used by the Docker host. This behavior
    can be overridden either at the service level or by passing the `--dns` or `--dns-search`
    flag to a container at runtime. For instance, we can start two more instances
    of the `web1` container and specify a specific DNS server in either case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that `web4` would receive `10.20.30.13` as a DNS forwarder even if we didn’t
    specify it explicitly. This is because that’s also the DNS server used by the
    Docker host and when not specified the container inherits from the host. It is
    specified here for the sake of the example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if we try to resolve a local DNS record on either container, we can see
    that in the case of `web1` it works since it has the local DNS server defined,
    whereas the lookup on `web2` fails because `8.8.8.8` doesn’t know about the `lab.lab`
    domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Creating Docker DNS aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before embedded DNS, the only way to alias a container to a different name was
    to use links. As we’ve seen in previous recipes, this is still the method used
    to create localized or container-specific aliases. However, what if you wanted
    to have an alias with a larger scope, one that any container connected to a given
    network could resolve? The embedded DNS server offers what are referred to as
    network-scoped aliases, which are resolvable within a given user-defined network.
    In this recipe, we’ll show you how to create network-scoped aliases within user-defined
    networks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll be demonstrating the configuration on a single Docker
    host. It is assumed that this host has Docker installed and that Docker is in
    its default configuration. We’ll be altering name resolution settings on the host,
    so you’ll need root-level access.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Network aliases can be defined in a couple of different ways. They can be defined
    at container runtime or when you connect a container to a network. Once again,
    network aliases are a feature only provided when a container implements a user-defined
    network. You cannot create a network alias without specifying a user-defined network
    at the same time. Docker will prevent you from specifying them at container runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If we create a user-defined network and specify it as part of the container
    configuration, the command will execute successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the alias is created, we can see it as part of the specific container''s
    configuration. For instance, if we now inspect the container `web1`, we’ll see
    a defined alias under its network configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s start another container named `web2` and see if we can resolve the
    alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of interesting things to point out here. First, this method
    for defining aliases is vastly different than the linking method in more than
    just scope. With links, a source container specified what it wanted a target container
    to be aliases to. In the case of network aliases, a source container sets its
    own alias.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, this only worked because the container `web2` is on the same user-defined
    network as `web1`. Because the alias'' scope is the entire user-defined network,
    this means that the same container could go by different aliases on a different
    user-defined networks. For instance, let’s create another user-defined network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s attach the container `web1` to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that we said you can define network-scoped aliases as part of the `network
    connect` subcommand as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the container `web1` now has two aliases, one on each network. Because
    the container `web2` is only connected to one network, it is still only able to
    resolve the alias associated with the `mybridge1` network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'However, once we connect `web2` to the `mybridge2` network, it is now able
    to resolve both aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, Docker also lets you define the same alias to multiple containers.
    For instance, let’s now start a third container named `web3` and connect it to
    `mybridge1` using the same alias as `web1` (`webserver1`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The alias is now defined for the container `web1` as well as `web2`. However,
    attempts to resolve the alias from `web2` still point to `web1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If we disconnect or stop the container `web1`, we should see that the resolution
    now changes to `web3` since it’s still active on the network and has the same
    alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This functionality can provide you with some interesting options in terms of
    high availability or failover, especially when coupled with the overlay network
    type.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that this functionality works for all user-defined network
    types including the overlay network type. We’ve used bridges in these examples
    to keep the examples simple.
  prefs: []
  type: TYPE_NORMAL
