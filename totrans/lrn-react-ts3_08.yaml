- en: React Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we have managed state within our React components. We've
    also used React context when state needs to be shared between different components.
    This approach works well for many applications. React Redux helps us to robustly
    handle complex state scenarios. It shines when user interactions result in several
    changes to state, perhaps some that are conditional, and particularly when the
    interaction results in web service calls. It's also great when there is lots of
    shared state across the application.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to continue building our React shop in this chapter, adding React
    Redux to help us manage our state interactions. We'll eventually add a basket
    summary component in the header of our shop, which informs the user of how many
    items are in their basket. Redux will help us update this component when items
    are added to the basket.
  prefs: []
  type: TYPE_NORMAL
- en: In the final section of the chapter, we'll explorer a Redux-like method for
    managing complex state within a component. This is a middle ground between managing
    state in a Redux store and just within a component using `setState` or `useState`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Principles and key concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Redux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating reducers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting our React App to the store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing state with useReducer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the following technologies in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node.js and** `npm`: TypeScript and React are dependent on these. We can
    install these from [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
    If we already have these installed, make sure `npm` is at least at version 5.2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Code**: We''ll need an editor to write our React and TypeScript
    code, which can be installed from [https://code.visualstudio.com/](https://code.visualstudio.com/).
    We will also need the TSLint (by egamma) and Prettier (by Estben Petersen) extensions
    installed within Visual Studio Code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**React shop**: We''ll start from the React shop project we finished in the
    last chapter. This is available on GitHub at [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/07-WorkingWithForms/04-FormSubmission](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/07-WorkingWithForms/04-FormSubmission).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to restore code from a previous chapter, the `LearnReact17WithTypeScript` repository
    at [https://github.com/carlrip/LearnReact17WithTypeScript](https://github.com/carlrip/LearnReact17WithTypeScript) can
    be downloaded. The relevant folder can then be opened in Visual Studio Code and
    then `npm install` can be entered in the terminal to do the restore. All the code
    snippets in this chapter can be found online at [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/08-ReactRedux%EF%BB%BF](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/08-ReactRedux%EF%BB%BF).
  prefs: []
  type: TYPE_NORMAL
- en: Principles and key concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll start by going through the three principles in Redux
    and then dive into the core concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the three principles of Redux:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single source of truth**: This means that the whole application state is
    stored in a single object. In a real app, this object is likely to contain a complex
    tree of nested objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State is read-only**: This means that state can''t be directly changed. This
    is a bit like saying we can''t directly change the state within a component. In
    Redux, the only way to change state is to dispatch what''s called an action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Changes are made with pure functions**: The functions that are responsible
    for changing the state are called reducers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we'll dive into actions and reducers a little more
    along with the thing that manages them which is what is called a store.
  prefs: []
  type: TYPE_NORMAL
- en: Key concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The whole state of the application lives inside what is called a **store**.
    The state is stored in a JavaScript object like the one following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the single object contains these:'
  prefs: []
  type: TYPE_NORMAL
- en: An array of products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the products are being fetched from a web API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current product the user is looking at
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The items in the users basket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state won't contain any functions or setters or any getters. It's a simple
    JavaScript object. The store also orchestrates all the moving parts in Redux.
    This includes pushing actions though reducers to update state.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the first thing that needs to happen in order to update state in a store
    is to dispatch an **action**. An action is another simple JavaScript object like
    the one following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `type` property determines the type of action that needs to be performed.
    This is an important and required part of the action. The reducer won't know how
    to change the state without the `type` in the action object. In the previous example,
    the action doesn't contain anything else other than the `type` property. This
    is because the reducer doesn't need any more information in order to make the
    change to state for this type of action.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is another action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This time, an additional bit of information is included in the action in a `product`
    property. This additional information is needed by the reducer to make the change
    to state for this type of action.
  prefs: []
  type: TYPE_NORMAL
- en: So, reducers are pure functions that make the actual state changes.
  prefs: []
  type: TYPE_NORMAL
- en: A pure function always returns the same result for a given set of parameters.
    So, these functions don't depend on any state outside the scope of the function
    that isn't passed into the function. Pure functions also don't change any state outside
    the scope of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is something about reducers:'
  prefs: []
  type: TYPE_NORMAL
- en: Reducers take in two parameters for the current state and the action that is
    being performed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state argument defaults to an initial state object for when the reducer
    is called for the very first time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A switch statement is used on the action type and creates a new state object
    appropriately for each action type in each of its branches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create the new state, we spread the current state into a new object and then
    overwrite it with properties that have changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new state is returned from the reducer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll notice that the actions and reducer we have just seen didn't have TypeScript
    types. Obviously, we'll include the necessary types when we implement these in
    the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we have started to get an understanding of what Redux is, it's
    time to put this into practice in our React shop.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can use Redux, we need to install it along with the TypeScript types.
    We will also install an additional library called `redux-thunk`, which we need
    in order to implement asynchronous actions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we haven''t already, let''s open our React shop project in Visual Studio
    Code from where we left off in the last chapter. So, let''s install the core Redux
    library via `npm` in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that the core Redux library contains TypeScript types within it. So, there
    is no need for an additional install for these.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now install the React-specific bits for Redux. These bits allow us to
    connect our React components to the Redux store. Let''s install these via `npm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also install the TypeScript types for `react-redux`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s install `redux-thunk` as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we can install the TypeScript types for `redux-thunk`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With all the Redux bits now installed, we can add Redux to the React shop we
    have been working on in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to extend the React shop we have been building in previous chapters
    and add Redux to manage the state on the Products page. In this section, we'll
    create actions to start the process of getting the products into the page. There
    will be one action to get the products. There will be another action to change
    some new loading state, which we'll eventually tie to the `withLoading` HOC that
    we already have in our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we make a start on the Redux actions, let''s create a fake API in `ProductsData.ts`
    for fetching products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So, the function asynchronously waits a second before returning the products.
  prefs: []
  type: TYPE_NORMAL
- en: We need to start our action's implementation by creating some types. We'll do
    this next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating state and action types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to finally make a start on enhancing our React shop with Redux.
    We''ll start by creating some types for the state and actions for our Redux store:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new file called `ProductsTypes.ts` in the `src` folder with
    the following import statement at the top:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create an enumeration for the two different action types that we are
    going to implement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Redux doesn''t dictate the format of the action type strings. So, the format
    of the action type strings is our choice. We need to make sure the strings are
    unique though across the actions types in the store. So, we''ve included two bits
    of information in the string:'
  prefs: []
  type: TYPE_NORMAL
- en: The area of the store the action is concerned with. In our case, this is `PRODUCTS`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The specific operation within that area. In our case, we have `GETALL` for getting
    all the products and `LOADING` to indicate products are being fetched.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could have chosen `PRODUCTS`-`GETALL` or `Get All Products`. We just need
    to make sure the strings are unique. We have used an enumeration to give us nice
    IntelliSense when we consume these when implementing the action and reducer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now create interfaces for the two actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `IProductsGetAllAction` interface is for an action that will be dispatched
    when the products need to be fetched. The `IProductsLoadingAction` interface is
    for an action that will cause the reducer to change the loading state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s combine the action types together with a union type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will be the type for the action parameter passed into the reducer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, let''s create an interface for this area of the state in the store:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So, our state will contain an array of products, and whether products are being
    loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the properties are prefixed with the `readonly` keyword. This will
    help us avoid changing the state directly.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have types in place for the actions and state, we can create some
    actions in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to create two actions for getting the products
    and indicating that products are being loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a `ProductsActions.ts` file with the following import
    statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These are a few types from Redux that we are going to use when implementing
    our actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of our actions is going to be asynchronous. So, let''s import a type from
    `redux-thunk` ready for when we implement this action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add another import statement so that we can use our fake API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We've renamed the API function to `getProductsFromAPI` to avoid a name clash
    because we are going to create an action called `getProducts` a little later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also import the types we created in the last section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to create what is called an action creator now. An action creator
    does what it says on the tin: it''s a function that creates and returns an action!
    Let''s create an action creator for creating the product loading action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We use the generic `ActionCreator` type containing the appropriate action interface
    for the function signature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function simply returns the required action object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can write this function more succinctly using an implicit return statement
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We'll use this shorter syntax from now on when implementing action creators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to implementing the action creator for getting products. This
    is more complex, so let''s start with the function signature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We again use the generic `ActionCreator` type, but this time it contains more
    than just the action interface that will eventually be returned. This is because
    this particular action is asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `ThunkAction` inside `ActionCreator` for asynchronous actions, which
    is, in turn, a generic type with four parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is the return type, which should ideally be `Promise<IProductsGetAllAction>`.
    However, the TypeScript compiler struggles to resolve this, so, we have opted
    for the slightly looser `Promise<AnyAction>` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter is the state interface that the action is concerned with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third parameter is the type of parameter passed into the action creator,
    which is `null` in our case because there is no parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last parameter is the type of the action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We export this action creator because this is going to be eventually called
    from the `ProductsPage` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Asynchronous actions need to return an asynchronous function that will eventually
    dispatch our action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So, the first thing that function does is return another function, flagging
    that it is asynchronous, using the `async` keyword. The inner function takes the
    dispatcher from the store as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the inner function then:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is dispatch our other action so that the loading state
    is eventually changed accordingly by the reducer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next step is to get the products asynchronously from the fake API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final step is to dispatch the required action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have created a couple of actions, we'll create a reducer in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating reducers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A reducer is a function that is responsible for creating new state for a given
    action. So, the function takes in an action with the current state and returns
    the new state. In this section, we'll create a reducer for the two actions we
    have created on products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a file called `ProductsReducer.ts` with the following
    import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We are importing the `Reducer` type from Redux along with types for the actions
    and state we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to define what the initial state is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: So, we are setting the products to an empty array and product loading state
    to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now start to create the reducer function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We've typed the function with the `Reducer` generic type from Redux, passing
    in our state and action types. This gives us a nice level of type safety.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function takes in parameters for the state and action as required by Redux.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state defaults to the initial state object we just set in the previous step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of the function, we return the default state if the action type is
    not recognized by the switch statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s carry on implementing our reducer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We have implemented a switch branch for each action. Both branches follow the
    same pattern by returning a new state object that has the old state spread into
    it and the appropriate properties merged over the top.
  prefs: []
  type: TYPE_NORMAL
- en: So, that's our first reducer complete. In the next section, we'll create our
    store.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll create a store that is going to hold our state and
    manage the actions and reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start off by creating a new file called `Store.tsx` with the following
    import statement to get the bits and pieces we need from Redux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`createStore` is a function we''ll eventually use to create our store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need the `applyMiddleware` function because we need to use the Redux Thunk
    middleware to manage our asynchronous actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `combineReducers` function is a function we can use to merge our reducers
    together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Store` is a TypeScript type we can use for the store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s import `redux-thunk`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s import our reducer and state type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'A key part of the store is the state. So, let''s define an interface for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the interface simply contains our products state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put our reducer in the Redux `combineReducer` function now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'With the state and root reducer defined, we can create our store. We are actually
    going to create a function that creates the store:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The function that creates our store is called `configureStore` and returns the
    generic `Store` type with our specific store state passed in to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function uses the Redux `createStore` function to create and return the
    store. We pass in our reducer as well as the Redux Thunk middleware. We pass `undefined`
    as the initial state because our reducer takes care of the initial state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've made a great start on our store. In the next section, we'll start to connect
    our React shop to our store.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting our React app to the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll connect the `Products` page to our store. The first job
    is to add the React Redux `Provider` component which we'll do in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the store Provider component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Provider` component can pass the store to components beneath it at any
    level. So, in this section we are going to add `Provider` right at the top of
    our component hierarchy so that all our components can access it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open our existing `index.tsx` and import the `Provider` component from
    React Redux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also import the `Store` type from React Redux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The final thing we need to import is the following from our store:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We are then going to create a little function component after the import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This `Root` component is going to be our new root element. It takes our store
    in as a prop.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we need to include the old root element, `Routes`, in our new root component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s one more thing to add to this component, which is the `Provider` component
    from React Redux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We've placed `Provider` at the top of the component tree with our store passed
    into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our new root component complete, let''s change our root render function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We first create the store using our `configureStore` function and then pass
    this into our `Root` component.
  prefs: []
  type: TYPE_NORMAL
- en: So, this is the first step in connecting our components to the store. In the
    next section, we'll complete this connection for our `ProductPage` component.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting components to the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are getting close to seeing our enhanced shop in action. In this section,
    we will connect our store to several components.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting ProductsPage to the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first component we are going to connect to the store is going to be the
    `ProductsPage` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up `ProductsPage.tsx` and start to refactor it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s import the `connect` function from React Redux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We'll use the `connect` function at the end of this section to connect the `ProductsPage`
    component to the store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s import the store state type and the `getProducts` action creator from
    our store:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ProductPage` component won''t contain any state now because this will
    be held in the Redux store. So, let''s start by removing the state interface,
    the static `getDerivedStateFromProps` method, as well as the constructor. The
    `ProductsPage` component should now have the following shape:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The data is going to come from the store via props now. So, let''s refactor
    our props interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we''ll get the following data passed from the store to our component:'
  prefs: []
  type: TYPE_NORMAL
- en: The `getProducts` action creator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A flag called `loading` that indicates whether products are being fetched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The array of products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, let''s adjust the `componentDidMount` life cycle method to invoke the `getProducts`
    action creator to start the process of products being fetched:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We no longer reference the `products` array directly from `ProductsData.ts`.
    So, let''s remove that from the input statement so that it looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'There is still no sign of the `search` state we used to have. We are just going
    to pick this up at the start of the `render` method now and not store it in state
    at all:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s stay in the `render` method and replace the old `state` references:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the class, but before the export statement, let''s create a function
    that will map the state coming from the store to the component props:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: So, we are getting whether products are being loaded as well as the products
    from the store and passing these to our props.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more prop we need to map to and that is the `getProducts` function
    prop. Let''s create another function that will map this action from the store
    to this function prop in the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s one more job to do at the bottom of the file. This is to wrap the
    React Redux `connect` HOC around our `ProductsPage` component before it is exported:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `connect` HOC connects the component to our store, which is provided to
    us by the `Provider` component higher up in the component tree. The `connect`
    HOC also invokes the mapper functions that map the state and action creators from
    the store into the component props.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s finally time to give our enhanced page a try. Let''s start the dev server
    and the app via the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We should find the page behaves exactly the same as it did before. The only
    difference is now the state is being managed in our Redux store.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going enhance our Products page by adding the loading
    spinner we already have in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting ProductsPage to the loading store state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to add a loading spinner to the Products page. Before
    we can do this, we are going to extract the list of products out into its own
    component. We can then add the `withLoader` HOC to the extracted component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new file for the extracted component called `ProductsList.tsx`
    with the following imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The component will take in props for the products array and the search string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll call the component `ProductList` and it will be an SFC. Let''s start
    to create the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now move the `ul` tag from the `ProductsPage` component JSX into our
    return statement in our new `ProductList` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note that we remove references to `this` after moving the JSX.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish off the `ProductList` component, let''s export it wrapped with our
    `withLoader` HOC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s change the return statement in `ProductPage.tsx` to reference the extracted
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We mustn''t forget to import the `ProductsList` component having referenced
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can remove the imported `Link` component in `ProductsPage.tsx` as
    this is no longer referenced.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we go to the running app and browse to the Products page, we should now
    see a loading spinner while the products load:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/85661d16-f25f-49f0-a37c-ba5ffde733ba.png)'
  prefs: []
  type: TYPE_IMG
- en: So, our Products page is nicely wired up to our Redux store now. In the next
    section, we'll wire up the Product page to the store.
  prefs: []
  type: TYPE_NORMAL
- en: Adding product state and actions to the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Connecting the `ProductPage` component to our store is first going to require
    a little work in our store. We need additional state for the current product,
    as well as whether it has been added to the basket. We also need additional actions
    and reducer code to get a product and add it to the basket:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add additional state for the current product in `ProductsTypes.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'While we are in `ProductTypes.ts`, let''s add the action type for getting a
    product:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also add the action type for getting a product:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add this action type to our union actions type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s move on to creating the new action creator in `ProductsActions.ts`.
    First, let''s import our fake API to get a product:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then import the type for the action creator we need to implement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement the action creator for getting a product:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This is very similar to the `getProducts` action creator. The only difference
    in structure is that the action creator takes in a parameter for the product ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Move on to the reducer now in `ProductsReducer.ts`. Let''s first set the current
    product to null in the initial state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `productReducer` function, let''s add a branch in the switch statement
    for our new action type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We spread the old state into a new object, overwrite the current project, and
    set the loading state to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: So, that's some of the state management that the Product page needs in the Redux
    store. However, we aren't managing the basket yet in our store. We'll do this
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding basket state and actions to the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll add state management for our basket in this section. We'll create a new
    section in our store for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a new file for the types called `BasketTypes.ts` with
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: There is only one piece of state in our basket and that's an array of products
    in the basket.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is only one action as well. This is to add a product to the basket.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a file called `BasketActions.ts` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This is the action creator for adding to the basket. The function takes in a
    product and returns it in the action with the appropriate action type.
  prefs: []
  type: TYPE_NORMAL
- en: 'On to the reducer now. Let''s create a file called `BasketReducer.ts` with
    the following import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create an object for the initial basket state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the reducer now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This follows the same pattern as `productsReducer`.
  prefs: []
  type: TYPE_NORMAL
- en: One interesting point to note is how we elegantly add the `product` to the `products`
    array without mutating the original array. We use the JavaScript `concat` function,
    which creates a new array by merging the original with the parameter passed in.
    This is a great function to use in reducers where state changes involve adding
    items to arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up `Store.ts` now and import the new reducer and state for the
    basket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the basket state to the store:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two reducers now. So, let''s add the basket reducer to the `combineReducers`
    function call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've adjusted our store, we can connect our `ProductPage` component
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting ProductPage to the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll connect the `ProductPage` component to our store:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first import the following into `ProductPage.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to reference the store''s `getProduct` now and not the one from
    `ProductsData.ts`. So, let''s remove this from this import so that it looks like
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s move the state into props:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: So, the `IState` interface and the `Props` type should be removed after this
    movement.
  prefs: []
  type: TYPE_NORMAL
- en: We can remove the constructor as we don't need to initialize any state now.
    This is all done in the store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s change the `componentDidMount` life cycle method to call the action
    creator for getting the product:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we also remove the `async` keyword because the method is no longer
    asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on to the `render` function, let''s replace the references to state
    with references to props:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the click handler now and refactor it to call the action creator
    for adding to the basket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'On to the final few steps now in the connection process. Let''s implement the
    function that maps the action creators from the store into the component props:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Mapping the state to the component props is a little more complex. Let''s start
    with the simple mappings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Note that we map a null `currentProduct` to `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining prop we need to map to is `added`. We need to check whether the
    current product in the store is in the basket state in order to set this `boolean`
    value. We can use the `some` function in the products array for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to use the `connect` HOC from React Redux to wire the `ProductPage`
    component to the store:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: We can now go to the running app, visit the product page, and add it to the
    basket. The Add to basket button should disappear after it is clicked. If we browse
    to a different product and then come back to a product we've already added to
    the basket, the Add to basket button shouldn't be present.
  prefs: []
  type: TYPE_NORMAL
- en: So, we now have both the Products and Product pages connected to our Redux store.
    In the next section, we'll create a basket summary component and connect that
    to the store.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and connecting BasketSummary to the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll create a new component called `BasketSummary`. This
    will show the number of items in the basket and will be located in the top right
    of our shop. The following screenshot shows what the basket summary will look
    like in the top right of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a46b9de9-0cd5-4ef5-aa49-42bd4cb7ebde.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s create a file called `BasketSummary.tsx` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple component that takes in the number of products in the basket
    as a prop and displays this value in a `div` styled with a `basket-summary` CSS
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the CSS class we have just referenced in `index.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to add our basket summary to our header component. So, let''s
    import it into `Header.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also import the `connect` function from React Redux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s import the state type for our store as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a prop for the number of products in the basket to the `Header` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: We're going to keep the search state local in this component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the `BasketSummary` component to the `Header` component JSX now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to map the number of products in the store basket to the `basketCount`
    prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we can connect the `Header` component to the store:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Now that the `Header` component is consuming the `BasketSummary` component and
    is also connected to the store, we should be able to add products to the basket
    in the running app and see the basket summary increase.
  prefs: []
  type: TYPE_NORMAL
- en: So, that completes this section on connecting components to the store. We have
    connected a few different components to the store, so hopefully this process is
    making good sense now.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll explore a Redux-like approach for managing state
    within a component.
  prefs: []
  type: TYPE_NORMAL
- en: Managing state with useReducer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redux is great for managing complex state across our app. It is a little heavy
    though if the state we are managing only exists within a single component. Obviously,
    we can manage these cases with `setState` (for class components) or `useState`
    (for function components). However, what if the state is complex? There may be
    lots of pieces of state and the state interactions may involve lots of steps with
    some of them being asynchronous. In this section, we'll explore an approach for
    managing these cases with the `useReducer` function in React. Our example will
    be contrived and simple but it will give us an understanding of this approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to add a Like button to the Product page in our React shop. Users
    will be able to like a product several times. The `Product` component will keep
    track of the number of likes and the date and time of the last like in its state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0a921b6d-3941-43a9-b25c-d14769e8a086.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll start by opening `Product.tsx` and creating an interface, before the
    `Product` component, for our state, containing the number of likes and the date
    of the last like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll create a variable to hold the initial state, also outside of `Product`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now create a type for the action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also create a union type containing all the action types. In our example,
    we only have one action type but let''s do this to understand an approach that
    scales:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Product` component, let''s call the `useReducer` function in React
    to get our state and `dispatch` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break this down:'
  prefs: []
  type: TYPE_NORMAL
- en: We pass into `useReducer` a function called `reducer` (which we haven't created
    yet).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also pass into `useReducer` our initial state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useReducer` returns an array containing two elements. The first element is
    the current state and the second is a `dispatch` function to invoke an action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s refactor this line and destructure the state so that we can reference
    the pieces of state directly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'At the bottom of the JSX in the `Product` component, let''s add JSX to render
    how many likes we have and a button to add likes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the `like-container` CSS class we have just referenced into `index.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also implement the click handler on the Like button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Our last task is to implement the reducer function outside the `Product` component,
    just under the `LikeActions` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: If we try this out, we'll initially see a Like button after we navigate to the Product
    page. If we click it, the button text turns to Like again and a piece of text
    appears above it indicating how many likes there are and the last time it was
    liked.
  prefs: []
  type: TYPE_NORMAL
- en: This implementation feels very similar to implementing actions and reducers
    in a Redux store but this is all within a component. This is overkill for the
    example we have just been through but could prove useful where we need to manage
    lots more pieces of state.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started the chapter by introducing ourselves to Redux, learning the principles
    and key concepts. We learned that the state is stored in a single object and changed
    by pure functions called reducers when actions are dispatched.
  prefs: []
  type: TYPE_NORMAL
- en: 'We created our own store in our React shop to put the theory into practice.
    Here are some key points we learned in our implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations for action types give us nice IntelliSense when referencing them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using interfaces to define the actions gives a nice level of type safety and
    allows us to create a union type that a reducer can use for the actions it has
    to deal with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using read-only properties within the state interface helps us avoid mutating
    the state directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronous action creators simply return the required action object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous action creators return a function that eventually returns the action
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reducer contains a branch of logic for each action type it deals with, creating
    new state by spreading old state into a new object and then overwriting it with
    changed properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function called `createStore` from Redux creates the actual store. We pass
    all our reducers merged together along with Redux Thunk middleware to manage asynchronous
    actions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We then connected some components to the store. Here are the key points in
    this process:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Provider` component from React Redux needs to sit above all the components
    that want to consume the store. This takes in a prop that contains the store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `connect` HOC from React Redux then wires up the individual components to
    the store. This takes in two parameters than can be used to map the state and
    action creators to the component props.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are lots of bits and pieces to get our heads around when implementing
    Redux within our React apps. It does shine in scenarios where the state management
    is complex because Redux forces us to break the logic up into separate pieces
    that are easy to understand and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that we can use a Redux-like approach within just a single component
    by leveraging React's `useReducer` function. This can be used when the state is
    complex and just exists in a single component.
  prefs: []
  type: TYPE_NORMAL
- en: One task that Redux actions often do is interact with a REST API. We are going
    to learn how we can interact with REST APIs in both class- and function-based
    components in the next chapter. We'll also learn about a native function we use
    to call to a REST API as well as a popular open source library.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we end this chapter, let''s test our knowledge with some questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the `type` property in action objects required, and does this property need
    to be called type? Can we call it something else?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many properties can the action object contain?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an action creator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why did we need Redux Thunk in our Redux store in our React shop app?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Could we have used something else other than Redux Thunk?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our `basketReducer` we have just implemented, why didn't we just use the
    `push` function to add the item to the basket state? That is, what is wrong with
    the highlighted line?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following links are good resources of further information on React Redux:'
  prefs: []
  type: TYPE_NORMAL
- en: The Redux online docs are well worth reading at [https://redux.js.org](https://redux.js.org).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these core Redux docs, the React Redux docs are worth looking
    at as well. These are at [https://react-redux.js.org/](https://react-redux.js.org/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Redux Thunk GitHub is at [https://github.com/reduxjs/redux-thunk](https://github.com/reduxjs/redux-thunk).
    The home page contains some useful information and samples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
