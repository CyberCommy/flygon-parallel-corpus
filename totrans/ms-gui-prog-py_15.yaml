- en: Creating 2D Graphics with QPainter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already seen that Qt provides a vast array of widgets with extensive styling
    and customization capabilities. There are times, however, when we need to take
    direct control of what is being drawn on the screen; for example, we might like
    to edit an image, create a unique widget, or build an interactive animation. At
    the core of all these tasks in Qt sits a humble, hardworking object known as `QPainter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to explore Qt''s **two-dimensional** (**2D**)
    graphics capabilities in three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Image editing with `QPainter`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom widgets with `QPainter`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating 2D graphics with `QGraphicsScene`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the basic Python and PyQt5 setup that you've been using
    throughout the book. You may also wish to download the example code from [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter12](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter12).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need the `psutil` library, which you can install from PyPI using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Finally, it would be helpful to have some images on hand that you can use for
    sample data.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [http://bit.ly/2M5xzlL](http://bit.ly/2M5xzlL)
  prefs: []
  type: TYPE_NORMAL
- en: Image editing with QPainter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Images can be edited in Qt using a `QPainter` object to draw on a `QImage` object.
    In [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml), *Styling Qt Applications,*
    you learned about the `QPixmap` object, which is a display-optimized object representing
    a graphical image. The `QImage` object is a similar object, which is optimized
    for editing rather than display. To demonstrate how we can draw on a `QImage` object
    using `QPainter`, we're going to build a classic meme generator application.
  prefs: []
  type: TYPE_NORMAL
- en: The meme generator GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a copy of your Qt application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow,* and call it `meme_gen.py`. We will begin
    by building the GUI form for our meme generator.
  prefs: []
  type: TYPE_NORMAL
- en: The editing form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we create the actual form, we''re going to simplify our code slightly
    by creating some custom button classes: a `ColorButton` class for setting colors,
    a `FontButton` class for setting fonts, and an `ImageFileButton` class for selecting
    images.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ColorButton` class begins like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This button inherits `QPushButton` but makes a few changes. We've defined a
    `changed` signal to track when the value of the button changes and added a keyword
    option so that this signal can be connected using keywords, just like built-in
    signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve also added the ability to specify a default color, which will be passed
    to a `set_color` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This method stores the passed color value in an instance variable and then generates
    a `pixmap` object of the given color to use as a button icon (we saw this technique
    in [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml), *Styling Qt Applications*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The button''s `clicked` signal is connected to an `on_click()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This method opens `QColorDialog`, allowing the user to choose a color and, if
    one is selected, it sets its color and emits the `changed` signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FontButton` class will be nearly identical to the preceding class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the color button, it defines a `changed` signal that can be connected
    through a keyword. It takes a default family and size, which is used to generate
    a default `QFont` object stored in the button's `_font` property using the `set_font()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The `set_font()` method also changes the button's font and text to the selected
    family and size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `on_click()` method handles the button clicks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the color button, we're displaying a `QFontDialog` dialog box and,
    if the user selects a font, setting the button's font accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `ImageFileButton` class will be very much like the preceding two
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The only difference here is that the dialog is now a `getOpenFileName` dialog
    that allows the user to select PNG, XPM, or JPEG files.
  prefs: []
  type: TYPE_NORMAL
- en: '`QImage` can actually handle a wide variety of image files. You can find these
    at [https://doc.qt.io/qt-5/qimage.html#reading-and-writing-image-files](https://doc.qt.io/qt-5/qimage.html#reading-and-writing-image-files) or
    by calling `QImageReader.supportedImageFormats()`. We''ve shortened the list here
    for brevity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that these classes are created, let''s build a form for editing the meme''s
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This form will be very similar to those that we have created in previous chapters,
    but, rather than using a `submitted` signal for when the form is submitted, the `changed`
    signal will be triggered whenever any form item is changed. This will allow us
    to display any changes in real-time rather than requiring a button push.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first control will be to set the filename of the source image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We're going to be linking the `changed` signal (or something similar) on each
    widget to a method called `on_change()`, which will gather up the data in the
    form and emit the `changed` signal of `MemeEditForm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, though, let''s add fields to control the text itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Our memes will have separate text drawn at the top and bottom of the images,
    and we've used our `ColorButton` and `FontButton` classes to create inputs for
    the text's color and font. Once again, we're connecting an appropriate `changed` signal
    from each widget to an `on_changed()` instance method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s finish up the form GUI by adding controls to draw background boxes for
    the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: These fields allow the user to add opaque backgrounds behind the text in case
    the image is too colorful for it to be readable. The controls allow you to change
    the number of lines for the top and bottom backgrounds, the color of the boxes,
    and the padding.
  prefs: []
  type: TYPE_NORMAL
- en: 'That takes care of the form layout, so now we''ll deal with the `on_change()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First, we define a `get_data()` method, which assembles a `dict` object of values
    from the form's widgets and returns them. This will be useful if we need to pull
    data from the form explicitly, rather than rely on a signal. The `on_change()`
    method retrieves this `dict` object and emits it with the `changed` signal.
  prefs: []
  type: TYPE_NORMAL
- en: The main GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the form widget created, let's now assemble our main GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with `MainView.__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We're going to begin by setting a window title and then defining a maximum size
    for our generated meme image. We'll use this to create our `QImage` object. Since
    we haven't got an image file at program launch time, we'll just generate a black
    placeholder image that is of the maximum size, which we do using the `fill()`
    method—just as we did with our pixmaps. However, when creating a blank `QImage` object,
    we need to specify an image format to use for the generated image. In this case,
    we're using the ARGB32 format, which can be used to make full-color images with
    transparency.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use this image as we create the main GUI layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This GUI is a simple two-panel layout featuring a `QLabel` object on the left
    for displaying our meme image, and the `MemeTextForm()` method on the right for
    editing it. We've connected the form's `changed` signal to a `MainWindow` method
    called `build_image()`, which will contain our main drawing logic. Note that we
    cannot display a `QImage` object in a `QLabel` object directly; we must convert
    it to a `QPixmap` object first.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing with QImage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our GUI is squared away, it's time to create `MainView.build_image()`.
    This method will contain all of the image manipulation and painting methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin by adding the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Our first task is to set up the base image of our meme. If we don't have an
    `image_source` value in the form data, then we'll just fill our `QImage` object
    with the color black, providing us a blank canvas for the rest of the drawing.
    If we do have an image source, then we can load in the selected image by passing
    its file path to `QImage.load()`. In the event that our loaded image is larger
    than the maximum size, we will want to scale it down so that it is smaller than
    the maximum width and height while keeping the same aspect ratio.
  prefs: []
  type: TYPE_NORMAL
- en: A quick way to check whether the image is too large in either dimension is to
    subtract its size from our maximum size. If either the width or the height is
    larger than the maximum, then one of the dimensions will be negative, which makes
    the `QSize` object produced by the subtraction expression invalid.
  prefs: []
  type: TYPE_NORMAL
- en: The `QImage.scaled()` method will return a new `QImage` object, which has been
    scaled to the provided `QSize` object. By specifying `KeepAspectRatio`, our width
    and height will be scaled separately so that the resulting size has an identical
    aspect ratio to the original.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our image, we can start painting on it.
  prefs: []
  type: TYPE_NORMAL
- en: The QPainter object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At last, we get to meet the `QPainter` class! `QPainter` can be thought of as
    a little robot that lives inside your screen—to whom we can provide a brush and
    a pen, and issue drawing commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our painting `robot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The painter's constructor is passed a reference to the object on which it will
    paint. The object to be painted must be a subclass of `QPaintDevice`; in this
    case, we're passing a `QImage` object, which is such a class. The passed object
    will be the painter's canvas on which the painter will draw when we issue drawing
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how basic painting works, let''s start with our top and bottom background
    blocks. We''ll first figure out the boundaries of the rectangles that we need
    to paint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The coordinates used by `QPainter` start from the upper-left side of the painting
    surface. Therefore, the coordinates `(0, 0)` are the upper-left side of the screen,
    and `(width, height)` will be the lower-right of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the height of our top rectangle, we've multiplied the number of
    lines desired by the pixel height of our selected font (which we obtained from
    `QFontInfo`; see [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml), *Styling
    Qt Applications,* for more information about using `QFontInfo`). Finally, we add
    in the padding amount. We end up with a rectangle that starts at the origin (`(0,
    0)`) and ends on a point that is at the full width and height of the image of
    our box. These coordinates are used to create a `QRect` object representing the
    box area.
  prefs: []
  type: TYPE_NORMAL
- en: For the bottom box, we will need to calculate from the bottom of the image; this
    means that we must first calculate the height of the rectangle and then *subtract*
    it from the height of the box. Then, we construct a rectangle that starts at that
    coordinate on the left-side and extends to the bottom-right.
  prefs: []
  type: TYPE_NORMAL
- en: '`QRect` coordinates must always be defined from upper-left to bottom-right.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our rectangles, let''s draw them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`QPainter` has a number of drawing functions for creating lines, circles, polygons,
    and other shapes. In this case, we''re using `drawRect()`, which draws a rectangle.
    To define the fill of this rectangle, we''ve set the painter''s `brush` property
    to a `QBrush` object, which is set to our selected background color. The painter''s
    `brush` value determines the color and pattern with which it will fill any shape.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to `drawRect()`, `QPainter` contains a number of other drawing
    methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | For drawing |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `drawEllipse()` | Circles and ellipses |'
  prefs: []
  type: TYPE_TB
- en: '| `drawLine()` | Straight lines |'
  prefs: []
  type: TYPE_TB
- en: '| `drawRoundedRect()` | Rectangle with rounded corners |'
  prefs: []
  type: TYPE_TB
- en: '| `drawPolygon()` | Polygons of any kind |'
  prefs: []
  type: TYPE_TB
- en: '| `drawPixmap()` | `QPixmap` objects |'
  prefs: []
  type: TYPE_TB
- en: '| `drawText()` | Text |'
  prefs: []
  type: TYPE_TB
- en: 'To place our meme text on the image, we need to use `drawText()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Before we draw the text, we need to give the painter a `QPen` object to define
    the text color and a `QFont` object to define the font used. The painter's `QPen`
    determines the color used for text, shape outlines, lines, and points drawn by
    our painter.
  prefs: []
  type: TYPE_NORMAL
- en: To control where the text is drawn on the image, we could use the first argument
    to `drawText()`, which is a `QRect` object defining the bounding box for our text.
    However, since we don't know how many lines of text we're dealing with, we're
    just going to use the entire image as a bounding box and use vertical alignment
    to determine whether the text is written at the top or bottom.
  prefs: []
  type: TYPE_NORMAL
- en: Behaviors such as alignment and word-wrap are configured using flag values from
    the `QtCore.Qt.TextFlag` and `QtCore.Qt.AlignmentFlag` enums. In this case, we're
    specifying the center alignment and word wrap for both the top and bottom text,
    and then adding the vertical alignment option inside the `drawText()` call.
  prefs: []
  type: TYPE_NORMAL
- en: The last argument to `drawText()` is the actual text, which we've pulled from
    our `dict` data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve drawn our text, the final thing we need to do is set the image
    in our image display label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you should be able to start up the program and create an image.
    Go ahead and try it out!
  prefs: []
  type: TYPE_NORMAL
- en: Saving our image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After creating a snazzy meme image, our user probably wants to save it so that
    they can upload it to their favorite social media website. To enable that, let''s
    head back to `MainWindow.__init_()` and create a toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You could, of course, do this using the menu options or another widget. In
    any case, we need to define the `save_image()` method called by this action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To save a `QImage` file to disk, we need to call its `save()` method with a
    file path string and a second string defining the image format. In this case,
    we're going to retrieve a save location using `QFileDialog.getSaveFileName()`
    and save it in the `PNG` format.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run your meme generator, you should find that it looks something like
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ce619532-1f47-4b59-bcbf-e28f4e9401a2.png)'
  prefs: []
  type: TYPE_IMG
- en: As an additional exercise, try thinking up some other things that you'd like
    to draw on a meme and add this capability to the code.
  prefs: []
  type: TYPE_NORMAL
- en: Custom widgets with QPainter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QPainter` is not merely a specialized tool for drawing on images; it''s actually
    the workhorse that draws all the graphics for all the widgets in Qt. In other
    words, every pixel of every widget you see in your PyQt application was drawn
    by a `QPainter` object. We can take control of `QPainter` to create a purely custom
    widget.'
  prefs: []
  type: TYPE_NORMAL
- en: To explore this idea, let's create a CPU monitor application. Get a fresh copy
    of the Qt application template and call it `cpu_graph.py`, and then we'll begin.
  prefs: []
  type: TYPE_NORMAL
- en: Building a GraphWidget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our CPU monitor will display real-time CPU activity using an area graph. The
    graph will be enhanced by a color gradient, which will show higher values in a
    different color from lower values. The graph will only show a configured number
    of values at one time, scrolling old values off to the left side of the widget
    as new ones are added from the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, we need to build a custom widget. We''ll call it `GraphWidget`,
    and begin it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The custom widget begins with some class properties to define colors for *good*,
    *warning*, and *critical* values. Feel free to change these if you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our constructor takes a number of keyword arguments, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data_width`: This refers to how many values will be displayed at a time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minimum` and `maximum`: The minimum and maximum values to be displayed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`warn_val` and `crit_val`: These are threshold values for color changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Scale`: This refers to how many pixels will be used on each data point'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our next step is to save all of these values as instance properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To store our values, we require something like a Python `list` but constrained
    to a fixed number of items. Python''s `collections` module offers the perfect
    object for this: the `deque` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s import this class at the top of our code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `deque` class can take a `maxlen` argument, which will limit its length.
    When new items are appended to the `deque` class, pushing it beyond its `maxlen`
    value, old items will be dropped from the beginning of the list to keep it under
    the limit. This is perfect for our graph since we only want to display a fixed
    number of data points in the graph at one time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create our `deque` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`deque` can take a `list` as an argument, which will be used to initialize
    its data. In this case, we''re initializing it with a `list` of `data_width` items
    containing our minimum value and setting the `maxlen` value of the `deque` class
    to `data_width`.'
  prefs: []
  type: TYPE_NORMAL
- en: You can create a list of *N* items quickly in Python by multiplying a list of
    1 item by *N*, as we've done here; for example, `[2] * 4` will create a list of `[2,
    2, 2, 2]`.
  prefs: []
  type: TYPE_NORMAL
- en: We finish off the `__init__()` method by setting the fixed width of the widget
    to `data_width * scale`, which represents the total number of pixels that we want
    to display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a method to add a new value to our `deque` class, which we''ll
    call `add_value()` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The method begins by constraining our value between the minimum and maximum
    values and then appending it to the `deque` object.  This has the additional effect
    of popping the first item off the beginning of the `deque` object so that it remains
    at the `data_width` value.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call `update()`, which is a `QWidget` method that tells the widget
    to redraw itself. We'll handle this drawing process next.
  prefs: []
  type: TYPE_NORMAL
- en: Painting the widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `QWidget` class, just like `QImage`, is a subclass of `QPaintDevice`; as
    such, we can use a `QPainter` object to draw directly onto the widget. When a
    widget gets a request to redraw itself (similar to how we issued our call to `update()`),
    it calls its `paintEvent()` method. We can override this method with our own drawing
    commands to define a custom look for our widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start the method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`paintEvent()` will be called with one argument, a `QPaintEvent` object. This
    object contains information about the event that requested the repaint – most
    notably, the region and rectangle that needs to be redrawn. For a complex widget,
    we can use this information to only redraw requested parts. For our simple widget,
    we''re going to ignore this information and just redraw the whole thing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve defined a painter object that is pointed to the widget itself, so any
    commands we issue to the painter will be drawn on our widget. Let''s start by
    creating a background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Just as we did in our meme generator, we're defining a brush, giving it to our
    painter, and drawing a rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we're using an alternate form of `drawRect()` here, which takes
    coordinates directly instead of a `QRect` object.  Many of the `QPainter` object's
    drawing functions have alternate versions that take slightly different types of
    arguments for flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s draw some dotted lines to show where the thresholds for warning
    and critical are. To do this, we''re going to need to translate a raw data value
    to a *y* coordinate on the widget. Since this will need to happen often, let''s
    create a convenient method to convert values to *y* coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To convert a value to a *y* coordinate, we need to first determine what fraction
    of the data range the value represents. We then multiply that fraction by the
    height of the widget to determine how many pixels it should be from the bottom
    of the widget. Then, because pixel coordinates count *down* from the top, we have
    to subtract our offset from the height of the widget to determine the *y* coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `paintEvent()`, let''s use this method to draw a warning threshold
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Since we're drawing a line, we need to set the painter's `pen` property. The
    `QPen.setDashPattern()` method allows us to define a dash pattern for the line
    by passing it a list of `1` and `0` values, representing drawn or not-drawn pixels.
    In this case, our pattern will alternate between a drawn pixel and an empty pixel.
  prefs: []
  type: TYPE_NORMAL
- en: With the pen created, we use our new conversion method to convert our `warn_val` value
    to a *y* coordinate and set the color of the pen to `warn_color`. We hand the
    configured pen to our painter and instruct it to draw a line across the width
    of the widget at the *y* coordinate that we calculated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same approach can be used to draw our critical threshold line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We can reuse our `QPen` object, but remember that any time we make changes to
    a pen or brush, we have to reassign it to the painter. The painter is passed a
    copy of the pen or brush, so the changes that we make to the object *after* assigning
    it to a painter are not implicitly passed along to the pen or brush that is used.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml), *Styling Qt Applications,*
    you learned how to make a gradient object and apply it to a `QBrush` object. We'll
    want to use a gradient in this application to draw our data values so that high
    values are red at the top, medium values are yellow, and low values are green.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a `QLinearGradient` gradient object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This gradient will go from the bottom of the widget (`self.height()`) to the
    top (`0`). This is important to remember because, as we define the color stops,
    a `0` location indicates the start of the gradient (which is at the bottom of
    the widget) and a `1` location will indicate the end of the gradient (which is
    at the top).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll set our color stops as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Similar to how we calculated the *y* coordinates, here, we're determining the
    fraction of the data range represented by the warning and critical values by dividing
    them by the difference between the minimum and maximum values. This fraction is
    what `setColorAt()` needs for its first argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a gradient, let''s set up our painter for drawing the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: To make our area graph look smooth and cohesive, we don't want any outlines
    on the chart sections. To stop `QPainter` from outlining shapes, we're setting
    our pen to a special constant: `QtCore.Qt.NoPen`.
  prefs: []
  type: TYPE_NORMAL
- en: To create our area chart, each data point is going to be represented by a quadrilateral,
    where the upper-right corner will be the current data point and the upper left
    corner will be the previous data point. The width will be equal to the `scale`
    property we set in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re going to need a *previous* value for each data point, we need
    to start with a bit of bookkeeping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we need to do is to determine a starting value. Since we need
    a value *before* our current value, our first item needs a place to start drawing.
    We're going to create an instance variable called `start_value`, which persists
    between calls to `paintEvent` and stores the value, to begin with. We then assign
    that to `last_value`, which is a local variable that will be used to remember
    the previous value for each iteration of the loop. Finally, we update the start
    value for the *next* call to `paintEvent` as the first value of the `deque` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s start looping through the data and calculating `x` and `y` values
    for each point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The two *x* coordinates for the polygon will be (`1`) the index of the value
    multiplied by the scale, and (`2`) the scale multiplied by the index of the value
    plus one. For the *y* values, we pass the current and last values to our conversion
    method. These four values will give us the ability to draw a four-sided shape
    representing a change from one point of data to the next.
  prefs: []
  type: TYPE_NORMAL
- en: To draw that shape, we're going to use something called a `QPainterPath` object.
    In digital graphics, a **path** is an object built from individual line segments
    or shapes combined together. The `QPainterPath` object allows us to create a unique
    shape by drawing each side individually in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start drawing our path object using the `x` and `y` data we''ve calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: To draw a path, we begin by creating a `QPainterPath` object. We then use its
    `moveTo()` method to set a starting point for drawing. We then connect the four
    corners of the path using the `lineTo()` method to draw a straight line between
    the points. The last connection between our end and start points is made automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we're not actually drawing on the screen at this point; we're merely
    defining an object that our painter can paint to the screen using its current
    brush and pen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s draw this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We've finished out the method by painting the path and updating the last value
    to the current value. Of course, this path, which is made of straight lines, is
    rather dull—we could have just used the painter's `drawPolygon()` method for this.
    The real power of using a `QPainterPath` object is to take advantage of some of
    its non-linear drawing methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want our chart to be smooth and rounded rather than jagged,
    then we can draw the last line (which is the top of the shape) using a **cubic
    Bezier curve** rather than a straight line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'A cubic Bezier curve uses two control points to define its curve. Each control
    point *pulls* a segment of the line towards it—the first control point pulling
    the first half of the line, and the second control point pulling the second half
    of the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/004dbd50-bd0b-40cc-8967-020135f4a640.png)'
  prefs: []
  type: TYPE_IMG
- en: We're setting the first control point at the last *y* value and the second control
    point at the current *y* value—both of these are halfway between the start and
    end *x* values. This gives us an *S* curve on the upward slopes and a reverse
    *S* curve on the downward slopes, resulting in softer peaks and valleys.
  prefs: []
  type: TYPE_NORMAL
- en: After setting up the `GraphWidget` object in an application, you can try switching
    between the curve and line commands to see the difference.
  prefs: []
  type: TYPE_NORMAL
- en: Using GraphWidget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our graph widget is finished, so let's head down to `MainWindow` and use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating your widget and making it the central widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create a method that will read the current CPU usage and send
    it to `GraphWidget`. To do this, we''ll need to import the `cpu_percent` function
    from the `psutil` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can write our graph-updating method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `cpu_percent()` function returns an integer from 0 to 100, reflecting the
    current CPU utilization on your computer. This is perfect for sending directly
    to our `GraphWidget`, whose default range is 0 to 100.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just need to call this method periodically to update the graph; back
    in `MainWindow.__init__()`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This is just a `QTimer` object, which you learned about in [Chapter 10](06a74416-66c5-4538-9dc5-c540a3a44da9.xhtml),
    *Multithreading with QTimer and QThread,* set to call `update_graph()` on a one-second
    interval.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the application now, you should get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9f215c0b-8fcb-4e0d-acbf-b344e4bf5605.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice the smooth peaks created by our Bezier curves. If you switch back to
    the straight-line code, you'll see those peaks sharpen up.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your CPU is too powerful to provide an interesting activity graph, try the
    following changes to `update_graph()` for a better test of the widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This will just spit out random values between `1` and `100` and should make
    for some fairly chaotic results.
  prefs: []
  type: TYPE_NORMAL
- en: Seeing this CPU graph animated in real-time might make you wonder about the
    animation capabilities of Qt. In the next section, we'll learn how to create 2D
    animations in Qt using `QPainter` in conjunction with the Qt Graphics View framework.
  prefs: []
  type: TYPE_NORMAL
- en: Animating 2D graphics with QGraphicsScene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Painting on a `QPaintDevice` object works well for simple widgets and image
    editing, but in situations where we want to draw a large number of 2D objects,
    and possibly animate them in real-time, we need a more powerful object. Qt provides
    the Graphics View Framework, an item-based model-view framework for composing
    complex 2D graphics and animations.
  prefs: []
  type: TYPE_NORMAL
- en: To explore how this framework operates, we're going to create a game called
    **Tankity Tank Tank Tank**.
  prefs: []
  type: TYPE_NORMAL
- en: First steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This tank game will be a two-player combat game modeled after the kind of simple
    action game you might find on a classic 1980s game system. One player will be
    at the top of the screen, one at the bottom, and the two tanks will move constantly
    from left to right while each player tries to shoot the other with a single bullet.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, copy your Qt application template to a new file called `tankity_tank_tank_tank.py`.
    Starting just after the `import` statements at the top of the file, we''ll add
    a few constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'These constants will be used throughout the game code to calculate sizes and
    locations. In fact, we''ll use two of them right away in `MainWindow.__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is all the code we''re going to add into `MainWindow`. After resizing
    the window to our width and height constants, we''ll create two objects, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is a `Scene` object. This is a custom class we're going to create,
    subclassed from `QGraphicsScene`. `QGraphicsScene` is the model in this model-view
    framework and represents a 2D scene containing a variety of graphics items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is the `QGraphicsView` object, which is the view component of the
    framework. This widget's job is simply to render the scene and display it for
    the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `Scene` object is going to contain most of the code for the game, so we
    will build that part next.
  prefs: []
  type: TYPE_NORMAL
- en: Making a scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Scene` class will be the main stage for our game and will manage all the
    various objects involved in the game, such as the tanks, bullets, and walls. It
    will also display the scores and keep track of other game logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we've done here is to paint our scene black by setting the `backgroundBrush` property.
    This property, naturally, takes a `QBrush` object, which it will use to fill the
    background of the scene. We've also set the `sceneRect` property, which describes
    the size of the scene, to a `QRect` object set to our width and height constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin placing objects on the scene, we can use one of its many add methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've used `addRect()` to draw two rectangles on the scene—one across
    the bottom for a floor and one across the top for a ceiling. Just like the `QPainter`
    class, `QGraphicsScene` has methods to add ellipses, pixmaps, lines, polygons,
    text, and other such items. Unlike the painter, however, the `QGraphicsScene`
    methods don't just draw pixels to the screen; instead, they create items of the
    `QGraphicsItem` class (or a subclass). We can subsequently query or manipulate
    the items created.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can add some text items to display our scores as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, after creating the text items, we are manipulating their properties and
    setting the position of each text item using the `setPos()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also update the text in the items; for example, let''s create methods
    to update our scores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If you think about `QPainter` as being analogous to painting on paper, adding
    `QGraphicsItems` to a `QGraphicsScene` class is analogous to placing felt shapes
    on a flannel-graph. The items are *on* the scene, but they not part of it and,
    subsequently, they can be altered or removed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the tanks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our game will have two tanks, one at the top of the screen and one at the bottom.
    These will be drawn on the `Scene` object and be animated so that the players
    can move them left and right. In [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml),
    *Styling Qt Applications,* you learned that animation can be done using `QPropertyAnimation`,
    but *only* if the property being animated belongs to a descendant of `QObject`.
    `QGraphicsItem` is *not* a `QObject` descendant, but the `QGraphicsObject` object
    combines both to provide us with a graphics item that we can animate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we''ll need to build our `Tank` class as a subclass of `QGraphicsObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This class begins by defining two constants, `TOP`, and `BOTTOM`. These will
    be used to signify whether we're creating the tank at the top of the screen or
    the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: '`TANK_BM` is a `bytes` object that contains data for an 8 × 8 bitmap of a tank
    graphic. We''ll see how this works shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, though, let''s begin the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Our tank will be given a color, a *y* coordinate, and a `side` value, which
    will be either `TOP` or `BOTTOM`. We'll use this information to position and orient
    the tank.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s use our `bytes` string to create a bitmap for our tank:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: A `QBitmap` object is a special case of `QPixmap` for monochromatic images.
    By passing a size and `bytes` object to the `fromData()` static method, we can
    generate a simple bitmap object without needing a separate image file.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how this works, consider the `TANK_BM` string. Because we're interpreting
    it as an 8 × 8 graphic, each byte (which is 8 bits) in this string corresponds
    to one row of the graphic.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to convert each row to binary numbers and lay them out one byte
    per line, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The shape created by the ones is essentially the shape that this bitmap will
    take. Of course, an 8x8 graphic will be quite small, so we ought to enlarge it.
    Additionally, this tank is clearly pointing up, so if we're the top tank, we need
    to flip it over.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do both of those things using a `QTransform` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: A `QTransform` object represents a set of transformations to be done on `QPixmap`
    or `QBitmap`. After creating the transform object, we can set the various transformations
    to be applied, starting with a scaling operation and adding a `rotate` transformation
    if the tank is on the top. The `QTransform` object can be passed to a bitmap `transformed()`
    method, which returns a new `QBitmap` object with the transformations applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bitmap is monochromatic and, by default, it draws in black. To draw in
    another color, we will need a `QPen` (not a brush!) object set to the desired
    color. Let''s use our `color` argument to create this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual appearance of the `QGraphicsObject` object is determined by overriding
    the `paint()` method. Let''s create this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The first argument to `paint()` is the `QPainter` object, which Qt has created
    and assigned to paint the object. We simply need to apply commands to that painter,
    which will draw the image as we desire. We'll start by setting the `pen` property
    to the pen we've created, and then use the painter's `drawPixmap()` method to
    draw our bitmap.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the coordinates we pass to `drawPixmap()` do not refer to coordinates
    of the `QGraphicsScene` class, but coordinates within the bounding rectangle of
    the `QGraphicsObject` object itself. Because of that, we need to make sure that
    our object returns a proper bounding rectangle so that our image is drawn correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we''ll need to override the `boundingRect()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we want our `boundingRect()` method to return a rectangle that
    is the same size as the bitmap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `Tank.__init__()`, let''s position our tank:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `QGraphicsObject.setPos()` method allows you to position the object anywhere
    on its assigned `QGraphicsScene` using pixel coordinates. Since pixel coordinates
    always count from the top-left of the object, we need to adjust the *y* coordinate
    of our object if it is on the bottom of the screen, raising it by its own height
    so that the *bottom* of the tank is at `y_pos` pixels from the top.
  prefs: []
  type: TYPE_NORMAL
- en: The position of an object always indicates the position of its upper-left corner.
  prefs: []
  type: TYPE_NORMAL
- en: Now we want to animate our tanks; each tank will move back and forth along the
    *x* axis, bouncing back when it hits the edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `QPropertyAnimation` method to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `QGraphicsObject` object has `x` and `y` properties that define its *x*
    and *y* coordinates on the scene, so animating the object is as simple as directing
    our property animation to these properties. We're going to animate `x` starting
    at `0` and ending at the width of the screen; however, to keep our tanks from
    going off the edge, we need to subtract the width of the bitmap from the value.
    Finally, we set duration of two seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'A property animation can be run forward or backward. So, to enable the left
    and right movement, we simply need to toggle the direction in which the animation
    runs. Let''s create some methods to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Switching directions is just a matter of setting the animation object's `direction`
    property to `Forward` or `Backward`, and then calling `start()` to apply it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `__init__()`, let''s use the `toggle_direction()` method to create
    the *bounce*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the game more interesting, we should also start our tanks on opposite
    ends of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: After setting up the animation, we start it by calling `start()`. This takes
    care of the tank animation; now it's time to load our weapons.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the bullets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this game, each tank will only be allowed one bullet on the screen at a time.
    This simplifies our game code, but also keeps the game relatively challenging.
  prefs: []
  type: TYPE_NORMAL
- en: To implement these bullets, we'll create another `QGraphicsObject` object called
    `Bullet`, which is animated to move along the *y* axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start our `Bullet` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The bullet class starts by defining a `hit` signal indicating that it has hit
    an enemy tank. The constructor takes a `y_pos` argument to define the starting
    point of the bullet, and a Boolean indicating whether the bullet is to travel
    up or down. These arguments are saved as instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s define the bullet''s look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Our bullet will simply be a 10 × 10 yellow square created using the painter''s
    `drawRect()` method. This is appropriate for a retro game but, just for fun, let''s
    make it a bit more interesting. To do this, we can apply something called a `QGraphicsEffect` class
    to the `QGraphicsObject`. The `QGraphicsEffect` class can apply a visual effect
    to the object in real-time. We implement this by creating an instance of one of
    the `QGraphicEffect` class''s subclasses and assigning it to the bullet''s `graphicsEffect`
    property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This code added to `Bullet.__init__()`, creates a blur effect and applies it
    to our `QGraphicsObject` class. Note that this is applied at the object level,
    and not at the painting level, so it is applied to any pixels we draw. We've adjusted
    the blur radius to 10 pixels and added the `AnimationHint` object, which tells
    us the effect that is being applied to an animated object and activates certain
    performance optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of animation, let''s create the bullet''s animation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The animation is configured so that it takes the bullet one second to go from
    its current `y_pos` argument to either the top or bottom of the screen, depending
    on whether the bullet is to shoot up or down. We aren't starting the animation
    yet, though, because we don't want the bullet to start moving until it's shot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shooting will happen in a `shoot()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: When a player shoots a bullet, we first stop any animation that might be happening.
    Since only one bullet is allowed at a time, rapid-firing will just result in the
    bullet starting over (while this is not terribly realistic, it makes gameplay
    more challenging).
  prefs: []
  type: TYPE_NORMAL
- en: Then, the bullet is repositioned to the *x* coordinate and passed into the `shoot()`
    method and the tank's *y* coordinate. Finally, the animation is started. The idea
    is that we'll pass in the tank's current *x* coordinate when the player shoots
    and the bullet will fly up or down from that position in a straight line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our `Tank` class and add a `Bullet` object. In `Tank.__init__()`,
    add in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: So that we don't hit our own tank with our own bullet, we want the bullet to
    start at a position just above the bottom tank or just below the top tank, which
    is what we've calculated in the first statement. Since our tanks don't move up
    or down, this position is a constant, and we can pass it to the bullet's constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the tank shoot the bullet, we''ll create a method in the `Tank` class
    called `shoot()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we need to do is to add the bullet to the scene if it's not
    yet added (or if it's been removed). We can determine this by checking the bullet's `scene`
    property, which returns `None` if the object is not on the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we call the bullet's `shoot()` method by passing in the tank's *x* coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: Collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bullets don't do much good if nothing happens when they hit the target. To make
    something happen when a bullet hits a tank, we need to implement **collision detection**.
    We will implement this in the `Bullet` class by asking it to check whether it
    has hit anything whenever it moves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a method in `Bullet` called `check_colllision()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '`QGraphicsObject.collidingItems()` returns a list of any `QGraphicsItem` objects
    whose bounding rectangles overlap with this item. This includes not only our `Tank`
    objects, but also the `floor` and `ceiling` items we created in the `Scene` class,
    or even the other tank''s `Bullet` object. If our bullet touches any of these
    items, we need to remove it from the scene; to do this, we call `self.scene().removeItem(self)`
    to eliminate the bullet.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we need to check whether any of the items we've collided with are `Tank`
    objects. This we do by simply checking the type and name of the object hit. If
    we hit a tank, we emit our `hit` signal. (We can safely assume it's the other
    tank because of the way our bullets move.)
  prefs: []
  type: TYPE_NORMAL
- en: This method needs to be called every time the `Bullet` object moves, since every
    movement could result in a collision. Fortunately, the `QGraphicsObject` method
    has a `yChanged` signal, which is emitted every time its *y* coordinate changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, back in the `Bullet.__init__()` method, we can add a connection, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Our tank and bullet objects are now ready, so let's head back to the `Scene`
    object to finish out our game.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Back in `Scene.__init__()`, let''s create our two tanks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The bottom tank sits on top of the floor, and the top tank is positioned on
    the bottom of the ceiling. Now we can connect the `hit` signals of their bullets
    to the proper score-incrementing methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, our game is almost done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/492381be-ba26-4e11-91b5-de1470a9ef5a.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, there is one very important aspect still missing—the controls!
  prefs: []
  type: TYPE_NORMAL
- en: Our tanks will be controlled by the keyboard; we'll assign the bottom player
    the arrow keys for movement and the return key for firing, while the top player
    will get *A* and *D* for movement and the spacebar for firing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle keystrokes, we need to override the `Scene` object''s `keyPressEvent()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '`keyPressEvent()` is called whenever the user presses a key while the `Scene` object
    is focused. It''s the only argument that is a `QKeyEvent` object whose `key()`
    method returns a constant from the `QtCore.Qt.Key` enum telling us what key was
    pressed. In this method, we''ve created a `dict` object that maps certain key
    constants to methods on our tank objects. Whenever we receive a keystroke, we
    attempt to fetch a callback method, and if we''re successful, we call the method.'
  prefs: []
  type: TYPE_NORMAL
- en: The game is now ready to play! Grab a friend (preferably someone you don't mind
    sharing a keyboard with) and fire it up.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned all about working with 2D graphics in PyQt. We
    learned how to use the `QPainter` object to edit images and create custom widgets.
    You then learned how to use a `QGraphicsScene` method in conjunction with the
    `QGraphicsObject` class to create animated scenes that can be controlled using
    automated logic or user input.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll add an additional dimension to our graphics as we
    explore the use of OpenGL 3D graphics with PyQt. You'll learn some of the basics
    of OpenGL programming and how it can be integrated into a PyQt application.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try these questions to test your knowledge from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add code to this method to write your name in blue on the bottom of the picture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Given a `QPainter` object called `painter`, write a line of code to paint an
    80 × 80 pixel octagon in the upper-left corner of the painter's paint device.
    You can refer to the documentation at [https://doc.qt.io/qt-5/qpainter.html#drawPolygon](https://doc.qt.io/qt-5/qpainter.html#drawPolygon) for
    guidance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''re creating a custom widget and can''t figure out why the text is showing
    up in black. The following is your `paintEvent()` method; see whether you can
    figure out the problem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: A deep-fried meme is a style of a meme that uses extreme compression, saturation,
    and other processing to make the meme image look intentionally low quality. Add
    a feature to your meme generator to optionally make the meme deep-fried. Some
    things you can try include reducing the color bit depth and adjusting the hue
    and saturation of the colors in the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''d like to animate a circle moving horizontally across the screen. Change
    the following code to animate the circle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code attempts to set up a `QPainter` object with a gradient brush.
    Discover what is wrong with it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'See whether you can implement some of the following improvements to the game
    we created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pulsating bullets
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Explosions when a tank is hit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sounds (see [Chapter 7](0234c71b-292c-4423-89d7-e9d9906d730e.xhtml), *Working
    with Audio-Visual Using QtMultimedia,* for guidance)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple bullets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For further information, please refer the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An in-depth discussion of `QPainter` and Qt's paint system can be found at [https://doc.qt.io/qt-5/paintsystem.html](https://doc.qt.io/qt-5/paintsystem.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of the Qt Graphics View framework can be found at [https://doc.qt.io/qt-5/graphicsview.html](https://doc.qt.io/qt-5/graphicsview.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of the animation framework can be found at [https://doc.qt.io/qt-5/animation-overview.html](https://doc.qt.io/qt-5/animation-overview.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
