- en: Item Views and Dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to display data using different types
    of chart. Charts are one of many ways to present information to the users on screen.
    It is very important for your application to present vital information to the
    users so that they know exactly what's happening to the application—whether data
    has been saved successfully, or the application is waiting for the user's input,
    or warning/error messages that the users should be aware of, and so on—it's all
    very important to ensure your application's user-friendliness and usability.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics :'
  prefs: []
  type: TYPE_NORMAL
- en: Working with item view widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with dialog boxes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with file selection dialogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image scaling and cropping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt provides us with many types of widget and dialog that we can easily use to
    display important information to the users. Let's check out what these widgets
    are!
  prefs: []
  type: TYPE_NORMAL
- en: Working with item view widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other than displaying data using different types of chart, we can also display
    this data using different types of item view. An item view widget presents data
    by rendering it visually, usually along the vertical axis.
  prefs: []
  type: TYPE_NORMAL
- en: A two-dimensional item view, often known as a **table view**, displays data
    in both vertical and horizontal directions. That allows it to display huge volumes
    of data within a compact space, and enables the users to search for an item very
    quickly and easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to display data in an item view. The most common method
    is to use the **model-view architecture**, which uses three different components,
    model, view, and delegate, to retrieve data from a data source and display it
    in the item view. These components all make use of the **signal-slot architecture**
    provided by Qt to communicate with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: Signals from the model inform the view about changes to the data held by the
    data source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signals from the view provide information about the user's interaction with
    the items being displayed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signals from the delegate are used during editing to tell the model and view
    about the state of the editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other method is the manual way, in which the programmer must tell Qt which
    data goes into which column and row. This method is much simpler than the model-view,
    but much slower when compared to its performance. However, for small amounts of
    data, the performance issue can be negligible, making this a good approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open up Qt Designer, you will see the two different categories for Item
    View Widgets, namely Item Views (Model-Based) and Item Widgets (Item-Based):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f63f909-cc29-4299-baf3-b34e7655cf7d.png)'
  prefs: []
  type: TYPE_IMG
- en: Even though they might look the same, in actual fact the widgets within the
    two categories work very differently. In this chapter, we will learn how to use
    the latter category, as it is more straightforward and easy to understand, and
    able to serve as prerequisite knowledge for the former category.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the Item Widgets (Item-Based) category are three different widgets called
    List Widget, Tree Widget, and Table Widget. Each of these item widgets displays
    data in a different way. Pick the one that suits your needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a50b4415-472d-4c74-b1e1-f735f0a5bd21.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding diagram, the **List Widget** displays its
    items in a one-dimensional list, while the **Table Widget** displays its item
    in a two-dimensional table. Even though the **Tree Widget** works almost similar
    to the **List Widget**, its items are displayed in a hierarchical structure, in
    which each item can have multiple children items under it, recursively. One good
    example of this is the filesystem in our operating system, which displays the
    directory structure using the tree widget.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the differences, let's create a new Qt Widgets application project
    and try it out ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our Qt Widgets application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have created the project, open up `mainwindow.ui` and drag the three
    different item widgets to your main window. After that, select the main window
    and click the Layout Vertically button located at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0e15392-5def-4f64-accd-075c8e6d2778.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, double-click on the List Widget and a new window will pop out. Here,
    you can add a few dummy items to the List Widget by clicking the + icon, or remove
    them by selecting an item from the list and clicking the - icon. Click the OK
    button to apply the final result to the widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a126e2c-2059-4faf-a325-fafa3b81ce9d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can do the same to the Tree Widget. It''s almost the same as the List Widget,
    except that you can add sub-items to an item, recursively. You can also add columns
    to the Tree Widget and name the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/486ef112-0666-4f94-a753-eac1472c352e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, double-click on the Table Widget to open the Edit Table Widget window.
    Unlike the other two item views, the Table Widget is a two-dimensional item view,
    which means you can add columns and rows to it just like a spreadsheet. Each column
    and row can be labeled with the desired name by setting it in the Columns or Rows
    tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3e07ba3-fb5c-4017-90db-caf9edae65e1.png)'
  prefs: []
  type: TYPE_IMG
- en: It's really easy to understand how a widget works by using the Qt Designer.
    Just drag and drop the widget into the window and play around with its settings,
    then build and run the project to see the result for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we have demonstrated the differences between the three item views
    widgets without writing a single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb94f990-0b6d-435e-8bea-c09205c56bf3.png)'
  prefs: []
  type: TYPE_IMG
- en: Making our List Widget functional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing code, however, is still required in order for the widgets to be fully
    functional in your application. Let's learn how to add items to our item view
    widgets using C++ code!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open up `mainwindow.cpp` and write the following code to the class constructor,
    right after `ui->setupui(this)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As simple as that, you have successfully added an item to the List Widget!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f54393e-6a48-42c9-90c3-0d36ae463ad2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is another way to add an item to the List Widget. But before that, we
    must add the following headers to `mainwindow.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `QDebug` header is for us to print out debug message, and the `QListWidgetItem`
    header is for us to declare List Widget `Item` objects. Next, open up `mainwindow.cpp`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code does the same as the previous one-line code. Except, this
    time, I've added an extra data to the item. The `setData()` function takes in
    two input variables—the first variable is the data-role of item, which indicates
    how it should be treated by Qt. If you put a value that matches the `Qt::ItemDataRole`
    enumerator, the data will affect the display, decoration, tooltip, and so on,
    and that may change its appearance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my case, I just simply set a number that doesn''t match any of the enumerators
    in `Qt::ItemDataRole` so that I can store it as a hidden data for later use. To
    retrieve the data, you can simply call `data()` and insert the number that matches
    the one you''ve just set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the project; you should be able to see that the new item is now
    being added to the List Widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf13b2e0-4637-4f30-a7c4-2c79b541baad.png)'
  prefs: []
  type: TYPE_IMG
- en: For more information about `Qt::ItemDataRole` enumerators, please check out
    the following link: [http://doc.qt.io/qt-5/qt.html#ItemDataRole-enum](http://doc.qt.io/qt-5/qt.html#ItemDataRole-enum)
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, hidden data can be attached to a list item for later use.
    For example, you could use the list widget to display a list of products ready
    to be purchased by the user. Each of these items can be attached with its product
    ID so that when the user selects the item and places it on the cart, your system
    can automatically identify which product has been added to the cart by identifying
    the product ID stored as the data role.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, I stored custom data, `1000`, in my list item and
    set its data role as `100`, which does not match any of the `Qt::ItemDataRole`
    enumerators. This way, the data won't be shown to the users, and thus it can only
    be retrieved through C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding functionality to the Tree Widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, let''s move on to the Tree Widget. It is actually not that different
    from the List Widget. Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It's pretty much the same as the List Widget, except we have to set the column
    ID in the `setText()` function. This is because the Tree Widget is somewhere between
    a List Widget and a Table Widget—it can have more than one column but can't have
    any rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most obvious distinction between a Tree Widget and other view widgets is
    that all its items can contain children items, recursively. Let''s look at the
    following code to see how we can add a child item to an existing item in the Tree
    Widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s really that simple! The final result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3580d596-4c97-4c34-9699-f54ddf816393.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, our Table Widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, let's do the same for the Table Widget. Technically, the items already
    exist and are reserved in the Table Widget when the columns and rows are being
    created. What we need to do is to create a new item and replace it with the (currently
    empty) item located at a specific column and row, which is why the function name
    is called `setItem()`, instead of `addItem()` used by the List Widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the code, I have added two sections of data to two different
    locations, which translates into the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05cecb5e-908c-4668-8afa-dde23dae413d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That''s it! It''s all that simple and easy to display data using item views
    in Qt. If you are looking for more examples related to item views, please visit
    the following link: [http://doc.qt.io/qt-5/examples-itemviews.html](http://doc.qt.io/qt-5/examples-itemviews.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Working with dialog boxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One very important aspect of creating a user-friendly application is the ability
    to display vital information regarding the status of the application when a certain
    event (intended or unintended) occurs. To display such information, we need an
    external window that can be dismissed by the user once he/she has acknowledged
    the information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt comes with this functionality, and it''s all residing in the `QMessageBox`
    class. There are several types of message box you can use in Qt; the most basic
    one uses just a single line of code, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three parameters you need to provide for this function. The first
    one is the parent of the message box, which we have set as the main window. The
    second parameter is for the window title, and the third parameter is for the message
    we want to deliver to the user. The preceding code will produce the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b92e3f2-4363-46db-aa12-afc721e665e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The appearance shown here is running on a Windows system. The appearance may
    look different on different operating systems (Linux, macOS, and so forth). As
    you can see, the dialog box even comes with an icon located before the text. There
    are a few types of icon you can use, such as information, warning, and critical.
    The following code shows you the code for calling all the different message boxes
    with icons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84024277-2f97-4651-b89e-b3a4e9528f8a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you don''t need any icons, just call the `QMessageBox::about()` function
    instead. You can also set the buttons you want by picking from a list of standard
    buttons provided by Qt, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will produce the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e95537ee-6b14-4da6-9e38-af1eaaf6fda3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since these are the built-in functions provided by Qt to create message boxes
    with ease, it doesn''t give developers the freedom to fully customize a message
    box. However, Qt does allow you to create your message boxes manually using another
    method, which is much more customizable than the built-in method. It takes a couple
    more lines of code, but is still pretty simple to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will produce the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f79a9076-7112-4fa4-bed4-5bc3b9bc5628.png)'
  prefs: []
  type: TYPE_IMG
- en: '*It looks just the same*, you''re telling me. What about adding our own icon
    and customized buttons? No problem with that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04e2e8f6-5139-4bfb-aced-564cedaf5d2d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding code example, I have loaded the question icon that comes with
    Qt, but you can also load your own icon from the resource file if you intended
    to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the project now, and you should be able to see this fantastic
    message box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce170a25-75c4-448e-ab26-b82691eda029.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you have understood how to create your own message boxes, let's proceed
    to learn about the event system that comes with the message box.
  prefs: []
  type: TYPE_NORMAL
- en: When a user is presented with a message box with multiple different choices,
    he/she would expect a different reaction from the application when pressing a
    different button.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when a message box pops up and asks the user whether they wish
    to quit the program or not, the button Yes should make the program terminate,
    while the No button will do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt''s `QMessageBox` class provides us with a simple solution for checking the
    button event. When the message box is being created, Qt will wait for the user
    to pick their choice; then, it will return the button that gets triggered. By
    checking which button is being clicked, the developer can then proceed to trigger
    the relevant event. Let''s take a look at the example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will produce the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ec73206-502c-4051-aa2a-ba175f839f16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you prefer the manual way to create your message box, the code for checking
    the button event is slightly longer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Even though the code is slightly longer, the basic concept is pretty much the
    same—the clicked button will always be able to be retrieved by the developer for
    triggering the appropriate action. This time, however, instead of checking the
    enumerator, Qt directly checks the button pointer instead, since the preceding
    code does not use the built-in standard buttons from the `QMessageBox` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the project, and you should be able to get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c49eca5-6076-4609-9e1c-e3f2e7a1a762.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For more information regarding the dialog boxes, please visit the API documents
    located at the following link: [http://doc.qt.io/qt-5/qdialog.html](http://doc.qt.io/qt-5/qdialog.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating File Selection Dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have covered the topic about message boxes, let's also learn about
    the other type of dialog—the File Selection Dialog. The File Selection Dialog
    is also very useful, especially if your application frequently deals with files.
    It is extremely unpleasant to ask users to key in the absolute path of the file
    they wanted to open, so the File Selection Dialog is very handy in this kind of
    situation.
  prefs: []
  type: TYPE_NORMAL
- en: Qt provides us with a built-in File Selection Dialog that looks exactly the
    same as the one we see in our operating system, and therefore, it won't feel unfamiliar
    to the users. The File Selection Dialog essentially only does one thing—it lets
    the user pick the file(s) or folder they want and return the path(s) of the selected
    file(s) or folder; that's all. In fact, it is not in charge of opening the file
    and reading its content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we can trigger the File Selection Dialog. First, open up
    `mainwindow.h` and add in the following header files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open up `mainwindow.cpp` and insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s that simple! Build and run the project now, and you should get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb0d3f1e-1e61-4d02-b280-9a4935ead609.png)'
  prefs: []
  type: TYPE_IMG
- en: If the user has selected a file and pressed Open, the `fileName` variable will
    be filled with the absolute path of the selected file. If the user clicked the
    Cancel button, the `fileName` variable will be an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The File Selection Dialog also contains several options that can be set during
    the initialization step. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three things that we have set in the preceding code they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The window title of the File Selection Dialog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default path that the users see when the dialog is being created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File type filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file type filter is very handy when you only allow the users to select a
    specific type of file (for example, only JPEG image files) and hide the rest.
    Besides `getOpenFileName()`, you can also use `getSaveFileName()`, which will
    allow the user to specify a filename that does not already exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information regarding the File Selection Dialog, please visit the
    API documents located at the following link: [http://doc.qt.io/qt-5/qfiledialog.html](http://doc.qt.io/qt-5/qfiledialog.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Image scaling and cropping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we learned about the File Selection Dialog in the previous section, I'd
    thought we should learn something fun this time!
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, let''s create a new Qt Widgets Application. Then, open up `mainwindow.ui`
    and create the following user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/867c3332-9f87-40c0-933b-05190c15dd8e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s dissect this user interface into three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Top—Image preview:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, add a Horizontal Layout to the window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, add a Label widget into the Horizontal Layout we just added, then set
    the text property to `empty`. Set both the label's minimumSize and maximumSize
    properties to 150x150\. Finally, set the frameShape property under the QFrame
    category to Box.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add two Horizontal Spacers to the sides of the label to make it centered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Middle—Sliders for adjustments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a Form Layout to the window, below the Horizontal Layout we just added previously
    in step 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add three Labels to the Form Layout, and set their text property to `Scale:`,
    `Horizontal:`, and `Vertical:` respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add three Horizontal Sliders to the Form Layout. Set the minimum property to
    `1` and maximum to `100`. Then, set the pageStep property to `1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the value property of the scale slider to `100`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bottom—Browse button and Save button:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a Horizontal Layout to the window, below the Form Layout we previously added
    during step 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add two Push Buttons to the Horizontal Layout and set their text property to
    `Browse` and `Save` respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, delete the Menu Bar, Tool Bar, and Status Bar from the central widget.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have created the user interface, let''s dive into the coding! First,
    open up `mainwindow.h` and add in the following headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, add the following variables to `mainwindow.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, go back to `mainwindow.ui` and right-click on the Browse button, followed
    by selecting Go to slot. Then, a window will pop up and ask you to select a signal.
    Pick the `clicked()` signal located at the top of the list, and then press the
    OK button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e63f85a0-57c5-4097-a3aa-ddba2adc9e17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A new `slot` function will be automatically added to your source file. Now,
    add the following code to open up the File Selection Dialog when the Browse button
    is clicked. The dialog only lists JPEG images and hides the other files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code checks whether any image has been selected by the user.
    If it has its checks again and see whether the image resolution is at least 150
    x 150\. If no problem is found, we will save the image's pixel map to a pointer
    called `pix`, then save the image size to the `imageSize` variable, and the initial
    drawing size to the `drawSize` variable. Finally, we set the `canDraw` variable
    to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, open up `mainwindow.h` again and declare these two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The first function, `paintEvent()`, is a virtual function that automatically
    gets called whenever Qt needs to refresh the user interface, such as when the
    main window is being resized. We''ll override this function and draw the newly
    loaded image onto the image preview widget. In this case, we''ll call the `paintImage()`
    function within the `paintEvent()` virtual function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we''ll write the `paintImage()` function in `mainwindow.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This function does two things—if we don't set the `fileName` variable, it will
    proceed to draw the image on top of the image preview widget, otherwise, it will
    crop the image based on the dimension of the image preview widget and save it
    to the disk following the `fileName` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll call this function again when the save button is being clicked. This
    time, we''ll set the `fileName` variable as the desired directory path and filename,
    so that the `QPainter` class can save the image correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, right-click on each of the three sliders and select Go to slot. Then,
    select `valueChanged(int)` and click OK.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b605edff-3b8d-4ce0-9661-b08ae23bbb5d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After that, we''ll write the code for the `slot` functions resulting from the
    previous step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The scale slider is basically for users to resize the image to their desired
    scale within the image preview widget. The left slider is for the users to move
    the image horizontally, while the top slider is used by the users to move the
    image vertically. By combining these three different sliders, users can adjust
    and crop the image to their liking before proceeding to upload the image to the
    server, or use it for other purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you build and run the project now, you should be able to get this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b7d67e4-2cc1-434a-87b7-8e09130c019a.png)'
  prefs: []
  type: TYPE_IMG
- en: You can click on the Browse button to select a JPG image file to load. After
    that, the image should appear on the preview area. You can then move the sliders
    around for adjusting the cropping size. Once you're satisfied with the result,
    click the Save button to save your image in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do check out the sample code that comes together with this book if you want
    to learn more about it in detail. You can find the source code at the following
    GitHub page: [https://github.com/PacktPublishing/Hands-On-GUI-Programming-with-C-QT5](https://github.com/PacktPublishing/Hands-On-GUI-Programming-with-C-QT5)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Input and Output (I/O)** are the essence of modern computer software. Qt
    allows us to display our data in many different ways that are both intuitive and
    engaging to the end users. Other than that, the event system that comes with Qt
    makes our life as a programmer a lot easier, as it tends to automatically capture
    the user inputs through the powerful signal-and-slot mechanism and in-response
    triggering custom-defined behaviors. Without Qt, we would have a hard time trying
    to figure out how to reinvent the proverbial wheel, and might eventually end up
    creating a less user-friendly product.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to make use of the fantastic features that
    are provided by Qt—view widgets, dialog boxes, and file selection dialogs used
    to display important information to the users. Furthermore, we also went through
    a fun little project that taught us how to scale and crop an image using Qt widgets
    for user inputs. In the next chapter, we will go for something more advanced (and
    fun too), which is creating our very own web browser using Qt!
  prefs: []
  type: TYPE_NORMAL
