- en: CircleCI UI Logging and Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered CircleCI CLI commands in depth and showed
    you some techniques to automate tasks in CircleCI. In this chapter, we will cover
    the Job Log in depth and explain the run steps in more detail. We will explain
    the workflows concept and show you how to use the CircleCI API to find the most
    recent builds for a project. We will look at how to debug a slow job by implementing
    caching in a build, and will finish by using some troubleshooting techniques to
    run a build with a local config YML script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Job log overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging slow builds in CircleCI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging and troubleshooting techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we cover some concepts about using RESTful APIs and will use
    the `curl` utility to make REST calls, so it would be good to understand what
    an API is and how to use a REST client such as `curl`. It would also be helpful
    to have a rudimentary understanding of the Unix programming environment and it
    would be beneficial to understand what scripting is and what a Bash environment
    is.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/packtci/circleci-jobs-example](https://github.com/packtci/circleci-jobs-example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/packtci/go-template-example-with-circle-ci](https://github.com/packtci/go-template-example-with-circle-ci)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Job log overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The job log in CircleCI is different than in Travis CI, as each step in each
    job is run in a separate non-login shell and CircleCI sets some smart defaults
    for each step in the job.
  prefs: []
  type: TYPE_NORMAL
- en: Run steps in job with a default build job
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a new repository to demonstrate multiple jobs in the default
    build job. The repository will be called `circleci-jobs-example` ([https://github.com/packtci/circleci-jobs-example](https://github.com/packtci/circleci-jobs-example)) and
    will have multiple run declarations in the build job. We will be using Node.js
    as our programming language of choice for demonstration purposes. Remember that
    we need to add the new project to CircleCI so that it can become aware of our
    project. In the previous chapters, we added the projects using the CircleCI web
    UI, but let's use the CircleCI API to add our new project to CircleCI.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a project to CircleCI via the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned how to work with the CircleCI API in [Chapter 13](98200aa9-aa3f-40d8-9f9e-d675fc2c67b8.xhtml), *CircleCI
    CLI Commands and Automation*, so please read the *Working with the CircleCI API* section
    of that chapter for more details on working with the API. If you already read
    this, then you will already have an API token that you can use. The API endpoint
    to follow for new projects on CircleCI ([https://circleci.com/docs/api/v1-reference/#follow-project](https://circleci.com/docs/api/v1-reference/#follow-project))
    shows that you need to make a `POST HTTP` request and add your API token as a
    query string parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Using curl as a REST client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already used `curl` as a REST client throughout the book, so you should
    be familiar with how to use it by now. We will be making a `POST` request to the
    following endpoint `https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/follow?circle-token=:token`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we use an environment variable called `CIRCLECI_API_TOKEN_GITHUB` that
    is set in our local environment, and we get the following response from the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Parse build_url attribute from the JSON response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s save this response into a new file we call `circleci-jobs-example-follow.json`
    by using the cat utility in a Terminal shell session, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s use the `jq` ([https://stedolan.github.io/jq/manual/](https://stedolan.github.io/jq/manual/))
    and find the `build_url` attribute in the JSON payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This command returns the following build URL: `https://circleci.com/gh/packtci/circleci-jobs-example/1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can either open a browser and paste this URL in or you can use a command-line
    utility available on your operating system. We will use the `open` utility in
    macOS like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will open the default browser in macOS and use the URL
    that you provide. In Linux, you might be able to use `xdg-open`, `gnome-open`,
    or `kde-open` depending on the OS that you have installed. Either way you can
    simply open a browser and paste the entry for the build URL.
  prefs: []
  type: TYPE_NORMAL
- en: CircleCI Web UI job log analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we open the URL for the new job that we triggered via the API, the first
    part of the UI looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2cdea96c-0964-4ef7-8259-cff00e265fca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice here that the top part shows basic information such as the commit SHA
    hash, the contributor information, and other background information. If you scroll
    down further in the job log, you will see the steps run in each part of the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fc15a2a7-11ff-4ded-a001-8c0a39c8480a.png)'
  prefs: []
  type: TYPE_IMG
- en: The build took 9 seconds to complete and notice here that each step in the build
    has its own section that is conveniently collapsed. You simply click on each section
    to get the details of the step. The names of each step correspond to the `name`
    field in the config YML script.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the name of the multi-line command used the name of the full command
    as its name.
  prefs: []
  type: TYPE_NORMAL
- en: 'This was the entry for the multi-line command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we expand one of the steps we will see the following entries common to each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f1f58407-568f-44d3-ad07-b4c9e05ccd51.png)'
  prefs: []
  type: TYPE_IMG
- en: The **Shebang** line `#!/bin/bash -eo pipefail` has set some sensible defaults
    for the non-login shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Bash option `-e` means that the script should exit if a statement returns
    a non-true value. The Bash option `-o  pipefail` means use the error status of
    the first failure, rather than that of the last item in a pipeline. Instead of
    adding these options in the Shebang line, you could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at another step in the job, we see the same thing is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9eea6aec-a651-45d8-b7d5-66c481852af3.png)'
  prefs: []
  type: TYPE_IMG
- en: CircleCI does this in each step of a job because it helps us troubleshoot issues
    that occur when writing shell scripts, and it helps promote best practices when
    writing shell scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a command that can fail that will report errors in the
    wrong spot of a build when using a Unix pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this pipeline, we list all the containers that are running, exited, or terminated
    for some reason and then pipe this into the `grep` utility and exclude any entries
    that have the text `busybox:latest` and then pipe this into the `awk` utility
    and only print the first column. We finally pipe this back into `grep` and exclude
    the text `CONTAINER`. This pipeline could fail at any chain of the pipeline but
    because we used the option `set -o pipefail` the script will fail on the first
    command that returns a non-true option. This is helpful because the default behavior
    is to report the last item in the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of the run declaration commands are that they are executed using
    non-login shells by default. This means that you must explicitly source any hidden
    files such as **dotfiles** as part of the command that is run, or else you risk
    not having environment variables ready to use as you might expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to illustrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, notice that the exit code is printed for each run declaration in the
    upper-right side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ab1f0883-87bf-4e05-bfa7-c5034ef1a511.png)'
  prefs: []
  type: TYPE_IMG
- en: You can also see a helpful button in the top-right corner, which will scroll
    you further down into the particular run step you are interested in seeing.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for environment variable safe usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important that you do not add secrets inside of the `.circleci/config`
    YML script file. If you do, you may leak secret information on the job log that
    may be publicly accessible. The full text of the `config.yml` is visible to developers
    with access to your project on CircleCI, so instead store your secrets and/or
    keys in Project or Context settings in the CircleCI app. Running scripts within
    configuration may expose secret environment variables so be careful when using
    the `set -o xtrace / set -x` in your run steps as they might expose environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note is that all environment variables are encrypted using Hashicorp
    Vault ([https://www.vaultproject.io/](https://www.vaultproject.io/)) and environment
    variables are encrypted using AES256-GCM96 and are unavailable to any CircleCI
    employees.
  prefs: []
  type: TYPE_NORMAL
- en: Run steps in job with workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the Circle CI Documentation on **workflows** ([https://circleci.com/docs/2.0/workflows/](https://circleci.com/docs/2.0/workflows/)),
    a workflow is a set of rules for defining a collection of jobs and their run order.
    Workflows support complex job orchestration using a simple set of configuration
    keys to help you resolve failures sooner.
  prefs: []
  type: TYPE_NORMAL
- en: We will use workflows in order to separate our jobs into more appropriate sections
    and then also to take advantage of the fact that some scripts are independent
    of each other and can be run separately. We can speed up our build process by
    using workflows in CircleCI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s think of the parts of the job that can be broken into separate steps
    in our build process. We can break the dependency step into a separate part of
    the build and then we can just collapse the individual steps we ran for the three
    tests into one step called test. Remember that the steps look like this in the
    config YML script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last step, we have the command `npm test` and this command references
    the following command specified in the `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this command runs all the tests already and then reports coverage
    using the NYC code coverage utility. The last command generates a Cobertura XML
    report that we will use later in the chapter. We will now rewrite the series of
    steps into their own field called `test`, and it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice here that I gave a more appropriate name to the collapsed command and
    also notice that we can use a multi-line command in the `command` field itself
    using the pipe (`|`) operator.
  prefs: []
  type: TYPE_NORMAL
- en: We will add a deploy section like we did in [Chapter 13](98200aa9-aa3f-40d8-9f9e-d675fc2c67b8.xhtml),
    *CircleCI CLI Commands and Automation*, which will deploy our application into
    **Heroku** ([https://dashboard.heroku.com/apps](https://dashboard.heroku.com/apps)).
    If you don't understand what Heroku is then please read [Chapter 11](f2319c39-b2e4-40cb-b1bb-53daa589776b.xhtml),* Travis
    CI UI Logging and Debugging*, and read the *Travis CI deployment overview and
    debugging* section for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a workflows section to the config YML script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will add the `workflows` section to the bottom of our config YML script,
    but we could also add it to the beginning of our config YML script. Here is the
    updated config YML script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we finish updating the config YML script, we should ensure that our config
    YML script is still valid by using CircleCI CLI, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/172ae51b-27ce-4f50-87c0-b7d5ba3c636f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It looks like we have an issue in our config YML script in line 19:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is actually a subtle bug in our config YML script because we did not properly
    indent the multi-line command and so CircleCI does not know where our multi-line
    command starts. Here is the updated config YML script section now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s run the CircleCI CLI validation again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d30bf085-04b1-480d-95c6-d9cd715105b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our config YML script is valid, so now let''s commit this into source control
    by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/02d14c9b-c808-4609-8163-a271dfac267a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice here that we gave a descriptive commit message which is good practice
    to do in version control if anything you are working with has a particular tag,
    such as JIRA for instance; you could add it like this for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using the CircleCI API to find the most recent build URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can certainly use the CircleCI web app and click the `workflows` section
    and find our most recent build, but let's use the CircleCI API instead and use
    `jq` to parse the JSON response payload as we have done before for other API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a command that will pipe output from the `/recent-builds` API endpoint to
    `jq` and return the first `build_url` from the array of objects, which will be
    the most recent build, and then pipe that into the system clipboard. We can see
    the shape of the JSON in the recent build project in the [https://circleci.com/docs/api/v1-reference/#recent-builds-project](https://circleci.com/docs/api/v1-reference/#recent-builds-project) documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the following URL to the Terminal: [https://circleci.com/gh/packtci/circleci-jobs-example/6](https://circleci.com/gh/packtci/circleci-jobs-example/6).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s go to this URL and look at the recent build; we will notice that
    the build failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5f71ae09-eeff-457c-af70-1d010502b50d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The build failed because we didn''t set the necessary environment variables
    that our config YML script is referencing, namely `HEROKU_API_KEY` and `HEROKU_APP_NAME`.
    We covered how to set project-level environment variables in [Chapter 13](98200aa9-aa3f-40d8-9f9e-d675fc2c67b8.xhtml),
    *CircleCI CLI Commands and Automation*, but we only need to copy over the project
    environment-level variables. CircleCI has an easy way to do that if the environment
    variables are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/23f2ea2c-3ec2-430c-ae93-6776446ea6ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click the Import Variables button and then enter the project you want to copy,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4fdd3ecd-aff0-4bd4-8998-fa4fc861d325.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice here that I only checked the `HEROKU_API_KEY` environment variable,
    and I will manually set the `HEROKU_APP_NAME` as it will be different for the
    `circleci-jobs-example` ([https://github.com/packtci/circleci-jobs-example](https://github.com/packtci/circleci-jobs-example))
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/65efefb3-627d-43a0-ada8-b3c12adf66e1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, with these environment variables set, let''s retry the same build using
    the Retries the build, returns a summary of the new build [https://circleci.com/docs/api/v1-reference/#retry-build](https://circleci.com/docs/api/v1-reference/#retry-build)
    API endpoint. We will use `curl` to make a call to the endpoint like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can verify that the build was fixed by copying the `build_url` value
    that is returned to standard output, which is [https://circleci.com/gh/packtci/circleci-jobs-example/7](https://circleci.com/gh/packtci/circleci-jobs-example/7):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9cef3f2d-bb60-4bbb-aef6-60d263a034fd.png)'
  prefs: []
  type: TYPE_IMG
- en: Debugging slow builds in CircleCI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A build may be slow in CircleCI due to a myriad of reasons. Let''s look at
    a workflow example for `go-template-example-with-circleci` ([https://circleci.com/workflow-run/533ee47a-a990-4679-826b-7b24221df2ca](https://circleci.com/workflow-run/533ee47a-a990-4679-826b-7b24221df2ca)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/981fe466-033f-40b6-b96e-5f0c36cab983.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In particular, notice that the integration job took over a minute to finish
    and the deploy job took over a minute to finish as well, which is making the build
    take 3 minutes and 20 seconds to complete. If we click on the integration job,
    we see the following steps in the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/483ce70d-5733-4a96-b693-88ad8ebf0fd2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice here that the `npm install` took 1 minute and 3 seconds to finish. Let''s
    open up the run step call `npm install` for further details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/61089a41-181b-4d56-984c-dacca67144b4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The only dependency we have is for `cypress.io`, but we are not caching this
    dependency so it will run this step every time. CircleCI has a way for us to cache
    our node dependencies by utilizing two field declarations called `save_cache`
    ([https://circleci.com/docs/2.0/configuration-reference/#save_cache](https://circleci.com/docs/2.0/configuration-reference/#save_cache))
    and `restore_cache` ([https://circleci.com/docs/2.0/configuration-reference/#restore_cache](https://circleci.com/docs/2.0/configuration-reference/#restore_cache))
    respectively. Let''s update the config YML script to use this caching strategy
    for the integration build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice here that we have placed the `restore_cache` step before the `npm install`
    and then placed the `save_cache` step after the `npm install` step. We also use
    a key field in both fields. The key value is immutable and we are using a prefix
    of `v2` as a way to version our cache key values and then getting the checksum
    for the `package.json` file. If we want to invalidate the cache for any changes,
    we can simply increment the cache value value by one, `v3` for example. Also notice
    that we have a paths field and we specify the paths to be the `~/.npm` and `~/.cache` directories.
    The cypress test runner expects the binary to be saved into a directory like this,
    or else it will throw an error. Let''s push this change up to source control and
    trigger a new build and look at the job log. Now let''s use a call to the recent
    builds API endpoint and copy the URL and see how the build went:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to copy the `build_url` entry that gets printed onto standard
    output and paste the URL into a browser. The `build_url` will open the current
    build, and from this page we can easily navigate to the workflow for that particular
    job by clicking a link that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/16b0eb39-214c-4e20-883c-3194eaf44328.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can click on the `build_integration_and_deploy` link under the Workflow
    label to get to the workflow. We now have the following steps in the integration
    build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/484d1a04-bfb7-4def-a4c4-2b2f884f2ede.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we expand the Restoring Cache dropdown we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6bcfdf16-3ead-403c-ba75-cb4eaeb4c0c9.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice here that no cache was found, which is expected since this is the first
    run of the build with this step added.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we expand the Saving Cache button we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9ce4f386-d53e-4f5f-9c3b-b986d6a32341.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice here that a cache archive was created and stored in the `node_modules`
    path as we specified the paths field in the config YML script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a simple text change in the `README.md` file and commit the change
    to trigger a new build. We will find the latest build using the API as we have
    been doing. Now let''s look at the new job log for the integration job:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/494a1dac-4c9c-4710-aa41-8f50406f766c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that the build went from 1 minute 20 seconds to 33 seconds. If we open
    the Restoring Cache dropdown, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c63045ce-4cb1-47e1-a851-643647b5ba9c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s look at the Saving Cache step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/28cf1c30-fdd9-4363-b4c9-ce237f4839c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice here that it skipped the cache generation as it was able to find the
    cache that we saved from the previous build.
  prefs: []
  type: TYPE_NORMAL
- en: Logging and troubleshooting techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can troubleshoot a problematic config YML script without having to make Git
    commits by using the CircleCI API. One technique that we can do is to create another
    folder and place a duplicate of our config YML script into it and then use this
    YML script as our debugging script. Once we can verify that the YML script is
    working correctly we can update the original YML script. This is useful since
    we won't be clogging up the Git history with troubleshooting commits but instead
    we will hit the CircleCI API directly.
  prefs: []
  type: TYPE_NORMAL
- en: Running a build using a local config YML script to troubleshoot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say that we want to experiment with storing build artifacts, such as code
    coverage on a project. At the moment we are generating a coverage report but it
    is not being saved during the builds for us to view a coverage report. This is
    a good use case of creating a separate config YML script to test this new functionality.
    Let's store the coverage artifacts from the `circleci-jobs-example` ([https://github.com/packtci/circleci-jobs-example](https://github.com/packtci/circleci-jobs-example))
    project and let's also update the test job to cache the node dependencies, as
    we learned how to do in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run this command to copy the contents of the `.circleci` directory and create
    a new directory in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will use the `store_and_cache_experiment` folder to run our local config
    YML script experiments. Here are the changes that we are going to make for the
    config YML script in the `store_and_cache_experiment` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We added the `save_cache` and `restore_cache` declaration changes and also
    added the `store_artifacts` declaration changes. Let''s verify that the config
    YML script is still valid with the `circleci config validate` command. Now, in
    order to test these changes in our local configuration without having to make
    a Git commit, we can use the CircleCI API and provide our local config YML script
    in the body of our request and reference a recent Git commit. We can get the latest
    Git commit by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7e31760b-a7e9-492f-bab4-01f49c6b1e28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So now we have a revision number that we can use for the API call that we are
    going to make. Here is the command that we will use to debug the changes in our
    new config YML script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The first option, `--user`, takes our API token that is saved in an environment
    variable and then the `:` after it means that there is no password that follows.
    The next option, `--request`, is the `HTTP POST` verb that we are specifying.
    The next option of `--form` revision is where we put the Git revision number that
    we got earlier and then in the next option we specify the `config.yml` script.
    We specify a form value of false for notify and then we provide the URL. Here
    we specify the version control system provider of GitHub and then our `packtci`
    username, followed by the project name, and then tree and then finally our branch
    name. Then we pipe this into the `jq` utility and parse out the `build_url`. Here
    is the API endpoint for clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After we make the REST call, we should get a JSON response that gives us a
    build URL for us to look at, and here is the build URL that we get: [https://circleci.com/gh/packtci/circleci-jobs-example/8](https://circleci.com/gh/packtci/circleci-jobs-example/8).
    If we look at this new build in the CircleCI Web UI, we see that it passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/da630c80-75f7-43a7-a17d-0af9bc4059b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s remove the troubleshooting directory and config YML script and shell
    script and copy over the config YML script into the `.circleci` directory, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we click on the current build and then go to the workflows link, we
    will see that the step Uploading artifacts was added to the job; this is what
    it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/de859dc7-d5c8-4fe4-af22-1edec5341768.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now scroll up and click on the Artifacts tab and see that an artifact
    has been saved on the build, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bf5c7d35-b257-405b-850b-bcc6cef5b3c3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we click on `index.html`, we will be redirected to a nice coverage report
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5c4b6870-944c-44cc-8f5e-3baa2ee7e5b3.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the job log in depth and showed you how to use the
    CircleCI API to add projects. We showed you how to analyze the job log and explained
    in more detail what a workflow is in CircleCI. We looked at how to use the CircleCI
    API to find the most recent build. We then looked at how to debug slow builds
    in Circle CI and wrapped up by showing you how to use a local config YML script
    to experiment with new changes to the CircleCI YML script.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at some best practices with continuous integration/continuous
    delivery and look at some patterns of configuration management, in particular
    secrets management, and present some checklists when implementing CI/CD in software
    companies.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What was the API endpoint that we used to follow new projects in CircleCI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can the cat utility be used to create new files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you run a multi-line command in the CircleCI config YML script?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are there any security vulnerabilities when using the `set -x` or execution
    tracing in scripts in CircleCI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What was the CLI command we used to validate our config YML script?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can environment variables be imported from other projects in CircleCI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What declarations did we use to cache our dependencies in CircleCI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To find out more about debugging and troubleshooting, and other useful information,
    please read the official CircleCI documentation: [https://circleci.com/docs/2.0/](https://circleci.com/docs/2.0/).
  prefs: []
  type: TYPE_NORMAL
