- en: Making Your Marvel Gallery Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already seen the most important Kotlin features that allow us to make
    Android development easier and more productive, but it is hard to understand the
    whole picture just by looking at the pieces. This is why, in this chapter, we
    will build a whole Android application written in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: It was a tough decision to choose what application should be implemented in
    this chapter. It has to be short and simple, but at the same time it should utilize
    as many Kotlin features as possible. At the same time, we wanted to minimize the
    number of used libraries, because it is a book about Android development in Kotlin,
    not about Android libraries. We wanted to make it look as good as possible, but
    we also wanted to avoid implementation of custom graphic elements, because they
    are usually complex and do not really provide benefits from a Kotlin perspective.
  prefs: []
  type: TYPE_NORMAL
- en: We have finally decided to make a Marvel Gallery application--a small app which
    we can use to find our favorite Marvel characters and display their details. All
    data is provided from the Marvel website by their API.
  prefs: []
  type: TYPE_NORMAL
- en: Marvel Gallery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s implement our Marvel Gallery application. This application should allow
    the following use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: After starting the application, the user can see a gallery of characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After starting the application, the user can search for a character by its name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user clicks on a character picture, there is a profile displayed. The
    character profile contains character name, photo, description, and its occurrences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are three use-cases that describe the main functionalities of the application.
    In the next sections, we are going to implement them one after another. If you
    are lost during this chapter, remember that you can always take a look at the
    complete application on GitHub ( [https://github.com/MarcinMoskala/MarvelGallery](https://github.com/MarcinMoskala/MarvelGallery)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand better what we want to build, let''s look at some screenshots
    from the final version of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to use this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter shows all steps and code necessary to build an application. Its
    purpose is to show the step-by-step process of this application development. When
    you are reading this chapter, concentrate on the development process and try to
    understand what the purpose of presented code is. You don't need to fully understand
    layouts and you don't have to understand unit test definitions as long as you
    understand what they are doing. Concentrate on application structure and Kotlin
    solutions that are making the final code simpler. Most solutions were already
    described in previous chapters, so they have only a brief description. The value
    in this chapter is that their usage is presented in the context of a concrete
    application.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the application code from GitHub ( [https://github.com/MarcinMoskala/MarvelGallery](https://github.com/MarcinMoskala/MarvelGallery)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: 'On GitHub, you can see the final code, download it, or you can clone it to
    your computer using Git:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The application also includes UI tests written in **Espresso** , but they are
    not presented on this chapter to make it simpler for readers who are not proficient
    in Espresso usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each section of this chapter has a corresponding Git branch on this project,
    so if you want to see how the code looks at the end of the section then you can
    just switch to the corresponding branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, locally, after you clone the repository, you can check out the corresponding
    branch using the following Git command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you have an electronic version of this book and you want to make the whole
    application by copy and pasting parts of the code then you can do it, but remember
    to place files in the folders corresponding to the package. This way, you will
    keep a clean structure in the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if you place code from the book in another folder, there will be
    a warning displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can intentionally place a file in any folder, because the second fix proposition
    is to move the file into the path corresponding to the defined package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00056.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can use it to move your file into the correct location.
  prefs: []
  type: TYPE_NORMAL
- en: Make an empty project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can start implementing functionalities, we need to create an empty
    Kotlin Android project with a single activity, `MainActivty` . This process was
    described in [Chapter 1](text00021.html) *,* *Beginning your Kotlin Adventure*
    . Therefore, we don''t need to describe it deeply, but we will show what the steps
    are in Android Studio 3.0:'
  prefs: []
  type: TYPE_NORMAL
- en: Set name, package, and location for the new project. Remember to tick Include
    Kotlin support option:*.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can choose other minimal Android version, but in this example, we are going
    to set API 16:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Choose a template. We don't need any of these templates so we should start from
    Empty Activity *:*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Name newly created activity. We can keep the first view named `MainActivity`
    *:*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For Android Studio prior to 3.x, we need to follow slightly different steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a project from template with empty *Activity* .
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Configure Kotlin in the project (for example, *Ctrl* /*Cmd* + *Shift* +
    *A* and Configure Kotlin in project ).
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Convert all Java classes to Kotlin (for example, in `MainActivity` *Ctrl/Cmd+Shift+A*
    and Convert Java file to Kotlin file ).
  prefs: []
  type: TYPE_NORMAL
- en: 'After these steps, we will have a Kotlin Android application with an empty
    Activity created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Character gallery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement a single use case--after starting the application,
    the user can see a gallery of characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a pretty complex use case because it requires view to be presented,
    network connection with API and business rules implementation. Therefore, we will
    split it into the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: View implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication with API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business logic implementation of character display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such tasks are much easier to implement. Let's implement them one after another.
  prefs: []
  type: TYPE_NORMAL
- en: View implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with View implementation. Here, we are going to define what the
    list of characters will look like. For testing purposes, we are also going to
    define a few characters and display them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with `MainActivity` layout implementation. We will use `RecyclerView`
    to show a list of elements. The `RecyclerView` layout is distributed in a separate
    dependency, which we have to add to the `app` module `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `android_support_version` instance is a variable which is not yet defined.
    The reason behind it is that the version should be the same for all Android support
    libraries and when we extract this version number as a separator variable then
    it is easier to manage. This is why we should replace the hard coded version for
    each of the Android support libraries with a reference to `android_support_version`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And we have to set support library version value. Good practice is to define
    it in the project `build*.* gradle` file inside `buildscript` , after the `kotlin*_*
    version` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can start implementation of `MainActivity` layout. This is the effect
    that we want to achieve:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will keep character elements on `RecyclerView` packed into `SwipeRefreshLayout`
    to allow swipe-refresh. Also, to fulfill Marvel copyright, there needs to be a
    presented label that is informing that data is provided by Marvel. The layout
    `activity_main` (`res/layout/activity_main.xml` ) should be replaced with following
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add a copyright notice to strings (`res/values/strings.xml` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a preview:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to define the item view. We would like each element to be
    always square. To do this, we need to define a view which will preserve the square
    shape (place it in `view/views` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using `JvmOverloads` annotation, we've avoided telescoping constructors that
    are normally used to define a custom view in Android. This was described in [Chapter
    4](text00088.html) , *Classes and Objects* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are forcing the element to have always the same height as width.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With `SquareFrameLayout` , we can define the layout of gallery items. This
    is what we want it to look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to define `ImageView` to display the character image, and `TextView`
    to display its name. While `SquareFrameLayout` is actually `FrameLayout` that
    has fixed height, its children elements (image and text) are by default placed
    one above another. Let''s add layout into `item_character.xml` file in `res/layout`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we are also using values such as `element_padding` defined in `dimens`
    . Let''s add them to the `dimen.xml` file in `res/values` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, each element needs to display the name of the character and
    its image. Therefore, the model of a character needs to contain these two properties.
    Let''s define a simple model for a character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To display a list of elements using `RecyclerView` , we need to implement both
    a `RecyclerView` list and an item adapter. A list adapter is used to manage all
    elements in a list, while an item adapter is an adapter for a single item type.
    Here, we need only one item adapter, because we display a single type of items.
    It is, however, good practice to assume that in future there might be other kind
    of elements on this list, for example, comics or ads. The same with the list adapter--we
    need only one in this example, but in most projects there is more than a single
    list and it is better to extract common behavior into a single abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this example is designed to present how Kotlin can be used in larger
    projects, we will define an abstract list adapter, which we will name `RecyclerListAdapter`
    , and an abstract item adapter, which we will name `ItemAdapter` . Here is the
    `ItemAdapter` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We need to pass a holder as a type parameter to allow direct operations on its
    fields. The holder is created in `onCreateViewHolder` so we know that its type
    will be always type parameter `T` . Therefore, we can cast the holder to `T` on
    `bindViewHolder` and use it as a receiver object for `onBindViewHolder` . Suppression
    `@Suppress("UNCHECKED_CAST")` is here just to hide the warning while we know that
    we can securely cast in this situation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Function used to create view holder. In most cases, it will be a single expression
    function that is just calling a constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `onBin+dViewHolder` function, we will set all values on item view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the definition of `RecyclerListAdapter` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Class is `open` instead of `abstract` because it can be initialized and used
    without any children. We define children to allow us to define custom methods
    for different lists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We keep items in list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will use layout to distinguish item type. Because of it, we cannot use two
    item adapters with the same layout on the same list, but this solution is simplifying
    a lot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Methods are overriding methods of `RecyclerView.Adapter` , but they also use
    `final` modifier to restrict their override in children. All list adapters that
    are extending `RecyclerListAdapter` should operate on items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define type alias to simplify the definition of any `ItemAdapter` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using the preceding definitions, we can define `MainListAdapter` (adapter for
    character list) and `CharacterItemAdapter` (adapter for item on list). Here is
    the definition of `MainListAdapter` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this project, we do not need any special methods defined in `MainListAdapter`
    , but to show how easy it is to define them, here is presented `MainListAdapter`
    with additional methods to add and delete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the definition of `CharacterItemAdapter` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`MarvelCharacter` is passed by constructor.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`onBindViewHolder` method is used set up views. It was defined as an abstract
    member extension function in `ItemAdapter` and, thanks to that, now we can use
    `textView` and `imageView` explicitly inside its body.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Function `loadImage` is not defined yet. We will define it as an extension function
    a bit later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In view holder, we are binding properties to view elements using the `bindView`
    function that will soon be defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside, we use the functions `loadImage` and `bindView` which are not yet defined.
    `bindView` is a top-level extension function to `RecyclerView.ViewHolder` , which
    is providing a lazy delegate that is providing a view found by its ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to define the `loadImage` extension function that will help us
    to download an image from the URL and place it into `ImageView` . Two typical
    libraries used to such purpose are **Picasso** and **Glide** . We will use Glide,
    and to do it, we need to add a dependency in `build.gradle` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Specify the version in project `build.gradle` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add permission to use the internet in `AndroidManifest` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can finally define the `loadImage` extension function for the `ImaveView`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It is time to define the activity that will display this list. We will use
    one more element, the **Kotlin Android extensions** plugin. It is used to simplify
    access to view elements from code. Its usage is simple--we add the `kotlin-android-extensions`
    plugin in module `build.gradle` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can import a reference to this view inside `Activity` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can access `View` elements directly using its name without using the
    `findViewById` method or define annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use Kotlin Android extensions in all activities in the project. Now
    let''s define `MainActivity` to display a list of characters with images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here we define a temporary list of characters to display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use this window feature because we don't want to display a title.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use `GridLayoutManager` as `RecyclerView` layout manager to achieve a grid
    effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are creating item adapters from characters using the `CharacterItemAdapter`
    constructor reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we can compile the project and we will see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Network definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now, the presented data was hard coded inside the application, but we
    want to use data from the Marvel API instead. To do it, we need to define some
    network mechanisms that will retrieve the data from the server. We are going to
    use **Retrofit** , a popular Android library used to simplify network operations,
    together with RxJava, a popular library used for reactive programming. For both
    libraries, we will use only basic functionalities to make their usage as simple
    as possible. To use them, we need to add following dependencies in the module
    `build.gradle` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And version definitions in project `build.gradle` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We already have internet permission defined on `AndroidManifest` , so we don''t
    need to add it. A simple `Retrofit` definition might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We can keep `retrofit` instance as lazy top-level property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here we define the `baseUrl`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'But there are some additional requirements on Retrofit that need to be matched.
    We need to add converters to use Retrofit together with RxJava, and to send objects
    serialized as JSON. We also need interceptors that will be used to provide headers
    and extra queries needed by Marvel API. This is a small application, so we can
    define all required elements as top-level functions. The full Retrofit definition
    will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Add a converter that allows object JSON serialization and deserialization using
    GSON library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a converter that will allow RxJava2 types (Observable, Single) as observables
    for returned values from network requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add custom interceptors. We need to define all of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s define the needed interceptors. `makeHeadersInterceptor` is used to
    add standard headers for each request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Interceptor is SAM, so we can define it using a SAM constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `makeLoggingInterceptor` function is used to display logs on console when
    we are running the application in debug mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `makeAddRequiredQueryInterceptor` function is more complex, because it
    is used to provide query parameters used by Marvel API to verify the user. These
    parameters need a hash calculated using the MD5 algorithm. It also needs a public
    and private key from the Marvel API. Everyone can generate their own keys at [https://developer.marvel.com/](https://developer.marvel.com/)
    . Once you have generated keys, we need to place them in the `gradle.properties`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Also add the following definitions in the module `build.gradle` in Android
    in the `defaultConfig` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After project rebuild, you will be able to access these values by `BuildConfig.PUBLIC_KEY`
    and `BuildConfig.PRIVATE_KEY` . Using these keys, we can generate query parameters
    that are required by Marvel API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to provide three additional queries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`apikey` : Which is just including our public key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ts` : Which is just containing device time in milliseconds. It is used to
    improve the security of the hash provided in the next query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hash` : Which is calculated as MD5 hash from time stamp, private, and public
    key, one after another in a single `String` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the definition of the function used to calculate the MD5 hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We are using the times extension operator to fill the hash with zeros if it
    is shorter than 32.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have interceptors defined, so we can define actual API methods. The Marvel
    API contains a lot of data models that are representing characters, lists, and
    so on. We need to define them as separate classes. Such classes are called **data
    transfer objects** (**DTOs** ). We will define objects we will need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: For values that might not be provided, we should set a default value. Values
    that are mandatory might be prefixed with `lateinit` instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Retrofit is using reflection to create an HTTP request basing of interface
    definition. This is how we can implement an interface that is defining an HTTP
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With such definitions, we can finally get a list of characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We use a `retrofit` instance to create an object that will make HTTP requests
    according to the `MarvelApi` interface definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create observable ready to send call to API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By `subscribe` , we send an HTTP request and we start listening for a response.
    The first argument is the callback that is invoked when we successfully receive
    a response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Such a network definition could be sufficient, but we might implement it better.
    The biggest problem is that we now need to operate on DTO objects instead of on
    our own data model objects. For mapping, we should define an additional layer.
    The repository pattern is used for this purpose. This pattern is also really helpful
    when we are implementing unit tests, because we can mock the repository instead
    of the whole API definition. This is the definition of repository that we would
    like to have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We are getting a list of DTO elements and mapping it into `MarvelCharacter`
    using a constructor reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To make it work, we need to define an additional constructor in `MarvelCharacter`
    , that takes `CharacterMarvelDto` as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'There are different ways to provide an instance of `MarvelRepository` . In
    most common implementation, a concrete instance of `MarvelRepository` is passed
    to `Presenter` as constructor argument. But what about UI testing (such as Espresso
    tests)? We don''t want to test the Marvel API and we don''t want to make a UI
    test depending on it. The solution is to make a mechanism that will generate standard
    implementation during normal runtime, but it will also allow us to set a different
    implementation for testing purposes. We will make the following generic implementation
    of such mechanism (place it in data):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Instead of defining our own `Provider` , we might use some of Dependency Injection
    libraries, such as **Dagger** or **Kodein** . Dagger usage for such purposes is
    really common in Android development, but we've decided that we won't include
    it in this example to avoid additional complexity for developers who are not experienced
    with this library.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make the `MarvelRepository` companion object provider extend above class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to the preceding definition, we can use the `MarvelRepository` companion
    object to get an instance of `MarvelRepository` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'It will be a lazy instance of MarvelRepositoryImpl, until somebody sets some
    not-null value of the `testingInstance` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Such a construction is useful to allow UI tests using espresso. Its usage for
    element override is present in the project and can be found in GitHub. It is not
    presented in this section to keep it simpler to understand for developers who
    are not proficient in testing. If you are willing to see it, then you can find
    it at [https://github.com/MarcinMoskala/MarvelGallery/blob/master/app/src/androidTest/java/com/sample/marvelgallery/MainActivityTest.kt](https://github.com/MarcinMoskala/MarvelGallery/blob/master/app/src/androidTest/java/com/sample/marvelgallery/MainActivityTest.kt)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Let's finally connect this repository with view by implementation of the business
    logic of the character gallery display.
  prefs: []
  type: TYPE_NORMAL
- en: Business logic implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have both view and repository parts implemented and it is time to finally
    implement the business logic. On this point, we need only to get the character
    list and display it on the list when the user enters the screen or when they refresh
    it. We will extract these business logic rules from view implementation by using
    an architectural pattern known as **Model-View-Presenter** (**MVP** ). Here are
    the simplified rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model** : This is the layer responsible for managing data. Model''s responsibilities
    include using APIs, caching data, managing databases, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Presenter** : The presenter is the middle-man between Model and View, and
    it should include all your presentation logic. The presenter is responsible for
    reacting to user interactions, using and updating the Model and the View.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View** : This is responsible for presenting data and forwarding user interaction
    events to the Presenter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our implementation of this pattern, we will treat Activity as a View, and
    for each view we need to create a presenter. It is good practice to write unit
    tests to check whether business logic rules are implemented correctly. To make
    it simple, we need to hide Activity behind an easy-to-mock interface that is representing
    all possible Presenter interaction with view (Activity). Also, we are going to
    create all the dependencies (such as `MarvelRepository` ) in Activity and deliver
    them to the Presenter via the constructor as objects hidden behind interfaces
    (for example, pass `MarvelRepositoryImpl` as `MarvelRepository` ).
  prefs: []
  type: TYPE_NORMAL
- en: 'In Presenter, we need to implement the following behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: When the Presenter is waiting for a response, loading animation is displayed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the View has been created, a list of characters is loaded and displayed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the refresh method is called, a list of characters is loaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the API returns a list of characters, it is displayed on the view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the API returns an error, it is displayed on the view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we can see, the Presenter needs to get by constructor both View and `MarvelRepository`
    , and it should specify the methods that will be called when the view is created
    or the user request list is refreshed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The View needs to specify the methods used to show the list of characters,
    show error and show progress bar when View is refreshing (define it in `view/main`
    and move `MainActivity` to `view/main` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Before adding logic to a presenter, let''s define first two unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Descriptive names are allowed in Kotlin unit tests, but there will be a warning
    displayed. This suppression is needed to hide this warning.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a list of example characters to display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a view and repository and create a presenter using them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a list of elements is shown, then we should set it as a displayed list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The test is failing when `showError` is called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `getAllCharacters` method is just returning an example list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We call a defined action on the presenter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We check whether the list returned by the repository is the same as the displayed
    list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To simplify the preceding definitions, we could extract `BaseMarvelRepository`
    and `BaseMainView` , and keep example data in a separate class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can simplify the definition of `PresenterActionAssertion` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We start the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will see that they are not passing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The reason is that functionalities are not implemented yet in `MainPresenter`
    . The simplest code that is satisfactory to pass this unit test is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our tests are passing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'But there are two issues with following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: It won't work in Android, because `getAllCharacters` is using a network operation
    and it cannot run on the main thread as in this example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will have a memory leak if the user left the application before loading had
    been finished
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To resolve the first issue, we need to specify on which threads what operations
    should run. The network request should be running on the I/O thread, and we should
    observe on the Android main thread (because we are changing the view in callback):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We specify that the network request should be running in IO thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We specify that callbacks should be started on the main thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While these are common schedulers to show, we can extract them in a top-level
    extension function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Tests are not allowed to access the Android main thread. Therefore, our tests
    will not pass. Also, operations running on a new thread are not what we want in
    unit tests, because we would have problem assertions synchronization. To resolve
    these problems, we need override schedulers before unit tests to make everything
    run on the same thread (add it in `MainPresenterTest` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now unit tests are passing again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another problem is memory leak if the user leaves the application before we
    get a server response. A common solution is to keep all subscriptions in composite,
    and dispose them all when the user is leaving the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In bigger applications, most presenters have some subscriptions. So the functionality
    of collecting subscriptions and disposing them when the user destroys the view
    can be treated as common behavior and extracted in `BasePresenter` . Also, to
    simplify the process, we can make a `BaseActivityWithPresenter` class that will
    hold the presenter behind the `Presenter` interface and call the `onViewDestroyed`
    method when the view is destroyed. Let''s define this mechanism in our application.
    Here is the definition of `Presenter` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the definition of `BasePresenter` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the definition of `BaseActivityWithPresenter` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'To simplify how a new subscription is added to subscriptions, we can define
    a plus assign operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can use both solutions to make `MainPresenter` secure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two `MainPresenter` behaviors have been implemented. It is time to
    move on to the next one--when the API returns an error, it is displayed on the
    view. We can add this requirement as a test in `MainPresenterTest` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple change that will make this test pass is error handler specification
    in the subscribe method in `MainPresenter` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'While `subscribe` is Java method, we cannot use named argument convention.
    Such invocation is not really descriptive. This is why we are going to define
    in the `RxExt.kt` custom subscribe method named `subscribeBy` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'And we will use it instead of subscribe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`subscribeBy` in full version defined for different RxJava typed (such as Observable,
    Flowable, and so on) together with lots of other useful Kotlin extensions to RxJava
    can be found in **RxKotlin** library ([https://github.com/ReactiveX/RxKotlin](https://github.com/ReactiveX/RxKotlin)
    ).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To show and hide list loading, we will define additional listeners to events
    that are always occurring before and after processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'And tests are passing again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `subscribe` method is becoming less and less readable, but we will resolve
    this problem together with another business rule, whose definition is the following--when
    the presenter is waiting for a response, refresh is displayed. Define its unit
    test in `MainPresenterTest` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We expect refresh displayed during network request and when elements are shown,
    but not after processing finishes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We expect refresh to be displayed during a network request and when elements
    are shown, but not after processing finishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the presented version on RxJava2, assertions inside callbacks are not breaking
    the test but displaying an error on the execution report instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00071.jpg)![](img/Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Probably, in future versions, it will be possible to add a handler that is allowing
    to fail a test from inside a callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show and hide list loading, we will define additional listeners to events
    that are always occurring before and after processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'After these changes, all tests are passing again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we have a fully functional presenter, network, and view. Time to connect
    it all and finish implementation of the first use case.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have `MainPresenter` ready to be used in the project. Now we need to use
    it in `MainActivity` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Activity should extend `BaseActivityWithPresenter` and implement `MainView`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bindToSwipeRefresh` and `toast` are not yet implemented.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We make presenter lazily. The first argument is a reference to activity behind
    the `MainView` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to pass events to the presenter using its methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the preceding code, we used two functions that were already described in
    the book, `toast` , used to display toast on the screen, and `bindToSwipeRefresh`
    , used to bind property with visibility of swipe refresh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our application should correctly show a list of characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00074.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our first use case has been implemented. We can move on to the next one.
  prefs: []
  type: TYPE_NORMAL
- en: Character search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another behavior we need to implement is character search. Here is the use case
    definition, after starting the application, the user can search for a character
    by its name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add it, we are going to add `EditText` to the `activity_main` layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add **Android Support Design** library dependency to allow `TextInputLayout`
    usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'And string `search_hint` definition in `strings.xml` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, to keep the label that is informing about Marvel copyright when the keyboard
    is opened, we also need to `adjustResize` to `windowSoftInputMode` in `activity`
    definition in `AndroidManifest` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the following preview:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we have a search field added in `MainActivity` :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00076.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The behavior we are expecting is that whenever the user changes the text in
    the search field, a new list will be loaded. We need a new method in `MainPresenter`
    , that will be used to inform the presenter that the text was changed. We will
    call it `onSearchChanged` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to change the `MarvelRepository` definition to accept a search query
    as `getAllCharacters` parameter (remember to update also `BaseMarvelRepository`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, we have to update the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We also update the network request definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'And to allow code compilation, we need to provide `null` as a `getAllCharacters`
    argument in `MainPresenter` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'And we need to update `BaseMarvelRepository` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our network implementation is returning a list of characters that starts
    from a query, or a fill list if we don''t specify any query. Time to implement
    the presenter. Let''s define the following tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'To make following test pass, we need to add search query as a parameter with
    default argument to the `loadCharacters` method of `MainPresenter` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'But the tricky part is that the Marvel API does not allow only white spaces
    as an search query. There should be a `null` send instead. Therefore, if the user
    deletes the last character or if they try to search place only space in search
    field, then the application would crash. We should prevent such situations. Here
    is a test that is checking whether the presenter is changing a query with only
    white spaces into `null` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all tests are passing again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00077.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We still need to implement an `Activity` functionality that will call the presenter
    when text has changed. We will do it using the optional callback class defined
    in [Chapter 7](text00171.html) , *Extension Functions and Properties* :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'And use it in the `onCreate` method of `MainActivity` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'That is all we need to define the functionality of the character search. Now
    we can build the application and use it to find our favorite character:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With a correctly working application, we can move on to the next use case.
  prefs: []
  type: TYPE_NORMAL
- en: Character profile display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Searching through characters is not enough. To make the app functional, we should
    add a character description display. Here is the use case we've defined--when
    the user clicks on some character picture, there is a profile displayed. The character
    profile contains character name, photo, description, and its occurrences.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this use case, we need to create a new activity and layout that
    will define what this `Activity` looks like. To do it, create a new Activity called
    `CharacterProfileActivity` in the package `com.sample.marvelgallery.view.character`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will start its implementation from changes in layout (in `activity_character_profile.xml`
    ). Here is the final result we would like to achieve:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The base element is `CoordinatorLayout` with `AppBar` and `CollapsingToolbarLayout`
    both used to achieve a collapsing effect known from material design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Collapsing effect step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need `TextView` for description and occurrences that will be filled
    with data in the next use case. Here is the full `activity_character_profile`
    layout definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add following styles in `styles.xml` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'And we need to define `AppFullScreenTheme` as the theme for `CharacterProfileActivity`
    in `AndroidManifest` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a preview of the defined layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This view will be used to display data about the character, but first we need
    to open it from `MainActivity` . We need to set `onClickListener` in `CharacterItemAdapter`
    *,* that is calling `clicked` callback provided by constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'And we need to update `MainActivity` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding implementation, we are using a method from the `CharacterProfileActivity`
    companion object to start `CharacterProfileActivity` . We need to pass the `MarvelCharacter`
    object to this method. The most efficient way to pass a `MarvelCharacter` object
    is pass it as *parcelable* . To allow it, `MarvelCharacter` must implement the
    `Parcelable` interface. This is why a useful solution is to use some annotation
    processing library such as **Parceler** , **PaperParcel** , or **Smuggler** ,
    that generates the necessary elements. We will use solution from Kotlin Android
    extensions we already have in the project. During book publication, it was still
    experimental, so there needs to be added following definition in the `build.gradle`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'All we need to do it to add `Parcelize` annotation before class, and we need
    to make this class implement `Parcelable` . We will also add error suppression
    because to hide default Android warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can implement the `start` function and field `character` , that will
    get the argument value from Intent using the property delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The `extra` and `getIntent` extension functions were already presented in the
    book, but they are not implemented yet in the project. Also, `loadImage` will
    display an error because it needs to be changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to update `loadImage` , and define `extra` and `getIntent` as top-level
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of defining functions to start the Activity, we might use some library
    that is generating these methods. For example, we might use the `ActivityStarter`
    library. This is what `CharacterProfileActivity` would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'We should start it of get its intent using static methods of the generated
    class `CharacterProfileActivityStarter` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'To allow it, we need the **kapt** plugin in the module `build.gradle` (used
    to support annotation processing in Kotlin):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'And `ActivityStarter` dependencies in module `build.gradle` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'After these changes, when we click into character in `MainActivity` , then
    `CharacterProfileActivity` will be started:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are displaying the name and showing the character photo. The next step is
    to display the description and list of occurrences. The necessary data can be
    found in the Marvel API and we only need to extend DTO models to get them. We
    need to add `ListWrapper` that is used to hold a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to define `ComicDto` , which holds the data we need about occurrence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'And we need to update `CharacterMarvelDto` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Data is now read from the API and kept in DTO objects, but to use them in the
    project, we also need to change the `MarvelCharacter` class definition, and add
    a new constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can update `CharacterProfileActivity` to display the description and
    list of occurrences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The composition of the list of occurrences is quite a complex task, so we extract
    it to the function `makeOccurrencesText` . There, for each occurrence type (comic,
    series, and so on), we want to show introduction text and list only if there are
    some occurrences of this type. We also want to prefix each item with a bullet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`makeOccurrencesText` is a single expression function that is using `addList`
    to append an initially empty string with the next lists that we want to display.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`addList` is a member extension function. It is returning a string unchanged
    if the provided list is empty, or it is returning a string appended with introduction
    text and list of elements with bullets.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the character that is used as a list bullet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We also need to define strings in `strings.xml` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can see the whole character profile--character name, image, description,
    and lists of its occurrences in comics, series, events, and stories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application is complete, but there are still lots of functionalities that
    can be added. In this application, we've seen some examples of how Kotlin can
    be used to simplify Android development. But there are still a lot of solutions
    to discover. Kotlin simplifies Android development at any level--from common operations
    such as listener set or view element reference, to high-level functionalities
    such as functional programming or collection processing.
  prefs: []
  type: TYPE_NORMAL
- en: This book cannot say everything about Android development with Kotlin. It was
    designed to show enough to allow everyone to start their own adventure with baggage
    full of ideas and feature understanding. The next step is to open Android Studio,
    create your own project, and start having fun with Kotlin. The big adventure is
    in front of you.
  prefs: []
  type: TYPE_NORMAL
