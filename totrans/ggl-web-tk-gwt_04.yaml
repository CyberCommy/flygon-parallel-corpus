- en: Chapter 4. Interactive Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn different ways of creating interactive forms,
    which utilize GWT and AJAX to provide a much smoother user experience when using
    web‑based user interfaces. This chapter along with the next two chapters is going
    to provide the foundation for our exploration of GWT.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tasks that we will address are:'
  prefs: []
  type: TYPE_NORMAL
- en: Live search
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Password strength checker
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Auto fill forms
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sortable tables
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dynamic lists
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flickr-style editable labels
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sample Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to incorporate all of the sample applications that we are creating
    in this book into the Samples GWT application that we created in the previous
    chapter. We will be doing this in a style that is similar to the `KitchenSink`
    application that we explored in[Chapter 1](ch01.html "Chapter 1. Getting Started").
    In order to do this, we will follow the steps given below:'
  prefs: []
  type: TYPE_NORMAL
- en: The user interface for the application will be created in a class that extends
    the `SamplePanel` class in the `com.packtpub.gwtbook.samples.client` package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This class will then be initialized and added to the list of applications in
    the `Samples` class in the `com.packtpub.gwtbook.samples.client` package. Since
    the `Samples` class is set up as the entry point class, when GWT starts up, it
    will load this class and display all of the sample applications, just like the
    `KitchenSink`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for all the samples is available from the download site for
    the book. Please see the Appendix for instructions on downloading and running
    the samples.
  prefs: []
  type: TYPE_NORMAL
- en: Live Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Live Search` is a user interface that actively provides the user with choices
    matching the search criteria that the user types in. It is a very popular AJAX
    pattern that is used to continuously display all valid results to a user as the
    user refines the search query. Since the user''s query is constantly synchronized
    with the displayed results, it creates a very smooth search experience for the
    user. It also enables the user to easily experiment with different search queries
    very quickly in a highly interactive fashion. The results from the search are
    asynchronously retrieved from the server without any page refreshes or resubmission
    of search criteria. The Google search page ([http://google.com/](http://google.com/))
    uses this to great effect. It even tells you the number of search results that
    match your query as you type!'
  prefs: []
  type: TYPE_NORMAL
- en: Instant feedback of the kind provided by the `Live Search` AJAX pattern could
    also be harnessed to pre-fetch results from server and use them for anticipating
    the user's actions. This kind of an instantaneous response smoothens the user
    experience of the application and significantly improves the application latency.
    Google Maps ([http://maps.google.com/](http://maps.google.com/)) are nice examples
    of using this pattern to pre-fetch the map data as you are navigating around the
    map.
  prefs: []
  type: TYPE_NORMAL
- en: Time for Action—Search as you Type!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this `Live Search` example, we will create an application that retrieves
    a list of fruit names that begin with the letters that you type into the search
    text. You can refine your query criteria by reducing or increasing the number
    of letters that you type, and the user interface will display the matching result
    set in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Java file named `LiveSearchService.java` in the `com.packtpub.gwtbook.samples.client`
    package. Define a `LiveSearchService` interface with one method to retrieve the
    search results matching the string provided as a parameter to the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the asynchronous version of this service definition interface in a new
    Java file named `LiveSearchServiceAsync.java` in the `com.packtpub.gwtbook.samples.client`
    package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Create the implementation of our live search service in a new Java file named
    `LiveSearchServiceImpl.java` in the `com.packtpub.gwtbook.samples.server` package.
    We will create a string array that holds a list of fruits and when the service
    method is invoked we will return a sub-list of fruits from this array whose names
    start with the string provided as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our server-side implementation is complete. Now we will create the user interface
    for interacting with the live search service. Create a new Java file named `LiveSearchPanel.java`
    in the `com.packtpub.gwtbook.samples.client.panels` package that extends the `com.packtpub.gwtbook.samples.client.panels.SamplePanel`
    class. As mentioned at the beginning of this chapter, each of the user interfaces
    created in this book will be added to a sample application that is similar to
    the `KitchenSink` application that is available as one of the sample projects
    with the GWT download. That is why we will create each user interface as a panel
    that extends the `SamplePanel` class, and we will add the created panel to the
    list of samples panels in the sample application. Add a text box for typing in
    the search string, and a `FlexTable` that will display the matching items retrieved
    from the service. Finally, create an instance of the `LiveSearchService` that
    we are going to invoke.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor for the `LiveSearchPanel`, create the service target and
    set its entry point. Also create a new `VerticalPanel` that we will use as the
    container for the widgets that we are adding to the user interface. Set the CSS
    style for the search text box. This style is defined in the `Samples.css` file,
    and is part of the source code distribution package for this book. Please see
    the Appendix for details on how to download the source code package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the same constructor, add a listener to the text box that will call the `LiveSearchService`
    asynchronously as the user types in the text box, and update the pop-up panel
    continuously with the latest results matching the current string in the text box.
    This is the method that starts of all the magic by calling the service to get
    a list of completion items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in the constructor, add the search text box and the search results
    panel to the work panel. Create a little info panel that displays descriptive
    text about this application, so that we can display this text when this sample
    is selected in the list of available samples in our `Samples` application. Add
    the info panel and the work panel to a dock panel, and initialize the widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Add the service to the module file for the `Samples` application—`Samples.gwt.xml`
    in the `com.packtpub.gwtbook.samples` package. Adding this path to the module
    file let us create and set the endpoint information for this service using this
    path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the user interface for the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for Action—Search as you Type!](img/1007_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once you start typing in the first few letters of a fruit name, all the names
    of the fruits whose name starts with the string typed in are retrieved and displayed
    in a panel below the text box.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for Action—Search as you Type!](img/1007_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What Just Happened?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The user interface for the application displays a text box when you load the
    application in the browser. When you type a letter in the box, the `onKeyUp()`
    event will be triggered on the text box and in this event handler we asynchronously
    call the `getCompletionItems()` in the `LiveSearchService` with the text that
    is currently in the text box. The implementation of this method in our service
    returns a list with all the matching names. The matching names in this example
    are retrieved from a map contained in the service itself, but could just as easily
    be retrieved from a database, another application or a web service, depending
    on your application needs. We add the items that are present in the list to a
    `FlexTable` widget, which is present right below the text box. A `FlexTable` allows
    us to create tables that can be dynamically expanded. If the text box is empty
    or if we delete all the text in the box, then we clear out the list in the table.
    We use a panel as the container for all of the widgets in this application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Panels are containers for widgets in the GWT framework and are used for laying
    them out. You can add any widget or even other panels to a panel. This enables
    us to build complex user interfaces by combining widgets together by adding them
    to panels. The commonly used panels in the GWT framework are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DockPanel:** A panel that lays out the child widgets that are added to it
    by docking them or positioning them at the edges, and it allows the last added
    widget to take the remaining space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CellPanel:** A panel that lays out its widgets within the cells of a table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TabPanel:** A panel that lays out the child widgets in a tabbed set of pages,
    each with a widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HorizontalPanel:** A panel that lays out all of its child widgets in a single
    horizontal column from left to right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VerticalPanel:** A panel that lays out all of its child widgets in a single
    vertical column from top to bottom.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FlowPanel:** A panel that lays out its widgets from left to right just like
    text flowing across a line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PopupPanel:** A panel that displays its child widgets by popping up or overlaying
    over other widgets on the page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**StackPanel:** A panel that lays out its child widgets by stacking them vertically
    from top to bottom. The metaphor used is the same as the user interface of Microsoft
    Outlook.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be using most of these panels to lay out our user interfaces in this
    chapter and the rest of this book. The concepts from this task can be extended
    and applied to almost any type of search that you want to provide to your users
    in your application. You can even enhance and extend this application to provide
    further information to the user such as the number of matching results. The plumbing
    and tools provided by GWT make it extremely easy to provide this functionality.
    One of the best examples of the live search AJAX pattern and its use is the Google
    suggest service. As you type a search query string in a text field, it retrieves
    and displays a list of matching results in a continuous fashion. You can see it
    in action at [http://www.google.com/webhp?complete=1&hl=en](http://www.google.com/webhp?complete=1&hl=en).
  prefs: []
  type: TYPE_NORMAL
- en: Password Strength Checker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual cues are great way to inform the user of the status of things in the
    application. Message boxes and alerts are used much too often for this purpose,
    but they usually end up irritating the user. A much smoother and enjoyable user
    experience is provided by subtly indicating to the user the status as an application
    is used. In this section, we are going to create an application that indicates
    the strength of a typed password to the user by the use of colors and checkboxes.
    We are going to use check-boxes very differently than their normal usage. This
    is an example of using GWT widgets in new and different ways, and mixing and matching
    them to provide a great user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Time for Action—Creating the Checker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the current day and age, passwords are required for almost everything, and
    choosing secure passwords is very important. There are numerous criteria suggested
    for creating a password that is secure from most common password cracking exploits.
    These criteria run the gamut from creating 15 letter passwords with a certain
    number of lower case and numeric digits to creating passwords using random password
    generators. In our example application, we are going to create a password strength
    checker that is very simple, and only checks the number of letters in the password.
    A password string that contains less than five letters will be considered weak,
    while a password that contains between five and seven letters will be considered
    to be of medium strength. Any password containing more than seven letters will
    be considered as strong. The criteria were deliberately kept simple so that we
    can focus on creating the application without getting all tangled up in the actual
    password strength criteria. This will help us to understand the concepts and then
    you can extend it to use any password strength criteria that your application
    warrants. This example uses a service to get the password strength, but this could
    also be done all on the client without needing to use a server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Java file named `PasswordStrengthService.java` in the `com.packtpub.gwtbook.samples.client`
    package. Define a `PasswordStrengthService` interface with one method to retrieve
    the strength of a password string provided as a parameter to the method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the asynchronous version of this service definition interface in a new
    Java file named `PasswordStrengthServiceAsync.java` in the `com.packtpub.gwtbook.samples.client`
    package :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Create the implementation of our password strength service in a new Java file
    named `PasswordStrengthServiceImpl.java` in the `com.packtpub.gwtbook.samples.server`
    package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now let's create the user interface for this application. Create a new Java
    file named `PasswordStrengthPanel.java` in the `com.packtpub.gwtbook.samples.client.panels`
    package that extends the `com.packtpub.gwtbook.samples.client.panels.SamplePanel`
    class. Create a text box for entering the password string an `ArrayList` named
    `strengthPanel` for holding the checkboxes that we will use for displaying the
    strength of the password. Also create the `PasswordStrengthService` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Add a private method for clearing all the checkboxes by setting their style
    to the default style.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Add a private method that will return the CSS name, based on the password strength.
    This is a nice way for us to dynamically set the style for the checkbox, based
    on the strength.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor for the `PasswordStrengthPanel` class, create a `HorizontalPanel`
    named `strengthPanel`, add nine checkboxes to it, and set its style. As mentioned
    before the styles that we are using in the sample applications in this book are
    available in the file `Samples.css`, which is part of the source code distribution
    for this book. We also add these same checkboxes to the `strength` object, so
    that we can retrieve them later to set their state. These checkboxes will be used
    for displaying the password strength visually. Create a new `VerticalPanel` that
    we will use as the container for the widgets that we are adding to the user interface.
    Finally, create the service target and set its entry point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the same constructor, set the style for the password text box, and add an
    event handler to listen for changes to the password box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in the constructor, add the password text box and the strength panel
    to the work panel. Create a little info panel that displays descriptive text about
    this application, so that we can display this text when this sample is selected
    in the list of available samples in our `Samples` application. Add the info panel
    and the work panel to a dock panel, and initialize the widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Add the service to the module file for the `Samples` application—`Samples.gwt.xml`
    in the `com.packtpub.gwtbook.samples` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the user interface for the password strength checking application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for Action—Creating the Checker](img/1007_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now start typing a password string to check its strength. Here is the password
    strength when you type a password string that is less than five characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for Action—Creating the Checker](img/1007_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What Just Happened?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The password strength service checks the size of the provided string and returns
    an integer value of three, six, or nine based on whether it is weak, medium, or
    strong. It makes this determination by using the criteria that if the password
    string is less than five characters in length, it is weak, and if it is more than
    five characters but not greater than seven characters, it is considered a medium
    strength password. Anything over seven characters is considered to be a strong
    password.
  prefs: []
  type: TYPE_NORMAL
- en: The user interface consists of a text box for entering a password string and
    a panel containing nine checkboxes that visually displays the strength of the
    typed string as a password. An event handler is registered to listen for keyboard
    events generated by the password text box. Whenever the password text changes,
    which happens when we type into the field or change a character in the field,
    we communicate asynchronously with the password strength service and retrieve
    the strength of the given string as a password. The returned strength is displayed
    to the user in a visual fashion by the use of colors to symbolize the three different
    password strengths.
  prefs: []
  type: TYPE_NORMAL
- en: The password strength is displayed in a compound widget that is created by adding
    nine checkboxes to a `HorizontalPanel`. The color of the checkboxes is changed
    using CSS depending on the strength of the password string. This process of combining
    the basic widgets provided by GWT into more complex widgets to build user interfaces
    is a common pattern in building GWT applications. It is possible to build quite
    intricate user interfaces in this way by utilizing the power of the GWT framework.
    We will see more examples of this as we continue to explore various GWT applications
    later in this chapter and also throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Auto Form Fill
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forms are ubiquitous on the Web and are widely used for everything from displaying
    information from customer profiles to filling out applications online. We do not
    like going through all those fields and typing in the information in every time,
    especially if we have already done this on that site once before. A very nice
    way to speed this up would be to pre-populate the fields with the previously collected
    information when a key form field is filled in. This not only saves the customer
    some typing, it also is a great usability enhancement that improves the whole
    customer experience. In this section, we are going to build a form that will automatically
    fill out the various fields when we type in a recognized value in the Customer
    ID field.
  prefs: []
  type: TYPE_NORMAL
- en: Time for Action—Creating a Dynamic Form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to create an application that makes it easy to fill out the various
    fields of a form when a certain value is provided in one of the fields. This is
    a very common occurrence in most of the web-based business applications where,
    for instance, user information needs to be provided in order to register for a
    service. In the case of a new user, this information will need to be filled out
    by the user, but in the case of a previous user of the system, this information
    is already available and can be accessed and used for filling out all the fields
    when the user types in a unique identifier that identifies him or her, an ID of
    some sort. In this application we are going to automatically fill out the various
    fields of the form when a user enters in a `CustomerID` that is known to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Java file named `AutoFormFillService.java` in the `com.packtpub.gwtbook.samples.client`
    package. Define an `AutoFormFillService` interface with one method to retrieve
    the form information when provided a key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new Java file named `AutoFormFillServiceAsync.java` in the `com.packtpub.gwtbook.samples.client`
    package. Define a `AutoFormFillAsync` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Create a new Java file named `AutoFormFillServiceImpl.java` in the `com.packtpub.gwtbook.samples.server`
    package. Define a `AutoFormFillServiceImpl` class that extends `RemoteServiceServlet`
    and implements the previously created `AutoFormFillService` interface. First we
    will use a simple `HashMap` to store the customer information and add a method
    to populate the map. In your application you can retrieve this customer information
    from any external data source, such as a database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Add logic to the `getFormInfo()` to return the form information for a provided
    form key. We take the provided key that was entered in the form by the user, and
    use that to look up the user information, and return it asynchronously to the
    client application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Create the user interface for this application in a new Java file named `AutoFormFillPanel.java`
    in the `com.packtpub.gwtbook.samples.client.panels` package. Create a text box,
    and a label for each information field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Create the service class that we are going to invoke.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Create private methods for setting and clearing the values of the form fields.
    We will use these methods from the event handlers that we will set up in the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Create accessor methods for retrieving the different labels. We will use these
    to get the label and set its value when we retrieve information from the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Create accessor methods for retrieving the different text boxes. We will use
    these to get the text box and set its value when we retrieve information from
    the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor for `AutoFormFillPanel`, create a new `VerticalPanel` that
    we will use as the container for the widgets that we are adding to the user interface.
    Also, create the service target and set its entry point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Also in the constructor, create a `HorizontalPanel` named `itemPanel` and add
    the widgets for each form field to it. For instance, this is how we add the `customerID`
    field to the `itemPanel`, set its style, and add this `itemPanel` to the `workPanel`,
    which is the main container that we have created earlier to hold the widgets for
    our user interface. You will create a new `HorizontalPanelfor` each form field
    and add it to the `workPanel`. Repeat for each form field that we have.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the same constructor, add a keyboard listener to the `custID` text box and
    in the event handler invoke the service to retrieve customer information for the
    value typed in customer ID. Set the values of the form fields from the return
    value of the service call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in the constructor, create a little info panel that displays descriptive
    text about this application, so that we can display this text when this sample
    is selected in the list of available samples in our `Samples` application. Add
    the info panel and the work panel to a dock panel, and initialize the widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Add the service to the module file for the `Samples` application—`Samples.gwt.xml`
    in the `com.packtpub.gwtbook.samples` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what the application looks like when the user types in a `CustomerID`,
    in this case 1111, which is known to our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for Action—Creating a Dynamic Form](img/1007_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What Just Happened?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We create a service that contains customer data stored in a `HashMap` data structure.
    In a real application, this data would usually come from an external data source
    such as a database. For each customer, we create a map that contains the customer
    information fields stored as key value pairs. This customer map is then added
    to a master `HashMap` using the `customerID` as the key. This makes it easier
    for us to retrieve the right customer information when we are provided with the
    key, which in this case is the `customerID`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When the user interface is loaded in the browser, the user is presented with
    a page that contains fields that are pertinent to a customer. The user needs to
    type a unique customer ID in the text box provided. There are only three known
    customer ids in this sample application—1111, 2222, and 3333\. We are using the
    customer ID as the key to customer information here, but you could also use a
    social security number or any other unique ID based on the requirements of your
    application. Of course in a real application the user would need to enter a password
    as well as an ID number to avoid unauthorized display of confidential details
    to anyone entering a valid ID. When the user types in a customer ID in the text
    box, for instance 1111, the event handler `onKeyUp()` is triggered. In the event
    handler we invoke the `getFormInfo()` method in the `AutoFormFillService` and
    pass in the typed text as a parameter. The `getFormInfo()` method searches the
    customer information for the given customer ID and returns the information as
    a `HashMap`. If no information is found due to an unknown ID, we return an empty
    map. The values from this map are retrieved and the corresponding fields are filled
    in by calling the `setValues()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple but very powerful and effective way to provide a nice experience
    for users interacting with our system.
  prefs: []
  type: TYPE_NORMAL
- en: Sortable Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tables are probably the most common way to display business data in an application.
    They are well known to all users and provide a universal way to view data. This
    has traditionally been hard to on a web page. GWT provides us with the ability
    to easily and quickly provide this functionality in our applications. We are going
    to create an application that contains a table whose rows can be sorted in an
    ascending or descending order by clicking on a column header. This provides for
    a much better user experience, as the user can modify the order of the displayed
    data to suit their needs. The table widgets provided with GWT does not have a
    built-in way to provide this capability, but GWT provides us with enough tools
    to add support for this easily to a table. Please keep in mind that this is just
    one way to create tables that can be sorted using GWT.
  prefs: []
  type: TYPE_NORMAL
- en: Time for Action—Sorting Table Rows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We do not need to create a service for this application as the sorting of data
    takes place on the client. We will create an application with some seed data for
    our table, and then add support for sorting that data by clicking on the column
    headers.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Java file named `SortableTablesPanel.java` in the `com.packtpub.gwtbook.samples.client.panels`
    package. We will add support to this class to make the included table sortable
    by clicking on the column headers. First create a `CustomerData` class that will
    represent one row in the table, and accessors for each field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Create an `ArrayList` named `customerData` for storing the customer data. Create
    variables for storing the sort direction, the headers for the columns in the table,
    temporary data structures for sorting, and a `FlexTable` for displaying the customer
    data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor for the `SortableTablesPanel`, create a new `VerticalPanel`
    that we will use as the container for the widgets that we are adding to the user
    interface. Set the styles for the table and set the column headers for the table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Also in the constructor, add five customers to the `customerData` list. Add
    the data from this list to the table and set a listener on the table that will
    sort the rows when the first column is clicked. We will be displaying this list
    of customers in the table and then sorting the table when a column header is clicked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in the constructor, add the table to the work panel. Create a little
    info panel that displays descriptive text about this application, so that we can
    display this text when this sample is selected in the list of available samples
    in our `Samples` application. Add the info panel and the work panel to a dock
    panel, and initialize the widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Add a private method for redrawing the headers of the table. This is a nice
    way for us to redraw the table column header so that we can change the image displayed
    in the header to match the current sort direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Add a private method to redraw the entire table when we change the sort order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Add a private method that can sort the data in an ascending or descending way
    and redraw the table with the sorted rows. We are using the sort method provided
    by the `Collections` class to sort the data, but can also modify this to use the
    `Comparator` class to compare two pieces of data, and then use that for sorting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here is a screenshot of the application. You can click on any of the column
    headers to sort the data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for Action—Sorting Table Rows](img/1007_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What Just Happened?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We create a `CustomerData` class to represent each row in a `FlexTable`. We
    then create some customer data and store it in an `ArrayList`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Data from this list is added to the table. We need to specify the row number
    and column number in order to add an element to the table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The column headers are contained in row zero and the table data starts from
    row 1\. We add the column header by setting the HTML for that particular cell
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This enables us to add a snippet of HTML to the cell instead of setting just
    plain text. We add the text for the column header along with an `img` tag with
    a blank image file. A column header without an image next to the text visually
    indicates to the user that there is no sort order specified for that particular
    column. When we click on a column header, we will be modifying this image to use
    either an ascending or descending icon. An event handler is registered to listen
    for clicks on the table. GWT does not contain a mechanism to register a handler
    when someone clicks on a specific cell, so we use the general table click listener
    and check to see if the click was on row zero, which is the row that contains
    the column headers. If the user did click on the column header, we go ahead and
    sort the table.
  prefs: []
  type: TYPE_NORMAL
- en: The real magic happens in the `sortTable()` method. A temporary `HashMap` named
    `dataBucket` is created to store the rows from the table, with each row keyed
    by the value in the column whose header was clicked, along with a temporary `ArrayList`
    named `sortColumnValues` that stores the column values in the column whose header
    was clicked. This means that the `sortColumnValues` list contains values that
    are keys in the `dataBucket` map.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We check the value of the `sortDirection` variable and, based on the value,
    sort the `sortColumnValues` list either ascending or descending to contain the
    column values in the right order. The built-in `sort()` and `reverseSort()` methods
    of the `Collections` class are used to provide the sorting mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The table column headers are then redrawn so that the column that was clicked
    will have the right icon for the sort order and all the other column headers have
    only plain text and a blank image. Finally, we redraw the table by iterating through
    the `sortColumnValues` list and retrieving the associated `CustomerData` object
    from the `dataBucket` and adding it as a row in the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'This application demonstrates the tremendous power that is provided by the
    GWT framework that enables you to manipulate tables to extend their functionality.
    GWT provides different kinds of tables for building user interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '**FlexTable:** A table that creates cells on demand. You can even have rows
    that contain a different number of cells. This table expands as needed when you
    add rows and columns to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grid:** A table that can contain text, HTML, or child widgets. It must, however,
    be created explicitly with the number of desired rows and columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be using both of these table widgets extensively in the applications
    that we build in this chapter and the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create an application that uses dynamic lists to present the user with
    a way to filter criteria for a search. In this section we are going to create
    dynamic tables, which will enable us to populate child tables as items in a master
    table are selected. We are going to do this by using GWT's AJAX support and display
    only those items in a child table that are relevant to the selection in the main
    table. This application will make it easy to navigate and filter out criteria
    for a search. In this sample application, we are going to enable a user to select
    a manufacturer of automobiles, which will automatically fill a second list with
    all the brands of cars made by that manufacturer. When the customer further selects
    an item in this list of brands, a third list will be automatically populated with
    the models of cars for the selected brand. In this way, a user can interactively
    select and navigate through the search criteria, in a user-friendly and intuitive
    way without having to submit data and refresh the page to present some of this
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Time for Action—Filtering Search Criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a part of this application, we will also create a service that will provide
    information on the manufacturers, brands, and models, and create a user interface
    that asynchronously retrieves this information from the service to display it
    to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Java file named `DynamicListsService.java` in the `com.packtpub.gwtbook.samples.client`
    package. Define a `DynamicListsService` interface with methods for retrieving
    information about the manufacturers, brands, and models:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new Java file named `DynamicListsServiceAsync.java` in the `com.packtpub.gwtbook.samples.client`
    package. Define a `DynamicListsServiceAsync` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Create a new Java file named `DynamicListsServiceImpl.java` in the `com.packtpub.gwtbook.samples.server`
    package. Define a `DynamicListsServiceImpl` class that extends `RemoteServiceServlet`
    and implements the previously created `DynamicListsService` interface. This class
    will return information about the manufacturers, brands, and models. Create a
    class named `Manufacturer` to encapsulate the information about each manufacturer,
    including the brands and models of automobiles offered by them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Create a private method to load the manufacturer information into a `HashMap`.
    The data on the manufacturers will be loaded into the first table later on. When
    the user interface starts up, the manufacturers table is the only one with the
    data, and provides the starting point for using the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Implement the service method for retrieving a list of manufacturers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Implement the service method for retrieving the list of brands offered by a
    manufacturer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Implement the service method for retrieving the models offered by a manufacturer
    for a particular brand.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Create the user interface for this application in a new Java file named `DynamicListsPanel.java`
    in the `com.packtpub.gwtbook.samples.client.panels` package. Create three Grid
    widgets to hold the manufacturers, brands, and models information and add them
    to the main panel. Create the service class that we are going to invoke.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Add a private method for clearing out the panels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor for the `DynamicListsPanel`, create a new `HorizontalPanel`
    that we will use as the container for the widgets that we are adding to the user
    interface. Also, create the service target and set its entry point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In the same constructor, add an event handler to listen for clicks on the Select
    Manufacturer table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In the same constructor, add an event handler to listen for clicks on the Select
    Brand table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Also in the constructor, add a listener to the Select Models table to clear
    out the selections when a model is selected. Load the Select Manufacturer table
    with data when the application starts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, create a `VerticalPanel` named `itemPanel`, and add each
    table and its associated label to it. Create an `itemPanel` for each of the three
    tables, set the style, and add them to the `workPanel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in the constructor, create a little info panel that displays descriptive
    text about this application, so that we can display this text when this sample
    is selected in the list of available samples in our `Samples` application. Add
    the info panel and the work panel to a dock panel, and set the widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Add the service to the module file for the `Samples` application—`Samples.gwt.xml`
    in the `com.packtpub.gwtbook.samples` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a screenshot of the application when we have selected one of the manufacturers—Mercedes,
    and one of its brands—E-class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for Action—Filtering Search Criteria](img/1007_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What Just Happened?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We create a list of the Manufacturer objects, one per manufacturer. Each of
    these Manufacturer objects contains a `HashMap` named brands, which contains an
    `ArrayList` of models for that particular brand. This data structure that we have
    just created contains all the information we need regarding the brands and models
    offered by a manufacturer. In an actual application this data would usually be
    retrieved from an enterprise data source. For instance, here is how we build up
    the data for the manufacturer Mercedes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We then implement the three service methods from the interface to return a
    list of manufacturers, a list of brands for a given manufacturer, and finally
    a list of models for a given manufacturer and brand. Each of these methods navigates
    the Manufacturer objects, and retrieves and returns a list with the necessary
    information. When we request a list of models for a given brand and manufacturer,
    the service method implementation returns the list by navigating the manufacturers
    list like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The user interface consists of three Grid widgets. A Grid is another kind of
    a table widget that can contain text, HTML, or a child widget within its cells.
    When the application is initialized, the list of manufacturers is initially retrieved
    from the `DynamicListsService` and the manufacturers grid is filled with the data.
    An event handler is registered to listen for clicks in the grids. When an item
    in the manufacturers grid is clicked, we clear the brands grid first and then
    invoke the `getBrands()` method on the service and load the brands grid with the
    retrieved information. When the user selects an item from the brands grid by clicking
    on it, we first clear the models grid and then we invoke the `getModels()` method
    on the service and load the models grid with the retrieved information. Every
    time we make a selection in any of the grids, we were able to retrieve all this
    information using GWT without any page refreshes or page submissions!
  prefs: []
  type: TYPE_NORMAL
- en: Flickr-Style Editable Labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flickr ([http://flickr.com/](http://flickr.com/)) is one of the most innovative
    Web 2.0 sites on the Internet. Its use of AJAX makes this website a pleasure to
    use. A prime example of this is the label widget that is displayed below any image
    that you add to your flickr account. It looks like a simple label, but when you
    hover the cursor over it, it changes color indicating that it is more than a label.
    When you click on it, it transforms into a text box where you can edit the text
    in the label! You even get buttons to make your changes persist or cancel to discard
    your changes. After you save or cancel, it transforms back into a label again.
    Try it out. It is really neat! This is a great way of combining multiple HTML
    controls—a label, text box, and buttons into one compound control that saves valuable
    space on the web page, while providing the necessary functionality in a very user-friendly
    manner. In this section, we are going to recreate the flickr-style label using
    the widgets available to us in GWT.
  prefs: []
  type: TYPE_NORMAL
- en: Time for Action—A Custom Editable Label
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to create a label that is dynamically converted into an editable
    text box when you click on it. It will also provide you with the ability to save
    changes or discard changes. If you modify the text and save the changes, the label
    text will be changed, otherwise the original text will be retained, and the text
    box will be transformed back into a label. It is a very innovative user interface
    and you really need to use it to appreciate it!
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Java file named `FlickrEditableLabelPanel.java` in the `com.packtpub.gwtbook.samples.client.panels`
    package. Create an image, a label, a text box and two buttons for the user interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Create a private method for displaying the text box along with the buttons while
    hiding the label. This is what will essentially transform the label into a text
    box with buttons!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor for `FlickrEditableLabelPanel`, create an event handler that
    listens for a click on the label, and invokes the above method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Also, in the constructor, create an event handler that listens for a mouse hover
    and modifies the label style to provide a visual cue to the user to click on the
    label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Create a text box for typing in the new name in the constructor and create an
    event handler that listens for the return key and escape key when the focus is
    in the text box, and either saves the change or cancels out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Create an event handler in the constructor to listen for a click on the save
    button and save the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Create an event handler in the constructor to listen for a click on the cancel
    button and discard any changes made.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, set the visibility of the widgets when the application is
    first loaded. When the user interface is first displayed, we want the label to
    be shown and everything else hidden.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in the constructor, create a `HorizontalPanel` named `buttonPanel`
    and add the widgets that we created to it. Create a `VerticalPanel` named `workPanel`
    and add the `buttonPanel` to it. Create a little info panel that displays descriptive
    text about this application, so that we can display this text when this sample
    is selected in the list of available samples in our `Samples` application. Add
    the info panel and the work panel to a dock panel, and initialize the widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Create a private method for displaying the label and hiding the text. Now we
    are hiding the label and displaying our nice text-editing interface with the text
    box and the buttons for saving or discarding changes made.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Create a private method for saving the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Create a method for discarding the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the application looks like when you visit the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for Action—A Custom Editable Label](img/1007_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you click on the label under the image, it will be converted to a text box
    with a save and cancel button. You can modify the text and save changes or click
    on cancel to change back to a label.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for Action—A Custom Editable Label](img/1007_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What Just Happened?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We create an user interface that consists of an image with a label under it,
    a text box, a save button, a label, and a cancel button. An event handler is registered
    to listen for clicks on the label. When the user clicks on the label, the event
    handler is triggered, and we hide the label, and set the text box and the buttons
    to be visible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: If we modify the text and click save, the event handler that is listening for
    the click on the save button saves the text as the values of the label and once
    again displays the label and hides all the other widgets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: If we discard the changes by clicking the cancel button, the event handler that
    is listening for the click on the cancel button will display the label and hide
    all the other widgets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In this application we do not invoke any services to propagate the change to
    a server-side process, but we can easily do that by adding the code to invoke
    a service when we save the change made to the text.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we took a look at creating a live search application. Then we
    took a look at creating a password strength checker. Also, we created forms that
    can be auto-filled with information from the server. We also created applications
    where tables were sorted. Then before creating a flickr-style editable label,
    we created dynamically populating lists based on user selection.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to look at creating responsive complex interfaces,
    which use some of the more advanced features of GWT.
  prefs: []
  type: TYPE_NORMAL
