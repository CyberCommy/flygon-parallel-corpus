- en: '*Chapter 6*:'
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers the most popular questions and problems relating to **Object-Oriented
    Programming** (**OOP**) that are encountered at Java interviews.
  prefs: []
  type: TYPE_NORMAL
- en: Please bear in mind that my goal is not to teach you about OOP or, in more general
    terms, the aim of this book is not to teach you about Java. My goal is to teach
    you how to answer questions and solve problems in the context of an interview.
    In such a context, the interviewer wants a clear and concise answer; you'll not
    have the time for dissertations and tutorials. You have to be able to express
    your ideas lucidly and cogently. Your answers should be meaningful and you have
    to convince the interviewer that you really understand what you are saying and
    that you are not just reciting a number of sterile definitions. Most of the time,
    you should be able to express an article of several pages or a chapter of a book
    in one or several key paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll know how to answer 40+ questions and problems
    that cover the fundamental aspects of OOP. Being fundamental aspects, you have
    to know them in detail. There is no excuse in the event that you don't know the
    correct and concise answers to these problems. A lack of knowledge in this area
    can severely affect your chances of success at interview.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s summarize our agenda as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: OOP concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOLID principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GOF design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with questions relating to OOP concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find all the codes present in this chapter on GitHub. Please visit the
    following link:[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter06](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter06)
  prefs: []
  type: TYPE_NORMAL
- en: Understanding OOP concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The OOP model is based on several concepts. These concepts must be familiar
    to any developer who is planning to design and program applications relying on
    objects. Therefore, let''s start by enumerating them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Association
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commonly, when these concepts are wrapped in questions, they are prefixed by
    *What is ...?* For example, *What is an object?*, or *What is polymorphism?*
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The correct answers to these questions are a combination of technical knowledge
    and real-world analogies or examples. Avoid cold answers with super-technical
    details and no examples (for example, don't talk about the internal representation
    of an object). Pay attention to what you're saying because the interviewer may
    extract questions directly from your answers. If your answer has mentioned a notion
    in passing, then the next question may refer to that notion. In other words, don't
    add to your answer any aspects that you are unfamiliar with.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's answer the questions relating to OOP concepts in an interview context.
    Notice that we apply what we've learned in [*Chapter 5*](B15403_05_Final_JM_ePub.xhtml#_idTextAnchor072),
    *How to Approach a Coding Challenge*. More precisely, we follow the **Understand
    the question**|**Nominate the key words/key points**|**Wrap an answer** technique.
    To begin with, in order to become familiar with this technique, I'll extract the
    key points as a bulleted list, and I will italicize them in the answer.
  prefs: []
  type: TYPE_NORMAL
- en: What is an object?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key points that you should encapsulate in your answer are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An object is one of the core concepts of OOP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object is a real-world entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object has state (fields) and behaviors (methods).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object represents an instance of a class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object takes up some space in memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object can communicate with other objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can present an answer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*An object is one of the core concepts of OOP. An object is a real-world entity,
    such as a car,* *table, or cat*. During its life cycle, an object *has state and
    behaviors*. For example, a cat''s state can be color, name, and breed, while its
    behaviors can be playing, eating, sleeping, and meowing. In Java, an object is
    an instance of a class usually built via the `new` keyword, and *it has state
    stored in fields and exposes its behavior through methods. Each instance takes
    some space in memory and can communicate with other objects*. For example, a boy,
    which is another object, can caress a cat and it sleeps.'
  prefs: []
  type: TYPE_NORMAL
- en: If further details are required, then you may want to talk about the fact that
    objects can have different access modifiers and visibility ranges, can be mutable,
    unmodifiable, or immutable, and are collected via the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: What is a class?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key points that you should encapsulate in your answer are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A class is one of the core concepts of OOP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class is a template or a blueprint for creating objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class doesn't consume memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class can be instantiated multiple times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class does one, and only one, thing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can present an answer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A class is one of the core concepts of OOP.* A class is a set of instructions
    that are required to build a specific type of object. We can *think of a class
    as a template, a blueprint*, or a recipe that tells us how to create objects of
    that class. *Creating an object of that class is a process called instantiation*
    and is usually done via the `new` keyword. *We can instantiate as many objects
    as we wish. A class definition doesn''t consume memory* being saved as a file
    on the hard drive. One of the best practices that a class should follow is the
    **Single Responsibility Principle** **(SRP)**. While conforming to this principle,
    *a class should be designed and written to do one, and only one, thing.*'
  prefs: []
  type: TYPE_NORMAL
- en: If further details are required, then you may want to talk about the fact that
    classes can have different access modifiers and visibility ranges, support different
    types of variables (local, class, and instance variables), and can be declared
    as `abstract`, `final`, or `private`, nested in another class (inner class), and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: What is abstraction?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key points that you should encapsulate in your answer are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction is one of the core concepts of OOP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstraction is the concept of exposing to the user only those things that are
    relevant to them and hiding the remainder of the details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstraction allows the user to focus on what the application does instead of
    how it does it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstraction is achieved in Java via abstract classes and interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can present an answer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Einstein claims that *Everything should be made as simple as possible, but not
    simpler*. *Abstraction is one of the main OOP concepts* that strive to make things
    as simple as possible for the user. In other words, *abstraction exposes the user
    only to the things that are relevant to them and hides the remainder of the details*.
    In OOP terms, we say that an object should expose to its users only a set of high-level
    operations, while the internal implementation of those operations is hidden. So,
    *abstraction allows the user to focus on what the application does instead of
    how it does it*. This way, abstraction reduces the complexity of exposing the
    things, increases code reusability, avoids code duplications, and sustains low
    coupling and high cohesion. Moreover, it maintains the security and discretion
    of the application by exposing only the important details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a real-life example: a man driving a car. The man knows what
    each pedal does and what the steering wheel does, but he doesn''t know how these
    things are done internally by the car. He doesn''t know about the inner mechanisms
    that empower these things. This is what abstraction is. *In Java, abstraction
    can be achieved via abstract classes and interfaces*.'
  prefs: []
  type: TYPE_NORMAL
- en: If further details are required, then you may share the screen or use paper
    and a pen and code your example.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we said that a man is driving a car. The man can speed up or slow down
    the car via the corresponding pedals. He also can turn left and right with the
    aid of the steering wheel. All these actions are grouped in an interface named
    `Car`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, each type of car should implement the `Car` interface and override these
    methods to provide the implementation of these actions. This implementation is
    hidden from the user (the man driving the car). For example, the `ElectricCar`
    class appears as follows (in reality, in place of `System.out.println`, we have
    complex business logic):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The user of this class has access to these `public` methods without being aware
    of the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So, this was an example of abstraction via an interface. The complete application
    is named *Abstraction/AbstractionViaInterface*. In the code bundled to this book,
    you can find the same scenario implemented via an abstract class. The complete
    application is named *Abstraction/AbstractionViaAbstractClass***.**
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, let's talk about encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: What is encapsulation?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key points that you should encapsulate in your answer are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation is one of the core concepts of OOP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation is the technique whereby the object state is hidden from the outer
    world and a set of public methods for accessing this state are exposed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation is achieved when each object keeps its state private, inside a
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation is known as the *data-hiding* mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation has a number of important advantages associated with it, such
    as loosely coupled, reusable, secure, and easy-to-test code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Java, encapsulation is implemented via the access modifiers – `public`, `private`,
    and `protected.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can present an answer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Encapsulation is one of the core concepts of OOP*. Mainly, encapsulation binds
    together the code and data in a single unit of work (a class) and acts as a defensive
    shield that doesn''t allow external code to access this data directly. Mainly,
    *it is the technique of hiding the object state from the outer world and exposing
    a set of* `public` *methods for accessing this state. When each object keeps its
    state* `private` *inside a class, we can say that encapsulation was achieved.
    This is why encapsulation is also referenced as the* `public`, `private`, and
    `protected`. Commonly, when an object manages its own state, its state is declared
    via `private` variables and is accessed and/or modified via `public` methods.
    Let''s consider an example: a `Cat` class can have its state represented by fields
    such as `mood`, `hungry`, and `energy`. While the code external to the `Cat` class
    cannot modify any of these fields directly, it can call `public` methods, such
    as `play()`, `feed()`, and `sleep()` that modify the `Cat` state internally. The
    `Cat` class may also have `private` methods that are not accessible outside the
    class, such as `meow()`.This is encapsulation.'
  prefs: []
  type: TYPE_NORMAL
- en: If further details are required, then you may share the screen or use paper
    and a pen and code your example.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the `Cat` class from our example can be coded as indicated in the following
    code block. Notice that the state of this class was encapsulated via `private`
    fields, and is therefore not directly accessible from outside the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The only way to modify the state is via the public methods, `play()`, `feed()`,
    and `sleep()`, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named *Encapsulation***.** Now, let's have a rundown
    on inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: What is inheritance?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key points that you should encapsulate in your answer are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance is one of the core concepts of OOP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance allows an object to be based on another object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance sustains code reusability by allowing an object to reuse the code
    of another object and adds its own logic as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance is known as an **IS-A** relationship, also referenced as a parent-child
    relationship.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Java, inheritance is achieved via the `extends` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The inherited object is referenced as the superclass, and the object that inherits
    the superclass is referenced as the subclass.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Java, multiple classes cannot be inherited.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can present an answer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Inheritance is one of the core concepts of OOP. It allows an object to be
    based on another object*, which is useful when different objects are pretty similar
    and share some common logic, but they are not identical. *Inheritance sustains
    code reusability by allowing an object to reuse the code of another object while
    it adds its own logic as well*. So, in order to achieve inheritance, we reuse
    the common logic and extract the unique logic in another class. *This is known
    as an IS-A relationship, also referenced as a parent-child relationship*. It is
    just like saying `Foo` IS-A `Buzz` type of thing. For example, cat IS-A feline,
    and train IS-A vehicle. An IS-A relationship is the unit of work used to define
    hierarchies of classes. *In Java, inheritance is accomplished via the* `extends`
    *keyword by deriving the child from its parent*. The child can reuse the fields
    and methods of its parent and add its own fields and methods. *The inherited object
    is referenced as the superclass, or the parent class, and the object that inherits
    the superclass is referenced as the subclass, or the child class. In Java, inheritance
    cannot be multiple*; therefore, a subclass or child class cannot inherit fields
    and methods of more than one superclass or parent class. For example, an `Employee`
    class (parent class) can define the common logic of any employee in a software
    company, while another class (child class), named `Programmer`, can extend the
    `Employee` to use this common logic and add logic specific to a programmer. Other
    classes can extend the `Programmer` or `Employee` classes as well.'
  prefs: []
  type: TYPE_NORMAL
- en: If further details are required, then you may share the screen or use paper
    and a pen and code your example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Employee` class is quite simple. It wraps the name of the employee:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the `Programmer` class extends the `Employee`. As any employee, a programmer
    has a name, but they are also assigned to a team:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s test inheritance by creating a `Programmer` and calling `getName()`,
    inherited from the `Employee` class, and `getTeam()`, inherited from the `Programmer`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named *Inheritance*. Moving on, let's talk about
    polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: What is polymorphism?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key points that you should encapsulate in your answer are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism is one of the core concepts of OOP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism means *many forms* in Greek.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism allows an object to behave differently in certain cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism can be shaped via method overloading (known as Compile-Time Polymorphism)
    or via method overriding in the case of an IS-A relationship (known as Runtime
    Polymorphism).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can present an answer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Polymorphism is one of the core concepts of OOP*. Polymorphism is a word composed
    of two Greek words: *poly*, which means *many*, and *morph*, which means *forms*.
    Therefore, *polymorphism means many forms*.'
  prefs: []
  type: TYPE_NORMAL
- en: More precisely, in the OOP context, *polymorphism allows an object to behave
    differently in certain cases* or, in other words, allows an action to be accomplished
    in different ways (approaches). *One way to implement polymorphism is via method
    overloading. This is known as Compile-Time Polymorphism* because the compiler
    can identify at compile time which form of an overloaded method to call (multiple
    methods with the same name but different arguments). So, depending on which form
    of the overloaded method is called, the object behaves differently. For example,
    a class named `Triangle` can define multiple methods named `draw()` with different
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '*Another way to implement polymorphism is via method overriding, and this is
    the common approach when we have an IS-A relationship. It is known as Runtime
    Polymorphism, or Dynamic Method Dispatch*. Typically, we start with an interface
    containing a bunch of methods. Next, each class implements this interface and
    overrides these methods to provide a specific behavior. This time, polymorphism
    allows us to use any of these classes exactly like its parent (the interface)
    without any confusion of their types. This is possible because, at runtime, Java
    can distinguish between these classes and knows which one is used. For example,
    an interface named `Shape` can declare a method named `draw()`, and the `Triangle`,
    `Rectangle`, and `Circle` classes implement the `Shape` interface and override
    the `draw()` method to draw the corresponding shape.'
  prefs: []
  type: TYPE_NORMAL
- en: If further details are required, then you may share the screen or use paper
    and a pen and code your example.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism via method overloading (compile time)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Triangle` class contains three `draws()` methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, notice how the corresponding `draw()` method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named *Polymorphism/CompileTime*. Moving on, let's
    look at an example of implementing runtime polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism via method overriding (runtime)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This time, the `draw()` method is declared in an interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Triangle`, `Rectangle`, and `Circle` classes implement the `Shape` interface
    and override the `draw()` method to draw the corresponding shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a triangle, a rectangle, and a circle. For each of these instances,
    let''s call the `draw()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output reveals that, at runtime, Java called the proper `draw()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named *Polymorphism/Runtime*. Moving on, let's talk
    about association.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: There are people who consider polymorphism as the most important concept in
    OOP. Moreover, there are voices that consider runtime polymorphism as the only
    genuine polymorphism, while compile-time polymorphism is not actually a form of
    polymorphism. During an interview, initiating such a debate is not recommended.
    It is better to act as a mediator and present both sides of the coin. We will
    discuss soon how to tackle such situations.
  prefs: []
  type: TYPE_NORMAL
- en: What is association?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key points that you should encapsulate in your answer are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Association is one of the core concepts of OOP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Association defines the relation between two classes that are independent of
    one another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Association has no owner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Association can be one-to-one, one-to-many, many-to-one, and many-to-many.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can present an answer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Association is one of the core concepts of OOP. The association goal is to
    define the relation between two classes independent of one another* and is also
    referenced as the multiplicity relation between objects. *There is no owner of
    the association*. The objects involved in an association can use one another (bidirectional
    association), or only one uses the other one (unidirectional association), but
    they have their own life span. *Association can be unidirectional/bidirectional,
    one-to-one, one-to-many, many-to-one, and many-to-many*. For example, between
    the `Person` and `Address` objects, we may have a bidirectional many-to-many relationship.
    In other words, a person can be associated with multiple addresses, while an address
    can belong to multiple people. However, people can exist without addresses, and
    vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: If further details are required, then you may share the screen or use paper
    and a pen and code your example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Person` and `Address` classes are very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The association between `Person` and `Address` is accomplished in the `main()`
    method, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named *Association*. Moving on, let's talk about
    aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: What is aggregation?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key points that you should encapsulate in your answer are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation is one of the core concepts of OOP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregation is a special case of unidirectional association.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregation represents a HAS-A relationship.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two aggregated objects have their own life cycle, but one of the objects is
    the owner of the HAS-A relationship.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can present an answer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Aggregation is one of the core concepts of OOP*. Mainly, aggregation is a
    special case of unidirectional association. While an association defines the relationship
    between two classes independent of one another, *aggregation represents a HAS-A
    relationship between these two classes*. In other words, *two aggregated objects
    have their own life cycle, but one of the objects is the owner of the HAS-A relationship*.
    Having their own life cycle means that ending one object will not affect the other
    object. For example, a `TennisPlayer` has a `Racket`. This is a unidirectional
    association since a `Racket` cannot have a `TennisPlayer`. Even if the `TennisPlayer`
    dies, the `Racket` is not affected.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, when we define the notion of aggregation, we also have a statement
    regarding what an association is. Follow this approach whenever two notions are
    tightly related and one of them is a special case of the other one. The same practice
    is applied next for defining composition as a special case of aggregation. The
    interviewer will notice and appreciate that you have an overview of things and
    that you can provide a meaningful answer that didn't overlook the context.
  prefs: []
  type: TYPE_NORMAL
- en: If further details are required, then you may share the screen or use paper
    and a pen and code your example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the `Rocket` class. This is a simple representation of a tennis
    racket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A `TennisPlayer` HAS-A `Racket`. Therefore, the `TennisPlayer` class must be
    capable of receiving a `Racket` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a `Racket` and a `TennisPlayer` that uses this `Racket`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named *Aggregation*. Moving on, let's talk about
    composition.
  prefs: []
  type: TYPE_NORMAL
- en: What is composition?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key points that you should encapsulate in your answer are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Composition is one of the core concepts of OOP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition is a more restrictive case of aggregation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition represents a HAS-A relationship that contains an object that cannot
    exist on its own.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition sustains code reuse and the visibility control of objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can present an answer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Composition is one of the core concepts of OOP*. *Primarily, composition is
    a more restrictive case of aggregation*. While aggregation represents a HAS-A
    relationship between two objects having their own life cycle, *composition represents
    a HAS-A relationship that contains an object that cannot exist on its own*. In
    order to highlight this coupling, the HAS-A relationship can be named PART-OF
    as well. For example, a `Car` has an `Engine`. In other words, the engine is PART-OF
    the car. If the car is destroyed, then the engine is destroyed as well. Composition
    is said to be better than inheritance because *it sustains code reuse and the
    visibility control of objects*.'
  prefs: []
  type: TYPE_NORMAL
- en: If further details are required, then you may share the screen or use paper
    and a pen and code your example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Engine` class is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the `Car` class. Check out the constructor of this class. Since
    `Engine` is part of `Car`, we create it with the `Car`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can test composition from the `main()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named *Composition***.**
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have covered the essential questions regarding OOP concepts. Keep
    in mind that such questions can occur in Java technical interviews for almost
    any position that involves coding or architecting applications. Especially if
    you have around 2–4 years of experience, the chances are high that you will be
    asked the preceding questions, and you must know the answers, otherwise this will
    be a black mark against you.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's continue with the SOLID principles. This is another fundamental area
    and a must-know topic alongside the OOP concepts. A lack of knowledge in this
    area will prove detrimental when it comes to a final decision regarding your interview.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the SOLID principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will formulate answers to the questions corresponding to
    the five famous design patterns for writing classes – the SOLID principles. By
    way of a quick remainder, SOLID is an acronym of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: Single Responsibility Principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: Open Closed Principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: Liskov''s Substitution Principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: Interface Segregation Principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: Dependency Inversion Principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In interviews, the most common questions pertaining to SOLID are of the *What
    is ...?* type. For example, *What is S?* or *What is D?* Typically, OOP-related
    questions are intentionally vague. This way, the interviewer tests your level
    of knowledge and wants to see whether you request further clarification. So, let's
    tackle each of these questions in turn and provide an awesome answer that will
    impress the interviewer.
  prefs: []
  type: TYPE_NORMAL
- en: What is S?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key points that you should encapsulate in your answer are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: S stands for the **Single Responsibility Principle** (SRP).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: S stands for *One class should have one, and only one, responsibility*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: S tells us to write a class for only one goal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: S sustains high maintainability and visibility control across the application
    modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can present an answer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, SOLID is an acronym for the first five **Object-Oriented Design**
    **(OOD)** principles enunciated by Robert C. Martin, also known as Uncle Bob (*optional
    phrase*). *S* is the first principle from SOLID and is known as the **Single Responsibility
    Principle** (**SRP**). *This principle translates to the fact that one class should
    have one, and only one, responsibility*. This is a very important principle that
    should be followed in any type of project for any type of class (model, service,
    controller, manager class, and so on). *As long as we write a class for only one
    goal, we will sustain high maintainability and visibility control across the application
    modules*. In other words, by *sustaining high maintainability*, this principle
    has a significant business impact, and by *providing visibility control across
    the application modules*, this principle sustains encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: If further details are required, then you may share the screen or use paper
    and a pen to code an example as the one presented here.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you want to calculate the area of a rectangle. The dimensions of
    the rectangle are initially given in meters and the area is computed in meters
    as well, but we want to be able to convert the computed area to other units, such
    as inches. Let's see the approach that breaks the SRP.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking the SRP
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing the preceding problem in a single class, `RectangleAreaCalculator`,
    can be done as follows. But this class does more than one thing: it breaks SRP.
    Keep in mind that, typically, when you use the word **and** to express what a
    class does, this is a sign that the SRP is broken. For example, the following
    class computes the area **and** converts it to inches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Since this code contravenes the SRP, we must fix it in order to follow the SRP.
  prefs: []
  type: TYPE_NORMAL
- en: Following the SRP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The situation can be remedied by removing the `metersToInches()` method from
    `RectangleAreaCalculator`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, `RectangleAreaCalculator` does only one thing (it computes the rectangle
    area), thereby observing the SRP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, `metersToInches()` can be extracted in a separate class. Moreover, we
    can add a new method for converting from meters to feet as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This class also follows the SRP, hence our job is done. The complete application
    is named *SingleResponsabilityPrinciple*. Moving on, let's talk about the second
    SOLID principle, the Open Closed Principle.
  prefs: []
  type: TYPE_NORMAL
- en: What is O?
  prefs: []
  type: TYPE_NORMAL
- en: 'The key points that you should encapsulate in your answer are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: O stands for the **Open Closed Principle** (OCP).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: O stands for *Software components should be open for extension, but closed for
    modification*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: O sustains the fact that our classes should not contain constraints that will
    require other developers to modify our classes in order to accomplish their job
    – other developers should only extend our classes to accomplish their job.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: O sustains software extensibility in a versatile, intuitive, and non-harmful
    way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can present an answer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, SOLID is an acronym for the first five **Object-Oriented Design**
    **(OOD)** principles enunciated by Robert C. Martin, also known as Uncle Bob (*optional
    phrase*). *O* is the second principle from SOLID and is known as the **Open Closed
    Principle** (OCP). This principle stands for *Software components should be open
    for extension, but closed for modification*. This means that our classes should
    be designed and written in such a way that other developers can change the behavior
    of these classes by simply extending them. So, *our classes should not contain
    constraints that will require other developers to modify our classes in order
    to accomplish their job – other developers should only extend our classes to accomplish
    their job*.
  prefs: []
  type: TYPE_NORMAL
- en: While we *must sustain software extensibility in a versatile, intuitive, and
    non-harmful way*, we don't have to think that other developers will want to change
    the whole logic or the core logic of our classes. Primarily, if we follow this
    principle, then our code will act as a good framework that doesn't give us access
    to modify their core logic, but we can modify their flow and/or behavior by extending
    some classes, passing initialization parameters, overriding methods, passing different
    options, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: If further details are required, then you may share the screen or use paper
    and a pen to code an example like the one presented here.
  prefs: []
  type: TYPE_NORMAL
- en: Now, for instance, you have different shapes (for example, rectangles, circles)
    and we want to sum their areas. First, let's see the implementation that breaks
    the OCP.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking the OCP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each shape will implement the `Shape` interface. Therefore, the code is pretty
    straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can easily use the constructors of these classes to create
    rectangles and circles of different sizes. Once we have several shapes, we want
    to sum their areas. For this, we can define an `AreaCalculator` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Since each shape has its own formula for area, we require an `if-else` (or `switch`)
    structure to determine the type of shape. Furthermore, if we want to add a new
    shape (for example, a triangle), we have to modify the `AreaCalculator` class
    to add a new `if` case. This means that the preceding code breaks the OCP. Fixing
    this code to observe the OCP imposes several modifications in all classes. Hence,
    be aware that fixing code that doesn't follow the OCP can be quite tricky, even
    in the case of a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: Following the OCP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main idea is to extract from `AreaCalculator` the area formula of each
    shape in the corresponding `Shape` class. Hence, the rectangle will compute its
    area, the circle as well, and so on. To enforce the fact that each shape must
    calculate its area, we add the `area()` method to the `Shape` contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, `Rectangle` and `Circle` implements `Shape` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `AreaCalculator` can loop the list of shapes and sum the areas by
    calling the proper `area()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The code is OCP-compliant. We can add a new shape and there is no need to modify
    the `AreaCalculator`. So, `AreaCalculator` is closed for modifications and, of
    course, is open for extension. The complete application is named the *OpenClosedPrinciple*.
    Moving on, let's talk about the third SOLID principle, Liskov's Substitution Principle.
  prefs: []
  type: TYPE_NORMAL
- en: What is L?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key points that you should encapsulate in your answer are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: L stands for **Liskov's Substitution Principle** **(LSP)**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: L stands for *Derived types must be completely substitutable for their base
    types*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: L sustains the fact that objects of subclasses must behave in the same way as
    the objects of superclasses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: L is useful for runtime-type identification followed by the cast.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can present an answer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, SOLID is an acronym for the first five `foo(p)`, where `p` is
    of the type `T`. Then, `foo(q)` should work fine if `q` is of the type `S` and
    `S` is a subtype of `T`.
  prefs: []
  type: TYPE_NORMAL
- en: If further details are required, then you may share the screen or use paper
    and a pen to code an example like the one presented here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a chess club that accepts three types of members: Premium, VIP, and
    Free. We have an abstract class named `Member` that acts as the base class, and
    three subclasses – `PremiumMember`, `VipMember`, and `FreeMember`. Let''s see
    whether each of these member types can substitute the base class.'
  prefs: []
  type: TYPE_NORMAL
- en: Breaking the LSP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Member` class is abstract, and it represents the base class for all members
    of our chess club:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PremiumMember` class can join chess tournaments or organize such tournaments
    as well. So, its implementation is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `VipMember` class is roughly the same as `PremiumMember`, so we can skip
    it and focus on the `FreeMember` class. The `FreeMember` class can join tournaments,
    but cannot organize tournaments. This is an issue that we need to tackle in the
    `organizeTournament()` method. We can throw an exception with a meaningful message
    or we can display a message as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'But throwing an exception or displaying a message doesn''t mean that we follow
    LSP. Since a free member cannot organize tournaments, it cannot be a substitute
    for the base class, therefore it breaks the LSP. Check out the following list
    of members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following loop reveals that our code is not LSP-compliant because when
    the `FreeMember` class has to substitute the `Member` class, it cannot accomplish
    its job since `FreeMember` cannot organize chess tournaments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This situation is a showstopper. We cannot continue the implementation of our
    application. We must redesign our solution to obtain a code that is LSP-compliant.
    So let's do this!
  prefs: []
  type: TYPE_NORMAL
- en: Following the LSP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The refactoring process starts by defining two interfaces meant to separate
    the two actions, joining and organizing chess tournaments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the abstract base class implements these two interfaces as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`PremiumMember` and `VipMember` remain untouched. They extend the `Member`
    base class. However, the `FreeMember` class, which cannot organize tournaments,
    will not extend the `Member` base class. It will implement the `TournamentJoiner`
    interface only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can define a list of members who can join chess tournaments as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Looping this list and substituting the `TournamentJoiner` interface with each
    type of member works as expected and observes the LSP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the same logic, a list of members who can organize chess tournaments
    can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`FreeMember` doesn''t implement the `TournamentOrganizer` interface. Therefore,
    it cannot be added to this list. Looping this list and substituting the `TournamentOrganizer`
    interface with each type of member works as expected and follows the LSP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Done! Now we have an LSP-compliant code. The complete application is named *LiskovSubstitutionPrinciple*.
    Moving on, let's talk about the fourth SOLID principle, the Interface Segregation
    Principle.
  prefs: []
  type: TYPE_NORMAL
- en: What is I?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key points that you should encapsulate in your answer are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: I stands for the **Interface Segregation Principle** (**ISP**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I stands for *Clients should not be forced to implement unnecessary methods
    that they will not use*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I splits an interface into two or more interfaces until clients are not forced
    to implement methods that they will not use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can present an answer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, SOLID is an acronym for the first five `Connection` interface,
    which has three methods: `connect()`, `socket()`, and `http()`. A client may want
    to implement this interface only for connections via HTTP. Therefore, they don''t
    need the `socket()` method. Most of the time, the client will leave this method
    empty, and this is a bad design. In order to avoid such situations, simply split
    the `Connection` interface into two interfaces; `SocketConnection` with the `socket()`
    method, and `HttpConnection` with the `http()` method. Both interfaces will extend
    the `Connection` interface that remains with the common method, `connect()`.'
  prefs: []
  type: TYPE_NORMAL
- en: If further details are required, then you may share the screen or use paper
    and a pen to code an example like the one presented here. Since we've described
    the preceding example, let's jump into the section about breaking the ISP.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking the ISP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Connection` interface defines three methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`WwwPingConnection` is a class that pings different websites via HTTP; hence,
    it requires the `http()` method, but doesn''t need the `socket()` method. Notice
    the dummy `socket()` implementation – since `WwwPingConnection` implements `Connection`,
    it is forced to provide an implementation to the `socket()` method as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Having an empty implementation or throwing a meaningful exception from methods
    that are not needed, such as `socket()`, is a really ugly solution. Check the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'What do we expect to obtain from this code? A working code that does nothing,
    or an exception caused by the `connect()` method because there is no HTTP endpoint?
    Or, we can throw an exception from `socket()` of the type: *Socket is not supported!*.
    Then, why is it here?! Hence, it is now time to refactor the code to follow the
    ISP.'
  prefs: []
  type: TYPE_NORMAL
- en: Following the ISP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to comply with the ISP, we need to segregate the `Connection` interface.
    Since the `connect()` method is required by any client, we leave it in this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `http()` and `socket()` methods are distributed in to separate interfaces
    that extend the `Connection` interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the `WwwPingConnection` class can implement only the `HttpConnection`
    interface and use the `http()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Done! Now, the code follows the ISP. The complete application is named *InterfaceSegregationPrinciple*.
    Moving on, let's talk about the last SOLID principle, the Dependency Inversion
    Principle.
  prefs: []
  type: TYPE_NORMAL
- en: What is D?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key points that you should encapsulate in your answer are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*D* stands for the **Dependency Inversion Principle** **(DIP)**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*D* stands for *Depend on abstractions, not on concretions*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*D* sustains the use of abstract layers to bind concrete modules together instead
    of having concrete modules that depend on other concrete modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*D* sustains the decoupling of concrete modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can present an answer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, SOLID is an acronym for the first five **Object-Oriented Design**
    **(OOD)** principles enunciated by Robert C. Martin, also known as Uncle Bob (*optional
    phrase*). *D* is the last principle from SOLID and is known as the **Dependency
    Inversion Principle****(DIP)**. This principle stands for *Depend on abstractions,
    not on concretions*. This means that we should *rely on abstract layers to bind
    concrete modules together instead of having concrete modules that depend on other
    concrete modules*. To accomplish this, all concrete modules should expose abstractions
    only. This way, the concrete modules allow extension of the functionality or plug-in
    in another concrete module while retaining the decoupling of concrete modules.
    Commonly, high coupling occurs between high-level concrete modules and low-level
    concrete modules.
  prefs: []
  type: TYPE_NORMAL
- en: If further details are required, then you may share the screen or use paper
    and a pen to code an example.
  prefs: []
  type: TYPE_NORMAL
- en: A database JDBC URL, `PostgreSQLJdbcUrl`, can be a low-level module, while a
    class that connects to the database may represent a high-level module, such as
    `ConnectToDatabase#connect()`.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking the DIP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we pass to the `connect()` method an argument of the `PostgreSQLJdbcUrl`
    type, then we have violated the DIP. Let''s look at the code of `PostgreSQLJdbcUrl`
    and `ConnectToDatabase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If we create another type of JDBC URL (for example, `MySQLJdbcUrl`), then we
    cannot use the preceding `connect(PostgreSQLJdbcUrl postgreSQL)` method. So, we
    have to drop this dependency on concrete and create a dependency on abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Following the DIP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The abstraction can be represented by an interface that should be implemented
    by each type of JDBC URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, `PostgreSQLJdbcUrl` implements `JdbcUrl` to return a JDBC URL specific
    to PostgreSQL databases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In precisely the same manner, we can write `MySQLJdbcUrl`, `OracleJdbcUrl`,
    and so on. Finally, the `ConnectToDatabase#connect()` method is dependent on the
    `JdbcUrl` abstraction, so it can connect to any JDBC URL that implements this
    abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Done! The complete application is named *DependencyInversionPrinciple*.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've covered the OOP fundamental concepts and the popular SOLID principles.
    If you plan to apply for a Java position that includes the design and architecture
    of applications, then it is recommended that you take a look at the **General
    Responsibility Assignment Software Principles** **(GRASP)** as well ([https://en.wikipedia.org/wiki/GRASP_(object-oriented_design](https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)).
    This is not a popular topic in interviews, but you never know!
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, we will scan a bunch of popular questions that combine these notions.
    Now that you are familiar with the **Understand the Question** | **Nominate key
    points | Answer** technique, I will only highlight the key points in the answer
    without extracting them as a list beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: Popular questions pertaining to OOP, SOLID, and GOF design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will tackle some more difficult questions that require a
    true understanding of OOP concepts, SOLID design principles, and **Gang of Four**
    **(GOF)** design patterns. Note that this book doesn't cover GOF design patterns,
    but there are great books and videos out there that are dedicated to this topic.
    I recommend that you try *Learn Design Patterns with Java*, by Aseem Jain ([https://www.packtpub.com/application-development/learn-design-patterns-java-video](https://www.packtpub.com/application-development/learn-design-patterns-java-video)).
  prefs: []
  type: TYPE_NORMAL
- en: What is method overriding in OOP (Java)?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Method overriding is an object-oriented programming technique that allows
    the developer to write two methods (***non-static, non-private and non-final***)
    with the same name and signature but different behavior.* Method overriding can
    be used in the presence of **Inheritance** or **Runtime Polymorphism**.'
  prefs: []
  type: TYPE_NORMAL
- en: In the presence of inheritance, we have a method in the superclass (referenced
    as the overridden method) and we override it in the subclass (referenced as the
    overriding method). In Runtime Polymorphism, we have a method in an interface
    and the classes that implements this interface are overriding this method.
  prefs: []
  type: TYPE_NORMAL
- en: '*Java decides at runtime the actual method that should be called, depending
    upon the type of object*. Method overriding sustains flexible and extensible code,
    or, in other words, *it sustains the addition of new functionality with minimal
    code changes*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If further details are required, then you can list the main rules that govern
    method overriding:'
  prefs: []
  type: TYPE_NORMAL
- en: The name and signature (including the same return type or subtype) of the method
    is the same in the superclass and subclass, or in the interface and implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot override a method in the same class (but we can overload it in the
    same class).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot override `private`, `static`, and `final` methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overriding method cannot reduce the accessibility of the overridden method,
    but the opposite is possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overriding method cannot throw checked exceptions that are higher in the
    exception hierarchy than the checked exception thrown by the overridden method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always use the `@Override` annotation for the overriding method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of overriding methods in Java is available in the code bundled to
    this book under the name *MethodOverriding*.
  prefs: []
  type: TYPE_NORMAL
- en: What is method overloading in OOP (Java)?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Method overloading is an object-oriented programming technique that allows
    the developer to write two methods (both static or non-static) with the same name,
    but a different signature and different functionalities*. By different signature,
    we understand a different number of arguments, different types of arguments, and/or
    a different order of arguments list. *The return type is not part of the method
    signature*. Therefore, the case when two methods have identical signatures, but
    different return types, is not a valid case of method overloading. So, this is
    a powerful technique that allows us to write methods (both static or non-static)
    having the same name but with different inputs. The *compiler bind overloaded
    method calls to the actual method; therefore, no binding is done during runtime*.
    A famous example of method overloading is `System.out.println()`. The `println()`
    method has several overloading flavors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, there are four main rules that govern method overloading:'
  prefs: []
  type: TYPE_NORMAL
- en: Overloading is accomplished by changing the method signature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return type is not part of the method signature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can overload `private`, `static`, and `final` methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can overload a method in the same class (but we cannot override it in the
    same class).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If further details are required, you can try to code an example. An example
    of overloading methods in Java is available in the code bundled to this book under
    the name *MethodOverloading*.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Besides the two aforementioned questions, you may need to answer some other
    related questions, including *What rules govern method overloading and overriding*
    (see above)?, *What are the main differences between method overloading and overriding*
    (see above)?, *Can we override a static or a private method* (the short answer
    is *No*, see above)?, *Can we override a final method* (the short answer is *No*,
    see above)?, *Can we overload a static method* (the short answer is *Yes*, see
    above)?, *Can we change the argument list of an overriding method* (the short
    answer is *No*, see above)? So, it is advisable to extract and prepare the answers
    to such questions. All the information required is available in the preceding
    section. Also, pay attention to questions such as *Is it true that we can only
    prevent overriding a method via the final modifier*? This type of wording is meant
    to confuse the candidate because the answer requires an overview of the notion
    involved. The answer here can be formulated as *This is not true, because we can
    prevent overriding a method by marking it as private or static as well. Such methods
    cannot be overridden*.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, let's examine several other questions related to overriding and overloading
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: What is covariant method overriding in Java?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Covariant method overriding is a less known feature introduced in Java 5\. By
    means of this feature, *an overriding method can return a subtype of its actual
    return type.* This means that a client of the overriding method doesn't need an
    explicit type casting of the returned type. For example, the Java `clone()` method
    returns `Object`. This means that, when we override this method to return a clone,
    we get back an `Object` that must be explicitly casted to the actual subclass
    of `Object` that we need. However, if we take advantage of the Java 5 covariant
    method overriding feature, then the overriding `clone()` method can return the
    requisite subclass directly instead of `Object`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Almost always, a question such as this requires an example as part of the answer,
    so let''s consider the `Rectangle` class that implements the `Cloneable` interface.
    The `clone()` method can return `Rectangle` instead of `Object` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the `clone()` method doesn''t require an explicit cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete application is named *CovariantMethodOverriding*. Pay attention
    to less direct questions regarding covariant method overriding. For example, it
    can be formulated like this: *Can we modify the return type of method to subclass
    while overriding?* The answer to this question is the same as *What is covariant
    method overriding in Java?*, discussed here.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the answer to questions that target less known features of Java can
    be a big plus at the interview. This demonstrates to the interviewer that you
    have a deep level of knowledge and that you are up to date with the Java evolution.
    If you require a supersonic update of all JDK 8 to JDK 13 features via tons of
    examples and minimum theory, then you will love my book entitled *Java Coding
    Problems*, published by Packt ([packtpub.com/au/programming/java-coding-problems](https://www.packtpub.com/product/java-coding-problems/9781789801415)).
  prefs: []
  type: TYPE_NORMAL
- en: What are the main restrictions in terms of working with exceptions in overriding
    and overloading methods?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let's discuss the overriding methods. *If we talk about unchecked exceptions,
    then we must say that there are no restrictions on using them in overriding methods*.
    Such methods can throw an unchecked exception, hence, any `RuntimeException`.
    On the other hand, *in the case of checked exceptions, the overriding methods
    can throw only the checked exception of the overridden method or a subclass of
    that checked exception*. In other words, an overriding method cannot throw a checked
    exception that has a broader scope than the checked exception thrown by the overridden
    method. For example, if the overridden method throws `SQLException`, then the
    overriding method can throw subclasses such as `BatchUpdateException`, but it
    cannot throw super classes such as `Exception`.
  prefs: []
  type: TYPE_NORMAL
- en: Second, let's discuss the overloading methods. *Such methods do not impose any
    kind of restrictions*. This means that we can modify the `throw` clause as required.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Pay attention to questions that are worded along the lines of *What are the
    main ...?, Can you enumerate the certain ...?, Can you nominate the...?, Can you
    highlight the ...?*, and so on. Commonly, when the question contains words such
    as *main, certain, nominate,* and *highlight*, the interviewer expects a clear
    and concise answer that should sound like a bullet list. The best practice for
    answering such questions is to jump into the response directly and enumerate each
    item as a compressed and meaningful statement. Don't make the common mistake of
    embarking on a story or dissertation of the notions involved before giving the
    expected answer. The interviewer wants to see your ability to synthesize and sanitize
    things and extract the essence while checking your level of knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: If more detail is required, then you can code an example like those from the
    code bundled to this book. Consider checking the *OverridingException* and *OverloadingException*
    applications. Now, let's continue with some more questions.
  prefs: []
  type: TYPE_NORMAL
- en: How can the superclass overridden method be called from the subclass overriding
    method?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*We can call the superclass overridden method from the subclass overriding
    method via the Java* `super` *keyword*. For example, consider a superclass, `A`,
    that contains a method, `foo()`, and a subclass of `A` named `B`. If we override
    the `foo()` method in subclass `B`, and we call `super.foo()` from the overriding
    method, `B#foo()`, then we call the overridden method, `A#foo()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Can we override or overload the main() method?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We must keep in mind that the `main()` method is static. This means that we
    can overload it. However, we cannot override it because the static methods are
    resolved at compile time, while the methods that we can override are resolved
    at runtime depending upon the type of object.
  prefs: []
  type: TYPE_NORMAL
- en: Can we override a non-static method as static in Java?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No. *We cannot override a non-static method as static*. Moreover, the reverse
    is not possible either. Both lead to compilation errors.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Questions that are to the point, like the last two aforementioned questions,
    deserve a short and concise answer. Interviewers trigger such flashlight questions
    to measure your ability to analyze a situation and make a decision. Mainly, the
    answer is brief, but you need some time to say *Yes* or *No*. Such questions don't
    carry a high score, but they may have a significant negative impact if you don't
    know the answer. If you know the answer, the interviewer might say in his mind,
    *Well, OK, this was an easy question anyway!* But, if you don't know the answer,
    then he might say, *He missed an easy one! There is a serious shortcoming in her/his
    basic knowledge.*
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's look at some more questions related to other OOP concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Can we have a non-abstract method inside a Java interface?
  prefs: []
  type: TYPE_NORMAL
- en: '*Until Java 8, we could not have a non-abstract method in a Java interface*.
    All methods from an interface were implicitly public and abstract. However, starting
    with Java 8, we have new types of methods that can be added to an interface. *In
    practical terms, starting with Java 8, we can add methods that have implementations
    directly in interfaces. This can be done by using the* `default` *and* `static`
    *keywords. The* `default` *keyword was introduced in Java 8 for including in interfaces
    the methods known as*`static` *methods in interfaces are quite similar to the
    default methods, the only difference being that we cannot override* `static` *methods
    in the classes that implement these interfaces*. Since `static` methods are not
    bound to an object, they can be called by using the interface name preceded by
    a dot and the method name. Moreover, `static` methods can be called within other
    `default` and `static` methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If further details are required, then you can try to code an example. Consider
    that we have an interface for shaping a vehicle like a steam car (this is an old
    car type exactly like old code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, different kinds of steam cars have been built by means of the following
    `SteamCar` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `SteamCar` class implements the `Vehicle` interface, it overrides
    the `speedUp()` and `slowDown()` methods. After a while, petrol cars are invented,
    and people start to care about horsepower and fuel consumption. So, our code must
    evolve to provide support for petrol cars as well. To compute the level of consumption,
    we can evolve the `Vehicle` interface by adding the `computeConsumption()` default
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Evolving the `Vehicle` interface doesn''t break `SteamCar` compatibility. Furthermore,
    electric cars have been invented. Computing the consumption of an electric car
    is not the same as in the case of a petrol car, but the formula relies on the
    same terms: the fuel, distance, and horsepower. This means that `ElectricCar`
    will override `computeConsumption()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we can override a `default` method, or we can use the implicit implementation.
    Finally, we have to add a description to our interface since now it serves steam,
    petrol, and electric cars. We can do this by adding to `Vehicle` a `static` method
    named `description()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This `static` method is not bound to any type of car and it can be called directly
    via `Vehicle.description()`. The complete code is named *Java8DefaultStaticMethods*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's continue with other questions. So far, you should be pretty familiar
    with the **Understand the Question**|**Nominate key points**|**Answer** technique,
    so I will stop highlighting the key points. From now on, it is your job to spot
    them.
  prefs: []
  type: TYPE_NORMAL
- en: What are the main differences between interfaces with default methods and abstract
    classes?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Among the differences between Java 8 interfaces and abstract classes, we can
    mention the fact that an abstract class can have a constructor while an interface
    doesn't support constructors. So, an abstract class can have a state while an
    interface cannot have a state. Moreover, interfaces remain the first citizens
    of full abstraction, with the main purpose of being implemented, while abstract
    classes are meant for partial abstraction. Interfaces are still designed to target
    completely abstract things that don't do anything by themselves, but specify contracts
    about how things will work at implementation. The default methods represent an
    approach for adding additional features to the interfaces without affecting the
    client code and without changing the state. They shouldn't be used for other purposes.
    In other words, another difference consists of the fact that it is perfectly fine
    to have an abstract class with no abstract methods, but it is an anti-pattern
    to have an interface only with default methods. This means that we have created
    the interface as a utility class substitute. This way, we defeat the main purpose
    of an interface, which is to be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When you have to enumerate a bunch of differences or similarities between two
    notions, pay attention to limit your answer to the coordinates settled by the
    question. For example, in the case of the preceding question, do not say that
    one difference lies in the fact that interfaces sustain multiple inheritance while
    abstract classes don't. This is a general variation between interfaces and classes,
    and not specifically between Java 8 interfaces and abstract classes.
  prefs: []
  type: TYPE_NORMAL
- en: What is the main difference between abstract classes and interfaces?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until Java 8, the main difference between abstract classes and interfaces consisted
    of the fact that an abstract class can contain non-abstract methods, while an
    interface cannot contain such methods. Starting with Java 8, the main difference
    consists of the fact that an abstract class can have constructors and state while
    an interface cannot have either of these.
  prefs: []
  type: TYPE_NORMAL
- en: Can we have an abstract class without an abstract method?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yes, we can. By adding the `abstract` keyword to a class, it becomes abstract.
    It cannot be instantiated, but it can have constructors and only non-abstract
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Can we have a class that is both abstract and final at the same time?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A final class cannot be sub-classed or inherited. An abstract class is meant
    to be extended in order to be used. Therefore, final and abstract are opposite
    notions. This means that they cannot be applied to the same class at the same
    time. The compiler will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between polymorphism, overriding, and overloading?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the context of this question, the overloading technique is known as **Compiled-Time
    Polymorphism**, while the overriding technique is known as **Runtime Polymorphism**.
    Overloading involves the use of static (or early) binding, while overriding uses
    dynamic (or late) binding.
  prefs: []
  type: TYPE_NORMAL
- en: The next two questions constitute add-ons to this one, but they can be formulated
    as standalone as well.
  prefs: []
  type: TYPE_NORMAL
- en: What is a binding operation?
  prefs: []
  type: TYPE_NORMAL
- en: A binding operation determines the method (or variable) to be called as a result
    of its references in the code lines. In other words, the process of associating
    a method call to the method body is known as a binding operation. Some references
    are bound at compile time, while other references are bound at runtime. Those
    that are bound at runtime depend upon the type of object. The references resolved
    at compile time are known as static binding operations, while those resolved at
    runtime are known as dynamic binding operations.
  prefs: []
  type: TYPE_NORMAL
- en: What are the main differences between static and dynamic binding?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, static binding occurs at compile time, while dynamic binding occurs
    at runtime. The second thing to consider involves the fact that private, static,
    and final members (methods and variables) use static binding, while virtual methods
    are bonded at runtime based upon the type of object. In other words, static binding
    is accomplished via `Type` (class in Java) information, while dynamic binding
    is accomplished via `Object`, meaning that a method relying on static binding
    is not associated with an object, but is instead called on `Type` (class in Java),
    while a method relying on dynamic binding is associated with an `Object`. The
    execution of methods that rely on static binding is marginally faster than those
    that rely on dynamic binding. Static and dynamic binding are used in polymorphism
    as well. Static binding is used by compile-time polymorphism (overloading methods),
    while dynamic binding is used in runtime polymorphism (overriding methods). Static
    binding adds overhead in terms of performance at compile time, while dynamic binding
    adds overhead in terms of performance at runtime, meaning that static binding
    is preferable.
  prefs: []
  type: TYPE_NORMAL
- en: What is method hiding in Java?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Method hiding is specific to static methods. More precisely, if we declare two
    static methods with the same signature and name in the superclass and in the subclass,
    then they will hide each other. Calling the method from the superclass will call
    the static method from the superclass, and calling the same method from the subclass
    will call the static method from the subclass. Hiding is not the same thing with
    overriding because static methods cannot be polymorphic.
  prefs: []
  type: TYPE_NORMAL
- en: 'If further details are required, then you can write an example. Consider the
    `Vehicle` superclass having the `move()` static method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, consider the `Car` subclass having the same static method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s call these two static methods from the `main()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The output reveals that these two static methods are hiding one another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we call static methods via the class name. Calling static methods
    on instances is a very bad practice, so avoid doing this during an interview!
  prefs: []
  type: TYPE_NORMAL
- en: Can we write virtual methods in Java?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yes, we can! Actually, in Java, all non-static methods are, by default, virtual
    methods. We can write a non-virtual method by marking it with the `private` and/or
    `final` keyword. In other words, the methods that can be inherited for polymorphic
    behavior are virtual methods. Or, if we turn the logic of this statement on its
    head, the methods that cannot be inherited (marked as `private`) and the methods
    that cannot be overridden (marked as `final`) are non-virtual.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between polymorphism and abstraction?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Abstraction and polymorphism represent two fundamental OOP concepts that are
    interdependent. Abstraction allows the developer to design general solutions that
    are reusable and customizable, while polymorphism allows the developer to defer
    choosing the code that should be executed at runtime. While abstraction is implemented
    via interfaces and abstract classes, polymorphism relies on overriding and overloading
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Do you consider overloading an approach for implementing polymorphism?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a controversial topic. Some people do not regard overloading as polymorphism;
    therefore, they do not accept the idea of compile-time polymorphism. Such voices
    maintain that the only overriding method is genuine polymorphism. The argument
    behind this statement says that only overriding allows code to behave differently
    depending on the runtime conditions. In other words, exhibiting polymorphic behavior
    is the privilege of method overriding. I consider that as long as we understand
    the premises of overloading and overriding, we also understand how both variants
    sustain polymorphic behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Questions that tackle controversial topics are delicate and hard to approach
    correctly. Therefore, it is advisable to jump into the answer directly with this
    statement *This is a controversial topic*. Of course, the interviewer is interested
    to hear your opinion as well, but he will be pleased to see that you know both
    sides of the coin. As a rule of thumb, try to answer in an objective manner and
    don't approach one side of a coin with radicalism or with a poor arsenal of arguments.
    Controversial things remain controversial after all, and this is not the proper
    time and place to demystify them.
  prefs: []
  type: TYPE_NORMAL
- en: OK, now let's continue with some questions based on the SOLID principles and
    the famous and indispensable **Gang Of Four** **(GOF)** design patterns. Note
    that this book doesn't cover GOF design patterns, but there are great books and
    videos out there that are dedicated to this topic. I recommend that you try *Learn
    Design Patterns with Java*, by Aseem Jain ([https://www.packtpub.com/application-development/learn-design-patterns-java-video)](https://www.packtpub.com/application-development/learn-design-patterns-java-video)).
  prefs: []
  type: TYPE_NORMAL
- en: Which OOP concept serves the Decorator design pattern?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OOP concept that serves the Decorator design pattern is **Composition**.
    Via this OOP concept, the Decorator design pattern provides new functionalities
    without modifying the original class.
  prefs: []
  type: TYPE_NORMAL
- en: When should the Singleton design pattern be used?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Singleton design pattern seems to be the proper choice when we need just
    one application-level (global) instance of a class. Nevertheless, a Singleton
    should be used with precaution because it increases the coupling between classes
    and can become a bottleneck during development, testing, and debugging. As the
    famous *Effective Java* points out, using Java enums is the best way of implementing
    this pattern. It is a common scenario to rely on a Singleton pattern for global
    configurations (for example, loggers, `java.lang.Runtime`), hardware access, database
    connections, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you can cite or mention famous references, do so.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between the Strategy and State design patterns?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The State design pattern is meant to do a certain thing depending upon the *state*
    (it exhibits certain behaviors in different *states* without changing the class).
    The Strategy design pattern, on the other hand, is meant to be used for switching
    between a range of algorithms without modifying the code that uses it (the client
    uses algorithms interchangeably via composition and runtime delegation). Moreover,
    in State, we have a clear order of *state* transition (the flow is created by
    linking each *state* to another *state*), while in Strategy, the client can choose
    the algorithm that it wants in any order. For example, the State pattern can define
    the *states* of sending a package to a client.
  prefs: []
  type: TYPE_NORMAL
- en: The package starts from the *ordered state*, and continues with the *delivered
    state* and so on until it passes through each *state* and reaches the final *state*
    when the client has *received* the package. On the other hand, the Strategy pattern
    defines different strategies for accomplishing each *state* (for example, we may
    have different strategies for delivering the package).
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between the Proxy and Decorator patterns?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Proxy design pattern is useful for providing an access control gateway to
    something. Commonly, this pattern creates proxy objects that stand in place of
    the real object. Each request for the real object must pass through the proxy
    objects, which decides how and when to forward it to the real object. The Decorator
    design pattern never creates an object, it just decorates an existing object at
    runtime with new functionality. While chaining proxies is not an advisable practice,
    chaining decorators in a certain order exploits this pattern in the right way.
    For example, while the Proxy pattern can represent a proxy server for the internet,
    the Decorator pattern can be used to decorate the proxy server with different
    custom settings.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between the Facade and Decorator patterns?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the Decorator design pattern is meant to add new functionalities to an
    object (in other words, to decorate the object), the Facade design pattern doesn't
    add new functionalities at all. It just facades the existing functionalities (hides
    the complexities of a system) and calls them behind the scenes via a *friendly
    face* exposed to the client. The Facade pattern can expose a simple interface
    that calls individual components to accomplish complex tasks. For example, the
    Decorator pattern can be used to build a car by decorating a chassis with an engine,
    a gearbox, and so on, while the Facade pattern can hide the complexity of building
    the car by exposing a simple interface for command industrial robots that know
    the building process details.
  prefs: []
  type: TYPE_NORMAL
- en: What is the key difference between the Template Method and the Strategy pattern?
  prefs: []
  type: TYPE_NORMAL
- en: The Template Method and Strategy patterns encapsulate domain-specific sets of
    algorithms into objects, but they don't do it in the same way. The key difference
    consists of the fact that the Strategy pattern is meant to decide at runtime between
    different strategies (algorithms) based on the requirements, while the Template
    Method pattern is meant to follow a fixed skeleton (predefined sequence of steps)
    implementation of an algorithm. Some steps are fixed, while other steps can be
    modified for different uses. For example, the Strategy pattern may decide between
    different payment strategies (for example, a credit card or PayPal), while the
    Template Method can describe the predefined sequence of steps for paying with
    a certain strategy (for example, payment via PayPal requires a fixed sequence
    of steps).
  prefs: []
  type: TYPE_NORMAL
- en: What is the key difference between the Builder and Factory patterns?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Factory pattern creates an object in a single method call. We have to pass
    in this call all the necessary parameters and the factory will return the object
    (commonly, by invoking a constructor). On the other hand, the Builder pattern
    is designed for building complex objects via chains of setter methods that allow
    us to shape any combination of parameters. At the end of the chain, the Builder
    method exposes a `build()` method that signals that the list of parameters is
    set, and it is time to build the object. In other words, Factory acts as a wrapper
    of a constructor, while Builder is much granular, acting as a wrapper of all the
    possible parameters you might want to pass into a constructor. Via Builder, we
    avoid the telescopic constructor used to expose all the possible combinations
    of parameters. For example, think back to the `Book` object. A book is characterized
    by a hand of fixed parameters such as the author, title, ISBN, and format. Most
    probably, you will not be juggling with the number of these parameters when creating
    books, and therefore the factory pattern will be a good fit for factoring books.
    But how about a `Server` object? Well, a server is a complex object with tons
    of optional parameters, and so the Builder pattern is much more appropriate here,
    or even a combination of these patterns where Factory relies internally on Builder.
  prefs: []
  type: TYPE_NORMAL
- en: What is the key difference between the Adapter and Bridge patterns?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Adapter pattern strives to provide compatibility between an existing code
    that we cannot modify (for example, third-party code) and a new system or interface.
    On the other hand, the Bridge pattern is implemented upfront and is meant to decouple
    an abstraction from implementation in order to avoid an insane number of classes.
    So, Adapter strives to provide compatibility between things after they were designed
    (think along the lines of *A comes from After*), while Bridge is built upfront
    to let the abstraction and the implementation vary independently (think along
    the lines of *B comes from Before*). While Adapter acts as the `ReadJsonRequest`
    and `ReadXmlRequest`, which are capable of reading from several devices, such
    as `D1`, `D2`, and `D3`. `D1` and `D2` produce only JSON requests, while `D3`
    produces XML requests only. Via Adapter, we can convert between JSON and XML,
    meaning that these two classes can communicate with all three devices. On the
    other hand, via the Bridge pattern, we can avoid ending with many classes such
    as `ReadXMLRequestD1`, `ReadXMLRequestD2`, `ReadXMLRequestD3`, `ReadJsonRequestD1`,
    `ReadJsonRequestD2`, and `ReadJsonRequestD3`.
  prefs: []
  type: TYPE_NORMAL
- en: We can continue to compare design patterns until we finish all the possible
    combinations. The final few of these questions have covered the most popular questions
    of the type **Design Pattern 1 versus Design Pattern 2**. It is strongly advisable
    to challenge yourself with these types of questions and try to identify similarities
    and differences between two or more given design patterns. Most of the time, these
    questions use two design patterns from the same category (for example, two structural
    or two creational patterns), but they can be from different categories as well.
    In such a case, this is the first statement that the interviewer expects to hear.
    So, in such cases, start by saying to which category each of the design patterns
    involved belongs.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we skipped all simple questions of the type, *What is an interface?,
    What is an abstract class?,* and so on. Typically, such questions are avoided
    since they don't say much about your understanding level, being more about reciting
    some definitions. The interviewer can ask *What is the main difference between
    abstract classes and interfaces?*, and he can deduce from your answer whether
    you know what an interface and an abstract class is. Always be prepared to give
    examples. The inability to shape an example reveals a serious lack of understanding
    of the essence of things.
  prefs: []
  type: TYPE_NORMAL
- en: Having OOP knowledge is just half of the problem. The other half is represented
    by having the vision and agility to put this knowledge into designing applications.
    This is what we will do in the next 10 examples. Keep in mind that we are focused
    on design, not on implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we will tackle several coding challenges regarding object-oriented programming.
    For each problem, we will follow Figure 5.2 from [*Chapter 5*](B15403_05_Final_JM_ePub.xhtml#_idTextAnchor072)*,
    How to Approach a Coding Challenge*. Mainly, we will start by asking the interviewer
    a question such as *What are the design constraints?* Commonly, coding challenges
    that orbit OOD are expressed by the interviewer in a general way. This is done
    intentionally to make you ask details about design constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a clear picture of the constraints, we can try an example (which
    can be a sketch, a step-by-step runtime visualization, a bullet list, and suchlike).
    Then, we figure out the algorithm(s)/solution(s), and finally, we provide the
    design skeleton.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1: Jukebox'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Design the main classes of the jukebox musical machine.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What to ask**: What is the jukebox playing – CDs, MP3s? What should I design
    – the jukebox building process, how it works, or something else? It is a free
    jukebox or is money required?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interviewer**: Is a free jukebox playing only CDs? Design its main functionalities,
    and therefore design how it works.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: In order to understand what classes should be involved in our
    design, we can try to visualize a jukebox and identify its main parts and functionalities.
    Sketching a diagram along the lines of the one here also helps the interviewer
    to see how you think. I suggest that you always take the approach of visualizing
    the problem in a written form – a sketch is a perfect start:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Jukebox'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.1_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Jukebox
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can identify the two main parts of a jukebox: a CD player (or a specific
    jukebox-playing mechanism) and an interface with commands for the users. The CD
    player is capable of managing a playlist and playing those songs. We can think
    of the interface of commands as a Java interface implemented by a Jukebox as shown
    in the next code. Along with the following code, you can use the UML diagram from
    here: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/Jukebox/JukeboxUML.png](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/Jukebox/JukeboxUML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CDPlayer` is the heart of the jukebox. Via `Selector`, we control the
    `CDPlayer` behavior. `CDPlayer` must have access to the set of available CDs and
    to the playlist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `Playlist` manages a list of `Song`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The `User`, `CD`, and `Song` classes are skipped for now, but you can find them
    all in the complete application named *Jukebox*. This kind of problem can be implemented
    in a wide variety of ways, so feel free to try your own designs as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2: Vending machine'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Design the main classes that sustain the implementation of the
    functionalities of a typical vending machine.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What to ask**: Is this a vending machine with different types of coins and
    items? Does it expose functionalities, such as checking an item price, buying
    an item, a refund, and resetting?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interviewer**: Yes, exactly! For coins, you can consider a penny, a nickel,
    a dime, and a quarter.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: In order to understand what classes should be involved in our
    design, we can try to sketch a vending machine. There are a wide range of vending
    machine types. Simply sketch one that you know (like the one in the following
    diagram):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Vending machine'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.2_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – Vending machine
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we immediately notice that items and coins are good candidates
    for Java enums. We have four types of coins and several types of items, so we
    can write two Java enums as follows. Along with the following code, you can use
    the UML diagram from here: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/VendingMachine/VendingMachineUML.png](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/VendingMachine/VendingMachineUML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The vending machine needs an internal inventory to track the items and status
    of the coins. We can shape this generically as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can focus on the buttons used by a client to interact with the vending
    machine. As you saw in the previous example as well, it is common practice to
    extract these buttons to an interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the vending machine can be shaped to implement the `Selector` interface
    and provide a bunch of private methods used to accomplish the internal tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named *VendingMachine*. By following the two aforementioned
    examples, you can try to design an ATM, a washing machine, and similar things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 3: Deck of cards'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Design the main classes of a generic deck of cards.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What to ask**: Since a card can be almost anything, can you define *generic*?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interviewer**: A card is characterized by a symbol (suit) and a value. For
    example, think of a standard 52-card set.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: In order to understand what classes should be involved in our
    design, we can quickly sketch a card and a deck of cards for the standard 52-card
    set, as shown in Figure 6.3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – A deck of cards'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.3_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – A deck of cards
  prefs: []
  type: TYPE_NORMAL
- en: Since every card has a suit and a value, we will need a class that encapsulates
    these fields. Let's call this class `StandardCard`. A suit for `StandardCard`
    contains a *Spade, Heart, Diamond*, or *Club*, so this suit is a good candidate
    for a Java enum. A `StandardCard` value can be between 1 and 13.
  prefs: []
  type: TYPE_NORMAL
- en: A card can live as a standalone or be a part of a pack of cards. Multiple cards
    form a pack of cards (for example, a standard 52-card set forms a pack of cards).
    The number of cards in a pack is usually obtained as a Cartesian product between
    the possible suits and values (for example, 4 suits x 13 values = 52 cards). So,
    52 `StandardCard` objects form `StandardPack`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a deck of cards should be a class capable of performing some actions
    with this `StandardPack`. For example, a deck of cards can shuffle the cards,
    can deal a hand or a card, and so on. This means that a `Deck` class is also needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have settled on having a Java `enum` and the `StandardCard`, `StandardPack`,
    and `Deck` classes. If we add the abstraction layers needed to avoid high coupling
    between these concrete layers, then we obtain the following implementation. Along
    with the following code, you can use the UML diagram from here: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/DeckOfCards/DeckOfCardsUML.png](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/DeckOfCards/DeckOfCardsUML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For standard card implementation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Standard pack of cards implementation gives the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Deck of cards implementation provides the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'A demo of the code can be quickly written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, you can easily add more types of cards by extending the `Card`
    and `Pack` classes. The complete code is named *DeckOfCards*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 4: Parking lot'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Design the main classes of a parking lot.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What to ask**: Is it a single-level or multi-level parking lot? Are all parking
    space spots the same? What type of vehicles should we park? Is it free parking?
    Do we use parking tickets?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interviewer**: It is a synchronous automatic multi-level free parking lot.
    All parking spots are the same size, but we expect cars (1 spot needed), vans
    (2 spots needed) and trucks (5 spots needed). Other types of vehicles should be
    added without modifying the code. The system releases a parking ticket that can
    be used later to unpark the vehicle. But if the driver introduces only the vehicle
    information (assuming a lost ticket), the system should still work and locate
    the vehicle in the parking lot and unpark it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: In order to understand what classes should be involved in our
    design, we can quickly sketch a parking lot to identify the main actors and behaviors
    as in Figure 6.4:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – A parking lot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.4_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – A parking lot
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram reveals two major actors: the parking lot and the automatic parking
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s focus on the parking lot. The main purpose of a parking lot is
    to park vehicles; therefore, we need to shape the accepted vehicles (car, van,
    and truck). This looks like a typical case for an abstract class (`Vehicle`) and
    three subclasses (`Car`, `Van`, and `Truck`). But this is not true! The driver
    provides information about their vehicle. They don''t effectively push the vehicle
    (the object) into the parking system, so our system does not need dedicated objects
    for cars, vans, trucks, and so on. Think from the perspective of a parking lot.
    It needs the vehicle license plate and the free spots required for parking. It
    doesn''t care about the characteristics of a van or a truck. So, we can shape
    a `Vehicle` as follows. Along with the following code, you can use the UML diagram
    from here: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/ParkingLot/ParkingLotUML.png](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/ParkingLot/ParkingLotUML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to design the parking lot. Mainly, a parking lot has several
    floors (or levels) and each floor has parking spots. Among others, a parking lot
    should expose methods for parking/unparking a vehicle. These methods will delegate
    the parking/unparking tasks to each floor (or to a certain floor) until it succeeds
    or there is no floor to scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'A parking floor controls the parking/unparking process on a certain floor.
    It has its own registry of parking tickets and is capable of managing its parking
    spots. Mainly, each parking floor acts as an independent parking lot. This way,
    we can shut down a complete floor while the remainder of the floors are not affected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, a parking spot is an object that holds information about its name
    (label or number), availability (whether it is free) and vehicle (whether a vehicle
    is parked on that spot). It also has methods for assigning/removing a vehicle
    to/from this spot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'At this moment, we have all the major classes of the parking lot. Next, we
    are going to focus on the automatic parking system. This can be shaped as a single
    class that acts as a dispatcher of the parking lot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The complete application containing a partial implementation as well is named
    *ParkingLot*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 5: Online reader system'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Design the main classes of an online reader system.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What to ask**: What are the required functionalities? How many books can
    be read simultaneously?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interviewer**: The system should be capable of managing readers and books.
    Your code should be able to add/remove a reader/book and to display a reader/book.
    The system can serve a single reader and a single book at a time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: In order to understand what classes should be involved in our
    design, we can think about sketching something as in Figure 6.5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – An online reader system'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.5_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – An online reader system
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to manage readers and books, we need to have such objects. This is
    a small and easy part, and starting with such parts in an interview is very helpful
    for breaking the ice and accommodating the problem at hand. When we design objects
    in an interview, there is no need to come up with a full version of an object.
    For example, a reader having a name and email, and a book having an author, title,
    and ISBN is more than sufficient. Let''s see them in the following code. Along
    with the following code, you can use the UML diagram from here: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/OnlineReaderSystem/OnlineReaderSystemUML.png](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/OnlineReaderSystem/OnlineReaderSystemUML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, if we consider that books are usually managed by a library, then we can
    wrap several functionalities, such as adding, finding, and removing a book, in
    a class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Readers can be managed by a similar class named `ReaderManager`. You can find
    this class in the complete application. To read a book, we require a displayer.
    The `Displayer` should display the reader and the book details and should be capable
    of navigating through the books pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, all we have to do is to wrap `Library`, `ReaderManager`, and `Displayer`
    in the `OnlineReaderSystem` class. This class is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named *OnlineReaderSystem*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 6: Hash table'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Design a hash table (this is a very popular problem in interviews).'
  prefs: []
  type: TYPE_NORMAL
- en: '**What to ask**: What are the required functionalities? What technique should
    be applied to solve index collisions? What is the data type of the key-value pairs?'
  prefs: []
  type: TYPE_NORMAL
- en: '`add()` and `get()` operations. For solving index collisions, I suggest you
    use the *chaining* technique. The key-value pairs should be generic.'
  prefs: []
  type: TYPE_NORMAL
- en: '**A brief overview of a hash table:** A hash table is a type of data structure
    that stores key-value pairs. Commonly, an array holds all the key-value entries
    in the table and the size of this array is set to accommodate the amount of data
    anticipated. The key of each key-value is passed through a hash function (or several
    hash functions) that outputs a hash value or a hash. Mainly, the hash value represents
    the index of the key-value pair in the hash table (for example, if we use an array
    to store all key-value pairs, then the hash function returns the index of this
    array that should hold the current key-value pair). Passing the same key through
    the hash function should produce the same index every time – this is useful for
    finding a value via its key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a hash function generates two identical indexes for different keys, we
    face an index collision. The most frequently used techniques for solving an index
    collision problem are *linear probing* (this technique searches linearly for the
    next free slot in the table – trying to find in the array a slot (an index) that
    doesn''t hold a key-value pair) and *chaining* (this technique represents a hash
    table implemented as an array of linked lists – collisions are stored at the same
    array index as linked list nodes). The following diagram is a hash table for storing
    *name-phone* pairs. It has *chaining* capabilities (check the *Marius-0838234*
    entry, which is chained to *Karina-0727928*, because their keys, *Marius* and
    *Karina*, lead to the same array index, *126*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – A hash table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.6_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – A hash table
  prefs: []
  type: TYPE_NORMAL
- en: '`HashEntry`). As you can see in the preceding diagram, a key-value pair has
    three main parts: the key, the value, and a link to the next key-value pair (this
    way, we implement *chaining*). Since a hash table entry should be accessed only
    via dedicated methods, such as `get()` and `put()`, we encapsulate it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the array that holds `HashEntry`. For testing purposes, a size
    of `10` elements is enough and it allows us to test *chaining* easily (having
    a small size is prone to collisions). In reality, such an array is much bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add the `get()` and `put()` methods. Their code is quite intuitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add a dummy hash function (in reality, we use hash functions such
    as Murmur 3 – [https://en.wikipedia.org/wiki/MurmurHash](https://en.wikipedia.org/wiki/MurmurHash)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Done! The complete application is named *HashTable*.
  prefs: []
  type: TYPE_NORMAL
- en: For the following four examples, we skipped the source code from the book. Take
    your time and dissect each example. Being able to understand an existing design
    is just another tool that you can use to shape your design skills. Of course,
    you can try your own approach before looking into the book's code and compare
    the results in the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 7: File system'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Design the main classes of a file system.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What to ask**: What are the required functionalities? What are the pieces
    of the file system?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interviewer**: Your design should support the addition, deletion, and renaming
    of directories and files. We are talking about a hierarchical structure of directories
    and files, like most operating systems have.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: The complete application is named *FileSystem*. Please visit
    the following link to check the UML: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/FileSystem/FileSystemUML.png](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/FileSystem/FileSystemUML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 8: Tuple'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Design a tuple data structure.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What to ask**: A tuple can have from 1 to *n* elements. So, what kind of
    tuple do you expect? What data types should be stored in the tuple?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interviewer**: I am expecting a tuple with two generic elements. The tuple
    is also known as a *pair*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: The complete application is named *Tuple*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 9: Cinema with a movie ticket booking system'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Design a cinema with a movie ticket booking system.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What to ask**: What is the main structure of the cinema? Does it have multiple
    cinema rooms? What types of tickets do we have? How do we play a movie (only in
    a room, just once a day)?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interviewer**: I am expecting a cinema with multiple identical rooms. A movie
    can run in multiple rooms at the same time and can run multiple times in a day
    in the same room. There are three types of tickets, simple, silver, and gold,
    based on the seat type. A movie can be added/removed in a very versatile way (for
    example, we can remove a movie from certain rooms at certain start times, or we
    can add a movie to all rooms).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: The complete application is named *MovieTicketBooking*. Please
    visit the following link to check the UML: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/MovieTicketBooking/MovieTicketBookingUML.png](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/MovieTicketBooking/MovieTicketBookingUML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 10: Circular byte buffer'
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Design a circular byte buffer.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What to ask**: It should be resizable?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interviewer**: Yes, it should be resizable. Mainly, I expect you to design
    the signatures of all methods that you consider necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: The complete application is named *CircularByteBuffer*.'
  prefs: []
  type: TYPE_NORMAL
- en: So far so good! I suggest you try your own designs for the preceding 10 problems
    as well. Do not consider that the solutions presented are the only ones that are
    correct. Practice as much as you can by varying the context of the problem and
    challenge yourself with other problems as well.
  prefs: []
  type: TYPE_NORMAL
- en: The source code bundle for this chapter is available under the name *Chapter06*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered the most popular questions about OOP fundamentals and 10
    design coding challenges that are very popular in interviews. In the first part,
    we began with OOP concepts (object, class, abstraction, encapsulation, inheritance,
    polymorphism, association, aggregation, and composition), continued with the SOLID
    principles, and finished with an amalgam of questions combining OOP Concepts,
    SOLID principles, and design pattern knowledge. In the second part, we tackled
    10 carefully crafted design coding challenges, including designing a jukebox,
    a vending machine, and the famous hash table.
  prefs: []
  type: TYPE_NORMAL
- en: Practicing these questions and problems will give you the ability to tackle
    any OOP problem encountered in an interview.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will tackle Big O notation and time.
  prefs: []
  type: TYPE_NORMAL
