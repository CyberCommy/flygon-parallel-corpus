- en: Managing Data Persistence with DynamoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to build a RESTful API with Lambda and
    API Gateway, and we discovered why Lambda functions should be stateless. In this
    chapter, we will resolve the stateless issue by using AWS DynamoDB for data storage.
    Moreover, we will also see how to integrate it with the Lambda functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up DynamoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with DynamoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a follow-up of the previous one as it will use the same source
    code. Hence, some snippets won't be explained to avoid repetition. Also, basic
    knowledge of NoSQL concepts is preferred so that you can follow this chapter with
    ease. The code bundle for this chapter is hosted on GitHub at [https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go](https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up DynamoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DynamoDB is an AWS NoSQL database. It's a managed AWS service that allows you
    to store and retrieve data at scale without managing or maintaining a database
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to understand a few key concepts about DynamoDB before digging into
    its integration with AWS Lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Structure and Design**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Table**: This is a set of items (rows) where each item is a set of attributes
    (columns) and values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partition key**: This is also called a hash key. It''s a unique ID used by
    DynamoDB to determine the partition (physical location) in which the item can
    be found (read operation) or will be stored (write operation). A sort key might
    be used to order/sort items in the same partition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Index**: Similar to relational databases, indexes are used to speed up queries.
    In DynamoDB, two types of indexes can be created:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global Secondary Index** (**GSI**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Local Secondary Index** (**LSI**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operations**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scan**: As the name implies, this operation scans the entire table before
    returning the requested items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query**: This operation finds items based on primary key values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PutItem**: This creates a new item or replaces an old item with a new one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GetItem**: This finds an item by its primary key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DeleteItem**: This deletes a single item in a table by its primary key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In terms of performance, scan operations are less efficient and more expensive
    (they consume more throughput) as the operation has to iterate through each item
    in the table to get the requested items. Therefore, it's always recommended to
    use query over scan operations.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you're familiar with DynamoDB terminology, we can start by creating
    our first DynamoDB table to store the API items.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin creating a table, sign in to the AWS Management Console ([https://console.aws.amazon.com/console/home](https://console.aws.amazon.com/console/home))
    and select DynamoDB from the Database section. Click on the **Create table** button
    to create a new DynamoDB table, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9602a30-7f26-4d7d-a22e-e2e5a3a1dada.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, give the table a name such as `movies` in the next example.. Since each
    movie will be identified by a unique ID, it will be the partition key for the
    table. Leave all of the other settings as their default states and hit Create,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/778d260b-e9d9-469a-a2d0-79fae4b4f2a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Wait a few seconds while the table is created, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ffd40dce-59bf-4d91-bfba-26dcce344897.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the `movies` table is created, a success message will prompt you to confirm
    its creation. Now, we need to load sample data into the table.
  prefs: []
  type: TYPE_NORMAL
- en: Loading sample data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To populate items in the `movies` table, click on the **Items** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b88f35a-8d5b-4991-84e8-3144f45c3fd1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, click on **Create item** and insert a new movie, as shown in the following
    screenshot (you need to use the plus (+) button to append an extra column to store
    the movie name):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40c329da-cd7a-41f7-b4be-670ee9a36e31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Save. The table should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ebb6530d-ff25-41fa-98f7-4fc7e45d3f40.png)'
  prefs: []
  type: TYPE_IMG
- en: For a real-world application, we won't use the console to populate millions
    of items. To save time, we will use the AWS SDK to write a small application in
    Go to load items to the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project in your Go workspace and copy the following content into
    the `init-db.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code reads a JSON file ([https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go/blob/master/ch5/movies.json](https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go/blob/master/ch5/movies.json)),
    which contains a list of movies; encode it into an array of the `Movie` struct
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it iterates through every movie within the movies array. Then, use the
    `PutItem` method to insert it into a DynamoDB table as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to install the AWS Go SDK with the `go get github.com/aws/aws-sdk-go-v2/aws` command
    from your terminal session*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'To load the `movies` table with data, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the DynamoDB Console to verify the data that you loaded into the
    `movies` table, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/729f5fbc-9820-4ce3-9161-521ce3eb2bac.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that the DynamoDB table is prepared, we need to update each API endpoint
    function's code to use the table instead of the hardcoded movies list.
  prefs: []
  type: TYPE_NORMAL
- en: Working with DynamoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will update the existing functions to read and write from/to
    the DynamoDB table. The following diagram describes the target architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca81f50b-4e81-4c21-9871-6cd97eeabfc6.png)'
  prefs: []
  type: TYPE_IMG
- en: API Gateway will forward incoming requests to the target Lambda function, which
    will call the corresponding DynamoDB operation on the `movies` table.
  prefs: []
  type: TYPE_NORMAL
- en: Scan request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, we need to implement the function responsible for returning
    a list of movies; the following steps describe how to achieve that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `findAll` handler endpoint to use the `Scan` method to fetch all
    items from the table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Full implementation of this function can be found in the GitHub repository ([https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go/blob/master/ch5/findAll/main.go](https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go/blob/master/ch5/findAll/main.go)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the deployment package and update the `FindAllMovies` Lambda function
    code with the following AWS CLI command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Be sure to update the FindAllMoviesRole in order to grant that Lambda function
    permissions to call the `Scan` operation on the DynamoDB table by adding the following
    IAM policy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the policy is assigned to the IAM role, it should be part of the attached
    policies, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec5e0848-c799-4198-9587-0907f2458486.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, with the Lambda console or using the AWS CLI, add a new environment
    variable to point to the DynamoDB table name that we created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows a properly configured FindAllMovies function
    with IAM access to DynamoDB and CloudWatch with a defined `TABLE_NAME` environment
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90ddc595-42c2-4356-89a7-4a0441a012e8.png)'
  prefs: []
  type: TYPE_IMG
- en: Properly configured FindAllMovies function
  prefs: []
  type: TYPE_NORMAL
- en: 'Save it and invoke the API Gateway URL with the cURL command as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'An array will be returned in a JSON format as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9970ba6a-ebfe-4d8c-96f5-fcb677345e48.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The endpoint is working and fetching the movie''s items from the table, but
    the JSON returned is a raw DynamoDB response. We will fix that by returning only
    the `ID` and `Name` properties as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Further to this, generate the ZIP file and update the Lambda function code,
    and then invoke the API Gateway URL with the cURL command given earlier, shown
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/af479fe5-73a7-486c-8dc9-b5f69ad75fa6.png)'
  prefs: []
  type: TYPE_IMG
- en: Much better, right?
  prefs: []
  type: TYPE_NORMAL
- en: GetItem request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second function to be implemented will be responsible for returning a single
    item from DynamoDB, the following steps illustrate how it should be built:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `findOne` handler to call the `GetItem` method in DynamoDB. This
    should return a single item with the identifier passed into the API endpoint parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Full implementation of this function can be found in the GitHub repository ([https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go/blob/master/ch5/findOne/main.go](https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go/blob/master/ch5/findAll/main.go)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the `FindAllMovies` function, create a ZIP file and update the existing
    Lambda function code with the following AWS CLI command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Grant `GetItem` permission on the `movies` table to the `FindOneMovie` Lambda
    function with the following IAM policy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The IAM role should be configured as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/97c1e2d9-b691-4661-a10f-b6603de50f75.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Define a new environment variable with the DynamoDB table name as a value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Head back to the `FindOneMovie` dashboard and verify that all of the settings
    have been configured, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b12ebdf3-11f4-4db8-85be-586c46979aea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Invoke the API Gateway by issuing the following cURL command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the response is a single movie item, with an ID of 3, as requested
    in the cURL command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9d7a8cf7-359c-48f7-afbe-119c70506adc.png)'
  prefs: []
  type: TYPE_IMG
- en: PutItem request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have learned how to list all items and return a single item from
    DynamoDB. The following section describes how we can implement a Lambda function
    to add a new item to a database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `insert` handler to call the `PutItem` method to insert a new movie
    into the table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Full implementation of this function can be found in the GitHub repository ([https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go/blob/master/ch5/insert/main.go](https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go/blob/master/ch5/findAll/main.go)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a deployment package and update the `InsertMovie` Lambda function code
    with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Allow the function to call the `PutItem` operation on the movies table with
    the IAM policy as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows that the IAM role is updated to handle the `PutItem`
    operation''s permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/342056fe-729b-4b4f-9115-b6ac94d5c117.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new environment variable with the DynamoDB table name as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that the Lambda function is configured as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6605624f-7263-42fd-a746-d0280410f375.png)'
  prefs: []
  type: TYPE_IMG
- en: Properly configured InsertMovie function
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert a new movie by calling the following cURL command on the API Gateway
    URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the movie is inserted in the DynamoDB Console, as shown in the
    next screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b7eea63f-4d13-4f9b-bdad-0b0f642b0db7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another way to verify that the insert was well-executed is to use the `findAll`
    endpoint with a cURL command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The movie which has an ID of `17` has been created. If the table contained
    a movie item with the same ID, it would have been replaced instead. The following
    is the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d1e275f0-c10e-44ae-a39f-b14a9ea600ae.png)'
  prefs: []
  type: TYPE_IMG
- en: DeleteItem request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, in order to delete an item from DynamoDB, the following Lambda function
    should be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Register a new handler to delete a movie. The handler will encode the payload
    in the request body to a `Movie` struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, call the `DeleteItem` method with the movie ID as a parameter to remove
    it from the table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Full implementation of this function can be found in the GitHub repository ([https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go/blob/master/ch5/delete/main.go](https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go/blob/master/ch5/findAll/main.go)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to what we did with the other functions, create a new IAM role called
    `DeleteMovieRole` with permissions to push logs to CloudWatch and to call the `DeleteItem`
    operation on the movies table, as shown in the next screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b12c59b9-b5c5-425a-a3d3-7216bbcfb7a4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, create a new Lambda function after building a deployment package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Head back to the Lambda Console. A `DeleteMovie` function should have been
    created, as shown in the next screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7b7ca496-3ee9-4be8-8099-47156c0478fe.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we need to expose a `DELETE` method on the `/movies` endpoint in the
    API Gateway. To do so, we won't use the API Gateway console, but we will use the
    AWS CLI so that you can get familiar with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create a `DELETE` method on `movies` resources, we will use the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we need to supply the API ID as well as the resource ID. Those IDs
    can be found easily in the API Gateway Console, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/939137cb-caec-46a0-8461-1dd68979dd39.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For CLI enthusiasts like myself, you can also get this information by running
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'REST API ID:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Resource ID:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now that the IDs have been defined, update the `aws apigateway put-method` command
    with your IDs and execute the command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, set the `DeleteMovie` function as the target for the `DELETE` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, tell the API Gateway to skip any translation and to pass it without
    any modification the response returned by the Lambda function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Resources panel, a `DELETE` method should be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/28a1ef22-904e-4f87-aabf-053d9ef08d44.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Redeploy the API with the following AWS CLI command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following cURL command to delete a movie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the movie had been deleted by calling the `findAll` endpoint with
    the following cURL command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The movie with ID as 1 won''t be part of the list that''s being returned. You
    can verify in the DynamoDB Console that the movie has been successfully deleted,
    shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3bea6331-a823-476e-a529-21f264eefb6e.png)'
  prefs: []
  type: TYPE_IMG
- en: Indeed, the movie having ID as 1, no longer exists in the `movies` table.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have created a serverless RESTful API with AWS Lambda, API
    Gateway, and DynamoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to build an event-driven API with Lambda and
    API Gateway, and how to store data in DynamoDB. In later chapters, we will go
    further and add a security layer on top of the API Gateway, build a CI/CD pipeline
    to automate the deployment, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go through some advanced AWS CLI commands and options
    that you can use while building serverless functions in AWS Lambda to save time.
    We will also see how to create and maintain multiple versions and releases of
    Lambda functions.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implement an `update` handler to update an existing movie item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new PUT method in API Gateway to trigger the `update` Lambda function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a single Lambda function to handle all type of events (GET, POST,
    DELETE, PUT).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `findOne` handler to return a proper response code for a valid request
    but an empty data (for example, no movie for the ID requested).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a pagination system on the `findAll` endpoint using a `Range` header
    and using a `Query` string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
