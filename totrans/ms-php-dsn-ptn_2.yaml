- en: Chapter 2. Anti-Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here's where we start on anti-patterns; before you get your hopes up thinking
    I'm about to tell you something amazing that will wonderfully streamline your
    code without using design patterns, I won't be doing that here (did I mention
    I'm great at crushing hopes and dreams?). Anti-patterns are, in short, things
    you don't want in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of crushing hopes and dreams, should you ever have a junior developer,
    anti-patterns are also a great way of teaching methodologies that should be equally
    avoided. Learning anti-patterns also can boost the effectiveness of code reviews;
    instead of debating code quality on the basis of personal opinions, you can have
    an external source to consult on code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-patterns constitute a terrible method of resolving a recurring problem
    that is usually ineffective and risks being highly counterproductive. They can
    then create technical debt as developers must later struggle to refactor to resolve
    the initial problems but hopefully use a more resilient design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'We all have encountered Spaghetti Code; one contract developer I worked with
    exclaimed to an ever more demanding product owner in the face of high technical
    debt: "There is so much spaghetti I might as well open a restaurant!" Spaghetti
    Code is where the control structure of a program is barely comprehensible as it
    is so tangled and over-complicated and it may be described as an anti-pattern.
    One of the major criticisms in PHP 5.3.0 was the implementation of goto operators
    in the language. Indeed, those critiquing their implementation claimed goto operators
    would provide yet another excuse for more Spaghetti Code in PHP.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Gotos were highly controversial in PHP, with someone even going as far to report
    it as a bug, stating: "PHP 5.3 includes goto. This is a problem. Seriously, PHP
    has made it this far without goto, why turn the language into a public menace?"'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this, the submitter of the bug report listed the expected result
    as: "the world will end" and the actual result being "the world ended". Despite
    this, goto operators in PHP are heavily restricted so you can''t just jump in
    and out of functions. Some people also argue that they are useful in finite state
    machines (essentially something with a binary output based on multiple inputs),
    but this is also controversial; so I shall allow you to make your own judgments
    about them.'
  prefs: []
  type: TYPE_NORMAL
- en: You may well have experienced copy and paste programming, where whole blocks
    of code are copied and pasted in a program; this is yet another example of bad
    software design. In reality, developers should be designing their software to
    create generic solutions to problems instead of copying, refactoring, and pasting
    bits of code to fit a situation.
  prefs: []
  type: TYPE_NORMAL
- en: I will introduce this chapter with a section on why learning anti-patterns is
    important. During this chapter, I will discuss not only traditional anti-pattern-related
    software design but also anti-pattern-related web infrastructure and management
    styles. In addition to this, I want to discuss some PHP-specific anti-patterns,
    or flaws in PHP, which you may need to compensate for in your own code.
  prefs: []
  type: TYPE_NORMAL
- en: This book contains a dedicated chapter on refactoring towards the end; if the
    process of refactoring is of interest to you, this chapter will help lay the foundations
    of the ideas you might want to start thinking about; in addition to this, the
    chapters specific to design patterns may help you realize the code you might be
    eventually aiming for. In the chapter dedicated to refactoring, we will also cover
    some code smells, which can help you discover anti-patterns in codebases you're
    maintaining.
  prefs: []
  type: TYPE_NORMAL
- en: Why anti-patterns matter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most programmers come from a background of adopting some form of anti-pattern
    until eventually realizing how it doesn't scale or doesn't work well. When I was
    17 and in my first job as an apprentice developer, I would be whisked down to
    London Monday-to-Friday, somehow compressing my suit and my totally black clothing
    into a surprisingly miniscule suitcase, and would learn about software development.
    On Fridays, we were often released for a half-day at 12:00 but I would pre-book
    my company train tickets in the afternoon so I would spend my time in fast-food
    restaurants or coffee shops working on simple projects. Every week, when I came
    back and tried to scale one of these solutions I would realize new scalability
    issues and code quality issues. Of course, I had done development before, but
    these were largely dealing with either brand new incredibly short programming
    tasks, using pre-made frameworks or dealing with legacy code where the architecture
    had already been done (or, as I now realize, butchered with a severely blunt knife).
    This learning process of scaling my own code was great; I rapidly taught myself
    how to design software better. As humans, we often don't know enough about a topic
    to know how little we know (something incredibly true I've found with those who
    manage software developers but has never written any code themselves); while bearing
    this in mind, we should remember we are never above learning from our own mistakes.
    While this is incredibly important, teaching ourselves documented anti-patterns
    is also vital in order to learn from others mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: I was once the technical lead and mentor for a developer who had the most down-right
    brutal treatment from learning from his mistakes. In the first appraisal I had
    with this developer, I was told by my HR counterpart that every time he'd made
    a mistake both the previous technical and HR leads dragged him into a meeting
    room to go through a formal disciplinary process. Both of these people had incredibly
    limited technical knowledge and also were completely incompetent at managing developers
    (so much so that they were the type of people who lived in their own bubble, clueless
    of how people worked in more successful environments and largely stuck in dead-end
    careers without the knowledge to ever do anything meaningful in their careers).
    By the time they left, this poor developers confidence had been crushed to such
    a point that he had no real career ambition in web and wasn't keen to learn. There's
    nothing wrong with being happy in your position. As a former boss of mine once
    said after I told him something incredibly personal, "ultimately, all that matters
    is that you're happy". Yes, it takes a lot of people to make the world go round,
    but as soon as you put yourself in a position where you are either mentoring or
    managing other developers you have an obligation to keep yourself ahead of the
    game. If you are a manager, you should know how to do your job effectively. The
    best people managers I've had have been those that possess a wealth of knowledge,
    keeping up to date with the latest and greatest in management methodologies the
    same way I like to keep up to date with the latest and greatest in the PHP core
    and community. Throughout the course of writing this book, my knowledge of project
    and people management has improved, but it still has a long way to go, and therefore
    I'd not take a job with such line management responsibilities without educating
    myself first. At the company I worked at, where there was effectively bullying
    as a management strategy, I once mentioned this to the head of department who
    responded by saying "we're not saying it's the best way of doing it"; if that's
    true, surely something should be done to fix this, for the sake of the business!
    This wasn't true in the entire business; other departments had a very different
    attitude, and indeed, the Technical Director once gave a tech talk about this
    very topic and the importance of knowing that you don't know. The CEO of the company
    started a similar conversation with me, saying how he knew he didn't know. Old
    practices die hard, but at least they have started sailing on the winds of change.
  prefs: []
  type: TYPE_NORMAL
- en: 'So other than ranting (I do love a good rant), why am I talking about this?
    My point is that your attitude matters. One of my favorite quotes on this subject
    is that "if you treat your developers like idiots, they will soon become idiots".
    Let me extend upon this by saying this:'
  prefs: []
  type: TYPE_NORMAL
- en: Bad performance in students is often a reflection of bad performance from teachers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everyone makes mistakes, mistakes getting out control is the fault of idiotic
    behavior from managers, not developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Idiots attract idiots. If you are an idiot in your body of subject knowledge,
    you will in turn likely recruit more idiots.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you operate a regime of fear in your workplace, you are an idiot and scared
    of being found out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you don't know how little you know and you don't seek to effectively cure
    your own ignorance, you are an idiot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you treat your developers like idiots, you are an idiot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, learn how little you know and grow. It sounds brutal, but it's the
    truth. We are all ignorant, we cannot know everything. Effectively utilizing our
    own knowledge in association with the knowledge of others is vital to success.
    Recognizing our own ignorance is key to this. For example, last year I decided
    that my knowledge in fundamental computer science wasn't broad enough to cope
    with my own demand for it, or the demands of those I mentored; therefore, I decided
    to go off and do a part-time master's degree in computer science. The learning
    process has been great and taught me about fields in computer science I didn't
    know existed before.
  prefs: []
  type: TYPE_NORMAL
- en: Some software developers use other people's work, and yes, WordPress or Drupal
    development can give you a happy and productive career, but you will find the building
    and architecting things for yourself to be a great learning experience. Having
    worked in a traditional engineering environment, I have been won over to the view
    that a firm theoretical background in computer science is hugely beneficial for
    software engineers. Indeed, the body of knowledge required to understand the fundamentals
    of computer science is actually quite easy to pick up. Of course, in many ways,
    I am preaching to the converted; if you are reading this book you presumably understand
    the need for a deeper theoretical computer science knowledge base, but please
    don't read this book and stop actively learning. Continue to have a plan to progress
    your knowledge, seek to improve the information stored in that piece of protein
    that resides in our skulls.
  prefs: []
  type: TYPE_NORMAL
- en: It is often said that "*in the land of the blind, the one-eyed man is king*";
    smaller development teams may often lack the basics when it comes to good software
    development (perhaps out of lack of necessity), and indeed, some larger development
    environments who become stuck in the past may end up in the same situation. In
    this regard, knowledge just becomes more precious and it becomes equally important
    for developers to be educated about software development.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-patterns aren't just something your team can be taught to avoid; good software
    development needs a firm understanding of not only the programming language but
    also a theoretical understanding of software development is key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let me just steal this quote from an article on SourceMaking:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Architecture-driven software development is the most effective approach to
    building systems. Architecture-driven approaches are superior to requirements-driven,
    document-driven, and methodology-driven approaches. Projects often succeed in
    spite of methodology, not because of it."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rant(s) over. Let's cover some anti-patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Not invented here syndrome
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cryptography can teach us a very important lesson about software; this is especially
    true about Kerckhoffs''s principle. The principle states this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"A cryptosystem should be secure even if everything about the system, except
    the key, is public knowledge."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This was reformulated by Claude Shannon in a form known as Shannon''s Maxim:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"One ought to design systems under the assumption that the enemy will immediately
    gain full familiarity with them".*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In layman's terms, in order to have a secure system, it shouldn't be secure
    just because no one knows how it's been implemented ("security through obscurity").
    If you were to secure your money through obscurity, you'd bury it under a tree
    and hope no one would find it. Whereas, when you use a real security mechanism,
    such as putting your money in a safe in a bank, you can have every detail about
    the security system as public information, but providing the security system is
    truly secure, you would really only have to keep the key to the safe secret and
    every other detail could be public knowledge. If someone was to find the key to
    your safe, you only need change the combination, whereas if someone actually found
    where your money was buried under a tree, you would actually have to dig up the
    money and find somewhere else to put it.
  prefs: []
  type: TYPE_NORMAL
- en: Security that is only done through obscurity is a bad idea (that said, it's
    not always a bad idea). As you may be aware, when you store a password in a database
    you should use a one-way cryptographic algorithm known as a **hashing algorithm**
    to ensure that if the database is stolen no one can ever use the data in the database
    to find the user's original password. Of course, in reality, you shouldn't just
    hash a password, you should salt it and use an algorithm such as PBKDF2 or BCrypt,
    but this book isn't about password security.
  prefs: []
  type: TYPE_NORMAL
- en: The reality of the situation, however, is that sometimes, when developers actually
    do bother to hash passwords, they decide to create their own password hashing
    functions, functions that are easily reversible and are only secured by the obscurity
    of someone not knowing the algorithm. This is a perfect example of *not invented
    here* (*NIH*) syndrome; instead of a developer using a well-created password hashing
    library that is highly respected, they decide to create their own, pretending
    they are a cryptographer without understanding the security implications of such
    a decision.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, PHP now makes it painlessly easy to hash your passwords; the `password_hash`
    function and `password_verify` function make this really easy with the `password_needs_rehash`
    function even telling you when the hash needs to be recalculated. Nevertheless,
    I digress.
  prefs: []
  type: TYPE_NORMAL
- en: So what actually is NIH syndrome? NIH syndrome is where a false sense of pride
    in an organization or individual developers own ability leads them to build their
    own solution instead of adopting superior third-party solutions. Reinventing the
    wheel isn't only costly, unnecessary, and can add needless overhead in maintenance;
    it can also be horribly insecure.
  prefs: []
  type: TYPE_NORMAL
- en: That said, where solutions are closed source and locked down, then it might
    be a good idea to avoid them. Doing so would also avoid vendor lock-in and restrictions
    on business flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: NIH syndrome relies on the existing solutions being good and living up to expectations.
    Using third-party libraries is no excuse not to review their code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Contributing to open source solutions is a great way to alleviate these issues.
    Room for improvement on an existing library? Fork it, propose an amendment to
    be merged in. No library that does the functionality you're after? Then you might
    want to consider writing your own library and publishing it.
  prefs: []
  type: TYPE_NORMAL
- en: I will finish this section by saying that the world has become heterogeneous;
    people are no longer looking for one technology stack to answer all their prayers;
    people are nowadays after the best tool for the job. It's worth thinking how you
    can utilize this fact for your own benefit.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party dependencies with Composer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Composer makes it really easy to manage third-party dependencies. In [Chapter
    1](ch01.html "Chapter 1. Why "Good PHP Developer" Isnt an Oxymoron"),  *Why "Good
    PHP Developer" Isn't an Oxymoron*, I briefly described how you can use Composer
    for autoloading. Big deal, autoloading has been supported as a core function since
    PHP 5.1.2, but the great thing about Composer is that you can also use it for
    dependency management. Composer can effectively go and fetch the dependencies
    you need using the version constraints you specify.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start off the with the following `composer.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'So let''s pull in a dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that all we've done is add a `require` parameter where we specify which
    software we want. No manually pasting files into your project or root, or using
    sub-modules in Git, for that matter!
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we pulled in Guzzle, an HTTP library for PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Composer by default queries repositories from a central repository called **Packergist**,
    which aggregates packages you can install from their various version control systems
    (such as GitHub, BitBucket, or another repository host). If you like, Packergist
    acts as a kind of phone book that connects the requests for packages from Composer
    to code repositories.
  prefs: []
  type: TYPE_NORMAL
- en: That said, it's not just Packergist repositories that Composer supports. In
    the spirit of being open source, it supports repositories from a range of VCS
    systems (such as Git/SVN) regardless of where they are hosted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the following `composer.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let me demonstrate how you can include a repository from BitBucket without
    it being on Packergist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s that easy! You literally just specify the repository you want to pull
    in from and Composer does the rest. It''s just as easy with other version control
    systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather cheekily, Composer can even support PEAR PHP repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In order to update the dependencies after you've made changes to your `composer.json`
    file, just run `composer update`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can't update external dependencies using just `composer dump-autoload`.
    The reason for this is that `dump-autoload` will solely update the class map of
    your autoloader. It will essentially update the list of classes it needs to autoload;
    it won't go and pull in new dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Occasionally, when using Composer and pulling in dependencies, Git may say you
    need to generate a GitHub authentication key. This is because if you have Git
    installed on your local machine, Composer will go ahead and pull in dependencies
    by cloning then via a version control system; however, occasionally, if it's clinging
    repositories from GitHub, you might come up against its rate limit. If this happens
    there is no need to panic. Composer will give you instructions on how to actually
    go ahead and get an API key so you can proceed without rate limiting.
  prefs: []
  type: TYPE_NORMAL
- en: An easy way to get around this issue is simply to generate a local SSH key and
    then put your public key into your GitHub account. That way, when you clone from
    GitHub to your local machine you won't face any rate limitations and you won't
    need to bother setting up an API key either.
  prefs: []
  type: TYPE_NORMAL
- en: In order to generate an SSH key on a Linux/Mac OS X machine, you can just use
    run the `ssh-keygen` command, which will create a public and private key you can
    use for SSH authentication, including with Github or BitBucket. These keys will
    (usually) be stored in the `~/.ssh` directory, noting the tilde (`~` represents
    your home directory). Therefore, in order to get your key printed out into your
    Terminal window, run the `cat ~/.ssh/id_rsa.pub` command. Note that the `.pub`
    suffix indicates that `id_rsa.pub` is your public key that you can publically
    share. You must not share your private key, which is usually named just `id_rsa`.
    On Windows, you can use a GUI tool known as **PuttyGen** to generate public and
    private keys.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've got your public and private keys, you can simply put them in GitHub
    by visiting the GitHub website and going to the SSH Keys page in the settings
    menu, paste in your key, and save it.
  prefs: []
  type: TYPE_NORMAL
- en: For subsequent updates, `composer update` will update to the latest versions
    of all dependencies as defined in `composer.json`. If you don't want to do this,
    though, there is an alternative; running Composer `dump-autoload` will solely
    regenerate the list of the PSR-0/PSR-4 classes that need to be included in the
    project (for example, you add, delete, or rename some of your classes).
  prefs: []
  type: TYPE_NORMAL
- en: Composer also supports private repositories, allowing you to effectively manage
    code reuse across multiple projects. Another key benefit is how Composer automatically
    generates a lock file that you can commit in with your projects. This allows you
    to effectively manage exactly which precise version of a dependency was installed
    at a particular point in time when you make a commit using your version control
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Composer makes it easy and effective to manage third-party dependencies. Some
    crucial libraries are already available via Composer, such as PHPUnit, but there
    are also some other great libraries to make your life easier. Two of my favorite
    database libraries on Composer are Eloquent (a database ORM system from Laravel
    that you can find at `illuminate`/`database`) and Phinx (a database migration/seeding
    system that you can find at `robmorgan`/`phinx`). In addition to this, there are
    some great SDKs for various APIs that are available from Packergist (Google publishes
    some of its SDKs, and there are also some more specific ones, such as the Twilio
    SDK for sending SMS messages from your PHP app).
  prefs: []
  type: TYPE_NORMAL
- en: Composer allows you to specify dependencies for particular environments; suppose
    you only want to pull in PHPUnit on your development environments...that's not
    a problem!
  prefs: []
  type: TYPE_NORMAL
- en: God objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: God objects are a tempting consequence of bad software design and also badly
    implemented object orientation.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, a **God object** is an object with either too many methods or too
    many properties; essentially, it's a class that knows too much or does too much.
    The God object soon becomes tightly coupled to (referenced by) lots of other bits
    of code in the application.
  prefs: []
  type: TYPE_NORMAL
- en: So what's actually wrong with this? Well, in short, when you have one bit of
    code tied into every single other bit of code, you quickly find a maintenance
    disaster. If you adjust the logic for a method in a God object for one use case,
    you might find it having unintended consequences for another element.
  prefs: []
  type: TYPE_NORMAL
- en: In computer science, it is often a good idea to adopt a divide and conquer strategy.
    Often, big problems are just a set of little problems. By solving this set of
    little problems you can rapidly solve the overall problem. Objects should typically
    be self-contained; they should only know problems about themselves and also should
    only solve one set of problems, its own problems. Anything that isn't relevant
    to this aim doesn't belong in that class.
  prefs: []
  type: TYPE_NORMAL
- en: It can be argued that objects relating to physical objects should be instantiated,
    while those that don't should be abstract classes.
  prefs: []
  type: TYPE_NORMAL
- en: The flip side to God objects being an anti-pattern is when developing embedded
    systems. Embedded systems are used to process data on anything from a calculator
    to LED signage; they are small chips that are essentially self-contained computers
    and quite low cost. In this use case, with restricted computational power you
    can often find that programming elegance and maintainability become peripheral
    concerns. Slight performance increase and centralization of control can be more
    important, meaning using God objects can be somewhat sensible. Fortunately, PHP
    is incredibly seldom used to program embedded systems, so you are incredibly unlikely
    to find yourself in this particular situation.
  prefs: []
  type: TYPE_NORMAL
- en: The most effective way of dealing with these classes is to split them into separate
    classes manually.
  prefs: []
  type: TYPE_NORMAL
- en: Another anti-pattern, called *Fear of Adding Classes*, can also play a part
    in this, along with failing to mitigating it. This is where developers are reluctant
    to create necessary classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here''s an example of a God class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So, as you can see that in this class, we've basically combined lots of irrelevant
    methods. In order to fix this, we can split this class up into two sub-classes,
    one being a `Watch` class and the other being a `CacheManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `Watch` class; this class is simply intended to show us the time
    in various formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the `CacheManager` class; this class separates all the cache''s
    functionality so it is entirely separate from the `Watch` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Environment variables in PHP source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Far too often you come across a project on GitHub and you notice that the original
    developer has left in a `config.php` file that contains (in the best case) useless
    database information or (in the worst case) incredibly important API keys.
  prefs: []
  type: TYPE_NORMAL
- en: When these files aren't accidentally versioned they are often shoved in a `.gitignore`
    file with a sample file attached for developers to amend as they need. One example
    of a platform that does this is WordPress.
  prefs: []
  type: TYPE_NORMAL
- en: There are some minor improvements to this, such as putting core configuration
    in an XML file that is buried in some obscure document with plenty of irrelevant
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: I've found that there tend to be two good ways of managing environment variables
    in PHP. The first method involves putting them in a file on your `root` folder
    in a format such as YML and reading these variables as required.
  prefs: []
  type: TYPE_NORMAL
- en: The second way, which I personally prefer, is a method implemented by a library
    known as `dotenv`. Essentially, what happens is there is a `.env` file is created
    and put in the room of your project. In order to read configuration from this
    file, you just need to call the `env()` function. You can then add this file to
    your `.gitignore` file so that when you push from your development environment
    and pull to various other server configurations this process is made easier. In
    addition to this, you can specify environment variables at the web server level,
    thus ensuring an additional level of security and also making management far easier.
  prefs: []
  type: TYPE_NORMAL
- en: So, for example, if my .`env` file had a `DB_HOST` property, then I can access
    it using `env('DB_HOST');`.
  prefs: []
  type: TYPE_NORMAL
- en: If you do go down the `dotenv` route, be sure to make sure that your `.env`
    is not publically visible from the document root. Either keep it out of your public
    HTTP directory (for example, in the level above), or restrict access to it at
    a web server level (for example, restrict permissions, or if you're using Apache,
    use your `.htaccess` file to limit access to it).
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, you can require this library by simply running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Soft Code** may often also be an anti-pattern that is adopted by using configuration
    files. This is where you start putting business logic in configuration files instead
    of source code; therefore, it is worth reminding yourself to consider when something
    really needs to be configuration oriented.'
  prefs: []
  type: TYPE_NORMAL
- en: Singletons (and why you should be using dependency injection)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Singletons are classes which can only be instantiated once. You can effectively
    only have one object per `Singleton` class in an application. If you've never
    heard of Singletons before you may jump into the air thinking "Yes! I have a million
    and one use cases for this!" Well, please don't. Singletons are just terrible
    and can be effectively avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, a `Singleton` class in PHP looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'So here are the reasons why this should be avoided:'
  prefs: []
  type: TYPE_NORMAL
- en: They are inherently tightly coupled meaning they are difficult to test, for
    example using unit tests. They even maintain their state throughout the life cycle
    of the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They violate the Single Responsibility Principle by controlling their own creation
    and life cycle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fundamentally, it results in you hiding the dependencies of your application
    in a `global` instance. You can no longer effectively follow your dependencies
    around your code as you can't follow where they are injected as function arguments.
    They make it ineffective to find the dependency chain should you need to analyze
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That said, some people argue they can be a valid solution to resource contention
    (where you need to only have a single instance of a resource and you need to manage
    that single resource).
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dependency injection is the antidote to Singletons. So, suppose you have a
    class that is called `Transaction`. As a constructor of the class, it accepts
    parameters called `$creditCardNumber` and `$clientID`, so therefore we can construct
    the object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Using dependency injection, we would instead pass in objects of `$creditCard`
    and `$client` which would be instances of classes for the credit card and client.
    If you are using an ORM, this could be a database model class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Database as IPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing, I'm currently over the Atlantic, on my way from London
    to San Francisco, which is probably a good thing as it means my neck is decisively
    out of the reach of some previous developers I've worked with.
  prefs: []
  type: TYPE_NORMAL
- en: Let me clear this up for you; your database isn't a message queuing system.
    You don't use it schedule jobs or queue up tasks to be completed. If you need
    something to do that, use a queuing system. Your database is for data...the clue
    is in the name; don't shove temporary messages in there.
  prefs: []
  type: TYPE_NORMAL
- en: There are many reasons why this is a bad idea. One major issue is the fact that
    in databases there is no real way to not enforce a policy by which you can guarantee
    that a double-read will not occur, and that is by utilizing row locks. This in
    turn, results in processes (either incoming out outgoing) being blocked, which
    in turn results in processing only being able to be done in a serial fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, in order to check if there is any work to do you end up essentially
    counting the rows of data in the database to see if there is work to do; you run
    this on a continuous basis. MySQL doesn't support push notifications; unlike PostgreSQL
    it doesn't have the `NOTIFY` command to pair with a `LISTEN` channel.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that when you merge a job queue with a database table that stores
    real data, you also invalidate the cache every time you complete a job and update
    a flag, in turn making MySQL far slower.
  prefs: []
  type: TYPE_NORMAL
- en: In short, it results in your database performing worse and can force it to slow
    critical messages to a standstill. You must be careful not to turn your database
    into a job queue by having this functionality sneak up on you; instead, use the
    database exclusively for data, and bear this in mind when extending your database.
  prefs: []
  type: TYPE_NORMAL
- en: RabbitMQ provides an open source queuing system with some great PHP SDKs.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-increment database IDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Database auto-increment is something I find incredibly frustrating; pretty much
    every PHP/MySQL beginner tutorial teaches people to do this, but you really shouldn't.
  prefs: []
  type: TYPE_NORMAL
- en: I have got experience trying to shard auto-increment database IDs, and it's
    messy. Let's suppose you shard the database so the dataset over two database servers...how
    on earth can you expect someone to scale auto-increment IDs?
  prefs: []
  type: TYPE_NORMAL
- en: MySQL now even features a UUID function, allowing you to generate good IDs with
    strong entropy, meaning it also features a higher theoretical limit than auto-increment
    triggers on tables with an `int` data type.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use the UUID function, the database table should ideally be a CHAR(20).
  prefs: []
  type: TYPE_NORMAL
- en: Cronjob imitating service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This one is a personal hatred of mine. A developer needs a service to run indefinitely,
    so they just enable a cronjob that never ends, or simply have a cronjob that operates
    incredibly frequently (such as once every few seconds).
  prefs: []
  type: TYPE_NORMAL
- en: A cronjob is a scheduled job that will run at a predetermined time. It's not
    something that operates services for you. Not only is this messy from an architectural
    perspective, but it scales horribly and becomes terrible to monitor.
  prefs: []
  type: TYPE_NORMAL
- en: A constantly processing task should be treated as a daemon and not as something
    that runs on the basis of a cronjob.
  prefs: []
  type: TYPE_NORMAL
- en: '**Monit** is a tool in Linux systems that allows you to imitate services.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install Monit using the `apt-get` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Monit is installed, you can add processes to its configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Monit can then be started by running the `monit` command. It also has a `status`
    command so you can verify it is still running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can learn more about Monit and find out how to configure it at [http://www.mmonit.com](http://www.mmonit.com).
    It is a highly valuable tool for every DevOps focused developer to have in their
    armory.
  prefs: []
  type: TYPE_NORMAL
- en: Software in place of architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, developers will seek to rectify a system's architectural issues at the
    software development level. While this has use cases, I am a huge fan of seeking
    to avoid this practice where it is not necessary. Moving issues from the software
    architecture layer to the infrastructure layer has its advantages.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose you need to proxy a request for a particular URL endpoint
    off to another server. I believe this is best done at the web server level as
    opposed to writing a PHP proxy script. Apache and Nginx can both handle reverse
    proxying, but writing a library to do this may mean you come up against several
    unheard issues. Have you thought you that you'll handle `HTTP PUT`/`DELETE` requests?
    What about error handling? Assuming you nail your library, what about performance?
    Can a PHP proxy script really be faster than a web server level proxy, utilizing
    a web server written in a low-level systems engineering language? Surely one or
    two lines in your web server configuration is far easier to implement that an
    entire proxy script in PHP?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of just how easy it is to create a proxy in a VirtualHost.
    The following configuration as an Apache VirtualHost will allow you to reroute
    everything from `test.local/api` to `api.local` (it''s even easier in Nginx):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is far easier to maintain than thousands of lines of code in a PHP library
    that imitates something that is already available in the ProxyPass Apache module.
  prefs: []
  type: TYPE_NORMAL
- en: I've heard a criticism of microservices that they seek to move problems from
    the software development layer to the infrastructure layer, but are we really
    saying that that's always a bad thing?
  prefs: []
  type: TYPE_NORMAL
- en: Yes, software developers have a vested interest in doing things at the software
    development layer, but it is often worth educating yourself about the functionality
    you have available higher up the chain and seeing if that can rectify any issues
    you are having.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think in terms of Occam''s razor: the shortest solution is often the best,
    as it is translated literally "more things should not be used than are necessary."'
  prefs: []
  type: TYPE_NORMAL
- en: Interface Bloat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have come across multiple instances of people thinking they're doing great
    architecture but it turns out their efforts turn out to be counterproductive.
    Interface Bloat is a common consequence of this.
  prefs: []
  type: TYPE_NORMAL
- en: Once, when I discussed the importance of Interfaces when doing polymorphism
    in PHP with a Scrum Master, he responded by telling me about an environment he
    once worked in where there was an engineer who spent months developing interfaces
    and thought he was doing brilliant architecture work. Unfortunately, it turns
    out he wasn't doing great infrastructure work, he was guilty of implementing Interface
    Bloat.
  prefs: []
  type: TYPE_NORMAL
- en: Interface Bloat is, as the name suggests, is where an Interface is excessively
    bloated. An interface can be so bloated that it becomes practically impossible
    for a class to be implemented any other way.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces should be used sparingly; do you actually need an interface if the
    class is only ever going to be implemented once and once alone (and realistically,
    no one is never going to need to tamper with such code?). If so, you might want
    to consider avoiding an interface in such a situation.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces should not be used as a means of testing unit functionality. In that
    situation you really should be using unit testing, for example, via PHPUnit. Even
    so, unit testing should test how a unit functions as opposed to being used as
    a tool to ensure no one edits your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let me draw you to one implementation of Interface Bloat. Let''s take a
    look at the `Pheanstalk` interface class in the Pheanstalk open source library
    (note I have stripped the comments to make it more readable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Yuck! Notice how even constants have been put in the implement, the one thing
    you might actually want to change. Clearly, this is an interface for a class that
    can only be implemented one way, making the Interface useless.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces provide a great degree of structure when writing object-oriented
    code; once implemented, they act as the guarantor that the methods in an interface
    have been implemented in a class that implements it.
  prefs: []
  type: TYPE_NORMAL
- en: However, like most good things, it can be a double-edged sword. Someone once
    gave me an incredibly naive argument against architecture design; they cited one
    of their previous co-workers who spent months simply writing incredibly detailed
    Interfaces and thought it was great architecture. In fact, he was committing Interface
    Bloat.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces should not be a way of enforcing implementation; indeed, there are
    examples of interfaces that result in someone being faced with the problem of
    not ever actually being able to implement an interface into a class any other
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces shouldn't contain thousands of methods that reference internal operations
    of the class. They should be lightweight and considered a way of guaranteeing
    that when something is queried that it is definitely there.
  prefs: []
  type: TYPE_NORMAL
- en: There is an anti-pattern known as the **swiss army knife** (or **kitchen sink**)
    around the idea that people try to design interfaces to fit every possible use
    case of a class. This can cause debugging, documentation and maintenance difficulties.
  prefs: []
  type: TYPE_NORMAL
- en: Cart before the horse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like most developers, I occasionally get bemused by some project management
    strategies; *putting the cart before the horse* is no exception.
  prefs: []
  type: TYPE_NORMAL
- en: Putting the cart before the horse is an anti-pattern under which features that
    never need to be built are architected, thus wasting time. The particular setting
    this annoys me is in technical meetings discussing a long-term technical plan
    where a project manager will discuss a feature and immediately demand the technical
    details of how this feature could be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, it's important to note that good developers should go away and have
    research time to come up with a solution. A developer is only made stronger by
    the ability to research their intended solution, to break out with their development
    team, to look online for other people facing similar issues, and then to come
    back with a unified, well-architected solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'I spoke at the inaugural Lead Developer conference in London, and there was
    one quote that stood out to me from listening to others talking at the event.
    It was reused from an African proverb, but is especially true in software engineering
    contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"If you want to go fast, go alone. If you want to go far, go together".*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Having spoken to managing directors and CEOs of various companies, they like
    to have a broad balance of personalities on their board of directors. A chief
    financial officer (CFO) may well be a ruthless perfectionist, only satisfied once
    all their figures are drop-dead perfect, whereas a chief operations officer may
    well be a fierce pragmatist when it comes to delivering on time. Such can be true
    in development teams; having a broad input of specialisms and personalities proposing
    ideas that are battled out to come up with a well-rounded solution can be beneficial
    for large decisions where a sole developer alone cannot be expected to make the
    decisions. Yes, you might want a filter or even say that only a small subsection
    of the development team may be relevant for one particular decision, but on the
    whole, your developers need the resources and time to make architectural decisions.
    Furthermore, the best place to make such architectural decisions is when they
    are most relevant, when it is necessary that they should be made.
  prefs: []
  type: TYPE_NORMAL
- en: Flat Earthers are people who believe that the earth is a flat disc. When confronted
    with the concept of gravity, they instead claim gravity doesn't exist and state
    that this flat earth is instead simply moving upwards in space at a speed of 9.8
    m/s. Confronted with further scientific theories they instead create their own
    illogically pieced together view of how the physical universe exists. Of course,
    such a theory is ridiculous. My point here is that you should base your decisions
    on sound computer science (e.g. published RFCs) instead of creating your own computer
    science on an ad-hoc basis.
  prefs: []
  type: TYPE_NORMAL
- en: Separation of development and operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have encountered development environments where developers are expressly forbidden
    from doing anything at all operational, where traditional development structure
    is relentlessly battered by the 21st-century web environment. There were caged
    job roles; you were either a developer or you looked after hosting. They had separate
    budgets, despite the fact both departments had a clear common destiny.
  prefs: []
  type: TYPE_NORMAL
- en: The result of this kind of setup was that developers and operations technicians
    never shared knowledge. By combining development and operations (DevOps, if you
    will) there is not only an effective boost in the quality of the work delivered
    through a shared knowledge base, but efficiency increases by empowering developers.
  prefs: []
  type: TYPE_NORMAL
- en: In the example I gave, when a site hosted on a company server was hacked or
    vandalized, all operations would do was restore from a backup. Combining development
    efforts into this mix not only resulted in vulnerabilities being patched, but
    also effective measures being put into hosting environments to rectify these issues
    (be they brute-force plugins or web application firewalls).
  prefs: []
  type: TYPE_NORMAL
- en: Excessive separation of development responsibilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Development responsibilities being split too blatantly can be detrimental to
    a team.
  prefs: []
  type: TYPE_NORMAL
- en: Some separation is necessary. For example, teams working with **Internet of
    Things** (**IoT**) platforms cannot be expected to maintain a strong electronics
    engineering knowledge and a strong frontend web development knowledge. That said,
    developers should be expected to learn other skills they encounter and this can
    be assisted by encouraging knowledge sharing. Having multi-disciplined team members
    is not a business disadvantage, indeed it is an advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Error suppression operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The error suppression operator in PHP is a very dangerous tool indeed. Simply
    by putting an at symbol, `@`, in front of a statement, you can suppress any errors
    that result from it, including fatal errors that stop the execution of a script.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this cannot necessarily be deprecated yet in PHP; having spoken
    to those in the PHP internals group, it is the case that there is a whole lot
    of prerequisite work that would need to be done first as some PHP functions do
    not have companion error functions to yield the error in the execution of a PHP
    script. As a result of this, the only way to show a non-fatal error that does
    not necessarily stop the execution of a script is to catch the error that is thrown
    during the operation of that particular function
  prefs: []
  type: TYPE_NORMAL
- en: The PHP core unfortunately, contains a considerable amount of technical debt
    in and of itself. Unfortunately, one thing that a good PHP developer should be
    good at is spotting technical debt in the PHP core itself. Indeed, Facebook tried
    to bypass this problem by rewriting the PHP core themselves and calling it **Hak**;
    I shall leave you to decide on whether you should consider adopting it or not.
  prefs: []
  type: TYPE_NORMAL
- en: One feature I have quite enjoyed in developing in Go (a systems language written
    by Google) is the fact you can do multiple return types (for example, you can
    return two values from one function). This has the added benefit of meaning that
    instead of having a companion function that will return the error message you
    can simply return any errors in a single function call.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing I do like in Go is the fact that all warnings are treated as errors.
    You assign a variable, then don't use it? The program will fail to run (unless
    you assign a variable to an underscore, `_`, which is a null assignment operator
    meaning the variable will not be stored anywhere). Treating warnings as errors
    has the result of meaning that when a developer encounters an error, they know
    it's serious.
  prefs: []
  type: TYPE_NORMAL
- en: 'So yes, PHP can learn a lot from languages such as Go, but fundamentally, it
    is clear that there is also a lot of work that already needs to be done on the
    PHP core, and in addition to this, the PHP community may well need a culture shift
    to being more open and less political. **PHP RFC: Adopt Code Of Conduct** proposed
    that PHP should adopt a *Code of Practice.* Needless to say, if this is adopted
    in some form the PHP community should benefit.'
  prefs: []
  type: TYPE_NORMAL
- en: Turning back to the issue at hand, error suppression operators should be avoided
    unless strictly necessary in the interest of making debugging far easier for developers.
  prefs: []
  type: TYPE_NORMAL
- en: Blind faith
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once when I was around 11 years old I was sitting in a physics lesson with a
    limited quantity of protractors and we were slowly passing them around in order
    to draw an angle. Being the devious short cutter that I was at such a young age,
    I decided not to wait and just trace a drawing someone else made. This was to
    the horror of my physics teacher at the time who stopped dead in his tracks and
    shouted "NO! PHYSICS IS ABOUT ACCURACY!"
  prefs: []
  type: TYPE_NORMAL
- en: He had a point and this is something that is also very true in the programming
    world.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid *blind faith*, you should be aware of the following mistakes:'
  prefs: []
  type: TYPE_NORMAL
- en: Failure to check return types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failure to check your data models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assuming data within your database is correct or is in the format you expect
    it to be
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take this to a more extreme level; take this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, there are two key mistakes. The first mistake is that
    we're directly extracting `GET` variables; we're importing remotely defined variables
    into the current symbol table, effectively allowing anyone to override any variables
    defined before the extract.
  prefs: []
  type: TYPE_NORMAL
- en: Also, there is obviously an XSS vulnerability in that we are returning a `GET`
    variable without sanitizing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So here''s how we can make it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Sequential coupling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Sequential coupling** is where you create a class that has methods that must
    be called in a particular order. Method names that start with `init`, `begin`,
    or `start` may be indicative of this behavior; this may be indicative of an anti-pattern
    depending on the context. Sometimes, engineers use cars to explain abstract concepts,
    here I''ll do the same.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, take the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may note, we have to run the `startCar` function before we can use any
    of the other functions, or an exception is thrown. Really, if you try to accelerate
    a car that is not started, it shouldn''t do anything, but for the sake of argument
    I''ve changed it so that the car will simply start first. In the next example
    of stopping the car, I have changed the class so that the method will return `false`
    if you try to stop the car without it running first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The big rewrite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One temptation of developers is to rewrite an entire codebase. There are pros
    and cons for you to decide, and yes, it is often harder to read existing code
    than it is to write new code; but please do bear in mind that rewrites take time
    and can be hugely costly for your business.
  prefs: []
  type: TYPE_NORMAL
- en: Always bear in mind that the sum of your technical debt from any one project
    can never be greater than starting the project from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Maiz Lulkin wrote the following in a brilliant blog post:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"The problem of big rewrites is that they are a technical solution to a cultural
    problem."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Big rewrites are horribly inefficient, especially when you simply cannot guarantee
    that developers will know any better now. Architecting the new system and migrating
    the data inside the deadlines can be a tall order.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, deploying the big rewrite can be hugely problematic; deploying
    such a change to the entire codebase of an application can be lethal. Try to deploy
    code regularly in frequent intervals. Try to change one thing at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Your software that exists is your existing specification. By building a rewrite,
    you are building code on the basis of legacy code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there is an alternative; rapidly improving your current code base
    in cycles. There are three primary steps you can take to improve your code base:'
  prefs: []
  type: TYPE_NORMAL
- en: Tests (unit tests, behavioral tests, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service splitting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perfectly staged migrations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a chapter in this book dedicated to refactoring and how we can alter
    the design of legacy code.
  prefs: []
  type: TYPE_NORMAL
- en: Automated tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need tests; yes, automated tests can be slow to write, but they are crucial
    for ensuring things don't break when you rewrite or refactor them.
  prefs: []
  type: TYPE_NORMAL
- en: It is also mission-critical that your tests and development occur on an environment
    that is as close to production as possible. Small changes in web server software
    or database permissions can have disastrous consequences.
  prefs: []
  type: TYPE_NORMAL
- en: Using an automated deployment system such as Vagrant with Puppet or Docker can
    be a great solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'When doing unit tests with PHPUnit and Composer, you can just include it in
    your `composer.json` file to pull it in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to this, a `phpunit.xml` file may also be useful so that PHPUnit
    knows where the tests are, but also where the Composer autoloader is (so it can
    go ahead and pull in classes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then write tests as you normally would in PHPUnit, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Except, of course, you have the added benefit of being able to pull in PHP classes
    in your autoloader as you need them.
  prefs: []
  type: TYPE_NORMAL
- en: Not all tests need to be unit tests. Writing external test scripts to test APIs
    can be beneficial too. A tool called **Selenium** ([http://www.seleniumhq.org](http://www.seleniumhq.org))
    can even help you with browser automation.
  prefs: []
  type: TYPE_NORMAL
- en: Service splitting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Splitting your monolith into small independent loosely coupled services is a
    great way to reduce technical debt.
  prefs: []
  type: TYPE_NORMAL
- en: Large monolith applications which have technical debt rooting right into the
    core of the application can be problematic to deal with. Building on top of such
    unstable foundations can be tough to split up later. There is a solution, however;
    by building new functionality as independent services you can effectively build
    on a new core with a stable foundation, diverging from your old weak infrastructure.
    You can then intercommunicate this with the old monolith and such new services
    using a RESTful structure.
  prefs: []
  type: TYPE_NORMAL
- en: This structure allows you to continue developing new functionality while migrating
    to a new microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Martin Fowler proposed a system known as **Branch by Abstraction**, which allows
    you to make the large-scale change to systems in a gradual way, which allows you
    to continue to release while change is still being conducted.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to capture the interaction between one section of client code
    and its supplier; we can then change that section of the code so it all inter-communicates
    via an abstraction layer.
  prefs: []
  type: TYPE_NORMAL
- en: We then do this for interactions with the supplier. As we do this, we take the
    opportunity to improve unit test coverage. Once a supplier isn't in use at all,
    we can migrate the clients over to use the supplier instead and delete the old
    supplier.
  prefs: []
  type: TYPE_NORMAL
- en: Perfectly staged migrations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Splitting your monolith into small independent loosely coupled services is a
    great way to reduce technical debt, but in this process, you clearly add extra
    burden to the architectural level.
  prefs: []
  type: TYPE_NORMAL
- en: When migrating data or hosting environments, you might come across difficulties
    in this process. This is particularly true when the deployment process isn't repeated
    and is unique for each deployment (such as in environments that don't use Continuous
    Integration).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using container technology such as Docker can allow you to better perform rapid
    application deployments, allowing you to deploy faster while also increasing portability
    and simplifying maintenance. Some people may find other technologies, such as
    Vagrant, more beneficial for them; regardless, there is a common factor in all
    these technologies: infrastructure as code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Infrastructure as code** is the process of managing and provisioning computing
    infrastructure through code instead of interactive configuration tools; however,
    what we are after here is even more basic than this. What we want is to be able
    to stage and test migrations of any kind before the fact and re-run the exact
    process when we perform the migration.'
  prefs: []
  type: TYPE_NORMAL
- en: By scripting migrations, you can test them beforehand just like code. You can
    be sure when it's done on a live server instead of a staging server there's a
    reduced chance of any mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, the migrations can later be used to reverse engineer the
    process should a factor in the deployment cause problems later, or so the justifications
    for decisions can be seen. It essentially acts as an artifact for the software
    deployment process.
  prefs: []
  type: TYPE_NORMAL
- en: Where possible, as many resources as possible should be available during this
    process; this includes those deploying the code, developers who put the project
    together, and in extreme cases, a communications individual to keep clients up
    to date. Those resources allow rapid debugging of those issues, but it is vital
    that an individual deploying the code takes the lead and orchestrates when these
    resources are required in order to prevent distractions.
  prefs: []
  type: TYPE_NORMAL
- en: Working to a formal pre-planned routine, while also allowing room to correct
    any issues, can often help make deployments as painless as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Tester-Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a tongue-in-cheek reference to **Test-Driven Development** (**TDD**).
    TDD is a software development strategy largely revolving around using development
    tests to drive implementation towards fulfilling the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Tester-Driven Development, however, is where the requirements are the shortcut
    and it becomes the case that the software team starts specifying the requirements
    through bug reports. Tester-Driven Development can also be referred to as **Bug-Driven
    Development** as it essentially results in bug reports being used to specify actions
    and features that developers should implement.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a developer builds a tool to export data from a database to a spreadsheet.
    It works perfectly, but a tester still comes back and raises a ticket saying that
    there is a bug in the product; they say that it doesn't contain the ability to
    export to PDF. If this wasn't in the requirements it shouldn't be raised as a
    bug. And yes, you should have requirements.
  prefs: []
  type: TYPE_NORMAL
- en: QA teams and testers exist to verify that software meets the requirements. They
    do not exist to specify the requirements themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Bloated optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, developers may trip over themselves trying to optimize their code or
    their design artifacts to a ridiculous extent, often before their code even performs
    basic functions, or even before any code has been created at all. This can rapidly
    perform issues in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, I wish to discuss three anti-patterns specifically relating
    to this topic:'
  prefs: []
  type: TYPE_NORMAL
- en: Analysis paralysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bikeshedding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Premature optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analysis paralysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In short, this is where a strategy is over-analyzed to the point where progress
    is slowed down, or even stopped entirely in extreme cases. Not only can such solutions
    become obsolete rapidly, they can be made in under-educated circumstances, for
    example, in a meeting where an over-analytic boss tries to dig too deep into detail
    in advance without allowing their developers to actually do some research.
  prefs: []
  type: TYPE_NORMAL
- en: Over-analyzing a problem and seeking a perfect solution upfront just does not
    work; programmers should seek to refine their solution, not come up with the refined
    solution up front.
  prefs: []
  type: TYPE_NORMAL
- en: Bikeshedding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Essentially, this is where analysis paralysis can occur on the basis of some
    very trivial decisions, for example, the color of a log in page. The only fix
    that's required is to not waste time on trivial decisions. Avoid design by committee
    where possible as the majority of people, regardless of how good they think their
    design skills are, are largely incompetent at design.
  prefs: []
  type: TYPE_NORMAL
- en: Premature optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, so far, I've largely beaten up project managers; no time to
    beat up developers. Often, developers will seek to optimize their code prematurely
    without having educated data-led conclusions to drive where and when optimizations
    should be made.
  prefs: []
  type: TYPE_NORMAL
- en: Writing clean and readable code is your first priority; then you can use some
    great profiling tools to determine where your bottlenecks are. XDebug and New
    Relic are just some of the tools that are good at this.
  prefs: []
  type: TYPE_NORMAL
- en: That said, there are some cases where optimization must be done, particularly
    on some long computational tasks where it can be mission-critical to reduce something
    from O(N2) time to O(N). This said, most simple PHP web apps will have no real
    need to use this consideration.
  prefs: []
  type: TYPE_NORMAL
- en: Uneducated manager syndrome
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Has your manager ever built a web app themselves? I find that this is a fairly
    important characteristic for a manager to have. The same way a junior doctor will
    report to a doctor who has been through the process of being a junior doctor themselves,
    or a teacher will report to a head teacher who themselves has been a teacher,
    a software developer should report to someone who has been through that process
    themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, in small teams (for example, a small design house that does web development
    on the side), an engineering manager might not be strictly necessary. This works
    well where managers do understand the need to defer decisions to the programmers
    where necessary. However, as soon as things scale up, there needs to be structure.
  prefs: []
  type: TYPE_NORMAL
- en: Decisions such as who to hire, who to fire, how to address technical debt, which
    elements need most focus, and so on, need to be taken by developers; in addition
    to this, they sometimes mustn't be taken democratically because doing so would
    result in design by committee. In this instance, an engineering manager is required.
  prefs: []
  type: TYPE_NORMAL
- en: In large scale teams, there should always be a developer who spends more than
    90% of their time not writing code.
  prefs: []
  type: TYPE_NORMAL
- en: I will take this a step further; a web engineering manager shouldn't just have
    a technical background, they should have a web background. Developing a Java application
    developer can be wholly different to building a PHP web application, and such
    an engineering manager should accordingly have an understanding of such a discipline
    by having some web experience (though it doesn't necessarily have to be in one
    particular language).
  prefs: []
  type: TYPE_NORMAL
- en: Wrong rocky foundations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The SensioLabs Insight tool was used to evaluate technical debt within various
    projects, and they evaluated and published the responses. SensioLabs responded
    on their blog saying that the results didn''t account for project age or project
    size, but nevertheless it does show the technical debt you''re up against in using
    some frameworks as foundations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wrong rocky foundations](graphics/image_02_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Don''t get me wrong: WordPress is a great CMS; yes, it has some quirks in the
    core and comes from the days before OOP, but it''s a great blogging platform.
    You ordinarily shouldn''t be fiddling with it''s core code, so you don''t need
    to worry about it. By no means should you write your own blogging platform or
    CMS, but at the same time, WordPress isn''t the right problem for building a marketing
    asset system or an insurance quote generator (yes, both are real projects I have
    been asked to do in WordPress initially).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In short: use the best foundations for your task.'
  prefs: []
  type: TYPE_NORMAL
- en: Long methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Methods can be overly complicated in some instances with PHP; for example,
    in the following class I have intentionally left out some meaningful comments
    and also made the constructor excessively long:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s make just two small changes; let''s extract some of our methods
    into their own functions and let''s add some DocBlock comments. This is still
    by no means perfect, but note the difference that is made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Long methods are an indicator of code smell; they refer to a symptom in the
    code that may have its origins in a deeper problem. Other examples include duplicate
    code and contrived complexity (using advanced design patterns where a simpler
    approach would suffice).
  prefs: []
  type: TYPE_NORMAL
- en: Magic numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Note how in the preceding example I always put my constant numeric variables
    in class constants, as opposed to directly putting them in the code itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The reason I did this was to avoid an anti-pattern known as **magic numbers** or
    **unnamed numerical constants**. Using class constants makes code easier to read,
    understand, and maintain; and of course, under the PSR standards, they should
    be declared in uppercase, separated by underscores.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we covered some fundamental anti-patterns for you to avoid;
    some were architectural, some were PHP-related, and others were at the management
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentally, anti-patterns result in technical debt. By technical debt, we
    are talking about code that is so hard to extend that it becomes harder to make
    changes to later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a list of things I want you to do to fix this:'
  prefs: []
  type: TYPE_NORMAL
- en: Plan before you start coding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make comments, and add a comment where the purpose of your code isn't immediately
    apparent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure your code has structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to avoid putting too much code in one method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use DocBlocking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use common sense approaches to PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we have learned some common design issues that can lead to
    severe problems; these principles can help you prevent sizable issues later on.
    Writing code to scale is an important factor of design. At its core, this requires
    understanding the constraints. Using proper strategies for inter-process communication
    can help your service scale while writing loosely coupled code can increase code
    reuse and debugging. Finally, when it comes to deploying this awesome code, automated
    testing and Perfectly Staged Migrations can make sure this goes off without a
    hitch.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, we will move on to covering some design patterns (presumably,
    what you've been waiting for).
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in learning about how to improve the design of an existing
    codebase, you might find the dedicated chapter on refactoring in this book particularly
    interesting; but it's worth reading up on the other design patterns first in order
    to gain an understanding of the patterns we are trying to refactor towards.
  prefs: []
  type: TYPE_NORMAL
