- en: Chapter 2. Setting Up an Android Forensic Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is crucial to have an established forensic environment set up before the
    start of any forensic examination. The forensic analyst needs to be in total control
    of the workstation at all times. This chapter will take you through everything
    that is necessary to have an established forensic set up to examine Android devices.
    In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installation of necessary software on the workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting and accessing an Android device from the workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ADB commands on the device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rooting Android devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Android forensic setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Setting up a sound and well-controlled forensic environment is crucial before
    the start of any investigation. Start with a fresh and **forensically sterile**
    computer. A forensically sterile computer is one that prevents the potential of
    cross contamination, does not introduce unwanted data, and is free from viruses
    and other malware. This is to ensure that the software present on the machine
    does not interfere with the current investigation. Install basic software, such
    as the following ones; they are necessary to connect to the device and perform
    analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: Android SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile drivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MS Office packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools used for analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Android SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important that we begin the discussion with the Android SDK. The Android
    **Software Development Kit** (**SDK**) helps developers build, test, and debug
    applications to run on Android. It includes software libraries, APIs, emulator,
    reference material, and many other tools. These tools not only help create Android
    applications but also provide documentation and utilities that help significantly
    in forensic analysis of Android devices. Having sound knowledge of the Android
    SDK can help you understand the particulars of a device. This, in turn, will help
    you during an investigation.
  prefs: []
  type: TYPE_NORMAL
- en: During forensic examination, the SDK helps us connect the device and access
    the data present on the device. The SDK is supported in most of environments,
    including Windows, Linux, and OS X. It can be downloaded for free from [http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Android SDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Google now offers Android Studio and SDK tools only as download options. Android
    studio contains the Android IDE, SDK tools, Android 5.0 (Lollipop) platform, Android
    5.0 system image with Google APIs, and other newly introduced features. However,
    for a forensic lab setup, downloading the SDK tools package alone would be sufficient.
    The following is a step-by-step procedure to install the Android SDK on a Windows
    8 machine:'
  prefs: []
  type: TYPE_NORMAL
- en: Before starting the Android SDK installation, make sure that the system has
    the **Java Development Kit** (**JDK**) installed, because the Android SDK is dependent
    on the Java SE Development Kit. JDK can be downloaded from [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html).
    Select the correct download based on your operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the latest version of the SDK tools package from [http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html).
    The `.exe` version of the package is recommended for download.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the installer file downloaded in step 2\. A wizard window will appear, as
    shown in the following screenshot. Then, click on **Next**.![Installing the Android
    SDK](img/image00268.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Android SDK setup wizard
  prefs: []
  type: TYPE_NORMAL
- en: The setup will automatically detect whether Java is installed on the system
    and select the path where Java is installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the installation location and remember it for future use. In this example,
    we will install it in `C:\Program Files (x86)`. In the case of a 32-bit operating
    system, the default location would be `C:\Program Files`. All the necessary files
    will be extracted to this location, as shown in the following screenshot:![Installing
    the Android SDK](img/image00269.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Android SDK tools installation
  prefs: []
  type: TYPE_NORMAL
- en: Once the installation is complete, open the `C:\Program Files (x86)\Android\android-sdk`
    directory and double-click on `SDK Manager.exe`. Make sure that you select the
    Android SDK Platform tools and any one release platform version of Android, as
    shown in the following screenshot. Some of the items are automatically selected.
    For instance, Google USB Driver is necessary to work with Android devices on Windows
    and is selected by default. Accept the license terms and then proceed to install
    it by clicking the **Install** button:![Installing the Android SDK](img/image00270.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Android packages installation
  prefs: []
  type: TYPE_NORMAL
- en: The last step in the preceding process takes some time to complete. Once it
    is done, the Android SDK installation is complete. You can now update the system's
    environment variables (path) by pointing to the executable files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The minimal ADB and fastboot tool, which is only 2 MB in size and available
    freely on XDA forums ([http://forum.xda-developers.com/showthread.php?t=2317790](http://forum.xda-developers.com/showthread.php?t=2317790)),
    can be used without installing the complete Android SDK. This tool is a Windows
    installer that will install the latest version of ADB and fastboot quickly and
    easily.
  prefs: []
  type: TYPE_NORMAL
- en: Android Virtual Device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the Android SDK installed, you can create an **Android Virtual Device**
    (**AVD**), which is an **emulator** that runs on the workstation. An emulator
    is often used by developers when creating new applications. However, an emulator
    is also considered helpful during forensic investigations. It allows the investigator
    to understand how certain applications behave and how the installation of an application
    affects the device. Another advantage is that you can design an emulator with
    the desired version. This is especially helpful when working with devices running
    on older versions of Android. Also, AVD comes with root as default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will guide you to create an AVD on the workstation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open command prompt (`cmd.exe`). To start AVD manager from the command line,
    navigate to the path where SDK is installed and call the android tool with the
    `avd` option as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will automatically open AVD manager, as shown in the following screenshot.
    AVD manager can also be started using the graphical AVD manager. To start it,
    navigate to the location where the SDK is installed and double-click on `AVD Manager`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Android Virtual Device](img/image00271.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Android Virtual Device Manager
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Create** in the **AVD Manager** window to create a new virtual device.
    Click on **Edit** to change the configuration of an existing virtual device, as
    shown in the following screenshot:![Android Virtual Device](img/image00272.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AVD details
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the necessary details based on the following information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**AVD Name**: Provide any name for the virtual device, for example, `MyAVD`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Device**: Select any device from the available options based on the screen
    size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target**: This option helps you select the platform of the device. Note that
    only those versions that were selected and installed during the SDK installation
    will be shown here for you to select. The platform version can be selected based
    on the OS of the seized device. For our example, the Android 4.4.2 platform is
    selected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hardware**: You can select hardware features to customize the emulator, for
    example, the size of internal storage memory, SD card, and so on. Once again,
    details such as screen resolution, hardware, and so on can be selected based on
    the details corresponding to the seized device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once this is done, the **AVD Manager** screen appears with the newly created
    AVD listed under the **Android Virtual Devices** tab. Select the AVD and click
    on **Start**. Then, click on **Launch**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The emulator will be automatically launched. This could take several minutes,
    depending on the workstation's CPU and RAM. Here is a screenshot of an AVD after
    its successful launch:![Android Virtual Device](img/image00273.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Android emulator
  prefs: []
  type: TYPE_NORMAL
- en: 'An emulator can be used to configure e-mail accounts, install applications,
    surf the Internet, send text messages, and so on. Forensic analysts and security
    engineers can learn a great deal about Android and how it operates by leveraging
    the emulator and examining the network, filesystem, and data artifacts. The data
    created when working on an emulator is stored in your home directory, in a folder
    named .android. For instance, in our example, the details about `MyAVD` emulator
    that we created earlier are stored in `C:\Users\Rohit\.android\avd\MyAVD.avd`.
    There are several files present under this directory, and here are some files
    of interest for a forensic analyst:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cache.img`: This is the disk image of the `/cache` partition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sdcard.img`: This is the disk image of the SD card partition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Userdata-qemu.img`: This is the disk image of `/data` partition. The `/data`
    partition contains valuable information about the device user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config.ini`: This is the configuration file that stores hardware options in
    AVD''s local directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emulator-user.ini`: This file contains values that can reset the position
    of the window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Androidtool.cfg`: This file can be used to manually set proxy settings for
    the Android SDK.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting and accessing an Android device from the workstation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to extract information from an Android device, it first needs to be
    connected to the workstation. As mentioned earlier, care should be taken to make
    sure that the workstation is forensically sterile and used only for the purpose
    of investigation. A forensically sterile workstation is one that has a proper
    build and is free from viruses and other malware. When a device is connected to
    the computer, changes can be made to the device. Hence, it is crucial that the
    forensic examiner maintains control over the device at all times. In the world
    of mobile forensics, using write-protection mechanisms may not be of great help,
    as they prevent successful acquisition of the device. This is because during acquisition,
    certain commands need to be pushed to the device to extract the necessary data.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the device cable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An Android device can be connected to the workstation using the physical USB
    interface of the device. This physical USB interface allows the device to connect,
    share data, and recharge from a computer. USB interfaces might change from manufacturer
    to manufacturer and also from device to device. There are different types, such
    as mini-USB, micro-USB, and other proprietary formats. Here is a brief description
    of the most widely used connector types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Connector type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Mini—A USB | It is approximately 7 x 3 mm in size, with two of the corners
    on one long side lifted out. |'
  prefs: []
  type: TYPE_TB
- en: '| Micro—B USB | It is approximately 6 x 1.5 mm in size, with two corners cut
    off to form a trapezoid. |'
  prefs: []
  type: TYPE_TB
- en: '| Co-axial | It has a circular hole with a pin sticking up in the middle. There
    are different sizes, varying from 2 to 5 mm in diameter. This type is widely used
    with Nokia models. |'
  prefs: []
  type: TYPE_TB
- en: '| D Sub-miniature | It has a rectangular shape with two rounded corners. The
    length of the rectangle varies, but the height is always 1.5 to 2 mm. This type
    is used mostly by Samsung and LG devices. |'
  prefs: []
  type: TYPE_TB
- en: Hence, the first step in acquisition is to identify what kind of device cable
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: Installing device drivers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A mobile device can communicate with the computer only when the necessary device
    drivers are installed on the computer. Without the necessary drivers, the computer
    may not be able to identify and work with the connected device. Since Android
    may be modified and customized by the manufacturers, there is no single generic
    driver that would work for all the Android devices. Each manufacturer has their
    own proprietary drivers and distributes them along with the phone. So, it is important
    to identify the specific device driver that needs to be installed. Of course,
    some of the Android forensic toolkits come with some generic drivers or a set
    of most used drivers. They may not work with all models of Android phones. Some
    Windows operating systems are able to auto detect and install the drivers once
    the device is plugged in but, more often than not, Windows fails. The device drivers
    for each manufacturer can be found on their respective websites.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After installing the necessary device drivers, connect the Android device to
    the computer, directly using the USB cable in order to access it. It is important
    to use genuine manufacturer-specific cables, because universal cables may not
    work properly with certain devices. Also, the investigator may encounter certain
    driver issues. Some of the devices may not be USB 3.0 compatible, which may lead
    to failed driver installations. In this case, it is recommended that you try switching
    to USB 2.0 ports. Once the device is connected, it will appear as a new drive,
    and you can access the files on the external storage. Some older Android devices
    may not be accessible unless the **Connect storage to PC** option (navigate to
    **Settings** | **USB utilities**) is enabled on the device. In this case, after
    connecting the device through a USB, the **Turn on USB storage** option needs
    to be selected, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing the device](img/image00274.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: USB mass storage connection
  prefs: []
  type: TYPE_NORMAL
- en: This is because older Android devices required USB mass storage mode to transfer
    files between a computer and the device. Latest Android devices use the **Media
    Transfer Protocol** (**MTP**) or the **Picture Transfer Protocol** (**PTP**),
    as there were some issues with the USB mass storage protocol. With USB mass storage,
    the drive makes itself completely available to the computer, just as if it were
    an internal drive.
  prefs: []
  type: TYPE_NORMAL
- en: However, the problem is that the device that is accessing the storage needs
    exclusive access to it. In other words, when the device drive is connected to
    the computer, it has to be disconnected from the Android operating system running
    on the device in order to work. So, any files or apps stored on the SD card or
    USB storage will be unavailable when it is connected to the computer. In MTP,
    the Android device doesn't expose its entire storage to Windows. Instead, when
    you connect a device to your computer, the computer queries the device, and the
    device responds with a list of files and directories it offers. If the computer
    has to download a file, it would send a request to the file from the device, and
    the device would send the file over the connection. PTP is also similar to MTP
    and is commonly used by digital cameras. In this mode, the Android device will
    work with digital camera applications that support PTP but not MTP. On the latest
    devices, you can select either MTP or PTP options by going to **Settings** | **Storage**
    | **USB computer connection**.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On some Android devices, the option to select MTP and PTP protocols is provided
    only after connecting the device to the computer. After the device is connected,
    watch out for the Notifications bar at the top of your screen, and you will see
    a USB symbol appear. Pull down the notifications bar, and you will find an option
    to switch between MTP and PTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following screenshot, the **MTP** and **PTP** options are shown
    only after connecting the device to a computer and pulling down the notifications
    bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing the device](img/image00275.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: USB PC connection in an Android device
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of certain Android devices (especially with HTC), the device may
    expose more than one functionality when connected with a USB cable. For instance,
    as shown in the following screenshot, when an HTC device is connected to the workstation,
    it presents a menu with four options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing the device](img/image00276.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Disk drive option on a HTC device
  prefs: []
  type: TYPE_NORMAL
- en: The default selection is **Charge only**. When the **Disk drive** option is
    selected, it is mounted as a disk drive. When the device is mounted as a disk
    drive, you will be able to access the SD card present on the device.
  prefs: []
  type: TYPE_NORMAL
- en: From a forensic point of view, the SD card has a significant value, as it may
    contain files that are important for an investigation. Most of the images and
    large files related to multimedia are stored in this external storage. SD cards
    are commonly formatted with the FAT16 filesystem, but you might also encounter
    some SD cards that have FAT32 and other filesystems. As discussed in [Chapter
    1](part0014.xhtml "Chapter 1. Introducing Android Forensics"), *Introducing Android
    Forensics*, note that most of the recent devices have the emulated SD card feature
    that uses the device's NAND flash to create a non-removable SD card. Thus, all
    the sensitive files present on the external storage can be accessed in this way.
    However, the core application data stored under `/data/data` will remain on the
    device and cannot be accessed in this way.
  prefs: []
  type: TYPE_NORMAL
- en: Android Debug Bridge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Android forensics, **Android Debug Bridge** (**ADB**) plays a very crucial
    role. It is present at `<sdk_path>/platform-tools`. In order to work with ADB,
    the **USB-debugging** option needs to be enabled. On a Samsung phone, you can
    access this by going to **Settings** | **Developer** options; as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Android Debug Bridge](img/image00277.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The USB debugging option in Android
  prefs: []
  type: TYPE_NORMAL
- en: However, this may not be the case with all the devices, as different devices
    have different environments and configuration features. Sometimes, the examiner
    might have to use certain techniques to access the developer options on a few
    devices. These techniques are device specific and need to be researched and determined
    by the forensic analyst, based on the device type and model.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On some devices, the **Developer options** menu is hidden and can be turned
    on by tapping on the **Build Number** field (navigate to **Settings** | **About
    Device**) *seven* times.
  prefs: []
  type: TYPE_NORMAL
- en: Once the **USB debugging** option is selected, the device will run the **adb
    daemon** (**adbd**) in the background and will continuously look for a USB connection.
    The daemon usually runs under a non-privileged shell user account and thus does
    not provide access to internal application data. However, on rooted phones, adbd
    will run under the root account and thus provide access to the entire data. On
    the workstation (where the Android SDK) is installed, adbd will run as a background
    process. Also, on the same workstation, a client program will run that can be
    invoked from a shell by issuing the `adb` command. We are going to see this in
    the following sections. When the adb client is started, it first checks whether
    the adbd is already running. If it isn't, it initiates a new process to start
    the abdb. The daemons communicate over their local host on ports 5555 through
    5585\. The even port communicates with the device's console, while the odd port
    is for adb connections. The adb client program communicates with the local adbd
    over port 5037\.
  prefs: []
  type: TYPE_NORMAL
- en: Using adb to access the device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated earlier, adb is a powerful tool that allows you to communicate with
    the Android device. We will now look at how to use adb and access certain parts
    of the device that cannot be accessed normally. It is important to note that the
    collection of data through adb may or may not be accepted as evidence in court.
    This will depend on the laws of respective countries. The following sections list
    some of the commonly used adb commands, their meanings, and usage in a logical
    sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting a connected device
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After connecting the device to the workstation and before issuing other adb
    commands, it is helpful to know whether the Android device is properly connected
    to the adb server. This can be done using the `adb.exe` devices command, which
    lists out all the devices that are connected to the computer, as shown in the
    following command. This would also list the emulator if it is running at the time
    of issuing the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that if the necessary drivers are not installed, then the preceding
    command would show a blank message. If you encounter this situation, download
    the necessary drivers from the manufacturer and install them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the preceding commands, the output contains the serial number of
    the device, followed by the connection state. The serial number is a unique string
    used by ADB to identify each Android device. The possible values of the connection
    state and their meaning is explained in the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '`offline`: The instance is not connected to adb or is not responding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`device`: The instance is connected to the adb server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no device`: There is no device connected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directing commands to a specific device
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If more than one device is connected to the system, you must specify the target
    device while issuing the commands. For example, consider the following case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding command-line output, there are two devices attached
    to the workstation. In this case, `adb` needs to be used along with the `–s` option
    to issue commands to the device of your choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, the `–d` command can be used to direct an `adb` command to the only
    attached USB device, and the `–e` command can be used to direct an `adb` command
    to the only running emulator instance.
  prefs: []
  type: TYPE_NORMAL
- en: Issuing shell commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 1](part0014.xhtml "Chapter 1. Introducing Android Forensics"),
    *Introducing Android Forensics*, Android runs on a Linux kernel and provides a
    way to access the shell. Using ADB, you can access a shell to run several commands
    on an Android device. For those who are not familiar with the Linux environment,
    the Linux shell refers to a special program that allows you to interact with it
    by entering certain commands from the keyboard. The shell will execute the commands
    and display their output.
  prefs: []
  type: TYPE_NORMAL
- en: 'More details about how things work on the Linux environment have been provided
    under the *Rooting Android device* section in this chapter. The `adb` shell command
    can be used to enter into a remote shell, as shown in the following command-line
    output. Once you enter the shell, you can execute most of the Linux commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the command, observe that the shell prompt is displayed to
    the user. In this shell prompt, commands can be executed on the device. For instance,
    as shown in the following command line, the `ls` command can be used to view all
    the files within a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The following section explains some of the widely used Linux commands that are
    very helpful while interacting with an Android device.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Linux commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will now take a look at some of the Linux commands and their usage with
    respect to an Android device:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ls`: The ls command (with no option) lists files and directories present in
    the current directory. With the `-l` option, it also shows their size, modified
    date and time, owner of file and it''s permission, and so on as shown in the following
    command-line output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, here are a few options that can be used along with the `ls` command.
    Depending on the requirement, one or more of these options can be used by the
    investigator to view the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `a` | Lists hidden files |'
  prefs: []
  type: TYPE_TB
- en: '| `c` | Displays files by timestamp |'
  prefs: []
  type: TYPE_TB
- en: '| `d` | Displays only directories |'
  prefs: []
  type: TYPE_TB
- en: '| `n` | Displays the long format listing, with GID and UID numbers |'
  prefs: []
  type: TYPE_TB
- en: '| `R` | Displays subdirectories as well |'
  prefs: []
  type: TYPE_TB
- en: '| `t` | Displays files based on timestamp |'
  prefs: []
  type: TYPE_TB
- en: '| `u` | Displays the file access time |'
  prefs: []
  type: TYPE_TB
- en: '`cat`: The cat command reads one or more files and prints them to standard
    output, as shown in the following command lines:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `>` operator can be used to combine multiple files into one. The `>>` operator
    can be used to append to an existing file.
  prefs: []
  type: TYPE_NORMAL
- en: '`cd`: The `cd` command is used to change from one directory to another. This
    is used while navigating from one folder to another. The following example shows
    commands used to change to the system folder:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`cp`: The `cp` command can be used to copy a file from one location to another.
    The syntax for this command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`chmod`: The `chmod` command is used to change the access permissions to filesystem
    objects (files and directories). It may also alter special mode flags. The syntax
    for this command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For example, `chmod 777` on a file gives permission to everyone to read, write,
    and execute it.
  prefs: []
  type: TYPE_NORMAL
- en: '`dd`: The `dd` command is used to copy a file, converting and formatting according
    to the operands. With Android, the `dd` command can be used to create a bit-by-bit
    image of the Android device. More details about the imaging are covered in [Chapter
    5](part0040.xhtml "Chapter 5. Extracting Data Physically from Android Devices"),
    *Extracting Data Physically from Android Devices*. Here is the syntax that needs
    to be used with this command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`rm`: The `rm` command can be used to delete files or directories. Here is
    the syntax for this command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`grep`: The `grep` command is used to search files or output for a particular
    pattern. The following example shows searching a `default.prop` file for the word
    `secure`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`pwd`: The `pwd` command displays the current working directory. For example,
    the following command-line output shows that the current working directory is
    `/system`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`mkdir`: The `mkdir` command is used to create a new directory. The syntax
    for this command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`exit`: The `exit` command can be used to exit the shell you are in. Just type
    `exit` in the shell to exit from it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing an application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'During forensic analysis, there might be cases where you need to install a
    few applications on the device in order to extract some data. To do so, you can
    use the `adb.exe install` command. Along with this command, as shown in the following
    command-line output, you need to specify the path to the `.apk` file that you
    want to install:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: However, it is important to note that installing third-party apps may not be
    accepted in a court of law. Hence, a forensic investigator needs to be cautious
    before installing any third-party app on the device.
  prefs: []
  type: TYPE_NORMAL
- en: Pulling data from the device
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the `adb pull` command to pull the files present on the Android
    device to the local workstation. Here is the syntax to use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `<remote>` refers to path of the file on the Android device, and `<local>`
    refers to the location on the local workstation where the file needs to be stored.
    For instance, the following command-line output shows a `Sample.png` file being
    pulled from the Android device to a `temp` folder on computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: However, on a normal Android phone, you will not be able to download all the
    files using the `adb pull` command, because of the inherent security features
    enforced by the operating system. For example, files present under the `/data/data`
    folder cannot be accessed in this manner on an Android device that is not rooted.
    More details about this topic have been covered in [Chapter 4](part0031.xhtml
    "Chapter 4. Extracting Data Logically from Android Devices"), *Extracting Data
    Logically from Android Devices*.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing data to the device
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the `adb push` command to copy files from the local workstation
    to the Android device. Here is the syntax to use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `<local>` refers to location of the file on the local workstation, and
    `<remote>` refers to the path on the Android device where the file needs to be
    stored. For instance, the following command-line output shows a `test.png` file
    copied from the computer to the `Pictures` folder of an Android device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can only push the files to the folders for which the user account has privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Restarting the adb server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some cases, you might need to terminate the adb server process and then restart
    it. For example, if adb does not respond to a command. This may resolve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: To stop the adb server, use the `kill-server` command. You can then restart
    the server by issuing any other adb command.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing log data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Android, the `logcat` command provides a way to view the system debug output.
    Logs from various applications and portions of the system are collected in a series
    of circular buffers which then can be viewed and filtered by this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The log message shown here is just a sample message. During investigation,
    logs need to be carefully analyzed to gather information on location details,
    data/time information, application details, and so on. Each log begins with a
    message type indicator, as described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Message Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `V` | Verbose |'
  prefs: []
  type: TYPE_TB
- en: '| `D` | Debug |'
  prefs: []
  type: TYPE_TB
- en: '| `I` | Information |'
  prefs: []
  type: TYPE_TB
- en: '| `W` | Warning |'
  prefs: []
  type: TYPE_TB
- en: '| `E` | Error |'
  prefs: []
  type: TYPE_TB
- en: '| `F` | Fatal |'
  prefs: []
  type: TYPE_TB
- en: '| `S` | Silent |'
  prefs: []
  type: TYPE_TB
- en: 'The `logcat` command can also be used to view full cellular radio debugging,
    as shown in the following command-line output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Rooting Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Rooting" is a word that is very often heard with respect to Android devices.
    As a forensic examiner, it is essential to understand this in detail. This will
    help you gain the knowledge that is required to understand the internals of the
    device. It will also help you gain expertise on several issues that are encountered
    during an investigation. Rooting Android phones has become a common phenomenon
    and rooted phones are very often encountered during investigations. Also, depending
    on the situation and data to be extracted, the examiner himself has to root the
    device in order to extract certain data. The following sections talk about rooting
    an Android device and other related concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: What is rooting?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand rooting, it is essential to understand how Unix-like systems
    work. The original Unix operating system on which Linux and other Unix-like systems
    are based was designed from the very beginning as a multiuser system. This is
    primarily because personal computers did not yet exist, and hence, it was necessary
    to have a mechanism to separate and protect the resources of the individual users
    while allowing them to use the system simultaneously. However, in order to perform
    privileged tasks, such as granting and revoking powers for ordinary users, accessing
    critical system files to repair or upgrade the system, and so on, it was necessary
    to have a system administrator account that has superuser access. So we have two
    types of accounts: normal user accounts, which have fewer privileges, and a superuser
    or root account, which has all the privileges.'
  prefs: []
  type: TYPE_NORMAL
- en: Hence, root is the user name or account that, by default, has access to all
    commands and files on a Linux or other Unix-like operating system. It is also
    referred to as the root account, root user, and the superuser. So, in Linux, the
    root user has the power to start or stop any system service, edit or delete any
    file, change the privileges of other users, and so on. You have learned that Android
    uses the Linux kernel, and hence, most of the concepts present in Linux are applicable
    to Android as well. However, when you buy an Android phone, normally, it does
    not let you log in as a root user. Rooting an Android phone is all about gaining
    this root access on the device to perform actions that are not normally allowed
    on the device.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to understand the difference between rooting and **jailbreaking**,
    as they are often wrongly assumed to be the same. Jailbreaking a device that runs
    Apple iOS allows you to remove certain restrictions and limitations put in place
    by Apple. For instance, Apple does not allow us to sideload an unsigned application
    on the device. So, by jailbreaking, you can install applications that are not
    approved by Apple. In contrast, Android allows sideloading of applications. Jailbreaking
    a phone involves bypassing several security restrictions simultaneously. Thus,
    gaining root access on the device is only one of the aspects of jailbreaking a
    device.
  prefs: []
  type: TYPE_NORMAL
- en: Why root?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rooting is often performed by many people with the goal of overcoming limitations
    that carriers and hardware manufacturers put on Android devices. By rooting an
    Android device, you can alter or replace system applications and settings, run
    specialized apps that require administrator-level permissions, or perform operations
    that are otherwise inaccessible to a normal Android user. These actions include
    uninstalling the default apps (especially the bloatware) that come along with
    the phone. Rooting is also done for extreme customization; for instance, new customized
    ROMs could be downloaded and installed. However, from a forensic analysis point
    of view, the main reason for rooting is to gain access to those parts of the system
    that are normally not accessible. Most of the public root tools will result in
    a permanent root, where the changes persist even after rebooting the device. In
    the case of a temporary root, the changes are lost once the device reboots. Temporary
    roots should always be preferred in forensic cases.
  prefs: []
  type: TYPE_NORMAL
- en: As explained in [Chapter 1](part0014.xhtml "Chapter 1. Introducing Android Forensics"),
    *Introducing Android Forensics*, in Linux systems, each user is assigned a **unique
    user ID** (**UID**), and users are segregated so that one user does not access
    the data of another user. Similarly, in Android, each application is assigned
    a UID and is run as a separate process. App UIDs are assigned usually in the order
    they are installed, starting from 10001\. These IDs are stored in the `packages.xml`
    file in `/data/system`. This file, in addition to storing UIDs, stores the Android
    permissions of each program as described in its manifest file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The private data of each application is stored in the `/data/data` location
    and is accessible only to that application. Hence, during the course of investigation,
    the data present at this location cannot be accessed. However, rooting a phone
    will allow you to access the data present in any location. It is important to
    keep in mind that rooting a phone has several implications, as described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security risk**: Rooting a phone might expose the device to security risks.
    For instance, imagine a malicious app that has access to the entire operating
    system and to the data of all the other apps installed on the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bricking of your device**: If rooting is not done in a proper manner, it
    might result in the bricking of your device. "Bricking" is a word commonly used
    with phones that are dead or cannot be turned on in any way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Voiding your warranty**: Depending on the manufacturer and carrier, rooting
    a device may void your warranty, since it exposes the device to several threats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forensic implications**: Rooting an Android device will allow an investigator
    to access a larger set of data, but it involves the alteration of certain portions
    of the device. Hence, the device should be rooted only when it is absolutely necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recovery and fastboot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before dealing with the process of rooting, it is necessary to understand boot
    loader, recovery, and fastboot modes in Android. The following sections explain
    these in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Recovery mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An Android phone can be seen as a device having three main partitions: boot
    loader, Android ROM, and recovery. The boot loader is present in the first partition
    and is the first program that runs when the phone is powered on. The primary job
    of this boot loader is to take care of low-level hardware initialization and boot
    the device into other partitions. It usually loads the Android partition, commonly
    referred to as Android ROM, by default. Android ROM contains all the operating
    system files that are necessary to run the device. The recovery partition, commonly
    referred to as stock recovery, is the one that is used to delete all user data
    and files or to perform system updates.'
  prefs: []
  type: TYPE_NORMAL
- en: Both of these operations can be started from the running Android system or by
    manually booting into the recovery mode. For example, when you do a factory reset
    on your phone, recovery boots up and erases the files and data. Likewise, with
    updates, the phone boots into the recovery mode to install the latest updates
    that are written directly to the Android ROM partition. Hence, the recovery mode
    is the screen that you see when you install any official update on the device.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the recovery mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The recovery image is stored on the recovery partition, and it consists of
    a Linux image with a simple user interface controlled by hardware buttons. The
    recovery mode can be accessed in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: By pressing certain combinations of keys when booting the device (usually, by
    holding volume +, volume -, and power buttons during the bootup)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By issuing the adb reboot recovery command to a booted Android system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the screenshot of the stock recovery mode on an Android device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing the recovery mode](img/image00278.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Android stock recovery
  prefs: []
  type: TYPE_NORMAL
- en: The stock Android recovery is intentionally very limited in functionality. It
    has the options to reboot the system, apply updates from adb and SD card, factory
    reset, and so on. However, custom recovery offers many more options.
  prefs: []
  type: TYPE_NORMAL
- en: Custom recovery
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Custom recovery is a third-party recovery environment. Flashing this recovery
    environment onto your device replaces the default stock recovery environment with
    a third-party, customized recovery environment. These are the most common features
    that are included in custom recovery:'
  prefs: []
  type: TYPE_NORMAL
- en: Full backup and restore functionality (such as NANDroid)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow unsigned update packages or allow signed packages with custom keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selectively mounts device partitions and SD card
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide USB mass storage access to SD card or data partitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide full ADB access, with the ADB daemon running as root
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fully featured BusyBox binary (Busybox is a collection of powerful command-line
    tools in a single binary executable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several custom recovery images available in the market today, such
    as ClockworkMod Recovery, TeamWin Recovery Project, and so on. The following screenshot
    shows the options available with ClockworkMod Recovery v6.0.2.5:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Custom recovery](img/image00279.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: ClockworkMod Recovery
  prefs: []
  type: TYPE_NORMAL
- en: Fastboot mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fastboot is a protocol that can be used to reflash partitions on your device.
    It is one of the tools that comes along with the Android SDK. It is an alternative
    to the recovery mode to do installations and updates and also to unlock the boot
    loader in some cases. While in fastboot, you can modify the filesystem images
    from a computer over a USB connection. Hence, it is one of the ways to install
    the recovery images and just boot in some cases. Once the phone is booted into
    fastboot, you can flash image files in the internal memory. For example, the custom
    recovery images, such as ClockworkMod recovery, discussed earlier can be flashed
    in this manner. One of the easiest ways to flash the ClockworkMod recovery is
    through the ROM Manager app. Once this app is installed on a rooted Android device,
    as shown in the following screenshot, the app provides a **Flash ClockworkMod
    Recovery** option to install the recovery:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fastboot mode](img/image00280.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Flashing ClockworkMod Recovery from the ROM Manager app
  prefs: []
  type: TYPE_NORMAL
- en: Locked and unlocked boot loaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Boot loaders may be locked or unlocked. Locked boot loaders do not allow you
    to perform modifications to the device's firmware by implementing restrictions
    at the boot loader level. This is usually done through cryptographic signature
    verification. Hence, unsigned code cannot be flashed to the device. In other words,
    in order to run any recovery image or your own operating system, the boot loader
    needs to be unlocked first. Unlocking the boot loader could result in serious
    security implications.
  prefs: []
  type: TYPE_NORMAL
- en: If the device is lost or stolen, all data on it can be recovered by an attacker
    simply by uploading a custom Android boot image or flashing a custom recovery
    image. Thus, the attacker has full access to the data contained on the device.
    As a result of this, a factory data reset is performed on the phone when unlocking
    a locked boot loader so that all the data is erased. Hence, it is important to
    perform this only when it is absolutely necessary. Some devices have ways to unlock
    them officially. For these devices, boot loader can be unlocked by putting the
    device into the fastboot mode and running the `fastboot oem unlock` command. This
    will unlock the boot loader and do a complete wipe of the Android device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other manufacturers provide unlocking through different means, for instance,
    through their websites and so on. The following screenshot shows the HTC website
    providing support to unlock HTC devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Locked and unlocked boot loaders](img/image00281.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The HTC website providing support to unlock boot loader
  prefs: []
  type: TYPE_NORMAL
- en: How to root
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section talks about how to deal with both a locked and an unlocked boot
    loader. Gaining root access on a device with an unlocked boot loader is very easy,
    while gaining root access on a device with a locked boot loader is not so straightforward.
    The following sections explain this in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Rooting an unlocked boot loader
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Unix-like systems, superuser is a special user account used for system administration
    and has privileges to access and modify all the files in an operating system.
    The process of rooting mainly involves copying the **superuser** (**su**) binary
    to a location in the current process''s path (`/system/xbin/su`) and granting
    it executable permissions with the `chmod` command. Hence, the first step here
    is to unlock the boot loader. As explained in the *Locked and unlocked boot loaders*
    section, depending on the device in question, unlocking a boot loader can be done
    either through the fastboot mode or through following vendor-specific boot loader
    unlock procedure. The su binary is usually accompanied by an Android application,
    such as Superuser, that provides a graphical prompt each time an application requests
    root access, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rooting an unlocked boot loader](img/image00282.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Superuser request
  prefs: []
  type: TYPE_NORMAL
- en: Once the boot loader is unlocked, you can make all the desired changes to the
    device. Hence, copying the su binary and granting it executable permissions can
    be done in many ways. The most common method is to boot a custom recovery image.
    This allows us to copy the su binary into the system partition and set the appropriate
    permissions through a custom update package.
  prefs: []
  type: TYPE_NORMAL
- en: 'On an unlocked boot loader device, follow these steps to root the device:'
  prefs: []
  type: TYPE_NORMAL
- en: Download custom recovery image from [http://www.clockworkmod.com/rommanager](http://www.clockworkmod.com/rommanager)
    and su update package from [http://superuserdownload.com/](http://superuserdownload.com/).
    The custom recovery image can be anything as long as it supports your device.
    Similarly, the su update package can be SuperSU, SuperUser, or any other package
    of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy both custom recovery image and the su update package to the SD card of
    the Android device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, put the device into fastboot mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the command prompt, and enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, `recovery.img` is the recovery image you downloaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `recovery` menu, select the `To apply an update zip file` option and
    browse to the location on your device where the su binary update package is present.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since Android 4.1 version, a new feature called the sideload mode has been introduced.
    This feature allows us to apply an update zip over ADB without copying it to the
    device beforehand. To sideload an update, run the `adb sideload su-package.zip`
    command, where `su-package.zip` is the filename of the update package on your
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: Alternately, you can also modify a factory image to add a su binary. This can
    be done by unpacking an ext4 formatted system image, adding a su binary, and repacking
    it. If this image is flashed, it will contain the su binary, and the device will
    be rooted.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rooting is a highly device-specific process. Hence, a forensic investigator
    needs to be cautious before applying these techniques on any Android device.
  prefs: []
  type: TYPE_NORMAL
- en: Rooting a locked boot loader
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the boot loader is locked and cannot be unlocked through any available
    means, rooting the device requires us to find a security flaw that can be exploited.
    However, before that, it is important to identify the type of boot loader lock.
    It can vary depending on the manufacturer and the software version. With some
    mobiles, fastboot access may not be allowed, but you can still flash using the
    manufacturer's proprietary flashing protocol, such as Samsung ODIN. Some devices
    enforce signature verification on selected partitions only, such as boot and recovery.
    Hence, it may not be possible to boot into custom recovery. However, you can still
    modify the factory image to include the su binary, as explained in the preceding
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the boot loader cannot be unlocked through any means, then the only option
    is to find some vulnerability on the device that allows us to exploit and add
    the su binary. The vulnerability can be in an Android kernel, in a process running
    as root, or any other issue. It is device specific and needs to be researched
    extensively before trying it on any device. Here are some of the common exploits
    used in rooting an Android device:'
  prefs: []
  type: TYPE_NORMAL
- en: psneuter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: asroot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GingerBreak
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RageAgainstTheCage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volez
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Levitator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: zergRush
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mempodroid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Razr blade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ADB on a rooted device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen how the ADB tool can be used to interact with the device
    and execute certain commands on the device. However, on a normal Android phone,
    certain locations, such as `/data/data`, cannot be accessed. For example, the
    following the command-line output appears when you try to access `/data/data`
    on a normal device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because the private data of all the applications is stored in this
    folder. Thus, the security is enforced by Android. Only the root user has access
    to this location. Hence, on a rooted device, you will be able to see all the data
    under this location, as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding commands, the private data of all the applications
    can now be seen easily by navigating to the respective folders. Hence, the ADB
    tool on a rooted device is very powerful and allows an examiner to access all
    the data of applications installed on the device. This is possible provided the
    device is not pattern or PIN protected or registered to the machine with an RSA
    key.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, even on a rooted phone, you will see the permission-denied message.
    In such cases, after executing the adb shell command, try entering the superuser
    mode by typing `su`. If root is enabled, you will see `#` without asking for password.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up a proper forensic environment is crucial prior to conducting investigation
    on an Android device. The Android SDK installation is necessary to use tools such
    as ADB that come along with it. Using ADB, an examiner can communicate with the
    device, view folders on the device, and pull data and copy data to the device.
    However, not all folders can be accessed on a normal phone in this manner. This
    is because the device's security enforcements prevent an examiner from viewing
    the locations that contain private data. Rooting a device solves this issue, as
    it provides unlimited access to all the data present on the device. Rooting a
    device with an unlocked boot loader is straightforward, while rooting a device
    with a locked boot loader involves exploiting some security bug.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge about accessing the device, you will now learn how data
    is organized on an Android device and many other details in [Chapter 3](part0026.xhtml
    "Chapter 3. Understanding Data Storage on Android Devices"), *Understanding Data
    Storage on Android Devices*.
  prefs: []
  type: TYPE_NORMAL
