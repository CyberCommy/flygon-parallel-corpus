- en: Component Properties, State, and Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React components rely on JSX syntax, which is used to describe the structure
    of the UI. JSX will only get you so far—you need data to fill in the structure
    of your React components. The focus of this chapter is component data, which comes
    in two main varieties: *properties* and *state*. Another option for passing data
    to components is via a context.'
  prefs: []
  type: TYPE_NORMAL
- en: I'll start things off by defining what is meant by properties and state. Then,
    I'll walk through some examples that show you the mechanics of setting component
    state, and passing component properties. Toward the end of this chapter, we'll
    build on your new-found knowledge of props and state and introduce functional
    components and the container pattern. Finally, you'll learn about context and
    when it makes a better choice than properties for passing data to components.
  prefs: []
  type: TYPE_NORMAL
- en: What is component state?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React components declare the structure of UI elements using JSX. But, components
    need data if they are to be useful. For example, your component JSX might declare
    a `<ul>` that maps a JavaScript collection to `<li>` elements. Where does this
    collection come from?
  prefs: []
  type: TYPE_NORMAL
- en: '**State** is the dynamic part of a React component. You can declare the initial
    state of a component, which changes over time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you''re rendering a component where a piece of its state is initialized
    to an empty array. Later on, this array is populated with data. This is called
    a **change in state**, and whenever you tell a React component to change its state,
    the component will automatically re-render itself. The process is visualized here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/710f0e3c-dd8c-4453-b746-81925f964f61.png)'
  prefs: []
  type: TYPE_IMG
- en: The state of a component is something that either the component itself can set,
    or other pieces of code, outside of the component. Now we'll look at component
    properties and how they differ from component state.
  prefs: []
  type: TYPE_NORMAL
- en: What are component properties?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Properties** are used to pass data into your React components. Instead of
    calling a method with new state as the argument, properties are passed only when
    the component is rendered. That is, you pass property values to JSX elements.'
  prefs: []
  type: TYPE_NORMAL
- en: In the context of JSX, properties are called **attributes**, probably because
    that's what they're called in XML parlance. In this book, properties and attributes
    are synonymous with one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties are different than state because they don''t change after the initial
    render of the component. If a property value has changed, and you want to re-render
    the component, then we have to re-render the JSX that was used to render it in
    the first place. The React internals take care of making sure this is done efficiently.
    Here''s a diagram of rendering and re-rendering a component using properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b6424cc1-3cd8-4039-b8df-3ff501aa0ce9.png)'
  prefs: []
  type: TYPE_IMG
- en: This looks a lot different than a stateful component. The real difference is
    that with properties, it's often a parent component that decides when to render
    the JSX. The component doesn't actually know how to re-render itself. As you'll
    see throughout this book, this type of top-down flow is easier to predict than
    state that changes all over the place.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make sense of these two concepts by writing some code.
  prefs: []
  type: TYPE_NORMAL
- en: Setting component state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you're going to write some React code that sets the state of
    components. First, you'll learn about the initial state—this is, the default state
    of a component. Next, you'll learn how to change the state of a component, causing
    it to re-render itself. Finally, you'll see how a new state is merged with an existing
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Initial component state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The initial state of a component isn't actually required, but if your component
    uses state, it should be set. This is because if the component expects certain
    state properties to be there and they aren't, then the component will either fail
    or render something unexpected. Thankfully, it's easy to set the initial component
    state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial state of a component should always be an object with one or more
    properties. For example, you might have a component that uses a single array as
    its state. This is fine, but just make sure that you set the initial array as
    a property of the state object. Don''t use an array as the state. The reason for
    this is simple: consistency. Every React component uses a plain object as its
    state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s turn our attention to some code now. Here''s a component that sets an
    initial state object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the JSX that''s returned by `render()`, you can actually see
    the state values that this component depends on—`first` and `second`. Since you''ve
    set these properties up in the initial state, you''re safe to render the component,
    and there won''t be any surprises. For example, you could render this component
    only once, and it would render as expected, thanks to the initial state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the rendered output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f6cbbd99-c074-4366-b7da-d285cdc4722c.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting the initial state isn't very exciting, but it's important nonetheless.
    Let's make the component re-render itself when the state is changed.
  prefs: []
  type: TYPE_NORMAL
- en: Setting component state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a component that has some initial state. You''ll then render
    this component, and update its state. This means that the component will be rendered
    twice. Let''s take a look at the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The JSX of this component depends on two state values—`heading` and `content`.
    The component also sets the initial values of these two state values, which means
    that it can be rendered without any unexpected gotchas. Now, let''s look at some
    code that renders the component, and then re-renders it by changing the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The component is first rendered with its default state. However, the interesting
    spot in this code is the `setTimeout()` call. After 3 seconds, it uses `setState()`
    to change the two state property values. Sure enough, this change is reflected
    in the UI. Here''s what the initial state looks like when rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/42c4bd4e-78b1-424d-a47e-09eb21bcefcd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s what the rendered output looks like after the state change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/acde8faf-2d3e-44d7-b06f-66c69d96140b.png)This example highlights
    the power of having declarative JSX syntax to describe the structure of the UI
    component. You declare it once, and update the state of the component over time
    to reflect changes in the application as they happen. All the DOM interactions
    are optimized and hidden from view.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you replaced the entire component state. That is, the call
    to `setState()` passed in the same object properties found in the initial state.
    But, what if you only want to update part of the component state?
  prefs: []
  type: TYPE_NORMAL
- en: Merging component state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you set the state of a React component, you''re actually merging the state
    of the component with the object that you pass to `setState()`. This is useful
    because it means that you can set part of the component state while leaving the
    rest of the state as it is. Let''s look at an example now. First, a component
    with some state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This component renders the keys and values of its state—except for `doneMessage`.
    Each value defaults to `loading...`. Let''s write some code that sets the state
    of each state property individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The takeaway from this example is that you can set individual state properties
    on components. It will efficiently re-render itself. Here''s what the rendered
    output looks like for the initial component state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c2f5e541-d867-419e-8a75-ab4f73b099ee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s what the output looks like after two of the `setTimeout()` callbacks
    have run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b0582be3-d3d4-4649-8254-69312bbd8f98.png)'
  prefs: []
  type: TYPE_IMG
- en: The fourth call to `setState()` looks different from the first three. Instead
    of passing a new object to merge into the existing state, you can pass a function.
    This function takes a state argument—the current state of the component. This
    is useful when you need to base state changes on current state values. In this
    example, the `doneMessage` value is used to set the value of `fourth`. The function
    then returns the new state of the component. It's up to you to merge existing
    state values into the new state. You can use the spread operator to do this (`...state`).
  prefs: []
  type: TYPE_NORMAL
- en: Passing property values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Properties are like state data that gets passed into components. However, properties
    are different from state in that they're only set once, when the component is
    rendered. In this section, you'll learn about *default property values*. Then,
    we'll look at *setting property values*. After this section, you should be able
    to grasp the differences between component state and properties.
  prefs: []
  type: TYPE_NORMAL
- en: Default property values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Default property values work a little differently than default state values.
    They''re set as a class attribute called `defaultProps`. Let''s take a look at
    a component that declares default property values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Why not just set the default property values as an instance property, like you
    would with default state? The reason is that *properties are immutable*, and there's
    no need for them to be kept as an instance property value. State, on the other
    hand, changes all the time, so the component needs an instance level reference
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that this component sets default property values for `disabled`
    and `text`. These values are only used if they''re not passed in through the JSX
    markup used to render the component. Let''s go ahead and render this component
    without any properties, to make sure that the `defaultProps` values are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The same principle of always having default state applies with properties. You
    want to be able to render components without having to know in advance what the
    dynamic values of the component are.
  prefs: []
  type: TYPE_NORMAL
- en: Setting property values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s create a couple of components that expect different types of
    property values:'
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 7, *Validating Component Properties*, I'll go into more detail on
    validating the property values that are passed to components.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple button component expects a boolean `disabled` property and a string `text`
    property. Let''s create one more component that expects an array property value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can pass just about anything you want as a property value via JSX, just
    as long as it''s a valid JavaScript expression. Now let''s write some code to
    set these property values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `render()` function looks like it's creating new React component instances
    every time it's called. React is smart enough to figure out that these components
    already exist, and that it only needs to figure out what the difference in output
    will be with the new property values.
  prefs: []
  type: TYPE_NORMAL
- en: Another takeaway from this example is that you have an `appState` object that
    holds onto the state of the application. Pieces of this state are then passed
    into components as properties, when the components are rendered. State has to
    live somewhere, and in this case, it's outside of the component. I'll build on
    this topic in the next section, when you will learn how to implement stateless
    functional components.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The components you've seen so far in this book have been classes that extend
    the base `Component` class. It's time to learn about **functional components**
    in React. In this section, you'll learn what a functional component is by implementing
    one. Then, you'll learn how to set default property values for stateless functional
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functional components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A functional React component is just what it sounds like—a function. Picture
    the `render()` method of any React component that you've seen. This method, in
    essence, is the component. The job of a functional React component is to return
    JSX, just like a class-based React component. The difference is that this is all
    a functional component can do. It has no state and no lifecycle methods.
  prefs: []
  type: TYPE_NORMAL
- en: Why would you want to use functional components? It's a matter of simplicity
    more than anything else. If your component renders some JSX and does nothing else,
    then why bother with a class when a function is simpler?
  prefs: []
  type: TYPE_NORMAL
- en: A **pure function** is a function without side effects. That is to say, called
    with a given set of arguments, the function always produces the same output. This
    is relevant for React components because, given a set of properties, it's easier
    to predict what the rendered content will be. Functions that always return the
    same value with a given argument values are easier to test as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a functional component now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Concise, isn''t it? This function returns a `<button>` element, using the properties
    passed in as arguments (instead of accessing them through `this.props`). This
    function is pure because the same content is rendered if the same `disabled` and
    `text` property values are passed. Now, let''s see how to render this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There's zero difference between class-based and function-based React components,
    from a JSX point of view. The JSX looks exactly the same whether the component
    was declared using class or function syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The convention is to use arrow function syntax to declare functional React components.
    However, it's perfectly valid to declare them using traditional JavaScript function
    syntax, if that's better suited to your style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the rendered HTML looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ce97845e-5e19-4a46-953d-82a3e96c2e96.png)'
  prefs: []
  type: TYPE_IMG
- en: Defaults in functional components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functional components are lightweight; they don''t have any state or lifecycle.
    They do, however, support some **metadata** options. For example, you can specify
    the default property values of functional components the same way you would with
    a class component. Here''s an example of what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `defaultProps` property is defined on a function instead of a class. When
    React encounters a functional component with this property, it knows to pass in
    the defaults if they're not provided via JSX.
  prefs: []
  type: TYPE_NORMAL
- en: Container components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you're going to learn the concept of **container components**.
    This is a common React pattern, and it brings together many of the concepts that
    you've learned about state and properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic premise of container components is simple: don''t couple data fetching
    with the component that renders the data. The container is responsible for fetching
    the data and passing it to its child component. It contains the component responsible
    for rendering the data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is that you should be able to achieve some level of **substitutability**
    with this pattern. For example, a container could substitute its child component.
    Or, a child component could be used in a different container. Let''s see the container
    pattern in action, starting with the container itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The job of this component is to fetch data and to set its state. Any time the
    state is set, `render()` is called. This is where the *child component* comes
    in. The state of the container is passed to the child as properties. Let''s take
    a look at the `MyList` component next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`MyList` is a functional component that expects an `items` property. Let''s
    see how the container component is actually used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Container component design will be covered in more depth in [Chapter 5](1e488811-5fba-4e61-a5b7-7b0a1da4ec0b.xhtml),
    *Crafting Reusable Components*. The idea of this example was to give you a feel
    for the interplay between state and properties in React components.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you load the page, you''ll see the following content rendered after the
    3 seconds it takes to simulate an HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/26ac6029-21c3-4f11-9b88-6725adf88629.png)'
  prefs: []
  type: TYPE_IMG
- en: Providing and consuming context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As your React application grows, it will use more components. Not only will
    it have more components, but the structure of your application will change so
    that components are nested more deeply. The components that are nested at the
    deepest level still need to have data passed to them. Passing data from a parent
    component to a child component isn't a big deal. The challenge is when you have
    to start using components as indirection for passing data around your app.
  prefs: []
  type: TYPE_NORMAL
- en: For data that needs to make its way to any component in your app, you can create
    and use a context. There are two key concepts to remember when using contexts
    in React—providers and consumers. A **context provider** creates data and makes
    sure that it's available to any React components. A **context consumer** is a
    component that uses this data within the context.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering whether or not context is just another way of saying
    global data in a React application. Essentially, this is exactly what contexts
    are used for. Using the React approach to wrapping components with a context works
    better than creating global data because you have better control of how your data
    flows down through your components. For example, you can have nested contexts
    and a number of other advanced use cases. But for now, let's just focus on simple
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that you have some application data that determines permissions for
    given application features. This data could be fetched from an API or it could
    be hardcoded. In either case, the requirement is that you don't want to have to
    pass all of this permission data through the component tree. It would be nice
    if the permission data were just there, for any component that needs it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting at the very top of the component tree, let''s look at `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<App>` component is the child of the `<PermissionProvider>` component.
    This means that the permission context has been provided to the `<App>` component
    and any of its children, all the way down the tree. Let''s take a look at the
    `PermissionContext.js` module where the permission context is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `createContext()` function is used to create the actual context. The return
    value is an object containing two components—`Provider` and `Consumer`. Next,
    there's a simple abstraction for the permission provider that's to be used all
    throughout the app. The state contains the actual data that components might want
    to use. In this example, if the value is true, the feature should be displayed
    as normal. If it's false, then the feature doesn't have permission to render.
    Here, the state is only set once, but since this is a regular React component,
    you could set the state the same way you would set the state on any other component.
    The value that's rendered is the `<Provider>` component. This provides any children
    with context data, set via the `value` property.
  prefs: []
  type: TYPE_NORMAL
- en: Next, there's a small abstraction for permission consumers. Instead of having
    every component that needs to test for permissions implement the same logic over
    and over, the `PermissionConsumer` component can do it. The child of the `<Consumer>`
    component is always a function that takes the context data as an argument. In
    this example, the `PermissionConsumer` component has a `name` prop, for the name
    of the feature. This is compared with the value from the context and if it's false,
    nothing is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This component renders three components that are features and each need to check
    for permissions. Without the context functionality of React, you would have to
    pass this data as properties to each of these components through this component.
    If `<First>` had children or grandchildren that needed to check permissions, the
    same property-passing mechanism can get quite messy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the `<First>` component (the `<Second>` and `<Third>`
    are almost exactly the same):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where the `PermissionConsumer` component is put to use. You just need
    to supply it with a `name` property, and the child component is the component
    that is rendered if the permission check passes. The `<PermissionConsumer>` component
    can be used anywhere, and there''s no need to pass data in order to use it. Here''s
    what the rendered output of these three components looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e83d35dc-0f8a-4cd7-af4f-8b26ba753c59.png)'
  prefs: []
  type: TYPE_IMG
- en: The second component isn't rendered because its permission in the `PermissionProvider`
    component is set to false.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about state and properties in React components.
    You started off by defining and comparing the two concepts. Then, you implemented
    several React components and manipulated their state. Next, you learned about
    properties by implementing code that passed property values from JSX to the component.
    Next, you were introduced to the concept of a container component, used to decouple
    data fetching from rendering content. Finally, you learned about the new context
    API in React 16 and how to use it to avoid introducing indirection in your components.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn about handling user events in React components.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why is it always a good idea to initialize the state of a component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because if you don't, React will throw an error when you try to render.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because React won't know what types you have in your component state and won't
    be able to optimize rendering.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because if the `render()` method expects state values, you need to make sure
    they're always there to avoid unexpected rendering behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use properties instead of state?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: State should only be used for values that can change. For everything else, properties
    should be used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should avoid state wherever possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should only use properties to update existing state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a context in React?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Context is how you pass event handler functions to different components in your
    app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Context is used to avoid transient properties. Contexts are used to share common
    data with a select number of components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Context is like state that's shared between components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Visit following links for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://reactjs.org/docs/react-component.html#instance-properties-1](https://reactjs.org/docs/react-component.html#instance-properties-1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://reactjs.org/docs/react-without-es6.html#setting-the-initial-state](https://reactjs.org/docs/react-without-es6.html#setting-the-initial-state)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://reactjs.org/docs/context.html](https://reactjs.org/docs/context.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
