- en: Working with Middleware and RPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at middleware functionality. What is middleware,
    and how can we build it from scratch? Next, we will move to a better middleware
    solution written for us, called Gorilla Handlers. We will then try to understand
    a few use cases where middleware can be helpful. After that, we will start building
    our RPC services with Go's internal RPC and JSON RPC. Then we will move to an
    advanced RPC framework, such Gorilla HTTP RPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we cover in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: What is middleware?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is an RPC (Remote Procedure Call)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we implement RPC and JSON RPC in Go?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code for this chapter is available at [https://github.com/narenaryan/gorestful/tree/master/chapter3](https://github.com/narenaryan/gorestful/tree/master/chapter3).
    Please refer to Chapter 1, *Getting Started with the REST API Development*, for
    setting up Go projects and running the programs. It is better to clone the entire
    `gorestful` repository from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: What is middleware?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Middleware is an entity that hooks into a server''s request/response processing.
    The middleware can be defined in many components. Each component has a specific
    function to perform. Whenever we define the handlers for our URL patterns (as
    in the last chapter), the request hits the handler and executes the business logic.
    So virtually all middleware should perform these functions in order:'
  prefs: []
  type: TYPE_NORMAL
- en: Process the request before hitting the handler (function)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Process the handler function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Process the response before giving it to the client
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can see the previous points in the form of a visual illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50edf7ee-41ae-4e5e-8f94-558c488e93f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we observe the diagram carefully, the journey of the request starts with
    the client. In an application with no middleware, a request reaches the API server
    and will get handled by some function handler. The response is immediately sent
    back from the server and the client receives it. But in applications with middleware,
    it passes through a set of stages, like logging, authentication, session validation,
    and so on, and then proceeds to the business logic. This is to filter the wrong
    requests from interacting with the business logic. The most common use cases are:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a logger to log each and every request hitting the REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validate the session of the user and keep the communication alive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticate the user, if not identified
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write custom logic to scrap the request data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attach properties to responses while serving the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the help of middleware, we can keep the housekeeping work, like authentication,
    in its proper place. Let us create a basic middleware and tamper an HTTP request
    in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware functions should be defined when a piece of code needs to be executed
    for every request or subset of HTTP requests. Without them, we need to duplicate
    the logic in each and every handler.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building middleware is simple and straightforward. Let us build a program based
    on the knowledge gained from the second chapter. If you are not familiar with
    closure functions, a closure function returns another function. This principle
    helps us write middleware. The first thing we should do is implement a function
    that satisfies the http.Handler interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample closure called `closure.go` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Numbers will be generated and printed using tab spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are creating a closure function called generator and calling it to get a
    new number. A generator pattern generates a new item each time, based on given
    conditions. The inner function getting returned is an anonymous function with
    no arguments and one return type of integer. The variable `i` that is defined
    inside the outer function is available to the anonymous function, making it useful
    to compute logic in the future. The other good example application of closure
    is creating a counter. You can implement it by following the same logic applied
    in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: In Go, the function signature of the outer function should exactly match the
    anonymous function's signature. In the previous example, `func() int` is the signature
    for both the outer and inner functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example is given to understand how closure works in Go. Now, let us use
    this concept to compose our first middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do a CURL request or see `http://localhost:8000` in your browser, the
    console will receive this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you observe the middleware illustration diagram provided before, the request
    phase is pointed to by the right arrow, and the response is the left one. This
    program is actually the one in the rightmost rectangle, that is, `CustomMiddleware`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In simple steps, the preceding program breaks down into this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a handler function by passing the main handler function (`mainLogic`)
    to `http.HandlerFunc()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a middleware function that accepts a handler and returns a handler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method `ServeHTTP` allows a handler to execute the handler logic that is mainLogic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `http.Handle` function expects an HTTP handler. By taking that into consideration,
    we wrapped up our logic in such a way that, finally, a handler gets returned,
    but the execution is modified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are passing the main handler into the middleware. Then middleware takes it
    and returns a function while embedding this main handler logic in it. This makes
    all the requests coming to the handler pass through the middleware logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of the print statement explains the request's journey.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we are serving the server on the `8000` port.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go web frameworks like Martini, Gin provide middleware by default. We will see
    more about them in upcoming chapters. It is good for a developer to understand
    the low-level details of middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram can help you understand how the logic flow happens in
    the middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4a887a7-9856-4aef-8414-9841ccb57e58.png)'
  prefs: []
  type: TYPE_IMG
- en: Multiple middleware and chaining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we built a single middleware to perform an action
    before or after the request hits the handler. It is also possible to chain a group
    of middleware. In order to do that, we should follow the same closure logic as
    the preceding section. Let us create a city API for saving city details. For simplicity''s
    sake, the API will have one POST method, and the body consists of two fields:
    city name and city area.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us think about a scenario where an API developer only allows the JSON media
    type from clients and also needs to send the server time in UTC back to the client
    for every request. Using middleware, we can do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions of two middleware are:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first middleware, check whether the content type is JSON. If not, don't
    allow the request to proceed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second middleware, add a timestamp called Server-Time (UTC) to the response
    cookie
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, let us create the `POST` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then give a CURL request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Go gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'CURL responses will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In order to chain, we need to pass the handler between multiple middlewares.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the program in simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a REST API with a POST as the allowed method. It is not complete
    because we are not storing data to a database or file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We imported the json package and used it to decode the POST body given by the
    client. Next, we created a structure that maps the JSON body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, JSON got decoded and printed the information to the console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Only one handler is involved in the preceding example. But now, for the upcoming
    task, the idea is to pass the main handler to multiple middleware handlers. The
    complete code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And run this for the CURL command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'But if we try to remove `Content-Type:application/json` from the CURL command,
    the middleware blocks us from executing the main handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: And the cookie will be set from the other middleware.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding program, we used log instead of the fmt package. Even though
    both do the same thing, log formats the output by attaching a timestamp of the
    log. It can also be easily directed to a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few interesting things in this program. The middleware functions
    we defined have quite common use cases. We can extend them to perform any action. The
    program is composed of many elements. If you read it function by function, the
    logic can be easily unwound. Take a look at the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: A struct called city was created to store city details, as in the last example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filterContentType` is the first middleware we added. It actually checks the
    content type of the request and allows or blocks the request from proceeding further.
    For checking, we are using `r.Header.GET` (content type). If it is application/json,
    we are allowing the request to call the `handler.ServeHTTP` function, which executes
    the `mainLogicHandler` code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setServerTimeCookie` is the second middleware that we designed to add a cookie
    to the response with a value of the server time. We are using Go''s time package
    to find the current UTC time in the Unix epoch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the cookie, we are setting `Name` and `Value`. The cookie also accepts another
    parameter called `Expire,` which tells the expiry time of the cookie.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the content type is not application/json, our application returns the 415-Media
    type not supported status code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the mainhandler, we are using `json.NewDecoder` to parse the JSON and fill
    them into the `city` struct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strconv.FormatInt` allows us to convert an `int64` number to a string. If
    it is a normal `int`, then we use `strconv.Itoa`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 201 is the correct status code to be returned when the operation is successful.
    For all other methods, we are returning 405, that is, a method not allowed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The form of chaining we did here is readable for two to three middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If an API server wishes a request to go through many middlewares, then how can
    we make that chaining simple and readable? There is a very good library called
    Alice to solve this problem. It allows you to semantically order and attach your
    middleware to the main handler. We will see it briefly in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Painless middleware chaining with Alice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Alice library reduces the complexity of chaining the middleware when the
    list of middleware is big. It provides us with a clean API to pass the handler
    to the middleware. In order to install it, use the go get command, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can import the Alice package in our program and use it straight away.
    We can modify the sections of the preceding program to bring the same functionality
    with improved chaining. In the import section, add `github.com/justinas/alice`,
    like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the main function, we can modify the handler part like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The complete code with these added changes is available as a file called `multipleMiddlewareWithAlice.go`
    in the `chapter 3` folder from the book's GitHub repository. With the knowledge
    of the preceding concepts, let us build a logging middleware with a library from
    the Gorilla toolkit called Handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Using Gorilla's Handlers middleware for Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Gorilla Handlers package provides various kinds of middleware for common
    tasks. The most important ones in the list are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LoggingHandler`: For logging in Apache Common Log Format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompressionHandler`: For zipping the responses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RecoveryHandler`: For recovering from unexpected panics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, we use the `LoggingHandler` to perform API-wide logging. First, install
    this library using go get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This logging server enables us to create a server like a log with time and
    option. For example, when you see `apache.log`, you find something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The format is `IP-Date-Method:Endpoint-ResponseStatus`. Writing our own such
    middleware will take some effort. But Gorilla Handlers already implements it for
    us. Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us open `http://127.0.0.1:8000` in the browser, or do a CURL, and
    you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you observe, the last two logs are generated by the middleware. Gorilla `LoggingMiddleware`
    writes them at response time.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we always checked the API on localhost. In this example,
    we explicitly specified replacing localhost with `127.0.0.1` because the former
    will show as an empty IP in the logs.
  prefs: []
  type: TYPE_NORMAL
- en: Coming to the program, we are importing the Gorilla Mux router and Gorilla handlers.
    Then we are attaching a handler called `mainLogic` to the router. Next, we are
    wrapping the router in the `handlers.LoggingHandler` middleware. It returns one
    more handler, which we can pass safely to http.ListenAndServe.
  prefs: []
  type: TYPE_NORMAL
- en: You can try other middleware from handlers, too. This section's motto is to
    introduce you to Gorilla Handlers. There are many other external packages available
    for Go. There is one library worth mentioning for writing middleware directly
    on net/http. It is Negroni ([github.com/urfave/negroni](http://github.com/urfave/negroni)).
    It also provides the functionality of Alice, the Gorilla LoggingHandler. So please
    have a look at it.
  prefs: []
  type: TYPE_NORMAL
- en: We can easily build cookie-based authentication middleware using a library called
    go.uuid ([github.com/satori/go.uuid](http://github.com/satori/go.uuid)) and cookies.
  prefs: []
  type: TYPE_NORMAL
- en: What is RPC?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remote Procedure Call (RPC) is an interprocess communication that exchanges
    information between various distributed systems. A computer called Alice can call
    functions (procedures) in another computer called Bob in protocol format and can
    get the computed result back. Without implementing the functionality locally,
    we can request things from a network that lies in another place or geographical
    region.
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire process can be broken down into the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Clients prepare function name and arguments to send
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clients send them to an RPC server by dialing the connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server receives the function name and arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server executes the remote process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The message will be sent back to the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client collects the data from the request and uses it appropriately
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The server needs to expose its service for the client to connect and request
    a remote procedure. Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b0c08f9-936a-43f9-b7a1-f5b4addef8c5.png)'
  prefs: []
  type: TYPE_IMG
- en: Go provides a library to implement both the RPC server and RPC client. In the
    preceding diagram, the RPC client dials the connection with the details like the
    host and port. It sends two things along with the request. One is arguments and
    the reply pointer. Since it is a pointer, the server can modify it and send it
    back. Then the client can use the data filled into the pointer. Go has two libraries, net/rpc,
    and net/rpc/jsonrpc, for working with RPC. Let us write an RPC server that talks
    to the client and serves the server time.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an RPC server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us create a simple RPC server that sends the UTC server time back to the
    RPC client. First, we start with the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The RPC server and RPC client should agree upon two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Arguments passed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Value returned
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The types for the preceding two parameters should exactly match for both server
    and client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We first create the Args struct. This holds information about arguments passed
    from the client (RPC) to the server. Then, we created a `TimeServer` number to
    register with the `rpc.Register`. Here, the server wishes to export an object
    of type `TimeServer(int64)`. `HandleHTTP` registers an HTTP handler for RPC messages
    to `DefaultServer`. Then we started a TCP server that listens on port 1234\. The
    `http.Serve` function is used to serve it as a running program. `GiveServerTime` is
    the function that will be called by the client, and the current server time is
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few points to note from the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GiveServerTime` takes the `Args` object as the first argument and a reply
    pointer object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It sets the reply pointer object but does not return anything except an error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Args` struct here has no fields because this server is not expecting the
    client to send any arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before running this program, let us write the RPC client, too. Both can be run
    simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an RPC client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, the client also uses the same net/rpc package but uses different methods
    to dial to the server and get the remote function executed. The only way to get
    data back is to pass the reply pointer object along with the request, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The client is performing the following things here:'
  prefs: []
  type: TYPE_NORMAL
- en: Do a `DialHTTP` to connect to the RPC server, which is running on the localhost
    on port `1234`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `Remote` function with the `Name:Function`format with `args` and reply
    with the pointer object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the data collected into the `reply` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **`Call` **function is sequential in nature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we can run both the server and client to see them in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This runs the server. Now open another shell tab and run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the server console will output the following UNIX time string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: See the magic? The client is running as an independent program. Here, both the
    programs can be on different machines and the computing can still be shared. This
    is the core concept of distributed systems. The tasks are divided and given to
    various RPC servers. Finally, the client collects the results and uses them for
    further actions.
  prefs: []
  type: TYPE_NORMAL
- en: Custom RPC code is only useful when the client and server are both written in
    Go. So in order to have the RPC server consumed by multiple services, we need
    to define the JSON RPC over HTTP. Then, any other programming language can send
    a JSON string and get JSON as a result.
  prefs: []
  type: TYPE_NORMAL
- en: RPC should be secured because it is executing the remote functions. Authorization
    is needed while collecting requests from the client.
  prefs: []
  type: TYPE_NORMAL
- en: JSON RPC using Gorilla RPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw that the Gorilla toolkit helps us by providing many useful libraries.
    Then we explored Mux, Handlers, and now, the Gorilla RPC library. Using this,
    we can create RPC servers and clients that talk using a JSON instead of a custom
    reply pointer. Let us convert the preceding example into a much more useful one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this scenario. We have a JSON file on the server that has details
    of books (name, ID, author). The client requests book information by making an
    HTTP request. When the RPC server receives the request, it reads the file from
    the filesystem and parses it. If the given ID matches any book, then the server
    sends the information back to the client in the JSON format. We can install Gorilla
    RPC with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This package derives from the standard `net/rpc` package but uses a single
    HTTP request per call instead of persistent connections. Other differences compared
    to `net/rpc`: are explained in the following sections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple codecs can be registered in the same server. A codec is chosen based
    on the `Content-Type` header from the request. Service methods also receive the `http.Request`
    as a parameter. This package can be used on Google App Engine. Now, let us write
    an RPC JSON server. Here we are implementing the JSON1.0 specification. For 2.0,
    you should use Gorilla JSON2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This program might look different from the preceding RPC server implementation.
    It is because of the inclusion of the Gorilla **`Mux`, **Gorilla `rpc`, and `jsonrpc`
    packages. Let us run the preceding program before explaining what is happening.
    Run the server with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now where it the client? Here the client can be a CURL command since the RPC
    server is serving requests over HTTP. We need to post JSON with a book ID to get
    the details. So fire up another shell and execute this CURL request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be nice JSON, that served directly from the JSON RPC server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, coming to the program, we have a lot to understand. The documentation for
    creating RPC services is very limited. So the technique we used in the program
    can be applied to a wide variety of use cases. First, we are creating the `Args`
    and `Book`structs to hold the information about the JSON arguments passed and
    the book structure, respectively. We are defining a remote function called `GiveBookDetail`
    on a resource called `JSONServer`. This struct is a service created to register
    with the **`RegisterService` **function of the RPC server. If you notice, we are
    also registering the codec as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we get a request from the client, we load the JSON file called **`books.json` **into
    memory and then into the `Book` struct using JSON's **`Unmarshal` **method. `jsonparse`
    is the alias given for the Go package **`encoding/json` **because the JSON package
    from the Gorilla import has the same name. In order to remove conflict, we used
    an alias.
  prefs: []
  type: TYPE_NORMAL
- en: The `reply` reference is passed to the remote function. In the remote function,
    we are setting the value of the reply with the matched book. If the ID sent by
    the client matches with any of the books in JSON, then the data is filled. If
    there is no match, then empty data will be sent back by the RPC server. In this
    way, one can create a JSON RPC to allow clients to be universal. Here, we didn't
    write a Go client. Any client can access data from the service.
  prefs: []
  type: TYPE_NORMAL
- en: Prefer JSON RPC when multiple client technologies need to connect to your RPC
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first looked into what middleware is, exactly, including
    how middleware processes a request and response. We then explored middleware code
    with a few practical examples. After that, we saw how to chain our middleware
    by passing one middleware to another. Then, we used a package called `Alice` for
    intuitive chaining. We also took a look at the Gorilla handlers middleware for
    logging. Next, we learned what an RPC is and how an RPC server and client can
    be built. After that, we explained what a JSON RPC is, and we saw how one can
    create a JSON RPC using Gorilla toolkit. We introduced many third-party packages
    for middleware and RPC, with examples.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to explore few famous web frameworks those
    further simplify the REST API creation. They have batteries included by possessing
    inbuilt middleware and HTTP routers.
  prefs: []
  type: TYPE_NORMAL
