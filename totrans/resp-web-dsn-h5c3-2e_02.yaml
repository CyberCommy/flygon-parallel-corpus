- en: Chapter 2. Media Queries – Supporting Differing Viewports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we had a brief look at the essential components for
    a responsive web page: a fluid layout, fluid images, and media queries.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will look in detail at media queries, hopefully providing all that's
    needed to fully understand their capability, syntax, and future development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn why media queries are needed for a responsive web design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the media query syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use media queries in `link` tags, with CSS `@import` statements
    and within CSS files themselves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand what device features we can test for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use media queries to facilitate visual changes dependent upon available screen
    space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider whether media queries should be grouped together or written as and
    where needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the `meta` viewport tag, to allow media queries to work as intended
    on iOS and Android devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider the capabilities being proposed for future media queries specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CSS3 specification is made up of a number of modules. Media Queries (Level
    3) are just one of these modules. Media queries allow us to target specific CSS
    styles depending upon the capabilities of a device. For example, with just a few
    lines of CSS we can change the way content is displayed, dependent upon things
    such as viewport width, screen aspect ratio, orientation (landscape or portrait),
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Media queries are widely implemented. Pretty much everything other than ancient
    versions of Internet Explorer (8 and below) support them. In short, there's absolutely
    no good reason not to be using them!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Specifications at the W3C go through a ratification process. If you have a spare
    day, knock yourself out with the official explanation of the process at [http://www.w3.org/2005/10/Process-20051014/tr](http://www.w3.org/2005/10/Process-20051014/tr).
    The simpler version is that specifications go from **Working Draft** (**WD**),
    to **Candidate Recommendation** (**CR**), to **Proposed Recommendation** (**PR**)
    before finally arriving, many years later, at W3C Recommendation (REC). Modules
    at a greater maturity level than others are generally safer to use. For example,
    CSS Transforms Module Level 3 ([http://www.w3.org/TR/css3-3d-transforms/](http://www.w3.org/TR/css3-3d-transforms/))
    has been at WD status since March 2009 and browser support for it is far poorer
    than CR modules such as media queries.
  prefs: []
  type: TYPE_NORMAL
- en: Why media queries are needed for a responsive web design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CSS3 media queries enable us to target particular CSS styles to particular
    device capabilities or situations. If you head over to the W3C specification of
    the CSS3 media query module ([http://www.w3.org/TR/css3-mediaqueries/](http://www.w3.org/TR/css3-mediaqueries/)),
    you''ll see that this is their official introduction to what media queries are
    all about:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"A media query consists of a media type and zero or more expressions that
    check for the conditions of particular media features. Among the media features
    that can be used in media queries are ''width'', ''height'', and ''color''. By
    using media queries, presentations can be tailored to a specific range of output
    devices without changing the content itself."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Without media queries we would be unable to substantially alter the visuals
    of a website using CSS alone. They facilitate us writing defensive CSS rules that
    pre-empt such eventualities as portrait screen orientation, small or large viewport
    dimensions, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Whilst a fluid layout can carry a design a substantial distance, given the gamut
    of screen sizes we hope to cover, there are times when we need to revise the layout
    more fully. Media queries make this possible. Think of them as basic conditional
    logic for CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Basic conditional logic in CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: True programming languages all have some facility in which one of two or more
    possible situations are catered for. This usually takes the form of conditional
    logic, typified by an `if/else` statement.
  prefs: []
  type: TYPE_NORMAL
- en: If programming vernacular makes your eyes itch, fear not; it's a very simple
    concept. You probably dictate conditional logic every time you ask a friend to
    order for you when visiting a cafe, "If they've got triple chocolate muffins I'll
    have one of those, if not, I'll have a slice of carrot cake". It's a simple conditional
    statement with two possible (and equally fine, in this case) results.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, CSS does not facilitate true conditional logic or programmatic
    features. Loops, functions, iteration, and complex math are still firmly in the
    domain of CSS processors (did I mention a fine book on the subject of the Sass
    pre-processor, called *Sass and Compass for Designers*?). However, media queries
    are one mechanism in CSS that allows us to author basic conditional logic. By
    using a media query the styles within are scoped depending upon whether certain
    conditions are met.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Programming features on their way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The popularity of CSS pre-processors has made the people working on CSS specifications
    take note. Right now there is a WD specification for CSS variables: [http://www.w3.org/TR/css-variables/](http://www.w3.org/TR/css-variables/)'
  prefs: []
  type: TYPE_NORMAL
- en: However, browser support is currently limited to Firefox so it's really not
    something to consider using in the wild at present.
  prefs: []
  type: TYPE_NORMAL
- en: Media query syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So what does a CSS media query look like and more importantly, how does it work?
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code at the bottom of any CSS file and preview the related
    web page. Alternatively, you can open `example_02-01`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, preview the file in a browser and resize the window. The background color
    of the page will vary depending upon the current viewport size. We'll cover how
    the syntax works in more detail shortly. First, it's important to know how and
    where you can use media queries.
  prefs: []
  type: TYPE_NORMAL
- en: Media queries in link tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Those that have been working with CSS since version 2 will know it''s possible
    to specify the type of device (for example, `screen` or `print`) applicable to
    a style sheet with the media attribute of the `<link>` tag. Consider this example
    (which you''d place in the `<head>` tags of your markup):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Media queries add the ability to target styles based upon the capability or
    features of a device, rather than merely the type of device. Think of it as a
    question to the browser. If the browser''s answer is "true", the enclosed styles
    are applied. If the answer is "false", they are not. Rather than just asking the
    browser "Are you a screen?"—as much as we could effectively ask with just CSS2—media
    queries ask a little more. Instead, a media query might ask, "Are you a screen
    and are you in portrait orientation?" Let''s look at that as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'First, the media query expression asks the type (are you a screen?), and then
    the feature (is your screen in portrait orientation?). The `portrait-screen.css`
    style sheet will be applied for any screen device with a portrait screen orientation
    and ignored for any others. It''s possible to reverse the logic of any media query
    expression by adding not to the beginning of the media query. For example, the
    following code would negate the result in our prior example, applying the file
    for anything that wasn''t a screen with a portrait orientation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Combining media queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's also possible to string multiple expressions together. For example, let's
    extend one of our prior examples and also limit the file to devices that have
    a viewport greater than 800 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Further still, we could have a list of media queries. If any of the listed
    queries are true, the file will be applied. If none are true, it won''t. Here
    is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There are two points to note here. Firstly, a comma separates each media query.
    Secondly, you'll notice that after projection, there is no trailing and/or feature/value
    combination in parentheses. That's because in the absence of these values, the
    media query is applied to all media types. In our example, the styles will apply
    to all projectors.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You should be aware that you can use any CSS length unit to specify media queries
    with. **Pixels** (**px**) are the most commonly used but **ems** (**em**) and
    **rems** (**rem**) are equally appropriate. For some further info on the merits
    of each, I wrote a little more on the subject here: [http://benfrain.com/just-use-pixels](http://benfrain.com/just-use-pixels)'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, if you want a break point at 800px (but specified in em units) simply
    divide the number of pixels by 16\. For example, 800px could also be specified
    as 50em (800 / 16 = 50).
  prefs: []
  type: TYPE_NORMAL
- en: Media queries with @import
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also use the `@import` feature of CSS to conditionally load style sheets
    into our existing style sheet. For example, the following code would import the
    style sheet called `phone.css`, providing the device was screen based and had
    a maximum viewport of 360 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Remember that using the `@import` feature of CSS, adds to HTTP requests (which
    impacts load speed) so use this method sparingly.
  prefs: []
  type: TYPE_NORMAL
- en: Media queries in CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have included them as links to CSS files that we would place within
    the `<head></head>` section of our HTML and as `@import` statements. However,
    it''s more likely we will want to use media queries within CSS style sheets themselves.
    For example, if we add the following code into a style sheet, it will make all
    `h1` elements green, providing the device has a screen width of 400 pixels or
    less:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First we specify we want a media query with the `@media` at-rule, then we specify
    the type we want to match. In the preceding example, we want to apply the rules
    enclosed only to screens (and not, for example, `print`). Then, inside parenthesis
    we enter the specifics of the query. Then like any CSS rule, we open the braces
    and write the required styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point it''s probably prudent of me to point out that in most situations,
    you don''t actually need to specify `screen`. Here''s the key point in the specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"A shorthand syntax is offered for media queries that apply to all media types;
    the keyword ''all'' can be left out (along with the trailing ''and''). I.e. if
    the media type is not explicitly given it is ''all''."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Therefore, unless you want to target styles to particular media types, just
    leave the `screen and` part out. That's the way we will be writing media queries
    in the example files from this point on.
  prefs: []
  type: TYPE_NORMAL
- en: What can media queries test for?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When building responsive designs, the media queries that get used most, usually
    relate to a device''s viewport width (`width`). In my own experience, I have found
    little need (with the occasional exception of resolution and viewport height)
    to employ the other capabilities. However, just in case the need arises, here
    is a list of all capabilities that Media Queries Level 3 can test for. Hopefully
    some will pique your interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`width`: The viewport width.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`height`: The viewport height.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`device-width`: The rendering surface''s width (for our purposes, this is typically
    the screen width of a device).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`device-height`: The rendering surface''s height (for our purposes, this is
    typically the screen height of a device).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`orientation`: This capability checks whether a device is portrait or landscape
    in orientation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aspect-ratio`: The ratio of width to height based upon the viewport width
    and height. A 16:9 widescreen display can be written as `aspect-ratio: 16/9`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`device-aspect-ratio`: This capability is similar to `aspect-ratio` but is
    based upon the width and height of the device rendering surface, rather than viewport.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color`: The number of bits per color component. For example, `min-color: 16`
    will check that the device has 16-bit color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color-index`: The number of entries in the color lookup table of the device.
    Values must be numbers and cannot be negative.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`monochrome`: This capability tests how many bits per pixel are in a monochrome
    frame buffer. The value would be a number (integer), for example, `monochrome:
    2`, and cannot be negative.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resolution`: This capability can be used to test screen or print resolution;
    for example, `min-resolution: 300dpi`. It can also accept measurements in dots
    per centimeter; for example, `min-resolution: 118dpcm`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scan`: This can be either progressive or interlace features largely particular
    to TVs. For example, a 720p HD TV (the p part of 720p indicates "progressive")
    could be targeted with `scan: progressive` while a 1080i HD TV (the i part of
    1080i indicates "interlaced") could be targeted with `scan: interlace`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grid`: This capability indicates whether or not the device is grid or bitmap
    based.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All the preceding features, with the exception of `scan` and `grid`, can be
    prefixed with `min` or `max` to create ranges. For example, consider the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, a minimum (`min`) and maximum (`max`) have been applied to width to set
    a range. The tiny.css file will only be imported for screen devices with a minimum
    viewport width of 200 pixels and a maximum viewport width of 360 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Features deprecated in CSS Media Queries Level 4**'
  prefs: []
  type: TYPE_NORMAL
- en: It's worth being aware that the draft specification for Media Queries Level
    4 deprecates the use of a few features ([http://dev.w3.org/csswg/mediaqueries-4/#mf-deprecated](http://dev.w3.org/csswg/mediaqueries-4/#mf-deprecated));
    most notably `device-height`, `device-width`, and `device-aspect-ratio`. Support
    for those queries will remain in browsers but it's recommended you refrain from
    writing any new style sheets that use them.
  prefs: []
  type: TYPE_NORMAL
- en: Using media queries to alter a design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By their very nature, styles further down a **cascading style sheet** (**CSS**
    file to you and me) override equivalent styles higher up (unless styles higher
    up are more specific). We can therefore set base styles at the beginning of a
    style sheet, applicable to all versions of our design (or at least providing our
    'base' experience), and then override relevant sections with media queries further
    on in the document. For example, we might choose to set navigation links as text
    alone in limited viewports (or perhaps just smaller text) and then overwrite those
    styles with a media query to give us both text and icons at larger viewports where
    more space is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at how this might look in practice (`example_02-02`). First
    the markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a screen grab of the links in a small viewport:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using media queries to alter a design](img/B03777_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And here''s a grab of them at a larger viewport:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using media queries to alter a design](img/B03777_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Any CSS can be wrapped in a media query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's important to remember that anything you would normally write in CSS can
    also be enclosed inside a media query. As such, it's possible to entirely change
    the layout and look of a site in different situations (usually for differing viewport
    sizes) with media queries.
  prefs: []
  type: TYPE_NORMAL
- en: Media queries for HiDPI devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another common use case for media queries is to change styles when the site
    is viewed on a high-resolution device. Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here our media query is specifying that we only want the enclosed styles to
    apply where the screen resolution is 2 dots per pixel unit (2dppx). This would
    apply to devices like the iPhone 4 (Apple's HiDPI devices are given the 'Retina'
    moniker) and a whole raft of Android devices. You could change that media query
    to apply to a wider range of devices by reducing the dppx value.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the broadest possible support, when writing min-resolution media queries,
    ensure you have a prefixing tool running to provide relevant vendor prefixes.
    Don't worry if the term vendor prefixes doesn't make much sense right now as we
    deal with the subject in more detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Considerations for organizing and authoring media queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will take a brief tangent at this point to consider some of the different
    approaches that authors can take when writing and organizing their media queries.
    Each approach offers some benefits and some tradeoffs so it's worth at least knowing
    about these factors, even if you decide they are largely irrelevant for your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Linking to different CSS files with media queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From a browser perspective, CSS is considered to be a 'render blocking' asset.
    The browser needs to fetch and parse a linked CSS file before rendering of the
    page can complete.
  prefs: []
  type: TYPE_NORMAL
- en: However, modern browsers are smart enough to discern which style sheets (linked
    with media queries in the head) need to be analyzed immediately and which can
    be deferred until after the initial page rendering.
  prefs: []
  type: TYPE_NORMAL
- en: For these browsers, CSS files linked to with non-applicable media queries (for
    example if the screen is too small for the media query to apply) can be 'deferred'
    until after the initial page load, providing some performance advantage.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s more on this topic over on Google''s developer pages: [https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css)'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, I would like to draw your attention to this part in particular:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"...note that "render blocking" only refers to whether the browser will have
    to hold the initial rendering of the page on that resource. In either case, the
    CSS asset is still downloaded by the browser, albeit with a lower priority for
    non-blocking resources."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To reiterate, all the linked files will still be downloaded, the browser just
    won't hold up rendering of the page if they don't immediately apply.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, a modern browser loading a responsive web page (take a look at `example_02-03`)
    with four different style sheets linked with different media queries (to apply
    different styles for different viewport ranges) will download all four CSS files
    but probably only parse the applicable one initially before rendering the page.
  prefs: []
  type: TYPE_NORMAL
- en: The practicalities of separating media queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although we have just learned that the process of splitting media queries potentially
    offers some benefit, there is not always a large tangible advantage (apart from
    personal preference and/or compartmentalization of code) in separating different
    media query styles into separate files.
  prefs: []
  type: TYPE_NORMAL
- en: After all, using separate files increases the number of HTTP requests needed
    to render a page, which in turn can make the pages slower in certain other situations.
    Nothing is ever easy on the Web! It's therefore really a question of evaluating
    the entire performance of your site and testing each scenario on different devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'My default stance on this is that, unless the project has considerable time
    available for performance optimizations, this is one of the last places I would
    look to make performance gains. Only once I am certain that:'
  prefs: []
  type: TYPE_NORMAL
- en: All images are compressed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All scripts are concatenated and minified
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All assets are being served gzipped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All static content is being cached via CDNs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All surplus CSS rules have been removed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perhaps then I would start looking to split up media queries into separate files
    for performance gains.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'gzip is a compression and decompression file format. Any good server should
    allow gzip for files such as CSS and this greatly decreases the size of the file
    as it travels from server to device (at which point it is decompressed to its
    native format). You can find a good summary of gzip on Wikipedia: [http://en.wikipedia.org/wiki/Gzip](http://en.wikipedia.org/wiki/Gzip)'
  prefs: []
  type: TYPE_NORMAL
- en: Nesting media queries 'inline'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In all but extreme circumstances, I recommend adding media queries within an
    existing style sheet alongside the 'normal' rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are happy to do the same, it leads to one further consideration: should
    media queries be declared underneath the associated selector? Or split off into
    a separate block of code at the end for all identical media queries? I''m glad
    you asked.'
  prefs: []
  type: TYPE_NORMAL
- en: Combine media queries or write them where it suits?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m a fan of writing media queries underneath the original ''normal'' definition.
    For example, let''s say I want to change the width of a couple of elements, at
    different places in the style sheet, depending upon the viewport width I would
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This seems like lunacy at first. We have two media queries that both relate
    to when the screen has a minimum width of 30rem. Surely repeating the same `@media`
    declaration is overly verbose and wasteful? Shouldn''t I be advocating grouping
    all the identical media queries into a single block like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That is certainly one way to do it. However, from a maintenance point of view
    I find this more difficult. There is no 'right' way to do this but my preference
    is to define a rule for an individual selector once and have any variations of
    that rule (such as changes within media queries) defined immediately after. That
    way I don't have to search for separate blocks of code to find the declaration
    that is relevant to a particular selector.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With CSS pre and post processors, this can be even more convenient as the media
    query 'variant' of a rule can be nested directly within the rule set. There's
    a whole section on that in my other book *Sass and Compass for Designers*.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would seem fair to argue against the former technique on the grounds of
    verbosity. Surely file size alone should be enough reason not to write media queries
    in this manner? After all, no one wants a big bloated CSS file to serve their
    users. However, the simple fact is that gzip compression (which should be compressing
    all the possible assets on your server) reduces the difference to a completely
    inconsequential amount. I''ve done various tests on this in the past so if it''s
    something you would like to read more about, head over to: [http://benfrain.com/inline-or-combined-media-queries-in-sass-fight/](http://benfrain.com/inline-or-combined-media-queries-in-sass-fight/).
    The bottom line is, I don''t believe you should concern yourself with file size
    if you would rather write media queries directly after the standard styles.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to author your media queries directly after the original rule but
    have all identical media queries definitions merged into one, there are a number
    of build tools (at the time of writing, Grunt and Gulp both have relevant plugins)
    that facilitate this.
  prefs: []
  type: TYPE_NORMAL
- en: The viewport meta tag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get the most out of media queries, you will want smaller screen devices to
    display web pages at their native size (and not render them in a 980px window
    that you then have to zoom in and out of).
  prefs: []
  type: TYPE_NORMAL
- en: When Apple released the iPhone in 2007, they introduced a proprietary `meta`
    tag called the viewport `meta` tag which Android and a growing number of other
    platforms now also support. The purpose of the viewport `meta` tag is to provide
    a way for web pages to communicate to mobile browsers how they would like the
    web browser to render the page.
  prefs: []
  type: TYPE_NORMAL
- en: For the foreseeable future, any web page you want to be responsive, and render
    well across small screen devices, will need to make use of this `meta` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Testing responsive designs on emulators and simulators**'
  prefs: []
  type: TYPE_NORMAL
- en: Although there is no substitute for testing your development work on real devices,
    there are emulators for Android and a simulator for iOS.
  prefs: []
  type: TYPE_NORMAL
- en: For the pedantic, a simulator merely simulates the relevant device whereas an
    emulator actually attempts to interpret the original device code.
  prefs: []
  type: TYPE_NORMAL
- en: The Android emulator for Windows, Linux, and Mac is available for free by downloading
    and installing the Android **Software Development Kit** (**SDK**) at [http://developer.android.com/sdk/](http://developer.android.com/sdk/).
  prefs: []
  type: TYPE_NORMAL
- en: The iOS simulator is only available to Mac OS X users and comes as part of the
    Xcode package (free from the Mac App Store).
  prefs: []
  type: TYPE_NORMAL
- en: Browsers themselves are also including ever improving tools for emulating mobile
    devices in their development tools. Both Firefox and Chrome currently have specific
    settings to emulate different mobile devices/viewports.
  prefs: []
  type: TYPE_NORMAL
- en: 'The viewport `<meta>` tag is added within the `<head>` tags of the HTML. It
    can be set to a specific width (which we could specify in pixels, for example)
    or as a scale, for example `2.0` (twice the actual size). Here''s an example of
    the viewport `meta` tag set to show the browser at twice (200 percent) the actual
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let's break down the preceding `<meta>` tag so we can understand what's going
    on. The `name="viewport"` attribute is obvious enough. The `content="initial-scale=2.0`
    section is then saying, "scale the content to twice the size" (where 0.5 would
    be half the size, 3.0 would be three times the size, and so on) while the `width=device-width`
    part tells the browser that the width of the page should be equal to device-width.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<meta>` tag can also be used to control the amount a user can zoom in
    and out of the page. This example allows users to go as large as three times the
    device width and as small as half the device width:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also disable users from zooming at all, although as zooming is an
    important accessibility tool, it''s rare that it would be appropriate in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `user-scalable=no` being the relevant part.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right, we''ll change the scale to `1.0`, which means that the mobile browser
    will render the page at 100 percent of its viewport. Setting it to the device''s
    width means that our page should render at 100 percent of the width of all supported
    mobile browsers. For the majority of cases, this `<meta>` tag would be appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Noticing that the viewport `meta` element is seeing increasing use, the W3C
    is making attempts to bring the same capability into CSS. Head over to [http://dev.w3.org/csswg/css-device-adapt/](http://dev.w3.org/csswg/css-device-adapt/)
    and read all about the new `@viewport` declaration. The idea is that rather than
    writing a `<meta>` tag in the `<head>` section of your markup, you could write
    `@viewport { width: 320px; }` in the CSS instead. This would set the browser width
    to 320 pixels. However, browser support is scant, although to cover all bases
    and be as future proof as possible you could use a combination of `meta` tag and
    the `@viewport` declaration.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should have a solid grasp of media queries and how they work.
    However, before we move on to a different topic entirely, I think it's nice to
    consider what may be possible in the near future with the next version of media
    queries. Let's take a sneak peak!
  prefs: []
  type: TYPE_NORMAL
- en: Media Queries Level 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing, while CSS Media Queries Level 4 enjoy a draft specification
    ([http://dev.w3.org/csswg/mediaqueries-4/](http://dev.w3.org/csswg/mediaqueries-4/)),
    the features in the draft don't enjoy many browser implementations. This means
    that while we will take a brief look at the highlights of this specification,
    it's highly volatile. Ensure you check browser support and double-check for syntax
    changes before using any of these features.
  prefs: []
  type: TYPE_NORMAL
- en: For now, while there are other features in the level 4 specification, we will
    concern ourselves only with scripting, pointer and hover, and luminosity.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting media feature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's a common practice to set a class on the HTML tag to indicate that no JavaScript
    is present by default and then replace that class with a different class when
    JavaScript runs. This provides a simple ability to fork code (including CSS) based
    upon that new HTML class. Specifically, using this practice you can then write
    rules specific to users that have JavaScript enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s potentially confusing so let''s consider some example code. By default,
    this would be the tag as authored in the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When JavaScript was run on the page, one of its first tasks would be to replace
    that `no-js` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, we can then write specific CSS rules that will only apply
    when JavaScript is present. For example, `.js .header { display: block; }`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the scripting media feature of CSS Media Queries Level 4 aims to provide
    a more standardized manner to do this directly in the CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And when JavaScript is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it also aims to provide the ability to ascertain when JavaScript is
    present but only initially. One example given in the W3C specification is that
    of a printed page that could be laid out initially but does not have JavaScript
    available after that. In such an eventuality, you should be able to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The current Editor''s draft of this feature can be read here: [http://dev.w3.org/csswg/mediaqueries-4/#mf-scripting](http://dev.w3.org/csswg/mediaqueries-4/#mf-scripting)'
  prefs: []
  type: TYPE_NORMAL
- en: Interaction media features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the W3C introduction to the pointer media feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"The pointer media feature is used to query about the presence and accuracy
    of a pointing device such as a mouse. If a device has multiple input mechanisms,
    the pointer media feature must reflect the characteristics of the "primary" input
    mechanism, as determined by the user agent."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There are three possible states for the pointer features: `none`, `coarse`,
    and `fine`.'
  prefs: []
  type: TYPE_NORMAL
- en: A `coarse` pointer device would be a finger on a touch screen device. However,
    it could equally be a cursor from a games console that doesn't have the fine grained
    control of something like a mouse.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: A `fine` pointer device would be a mouse but could also be a stylus pen or any
    future fine grained pointer mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As far as I'm concerned, the sooner browsers implement these pointer features,
    the better. At present it's notoriously difficult to know whether or not a user
    has mouse, touch input, or both. And which one they are using at any one time.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The safest bet is always to assume users are using touch-based input and size
    user interface elements accordingly. That way, even if they are using a mouse
    they will have no difficulty using the interface with ease. If however you assume
    mouse input, and can't reliably detect touch to amend the interface, it might
    make for a difficult experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a great overview of the challenges of developing for both touch and pointer,
    I recommend this set of slides called *Getting touchy* from Patrick H. Lauke:
    [https://patrickhlauke.github.io/getting-touchy-presentation/](https://patrickhlauke.github.io/getting-touchy-presentation/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Read the Editor''s draft of this feature here: [http://dev.w3.org/csswg/mediaqueries-4/#mf-interaction](http://dev.w3.org/csswg/mediaqueries-4/#mf-interaction)'
  prefs: []
  type: TYPE_NORMAL
- en: The hover media feature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you might imagine, the hover media feature tests the users'' ability to
    hover over elements on the screen. If the user has multiple inputs at their disposal
    (touch and mouse for example), characteristics of the primary input are used.
    Here are the possible values and example code:'
  prefs: []
  type: TYPE_NORMAL
- en: For users that have no ability to hover, we can target styles for them with
    a value of `none`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: For users that can hover but have to perform a significant action to initiate
    it, `on-demand` can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For users that can hover, `hover` alone can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Be aware that there are also `any-pointer` or `any-hover` media features. They
    are like the preceding hover and pointer but test the capabilities of any of the
    possible input devices.
  prefs: []
  type: TYPE_NORMAL
- en: Environment media features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Wouldn''t it be nice if we had the ability to alter our designs based upon
    environmental features such as ambient light level? That way if a user was in
    a darker room, we could dim the lightness of the colors used. Or conversely, increase
    contrast in brighter sunlight. The environment media features aim to solve these
    very problems. Consider these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Remember there are few implementations of these Level 4 Media Queries in the
    wild. It's also probable that the specifications will change before we can safely
    use them. It is however useful to have some feel for what new capabilities are
    on the way for us in the next few years.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read the Editor''s draft of this feature here: [http://dev.w3.org/csswg/mediaqueries-4/#mf-environment](http://dev.w3.org/csswg/mediaqueries-4/#mf-environment)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've learned what CSS3 media queries are, how to include them
    in our CSS files, and how they can help our quest to create a responsive web design.
    We've also learned how to use the `meta` tag to make modern mobile browsers render
    pages as we'd like.
  prefs: []
  type: TYPE_NORMAL
- en: However, we've also learned that media queries alone can only provide an adaptable
    web design, one that snaps from one layout to another. Not a truly responsive
    one that smoothly transitions from one layout to another. To achieve our ultimate
    goal we will also need to utilize fluid layouts. They will allow our designs to
    flex between the break points that the media queries handle. Creating fluid layouts
    to smooth the transition between our media query break points is what we'll be
    covering in the next chapter.
  prefs: []
  type: TYPE_NORMAL
