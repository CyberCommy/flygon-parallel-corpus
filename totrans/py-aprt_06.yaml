- en: Chapter 1 – Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter we’ll cover obtaining and installing Python on your system for
    Windows, Ubuntu Linux, and macOS. We’ll also write our first basic Python code
    and become a acquainted with the essentials Python programming culture, such as
    the Zen of Python, while never forgetting the comical origins of the name of the
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining and installing Python 3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two major versions of the Python language, *Python 2* which is the
    widely deployed legacy language and *Python 3* which is the present and future
    of the language. Much Python code will work without modification between the last
    version of Python 2 (which is [Python 2.7](https://www.python.org/download/releases/2.7/))
    and recent versions of Python 3, such as [Python 3.5](https://www.python.org/download/releases/3.5.1/).
    However, there are some key differences between the major versions, and in a strict
    sense the languages are incompatible. We’ll be using Python 3.5 for this book,
    but we’ll point out key differences with Python 2 as we go. It’s also very likely
    that, this being a book on Python fundamentals, everything we present will apply
    to future versions of Python 3, so don’t be afraid to try those as they become
    available.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can start programming in Python we need to get hold of a Python environment.
    Python is a highly portable language and is available on all major operating systems.
    You will be able to work through this book on Windows, Mac or Linux, and the only
    major section where we diverge into platform specifics is coming right up — as
    we install Python 3\. As we cover the three platforms, feel free to skip over
    the sections which aren’t relevant for you.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For Windows you need to visit the [official Python website](http://python.org),
    and then head to the Download page by clicking the link on the left. For Windows
    you should choose one of the MSI installers depending on whether you’re running
    on a 32- or 64-bit platform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download and run the installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the installer, decide whether you only want to install Python for yourself,
    or for all users of your machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a location for the Python distribution. The default will be in `C:\Python35`
    in the root of the `C:` drive. We don’t recommended installing Python into `Program
    Files` because the virtualized file store used to isolate applications from each
    other in Windows Vista and later can interfere with easily installing third-party
    Python packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the *Customize Python* page of the wizard we recommend keeping the defaults,
    which use less than 40 MB of space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition to installing the Python runtime and standard library, the installer
    will register various file types, such as `*.py` files, with the Python interpreter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once Python has been installed, you’ll need to add Python to your system `PATH`
    environment variable. To do this, from the Control Panel choose *System and Security*,
    then *System*. Another way to get here easily is to hold down your Windows key
    and press the Break key on your keyboard. Using the task pane on the left choose
    *Advanced System Settings* to open the *Advanced* tab of the *System Properties*
    dialog. Click *Environment variables* to open the child dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have Administrator privileges you should be able to add the paths `C:\Python35`
    and `C:\Python35\Scripts` to the semicolon separated list of entries associated
    with the `PATH` system variable. If not, you should be able to create, or append
    to, a `PATH` variable specific to your user containing the same value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now open a *new* console window — either Powershell or cmd will work fine —
    and verify that you can run python from the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Welcome to Python!**'
  prefs: []
  type: TYPE_NORMAL
- en: The triple arrow prompt shows you that Python is waiting for your input.
  prefs: []
  type: TYPE_NORMAL
- en: At this point you might want to skip forward whilst we show how to install Python
    on Mac and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For macOS you need to visit the official Python website at [http://python.org](http://python.org).
    Head to the Download page by clicking the link on the left. On the Download page,
    find the macOS installer matching your version of macOS and click the link to
    download it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A DMG Disk Image file downloads, which you open from your Downloads stack or
    from the Finder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Finder window that opens you will see the file `Python.mpkg` multipackage
    installer file. Use the “secondary” click action to open the context menu for
    that file. From that menu, select “Open”.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On some versions of macOS you will now be told that the file is from an unidentified
    developer. Press the “Open” button on this dialog to continue with the installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are now in the Python installer program. Follow the directions, clicking
    through the wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no need to customize the install, and you should keep the standard
    settings. When it’s available, click the “Install” button to install Python. You
    may be asked for your password to authorize the installation. Once the installation
    completes click “Close” to close the installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that Python 3 is installed, open a terminal window and verify that you
    can run Python 3 from the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Welcome to Python!**'
  prefs: []
  type: TYPE_NORMAL
- en: The triple arrow prompt shows that Python is waiting for your input.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To install Python on Linux you will want to use your system’s package manager.
    We’ll show how to install Python on a recent version of Ubuntu, but the process
    is very similar on most other modern Linux distributions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On Ubuntu, first start the “Ubuntu Software Center”. This can usually be run
    by clicking on it’s icon in the launcher. Alternatively, you can run it from the
    dashboard by searching on “Ubuntu Software Center” and clicking the selection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you’re in the software center, enter the search term “python 3.5” in the
    search bar in the upper right-hand corner and press return.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One of the results you’ll get will say “Python (v3.5)” with “Python Interpreter
    (v3.5)” in smaller type beneath it. Select this entry and click the “Install”
    button that appears.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may need to enter your password to install the software at this point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now see a progress indicator appear, which will disappear when installation
    is complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a terminal (using `Ctrl-Alt-T`) and verify that you can run Python 3.5
    from the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Welcome to Python!**'
  prefs: []
  type: TYPE_NORMAL
- en: The triple arrow prompt shows you that Python is waiting for your input.
  prefs: []
  type: TYPE_NORMAL
- en: Starting Python command line REPL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that Python is installed and running, you can immediately start using it.
    This is a good way to get to know the language, as well as a useful tool for experimentation
    and quick testing during normal development.
  prefs: []
  type: TYPE_NORMAL
- en: This Python command line environment is a *Read-Eval-Print-Loop*. Python will
    **READ** whatever input we type in, **EVAL**uate it, **PRINT** the result and
    then **LOOP** back to the beginning. You’ll often hear it referred to by the acronymn
    “REPL”.
  prefs: []
  type: TYPE_NORMAL
- en: When started, the REPL will print some information about the version of Python
    you’re running, and then it will give you a triple-arrow prompt. This prompt tells
    you that Python is waiting for you to type something.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within an interactive Python session you can enter fragments of Python programs
    and see instant results. Let’s start with some simple arithmetic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Python reads our input, evaluates it, prints the result, and
    loops around to do the same again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can assign to variables in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'print their contents by typing their name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'and refer to them in expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the REPL you can use the special underscore variable to refer to the
    most recently printed value, this being one of very few obscure shortcuts in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can use the special underscore variable in an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that not all statements have a return value. When we assigned 5 to `x`
    there was no return value, only the side-effect of bringing the variable `x` into
    being. Other statements have more visible side-effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see that Python immediately evaluates and executes this command, printing
    the string “Hello, Python” and returning you to another prompt. It’s important
    to understand that the response here is not the result of the expression evaluated
    and displayed by the REPL, but is a side-effect of the `print()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Leaving the REPL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, we should show you how to exit the REPL and get back to your
    system shell prompt. We do this by sending the *end-of-file* control character
    to Python, although unfortunately the means of sending this character varies across
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’re on Windows, press `Ctrl-Z` to exit.
  prefs: []
  type: TYPE_NORMAL
- en: Unix
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’re on Mac or Linux, press `Ctrl-D` to exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you regularly switch between platforms and you accidentally press `Ctrl-Z`
    on a Unix-a-like system, you will inadvertently suspend the Python interpreter
    and return to your operating system shell. To reactivate Python by making it a
    foreground process again, run the `fg` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'and press `Enter` and couple of times to get the triple arrow Python prompt
    back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Code structure and significant indentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Start your Python 3 interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'on Windows or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: on Mac or Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'The control flow structures of Python, such as for-loops, while-loops, and
    if-statements, are all introduced by statements which are terminated by a colon,
    indicating that the body of the construct is to follow. For example, for-loops
    require a body, so if you enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Python will present you with a prompt of three dots to request that you provide
    the body.
  prefs: []
  type: TYPE_NORMAL
- en: One distinctive (and sometimes controversial) aspect of Python is that leading
    whitespace is syntactically significant. What this means is that Python uses indentation
    levels, rather the braces used by other languages, to demarcate code blocks. By
    convention, contemporary Python code is indented by four spaces for each level.
  prefs: []
  type: TYPE_NORMAL
- en: 'So when Python present us with the three dot prompt, we provide those four
    spaces and a statement to form the body of the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Our loop body will contain a second statement, so after pressing `Return` at
    the next three dot prompt we’ll enter another four spaces followed by a call to
    the built-in `print()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To terminate our block, we must enter a blank line into the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With the block complete, Python executes the pending code, printing out the
    multiples of 10 less than 50:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at at screenful of Python code, we can see how the indentation clearly
    matches — and in fact *must* match — the structure of the program.
  prefs: []
  type: TYPE_NORMAL
- en: '![Python source code](images/m01----significant_whitespace_code.png)'
  prefs: []
  type: TYPE_IMG
- en: Python source code
  prefs: []
  type: TYPE_NORMAL
- en: Even if we replace the code by gray lines, the structure of the program is clear.
  prefs: []
  type: TYPE_NORMAL
- en: '![Grayed out code](images/m01----significant_whitespace_bars.png)'
  prefs: []
  type: TYPE_IMG
- en: Grayed out code
  prefs: []
  type: TYPE_NORMAL
- en: Each statement terminated by a colon starts a new line and introduces an additional
    level of indentation, which continues until a dedent restores the indentation
    to a previous level. Each level of indent is typically four spaces, although we’ll
    cover the rules in more detail in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python’s approach to significant whitespace has three great advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It forces developers to use a single level of indentation in a code-block. This
    is generally considered good practice in any language because it makes code much
    more readable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code with significant whitespace doesn’t need to be cluttered with unnecessary
    braces, and you never need to have code-standard debates about where the braces
    should go. All code-blocks in Python code are easily identifiable and everyone
    writes them the same way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Significant whitespace requires that a consistent interpretation must be given
    to the structure of the code by the author, the Python runtime system and future
    maintainers who need to read the code. As a result you can never have code that
    contains a block from Python’s point of view, but which doesn’t look like it contains
    a block from a cursory human perspective.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The rules for Python indentation can seem complex, but they are quite straightforward
    in practice.
  prefs: []
  type: TYPE_NORMAL
- en: The whitespace you use can be either spaces or tabs. The general consensus is
    that *spaces are preferable to tabs*, and *four spaces has become a standard in
    the Python community*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One essential rule is **NEVER** to mix spaces and tabs. The Python interpreter
    will complain, and your colleagues will hunt you down.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are allowed to use different amounts of indentation at different times if
    you wish. The essential rule is that *consecutive lines of code at the same indentation
    level are considered to be part of the same code block*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some exceptions to these rules, but they almost always have to do
    with improving code readability in other ways, for example by breaking up necessarily
    long statements over multiple lines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This rigorous approach to code formatting is “Programming as Guido intended
    it” or, perhaps more appropriately, “as Guido *indented* it”! A philosophy of
    placing a high value on code qualities such as readability gets to the very heart
    of Python culture, something we’ll take a short break to explore now.
  prefs: []
  type: TYPE_NORMAL
- en: Python culture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many programming languages are at the center of a cultural movement. They have
    their own communities, values, practices, and philosophy, and Python is no exception.
    The development of the Python language itself is managed through a series of documents
    called *Python Enhancement Proposals*, or *PEPs*. One of the PEPs, called PEP
    8, explains how you should format your code, and we follow its guidelines throughout
    this book. For example, it is PEP 8 which recommends that we use four spaces for
    indentation in new Python code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another of these PEPs, called PEP 20 is called “The Zen of Python”. It refers
    to 20 aphorisms describing the guiding principles of Python, only 19 of which
    have been written down. Conveniently, the Zen of Python is never further away
    than the nearest Python interpreter, as it can always be accessed from the REPL
    by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Throughout this book we’ll be highlighting particular nuggets of wisdom from
    the Zen of Python in *moments of zen* to understand how they apply to what we
    have learned. As we’ve just introduced Python significant indentation, this is
    a good time for our first *moment of zen*.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/m01----zen-readability-counts.png)'
  prefs: []
  type: TYPE_IMG
- en: In time, you’ll come to appreciate Python’s significant whitespace for the elegance
    it brings to *your* code, and the ease with which you can read *other’s*.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Importing standard library modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier, Python comes with an extensive standard library, an aspect
    of Python that is often referred to as “batteries included”. The standard library
    is structured as *modules*, a topic we’ll discuss in depth later. What’s important
    at this stage is to know that you gain access to standard library modules by using
    the `import` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic form of importing a module is the `import` keyword followed by a
    space and the name of the module. For example, lets see how we can use the standard
    library’s `math` module to compute square roots. At the triple-arrow prompt we
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `import` is a statement which doesn’t return a value, Python doesn’t
    print anything if the import succeeds, and we’re immediately returned to the prompt.
    We can access the contents of the imported module by using the name of the module,
    followed by a dot, followed by the name of the attribute in the module that you
    need. Like many object oriented languages the dot operator is used to drill down
    into object structures. Being expert Pythonistas, we have inside knowledge that
    the `math` module contains a function called `sqrt()`. Let’s try to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Getting `help()`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: But how can we find out what other functions are available in the `math` module?
  prefs: []
  type: TYPE_NORMAL
- en: The REPL has a special function `help()` which can retrieve any embedded documentation
    from objects for which documentation has been provided, such as standard library
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get help, type “help” at the prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll leave you to explore the first form — for interactive help — in your
    own time. Here we’ll go for the second option and pass the `math` module as the
    object for which we want help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can use the space-bar to page through the help, and if you’re on Mac or
    Linux use the arrow keys to scroll up and down.
  prefs: []
  type: TYPE_NORMAL
- en: Browsing through the functions, you’ll can see that there’s a math function,
    `factorial`, for computing factorials. Press ‘q’ to exit the help browser, and
    return us to the Python REPL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now practice using `help()` to request specific help on the `factorial` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Press ‘q’ to return to the REPL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use `factorial()` a bit. The function accepts an integer argument and
    return an integer value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we need to qualify the function name with the module namespace. This
    is generally good practice, as it makes it abundantly clear where the function
    is coming from. That said, it can result in code that is excessively verbose.
  prefs: []
  type: TYPE_NORMAL
- en: Counting fruit with `math.factorial()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s use factorials to compute how many ways there are to draw three fruit
    from a set of five fruit using some math we learned in school:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple expression is quite verbose with all those references to the math
    module. The Python `import` statement has an alternative form that allows us to
    bring a specific function from a module into the current namespace by using the
    `from` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is a good improvement, but is still a little long-winded for such a simple
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'A third form of the import statement allows us to rename the imported function.
    This can be useful for reasons of readability, or to avoid a namespace clash.
    Useful as it is, though, we recommend that this feature be used infrequently and
    judiciously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Different types of numbers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Remember that when we used `factorial()` alone it returned an integer. But
    our more complex expression above for calculating combinations is producing a
    floating point number. This is because we’ve used `/`, Python’s floating-point
    division operator. Since we know our operation will only ever return integral
    results, we can improve our expression by using `//`, Python’s integer division
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'What’s notable is that many other programming languages would fail on the above
    expression for even moderate values of `n`. In most programming languages, regular
    garden variety signed integers can only store values less than ![2^{31}](images/leanpub_equation_0.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'However, factorials grow so fast that the largest factorial you can fit into
    a 32-bit signed integer is 12! since 13! is too large:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In most widely used programming languages you would need either more complex
    code or more sophisticated mathematics merely to compute how many ways there are
    to draw three fruits from a set of thirteen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python encounters no such problems and can compute with arbitrarily large integers,
    limited only by the memory in your computer. To demonstrate this further, let’s
    try the larger problem of computing how many different pairs of fruit we can pick
    from 100 different fruits (assuming we can lay our hands on so many fruit!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Just to emphasize how large the size of the first term of that expression is,
    calculate 100! on it’s own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This number is vastly larger even than the number of atoms in the known universe,
    with an awful lot of digits. If, like us, you’re curious to know exactly how many
    digits, we can convert our integer to a text string and count the number of characters
    in it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: That’s definitely a lot of digits. And a lot of fruit. It also starts to show
    how Python’s different data types — in this case, integers, floating point numbers,
    and text strings — work together in natural ways. In the next section we’ll build
    on this experience and look at integers, strings, and other built-in types in
    more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scalar data types: integers, floats, None and bool'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python comes with a number of built-in datatypes. These include primitive scalar
    types like integers as well as collection types like dictionaries. These built-in
    types are powerful enough to be used alone for many programming needs, and they
    can be used as building blocks for creating more complex data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic built-in scalar types we’ll look at are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int` — signed, unlimited precision integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float` — IEEE 754 floating-point numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`None` — a special, singular null value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool` — true/false boolean values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For now we’ll just be looking at their basic details, showing their literal
    forms and how to create them.
  prefs: []
  type: TYPE_NORMAL
- en: '`int`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve already seen Python integers in action quite a lot. Python integers are
    signed and have, for all practical purposes, unlimited precision. This means that
    there is no pre-defined limit to the magnitude of the values they can hold.
  prefs: []
  type: TYPE_NORMAL
- en: 'Integer literals in Python are typically specified in decimal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'They may also be specified in binary with a `0b` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'octal, with a `0o` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'or hexadecimal with a `0x` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also construct integers by a call to the `int` constructor which can
    convert from other numeric types, such as floats, to integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, when using the `int` constructor, the rounding is always towards
    zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also convert strings to integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Be aware, though, that Python will throw an exception (much more on those later!)
    if the string doesn’t represent an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even supply an optional number base when converting from a string.
    For example, to convert from base 3 simply pass 3 as the second argument to the
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: float
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Floating point numbers are supported in Python by the `float` type. Python floats
    are implemented as [IEEE-754 double-precision floating point numbers](https://en.wikipedia.org/wiki/IEEE_floating_point)
    with 53 bits of binary precision. This is equivalent to between 15 and 16 significant
    digits in decimal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any literal number containing a decimal point is interpreted by Python as a
    `float`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Scientific notation can be used, so for large numbers — such as ![3\times10^8](images/leanpub_equation_1.png),
    the approximate speed of light in metres per second — we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'and for small numbers like Planck’s constant ![1.616\times10^{ - 35}](images/leanpub_equation_2.png)
    we can enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Notice how Python automatically switches the display representation to the most
    readable form.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for integers, we can convert to floats from other numeric or string types
    using the `float` constructor. For example, the constructor can accept an `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'or a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Special floating point values
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'By passing certain strings to the `float` constructor, we can create the special
    floating point value `NaN` (short for **N**ot **a** **N**umber) and also positive
    and negative infinity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Promotion to float
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The result of any calculation involving `int` and `float` is promoted to a
    `float`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: You can read more about Python’s number types [in the Python documentation](http://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex).
  prefs: []
  type: TYPE_NORMAL
- en: '`None`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Python has a special null value called `None`, spelled with a capital “N”.
    `None` is frequently used to represent the absence of a value. The Python REPL
    never prints `None` results, so typing `None` into the REPL has no effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '`None` can be bound to variable names just like any other object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'and we can test whether an object is `None` by using Python’s `is` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We can see here that the response is `True`, which brings us conveniently on
    to the `bool` type.
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `bool` type represents logical states and plays an important role in several
    of Python’s control flow structures, as we’ll see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you would expect there are two bool values, `True` and `False`, both spelled
    with initial capitals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a `bool` constructor which can be used to convert from other
    types to `bool`. Let’s look at how it works. For `int`s, zero is considered “falsey”
    and all other values “truthy”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We see the same behavior with `float`s where only zero is considered “falsey”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'When converting from collections, such as strings or lists, only empty collections
    are treated as “falsey”. When converting from lists — which we’ll look at shortly
    — we see that only the empty list (shown here in it’s literal form of `[]`) evaluates
    to `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, with strings only the empty string, `""`, evaluates to `False` when
    passed to `bool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In particular, you cannot use the `bool` constructor to convert from string
    representations of `True` and `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Since the string “False” is not empty, it will evaluate to `True`!
  prefs: []
  type: TYPE_NORMAL
- en: These conversions to `bool` are important because they are widely used in Python
    if-statements and while-loops which accept `bool` values in their condition.
  prefs: []
  type: TYPE_NORMAL
- en: Relational operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Boolean values are commonly produced by Python’s relational operators which
    can be used for comparing objects.
  prefs: []
  type: TYPE_NORMAL
- en: Two of the most widely used relational operators are Python’s equality and inequality
    tests, which actually test for equivalence or inequivalence of values. That is,
    two objects are *equivalent* if one could use used in place of the other. We’ll
    learn more about the notion of object equivalence later in the book. For now,
    we’ll compare simple integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by assigning — or binding — a value to a variable `g`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We test for equality with `==`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'or for inequality using `!=`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Rich comparison operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can also compare the order of quantities using the rich comparison operators.
    Use `<` to determine if the first argument is less than the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, use `>` to determine if the first is greater than the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test less-than or equal-to with `<=`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'and greater-than or equal-to with `>=`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: If you have experience with relational operators from other languages, then
    Python’s operators are probably not surprising at all. Just remember that these
    operators are comparing equivalence, not identity, a distinction we’ll cover in
    detail in coming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Control flow: if-statements and while-loops'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we’ve examined some basic built-in types, let’s look at two important
    control flow structures which depend on conversions to the `bool` type: if-statements
    and while-loops.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Conditional control flow: the if-statement'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Conditional statements allow us to branch execution based on the value of an
    expression. The form of the statement is the `if` keyword, followed by an expression,
    terminated by a colon to introduce a new block. Let’s try this at the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Remembering to indent four spaces within the block, we add some code to be
    executed if the condition is `True`, followed by a blank line to terminate the
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point the block will execute, because self-evidently the condition
    is `True`. Conversely, if the condition is `False`, the code in the block does
    not execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression used with the if-statement will be converted to a `bool` just
    as if the `bool()` constructor had been used, so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'is exactly equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to this useful shorthand, explicit conversion to `bool` using the `bool`
    constructor is rarely used in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '`if...else`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The if-statement supports an optional “else” clause which goes in a block introduced
    by the `else` keyword (followed by a colon) which is indented to the same level
    as the `if` keyword. Let’s start by creating (but not finishing) an if-block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To start the `else` block in this case, we just omit the indentation after
    the three dots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '`if...elif...else`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For multiple conditions you might be tempted to do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Whenever you find yourself with an else-block containing a nested if-statement,
    like this, you should consider using Python’s `elif` keyword which is a combined
    `else-if`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the Zen of Python reminds us, “Flat is better than nested”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This version is altogether easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conditional repetition: the while-loop'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Python has two types of loop: for-loops and while-loops. We’ve already briefly
    encountered for-loops back when we introduced significant whitespace, and we’ll
    return to them soon, but right now we’ll cover while-loops.'
  prefs: []
  type: TYPE_NORMAL
- en: While-loops in Python are introduced by the `while` keyword, which is followed
    by a boolean expression. As with the condition for if-statements, the expression
    is implicitly converted to a boolean value as if it has been passed to the `bool()`
    constructor. The `while` statement is terminated by a colon because it introduces
    a new block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write a loop at the REPL which counts down from five to one. We’ll initialize
    a counter variable called `c` to five, and keep looping until we reach zero. Another
    new language feature here is the use of an augmented-assignment operator, `-=`,
    to subtract one from the value of the counter on each iteration. Similar augmented
    assignment operators exist for the other basic math operations such as addition
    and multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the condition — or predicate — will be implicitly converted to `bool`,
    just as if a call to the `bool()` constructor were present, we could replace the
    above code with the following version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This works because the conversion of the integer value of `c` to `bool` results
    in `True` until we get to zero which converts to `False`. That said, to use this
    short form in this case might be described as un-Pythonic, because, referring
    back to the Zen of Python, explicit is better than implicit. We place higher value
    of the readability of the first form over the concision of the second form.
  prefs: []
  type: TYPE_NORMAL
- en: 'While-loops are often used in Python where an infinite loop is required. We
    achieve this by passing `True` as the predicate expression to the while construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you’re probably wondering how we get out of this loop and regain control
    of our REPL! Simply press `Ctrl-C`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Python intercepts the key stroke and raises a special exception which terminates
    the loop. We’ll be talking much more about what exceptions are, and how to use
    them, later in Chapter 6.
  prefs: []
  type: TYPE_NORMAL
- en: Exiting loops with `break`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Many programming languages support a loop construct which places the predicate
    test at the end of the loop rather than at the beginning. For example, C, C++,
    C# and Java support the do-while construct. Other languages have repeat-until
    loops instead or as well. This is not the case in Python, where the idiom is to
    use `while True` together with an early exit, facilitated by the `break` statement.
  prefs: []
  type: TYPE_NORMAL
- en: The `break` statement jumps out of the loop — and only the innermost loop if
    severals loops have been nested — continuing execution immediately after the loop
    body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of `break`, introducing a few other Python features
    along the way, and examine it line-by-line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We start with a `while True:` for an infinite loop. On the first statement of
    the while block we use the built-in `input()` function to request a string from
    the user. We assign that string to a variable called `response`.
  prefs: []
  type: TYPE_NORMAL
- en: We now use an if-statement to test whether the value provided is divisible by
    seven. We convert the response string to an integer using the `int()` constructor
    and then use the modulus operator, `%`, to divide by seven and give the remainder.
    If the remainder is equal to zero, the response was divisible by seven, and we
    enter the body of the if-block.
  prefs: []
  type: TYPE_NORMAL
- en: Within the if-block, now two levels of indentation deep, we start with eight
    spaces and use the `break` keyword. `break` terminates the inner-most loop — in
    this case the while-loop — and causes execution to jump to the first statement
    after the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Here, that “statement” is the end of the program. We enter a blank line at the
    three dots prompt to close both the if-block and the while-block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our loop will start executing, and will pause at the call to `input()` waiting
    for us to enter a number. Let’s try a few:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: As soon as we enter a number divisible by seven the predicate becomes `True`,
    we enter the if-block, and then we literally break out of the loop to the end
    of program, returning us to the REPL prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting out with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtaining and installing Python 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting the Read-Eval-Print-Loop or REPL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple arithmetic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating variables by binding objects to names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing with the built-in `print()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exiting the REPL with `Ctrl-Z` (Windows) or `Ctrl-D` (Unix)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being Pythonic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Significant indentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PEP 8 - The Style Guide for Python Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PEP 20 - The Zen of Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing modules with the import statement in various forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding and browsing `help()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic types and control flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`s, `float`s, `None`, and `bool`, plus conversions between them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational operators for equality and ordering tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if-statements with `else` and `elif` blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: while-loops with implicit conversion to `bool`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interrupting infinite loops with `Ctrl-C`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking out of loops with `break`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requesting text from the user with `input()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Augmented assignment operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
