- en: Creating a Graphical User Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In games, user interaction is an extremely important part of the design. Being
    able to provide the user with visual information and a visual selection of choices
    is where the **Graphical User Interface** (**GUI**) comes in. Like many other
    systems discussed in this book, there are existing libraries available for use.
    One of the most commonly known in the open source game development world is **Crazy
    Eddies GUI** (**CEGUI**). While CEGUI is a very robust GUI system implementation,
    with that robustness comes complexity, and to be honest, most of the time you
    will really just need a text label, a simple button, and maybe a checkbox and
    icon support. With these simple building blocks, you can create a lot.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will construct the building blocks and create a simple
    GUI system. It should be noted that creating a complete, production-ready GUI
    system from scratch is an enormous task, not one for a single chapter. So, we
    will focus on the core concepts and build a system that can be extended and scaled
    later on. Our GUI will not use any API specifics and will continue to build off
    of the created structure from previous chapters. The topics covered in this chapter
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Coordinate systems and positioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding control logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering the GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complete code example for this chapter can be found in the `Chapter06` folder
    in the code repository. For brevity's sake, I will be omitting some of the non-essential
    lines of code from the sections and may jump around files and classes more frequently.
  prefs: []
  type: TYPE_NORMAL
- en: Coordinate systems and positioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important parts of every GUI system is how objects/elements
    are positioned on the screen. For the most part, graphics APIs use coordinates
    known as screen space, usually expressed in an absolute range [-1, 1]. While this
    is good for rendering, this can cause some issues when trying to develop our GUI
    system. Let's take, for example, the idea of using an absolute system. In this
    system, we would explicitly set each element in the GUI to a real pixel coordinate.
    This could be very simple to implement, but would only work if the game's resolution
    stayed the same. If at any time we changed the resolution, the elements would
    stay locked to their pixel coordinates and would not scale to match the new resolution.
  prefs: []
  type: TYPE_NORMAL
- en: Another option would be to create a relative system, where each GUI element's
    position would be described in relation to other elements or screen locations.
    This approach is much better than an absolute system but still poses some scaling
    issues. For example, if we had an element that we placed at the top left of the
    screen, with a small offset, if at any time the game's resolution changed, the
    spacing that we used would change as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we are going to build is a somewhat similar approach employed by CEGUI,
    which is a combination of the two solutions mentioned previously. While we are
    at it, we are also going to add another common convention used in modern GUIs:
    containing grouped elements in *panels*. There are a couple of good reasons why
    we want to group our GUI elements in panels. The first is that if we wanted to
    move a bunch of elements, say a status bar with health, ammo, and items indicators,
    if we group them in a panel, we only have to move the panel and all the elements
    will follow, correctly positioned. Which brings us to reason two: by grouping
    elements together in panels, we can define the position of the elements relative
    to the panel''s position, as opposed to setting the elements positions as pixel
    coordinates or even relative to a screen location.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a diagram depicting this design layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00836859-220f-4875-a4cd-a99dcc87cd00.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, a combination of relative and absolute positioning is used,
    but this time the relative starting point is not the origin **[0,0]** of the entire
    screen, but the origin **[0,0]** of our panel. While the panel's origin point
    already has some coordinates on the screen, we don't use those for setting the
    position of the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'In theory, we now have scalable elements inside the panel(s), but we still
    need a way to *lock* or *stickie* panels in place, regardless of the screen resolution.
    This is where the concept of GUI anchor systems comes in. Chances are, if you
    have ever worked with a GUI before, you have seen anchors in action. In our example,
    we are going to slightly simplify the concept for the sake of time. In our system,
    every panel will have the ability to set its origin relative to one of five anchor
    points: top left, top right, bottom left, bottom right, and center.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram demonstrates this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b2ce10a-aa70-43a8-bdfe-a91cdf9d5897.png)'
  prefs: []
  type: TYPE_IMG
- en: 'OK, so how do we implement these concepts and design them in code? Let start
    with a `IGUIElement` class that all other elements will inherit from. Take a look
    at the `IGUIElement` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To start with, our elements are not that complicated. Each element will have
    an `Update()` function, as well as a getter function to return the position of
    the element. We will be expanding on this class later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part of the system we can implement is the concept of panels. Let''s
    start by taking a look at the header file of `IGUIPanel.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The file starts off with the declaration of an `enum class` called `GUIAnchorPos`;
    this `enum` will give the elements access to the calculated anchor points. We
    are making this an enum class instead of just an `enum` inside of the `IGUIPanel`
    class, as this will allow elements to access the anchor points without the need
    for an `IGUIPanel` instance. Later on, we will see a function that connects these
    enumerated values to the screen positions that have been calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part of the file that is of interest is the constructor. Here, we
    are requesting a vector 4 to be passed in to define the bounds of the panel to
    be created. Next, we are requesting a vector two for the panel anchor''s origin
    location, as well as a vector two to provide the offset or *padding* for the panel''s
    position. You will also notice that we are also providing some defaults for each
    parameter. We are doing this for a couple of reasons, but the biggest one is that
    we want to be able to create GUI elements and attach them to a panel by default.
    By providing defaults, if we do create a GUI element and there is no existing
    panel to attach it to, we can create one without the need to pass in values when
    it''s created. We will revisit this later on in the chapter. Let''s move on to
    the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For the implementation of the `IGUIPanel` constructor, the first thing we will
    calculate is the panel's position on the screen. We do this by adding the panel's
    anchor point with the offset that has been passed in and storing it in the protected
    member variable `m_Pos`. Next, we calculate the panel's width and height; we do
    this using the bounds values being passed in. We store them in protected member
    variables named `m_panelWidth` and `m_panelHeight` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the panel constructor in place, we can move on to setting
    up how the panels will hold their elements. To accomplish this, we simply create
    a vector of `IGUIElements` pointers called `m_GUIElementList`. We can then start
    to create some public methods to access and manipulate the panel''s element list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'First, in the `IGUIPanel.cpp` file, we create an `AddGUIElement()` function
    to add new elements to the panel. This function implements a call to the `push_back()`
    method of the panel''s element list, pushing in the giving `GUIElement` reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Jumping to the `IGUIPanel.h` file, we implement a getter function, `GetGUIElementList()`,
    to provide public access to the private element list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Switching back to the `IGUIPanel.cpp` file, we can look at the implementation
    of the `Update()` function for the panel class. This update will step through
    the panel''s element list and then call the `Update()` function for each of the
    elements in the list. This will allow the panel to control the updates of its
    elements, and provides the structure for implementing concepts such as pausing
    element updates on the panel being hidden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we need to remember to clean up all the elements belonging to the panel
    when the destructor is called. To do this, we are going to use the `for_each()`
    method of the `standard` library. We are using this method mostly because this
    is an example and due to the sheer fact that I want to introduce you to it. The
    `for_each()` method takes three parameters. The first two are applied to the range,
    and the third is the function to execute. In our example, we are going to call
    `default_delete()` on each element we step through, and again we are using this
    method as a means to introduce you to the function. The `default_delete()` function
    is actually a function object class, whose function-like invocation takes a templated
    object type and deletes it. This can be compared the non-specialized version that
    simply uses delete for the delete operation or the specialization for arrays,
    `delete[]`. This class is specifically designed to be used with `unique_ptr` and
    provides a way to delete `unique_ptr` objects with no overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, now that we have the `IGUIPanel` class in place, we can move on to constructing
    some more complex elements needed for our GUI system. For this example, we will
    add a basic button with label support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the `IGUIButton.h` file, we can see that the button inherits from our basic
    `IGUIElement`. This of course means we have access to all the functions and protected
    members of the parent class, including the `m_position` and `GetPosition()` functions,
    so we do not redefine them here. While we are looking at the `IGUIButton.h`, we
    can also peek at the constructor, where we are defining what the button will require
    to be passed in when creating. In our example button, we are looking for the bounds
    (size) of the button, the position, a texture to use when drawing the button,
    a label for the button (text to be displayed), the font to use for the label,
    the scale of the font (which we give as a default of `1.0f`), and finally a panel
    to add the button to which we default to `NULL` unless otherwise specified. We
    will take a deeper look at these parameters as we continue on with the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shifting to the implementation of the constructor, in the `IGUIButton.cpp` before `IGUIButton::IGUIButton(glm::vec4
    & bounds, glm::vec2 & position, std::string label, GLTexture * texture, SpriteFont*
    font, glm::vec2& fontScale, IGUIPanel* panel)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For the most part, we are just setting the internal member variables to the
    passed in values, but the one thing of note is how we handle the panel value.
    In the constructor body, we perform a check to see if the value stored in `m_panel`
    is not null. If this check is true, we can move on to setting the position of
    the button element relative to the panel''s position. We do this by first calling
    the panel''s `GetPosition()` function, adding the returned value to our passed
    in position value, and saving that calculation in the `m_position` member variable.
    This will give us, partially, what we want by setting the position of our button
    to the relation origin of the panel, but since the origin of our default panel
    elements is the lower left corner, the outcome would be the button being placed
    at the bottom of the panel. This is not necessarily the desired behavior. To correct
    this, we need to calculate our button''s new *y* axis value based on the top of
    the panel, and of course any already existing elements in the panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First, we want to check if the panel we are adding the button to has any existing
    elements in it already. We do this by checking the panel's vector with the `GetGUIElementList().empty()`
    function. If the panel's element list is not empty, we then need the position
    the of the last element in the panel's list. We do this by creating a temporary
    element called `lastElement` and assigning it to the last element in the panel's
    list using `GetGUIElementList().back()`. With the element stored, we can then
    use it to calculate the button's *y* axis value. We do this by subtracting the
    stored element's *y* axis value from the stored element's height (`GetBounds().w`)
    and a default padding value, which we are setting at `10.0f` in this example.
    In a full GUI implementation, you would want to make this padding value dynamic.
    Finally, if the panel is empty, and this is the first element, we set the button's
    *y* axis by calculating the panel's height (`GetBounds()->w`) minus the new button's
    height. This will place the button element at the very top of the panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a panel system with an element class and an implemented button
    element created. The last thing we need to do is build a high-level class to glue
    the system together. We are going to create an `IGUI` class that will house panels,
    provide access to the GUI methods to other game systems, and, as we will see in
    the next sections, provide input, update, and draw mechanisms. Let''s jump into
    the constructor implementation in the `IGUI.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor for the `IGUI` class, we are going to define the anchor
    points that we will use for all the panels held by the `IGUI` instance. We are
    going to store these values in private member variables: `m_BL` for the bottom
    left of the screen, `m_BR` for the bottom right of the screen, `m_TL` for the
    top left, `m_TR` for the top right, and `m_C` for the center of the screen. We
    use the set `m_window` Window object to return the width and height of the screen
    used to calculate the anchor points. We will see how these points are used to
    provide anchors to the panels later in the class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at the functions we will use to add the elements and panels
    to the `IGUI` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting with the `AddGUIElement` function, this function, as its name implies,
    adds a GUI element to the GUI. By default, the element will be added to the first
    panel found in the GUI''s panel list, which is stored in the `m_GUIPanelsList`
    vector. If the panel list is empty we then create a new panel, add it to the list,
    and then finally add the element to that panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `AddGUIPanel()` function is very simple. We take the passed in `IGUIPanel`
    object and add it to the GUI's panel list using the `push_back()` vector method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the positioning system that we need to look at is the `GetAnchorPos()`
    function. This function will return the panel''s anchor position based on the
    calculated screen values, which we saw previously in the `IGUI` constructor and
    the size of the panel itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We start off by passing in two values. The first is `GUIAnchorPos`, which you
    might remember from earlier on in the chapter when we defined an `enum` class
    in the `IGUIPanel.h` file. The second is the bounds of the panel, described with
    a vector four object. Inside the function, we have a switch case statement which
    we are using to determine what anchor point to calculate.
  prefs: []
  type: TYPE_NORMAL
- en: If the case matches the `TopRight` enum value, first we modify the *y* axis
    value of the anchor point. We do this because we use the bottom left corner as
    the default origin, so we need to modify this so the top left corner is the new
    origin for the anchor point. Next, we modify the *x* axis value of the anchor
    point. We do this because we need to move the anchor point in from the top right
    corner of the screen by the width of the panel object. If we don't modify the
    *x* axis value, the panel will draw off screen to the right.
  prefs: []
  type: TYPE_NORMAL
- en: Next, if the case matches the TopLeft enum value, we modify the *y* axis value
    of the anchor point. As stated previously, we do this to account for the origin
    of our coordinate system being the lower left-hand corner. We do not have to modify
    the *x* axis value this time, since when we draw left to right, our panel will
    appear on screen.
  prefs: []
  type: TYPE_NORMAL
- en: If the case matches the `BottomRight` enum value, we need to modify the *x*
    axis value. As mentioned before, we need to move the anchor point to the left
    by the width of the panel, to make sure the panel will draw on the screen. We
    do not need to modify the *y* axis this time, since the anchor will match the
    default coordinate system's *y* origin of the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: If the case matches the `BottomLeft` enum value, we simply return the anchor
    point unmodified since it matches the default origin of the coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if the case matches the `Center` enum value, we will only modify the
    *y* axis value since we only have to account for the default origin being in the
    lower left corner. The *x* axis value calculated in the constructor will move
    the panel to the right to position it properly in the center of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: That takes care of the positioning and anchor system for our GUI system. We
    now have a solid framework to continue building on throughout the rest of the
    chapter. Next, we will look at how we can add input control to our GUI system.
  prefs: []
  type: TYPE_NORMAL
- en: Adding control logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A GUI is much more than just what you can see on screen. There is also logic
    running behind the scenes, so to speak, that provides the functionality needed
    to interact with objects. Handling what happens if a mouse is moved over an element,
    if a checkbox is selected, or if a button is clicked is all part of the GUI input
    system. In this section, we are going to construct the necessary architecture
    to handle mouse input for our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: While there are a few different ways we could implement the system to handle
    input for our GUI, I think this is a perfect opportunity to introduce you to one
    of my favorite programming patterns, the Observer. The `Observer` is one of the
    most widely known patterns from the **Gang of Four**. The `Observer` is so commonly
    used that Java has a core library dedicated to it, `java.util.Observer` and C#
    has it incorporated into the language itself in the form of the event keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'I think the easiest way to explain the `Observer` pattern is that when you
    have objects doing various things that are of interest to another class or object,
    you can *subscribe* to *events* and get notified when these objects perform their
    interesting functions. It''s very likely you have seen and/or used the `Observer`
    pattern before in your development adventures. In fact, we have seen it already
    in this book. The SDL library uses its own `Observer` pattern for handling input.
    We tap into it to perform tasks based on the user''s input. The following is the
    SDL event implementation we use to handle our game input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: What we are going to build is something a little more basic, but it will provide
    you with a good understanding of how you can implement an input system for a GUI,
    and you can hopefully familiarize yourself with a flexible pattern for future
    development.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, inside the `IGUIElement` header file, we create a new `enum`
    class called `GUIEvent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This `enum` class defines the different types of events that our GUI elements
    can listen for. Next, still in our `IGUIElement` class header file, we need to
    add a completely virtual function, `OnNotify()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will be overridden by each of the element types and will be called
    when events occur. The elements that have this function implemented can *listen *to
    the events that matter to them and perform actions as necessary. `OnNotify()`
    takes two parameters: an `IGUIElement()` which defines which element is affected,
    and the event type. These two parameters will give us all the information we need
    to determine what to do with each event sent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `OnNotify()` implementation in our `IGUIButton()`
    object class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `IGUIButton::OnNotify` implementation, we can listen to different types
    of events being passed in. In this example case, we are checking if the event
    passed in is a `HoverOver` event. If it is, we add a comment for where we will
    perform any actions we need to when the button is hovered over. That''s really
    it when it comes to setting up the *listener*. Next, we need to connect our GUI
    input system to the current input system and start sending out the event notifications.
    Let''s move on and look at the `CheckInput()` function implementation in the `IGUI`
    object class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will take a look at it piece by piece. To start with, we get the current
    mouse coordinates from the passed in `InputManager` object and save them to temporary
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to use a nested `for` loop to step through all the panels in
    the GUI and, in turn, all the elements attached to each one of those panels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside of the nested loop, we are going to do a simple *hit* test to see if
    we are in the button''s bound. However, first, we need to do a quick calculation.
    In the coordinate and position section earlier in this chapter, you might remember
    we made a conversion to have the anchor point''s *y* axis moved to the top left
    corner. Now we need to do the opposite and convert the *y* axis of the element''s
    position back to the lower left corner. The reason we need to do this is so the
    mouse cursor''s screen coordinate system is in the same as the buttons position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to do in the loop is to perform the actual *hit* or
    bounds check. To do this, we check and see if the mouse cursor''s, *x* axis value
    is within the button''s screen area. We also check the same thing on the *y* axis
    using the converted *y* values from earlier. If all these conditions are met,
    then we can send a `HoverOver` event notification to the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, we have, while crude, a working event system. The last piece of
    the puzzle we need to put in place is connecting it to the current input handling
    system of the game engine. To do that, we add one simple line to the `CheckInput()`
    function of the `ExampleScreen` class, `m_gui->CheckInput(m_game->GetInputManager());`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: That takes care of the logic implementation for this chapter's example. There
    is definitely room for refactoring and tuning, but this should provide you with
    a good starting point to expand upon. I would recommend going through the next
    steps and adding more functionality, maybe even new elements to work with. In
    the next section, we are going to close out the chapter by adding rendering to
    our GUI system and finally drawing our example on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all the positioning and input logic in place, we can now finish up our
    GUI system by implementing some basic rendering. The good news is we already have
    a strong infrastructure for our main rendering that we built earlier on in the
    book. We are going to tap into this infrastructure to render our GUI on the screen.
    Basically, you have two real choices when it comes to rendering the GUI. You could
    render the GUI to a texture and then blend the created texture into your final
    drawn scene. The other option is to render everything as geometry in each frame
    on top of your scene. Both have their issues, but I would argue that in most cases
    creating a texture and blending that texture will be slower than rendering the
    GUI elements as geometry.
  prefs: []
  type: TYPE_NORMAL
- en: To keep things slightly simple and to focus more on the implementation, we start
    with an easier approach and render each of the elements separately. This, of course,
    is not the most performance-friendly way of rendering if we have lots of elements
    in the GUI. In our example, we will not have a large number of elements, and if
    you are building something such as a start game/menu GUI, this solution in its
    current form will be more than sufficient. Keep an eye on your framerate, as if
    you notice a drop then chances are you have too many draw calls.
  prefs: []
  type: TYPE_NORMAL
- en: The best way we can approach our solution is to use the same approach we took
    when rendering our models, with some slight differences. We will use shaders again
    to draw the geometry, as this will provide us with lots of control and the ability
    to perform any blend, masks, patterns, and effects we might want to add. For our
    GUI example, we are going to reuse our texture vertex and fragment shaders from
    the previous chapters. In the next chapter, we are going to dive deeper into advanced
    shaders and drawing techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s dive into the implementation. Add this to the `IGUI.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And then add this in the constructor for the `IGUI` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are specifying a shader texture program, a sprite batch, and a 2D camera.
    This camera is slightly different to the 3D version we created earlier in the
    book. I won't go too deep into the 2D camera since its slightly out of the scope
    of this chapter, but I will mention that the major change is that we are constructing
    an orthographic matrix for 2D drawing. We are giving each GUI instance its own
    shader, camera, and sprite batch. It will be up to the instance to handle the
    final setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ExampleGUI` is the implementation of the `IGUI` class for our example.
    Taking a look at the `OnInit()` function, we can see the setup of these resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We will break it down piece by piece. To start with, we need to compile the
    `Shaders` we need for our GUI, so we add the attributes we need for the shaders,
    and finally link them for use. This should be familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We then call `Init` on our 2D camera instance, passing the screen width and
    height. After the `Init`, we then set the position of the camera to the middle
    of the screen by dividing the screen''s height and width values in half:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the shader program, the sprite batch, and camera setup, we
    move on to the creation of the GUI elements. First up is the panel element, which
    we create using the architecture we created earlier in the chapter. We set its
    anchor point as the bottom left of the screen. Once the panel is created, we add
    it to the GUI instance by calling the `AddGUIPanel` function that the class has
    inherited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'With the panel created and added to the GUI instance''s panel list, we then
    add a button to that panel. To do that, we first create a temporary variable to
    hold the texture we want to load for this button. Then we create the button itself.
    We again use the structure we built earlier on in the chapter. We pass in the
    label of `My Button` and the texture we just loaded. Once complete, we call the
    `AddGUIElement()` function and add the button to the panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our elements are in place, and the rendering components have been created
    and set up, we can finalize the rendering pipeline for the GUI system. To do this,
    we are going to fall back on the inheritance structure we have created in our
    objects. To start the draw call chain, we begin with the `ExampleGUI` class and
    its `Draw()` function implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Focusing on an important aspect of our GUI implementation, we begin the `Draw()`
    function by specifying the shader program we want to use when rendering the GUI
    elements. Next, we start the sprite batch that will be used for the GUI elements.
    Then, between the start of the sprite batch and the end of the sprite batch, we
    use a `for` loop to step through all the panels in the GUI's panel list and call
    its `Draw()` function implementation. Once the `for` loop has completed, we then
    end the sprite batch, call the `BatchRender()` method to render all the objects
    in the batch, and finally close out the function by calling the `UnUse()` method
    on our shader program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go down one level in the draw chain and look at the IGUIPanel''s Draw
    function implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the `IGUIPanel::Draw()` function, we start by adding the panel itself to
    the sprite batch that we passed in from the calling object. This will draw a slightly
    opaque black background. Ideally, you want to make the texture used for the background
    a non-hardcoded value and allow it to be set for each instance. After we have
    added the panel to the sprite batch for drawing, we again use a `for` loop to
    step through each element in the panel's element list and call its `Draw()` function
    implementation. This effectively pushes its use to the next layer down in the
    draw chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `IGUIElement` class, we simply create a pure virtual function that
    the elements inheriting will have to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'So this means we can now step down to the last link in our draw chain example
    and look at the `IGUIButton::Draw()` function implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Again, this implementation of the functions is not too complicated. We are adding
    the element to the sprite batch passed in by the calling object to be drawn. The
    effect of this is that all panels and their elements will be added to a single
    GUI instance's sprite batch, which will be far more performant than each panel
    and object drawing itself in sequence. The last code block in the `Draw()` function
    is a call to a Sprite Font instance's `Draw()` method. I won't go into detail
    about how the Sprite Font class works since it is out of the scope of this chapter,
    but have a look at the code files to understand how things are working under its
    hood. The role of the `SpriteFont` class is much like the `Sprite` class, except
    it provides a means to draw fonts/text on screen. Here in this example, we are
    using it to draw the label for the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'That wraps up the draw chain. All we need to do now is connect the GUI''s head
    `Draw()` call to the main game''s `Draw()` call. To do this, we add one line to
    call the `Draw()` method of the GUI''s instance in the `ExampleScreen` class''s
    `Draw()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, I am happy to say, we have a simple but complete, working GUI system in
    place. You can run the example demo to see the completed GUI running. If you want
    to see how the panel is effected by each of the defined anchor points, you just
    need to change the `BookEngine::GUIAnchorPos` value when setting the panel in
    the `ExampleGUI` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are screenshots of the GUI in action, with its anchor points
    changed to `BottomLeft`, `BottomRight`, `TopLeft`, `TopRight`, and `Center`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The screenshot for `BottomRight` is as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0595a630-669f-412c-adb4-9e951d649152.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The screenshot for `BottomLeft` is as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ee5b8ea-aa35-454f-8e9a-c4fcf8a37907.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The screenshot for `TopLeft` is as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ebbf1359-bb61-446e-9caa-461cc74cab06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The screenshot for `TopRight` is as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/770ecc8b-c2d8-4e5f-bfca-eed425cd420c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The screenshot for `Center` is as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14a196c6-26aa-4e71-a784-45126f8d26d3.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a large amount of information. We discussed the
    different aspects needed to create a GUI. We walked through its implementation,
    diving deep into the core architecture behind a working GUI. We developed a panel
    and element architecture complete with anchor points for controlling positioning.
    We implemented a user input structure using the `Observer` design pattern and
    rounded it out by coding up the rendering pipe needed to display the GUI elements
    on the screen. In the next chapter, we will dive deep into some of the advanced
    rendering techniques used in game development.
  prefs: []
  type: TYPE_NORMAL
