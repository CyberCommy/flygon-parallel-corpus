- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Saving, Loading, and Serializing Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every game you've ever played works with data, whether it's your player stats,
    game progress, or online multiplayer scoreboards. Your favorite game also manages
    internal data, meaning the programmers used hardcoded information to build levels,
    keep track of enemy stats, and write helpful utilities. In other words, data is
    everywhere.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to start with how both C# and Unity handle the
    filesystem on your computer, and move on to reading, writing, and serializing
    our game data. Our focus is on working with the three most common data formats
    you''ll likely come across: text files, XML, and JSON.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll have a foundational understanding of your
    computer's filesystem, data formats, and basic read-write functionality. This
    will be the foundation you build your game data on, creating a more enriching
    and engaging experience for your players. You'll also be in a good position to
    start thinking about what game data is important enough to save, and how your
    C# classes and objects will look in different data formats.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'Along the way, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Introducing text, XML, and JSON formats
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the filesystem
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with different stream types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing game data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing objects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing data formats
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data can take different forms in programming, but the three formats you should
    be familiar with at the beginning of your data journey are:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '**Text**, which is what you''re reading right now'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XML** (**Extensible Markup Language**), which is a way of encoding document
    information so it''s readable for you and a computer'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSON** (**JavaScript Object Notation**), which is a human-readable text format
    made up of attribute-value pairs and arrays'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these data formats has its own strengths and drawbacks, as well as applications
    in programming. For instance, text is generally used to store simpler, non-hierarchical,
    or nested information. XML is better at storing information in a document format,
    while JSON has a more diverse range of capabilities, specifically with database
    information and server communication with applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about XML at [https://www.xml.com](https://www.xml.com)
    and JSON at [https://www.json.org](https://www.json.org).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Data is a big topic in any programming language, so let's start off by breaking
    down what XML and JSON formats actually look like in the next two sections.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down XML
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A typical XML file has a standardized format. Each element of the XML document
    has an opening (`<element_name>`), a closing tag (`</element_name>`), and supports
    tag attributes (`<element_name attribute= "attribute_name"></element_name>`).
    A basic file will start with the version and encoding being used, then the starting
    or root element, followed by a list of element items, and finally the closing
    element. As a blueprint, it would look like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'XML data can also store more complex objects by using child elements. For example,
    we''ll be turning a list of weapons into XML using the `Weapon` class we wrote
    earlier in the book. Since each weapon has properties for its name and damage
    value, that will look like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s break down the example above to make sure we''ve got it right:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The XML document starts with the version being used
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The root element is declared with an opening tag named `ArrayOfWeapon`, which
    will hold all our element items
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A weapon item is created with an opening tag named `Weapon`
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Its child properties are added with opening and closing tags on a single line
    for `name` and `damage`
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The weapon item is closed, and two more weapon items are added
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The array is closed, marking the end of the document
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The good news is our application doesn't have to manually write our data in
    this format. C# has an entire library of classes and methods to help us translate
    simple text and class objects directly into XML.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: We'll dive into practical code examples a little later on, but first we need
    to understand how JSON works.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down JSON
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JSON data format is similar to XML, but without the tags. Instead, everything
    is based on attribute-value pairs, like the **Dictionary** collection type we
    worked with back in *Chapter 4*, *Control Flow and Collection Types*. Each JSON
    document starts with a parent dictionary that holds as many attribute-value pairs
    as you need. Dictionaries use open and closed curly braces ( `{ }` ), a colon
    separates each attribute and value, and each attribute-value pair is separated
    by a comma:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'JSON can also have child or nested structures by setting the value of an attribute-value
    pair to an array of attribute-value pairs. For instance, if we want to store a
    weapon, it would look like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, JSON data is often made up of lists, or arrays, or objects. Continuing
    our example, if we wanted to store a list of all the weapons our player could
    choose, we would use a pair of square brackets to denote an array:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can mix and match any of these techniques to store any kind of complex data
    you need, which is one of JSON's main strengths. But just like with XML, don't
    be overtaken by the new syntax – C# and Unity both have helper classes and methods
    to translate text and class objects into JSON without us having to do any heavy
    lifting. Reading XML and JSON is sort of like learning a new language—the more
    you use it the more familiar it becomes. Soon it'll be second nature!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've dipped our toes into data formatting basics, we can start talking
    about how the filesystem on your computer works and what properties we can access
    from our C# code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the filesystem
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we say filesystem, we're talking about something you're already familiar
    with – how files and folders are created, organized, and stored on your computer.
    When you create a new folder on your computer, you can name it and put files or
    other folders inside it. It's also represented by an icon, which is both a visual
    cue and a way to drag, drop, and move it anywhere you like.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Everything you can do on your desktop you can do in code. All you need is the
    name of the folder, or directory as it's called, and a location to store it. Anytime
    you want to add a file or subfolder, you reference the parent directory and add
    your new content.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'To drive the filesystem home, let''s start building out the `DataManager` class:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the **Hierarchy** and choose **Create Empty**, then name it **Data_Manager**:![](img/B17573_12_01.png)
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.1: Data_Manager in the Hierarchy'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Data_Manager** object in the **Hierarchy** and drag the `DataManager`
    script we created in *Chapter 10*, *Revisiting Types, Methods, and Classes*, from
    the **Scripts** folder into the **Inspector**:![](img/B17573_12_02.png)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.2: Data_Manager in the Inspector'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `DataManager` script and update it with the following code to print
    out a few filesystem properties:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s break down the code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: First, we add the `System.IO` namespace, which has all the classes and methods
    we need to work with the filesystem.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We call the `FilesystemInfo` method we create in the next step.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We create the `FilesystemInfo` method to print out a few filesystem properties.
    Every operating system handles its filesystem paths differently—a path is the
    location of a directory or file written in a string. On Macs:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paths are separated by a colon (`:`)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directories are separated by a forward slash (`/`)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current directory path is where the *Hero Born* project is stored
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The temporary path is the location of your filesystem's temporary folder
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're on other platforms and operating systems, make sure to check the `Path`
    and `Directory` methods for yourself before working with the filesystem.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the game and take a look at the output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_03.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: Console messages from Data Manager'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: The `Path` and `Directory` classes are the foundation we're going to be building
    on to store our data in the following sections. However, they're both large classes,
    so I encourage you to look into their documentation as you continue your data
    journey.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`和`Directory`类是我们将在接下来的部分中用来存储数据的基础。然而，它们都是庞大的类，所以我鼓励您在继续数据之旅时查阅它们的文档。'
- en: You can find more documentation for the Path class at [https://docs.microsoft.com/en-us/dotnet/api/system.io.path](https://docs.microsoft.com/en-us/dotnet/api/system.io.path)
    and the Directory class at [https://docs.microsoft.com/en-us/dotnet/api/system.io.directory](https://docs.microsoft.com/en-us/dotnet/api/system.io.directory).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/dotnet/api/system.io.path](https://docs.microsoft.com/en-us/dotnet/api/system.io.path)找到`Path`类的更多文档，以及在[https://docs.microsoft.com/en-us/dotnet/api/system.io.directory](https://docs.microsoft.com/en-us/dotnet/api/system.io.directory)找到`Directory`类的更多文档。
- en: Now that we have a simple example of filesystem properties printed out in our
    `DataManager` script, we can create a filesystem path to the location where we
    want to save our data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在`DataManager`脚本中打印出了文件系统属性的简单示例，我们可以创建一个文件系统路径，将数据保存到我们想要保存数据的位置。
- en: Working with asset paths
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理资源路径
- en: In a purely C# application, you would have to choose what folder to save your
    files in and write out the folder path in a string. However, Unity provides a
    handy pre-configured path as part of the `Application` class where you can store
    persistent game data. Persistent data means the information is saved and kept
    each time the program runs, which makes it ideal for this kind of player information.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯C#应用程序中，您需要选择要保存文件的文件夹，并将文件夹路径写入字符串中。然而，Unity提供了一个方便的预配置路径作为`Application`类的一部分，您可以在其中存储持久游戏数据。持久数据意味着信息在每次程序运行时都会被保存和保留，这使得它非常适合这种玩家信息。
- en: It's important to know that the path to Unity's persistent data directory is
    cross-platform, meaning that it's different whether you're building a game for
    iOS, Android, Windows, and more. You can find out more information in the Unity
    documentation at [https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html](https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，Unity持久数据目录的路径是跨平台的，这意味着为iOS、Android、Windows等构建游戏时会有所不同。您可以在Unity文档中找到更多信息[https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html](https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html)。
- en: The only update we need to make to `DataManager` is creating a private variable
    to hold our path string. We're making this private because we don't want any other
    script to be able to access or change the value. That way, `DataManager` is responsible
    for all data-related logic and nothing else.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对`DataManager`进行的唯一更新是创建一个私有变量来保存我们的路径字符串。我们将其设置为私有，因为我们不希望任何其他脚本能够访问或更改该值。这样，`DataManager`负责所有与数据相关的逻辑，而不会有其他东西。
- en: 'Add the following variable to `DataManager.cs`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DataManager.cs`中添加以下变量：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s break down our code update:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下我们的代码更新：
- en: We created a private variable to hold the data path string
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个私有变量来保存数据路径字符串
- en: 'We set the data path string to the application''s `persistentDataPath` value,
    added a new folder name called **Player_Data** using open and closed forward slashes,
    and printed out the complete path:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将数据路径字符串设置为应用程序的`persistentDataPath`值，使用开放和关闭的斜杠添加了一个名为**Player_Data**的新文件夹，并打印出完整路径：
- en: It's important to note that `Application.persistentDataPath` can only be used
    in a `MonoBehaviour` method like `Awake()`, `Start()`, `Update()`, and so on and
    the game needs to be running for Unity to return a valid path.![](img/B17573_12_04.png)
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的是要注意，`Application.persistentDataPath`只能在`MonoBehaviour`方法中使用，如`Awake()`、`Start()`、`Update()`等，游戏需要运行才能让Unity返回有效的路径。
- en: 'Figure 12.4: File path for Unity persistent data files'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：Unity持久数据文件的文件路径
- en: Since I'm using a Mac, my persistent data folder is nested inside my `/Users`
    folder. Remember to check out [https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html](https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html)
    to find out where your data is stored if you're using a different device.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我使用的是Mac，我的持久数据文件夹嵌套在我的`/Users`文件夹中。如果您使用不同的设备，请记得查看[https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html](https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html)以找出您的数据存储在何处。
- en: 'When you''re not working with a predefined asset path like Unity''s persistent
    data directory, C# has a handy method called `Combine` in the `Path` class for
    automatically configuring path variables. The `Combine()` method can take up to
    four strings as input parameters or an array of strings representing the path
    components. For example, a path to your `User` directory might look like:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当您不使用类似Unity持久数据目录这样的预定义资源路径时，C#中有一个名为`Combine`的便利方法，位于`Path`类中，用于自动配置路径变量。`Combine()`方法最多可以接受四个字符串作为输入参数，或者表示路径组件的字符串数组。例如，指向您的`User`目录的路径可能如下所示：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This takes care of any potential cross-platform issues with separating characters
    and back or forward slashes in paths and directories.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了路径和目录中的分隔字符和反斜杠或正斜杠的任何潜在跨平台问题。
- en: Now that we have a path to store our data, let's create a new directory, or
    folder, in the filesystem. This will let us store our data securely and between
    game runs, as opposed to temporary storage where it would be deleted or overwritten.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个存储数据的路径，让我们在文件系统中创建一个新目录，或文件夹。这将使我们能够安全地存储我们的数据，并在游戏运行之间进行存储，而不是在临时存储中被删除或覆盖。
- en: Creating and deleting directories
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和删除目录
- en: Creating a new directory folder is straightforward—we check to see if one already
    exists with the same name at the same path, and if not, we tell C# to create it
    for us. Everyone has their own ways of dealing with duplicates in their files
    and folders, so we'll be repeating a fair bit of duplicate checking code in the
    rest of the chapter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'I''d still recommend following the **DRY** (**Don''t Repeat Yourself**) principle
    in real-world applications; the duplicate checking code is only repeated here
    to make the examples complete and easy to understand:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to `DataManager`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Call the new method inside `Initialize()`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s break down what we did:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: First, we check if the directory folder already exists using the path we created
    in the last step
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it's already been created, we send ourselves a message in the console and
    use the `return` keyword to exit the method without going any further
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the directory folder doesn't exist, we pass the `CreateDirectory()` method
    our data path and log that it's been created
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game and make sure that you see the right debug logs in the console,
    as well as the new directory folder in your persistent data folder.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: If you can't find it, use the `_dataPath` value we printed out in the previous
    step.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_05.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.5: Console message for new directory creation'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_06.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.6: New directory created on the desktop'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game a second time, no duplicate directory folder will be created,
    which is exactly the kind of safe code we want.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_07.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.7: Console message for duplicate directory folders'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a directory is very similar to how we created it – we check if it exists,
    then we use the `Directory` class to delete whatever folder is at the path we
    pass in.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to `DataManager`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since we want to keep the directory we just created, you don't have to call
    this function right now. However, if you want to try it out all you need to do
    is replace `NewDirectory()` with `DeleteDirectory()` in the `Initialize()` function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: An empty directory folder isn't super useful, so let's create our first text
    file and save it in our new location.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Creating, updating, and deleting files
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working with files is similar to creating and deleting a directory, so we already
    have the basic building blocks we need. To make sure we don't duplicate data,
    we'll check if the file already exists, and if not, we'll create a new one in
    our new directory folder.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: We'll be working with the `File` class for this section, which has a ton of
    helpful methods to help us implement our features. You can find the entire list
    at [https://docs.microsoft.com/en-us/dotnet/api/system.io.file](https://docs.microsoft.com/en-us/dotnet/api/system.io.file).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: An important point to drive home about files before we start is that they need
    to be opened before you can add text, and they need to be closed after you're
    finished. If you don't close the file you're programmatically working with, it
    will stay open in the program's memory. This both uses computation power for something
    you're not actively editing and can create potential memory leaks. More on them
    later in the chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: We're going to be writing individual methods for each action we want to perform
    (create, update, and delete). We're also going to check if the files we're working
    with exist or not in each case, which is repetitive. I've structured this part
    of the book so you can get a solid grasp of each of the procedures. However, you
    can absolutely combine them into more economical methods after you've learned
    the basics.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new private string path for the new text file and set its value in `Awake`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add a new method to `DataManager`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Call the new method in `Initialize()`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s break down our new code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'We check if the file already exists, and if it does we `return` out of the
    method to avoid duplicates:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's worth noting that this approach works well for new files that aren't going
    to be changed. We'll cover updating and overwriting data to files in the next
    exercise.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use the `WriteAllText()` method because it does everything we need all in
    one:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new file is created using our `_textFile` path
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We add a title string that says `<SAVE DATA>` and add two new lines with the
    `\n` characters
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then the file is closed for us automatically
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We print out a log message to let us know everything went smoothly
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you play the game now, you''ll see the debug log in the console and the
    new text file in your persistent data folder location:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_08.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.8: Console messages for new file creation'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_09.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.9: New file created on desktop'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'To update our new text file, we''ll do a similar set of operations. It''s always
    nice to know when a new game is started, so your next task is to add a method
    to write that information to our save data file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `using` directive to the top of `DataManager`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add a new method to `DataManager`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Call the new method in `Initialize()`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s break down the above code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: If the file exists, we don't want to duplicate it so we just exit out of the
    method without any further action
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the file does exist, we use another all-in-one method called `AppendAllText()`
    to add the game''s start time:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This method opens the file
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It adds a new line of text that's passed in as a method parameter
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It closes the file
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print out a log message to let us know everything went smoothly
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Play the game again and you''ll see our console message and a new line in our
    text file with the new game''s date and time:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_10.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.10: Console messages for updating the text file'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_11.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.11: Text file data updated'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to read our new file data, we need a method to grab all the file''s
    text and hand it back to us in a string. Luckily, the `File` class has methods
    to do just that:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new method to `DataManager`:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Call the new method in `Initialize()` and pass in the `_textFile` as a parameter:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s break down the new method''s code below:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: We create a new method that takes in a string parameter for the file we want
    to read
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the file doesn't exist, there's no action needed so we exit out of the method
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `ReadAllText()` method to get all the file's text data as a string
    and print it out to the console
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the game and you'll see a console message with our previous save and a
    new one!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_12.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.12: Console message with saved text data read from file'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, let''s add a method to delete our text file if we wanted. We''re not
    actually going to use this method, as we want to keep our text file as is, but
    you can always try it out for yourself:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we've dipped our toes a little deeper into the filesystem waters, it's
    time to talk about a slightly upgraded way of working with information — data
    streams!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Working with streams
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've been letting the `File` class do all of the heavy lifting with
    our data. What we haven't talked about is how the `File` class, or any other class
    that deals with reading and writing data, does that work under the hood.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: For computers, data is made up of bytes. Think of bytes as the computer's atoms,
    they make up everything—there's even a C# `byte` type. When we read, write, or
    update a file, our data is converted into an array of bytes, which are then streamed
    to or from the file using a `Stream`. The data stream is responsible for carrying
    the data as a sequence of bytes to or from a file, acting as a translator or intermediary
    for us between our game application and the data files themselves.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_13.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.13: Diagram of streaming data to a file'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'The `File` class uses `Stream` objects for us automatically, and there are
    different `Stream` subclasses for different functionality:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Use a `FileStream` to read and write data to your files
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a `MemoryStream` to read and write data to memory
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a `NetworkStream` to read and write data to other networked computers
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a `GZipStream` to compress data for easier storage and downloading
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the coming sections, we'll get into managing stream resources, using helper
    classes called `StreamReader`and `StreamWriter` to create, read, update, and delete
    files. You'll also learn how to format XML more easily using the `XmlWriter` class.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Managing your Stream resources
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One important topic we haven't talked about yet is resource allocation. What
    that means is some processes in your code will put computing power and memory
    on a sort of layaway plan where you can't touch it. These processes will wait
    until you explicitly tell your program or game to close and return the layaway
    resources to you so you're back to full power. Streams are one such process, and
    they need to be closed after you're done using them. If you don't properly close
    your streams, your program will keep using those resources even though you're
    not.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, C# has a handy interface called `IDisposable` that all `Stream` classes
    implement. This interface only has one method, `Dispose()`, which tells the stream
    when to give you back the resources it's been using.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: You don't have to worry too much about this, as we'll cover an automatic way
    to make sure your streams are always closed correctly. Resource management is
    just a good programming concept to understand.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: We'll be using a `FileStream` for the rest of the chapter, but we'll be doing
    so with convenience classes called `StreamWriter` and `StreamReader`. These classes
    leave out the manual conversion of data to bytes, but still use `FileStream` objects
    themselves.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Using a StreamWriter and StreamReader
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both the `StreamWriter` and `StreamReader` classes serve as helpers for using
    objects belonging to `FileStream` to write and read text data to a specific file.
    These classes are a big help because they create, open, and return a stream you
    can use with minimal boilerplate code. The example code we've covered so far is
    fine for small data files, but streams are the way to go if you're dealing with
    large and complex data objects.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need is the name of the file we want to write to or read from and we''re
    all set. Your next task is to use a stream to write text to a new file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new private string path for the new streaming text file and set its value
    in `Awake()`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add a new method to `DataManager`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Delete or comment out the methods in `Initialize()` that we used in the previous
    section and add in our new code:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s break down the new method in the above code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: First, we check if the file doesn't exist
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the file hasn't been created yet, we add a new `StreamWriter` instance called
    `newStream`, which uses the `CreateText()` method to create and open the new file
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the file is open, we use the `WriteLine()` method to add a header, close
    the stream, and print out a debug message
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the file already exists and we just want to update it, we grab our file through
    a new `StreamWriter` instance using the `AppendText()` method so our existing
    data doesn't get overwritten
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we write a new line with our game data, close the stream, and print
    out a debug message:![](img/B17573_12_14.png)
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.14: Console messages for writing and updating text with a stream'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_15.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.15: New file created and updated with a stream'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading from a stream is almost exactly like the `ReadFromFile()` method we
    created in the last section. The only difference is that we''ll use a `StreamReader`
    instance to open and read the information. Again, you want to use streams when
    you''re dealing with big data files or complex objects instead of manually creating
    and writing to files with the `File` class:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new method to `DataManager`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Call the new method in `Initialize()` and pass in the `_streamingTextFile`
    as a parameter:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s break down our new code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: First, we check if the file doesn't exist, and if it doesn't then we print out
    a console message and exit the method
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the file does exist, we create a new `StreamReader` instance with the name
    of the file we want to access and print out the entire contents using the `ReadToEnd`
    method:![](img/B17573_12_16.png)
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.16: Console printing out saved data read from a stream'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: As you'll start to notice, a lot of our code is starting to look the same. The
    only difference is our use of stream classes to do the actual reading-writing
    work. However, it's important to keep in mind how different use cases will determine
    which route you take. Refer back to the beginning of this section to review how
    each stream type is different.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've covered the basic features of a **CRUD** (**Creating**, **Reading**,
    **Updating**, **and** **Deleting**) application using text files. But text files
    aren't the only data format you'll be using in C# games and applications. You're
    likely to see lots of XML and JSON in the wild once you start working with databases
    and your own complex data structures, which text can't compare to in efficiency
    or storage.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll work with some basic XML data, then talk about an
    easier way to manage streams.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Creating an XMLWriter
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you won't just have plain old text to write and read from a file.
    Your project might require XML-formatted documents, in which case you'll need
    to know how to use a regular `FileStream` to save and load XML data.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Writing XML data to a file isn't all that different from what we've been doing
    with text and streams. The only difference is we'll explicitly create a `FileStream`
    and use it to create an instance of an `XmlWriter`. Think of the `XmlWriter` class
    as a wrapper that takes our data stream, applies XML formatting, and spits out
    our information as an XML file. Once we have that, we can structure the document
    in the proper XML format using methods from the `XmlWriter` class and close the
    file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Your next task is to create a file path for a new XML document and add the
    ability to write XML data to that file using the `DataManager` class:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the highlighted `using` directive to the top of the `DataManager` class:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add a new private string path for the new XML file and set its value in `Awake()`:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add a new method at the bottom of the `DataManager` class:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Call the new method in `Initialize()` and pass in `_xmlLevelProgress` as a
    parameter:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s break down our XML writing method:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: First, we check if the file already exists
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the file doesn't exist, we create a new `FileStream` using the new path variable
    we created
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then create a new `XmlWriter` instance and pass it our new `FileStream`
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we use the `WriteStartDocument` method to specify XML version 1.0
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we call the `WriteStartElement` method to add the opening root element
    tag named `level_progress`
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can add individual elements to our document using the `WriteElementString`
    method, passing in `level` as the element tag and the level number using a `for`
    loop and its index value of `i`
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To close the document, we use the `WriteEndElement` method to add a closing
    `level` tag
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we close the writer and stream to release the stream resources we've
    been using
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you run the game now, you''ll see a new `.xml` file in our **Player_Data**
    folder with the level progress information:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_17.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.17: New XML file created with document data'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice that there is no indenting or formatting, which is expected because
    we didn't specify any output formatting. We're not going to use any of them in
    this example because we'll be talking about a more efficient way of writing XML
    data in the next section, on serialization.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: You can find the list of output formatting properties at [https://docs.microsoft.com/dotnet/api/system.xml.xmlwriter#specifying-the-output-format](https://docs.microsoft.com/dotnet/api/system.xml.xmlwriter#specifying-the-output-format).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is that reading an XML file is no different than reading any
    other file. You can call either the `readfromfile()` or `readfromstream()` methods
    inside `initialize()` and get the same console output:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![](img/B17573_12_18.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.18: Console output from reading the XML file data'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've written a few methods using streams, let's take a look at how
    to efficiently, and more importantly automatically, close any stream.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Automatically closing streams
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you're working with streams, wrapping them in a `using` statement automatically
    closes the stream for you by calling the `Dispose()` method from the `IDisposable`
    interface we mentioned earlier.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: This way, you never have to worry about unused allocated resources your program
    might be keeping open for no reason.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is almost exactly the same as what we''ve already done, except we
    use the `using` keyword at the beginning of the line, then reference a new stream
    inside a pair of parentheses, followed by a set of curly braces. Anything we want
    the stream to do, like read or write data, is done inside the curly braces block
    of code. For example, creating a new text file as we did in the `WriteToStream()`
    method would look like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As soon as the stream logic is inside the code block, the outer `using` statement
    automatically closes the stream and returns the allocated resources to your program.
    From here on out, I'd recommend always using this syntax to write your streaming
    code. It's more efficient, much safer, and will demonstrate your understanding
    of basic resource management!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: With our text and XML stream code working, it's time to move on. If you're wondering
    why we didn't stream any JSON data, it's because we need to add one more tool
    to our data toolbox—serialization!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Serializing data
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about serializing and deserializing data, what we're really talking
    about is translation. While we've been translating our text and XML piecemeal
    in previous sections, being able to take an entire object and translate it in
    one shot is a great tool to have.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'By definition:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: The act of **serializing** an object translates the object's entire state into
    another format
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The act of **deserializing** is the reverse, taking the data from a file and
    restoring it to its former object state
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B17573_12_19.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.19: Example of serializing an object into XML and JSON'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a practical example from the above image — an instance of our `Weapon`
    class. Each weapon has its own name and damage properties and associated values,
    which is called its state. The state of an object is unique, which allows the
    program to tell them apart.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: An object's state also includes properties or fields that are reference types.
    For instance, if we had a `Character` class that had a `Weapon` property, C# would
    still recognize the weapon's `name` and `damage` properties when serializing and
    deserializing. You might hear objects with reference properties referred to as
    object graphs out in the programming world.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Before we jump in, it's worth noting that serializing objects can be tricky
    if you're not keeping a close eye on making sure the object properties match the
    data from a file, and vice versa. For example, if there's a mismatch between your
    class object properties and the data being deserialized, the serializer will return
    an empty object. We'll cover this in more detail when we try to serialize a C#
    list into JSON later in the chapter.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: To really get the hang of this, let's take our `Weapon` example and turn it
    into working code.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Serializing and deserializing XML
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your task for the rest of this chapter is to serialize and deserialize a list
    of weapons into XML and JSON, with XML going first!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `using` directive to the top of the `DataManager` class:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add a serializable attribute to the `Weapon` class so Unity and C# know the
    object can be serialized:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add two new variables, one for the XML file path and one for the list of weapons:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Set the XML file path value in `Awake`:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add a new method at the bottom of the `DataManager` class:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Call the new method in `Initialize`:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s break down our new method:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create an `XmlSerializer` instance and pass in the type of data we''re
    going to be translating. In this case, the _`weaponInventory` is of type `List<Weapon>`,
    which is what we use in the `typeof` operator:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `XmlSerializer` class is another helpful formatting wrapper, just like the
    `XmlWriter` class we used earlier
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we create a `FileStream` using the `_xmlWeapons` file path and wrapped
    in a `using` code block to make sure it's closed properly.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we call the `Serialize()` method and pass in the stream and the data
    we want to translate.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game again and take a look at the new XML document we created without
    having to specify any additional formatting!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_20.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.20: XML output in the weapon inventory file'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'To read back our XML into a list of weapons, we set up everything almost exactly
    same except we use the `Deserialize()` method from the `XmlSerializer` class instead:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to the bottom of the `DataManager` class:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Call the new method in `Initialize` and pass in the `_xmlWeapons` as a parameter:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s break down the `deserialize()` method:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: First, we check if the file exists
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the file exists, we create an `XmlSerializer` object and specify that we're
    going to put the XML data back into a `List<Weapon>` object
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we open up a `FileStream` with the `_xmlWeapons` file name:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're using `File.OpenRead()` to specify that we want to open the file for reading,
    not writing
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we create a variable to hold our deserialized list of weapons:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We put the explicit `List<Weapon>` cast in front of the call to `Deserialize()`
    so that we get the correct type back from the serializer
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we use a `foreach` loop to print out each weapon's name and damage
    values in the console
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you run the game once again, you'll see that we get a console message for
    each weapon we deserialized from the XML list.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_21.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.21: Console output from deserializing XML'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: That's all we need to do for XML data, but before we finish out the chapter
    we still need to learn how to work with JSON!
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Serializing and deserializing JSON
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to serializing and deserializing JSON, Unity and C# aren't completely
    in sync. Essentially, C# has its own `JsonSerializer` class that works the exact
    same way as the `XmlSerializer` class we used in the previous examples.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: In order to access the JSON serializer, you need the `System.Text.Json` `using`
    directive. Here's the rub—Unity doesn't support that namespace. Instead, Unity
    uses the `System.Text` namespace and implements its own JSON serializer class
    called `JsonUtility`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Because our project is in Unity, we're going to work with Unity's supported
    serialization class. However, if you're working with a non-Unity C# project, the
    concepts are the same as the XML code we just wrote.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: You can find a complete how-to that includes code from Microsoft at [https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-how-to#how-to-write-net-objects-as-json-serialize](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-how-to#how-to-write-net-objects-as-json-serialize).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'Your next task is to serialize a single weapon to get the hang of the `JsonUtility`
    class:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `using` directive to the top of the `DataManager` class:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add a new private string path for the new XML file and set its value in `Awake()`:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add a new method at the bottom of the `DataManager` class:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Call the new method in `Initialize()` and pass in the `_jsonWeapons` as a parameter:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here''s the breakdown of the serialize method:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: First, we need a weapon to work with, so we create one with our class initializer
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then we declare a variable to hold the translated JSON data when it''s formatted
    as a string and call the `ToJson()` method:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ToJson()` method we're using takes in the `sword` object we want to serialize
    and a Boolean value of `true` so the string is pretty printed with proper indenting.
    If we didn't specify a `true` value, the JSON would still print out, it would
    just be a regular string, which isn't easily readable.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a text string to write to a file, we create a `StreamWriter`
    stream and pass in the `_jsonWeapons` file name
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we use the `WriteLine()` method and pass it the `jsonString` value
    to write to the file
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the program and look at the new JSON file we created and wrote data into!
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_22.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.22: JSON file with weapon properties serialized'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Now let's try and serialize our list of weapons we used in the XML examples
    and see what happens.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `SerializeJSON()` method to use the existing list of weapons instead
    of the single `sword` instance:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When you run the game again, you''ll see the JSON file data was overwritten
    and all we ended up with is an empty array:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_23.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.23: JSON file with an empty object after serialization'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Again, this is because the way Unity handles JSON serialization doesn't support
    lists or arrays by themselves. Any list or array needs to be part of a class object
    for Unity's `JsonUtility` class to recognize and handle it correctly.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Don't panic, if we think about this, it's a fairly intuitive fix—we just need
    to create a class that has a weapons list property and use that when we serialize
    our data into JSON!
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `Weapon.cs` and add the following serializable `WeaponShop` class to the
    bottom of the file. Be super careful to put the new class outside the `Weapon`
    class curly braces:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Back in the `DataManager` class, update the `SerializeJSON()` method with the
    following code:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s break down the changes we just made:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a new variable called `shop`, which is an instance of the `WeaponShop`
    class
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we set the `inventory` property to the `weaponInventory` list of weapons
    we already declared
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we pass the `shop` object to the `ToJson()` method and write the new
    string data to the JSON file
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the game again and look at the pretty printed list of weapons we''ve created:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_24.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.24: List object properly serialized into JSON'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'Deserializing JSON text back into an object is the reverse process of what
    we just did:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new method at the bottom of the `DataManager` class:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Call the new method in `Initialize()` and pass `_jsonWeapons` in as a parameter:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s break down the `DeserializeJSON()` method below:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: First, we check if the file exists
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it does exist, we create a stream with the `_jsonWeapons` file path wrapped
    in a `using` code block
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we use the stream's `ReadToEnd()` method to grab the entire JSON text
    from the file
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we create a variable to hold our deserialized list of weapons and call
    the `FromJson()` method:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that we specify that we want to turn our JSON into a `WeaponShop` object
    with the `<WeaponShop>` syntax before passing in the JSON string variable
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we loop through the weapon shop's `inventory` list property and print
    out each weapon's name and damage values in the console
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the game one last time and you''ll see a console message printed out for
    each weapon in our JSON data:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_25.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.25: Console output from deserializing a list of JSON objects'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Data roundup
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every individual module and topic we've covered in this chapter can be used
    by itself or combined to suit your project's needs. For example, you could use
    text files to store character dialogue and only load it when you need to. This
    would be more efficient than having the game keep track of it every time it runs,
    even when the information isn't being used.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: You could also put character data or enemy statistics into either an XML or
    JSON file and read from the file anytime you need to level up a character or spawn
    a new monster. Finally, you could fetch data from a third-party database and serialize
    it into your own custom classes. This is a super common scenario with storing
    player accounts and external game data.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: You can find a list of data types that can be serialized in C# at [https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer](https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer).
    Unity handles serialization a little differently, so make sure you check the available
    types at [https://docs.unity3d.com/ScriptReference/SerializeField.html](https://docs.unity3d.com/ScriptReference/SerializeField.html).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: The point I'm trying to make is that data is everywhere, and it's your job to
    create a system that handles it the way your game needs, brick by brick.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: And that's a wrap on the basics of working with data! Congratulations on making
    it through this monster chapter intact. Data in any programming context is a big
    topic, so take everything you've learned in this chapter as a jumping-off point.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: You already know how to navigate the filesystem, and create, read, update, and
    delete files. You also learned how to effectively work with text, XML, and JSON
    data formats, as well as data streams. And you know how to take an entire object's
    state and serialize or deserialize it into both XML and JSON. All in all, learning
    these skills was no small feat. Don't forget to review and revisit this chapter
    more than once; there's a lot here that might not become second nature on the
    first run-through.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll discuss the basics of generic programming, get a
    little hands-on experience with delegates and events, and wrap up with an overview
    of exception handling.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – data management
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which namespace gives you access to the `Path` and `Directory` classes?
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Unity, what folder path do you use to save data between runs of your game?
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What data type do `Stream` objects use to read and write information to files?
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens when you serialize an object into JSON?
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JOIN us on Discord!
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Join Now!
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
