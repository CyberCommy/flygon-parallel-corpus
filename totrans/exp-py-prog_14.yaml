- en: Chapter 14. Useful Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A design pattern is a reusable, somewhat language-specific solution to a common
    problem in software design. The most popular book on this topic is *Design Patterns:
    Elements of Reusable Object-Oriented Software*, *Addison-Wesley Professional*,
    written by Gamma, Helm, Johnson, and Vlissides, also known as the *Gang of Four*
    or *GoF*. It is considered as a major writing in this area and provides a catalogue
    of 23 design patterns with examples in SmallTalk and C++.'
  prefs: []
  type: TYPE_NORMAL
- en: While designing an application code, these patterns help in solving common problems.
    They ring a bell to all developers since they describe proven development paradigms.
    But they should be studied with the used language in mind, since some of them
    do not make sense in some languages or are already built-in.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter describes the most useful patterns in Python or patterns that
    are interesting to discuss, with implementation examples. The following are the
    three sections that correspond to design pattern categories defined by the GoF:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creational patterns**: These are patterns that are used to generate objects
    with specific behaviors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural patterns**: These are patterns that help in structuring the code
    for specific use cases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavioral patterns**: These are patterns that help in assigning responsibilities
    and encapsulating behaviors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creational patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creational patterns deal with object instantiation mechanism. Such a pattern
    might define a way as to how object instances are created or even how classes
    are constructed.
  prefs: []
  type: TYPE_NORMAL
- en: These are very important patterns in compiled languages such as C or C++, since
    it is harder to generate types on-demand at run time.
  prefs: []
  type: TYPE_NORMAL
- en: 'But creating new types at runtime is pretty straightforward in Python. The
    built-in `type` function lets you define a new type object by code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Classes and types are built-in factories. We already dealt with the creation
    of new class objects and you can interact with class and object generation using
    metaclasses. These features are the basics for implementing the **factory** design
    pattern, but we won't further describe it in this section because we extensively
    covered the topic of class and object creation in [Chapter 3](ch03.html "Chapter 3. Syntax
    Best Practices – above the Class Level"), *Syntax Best Practices – above the Class
    Level*.
  prefs: []
  type: TYPE_NORMAL
- en: Besides factory, the only other creational design pattern from the GoF that
    is interesting to describe in Python is singleton.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Singleton** restricts the instantiation of a class to only a single object
    instance.'
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern makes sure that a given class has always only one living
    instance in the application. This can be used, for example, when you want to restrict
    a resource access to one and only one memory context in the process. For instance,
    a database connector class can be a singleton that deals with synchronization
    and manages its data in memory. It makes the assumption that no other instance
    is interacting with the database in the meantime.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern can simplify a lot the way concurrency is handled in an application.
    Utilities that provide application-wide functions are often declared as singletons.
    For instance, in web applications, a class that is in charge of reserving a unique
    document ID would benefit from the singleton pattern. There should be one and
    only one utility doing this job.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a popular semi-idiom to create singletons in Python by overriding
    the `__new__()` method of a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to create multiple instances of that class and compare their IDs,
    you will find that they all represent the same object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'I call this a semi-idiom because it is a really dangerous pattern. The problem
    starts when you try to subclass your base singleton class and create an instance
    of this new subclass if you already created an instance of the base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This may become even more problematic when you notice that this behavior is
    affected by an instance creation order. Depending on your class usage order, you
    may or may not get the same result. Let''s see what the results are if you create
    the subclass instance first and after that, the instance of the base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the behavior is completely different and very hard to predict.
    In large applications, it may lead to very dangerous and hard-to-debug problems.
    Depending on the run time context, you may or may not use the classes that you
    were meant to. Because such a behavior is really hard to predict and control,
    the application may break because of changed import order or even user input.
    If your singleton is not meant to be subclassed, it may be relatively safe to
    implement that way. Anyway, it's a ticking bomb. Everything may blow up if someone
    disregards the risk in future and decides to create a subclass from your singleton
    object. It is safer to avoid this particular implementation and use an alternative
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a lot safer to use a more advanced technique—metaclasses. By overriding
    the `__call__()` method of a metaclass, you can affect the creation of your custom
    classes. This allows creating a reusable singleton code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By using this `Singleton` as a metaclass for your custom classes, you are able
    to get singletons that are safe to subclass and independent of instance creation
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Another way to overcome the problem of trivial singleton implementation is to
    use what Alex Martelli proposed. He came out with something similar in behavior
    to singleton but completely different in structure. This is not a classical design
    pattern coming from the GoF book, but it seems to be common among Python developers.
    It is called **Borg** or **Monostate**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is quite simple. What really matters in the singleton pattern is not
    the number of living instances a class has, but rather the fact that they all
    share the same state at all times. So, Alex Martelli came up with a class that
    makes all instances of the class share the same `__dict__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This fixes the subclassing issue but is still dependent on how the subclass
    code works. For instance, if `__getattr__` is overridden, the pattern can be broken.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, singletons should not have several levels of inheritance. A class
    that is marked as a singleton is already specific.
  prefs: []
  type: TYPE_NORMAL
- en: That said, this pattern is considered by many developers as a heavy way to deal
    with uniqueness in an application. If a singleton is needed, why not use a module
    with functions instead, since a Python module is already singleton? The most common
    pattern is to define a module-level variable as an instance of a class that needs
    to be singleton. This way, you also don't constrain the developers to your initial
    design.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The singleton factory is an *implicit* way of dealing with the uniqueness of
    your application. You can live without it. Unless you are working in a framework
    à la Java that requires such a pattern, use a module instead of a class.
  prefs: []
  type: TYPE_NORMAL
- en: Structural patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structural patterns are really important in big applications. They decide how
    the code is organized and give developers recipes on how to interact with each
    part of the application.
  prefs: []
  type: TYPE_NORMAL
- en: For a long time, the most well-known implementation of many structural patterns
    in the Python world provided the Zope project with its **Zope Component Architecture**
    (**ZCA**). It implements most of the patterns described in this section and provides
    a rich set of tools to work with them. The ZCA is intended to run not only in
    the Zope framework, but also in other frameworks such as Twisted. It provides
    an implementation of interfaces and adapters among other things.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately (or not), Zope lost almost all of its momentum and is not as popular
    as it used to be. But its ZCA may still be a good reference on implementing structural
    patterns in Python. Baiju Muthukadan created *A Comprehensive Guide to Zope Component
    Architecture*. It is available both in print and freely online (refer to [http://muthukadan.net/docs/zca.html](http://muthukadan.net/docs/zca.html)).
    It was written in 2009, so it does not cover the latest versions of Python but
    should still be a good read because it provides a lot of rationale for some of
    the mentioned patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Python already provides some of the popular structural patterns through its
    syntax. For instance, the class and function decorators can be considered a flavor
    of the **decorator pattern**. Also, support for creating and importing modules
    is an emanation of **module pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of common structural patterns is actually quite long. The original
    *Design Patterns* book featured as many as seven of them and the list was later
    extended by other literature. We won''t discuss all of them but will focus only
    on the three most popular and recognized ones, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: Adapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Adapter** pattern allows the interface of an existing class to be used
    from another interface. In other words, an adapter wraps a class or an object
    *A* so that it works in a context intended for a class or an object *B*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating adapters in Python is actually very straightforward due to how typing
    in this language works. The typing philosophy in Python is commonly referred to
    as duck-typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"If it walks like a duck and talks like a duck, then it''s a duck!"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: According to this rule, if a value for a function or method is accepted, the
    decision should not be based on its type but rather on its interface. So, as long
    as the object behaves as expected, that is, has proper method signatures and attributes,
    its type is considered compatible. This is completely different from many statically
    typed languages where such a thing is rarely available.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, when some code is intended to work with a given class, it is fine
    to feed it with objects from another class as long as they provide the methods
    and attributes used by the code. Of course, this assumes that the code isn't calling
    an `instance` to verify that the instance is of a specific class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The adapter pattern is based on this philosophy and defines a wrapping mechanism
    where a class or an object is wrapped in order to make it work in a context that
    was not primarily intended for it. `StringIO` is a typical example, as it adapts
    the `str` type, so it can be used as a `file` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let's take another example. A `DublinCoreInfos` class knows how to display the
    summary of some subset of Dublin Core information (see [http://dublincore.org/](http://dublincore.org/))
    for a given document provided as a `dict`. It reads a few fields, such as the
    author's name or the title, and prints them. To be able to display Dublin Core
    for a file, it has to be adapted in the same way `StringIO` does. The following
    figure shows a UML-like diagram for such a kind of adapter pattern implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adapter](graphics/B05295_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2 UML diagram for simple adapter pattern example
  prefs: []
  type: TYPE_NORMAL
- en: '`DublinCoreAdapter` wraps a file instance and provides metadata access over
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the example usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Besides the fact that it allows substitution, the adapter pattern can also change
    the way developers work. Adapting an object to work in a specific context makes
    the assumption that the class of the object does not matter at all. What matters
    is that this class implements what `DublinCoreInfo` is waiting for and this behavior
    is fixed or completed by an adapter. So, the code can, somehow, simply tell whether
    it is compatible with objects that are implementing a specific behavior. This
    can be expressed by *interfaces*.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An **interface** is a definition of an API. It describes a list of methods and
    attributes a class should have to implement with the desired behavior. This description
    does not implement any code but just defines an explicit contract for any class
    that wishes to implement the interface. Any class can then implement one or several
    interfaces in whichever way it wants.
  prefs: []
  type: TYPE_NORMAL
- en: While Python prefers duck-typing over explicit interface definitions, it may
    be better to use them sometimes. For instance, explicit interface definition makes
    it easier for a framework to define functionalities over interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit is that classes are loosely coupled, which is considered as a good
    practice. For example, to perform a given process, a class `A` does not depend
    on a class `B`, but rather on an interface `I`. Class `B` implements `I`, but
    it could be any other class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The support for such a technique is built-in in many statically typed languages
    such as Java or Go. The interfaces allow the functions or methods to limit the
    range of acceptable parameter objects that implement a given interface, no matter
    what kind of class it comes from. This allows for more flexibility than restricting
    arguments to given types or their subclasses. It is like an explicit version of
    duck-typing behavior: Java uses interfaces to verify a type safety at compile
    time rather than use duck-typing to tie things together at run time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has a completely different typing philosophy to Java, so it does not
    have native support for interfaces. Anyway, if you would like to have more explicit
    control on application interfaces, there are generally two solutions to choose
    from:'
  prefs: []
  type: TYPE_NORMAL
- en: Use some third-party framework that adds a notion of interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use some of the advanced language features to build your methodology for handling
    interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using zope.interface
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are a few frameworks that allow you to build explicit interfaces in Python.
    The most notable one is a part of the Zope project. It is the `zope.interface`
    package. Although, nowadays, Zope is not as popular as it used to be, the `zope.interface`
    package is still one of the main components of the Twisted framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'The core class of the `zope.interface` package is the `Interface` class. It
    allows you to explicitly define a new interface by subclassing. Let''s assume
    that we want to define the obligatory interface for every implementation of a
    rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Some important things to remember when defining interfaces with `zope.interface`
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The common naming convention for interfaces is to use `I` as the name suffix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The methods of the interface must not take the `self` parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the interface does not provide concrete implementation, it should consist
    only of empty methods. You can use the `pass` statement, raise `NotImplementedError`,
    or provide a docstring (preferred).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interface can also specify the required attributes using the `Attribute`
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you have such a contract defined, you can then define new concrete classes
    that provide implementation for our `IRectangle` interface. In order to do that,
    you need to use the `implementer()` class decorator and implement all of the defined
    methods and attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It is common to say that the interface defines a contract that a concrete implementation
    needs to fulfill. The main benefit of this design pattern is being able to verify
    consistency between contract and implementation before the object is being used.
    With the ordinary duck-typing approach, you only find inconsistencies when there
    is a missing attribute or method at runtime. With `zope.interface`, you can introspect
    the actual implementation using two methods from the `zope.interface.verify` module
    to find inconsistencies early on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`verifyClass(interface, class_object)`: This verifies the class object for
    existence of methods and correctness of their signatures without looking for attributes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`verifyObject(interface, instance)`: This verifies the methods, their signatures,
    and also attributes of the actual object instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we have defined our interface and two concrete implementations, let''s
    verify their contracts in an interactive session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing impressive. The `Rectangle` and `Square` classes carefully follow the
    defined contract so there is nothing more to see than a successful verification.
    But what happens when we make a mistake? Let''s see an example of two classes
    that fail to provide full `IRectangle` interface implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Point` class does not provide any method or attribute of the `IRectangle`
    interface, so its verification will show inconsistencies already on the class
    level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Circle` class is a bit more problematic. It has all the interface methods
    defined but breaks the contract on the instance attribute level. This is the reason
    why, in most cases, you need to use the `verifyObject()` function to completely
    verify the interface implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using `zope.inteface` is an interesting way to decouple your application. It
    allows you to enforce proper object interfaces without the need for the overblown
    complexity of multiple inheritance, and it also allows to catch inconsistencies
    early. However, the biggest downside of this approach is the requirement that
    you explicitly define that the given class follows some interface in order to
    be verified. This is especially troublesome if you need to verify instances coming
    from external classes of built-in libraries. `zope.interface` provides some solutions
    for that problem, and you can of course handle such issues on your own by using
    the adapter pattern, or even monkey-patching. Anyway, the simplicity of such solutions
    is at least arguable.
  prefs: []
  type: TYPE_NORMAL
- en: Using function annotations and abstract base classes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Design patterns are meant to make problem solving easier and not to provide
    you with more layers of complexity. The `zope.interface` is a great concept and
    may greatly fit some projects, but it is not a silver bullet. By using it, you
    may soon find yourself spending more time on fixing issues with incompatible interfaces
    for third-party classes and providing never-ending layers of adapters instead
    of writing the actual implementation. If you feel that way, then this is a sign
    that something went wrong. Fortunately, Python supports for building lightweight
    alternative to the interfaces. It's not a full-fledged solution like `zope.interface`
    or its alternatives but it generally provides more flexible applications. You
    may need to write a bit more code, but in the end you will have something that
    is more extensible, better handles external types, and may be more *future proof*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that Python in its core does not have explicit notions of interfaces,
    and probably will never have, but has some of the features that allow you to build
    something that resembles the functionality of interfaces. The features are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstract base classes** (**ABCs**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core of our solution is abstract base classes, so we will feature them first.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you probably know, the direct type comparison is considered harmful and
    not *pythonic*. You should always avoid comparisons as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Comparing types in functions or methods that way completely breaks the ability
    to pass a class subtype as an argument to the function. The slightly better approach
    is to use the `isinstance()` function that will take the inheritance into account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The additional advantage of `isinstance()` is that you can use a larger range
    of types to check the type compatibility. For instance, if your function expects
    to receive some sort of sequence as the argument, you can compare against the
    list of basic types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Such a way of type compatibility checking is OK in some situations but it is
    still not perfect. It will work with any subclass of `list`, `tuple`, or `range`,
    but will fail if the user passes something that behaves exactly the same as one
    of these sequence types but does not inherit from any of them. For instance, let's
    relax our requirements and say that you want to accept any kind of iterable as
    an argument. What would you do? The list of basic types that are iterable is actually
    pretty long. You need to cover list, tuple, range, str, bytes, dict, set, generators,
    and a lot more. The list of applicable built-in types is long, and even if you
    cover all of them it will still not allow you to check against the custom class
    that defines the `__iter__()` method, but will instead inherit directly from `object`.
  prefs: []
  type: TYPE_NORMAL
- en: And this is the kind of situation where abstract base classes (ABC) are the
    proper solution. ABC is a class that does not need to provide a concrete implementation
    but instead defines a blueprint of a class that may be used to check against type
    compatibility. This concept is very similar to the concept of abstract classes
    and virtual methods known in the C++ language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Abstract base classes are used for two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking for implementation completeness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for implicit interface compatibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, let''s assume we want to define an interface which ensures that a class
    has a `push()` method. We need to create a new abstract base class using a special
    `ABCMeta` metaclass and an `abstractmethod()` decorator from the standard `abc`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `abc` module also provides an ABC base class that can be used instead of
    the metaclass syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it is done, we can use that `Pushable` class as a base class for concrete
    implementation and it will guard us from the instantiation of objects that would
    have incomplete implementation. Let''s define `DummyPushable`, which implements
    all interface methods and the `IncompletePushable` that breaks the expected contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to obtain the `DummyPushable` instance, there is no problem because
    it implements the only required `push()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'But if you try to instantiate `IncompletePushable`, you will get `TypeError`
    because of missing implementation of the `interface()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding approach is a great way to ensure implementation completeness
    of base classes but is as explicit as the `zope.interface` alternative. The `DummyPushable`
    instances are of course also instances of `Pushable` because Dummy is a subclass
    of `Pushable`. But how about other classes with the same methods but not descendants
    of `Pushable`? Let''s create one and see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Something is still missing. The `SomethingWithPush` class definitely has a compatible
    interface but is not considered as an instance of `Pushable` yet. So, what is
    missing? The answer is the `__subclasshook__(subclass)` method that allows you
    to inject your own logic into the procedure that determines whether the object
    is an instance of a given class. Unfortunately, you need to provide it by yourself,
    as `abc` creators did not want to constrain the developers in overriding the whole
    `isinstance()` mechanism. We got full power over it, but we are forced to write
    some boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although you can do whatever you want to, usually the only reasonable thing
    to do in the `__subclasshook__()` method is to follow the common pattern. The
    standard procedure is to check whether the set of defined methods are available
    somewhere in the MRO of the given class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `__subclasshook__()` method defined that way, you can now confirm
    that the instances that implement the interface implicitly are also considered
    instances of the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this approach to the verification of type compatibility and implementation
    completeness does not take into account the signatures of class methods. So, if
    the number of expected arguments is different in implementation, it will still
    be considered compatible. In most cases, this is not an issue, but if you need
    such fine-grained control over interfaces, the `zope.interface` package allows
    for that. As already said, the `__subclasshook__()` method does not constrain
    you in adding more complexity to the `isinstance()` function's logic to achieve
    a similar level of control.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two other features that complement abstract base classes are function annotations
    and type hints. Function annotation is the syntax element described briefly in
    [Chapter 2](ch02.html "Chapter 2. Syntax Best Practices – below the Class Level"),
    *Syntax Best Practices – below the Class Level*. It allows you to annotate functions
    and their arguments with arbitrary expressions. As explained in [Chapter 2](ch02.html
    "Chapter 2. Syntax Best Practices – below the Class Level"), *Syntax Best Practices
    – below the Class Level*, this is only a feature stub that does not provide any
    syntactic meaning. There is no utility in the standard library that uses this
    feature to enforce any behavior. Anyway, you can use it as a convenient and lightweight
    way to inform the developer of the expected argument interface. For instance,
    consider this `IRectangle` interface rewritten from `zope.interface` to abstract
    the base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a function that works only on rectangles, let''s say `draw_rectangle()`,
    you could annotate the interface of the expected argument as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This adds nothing more than information for the developer about expected information.
    And even this is done through an informal contract because, as we know, bare annotations
    contain no syntactic meaning. However, they are accessible at runtime, so we can
    do something more. Here is an example implementation of a generic decorator that
    is able to verify interface from function annotation if it is provided using abstract
    base classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it is done, we can create some concrete class that implicitly implements
    the `IRectangle` interface (without inheriting from `IRectangle`) and update the
    implementation of the `draw_rectangle()` function to see how the whole solution
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we feed the `draw_rectangle()` function with an incompatible object, it
    will now raise `TypeError` with a meaningful explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'But if we use `ImplicitRectangle` or anything else that resembles the `IRectangle`
    interface, the function executes as it should:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Our example implementation of `ensure_interface()` is based on the `typechecked()`
    decorator from the `typeannotations` project that tries to provide run-time checking
    capabilities (refer to [https://github.com/ceronman/typeannotations](https://github.com/ceronman/typeannotations)).
    Its source code might give you some interesting ideas about how to process type
    annotations to ensure run-time interface checking.
  prefs: []
  type: TYPE_NORMAL
- en: The last feature that can be used to complement this interface pattern landscape
    are type hints. Type hints are described in detail by PEP 484 and were added to
    the language quite recently. They are exposed in the new `typing` module and are
    available from Python 3.5\. Type hints are built on top of function annotations
    and reuse this slightly forgotten syntax feature of Python 3\. They are intended
    to guide type hinting and check for various *yet-to-come* Python type checkers.
    The `typing` module and PEP 484 document aim to provide a standard hierarchy of
    types and classes that should be used for describing type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Still, type hints do not seem to be something revolutionary because this feature
    does not come with any type checker built-in into the standard library. If you
    want to use type checking or enforce strict interface compatibility in your code,
    you need to create your own tool because there is none worth recommendation yet.
    This is why we won't dig into details of PEP 484\. Anyway, type hints and the
    documents describing them are worth mentioning because if some extraordinary solution
    emerges in the field of type checking in Python, it is highly probable that it
    will be based on PEP 484.
  prefs: []
  type: TYPE_NORMAL
- en: Using collections.abc
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Abstract base classes are like small building blocks for creating a higher level
    of abstraction. They allow you to implement really usable interfaces but are very
    generic and designed to handle lot more than this single design pattern. You can
    unleash your creativity and do magical things but building something generic and
    really usable may require a lot of work. Work that may never pay off.
  prefs: []
  type: TYPE_NORMAL
- en: This is why custom abstract base classes are not used so often. Despite that,
    the `collections.abc` module provides a lot of predefined ABCs that allow to verify
    interface compatibility of many basic Python types. With base classes provided
    in this module, you can check, for example, whether a given object is callable,
    mapping, or if it supports iteration. Using them with the `isinstance()` function
    is way better than comparing them against the base python types. You should definitely
    know how to use these base classes even if you don't want to define your own custom
    interfaces with `ABCMeta`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common abstract base classes from `collections.abc` that you will
    use from time to time are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Container`: This interface means that the object supports the `in` operator
    and implements the `__contains__()` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Iterable`: This interface means that the object supports the iteration and
    implements the `__iter__()` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Callable`: This interface means that it can be called like a function and
    implements the `__call__()` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hashable`: This interface means that the object is hashable (can be included
    in sets and as key in dictionaries) and implements the `__hash__` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sized`: This interface means that the object has size (can be a subject of
    the `len()` function) and implements the `__len__()` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A full list of the available abstract base classes from the `collections.abc`
    module is available in the official Python documentation (refer to [https://docs.python.org/3/library/collections.abc.html](https://docs.python.org/3/library/collections.abc.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Proxy** provides indirect access to an expensive or a distant resource. A
    **Proxy** is between a **Client** and a **Subject**, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Proxy](graphics/B05295_14_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is intended to optimize Subject accesses if they are expensive. For instance,
    the `memoize()` and `lru_cache()` decorators described in [Chapter 12](ch12.html
    "Chapter 12. Optimization – Some Powerful Techniques"), *Optimization – Some Powerful
    Techniques*, can be considered as proxies.
  prefs: []
  type: TYPE_NORMAL
- en: A proxy can also be used to provide smart access to a subject. For instance,
    big video files can be wrapped into proxies to avoid loading them into memory
    when the user just asks for their titles.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example is given by the `urllib.request` module. `urlopen` is a proxy for
    the content located at a remote URL. When it is created, headers can be retrieved
    independently from the content itself without the need to read the rest of the
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be used to decide whether the page has been changed before getting
    its body to update a local copy, by looking at the `last-modified` header. Let''s
    take an example with a big file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Another use case of proxies is **data uniqueness**.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's consider a website that presents the same document in several
    locations. Extra fields specific to each location are appended to the document,
    such as a hit counter and a few permission settings. A proxy can be used in that
    case to deal with location-specific matters and also to point to the original
    document instead of copying it. So, a given document can have many proxies, and
    if its content changes, all locations will benefit from it without having to deal
    with version synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally speaking, proxy pattern is useful for implementing a local handle
    of something that may live somewhere else to:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the process faster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid external resource access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce memory load
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure data uniqueness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facade
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Facade** provides high-level, simpler access to a subsystem.'
  prefs: []
  type: TYPE_NORMAL
- en: A facade is nothing but a shortcut to use a functionality of the application,
    without having to deal with the underlying complexity of a subsystem. This can
    be done, for instance, by providing high-level functions at the package level.
  prefs: []
  type: TYPE_NORMAL
- en: Facade is usually done on existing systems, where a package's frequent usage
    is synthesized in high-level functions. Usually, no classes are needed to provide
    such a pattern and simple functions in the `__init__.py` module are sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: A good example of project that provides a big facade over complicated and complex
    interfaces is the `requests` package (refer to [http://docs.python-requests.org/](http://docs.python-requests.org/)).
    It really simplifies the madness of dealing with HTTP requests and responses in
    Python by providing a clean API that is easily readable to developers. It is actually
    even advertised as *HTTP for humans*. Such ease of use always comes at some price
    but eventual tradeoffs and additional overhead does not scare most people from
    using the Requests project as their HTTP tool of choice. In the end, it allows
    us to finish projects faster and a developer's time is usually more expensive
    than hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Facade simplifies the usage of your packages. Facades are usually added after
    a few iterations with usage feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Behavioral patterns are intended to simplify the interactions between classes
    by structuring the processes of their interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section provides three examples of popular behavioral patterns that you
    may want to consider when writing Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: Observer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **observer** pattern is used to notify a list of objects about a state change
    of the observed component.
  prefs: []
  type: TYPE_NORMAL
- en: Observer allows adding features in an application in a pluggable way by de-coupling
    the new functionality from the existing code base. An event framework is a typical
    implementation of the observer pattern and is described in the figure that follows.
    Every time an event occurs, all observers for this event are notified with the
    subject that has triggered this event.
  prefs: []
  type: TYPE_NORMAL
- en: An event is created when something happens. In graphical user interface applications,
    event-driven programming (see [http://en.wikipedia.org/wiki/Event-driven_programming](http://en.wikipedia.org/wiki/Event-driven_programming))
    is often used to link the code to user actions. For instance, a function can be
    linked to the `MouseMove` event so it is called every time the mouse moves over
    the window.
  prefs: []
  type: TYPE_NORMAL
- en: In case of GUI application, de-coupling the code from the window management
    internals simplifies the work a lot. Functions are written separately and then
    registered as event observers. This approach exists from the earliest versions
    of Microsoft's MFC framework (see [http://en.wikipedia.org/wiki/Microsoft_Foundation_Class_Library](http://en.wikipedia.org/wiki/Microsoft_Foundation_Class_Library))
    and in all GUI development tools such as Qt or GTK. Many frameworks use the notion
    of *signals*, but they are simply another manifestation of the observer pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The code can also generate events. For instance, in an application that stores
    documents in a database, `DocumentCreated`, `DocumentModified`, and `DocumentDeleted`
    can be three events provided by the code. A new feature that works on documents
    can register itself as an observer to get notified every time a document is created,
    modified, or deleted and do the appropriate work. A document indexer could be
    added that way in an application. Of course, this requires that all the code in
    charge of creating, modifying, or deleting documents is triggering events. But
    this is rather easier than adding indexing hooks all over the application code
    base! A popular web framework that follows this pattern is Django with its mechanism
    of signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `Event` class can be implemented for the registration of observers in Python
    by working at the class level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea is that observers register themselves using the `Event` class method
    and get notified with `Event` instances that carry the subject that triggered
    them. Here is an example of the concrete `Event` subclass with some observers
    subscribed to its notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is an example result of firing the event with the `WriteEvent.notify()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This implementation is simple and serves only as illustrational purposes. To
    make it fully functional, it could be enhanced by:'
  prefs: []
  type: TYPE_NORMAL
- en: Allowing the developer to change the order or events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the event object hold more information than just the subject
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: De-coupling your code is fun and the observer is the right pattern to do it.
    It componentizes your application and makes it more extensible. If you want to
    use an existing tool, try **Blinker** (refer to [https://pythonhosted.org/blinker/](https://pythonhosted.org/blinker/)).
    It provides fast and simple object-to-object and broadcast signaling for Python
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Visitor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Visitor** helps in separating algorithms from data structures and has a similar
    goal to that of the observer pattern. It allows extending the functionalities
    of a given class without changing its code. But the visitor goes a bit further
    by defining a class that is responsible for holding data and pushes the algorithms
    to other classes called `Visitors`. Each visitor is specialized in one algorithm
    and can apply it on the data.'
  prefs: []
  type: TYPE_NORMAL
- en: This behavior is quite similar to the MVC paradigm (refer to [http://en.wikipedia.org/wiki/Model-view-controller](http://en.wikipedia.org/wiki/Model-view-controller)),
    where documents are passive containers pushed to views through controllers, or
    where models contain data that is altered by a controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visitor pattern is implemented by providing an entry point in the data class
    that can be visited by all kinds of visitors. A generic description is a `Visitable`
    class that accepts `Visitor` instances and calls them, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visitor](graphics/B05295_14_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Visitable` class decides how it calls the `Visitor` class, for instance,
    by deciding which method is called. For example, a visitor in charge of printing
    built-in type content can implement the `visit_TYPENAME()` methods, and each of
    these types can call the given method in its `accept()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This is done as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: But this pattern means that each visited class needs to have an `accept` method
    to be visited, which is quite painful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Python allows code introspection, a better idea is to automatically link
    visitors and visited classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This pattern is used in this way in the `ast` module, for instance, by the `NodeVisitor`
    class that calls the visitor with each node of the compiled code tree. This is
    because Python doesn't have a match operator like Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example is a directory walker that calls Visitor methods depending
    on the file extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If your application has data structures that are visited by more than one algorithm,
    the Visitor pattern will help in separating concerns. It is better for a data
    container to focus only on providing access to data and holding them, and nothing
    else.
  prefs: []
  type: TYPE_NORMAL
- en: Template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Template** helps in designing a generic algorithm by defining abstract steps
    which are implemented in subclasses. This pattern uses the **Liskov substitution
    principle**, which is defined by Wikipedia as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"If S is a subtype of T, then objects of type T in a program may be replaced
    with objects of type S without altering any of the desirable properties of that
    program."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In other words, an abstract class can define how an algorithm works through
    steps that are implemented in concrete classes. The abstract class can also give
    a basic or partial implementation of the algorithm and let developers override
    its parts. For instance, some methods of the `Queue` class in the `queue` module
    can be overridden to make its behavior vary.
  prefs: []
  type: TYPE_NORMAL
- en: Let's implement an example, as shown in the figure that follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Template](graphics/B05295_14_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`Indexer` is an indexer class that processes a text in five steps, which are
    common steps no matter what indexing technique is used:'
  prefs: []
  type: TYPE_NORMAL
- en: Text normalization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text split
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop words removal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stem words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frequency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `Indexer` provides partial implementation for the process algorithm but requires
    `_remove_stop_words` and `_stem_words` to be implemented in a subclass. `BasicIndexer`
    implements the strict minimum, while `LocalIndex` uses a stop word file and a
    stem words database. `FastIndexer` implements all steps and could be based on
    a fast indexer such as **Xapian** or **Lucene**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A toy implementation can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'From there, a `BasicIndexer` implementation can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'And, like always, here is an example usage for the preceding example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Template should be considered for an algorithm that may vary and can be expressed
    into isolated substeps. This is probably the most used pattern in Python and does
    not always needs to be implemented via subclassing. For instance, a lot of built-in
    Python functions that deal with algorithmic problems accept arguments that allow
    you to delegate part of the implementation to external implementation. For instance,
    the `sorted()` function allows for an optional `key` keyword argument that is
    later used by a sorting algorithm. This is also the same for `min()` and `max()`
    functions that find minimum and maximum values in the given collection.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design patterns are reusable, somewhat language-specific solutions to common
    problems in software design. They are a part of the culture of all developers,
    no matter what language they use.
  prefs: []
  type: TYPE_NORMAL
- en: So, using implementation examples for the most used patterns for a given language
    is a great way to document that. Both on the Web and in other books, you will
    easily find implementation for every design pattern mentioned in GoF books. This
    is why we concentrated only on patterns that are the most common and popular in
    the context of the Python language.
  prefs: []
  type: TYPE_NORMAL
