- en: Chapter 4. Porting and Configuring the Kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The kernel is the third element of embedded Linux. It is the component that
    is responsible for managing resources and interfacing with hardware and so affects
    almost every aspect of your final software build. It is usually tailored to your
    particular hardware configuration although, as we saw in [Chapter 3](ch03.html
    "Chapter 3. All About Bootloaders"), *All About Bootloaders*, device trees allow
    you to create a generic kernel that is tailored to particular hardware by the
    contents of the device tree.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at how to get a kernel for a board and how to
    configure and compile it. We will look again at bootstrap, this time focusing
    on the part the kernel plays. We will also look at device drivers and how they
    pick up information from the device tree.
  prefs: []
  type: TYPE_NORMAL
- en: What does the kernel do?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux began in 1991 when Linus Torvalds started writing an operating system
    for Intel 386 and 486-based personal computers. He was inspired by the Minix operating
    system written by Andrew S. Tanenbaum four years earlier. Linux differed in many
    ways from Minix, the main differences being that it was a 32-bit virtual memory
    kernel and the code was open source, later released under the GPL 2 license.
  prefs: []
  type: TYPE_NORMAL
- en: He announced it on the 25th August 1991 on the *comp.os.minix* newsgroup in
    a famous post that begins as *Hello everybody out there using minix - I'm doing
    a (free) operating system (just a hobby, won't be big and professional like gnu)
    for 386(486) AT clones. This has been brewing since april, and is starting to
    get ready. I'd like any feedback on things people like/dislike in minix, as my
    OS resembles it somewhat (same physical layout of the file-system (due to practical
    reasons) among other things)*.
  prefs: []
  type: TYPE_NORMAL
- en: To be strictly accurate, Linus did not write an operating system, he wrote a
    kernel instead, which is one component of an operating system. To create a working
    system, he used components from the GNU project, especially the toolchain, C library,
    and basic command-line tools. That distinction remains today, and gives Linux
    a lot of flexibility in the way it is used. It can be combined with a GNU user
    space to create a full Linux distribution that runs on desktops and servers, which
    is sometimes called GNU/Linux; it can be combined with an Android user space to
    create the well-known mobile operating system or it can be combined with a small
    Busybox-based user space to create a compact embedded system. Contrast this with
    the BSD operating systems, FreeBSD, OpenBSD, and NetBSD, in which the kernel,
    the toolchain, and the user space are combined into a single code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel has three main jobs: to manage resources, to interface with hardware,
    and to provide an API that offers a useful level of abstraction to user space
    programs, as summarized in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What does the kernel do?](img/B03982_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Applications running in user space run at a low CPU privilege level. They can
    do very little other than make library calls. The primary interface between the
    user space and the kernel space is the C library, which translates user level
    functions such as those defined by POSIX into kernel system calls. The system
    call interface uses an architecture-specific method such as a trap or a software
    interrupt to switch the CPU from the low privilege user mode to the high privilege
    kernel mode, which allows access to all memory addresses and CPU registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The system call handler dispatches the call to the appropriate kernel subsystem:
    scheduling calls to the scheduler, the filesystem, calls to the filesystem code,
    and so on. Some of those calls require input from the underlying hardware and
    will be passed down to a device driver. In some cases, the hardware itself invokes
    a kernel function by raising an interrupt. Interrupts can only be handled in a
    device driver, never by a user space application.'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, all the useful things that your application does, it does them
    through the kernel. The kernel, then, is one of the most important elements in
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to choose the kernel for your project, balancing the desire
    to always use the latest version of software against the need for vendor-specific
    additions.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel development cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Linux has been developed at a fast pace, with a new version being released
    every 8 to 12 weeks. The way that the version numbers are constructed has changed
    a bit in recent years. Before July 2011, there was a three number version scheme
    with version numbers that looked like 2.6.39\. The middle number indicated whether
    it was a developer or stable release, odd numbers (2.1.x, 2.3.x, 2.5.x) were for
    developers and even numbers were for end users. From version 2.6 onwards, the
    idea of a long-lived development branch (the odd numbers) was dropped as it slowed
    down the rate at which new features were made available to users. The change in
    numbering from 2.6.39 to 3.0 in July 2011 was purely because Linus felt that the
    numbers were becoming too large: there was no huge leap in the features or architecture
    of Linux between those two versions. He also took the opportunity to drop the
    middle number. Since then, in April 2015, he bumped the major from 3 to 4, again
    purely for neatness, not because of any large architectural shift.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Linus manages the development kernel tree. You can follow him by cloning his
    git tree like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will check out into subdirectory `linux`. You can keep up to date by running
    the command `git pull` in that directory from time to time.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, a full cycle of kernel development begins with a merge window of
    two weeks, during which Linus will accept patches for new features. At the end
    of the merge window, a stabilization phase begins, during which Linus will produce
    release candidates with version numbers ending in -rc1, -rc2, and so on, usually
    up to -rc7 or -rc8\. During this time, people test the candidates and submit bug
    reports and fixes. When all significant bugs have been fixed, the kernel is released.
  prefs: []
  type: TYPE_NORMAL
- en: The code incorporated during the merge window has to be fairly mature already.
    Usually, it is pulled from the repositories of the many subsystem and architecture
    maintainers of the kernel. By keeping to a short development cycle, features can
    be merged when they are ready. If a feature is deemed not sufficiently stable
    or well developed by the kernel maintainers, it can simply be delayed until the
    next release.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping a track of what has changed from release to release is not easy. You
    can read the commit log in Linus' git repository but, with roughly 10,000 or more
    entries per release, it is not easy to get an overview. Thankfully, there is the
    *Linux Kernel Newbies* website, [http://kernelnewbies.org](http://kernelnewbies.org)
    where you will find a succinct overview of each version, at [http://kernelnewbies.org/LinuxVersions](http://kernelnewbies.org/LinuxVersions).
  prefs: []
  type: TYPE_NORMAL
- en: Stable and long term support releases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The rapid rate of change of Linux is a good thing in that it brings new features
    into the mainline code base, but it does not fit very well with the longer life
    cycle of embedded projects. Kernel developers address this in two ways. Firstly,
    it is acknowledged that a release may contain bugs that need to be fixed before
    the next kernel release comes around. That is the role of the stable Linux kernel,
    maintained by Greg Kroah-Hartman. After release, the kernel moves from being **mainline**
    (maintained by Linus) to **stable** (maintained by Greg). Bug fix releases of
    the stable kernel are marked by a third number, 3.18.1, 3.18.2, and so on. Before
    version 3, there were four release numbers, 2.6.29.1, 2.6.39.2, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the stable tree by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `git chckout` to get a particular version, for example version
    4.1.10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Usually, the stable kernel is maintained only until the next mainline release,
    8 to 12 weeks later, so you will see that there is just one or sometimes two stable
    kernels at [kernel.org](http://kernel.org). To cater for those users who would
    like updates for a longer period of time and be assured that any bugs will be
    found and fixed, some kernels are labeled **long term** and maintained for two
    or more years. There is at least one long term kernel each year. Looking at [kernel.org](http://kernel.org)
    at the time of writing, there are a total of eight long term kernels: 4.1, 3.18,
    3.14, 3.12, 3.10, 3.4, 3.2, and 2.6.32\. The latter has been maintained for five
    years and is at version 2.6.32.68\. If you are building a product that you will
    have to maintain for this length of time the latest long term kernel might well
    be a good choice.'
  prefs: []
  type: TYPE_NORMAL
- en: Vendor support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In an ideal world, you would be able to download a kernel from [kernel.org](http://kernel.org)
    and configure it for any device that claims to support Linux. However, that is
    not always possible: in fact mainline Linux has solid support for only a small
    subset of the many devices that can run Linux. You may find support for your board
    or SoC from independent open source projects, Linaro or the Yocto Project, for
    example, or from companies providing third party support for embedded Linux, but
    in many cases you will be obliged to look to the vendor of your SoC or board for
    a working kernel. As we also know, some are better than others.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: My only advice at this point is to choose vendors who give good support or who,
    even better, take the trouble to get their kernel changes into the mainline.
  prefs: []
  type: TYPE_NORMAL
- en: Licensing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Linux source code is licensed under GPL v2, which means that you must make
    the source code of your kernel available in one of the ways specified in the license.
  prefs: []
  type: TYPE_NORMAL
- en: The actual text of the license for the kernel is in the file `COPYING`. It begins
    with an addendum written by Linus that states that code calling the kernel from
    user space via the system call interface is not considered a derivative work of
    the kernel and so is not covered by the license. Hence, there is no problem with
    proprietary applications running on top of Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is one area of Linux licensing that causes endless confusion
    and debate: kernel modules. A kernel module is simply a piece of code that is
    dynamically linked with the kernel at runtime, thereby extending the functionality
    of the kernel. The GPL makes no distinction between static and dynamic linking,
    so it would appear that the source for kernel modules is covered by the GPL. But,
    in the early days of Linux, there were debates about exceptions to this rule,
    for example, in connection with the Andrew filesystem. This code predates Linux
    and therefore (it was argued) is not a derivative work, and so the license does
    not apply. Similar discussions took place over the years with respect to other
    pieces of code, with the result that it is now accepted practice that the GPL
    does not necessarily apply to kernel modules. This is codified by the kernel `MODULE_LICENSE`
    macro, which may take the value `Proprietary` to indicate that it is not released
    under the GPL. If you plan to use the same arguments yourself, you may want to
    read though an oft-quoted email thread titled *Linux GPL and binary module exception
    clause?* ([http://yarchive.net/comp/linux/gpl_modules.html](http://yarchive.net/comp/linux/gpl_modules.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: The GPL should be considered a good thing because it guarantees that when you
    and I are working on embedded projects, we can always get the source code for
    the kernel. Without it, embedded Linux would be much harder to use and more fragmented.
  prefs: []
  type: TYPE_NORMAL
- en: Building the kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having decided which kernel to base your build on, the next step is to build
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s assume that you have a board that is supported in mainline. You can
    get the source code through git or by downloading a tarball. Using git is better
    because you can see the commit history, you can easily see any changes you may
    make and you can switch between branches and versions. In this example, we are
    cloning the stable tree and checking out the version tag 4.1.10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you could download the tarball from [https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.1.10.tar.xz](https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.1.10.tar.xz).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a lot of code here. There are over 38,000 files in the 4.1 kernel
    containing C source code, header files, and assembly code, amounting to a total
    of over 12.5 million lines of code (as measured by the cloc utility). Nevertheless,
    it is worth knowing the basic layout of the code and to know, approximately, where
    to look for a particular component. The main directories of interest are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arch`: This contains architecture-specific files. There is one subdirectory
    per architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Documentation`: This contains kernel documentation. Always look here first
    if you want to find more information about an aspect of Linux.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drivers`: This contains device drivers, thousands of them. There is a subdirectory
    for each type of driver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fs`: This contains filesystem code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include`: This contains kernel header files, including those required when
    building the toolchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init`: This contains the kernel start-up code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kernel`: This contains core functions, including scheduling, locking, timers,
    power management, and debug/trace code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mm`: This contains memory management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net`: This contains network protocols.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scripts`: This contains many useful scripts including the device tree compiler,
    dtc, which I described in [Chapter 3](ch03.html "Chapter 3. All About Bootloaders"),
    *All About Bootloaders*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tools`: This contains many useful tools, including the Linux performance counters
    tool, perf, which I will describe in [Chapter 13](ch13.html "Chapter 13. Profiling
    and Tracing"), *Profiling and Tracing*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Over a period of time, you will become familiar with this structure, and realize
    that, if you are looking for the code for the serial port of a particular SoC,
    you will find it in `drivers/tty/serial` and not in `arch/$ARCH/mach-foo` because
    it is a device driver and not something central to the running of Linux on that
    SoC.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding kernel configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the strengths of Linux is the degree to which you can configure the kernel
    to suit different jobs, from a small dedicated device such as a smart thermostat
    to a complex mobile handset. In current versions there are many thousands of configuration
    options. Getting the configuration right is a task in itself but, before that,
    I want to show you how it works so that you can better understand what is going
    on.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration mechanism is called `Kconfig`, and the build system that it
    integrates with is called `Kbuild`. Both are documented in `Documentation/kbuild/`.
    `Kconfig/Kbuild` is used in a number of other projects as well as the kernel,
    including crosstool-NG, U-Boot, Barebox, and BusyBox.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration options are declared in a hierarchy of files named `Kconfig`
    using a syntax described in `Documentation/kbuild/kconfig-language.txt`. In Linux,
    the top level `Kconfig` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line includes the architecture-dependent configuration file which
    sources other `Kconfig` files depending on which options are enabled. Having the
    architecture play such a role has two implications: firstly, that you must specify
    an architecture when configuring Linux by setting `ARCH=[architecture]`, otherwise
    it will default to the local machine architecture, and second that the layout
    of the top level menu is different for each architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: The value you put into `ARCH` is one of the subdirectories you find in directory
    `arch`, with the oddity that `ARCH=i386` and `ARCH=x86_64` both have the source
    `arch/x86/Kconfig`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Kconfig` files consist largely of menus, delineated by `menu`, `menu title`,
    and `endmenu` keywords, and menu items marked by `config`. Here is an example,
    taken from `drivers/char/Kconfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter following `config` names a variable that, in this case, is `DEVMEM`.
    Since this option is a Boolean, it can only have two values: if it is enabled
    it is assigned to `y`, if not the variable is not defined at all. The name of
    the menu item that is displayed on the screen is the string following the `bool`
    keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This configuration item, along with all the others, is stored in a file named
    `.config` (note that the leading dot ''`.`'' means that it is a hidden file that
    will not be shown by the `ls` command unless you type `ls -a` to show all files).
    The variable names stored in `.config` are prefixed with `CONFIG_`, so if `DEVMEM`
    is enabled, the line reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several other data types in addition to `bool`. Here is the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bool`: This is either `y` or not defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tristate`: This is used where a feature can be built as a kernel module or
    built into the main kernel image. The values are `m` for a module, `y` to be built
    in, and not defined if the feature is not enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: This is an integer value written using decimal notation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hex`: This is an unsigned integer value written using hexadecimal notation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`: This is a string value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There may be dependencies between items, expressed by the `depends on` phrase,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If `CONFIG_MTD` has not been enabled elsewhere, this menu option is not shown
    and so cannot be selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also reverse dependencies: the `select` keyword enables other options
    if this one is enabled. The `Kconfig` file in `arch/$ARCH` has a large number
    of `select` statements that enable features specific to the architecture, as can
    be seen here for arm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There are several configuration utilities that can read the `Kconfig` files
    and produce a `.config` file. Some of them display the menus on screen and allow
    you to make choices interactively. `Menuconfig` is probably the one most people
    are familiar with, but there is also `xconfig` and `gconfig`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You launch each one via `make`, remembering that, in the case of the kernel,
    you have to supply an architecture, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see `menuconfig` with the `DEVMEM` `config` option highlighted
    in the previous paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding kernel configuration](img/B03982_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Kernel configuration using menuconfig
  prefs: []
  type: TYPE_NORMAL
- en: The star (`*)` to the left of an item means that it is selected (`="y"`) or,
    if it is an `M,` that it has been selected to be built as a kernel module.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You often see instructions like `enable CONFIG_BLK_DEV_INITRD,` but with so
    many menus to browse through, it can take a while to find the place where that
    configuration is set. All configuration editors have a `search` function. You
    can access it in `menuconfig` by pressing the forward slash key, `/`. In xconfig,
    it is in the edit menu but, in this case make sure you miss off the `CONFIG_`
    part of the variable you are searching for.
  prefs: []
  type: TYPE_NORMAL
- en: 'With so many things to configure, it is unreasonable to start with a clean
    sheet each time you want to build a kernel so there are a set of known working
    configuration files in `arch/$ARCH/configs`, each containing suitable configuration
    values for a single SoC or a group of SoCs. You can select one with `make [configuration
    file name]`. For example, to configure Linux to run on a wide range of SoCs using
    the armv7-a architecture, which includes the BeagleBone Black AM335x, you would
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is a generic kernel that runs on various different boards. For a more specialized
    application, for example when using a vendor-supplied kernel, the default configuration
    file is part of the board support package; you will need to find out which one
    to use before you can build the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another useful configuration target named `oldconfig`. This takes
    an exiting `.config` file and asks you to supply configuration values for any
    options that don''t have them. You would use it when moving a configuration to
    a newer kernel version: copy `.config` from the old kernel to the new source directory
    and run `make ARCH=arm oldconfig` to bring it up to date. It can also be used
    to validate a `.config` file that you have edited manually (ignoring the text
    `Automatically generated file; DO NOT EDIT` that occurs at the top: sometimes
    it is OK to ignore warnings).'
  prefs: []
  type: TYPE_NORMAL
- en: If you do make changes to the configuration, the modified `.config` file becomes
    part of your device and needs to be placed under source code control.
  prefs: []
  type: TYPE_NORMAL
- en: When you start the kernel build, a header file, `include/generated/autoconf.h`,
    is generated which contains a `#define` for each configuration value so that it
    can be included in the kernel source, exactly as with U-Boot.
  prefs: []
  type: TYPE_NORMAL
- en: Using LOCALVERSION to identify your kernel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can discover the kernel version that you have built using the `make kernelversion`
    target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is reported at runtime through the `uname` command and is also used in
    naming the directory where kernel modules are stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you change the configuration from the default it is advisable to append
    your own version information, which you can configure by setting `CONFIG_LOCALVERSION`,
    which you will find in the **General setup configuration** menu. It is also possible
    (but discouraged) to do the same by editing the top level makefile and appending
    it to the line that begins with `EXTRAVERSION`. As an example, if I wanted to
    mark the kernel I am building with an identifier `melp` and version 1.0, I would
    define the local version in the `.config` file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `make kernelversion` produces the same output as before but now, if
    I run `make kernelrelease,` I see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also printed at the beginning of the kernel log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: I can now identify and track my custom kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I have mentioned kernel modules several times already. Desktop Linux distributions
    use them extensively so that the correct device and kernel functions can be loaded
    at runtime depending on the hardware detected and features required. Without them,
    every single driver and feature would have to be statically linked in to the kernel,
    making it unfeasibly large.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, with embedded devices, the hardware and kernel configuration
    is usually known at the time the kernel is built so modules are not so useful.
    In fact, they cause a problem because they create a version dependency between
    the kernel and the root filesystem which can cause boot failures if one is updated
    but not the other. Consequently, it is quite common for embedded kernels to be
    built without any modules at all. Here are a few cases where kernel modules are
    a good idea:'
  prefs: []
  type: TYPE_NORMAL
- en: When you have proprietary modules, for the licensing reasons given in the preceding
    section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To reduce boot time by deferring the loading of non-essential drivers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When there are a number of drivers that could be loaded and it would take up
    too much memory to compile them statically. For example, you have a USB interface
    to support a range of devices. This is essentially the same argument as is used
    in desktop distributions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The kernel build system, `kbuild`, is a set of `make` scripts that take the
    configuration information from the `.config` file, work out the dependencies and
    compile everything that is necessary to produce a kernel image containing all
    the statically linked components, possibly a device tree binary and possibly one
    or more kernel modules. The dependencies are expressed in the makefiles that are
    in each directory with buildable components. For instance, these two lines are
    taken from `drivers/char/Makefile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `obj-y` rule unconditionally compiles a file to produce the target, so `mem.c`
    and `random.c` are always part of the kernel. In the second line, `ttyprintk.c`
    is dependent on a configuration parameter. If `CONFIG_TTY_PRINTK` is `y` it is
    compiled as a built in, if it is `m` it is built as a module and, if the parameter
    is undefined, it is not compiled at all.
  prefs: []
  type: TYPE_NORMAL
- en: For most targets, just typing `make` (with the appropriate `ARCH` and `CROSS_COMPILE`)
    will do the job, but it is instructive to take it one step at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling the kernel image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build a kernel image, you need to know what your bootloader expects. This
    is a rough guide:'
  prefs: []
  type: TYPE_NORMAL
- en: '**U-Boot**: Traditionally U-Boot has required a uImage, but newer versions
    can load a `zImage` file using the `bootz` command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**x86 targets**: It requires a `bzImage` file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Most other bootloaders**: It requires a `zImage` file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of building a `zImage` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `-j 4` option tells `make` how many jobs to run in parallel, which reduces
    the time taken to build. A rough guide is to run as many jobs as you have CPU
    cores.
  prefs: []
  type: TYPE_NORMAL
- en: It is the same when building `bzImage` and `uImage` targets.
  prefs: []
  type: TYPE_NORMAL
- en: There is a small issue with building a `uImage` file for ARM with multi-platform
    support, which is the norm for the current generation of ARM SoC kernels. Multi-platform
    support for ARM was introduced in Linux 3.7\. It allows a single kernel binary
    to run on multiple platforms and is a step on the road toward having a small number
    of kernels for all ARM devices. The kernel selects the correct platform by reading
    the machine number or the device tree passed to it by the bootloader. The problem
    occurs because the location of physical memory might be different for each platform,
    and so the relocation address for the kernel (usually 0x8000 bytes from the start
    of physical RAM) might also be different. The relocation address is coded into
    the `uImage` header by the `mkimage` command when the kernel is built, but it
    will fail if there is more than one relocation address to choose from. To put
    it another way, the `uImage` format is not compatible with multi-platform images.
    You can still create a uImage binary from a multi-platform build so long as you
    give the `LOADADDR` of the particular SoC you are hoping to boot this kernel on.
    You can find the load address by looking in `mach-[your SoC]/Makefile.boot` and
    noting the value of `zreladdr-y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of a BeagleBone Black, the full command would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A kernel build generates two files in the top level directory: `vmlinux` and
    `System.map`. The first, `vmlinux`, is the kernel as an ELF binary. If you have
    compiled your kernel with debug enabled (`CONFIG_DEBUG_INFO=y`), it will contain
    debug symbols which can be used with debuggers like `kgdb`. You can also use other
    ELF binary tools such as `size`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`System.map` contains the symbol table in human readable form.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most bootloaders cannot handle ELF code directly. There is a further stage
    of processing which takes `vmlinux` and places those binaries in `arch/$ARCH/boot`
    that are suitable for the various bootloaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Image`: `vmlinux` converted to raw binary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zImage`: For the PowerPC architecture, this is just a compressed version of
    `Image`, which implies that the bootloader must do the decompression. For all
    other architectures, the compressed `Image` is piggybacked onto a stub of code
    that decompresses and relocates it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uImage`: `zImage` plus a 64-byte U-Boot header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While the build is running, you will see a summary of the commands being executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, when the kernel build fails, it is useful to see the actual commands
    being executed. To do that, add `V=1` to the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Compiling device trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is to build the device tree, or trees if you have a multi-platform
    build. The dtbs target builds device trees according to the rules in `arch/$ARCH/boot/dts/Makefile`
    using the device tree source files in that directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `.dtb` files are generated in the same directory as the sources.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have configured some features to be built as modules, you can build
    them separately using the `modules` target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiled modules have a `.ko` suffix and are generated in the same directory
    as the source code, meaning that they are scattered all around the kernel source
    tree. Finding them is a little tricky but you can use the `modules_install` make
    target to install them in the right place. The default location is `/lib/modules`
    in your development system, which is almost certainly not what you want. To install
    them into the staging area of your root filesystem (we will talk about root filesystems
    in the next chapter), provide the path using `INSTALL_MOD_PATH`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Kernel modules are put into the directory `/lib/modules/[kernel version]`, relative
    to the root of the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning kernel sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three make targets for cleaning the kernel source tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '`clean`: removes object files and most intermediates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mrproper`: removes all intermediate files, including the `.config` file. Use
    this target to return the source tree to the state it was in immediately after
    cloning or extracting the source code. If you are curious about the name, Mr Proper
    is a cleaning product common in some parts of the world. The meaning of `make
    mrproper` is to give the kernel sources a really good scrub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`distclean`: This is the same as mrproper but also deletes editor backup files,
    patch leftover files, and other artifacts of software development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Booting your kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Booting is highly device-dependent, but here is an example using U-Boot on a
    BeagleBone Black and QEMU:.
  prefs: []
  type: TYPE_NORMAL
- en: BeagleBone Black
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following U-Boot commands show how to boot Linux on a BeagleBone Black:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that we set the kernel command line to `console=ttyO0,115200`. That tells
    Linux which device to use for console output which, in this case, is the first
    UART on the board, device `ttyO0`, at a speed of 115,200 bits per second. Without
    this, we would not see any messages after `Starting the kernel ...` and therefore
    would not know if it was working or not.
  prefs: []
  type: TYPE_NORMAL
- en: QEMU
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assuming that you have already installed `qemu-system-arm`, you can launch
    it with the multi_v7 kernel and the `.dtb` file for the ARM Versatile Express,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that setting `QEMU_AUDIO_DRV` to `none` is just to suppress error messages
    from QEMU about missing configurations for the audio drivers, which we do not
    use.
  prefs: []
  type: TYPE_NORMAL
- en: To exit from QEMU, type `Ctrl-A` then `x` (two separate keystrokes).
  prefs: []
  type: TYPE_NORMAL
- en: Kernel panic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While things started off well, they ended badly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is a good example of a kernel panic. A panic occurs when the kernel encounters
    an unrecoverable error. By default, it will print out a message to the console
    and then halt. You can set the `panic` command line parameter to allow a few seconds
    before it reboots following a panic.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the unrecoverable error is because there is no root filesystem,
    illustrating that a kernel is useless without a user space to control it. You
    can supply a user space by providing a root filesystem either as a ramdisk or
    on a mountable mass storage device. We will talk about how to create a root filesystem
    in the next chapter but, to get things up and running, assume that we have a ramdisk
    in the file `uRamdisk` and you can then boot to a shell prompt by entering these
    commands into U-Boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, I have added `rdinit=/bin/sh` to the command line so that the kernel
    will run a shell and give us a shell prompt. Now, the output on the console looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: At last, we have a prompt and can interact with our device.
  prefs: []
  type: TYPE_NORMAL
- en: Early user space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to transition from kernel initialization to user space, the kernel
    has to mount a root filesystem and execute a program in that root filesystem.
    This can be via a ramdisk, as shown in the previous section, or by mounting a
    real filesystem on a block device. The code for all of this is in `init/main.c`,
    starting with the function `rest_init()` which creates the first thread with PID
    1 and runs the code in `kernel_init()`. If there is a ramdisk, it will try to
    execute the `program /init`, which will take on the task of setting up the user
    space.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it fails to find and run `/init`, it tries to mount a filesystem by calling
    the function `prepare_namespace()` in `init/do_mounts.c`. This requires a `root=`
    command line to give the name of the block device to use for mounting, usually
    in the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '`root=/dev/<disk name><partition number>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`root=/dev/<disk name>p<partition number>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, for the first partition on an SD card, that would be `root=/dev/mmcblk0p1`.
    If the mount succeeds, it will try to execute `/sbin/init`, followed by `/etc/init`,
    `/bin/init`, and then `/bin/sh`, stopping at the first one that works.
  prefs: []
  type: TYPE_NORMAL
- en: The `init` program can be overridden on the command line. For a ramdisk, use
    `rdinit=`, (I used `rdinit=/bin/sh` earlier to execute a shell) and, for a filesystem,
    use `init=`.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kernel developers are fond of printing out useful information through liberal
    use of `printk()` and similar functions. The messages are categorized according
    to importance, 0 being the highest:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Level | Value | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_EMERG` | 0 | The system is unusable |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_ALERT` | 1 | Action must be taken immediately |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_CRIT` | 2 | Critical conditions |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_ERR` | 3 | Error conditions |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_WARNING` | 4 | Warning conditions |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_NOTICE` | 5 | Normal but significant conditions |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_INFO` | 6 | Informational |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_DEBUG` | 7 | Debug-level messages |'
  prefs: []
  type: TYPE_TB
- en: They are first written to a buffer, `__log_buf`, the size of which is two to
    the power of `CONFIG_LOG_BUF_SHIFT`. For example, if it is 16, then `__log_buf`
    is 64 KiB. You can dump the entire buffer using the command `dmesg`.
  prefs: []
  type: TYPE_NORMAL
- en: If the level of a message is less than the console log level, it is displayed
    on the console as well as being placed in `__log_buf`. The default console log
    level is 7, meaning that messages of level 6 and lower are displayed, filtering
    out `KERN_DEBUG` which is level 7\. You can change the console log level in several
    ways, including by using the kernel parameter `loglevel=<level>` or the command
    `dmesg -n <level>`.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel command line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The kernel command line is a string that is passed to the kernel by the bootloader,
    via the `bootargs` variable in the case of U-Boot; it can also be defined in the
    device tree, or set as part of the kernel configuration in `CONFIG_CMDLINE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen some examples of the kernel command line already but there are
    many more. There is a complete list in `Documentation/kernel-parameters.txt`.
    Here is a smaller list of the most useful ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `debug` | Sets the console log level to the highest level, eight, to ensure
    that you see all the kernel messages on the console. |'
  prefs: []
  type: TYPE_TB
- en: '| `init=` | The `init` program to run from a mounted root filesystem, which
    defaults to `/sbin/init`. |'
  prefs: []
  type: TYPE_TB
- en: '| `lpj=` | Sets the `loops_per_jiffy` to a given constant, see the following
    paragraph. |'
  prefs: []
  type: TYPE_TB
- en: '| `panic=` | Behavior when the kernel panics: if it is greater than zero, it
    gives the number of seconds before rebooting; if it is zero, it waits forever
    (this is the default); or if it is less than zero, it reboots without any delay.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `quiet` | Sets the console log level to one, suppressing all but emergency
    messages. Since most devices have a serial console, it takes time to output all
    those strings. Consequently, reducing the number of messages using this option
    reduces boot time. |'
  prefs: []
  type: TYPE_TB
- en: '| `rdinit=` | The `init` program to run from a ramdisk, it defaults to `/init`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ro` | Mounts the root device as read-only. Has no effect on a ramdisk which
    is always read/write. |'
  prefs: []
  type: TYPE_TB
- en: '| `root=` | Device to mount the root filesystem. |'
  prefs: []
  type: TYPE_TB
- en: '| `rootdelay=` | The number of seconds to wait before trying to mount the root
    device, defaults to zero. Useful if the device takes time to probe the hardware,
    but also see `rootwait`. |'
  prefs: []
  type: TYPE_TB
- en: '| `rootfstype=` | The filesystem type for the root device. In many cases, it
    is auto-detected during mount, but it is required for `jffs2` filesystems. |'
  prefs: []
  type: TYPE_TB
- en: '| `rootwait` | Waits indefinitely for the root device to be detected. Usually
    necessary with `mmc` devices. |'
  prefs: []
  type: TYPE_TB
- en: '| `rw` | Mounts the root device as read-write (default). |'
  prefs: []
  type: TYPE_TB
- en: 'The `lpj` parameter is often mentioned in connection with reducing the kernel
    boot time. During initialization, the kernel loops for approximately 250 ms to
    calibrate a delay loop. The value is stored in the variable `loops_per_jiffy`,
    and reported like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If the kernel always runs on the same hardware it will always calculate the
    same value. You can shave 250 ms off the boot time by adding `lpj=4980736` to
    the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Porting Linux to a new board
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The scope of the task depends on how similar your board is to an existing development
    board. In [Chapter 3](ch03.html "Chapter 3. All About Bootloaders"), *All About
    Bootloaders* we ported U-Boot to a new board, named Nova, which is based on the
    BeagleBone Black (when I say based, it actually is one) so, in this case, there
    are very few changes to the kernel code to be made. If you are porting to completely
    new and innovative hardware, there will be more to do. I am only going to consider
    the simple case.
  prefs: []
  type: TYPE_NORMAL
- en: The organization of architecture-specific code in `arch/$ARCH` differs from
    one system to another. The x86 architecture is pretty clean because hardware details
    are detected at runtime. The PowerPC architecture puts SoC and board-specific
    files in subdirectory platforms. The ARM architecture has the most board and SoC-specific
    files of all because there are a lot of ARM boards and SoCs. Platform-dependent
    code is in directories named `mach-*` in `arch/arm`, approximately one per SoC.
    There are other directories named `plat-*` which contain code common to several
    versions of an SoC. In the case of the Nova board, the relevant directory is `mach-omap2`.
    Don't be fooled by the name, though, it contains support for OMAP2, 3, and 4 chips.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, I am going do the port to the Nova board in two different
    ways. Firstly, I am going to show you how to do this with a device tree, and then
    without, since there are a lot of devices in the field that fit in this category.
    You will see that it is much simpler when you have a device tree.
  prefs: []
  type: TYPE_NORMAL
- en: With a device tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing to do is create a device tree for the board and modify it to
    describe the additional or changed hardware on the board. In this simple case,
    we will just copy `am335x-boneblack.dts` to `nova.dts` and change the board name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can build `nova.dtb` explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if we want `nova.dtb` to be produced by default for the OMAP2 platform
    with `make ARCH=arm dtbs` then we could add the following line to `arch/arm/boot/dts/Makefile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can boot the same `zImage` file as before, configured with `multi_v7_defconfig`,
    but load the `nova.dtb` as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We could create a custom configuration by taking a copy of `multi_v7_defconfig`
    and adding in those features we need, and cutting down code size by leaving out
    those we don't.
  prefs: []
  type: TYPE_NORMAL
- en: Without a device tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firstly, we need to create a configuration name for the board, in this case,
    it is `NOVABOARD`. We need to add this to the `Kconfig` file of the `mach-` directory
    for your SoC and we need to add a dependency for the SoC support itself, which
    is `OMAPAM33XX`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These lines are added to `arch/arm/mach-omap2/Kconfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a source file named `board-*.c` for each board, which contains code
    and configurations which are specific to the target. In our case, it is `board-nova.c`,
    based on a copy of `board-am335xevm.c`. There must be a rule to compile it, conditional
    on `CONFIG_MACH_NOVABOARD`, which this addition to `arch/arm/mach-omap2/Makefile`
    takes care of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are not using the device tree to identify the board, we will have
    to use the older machine number mechanism. This is a number unique to each board
    that is passed by the bootloader in register r1, and which the ARM start code
    will use to select the correct board support. The definitive list of ARM machine
    numbers is held at: [www.arm.linux.org.uk/developer/machines/download.php](http://www.arm.linux.org.uk/developer/machines/download.php).
    You can request a new machine number from: [www.arm.linux.org.uk/developer/machines/?action=new#](http://www.arm.linux.org.uk/developer/machines/?action=new#).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we hijack machine number `4242`, we could add it to `arch/arm/tools/mach-types,`
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When we build the kernel, it will be used to create the `mach-types.h` header
    file present in `include/generated/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The machine number and the board support are tied together by a structure which
    is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that there may be more than one machine structure in a board file, allowing
    us to create a kernel that will run on several different boards. The machine number
    passed by the bootloader selects the correct one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need a new default configuration for our board, which selects `CONFIG_MACH_NOVABOARD`
    and other configuration options specific to it. In the following example, it would
    be in `arch/arm/configs/novaboard_defconfig`. Now you can build the kernel image
    as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'There is still one step before the job is finished. The bootloader needs to
    be modified to pass the right machine number. Assuming that you are using U-Boot,
    you need to copy the machine numbers generated by Linux in `arch/arm/include/asm/mach-types.h`
    to U-Boot file `arch/arm/include/asm/mach-types.h`. Then you need to update the
    configuration header file for Nova, `include/configs/nova.h`, and add the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, at last, you can build U-Boot and use it to boot the new kernel on the
    Nova board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Additional reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources have further information about the topics introduced
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Linux Kernel Newbies*, [kernelnewbies.org](http://kernelnewbies.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Linux Weekly News*, [www.lwn.net](http://www.lwn.net)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux is a very powerful and complex operating system kernel that can be married
    to various types of user space ranging from a simple embedded device, to increasingly
    complex mobile devices using Android, to a full server operating system. One of
    its strengths is the degree of configurability. The definitive place to get the
    source code is [www.kerenl.org](http://www.kerenl.org), but you will probably
    need to get the source for a particular SoC or board from the vendor of that device
    or a third-party that supports that device. The customization of the kernel for
    a particular target may consist of changes to the core kernel code, additional
    drivers for devices that are not in mainline Linux, a default kernel configuration
    file and, a device tree source file.
  prefs: []
  type: TYPE_NORMAL
- en: Normally you start with the default configuration for your target board, and
    then tweak it by running one of the configuration tools such as `menuconfig`.
    One of the things you should consider at this point is whether kernel features
    and drivers should be compiled as modules or built-in. Kernel modules are usually
    no great advantage for embedded systems, where the feature set and hardware are
    usually well defined. However, modules are often used as a way to import proprietary
    code into the kernel, and also to reduce boot time by loading non-essential drivers
    after boot. Building the kernel produces a compressed kernel image file, named
    `zImage`, `bzImage`, or `uImage` depending on the bootloader you will be using
    and the target architecture. A kernel build will also generate any kernel modules
    (as `.ko` files) that you have configured, and device tree binaries (as `.dtb`
    files) if your target requires them.
  prefs: []
  type: TYPE_NORMAL
- en: Porting Linux to a new target board can be quite simple or very difficult depending
    on how different the hardware is from that in the mainline or vendor supplied
    kernel. If your hardware is based on a well-known reference design, then it may
    be just a question of making changes to the device tree or to the platform data.
    You may well need to add device drivers, which I discuss in [Chapter 8](ch08.html
    "Chapter 8. Introducing Device Drivers"), *Introducing Device Drivers*. However,
    if the hardware is radically different to a reference design, you may need additional
    core support, which is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel is the core of a Linux based system, but it cannot work by itself.
    It requires a root filesystem that contains user space. The root filesystem can
    be a ramdisk or a filesystem accessed via a block device, which will be the subject
    of the next chapter. As we have seen, booting a kernel without a root filesystem
    results in a kernel panic.
  prefs: []
  type: TYPE_NORMAL
