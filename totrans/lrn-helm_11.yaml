- en: '*Chapter 8*: Using Helm with the Operator Framework'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the advantages of using Helm is the ability to synchronize the local
    and the live states. With Helm, the local state is managed with values files that,
    when provided using the `install` or `upgrade` command, apply the values to synchronize
    the live state in a Kubernetes cluster. In previous chapters, this was performed
    by invoking these commands when a change to the application was desired.
  prefs: []
  type: TYPE_NORMAL
- en: Another way these changes can be synchronized is to create an application inside
    the cluster that checks periodically that the desired state matches the current
    configurations within an environment. If the state does not match, the application
    can automatically modify the environment to match the desired state. This application
    is referred to as a Kubernetes operator. In this chapter, we will create a Helm-based
    operator that helps ensure the locally defined state always matches the live state
    of the cluster. If it does not, the operator will execute the appropriate Helm
    commands to update the environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Kubernetes Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Helm Operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Helm to manage Operators and **Custom Resources** (**CRs**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleaning up your Kubernetes environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need to have the following technologies installed
    on your local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '`minikube`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`helm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these tools, you should find the Packt repository containing
    resources associated with the examples on GitHub at [https://github.com/PacktPublishing/-Learn-Helm](https://github.com/PacktPublishing/-Learn-Helm).
    This repository will be referenced throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Kubernetes Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automation is at the core of the Kubernetes platform. As covered in [*Chapter
    1*](B15458_01_Final_JM_ePub.xhtml#_idTextAnchor017), *Understanding Kubernetes
    and Helm*, Kubernetes resources can be managed either implicitly by running `kubectl`
    commands or declaratively by applying **YAML**-formatted representations. Once
    the resources are applied using the Kubernetes **Command-Line Interface** (**CLI**),
    one of the fundamental principles of Kubernetes is to match the current state
    of resources within the cluster to the desired state, a process known as **the
    control loop**. This ongoing, non-terminating pattern of monitoring the state
    of the cluster is implemented through the use of controllers. Kubernetes includes
    numerous controllers that are native to the platform, with examples ranging from
    admission controllers that intercept requests to the Kubernetes **Application
    Programming Interface** (**API)** to replication controllers that manage the number
    of Pod replicas that are running.
  prefs: []
  type: TYPE_NORMAL
- en: As interest in Kubernetes began to grow, the combination of providing users
    the ability to extend the capabilities of the base platform, as well as a way
    to provide more intelligence around managing the life cycle of applications, led
    to the creation of several important concepts that have defined the second wave
    of Kubernetes development. First, the introduction of the **Custom Resource Definitions**
    (**CRDs**) enabled users the ability to extend the default Kubernetes API, the
    mechanism for interacting with the Kubernetes platform, in order to create and
    register new types of resources. Registering a new CRD creates a new **Representational
    State Transfer** (**REST****ful**) resource path on the Kubernetes API server.
    So, similar to how you can use the Kubernetes CLI to execute `kubectl get pods`
    to retrieve all Pod objects, registering a new CRD for an object type called **Guestbook**,
    for example, allows for the capability of invoking `kubectl get guestbook` to
    view all Guestbook objects that have been previously created. With this new capability
    realized, developers could now create controllers of their own to monitor these
    types of CRs to manage the lifecycle of applications that can be described through
    the use of CRDs.
  prefs: []
  type: TYPE_NORMAL
- en: The second major trend was the advances in the types of applications that were
    being deployed onto Kubernetes. Instead of small and simple applications, more
    complex and stateful applications were being deployed more frequently. These types
    of advanced applications typically require a higher level of management and maintenance,
    such as handling the deployment of multiple components, as well as considerations
    around 'day 2' activities, such as backup and restorations. These tasks extend
    beyond the typical types of controllers found in Kubernetes, as deep knowledge
    related to the application they are managing must be embedded within. This pattern
    of using a CR to manage applications and their components is known as an **Operator**
    pattern. First coined by the software company CoreOS in 2016, Operators aim to
    capture the knowledge that a human operator would have for managing the lifecycle
    of an application. Operators are packaged as normal containerized applications—deployed
    within pods—that react on changes to the API against CRs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Operators are commonly written using a toolkit called the Operator Framework,
    and are based on one of the following three different technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go-based Operators leverage the Go programming language to implement control
    loop logic. Ansible-based Operators leverage the Ansible CLI tool and Ansible
    playbooks. Ansible is an automation tool whose logic is written in YAML files
    called playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on Helm-based Operators. Helm Operators base
    their control loop logic on Helm charts and a subset of the features provided
    by the Helm CLI. As a result, they represent an easy way for Helm users to implement
    their Operators.
  prefs: []
  type: TYPE_NORMAL
- en: With an understanding of Operators, let's create an operator of our own, using
    Helm.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Helm operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will write a Helm-based operator that will be used to install
    the Guestbook Helm chart created in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your First Helm Chart*. This chart can be seen under the `guestbook/`
    folder of the Pack[t repository (https://github.com/PacktPublishing/-Learn-Helm/tree/master/helm-charts/ch](https://github.com/PacktPublishing/-Learn-Helm/tree/master/helm-charts/charts/guestbook)arts/guestbook).
  prefs: []
  type: TYPE_NORMAL
- en: 'An operator is built as a container image that contains the control loop logic
    to maintain an application. The following diagram demonstrates how the Guestbook
    Operator will function once it is deployed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Guestbook Operator workflow'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Guestbook Operator workflow
  prefs: []
  type: TYPE_NORMAL
- en: The Guestbook Operator will constantly watch for changes to Guestbook CRs. When
    a Guestbook CR is created, the Guestbook Operator will install the Guestbook chart
    you created in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your First Helm Chart*. Conversely, if the Guestbook CR is deleted,
    the Guestbook Operator will remove the Guestbook Helm chart.
  prefs: []
  type: TYPE_NORMAL
- en: With an understanding of how the Guestbook Operator will function, let's set
    up an environment in which the operator can be built and deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, since the operator will be deployed to Kubernetes, you should start
    your Minikube environment by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After starting Minikube, create a namespace called `chapter8`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since the Guestbook Operator is built as a container image, you will need to
    create an image repository that can store it so it can later be referenced. To
    store this image, we will create a new repository in Quay (quay.io), a public
    container registry (though if you have an account elsewhere, that will suffice
    as well). We will also prepare a local development environment with the necessary
    tooling required to build the operator image.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by creating a new image repository in Quay.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Quay repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating a new repository in Quay requires you to have a Quay account. Follow
    these steps to create a Quay accou[nt:](https://quay.io/signin/)
  prefs: []
  type: TYPE_NORMAL
- en: '[Navigate to https:/](https://quay.io/signin/)/quay.io/signin/ in your browser.
    You will be prompted by a screen to enter your Quay credentials, as illustrated
    in the following screenshot:![Figure 8.2 – Red Hat Quay sign-in page'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_8.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Red Hat Quay sign-in page
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the page, click the **Create Account** link. You will be prompted
    with a set of dialog boxes to create a new Quay account, as illustrated in the
    following screenshot:![Figure 8.3 – Red Hat Quay Create new account page
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_8.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – Red Hat Quay **Create new account** page
  prefs: []
  type: TYPE_NORMAL
- en: Enter your desired credentials, and then select **Create Free Account**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will soon be sent an email confirmation. Click the link on the confirmation
    email to verify your account and continue using Quay with your new account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have created a new Quay account, you can continue to create a new image
    repository for the operator image.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new image repository, select the **+** plus icon at the top-right
    corner of the Quay page and select **New Repository**, as illustrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Selecting “New Repository” to create a new image repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Selecting 'New Repository' to create a new image repository
  prefs: []
  type: TYPE_NORMAL
- en: 'You will then be taken to the **Create New Repository** page, where you should
    enter the following details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For **Repository Name**, enter `guestbook-operator.`
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Public** radio button, indicating unauthenticated access to the
    repository. This change will simplify how Kubernetes will be able to access the
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remainder of the options can be kept at the default values. Once complete,
    the **Create New Repository** page should appear, as illustrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – The “Create New Repository” page in Quay'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – The 'Create New Repository' page in Quay
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Create Public Repository** button to create the Quay repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that a repository has been created to store the Guestbook Operator image,
    let's prepare an environment with the tooling required to build a Helm operator.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a local development environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to create a Helm operator, you will need the following CLI tools at
    a minimum:'
  prefs: []
  type: TYPE_NORMAL
- en: '`operator-sdk`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker`, `podman`, or `buildah`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `operator-sdk` CLI is a toolkit used to help develop Kubernetes Operators.
    It contains inherent logic to simplify the operator development process. Under
    the hood, `operator-sdk` requires a container management tool that it can use
    to build the operator image. The `operator-sdk` CLI supports `docker`, `podman`,
    and `buildah` as the underlying container management tools.
  prefs: []
  type: TYPE_NORMAL
- en: To install the `operator-sdk` CLI, you can simply download a release from their
    [GitHub repository at https://github.com/operator-framework/](https://github.com/operator-framework/operator-sdk/releases)operator-sdk/releases.
    However, the process used to install `docker`, `podman`, or `buildah` may vary
    greatly, depending on your operating system; not to mention, that Windows users
    will not be able to use the `operator-sdk` toolkit natively.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the Minikube **Virtual Machine** (**VM**) can be leveraged as a
    working environment for developers of many different operating systems since it
    is a Linux VM and also contains the Docker CLI. In this section, we will install
    `operator-sdk` to the Minikube VM and will use this environment to create the
    operator. Note that while the steps provided are designed to run in the VM, most
    of these steps will also apply to all Linux and Mac machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to install `operator-sdk` on the Minikube VM:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Gain access to the VM by running the `minikube ssh` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once inside the VM, you need to download the `operator-sdk` CLI. This can be
    accomplished using the `curl` command. Note that the `operator-sdk` version used
    at the time of writing was version `0.15.2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To download this version of the `operator-sdk` CLI, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once downloaded, you will need to change the permission of the `operator-sdk`
    binary to be user-executable. Run the `chmod` command to make this modification,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, move the `operator-sdk` binary to a location managed by the VM''s `PATH`
    variable, such as `/usr/bin`. Because this operation requires a root privilege,
    you will need to run the `mv` command using `sudo`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, verify your `operator-sdk` installation by running the `operator-sdk
    version` command, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If this command executes without error, you have successfully installed the
    `operator-sdk` CLI.
  prefs: []
  type: TYPE_NORMAL
- en: As an additional step, you should also clone the Packt repository in your Minikube
    VM since we will later leverage the `guestbook` Helm chart to build a Helm operator.
    Run the following command in your VM to clone the r[epository:](https://github.com/PacktPublishing/-Learn-Helm.git)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have a Quay image repository and a local development environment
    created from the Minikube VM, let's begin writing the Guestbook Operator. Note
    that an example of the operator code is located in t[he Packt repository at https://github.com/PacktPublishing/-Learn-Helm/tree/ma](https://github.com/PacktPublishing/-Learn-Helm/tree/master/guestbook-operator)ster/guestbook-operator.
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding the operator file structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to Helm charts themselves, Helm Operators built by the `operator-sdk`
    CLI have a specific file structure that must be adhered to. The file structure
    is explained in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – The file structures explained'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – The file structures explained
  prefs: []
  type: TYPE_NORMAL
- en: 'The operator file structure can be easily created using the `operator-sdk new`
    command. In your Minikube VM, execute the following command to scaffold the Guestbook
    Operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `operator-sdk new` command created a local directory called `guestbook-operator`,
    which contains the operator contents. It is specified that a Helm operator should
    be created using the `--type` flag, along with `Guestbook` as the name of the
    CR.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `--helm-chart` flag instructed the `operator-sdk` CLI to copy the
    source Guestbook chart to the operator directory.
  prefs: []
  type: TYPE_NORMAL
- en: With the Guestbook operator successfully scaffolded, let's build the operator
    and push it to your Quay registry.
  prefs: []
  type: TYPE_NORMAL
- en: Building the operator and pushing it to Quay
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `operator-sdk` CLI provides an `operator-sdk build` command that makes it
    straightforward to build an operator image. This command is designed to be run
    against the top-level directory of an operator, and will build the image by referencing
    the Dockerfile located under the operator's `build/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your Minikube VM, run the `operator-sdk build` command, substituting your
    Quay username where directed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If the build is successful, you will receive the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the Minikube VM has Docker installed, the `operator-sdk` CLI used Docker
    in the background to build the image. You can run the `docker images` command
    to verify that the image has been built, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With the operator image built locally, it must be pushed to an image registry
    so that it can be pulled from Kubernetes. In order to push an image to a registry
    using Docker, you must first authenticate with the target registry. Use the `docker
    login` command to log in to Quay, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once logged in to Quay, use the `docker push` command to push your operator
    image to your Quay registry, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When the push is finished, return to the `guestbook-operator` repository that
    you created in the *Creating a Quay repository* section. You should be able to
    see a new tag published under the **Repository tags** section, as illustrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – A new tag should be pushed to your Quay registry'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – A new tag should be pushed to your Quay registry
  prefs: []
  type: TYPE_NORMAL
- en: Now that your operator has been pushed to a container registry, let's continue
    by deploying the operator to your Kubernetes environment.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the Guestbook Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When scaffolding the Guestbook Operator, the `operator-sdk` CLI also created
    a folder called `deploy` and generated the files required to deploy the operator
    within.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following file structure depicts the contents of the `deploy` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `crds/` folder contains the YAML resource required to create the Guestbook
    CRD (`charts.helm.k8s.io_guestbooks_crd.yaml`). This file is required to register
    the new Guestbook API endpoint with Kubernetes. In addition, the `crds/` folder
    contains an example Guestbook CR application (`charts.helm.k8s.io_v1alpha1_guestbook_cr.yaml`).
    Creating this file will trigger the operator to install the Guestbook Helm chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Review the contents of the CR in order to become familiar with the types of
    properties defined, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A snippet of the output is provided in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Snippet of the Guestbook CR'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8 – Snippet of the Guestbook CR
  prefs: []
  type: TYPE_NORMAL
- en: Each of the entries under the `spec` stanza refer to the Guestbook chart's `values.yaml`
    file. The `operator-sdk` tool automatically created this example CR with each
    of the default values that were included from this file. Additional entries can
    be added or modified before applying this CR, to override other values of the
    Guestbook chart. These values are consumed by the operator at runtime to deploy
    the Guestbook application accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The `deploy/operator.yaml` file defines the actual operator itself and contains
    a simple deployment resource. We will return soon to this file's contents.
  prefs: []
  type: TYPE_NORMAL
- en: The `role_binding.yaml`, `role.yaml` and `service_account.yaml` files were created
    in order to provide the operator with the permissions necessary to watch for Guestbook
    CRs and install the Guestbook Helm chart to Kubernetes. It performs these actions
    by authenticating with the Kubernetes API using the service account defined in
    the `service_account.yaml` file. Once authenticated, the operator will be provided
    authorization based on the `role.yaml` and `role_binding.yaml` resources. The
    `role.yaml` file lists the finely grained permissions that describe the exact
    resources and actions that the operator is allowed to perform. The `role_binding.yaml`
    file binds the role to the operator's service account.
  prefs: []
  type: TYPE_NORMAL
- en: 'With an understanding of each resource created under the operator''s `deploy/`
    folder, follow these steps to deploy your Guestbook operator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the Minikube VM does not contain `Kubectl`, so you must first
    exit to your local system if you are still connected to the VM from the command
    line, by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The resources that were created with `operator-sdk` earlier are also located
    in the Packt repository under the `guestbook-operator/` folder. If you have not
    cloned this repository in previous chapters, clone it now using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As a quick aside, note that the only resource in the Packt repository that
    is modified from the resources you created in your Minikube VM is the `role.yaml`
    file. The `operator-sdk` CLI generated a simple `role.yaml` file based on the
    template files that were included in the guestbook Helm chart. However, if you
    can recall, the guestbook chart contained a couple of resources that would only
    be included based on a conditional value. These resources were the `Job` and `PersistentVolumeClaim`
    hook resources that were only included if persistent storage was enabled. One
    example of this is shown in the `PersistentVolumeClaim` template, in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `operator-sdk` CLI did not automatically create the **Role-Based Access
    Control** (**RBAC**) rules for `Jobs` and `PersistentVolumeClaims` since it did
    not know whether this template would be included.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the authors have added these rules to the `role.yaml` file, located
    at https://github.com/PacktPublishing/-Learn-Helm/blob/master/guestbook-operator/deploy/role.yaml#L81-L104.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Guestbook operator will be dependent on a new API endpoint. Create this
    endpoint by applying the CRD under the `guestbook-operator/deploy/crds` folder,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We will use the second file under that folder (the CR) later to deploy the Guestbook
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you will need to modify the `guestbook-operator/deploy/operator.yaml`
    file to specify the operator image that you built earlier. You will notice the
    following lines of code within this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Replace the `REPLACE_IMAGE` text with the location of your operator image. This
    value should be similar to `quay.io/$QUAY_USERNAME/guestbook-operator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have applied the CRD and updated your `operator.yaml` file, you can
    proceed to apply each of the resources under the `guestbook-operator/deploy/`
    folder by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the operator to report the `1/1` ready state by running a watch against
    the Pods in the `chapter8` namespace, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now that the Guestbook operator has been deployed, let's use it to install the
    Guestbook Helm chart.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the Guestbook application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using Helm normally as a standalone CLI tool, you would install a Helm
    chart by running the `helm install` command. With a Helm operator, you install
    a Helm chart by creating a CR. Install the Guestbook Helm chart by creating the
    provided CR located under the `guestbook-operator/deploy/crds/` folder, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Run another `watch` command against the Pods in the `chapter8` namespace, as
    shown in the following code snippet, and you should be able to see the Guestbook
    and Redis Pods spin up as a result of the Helm chart installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code block depicts each Pod in its `READY` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When you created the Guestbook CR, a `helm install` command was executed by
    the operator to install the Guestbook chart. You can confirm the release that
    was created by running `helm list`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'An upgrade of the release can be performed by modifying the `example-guestbook`
    CR. Modify your `guestbook-operator/deploy/crds/charts.helm.k8s.io_v1alpha1_guestbook_cr.yaml`
    file to change the number of replicas from `1 to 2`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the change once you have updated the `replicaCount` value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The modification to the Guestbook CR will trigger a `helm upgrade` command
    against the `example-guestbook` release. As you may recall from [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your First Helm Chart*, the upgrade hook for the Guestbook Helm chart
    will initiate a backup of the Redis database. If you run a watch against the Pods
    in the `chapter8` namespace after modifying the CR, you will notice a backup `Job`
    begin and will see one of the two Guestbook Pods terminate once the backup is
    finished. You will also notice from the `helm list` command in the following code
    snippet that the revision number of the `example-guestbook` release was increased
    to `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the revision number was increased to `2`, one limitation of Helm-based
    Operators as of writing is that you cannot initiate a rollback to a previous revision
    as you can by using the CLI. If you attempt to run `helm history` against the
    `example-guestbook` release, you will also notice that only the second revision
    is in the release history, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This is an important difference between using Helm regularly with the CLI and
    using Helm via a Helm-based operator. Because the release history is not retained,
    the Helm-based operator does not allow you to perform an explicit rollback. However,
    a `helm rollback` command will be run in cases where upgrades fail. In this case,
    the rollback hook will be executed in an attempt to roll back to the attempted
    upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: Although the Helm-based operator does not retain release history, one area in
    which it excels is synchronizing the desired and live states of an application.
    This is because the operator constantly watches the state of the Kubernetes environment
    and ensures that the application is always configured to match the configuration
    specified on the CR. In other words, if one of the Guestbook application's resources
    is modified, the operator will immediately revert the change to make it match
    the specification as defined on the CR. You can see this in action by modifying
    a field on one of the Guestbook resources.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we will change the Guestbook deployment's replica count directly
    from `2` to `3` and watch the operator revert this back to `2` replicas automatically
    to re-synchronize the desired state defined in the CR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following `kubectl patch` command to change the replica count of
    the Guestbook deployment from `2` to `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Normally, this would simply add an additional replica of your Guestbook application.
    However, because the Guestbook CR currently defines only `2` replicas, the operator
    quickly changes the replica count back to `2` and terminates the additional Pod
    that was created. If you actually wanted to increase the replica count to `3`,
    you would have to update the `replicaCount` value on the Guestbook CR. This process
    provides the advantage of ensuring that the desired state matches the live state
    of the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Uninstalling the Guestbook application with a Helm-based operator is as simple
    as removing the CR. Delete the `example-guestbook` CR to uninstall the release,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This will remove the `example-guestbook` release and all of the dependent resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also remove the Guestbook Operator and its resources as well, since
    we will not need them in the next section. You can do this by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In general, you should always make sure that you delete the CR first before
    deleting the operator. The operator is programmed to perform a `helm uninstall`
    command on your release when you delete the CR. If you accidentally delete the
    operator first, you will have to manually run `helm uninstall` from the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you created a Helm operator and learned how to deploy an application
    using an operator-based approach. In the next section, we will continue the discussion
    on Operators by investigating how they can be managed using Helm.
  prefs: []
  type: TYPE_NORMAL
- en: Using Helm to manage Operators and CRs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you installed the Guestbook Operator by first creating
    the CRD that is found underneath the `guestbook-operator/deploy/crds/` folder.
    Next, you created the operator resources contained underneath the `guestbook-operator/deploy/`
    folder. Finally, you created the CR to deploy the Guestbook application. Each
    of these tasks was performed by using the Kubectl CLI, but this instead can also
    be accomplished using Helm charts to provide a more flexible and repeatable solution
    toward installing and managing an operator.
  prefs: []
  type: TYPE_NORMAL
- en: Helm allows you to provide a special directory called `crds/` inside your Helm
    chart, which is used to create CRDs whenever the chart is installed. Helm creates
    CRDs before any of the other resources defined under the `templates/` folder,
    making it simpler to install applications such as Operators that depend on the
    presence of CRDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following file structure depicts a Helm chart that could be used to install
    the Guestbook Operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This Helm chart, upon installation, would first install the Guestbook CRD. If
    the CRD is already present in the cluster, it would skip CRD creation and would
    simply create the template resources instead. Note that while CRDs can be convenient
    to include in a Helm chart, there are several limitations. First, CRDs in a Helm
    chart cannot contain any Go templating, so CRDs cannot benefit from parameterization
    as in typical resources. CRDs can also never be upgraded, rolled back, or deleted.
    As a result, users must take care to modify or remove the CRDs manually if these
    actions are desired. Finally, installing such a chart as previously described
    would require a cluster-admin privilege, the highest privilege permitted in Kubernetes,
    because the chart contains at least one CRD resource.
  prefs: []
  type: TYPE_NORMAL
- en: The Helm chart described previously can be used by cluster administrators to
    easily install the Guestbook operator. This, however, is only half of the equation,
    as end users must still create CRs to deploy the Guestbook application. Luckily,
    end users of the operator can also leverage Helm by creating a Helm chart that
    wraps the Guestbook CR.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example layout for such a Helm chart is shown in the following file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example includes a template called `guestbook.yaml`. This template
    could contain the Guestbook CR originally generated by the `operator-sdk` CLI,
    with the name `charts.helm.k8s.io_v1alpha1_guestbook_cr.yaml`. Unlike CRDs, CRs
    underneath the `templates/` folder benefit from Go templating and lifecycle management,
    as do all other resources. This methodology provides the most value when the CR
    contains complex fields that may be conditionally included based on the user-provided
    values or when multiple different CRs must be included in the same release. With
    this method, you would also be able to manage the lifecycle of your CRs and maintain
    a history of revisions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an understanding of how a Helm operator can be created and
    how Helm can be used to help manage Operators, feel free to clean up your Kubernetes
    environment in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up your Kubernetes environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, run the following command to remove your Guestbook CRD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Before you proceed with the next clean-up steps, note that one of the questions
    posed later under the *Questions* section will challenge you with writing your
    own Helm charts to implement the chart designs discussed under the *Using Helm
    to manage Operators and CRs* section. You may want to postpone these steps to
    test your implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To continue the clean-up, run the following command to delete your `chapter8`
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Finally, run the `minikube stop` command to stop your Minikube VM.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Operators are important to help ensure that the desired state always matches
    the live state. Such a feat allows users to more easily maintain a source of truth
    for resource configuration. Users can leverage the Helm-based operator to provide
    this type of resource reconciliation, and it is easy to get started because this
    uses Helm charts as its deployment mechanism. When a CR is created, the Helm operator
    will install the associated Helm chart to create a new release. Subsequent upgrades
    will be performed when the CR is modified, and the release will be uninstalled
    when the CR is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: To manage the operator, cluster administrators can create a separate Helm chart
    used for creating the operator's resources and CRDs. End users can also create
    a separate Helm chart that can be used for creating the operator's CRs, along
    with any other resources that may be relevant.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss best practices and topics around security
    within the Helm ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information about the Kubernetes resources, you can check the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To discover more Operators that have been developed b[y the community, consult
    this repository: https://githu](https://github.com/operator-framework/awesome-operators)b.com/operator-framework/awesome-Operators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can learn more about Operators along with their origins from the Kubernetes
    documentation at [https://kubernetes.io/docs/concepts/extend-kubernetes/operator/.](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/.
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does a Kubernetes operator work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the differences between using the Helm CLI and using a Helm-based operator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Imagine you are tasked with creating a Helm operator out of an existing Helm
    chart. What steps would you take to complete this task?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do the install, upgrade, rollback, and uninstall lifecycle hooks function
    in a Helm operator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `crds/` folder in a Helm chart?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the *Using Helm to manage Operators and CRs* section, we introduced two different
    Helm charts that can be used to help manage Operators and CRs. Implement the Helm
    charts by using the chart layouts provided within that section. The charts should
    be used to install the Guestbook operator and to install the Guestbook CR. Refer
    to [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265), *Building Your
    First Helm Chart* for assistance on creating a Helm chart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
