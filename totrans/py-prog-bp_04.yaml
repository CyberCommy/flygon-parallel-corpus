- en: Exchange Rates and the Currency Conversion Tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we built a really cool application to count votes on
    Twitter and learned how to authenticate and consume the Twitter API using Python.
    We also had a good introduction to how to use Reactive Extensions for Python.
    In this chapter, we are going to create a terminal tool that will fetch exchange
    rates for the current day from `fixer.io` and use this information to convert
    the value between different currencies.
  prefs: []
  type: TYPE_NORMAL
- en: '`Fixer.io` is a very nice project created by [https://github.com/hakanensari](https://github.com/hakanensari);
    on a daily basis, it fetches foreign exchange rate data from the European Central
    Bank. The API that he created is simple to use and works pretty well.'
  prefs: []
  type: TYPE_NORMAL
- en: Our project starts out by creating a framework around the API; when that is
    in place, we are going to create a terminal application where we can perform currency
    conversion. All the data that we fetch from the `fixer.io` is going to be stored
    in a MongoDB database, so we can perform conversions without doing requests to
    `fixer.io` all the time. This will increase the performance of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use `pipenv` to install and manage our project's dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with MongoDB using the PyMongo module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming REST APIs using Requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that said, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As usual, we will start by setting up our environment; the first thing we need
    to do is set up a virtual environment that will allow us to easily install our
    project dependencies without interfering with Python's global installation.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, we used `virtualenv` to create our virtual environment;
    however, Kenneth Reitz (the creator of the popular package *requests*) created `pipenv`.
  prefs: []
  type: TYPE_NORMAL
- en: '`pipenv` is for Python what NPM is for Node.js. However, `pipenv` is used for
    much more than package management, and it also creates and manages a virtual environment
    for you. In my opinion, there are a lot of advantages of the old development workflows,
    but for me, there are two things that stand out: the first is that you no longer
    need two different tools (`pip`, `virtualenv`), and the second is that it is much
    simpler to have all these great features in just one place.'
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that I really like about `pipenv` is the use of `Pipfile`. Sometimes,
    it is really hard to work with requirement files. Our production environment and
    development environment have the same dependencies, and you end up having to maintain
    two different files; plus, every time you need to remove one dependency, you will
    need to edit the requirement file manually.
  prefs: []
  type: TYPE_NORMAL
- en: With `pipenv`, you don't need to worry about having multiple requirement files.
    Development and production dependencies are placed in the same file, and `pipenv` also
    takes care of updating the `Pipfile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing `pipenv` is quite simple, just run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing it you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b92b58f8-cc44-4f22-9c04-0e761751af85.png)'
  prefs: []
  type: TYPE_IMG
- en: We are not going to go through all the different options because that is beyond
    the scope of this book, but while we are creating our environment, you will acquire
    a good knowledge of the basics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create a directory for our project. Let''s create a directory
    called `currency_converter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you are inside the `currency_converter` directory, we are going to
    use `pipenv` to create our virtual environment. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will create a virtual environment for the project living in the current
    directory and will use Python 3.6\. The `--python` option also accepts a path
    to where you installed Python. In my case, I always download the Python source
    code, build it, and install it in a different location, so this is very useful
    for me.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could also use the `--three` option, which would use the default Python3
    installation on your system. After running the command, you should see the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8784ad3b-7ce3-4d9e-bc95-e01455d19615.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you have a look at the contents of the `Pipfile`, you should have something
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This file starts defining where to get the packages from, and in this case,
    it will download packages from `pypi`. Then, we have a place for the development
    dependencies of our project, and in `packages`, the production dependencies. Lastly,
    it says that this project requires Python version 3.6.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! Now you can use some commands. For example, if you want to know which
    virtual environment the project uses, you can run `pipenv --venv`; you will see
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f729d03d-b885-4866-a3f1-f69689ba4168.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to activate the virtual environment for the project, you can use
    the `shell` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/17b5e4d5-1962-4054-afd5-50748321d710.png)'
  prefs: []
  type: TYPE_IMG
- en: Perfect! With the virtual environment in place, we can start adding our project's
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The first dependency that we are going to add is `requests`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fef2a704-9e32-4cd2-b6e1-21d2a29d20a7.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, `pipenv` installs `requests` as well as all its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The author of `pipenv` is the same developer who created the popular requests
    library. In the installation output, you can see an easter egg, saying `PS: You
    have excellent taste!`.'
  prefs: []
  type: TYPE_NORMAL
- en: The other dependency that we need to add to our project is `pymongo` so that
    we can connect and manipulate data in a MongoDB database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cd80273e-1faa-4667-835c-54d65e0bfdd6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s have a look at the `Pipfile` and see how it looks now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, under the `packages` folder, we have now our two dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Not much has changed in comparison with installing packages with `pip`. The
    exception is that now installing and removing dependencies will automatically
    update the `Pipfile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another command that is very useful is the `graph` command. Run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4b513feb-d291-4c36-abce-6d7272159f16.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the `graph` command is very helpful when you want to know what
    the dependencies of the packages you have installed are. In our project, we can
    see that `pymongo` doesn't have any extra dependencies. However, `requests` has
    four dependencies: `certifi`, `chardet`, `idna`, and `urllib3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have had a great introduction to `pipenv`, let''s have a look
    at what this project''s structure will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The top `currency_converter` is the application's `root` directory. Then, one
    level down we have another `currency_converter` and that is the `currency_converter` module
    that we are going to create.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `currency_converter` module directory, we have a core which contains
    the application core functionality, for example, a command line argument parser,
    helper functions to handle data, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We have also configured, as with the other projects, which project will contain
    functions to read YAML configuration files; finally, we have HTTP, which have
    all the functions that will perform HTTP requests to the `fixer.io` REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to use `pipenv` and how it will help us to be more
    productive, we can install the initial dependencies to our project. We created
    the project's directory structure, too. The only missing piece of the puzzle is
    installing MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m using Linux Debian 9 and I can easily just install this using Debian''s
    package manager tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You will find MongoDB in the package repositories of the most popular Linux
    distributions, and if you are using Windows or macOS, you can see the instructions
    in the following  links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For macOS: [https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/)'
  prefs: []
  type: TYPE_NORMAL
- en: For Windows: [https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/)
  prefs: []
  type: TYPE_NORMAL
- en: After installation, you can verify that everything is working properly using
    the MongoDB client. Open a terminal and just run the `mongo` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'And you should get into the MongoDB shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To exit the MongoDB shell, just type *CTRL *+ *D.*
  prefs: []
  type: TYPE_NORMAL
- en: Perfect! Now we are ready to start coding!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the API wrapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to create a set of functions that will wrap the
    `fixer.io` API and will help us use it in a simple way within our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and create a new file called `request.py` in the `currency_converter/currency_converter/core` directory.
    First, we are going to include some `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We obviously need `requests` so that we can perform requests to the `fixer.io`
    endpoints, and we are also importing `HTTPStatus` from the HTTP module so we can
    return the correct HTTP status code; also be a bit more verbose in our code. It's
    much nicer and easier to read the `HTTPStatus.OK` return than only `200.`
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we import the `json` package so that we can parse the JSON content that
    we get from `fixer.io` into Python objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to add our first function. This function will return the
    current exchange rates given a specific currency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This function gets a currency as an argument and starts off by sending a request
    to the `fixer.io` API to get the latest exchange rates using the currency as a
    base, which was given as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: If the response was `HTTPStatus.OK` (`200`), we use the load function from the
    JSON module to parse the JSON response; otherwise, we raise exceptions depending
    on the error that occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create a file called `__init__.py` in the `currency_converter/currency_converter/core` directory
    and import the function that we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Let''s try it out in the Python REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! It works just like we expected.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to start building the database helper class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the database helper class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have implemented the function that will fetch the exchange rate
    information from `fixer.io`, we need to add the class that will retrieve and save
    the information we fetched into our MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s go ahead and create a file called `db.py` inside the `currency_converter/currency_converter/core` directory;
    let''s add some `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The only thing we need to `import` is the `MongoClient`. The `MongoClient` will
    be responsible for opening a connection with our database instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to add the `DbClient` class. The idea of this class is to serve
    as a wrapper around the `pymongo` package functions and provide a simpler set
    of functions, abstracting some of the repetitive boilerplate code when working
    with `pymongo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: a class called `DbClient` and its constructor gets two arguments, `db_name`
    and `default_collection`. Note that, in MongoDB, we don't need to create the database
    and the collection before using it. When we try to insert data for the first time,
    the database and the collection will be created for us.
  prefs: []
  type: TYPE_NORMAL
- en: This might seem strange if you are used to working with SQL databases such as
    MySQL or MSSQL where you have to connect to the server instance, create a database,
    and create all the tables before using it.
  prefs: []
  type: TYPE_NORMAL
- en: We aren't concerned about security in this example since MongoDB is beyond the
    scope of this book and we are only focusing on Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we are going to add two methods, `connect` and `disconnect`, to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `connect` method will use the `MongoClient` connecting to the database instance
    at our localhost, using the port `27017` which is the default port that MongoDB
    runs right after the installation. These two values might be different for your
    environment. The `disconnect` method simply calls the method close to the client
    and, as the name says, it closes the connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to add two special functions, `__enter__` and `__exit__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We want the `DbClient` class to be used within its own context, and this is
    achieved by using a context manager and with the `with` statement. The basic implementation
    of a context manager is done by implementing these two functions, `__enter__`
    and `__exit__`. `__enter__` will be called when we enter the context that the
    `DbClient` is running. In this case, we are going to call the `connect` method
    to connect to our MongoDB instance.
  prefs: []
  type: TYPE_NORMAL
- en: The `__exit__` method, on the other hand, is called when the current context
    is terminated. The context can be terminated by normal causes or by some exception
    that has been thrown. In our case, we disconnect from the database and, if `exec_type`
    is not equal to `None`, which means that if some exception has occurred, we raise
    that exception. This is necessary, otherwise, exceptions occurring within the
    context of the `DbClient` would be suppressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to add a private method called `_get_collection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This method will simply check if we have defined a `default_collection`. If
    not, it will throw an exception; otherwise, we return the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need just two methods to finish this class, one to find items in the database
    and another to insert or update data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `find_one` method gets one optional argument called filter, which is a dictionary
    with criteria that will be used to perform the search. If omitted, it will just
    return the first item in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few more things going on in the update method. It gets three arguments: `filter`,
    `document`, and the optional argument, `upsert.`
  prefs: []
  type: TYPE_NORMAL
- en: The `filter` argument is exactly the same as the `find_one` method; it is a
    criterion that will be used to search the collection's item that we want to update.
  prefs: []
  type: TYPE_NORMAL
- en: The `document` argument is a dictionary with the fields that we want to update
    in the collection's item or insert.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the optional argument `upsert`, when set to `True`, means that if the
    item that we are trying to update doesn't exist in the database's collection,
    then we are going to perform an insert operation and add the item to the collection.
  prefs: []
  type: TYPE_NORMAL
- en: The method starts off by getting the default collection and then uses the collection's `find_on_and_update` method,
    passing the `filter` to the dictionary with the fields that we want to update
    and also the `upsert` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to update the `__init__.py` file in the `currency_converter/currency_converter/core`
    directory with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Great! Now, we can start creating the command line parser.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the command line parser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I have to confess one thing: I''m a command-line type of guy. Yes, I know it
    is considered by some people as outdated, but I love doing work on the terminal.
    I am definitely more productive and if you are using Linux or macOS, you can combine
    tools to get the results that you want. That''s the reason that we are going to
    add a command line parser for this project.'
  prefs: []
  type: TYPE_NORMAL
- en: There are some things we need to implement in order to start creating the command
    line parser. One functionality that we are going to add is the possibility of
    setting a default currency, which will avoid user of our application always having
    to specify the base currency to perform currency conversions.
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we are going to create an action, We have seen how actions work
    in [Chapter 1](760a1425-6ef8-4e6b-ba1e-0f936d046aee.xhtml), *Implementing the
    Weather Application*, but just to refresh our minds, actions are classes that
    can be bound to command line arguments to execute a certain task. These actions
    are called automatically when the argument is used in the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before going into the development of custom actions, we need to create a function
    that will fetch the configuration of our application from the database. First,
    we are going to create a custom exception that will be used to raise errors when
    we cannot retrieve the configuration from the database. Create a file named `config_error.py`
    in the `currency_converter/currency_converter/config` directory with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! This is all we need to create our custom exception. We could have used
    a built-in exception, but that would have been too specific to our application.
    It is always a good practice to create custom exceptions for your application;
    it will make your life and the life of your colleagues much easier when troubleshooting
    bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `config.py` in the `currency_converter/currency_converter/config/` directory
    with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we start off by adding from the `import` statements. We start importing
    the `ConfigError` custom exception that we just created and we also import the
    `DbClient` class so we can access the database to retrieve the configuration for
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define the `get_config` function. This function will not take any argument,
    and the function starts by defining a variable config with a `None` value. Then,
    we use the `DbClient` to connect to the `exchange_rate` database and use the collection
    named `config`. inside the `DbClient` context, we use the `find_one` method without
    any argument, which means that the first item in that config collection will be
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: If the `config` variable is still `None`, we raise an exception saying to the
    user that there's no configuration in the database yet and that it is necessary
    to run the application again with the `--setbasecurrency` argument. We are going
    to implement the command line arguments in a short while. If we have the value
    of the config, we just return it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to create a `__init__.py` file in the `currency_converter/currency_converter/config`
    directory with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s start adding our first action, which will set the default currency.
    Add a file called `actions.py` in the `currency_converter/currency_converter/core`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: First, we import `sys` so we can terminate the program's execution if something
    goes wrong. Then, we import the `Action` from the `argparse` module. We need to
    create a class inheriting from `Action` when creating custom actions. We also
    import `datetime` because we are going to add functionality to check if the exchange
    rates that we are going to use are outdated.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we import some of the classes and functions that we created. We start
    with the `DbClient` so we can fetch and store data in the MongoDB, then `fetch_exchange_rates_by_currency`
    to fetch fresh data from `fixer.io` when necessary. Finally, we import a helper
    function called `get_config` so we can get the default currency from the config
    collection in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the `SetBaseCurrency` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define the `SetBaseCurrency` class, inheriting from `Action`, and we
    also add a constructor. It doesn't do much; it just all the constructor of the
    base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to implement a special method called `__call__`. It will be called
    when the argument that the action is bound to is parsed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This method gets four arguments, and the parser is an instance of the `ArgumentParser`
    that we are going to create shortly.  `namespace` is an object which is the result
    of the argument parser;  we went through namespace objects in detail in [Chapter
    1](760a1425-6ef8-4e6b-ba1e-0f936d046aee.xhtml), *Implementing the Weather Application*.
    The value is the value that has been passed to the underlying argument and lastly,
    the `option_string`  is the argument that the action is bound to.
  prefs: []
  type: TYPE_NORMAL
- en: We start the method by setting the value, the destination variable for the argument,
    and then create an instance of the `DbClient`. Note that we are using the `with`
    statement here, so we run the update within the DbClient context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we call the `update` method. Here, we are passing two arguments to the
    `update` method, the first being `filter`. When we have `{''base_currrency'':
    {''$ne'': None}}`, it means that we are going to update an item in the collection
    where the base currency is not equal to None; otherwise, we are going to insert
    a new item. This is the default behavior of the `update` method in the `DbClient`
    class because we have the `upsert` option set to `True` by default.'
  prefs: []
  type: TYPE_NORMAL
- en: When we finish updating, we print the message to the user saying that the default
    currency has been set and we exit the execution of the code when we hit the `finally`
    clause. If something goes wrong, and for some reason, we cannot update the `config`
    collection, an error will be displayed and we exit the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other class that we need to create it is the `UpdateForeignerExchangeRates` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the class before, we define the class and inherit from `Action`. The
    constructor only calls the constructor in the base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We also need to implement the `__call__` method, which will be called when using
    the argument that this action will be bound to. We are not going through the method
    arguments again because it is exactly the same as the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: The method starts by setting the value to `True` for the destination property.
    The argument that we are going to use to run this action will not require arguments
    and it will default to `False`, so if we use the argument, we set it to `True`.
    It is just a way of stating that we have used that argument.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we get the configuration from the database and get the `base_currency`.
    We show a message to the user saying that we are fetching the data from `fixer.io`
    and then we use our `fetch_exchange_rates_by_currency` function, passing the `base_currency`
    to it. When we get a response, we change the date to UTC time so it will be easier
    for us to calculate if the exchange rate for a given currency needs to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that `fixer.io` updates its data around 16:00 CET.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create another instance of the `DbClient` and use the `update` method
    with two arguments. The first one is `filter`, so it will change any item in the
    collection that matches the criteria, and the second argument is the response
    that we get from `fixer.io` API.
  prefs: []
  type: TYPE_NORMAL
- en: After everything is done, we hit the `finally` clause and terminate the program's
    execution. If something goes wrong, we show a message to the user in the terminal
    and terminate the program's execution.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the currency enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another thing we need to do before starting the command line parser is to create
    an enumeration with the possible currencies that the users of our application
    will be able to choose from. Let''s go ahead and create a file called `currency.py`
    in the `currency_converter/currency_converter/core` directory with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty straightforward. We have already covered enumerations in Python
    in the previous chapters, but here we define the enumeration where the key is
    the currency's abbreviation and the value is the name. This matches the currencies
    that are available in `fixer.io` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `__init__.py` file in the `currency_converter/currency_converter/core` directory
    and add the following import statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Creating the command line parser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perfect! Now, we are all set to create the command line parser. Let''s go ahead
    and create a file called `cmdline_parser.py` in the `currency_converter/currency_converter/core`
    directory and as usual, let''s start importing everything we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: From the top, we import `sys`, so that can we exit the program if something
    is not right. We also include the `ArgumentParser` so we can create the parser;
    we also import the `UpdateforeignerExchangeRates` and `SetBaseCurrency` actions
    that we just created. The last thing in the `Currency` enumeration is that we
    are going to use it to set valid choices in some arguments in our parser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a function called `parse_commandline_args`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we do here is get only the names of the `Currency` enumeration''s
    keys; this will return a list like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c9385f16-58d4-4ec9-94db-6905c05a5be3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we finally create an instance of the `ArgumentParser` and we pass two
    arguments: `prog`, which is the name of the program, we can call it `currency_converter`,
    and the second is `description`(the description that will be displayed to the
    user when the `help` argument is passed in the command line).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the first argument that we are going to add in `--setbasecurrency`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The first argument that we define is `--setbasecurrency`. It will store the
    currency in the database, so we don't need to specify the base currency all the
    time in the command line. We specify that this argument will be stored as a string
    and the value that the user enters will be stored in an attribute called `base_currency`.
  prefs: []
  type: TYPE_NORMAL
- en: We also set the argument choices to the `currency_options` that we defined in
    the preceding code. This will ensure that we can only pass currencies matching
    the `Currency` enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: '`action` specifies which action is going to be executed when this argument
    is used, and we are setting it to the `SetBaseCurrency` custom action that we
    defined in the `actions.py` file. The last option, `help`, is the text that is
    displayed when the application''s help is displayed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the `--update` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `--update` argument, as the name says, will update the exchange rates for
    the default currency. It is meant to be used after the `--setbasecurrency` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we define the argument with the name `--update`, then we set the `metavar` argument.
    The `metavar` keyword `--update` will be referenced when the help is generated.
    By default, it's the same as the name of the argument but in uppercase. Since
    we don't have any value that we need to pass to this argument, we set `metavar`
    to nothing. The next argument is `nargs`, which tells the `argparser` that this
    argument does not require a value to be passed. Finally, we have the `action` that
    we set to the other custom action that we created previously, the `UpdateForeignExchangeRates`
    action. The last argument is `help`, which specifies the help text for the argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next argument is the `--basecurrency` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The idea with this argument is that we want to allow users to override the default
    currency that they set using the `--setbasecurrency` argument when asking for
    a currency conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we define the argument with the name `--basecurrency`. With the `string` type,
    we are going to store the value passed to the argument in an attribute called
    `from_currency`; we also set the choices to `currency_option` here so we can make
    sure that only currencies that exist in the `Currency` enumeration are allowed.
    Lastly, we set the help text.
  prefs: []
  type: TYPE_NORMAL
- en: The next argument that we are going to add is called `--value`. This argument
    will receive the value that the users of our application want to convert to another
    currency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we will write it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set the name of the argument as `--value`. Note that the type is different
    from the previous arguments that we defined. Now, we will receive a float value,
    and the argument parser will store the value passed to the `--value` argument
    to the attribute called value. The last argument is the `help` text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the last argument that we are going to add in the argument that specifies
    which currency the value will be converted to is going to be called `--to`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This argument is very similar to the `--basecurrency` argument that we defined
    in the preceding code. Here, we set the argument's name to `--to` and it is going
    to be of type `string`. The value passed to this argument will be stored in the
    attribute called `dest_currency`. Here, we also set a choice of arguments to the
    list of valid currencies that we extracted from the `Currency` enumeration; last
    but not the least, we set the help text.
  prefs: []
  type: TYPE_NORMAL
- en: Basic validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that many of these arguments that we defined are required. However, there
    are some arguments that are dependent on each other, for example, the arguments
    `--value` and `--to`. You cannot try to convert a value without specifying the
    currency that you want to convert to and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another problem here is that, since many arguments are required, if we run
    the application without passing any argument at all, it will just accept it and
    crash; the right thing to do here is that, if the user doesn''t use any argument,
    we should display the Help menu. With that said, we need to add a function to
    perform this kind of validation for us, so let''s go ahead and add a function
    called `validate_args`. You can add this function right at the top, after the
    `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: So, `args` is going to be passed to this function. `args` is actually an object
    of `time` and `namespace`. This object will contain properties with the same name
    that we specified in the `dest` argument in the argument's definitions. In our
    case, the `namespace` will contain these properties: `base_currency`, `update`,
    `from_currency`, `value`, and `dest_currency`.
  prefs: []
  type: TYPE_NORMAL
- en: We use a comprehension to get all the fields that are not set to `None`. In
    this comprehension, we use the built-in function `vars`, which will return the
    value of the property `__dict__` of `args`, which is an instance of the `Namespace`
    object. Then, we use the `.items()` function so we can iterate through the dictionary
    items and one by one test if its value is `None`.
  prefs: []
  type: TYPE_NORMAL
- en: If any argument is passed in the command line, the result of this comprehension
    will be an empty list, and in that case, we return `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we test the arguments that need to be used in pairs: `--value` (value)
    and `--to` (`dest_currency`). It will return `False` if we have a value, but `dest_currency`
    is equal to `None` and vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can complete `parse_commandline_args`. Let''s go to the end of this
    function and add the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we parse the arguments and set them to the variable `args`, and remember
    that `args` will be of the `namespace` type. Then, we pass `args` to the function
    that we just created, the `validate_args` function. If the `validate_args` returns
    `False`, it will print the help and terminate the program's execution; otherwise,
    it will return `args`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to develop the application's entry point that will glue together
    all the pieces that we have developed so far.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the application's entry point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the section of this chapter that we all have been waiting for; we are
    going to create the application entry point and glue together all the pieces of
    code that we have written so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a file called `__main__.py` in the `currency_converter/currency_converter`
    directory. We have already used the `_main__` file before in [Chapter 1](760a1425-6ef8-4e6b-ba1e-0f936d046aee.xhtml),
    *Implementing the Weather Application*. When we place a file called `__main__.py`
    in the module''s `root` directory, it means that that file is the entry script
    of the module. So, if we run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'It is the same as running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! So, let''s start adding content to this file. First, add some `import`
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We import the `sys` package as usual in case we need to call exit to terminate
    the execution of the code, then we import all the classes and utility functions
    that we developed so far. We start by importing the `parse_commandline_args` function
    for command line parsing, the `get_config` so that we can get hold of the default
    currency set by the user, the `DbClient` class so we can access the database and
    fetch the exchange rates; lastly, we also import the `fetch_exchange_rates_by_currency ` function,
    which will be used when we choose a currency that is not in our database yet.
    We will fetch this from the `fixer.io` API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can create the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` function starts off by parsing the command line arguments. If everything
    is entered by the user correctly, we should receive a `namespace` object containing
    all the arguments with its values. In this stage, we only care about three arguments:
    `value`, `dest_currency`, and `from_currency`. If you recall from earlier, `value`
    is the value that the user wants to convert to another currency, `dest_currency`
    is the currency that the user wants to convert to, and `from_currency` is only
    passed if the user wishes to override the default currency that is set on the
    database.'
  prefs: []
  type: TYPE_NORMAL
- en: After getting all these values, we call `get_config` to get the `base_currency`
    from the database, and right after that we check if there is a `from_currency` where
    we can use the value; otherwise, we use the `base_currency` from the database.
    This will ensure that if the user specifies a `from_currency` value, then that
    value will override the default currency stored in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we implement the code that will actually fetch the exchange rates from
    the database or from the `fixer.io` API, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We create a connection with the database using the `DbClient` class and also
    specify that we are going to access the rates collection. inside the context,
    we first try to find the exchange rated for the base currency. if it is not in
    the database, we try to fetch it from `fixer.io`.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we extract the exchange rate value for the currency that we are
    converting to and insert the result in the database so that, the next time that
    we run the program and want to use this currency as the base, we don't need to
    send a request to `fixer.io` again.
  prefs: []
  type: TYPE_NORMAL
- en: If we find the exchange rate for the base currency, we simply get that value
    and assign it to the `dest_rate` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we have to do is perform the conversion and use the built-in
    round function to limit the number of digits after the decimal point to two digits,
    and we print the value in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the file, after the `main()` function, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: And we're all done!
  prefs: []
  type: TYPE_NORMAL
- en: Testing our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s test our application. First, we are going to show the help message to
    see which options we have available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b0f7d3ce-7807-4396-9065-ce200aabd67b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Nice! Just as expected. Now, we can use the `--setbasecurrency` argument to
    set the base currency:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ad6fb0bd-bcf1-49eb-a325-f9fc65accb57.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, I have set the base currency to SEK (Swedish Kronor) and, every time
    I need to perform a currency conversion, I don''t need to specify that my base
    currency is SEK. Let''s convert 100 SEK to USD (United States Dollars):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/38bfab21-ab5d-4b56-b505-d51ebb2957ee.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we didn't have the exchange rate in the database yet, so the
    first thing the application does is to fetch it from `fixer.io` and save it into
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since I am a Brazilian developer based in Sweden, I want to convert SEK to
    BRL (Brazil Real) so that I know how much Swedish Crowns I will have to take to
    Brazil next time I go to visit my parents:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4666b921-54a0-4ed8-914d-96324ba2d6d6.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that, since this is the second time that we are running the application,
    we already have exchange rates with  SEK as the base currency, so the application
    does not fetch the data from `fixer.io` again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the last thing that we want to try is overriding the base currency.  At
    the moment, it is set to SEK. We use MXN (Mexico Peso) and convert from MXN to
    SEK:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/30e9fa97-c5a3-4c03-be9f-cf743813f5de.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered a lot of interesting topics. In the first section,
    while setting up the environment for our application, you learned how to use the
    super new and popular tool `pipenv`, which has become the recommend tool at [python.org](https://www.python.org/)
    for creating virtual environments and also managing project dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned the basic concepts of object-oriented programming, how to create
    custom actions for your command line tools, the basics about context managers
    which is a really powerful feature in the Python language, how to create enumerations
    in Python, and how to perform HTTP requests using `Requests`, which is one of
    the most popular packages in the Python ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not the least, you learned how to use the `pymongo` package to insert,
    update, and search for data in a MongoDB database.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to switch gears and develop a complete, very
    functional web application using the excellent and very popular Django web framework!
  prefs: []
  type: TYPE_NORMAL
