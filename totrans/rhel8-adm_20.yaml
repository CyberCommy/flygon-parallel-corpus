- en: '*Chapter 17*: Managing Containers with Podman, Buildah, and Skopeo'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll learn to use **Podman** and **Red Hat Universal Base
    Image**, also called **UBI**. Together, Podman and UBI provide users with the
    software they need to run, build, and share enterprise-quality containers on **Red
    Hat Enterprise Linux** (**RHEL**).
  prefs: []
  type: TYPE_NORMAL
- en: In recent years, understanding and using containers has become a key requirement
    for Red Hat systems administrators. In this chapter, we'll review the basics of
    containers, how containers work, and the standard tasks for managing containers.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to run containers with simple commands, build enterprise-quality
    container images, and deploy them on a production system. You will also learn
    when to use more advanced tools such as **Buildah** and **Skopeo**.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the topics that will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a container using Podman and UBI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to use Buildah and Skopeo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will review the basic usage of Podman, Buildah, and Skopeo,
    as well as how to build and run containers using Red Hat UBI.
  prefs: []
  type: TYPE_NORMAL
- en: We will create and run containers on the local RHEL 8 system, as we deployed
    in [*Chapter 1*](B16799_01_Final_SK_ePub.xhtml#_idTextAnchor014), *Installing
    RHEL8*. You will need to have the `container-tools:rhel8` **Application Stream**
    installed.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Containers provide users with a new way to run software on Linux systems. Containers
    provide all the dependencies related to a given piece of software, in a consistent
    redistributable manner. While containers were first made popular by Docker, Google,
    Red Hat, and many others joined Docker to create a set of open standards called
    the **Open Container Initiative** (**OCI**). The popularity of the OCI standards
    has facilitated a large ecosystem of tools where users don''t have to worry about
    compatibility between popular container images, registries, and tools. Containers
    have become standardized in recent years and most major tools follow three standards
    governed by the OCI, outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Image specification**: Governs how container images are saved on disk'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime specification**: Specifies how containers are started by communicating
    with the operating system (in particular, the Linux kernel)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distribution specification**: Governs how images are pushed and pulled from
    registry servers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can learn more about this at https://opencontainers.org/.
  prefs: []
  type: TYPE_NORMAL
- en: 'All container tools (Docker, Podman, Kubernetes, and so on) need an operating
    system to run the container, and each operating system can choose different sets
    of technology to secure containers, as long as they comply with the OCI standards.
    RHEL uses the following operating system capabilities to securely store and run
    the containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Namespaces**: These are a technology in the Linux kernel that helps isolate
    processes from one another. Namespaces prevent containerized processes from having
    visibility of other processes on the host operating system (including other containers).
    Namespaces are what make a container feel like a **virtual machine** (**VM**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Control groups (Cgroups)**: These limit the amount of **central processing
    unit** (**CPU**), memory, disk **input/output** (**I/O**), and/or network I/O
    available to a given process/container. This prevents the *noisy neighbor* problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security-Enhanced Linux (SELinux)**: As described in [*Chapter 10*](B16799_10_Final_SK_ePub.xhtml#_idTextAnchor143),
    *Keeping Your System Hardened with SELinux*, this provides an extra layer of operating
    system security that can limit the damage caused by security exploits. SELinux
    is nearly transparent when used in conjunction with containers and provides mitigation
    of security breakouts, even when there are vulnerabilities in tools such as Podman,
    Docker, or Runc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many systems administrators use VMs to isolate applications and their dependencies
    (libraries, and so on). Containers provide the same level of isolation but reduce
    the overhead of virtualization. Since containers are simple processes, they do
    not need a **virtual CPU** (**vCPU**) with all of the overhead of translation.
    Containers are also smaller than VMs, which simplifies management and automation.
    This is particularly useful for **continuous integration/continuous delivery**
    (**CI/CD**).
  prefs: []
  type: TYPE_NORMAL
- en: 'RHEL provides users with container tools and images that are compatible with
    all OCI standards. This means they work in a way that is very familiar to anyone
    who has used Docker. For those unfamiliar with these tools and images, the following
    concepts are important:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Layers**: Container images are constructed as a set of layers. New containers
    are created by adding new layers (even to delete things) that reuse existing lower
    layers. The ability to use existing prepackaged containers is convenient for developers
    who simply want to make changes to their applications and test them in a reproducible
    way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distribution and deployments**: Since containers provide all the dependencies
    coupled with an application, they are easy to deploy and redistribute. Combining
    them with container registries makes it easy to share container images, and collaboration,
    deployments, and rollbacks are much quicker and easier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The container tools provided with RHEL make it easy to deploy containers at
    a small scale, even for production workloads. But to manage containers at scale
    and with reliability, container orchestration such as Kubernetes is a much better
    fit. Red Hat, following the lessons learned from building Linux distributions,
    has created a Kubernetes distribution called **OpenShift**. If you need to deploy
    containers at scale, we recommend you take a look at this platform. The container
    tools and images provided in RHEL, and introduced in this chapter, will provide
    a solid foundation for later deploying to Kubernetes/OpenShift if and when you
    are ready for it. The tools introduced in this chapter are built in a way that
    will prepare your applications to be deployed in Kubernetes when you are ready
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing container tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two Application Streams for **container tools** provided in RHEL 8\.
    The first is a fast-moving stream that is updated every 12 weeks. The second is
    a stable stream that is released once a year and supported for 24 months.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we install the container tools, let''s take a look at which ones are
    available, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the main tools that we have listed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`podman`: This is the command to run containers. You may use it in every case
    in which you find the use of the `docker` command in the examples you will discover
    on the internet. It is the command we will use in this chapter to run our own
    containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buildah`: This is a tool specific to create container images. It uses the
    same Dockerfile definitions as Docker but without the need for a daemon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skopeo`: A tool to introspect containers and check the different layers so
    that we can review whether they contain any non-compliant issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will install the fast-moving stream to get access to the latest versions
    of Podman, Skopeo, and Buildah, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You now have a machine installed with all of the tools you need to build, run,
    and manage containers on an RHEL 8 system.
  prefs: []
  type: TYPE_NORMAL
- en: Running a container using Podman and UBI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now you have the container tools'' Application Stream installed, let''s run
    a simple container based on Red Hat UBI that is a set of official container images
    and extra software based on RHEL. To run a UBI image, it only takes a single command,
    as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: These tutorials run commands as root, but one of the benefits of Podman is that
    it can run containers as a regular user without special permissions or a running
    daemon in the system.
  prefs: []
  type: TYPE_NORMAL
- en: You now have a fully isolated environment to execute whatever you want. You
    can run any commands you'd like in this container. It's isolated from the host
    and from other containers that might be running, and you can even install software
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Red Hat UBI is based on software and packages from RHEL. This is the official
    image for use with RHEL and provides a rock solid, enterprise-ready base for your
    containers. UBI is used throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Running a one-off container such as this is useful for testing new configuration
    changes and new pieces of software without interfering with software directly
    on the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the processes running in the container, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the only processes running are the shell we are using and the
    command we have just run. It is a completely isolated environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, exit the container by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a working set of container tools and a UBI container image cached
    locally, we're going to move on to some more basic commands.
  prefs: []
  type: TYPE_NORMAL
- en: Basic container management – pull, run, stop, and remove
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we''ll run some basic commands to get familiar with using
    containers. First, let''s pull some more images, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have several different images cached locally. Let''s take a look at
    these here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we have four images cached locally. The Red Hat UBI actually comes
    in multiple flavors, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: "`ubi8/ubi`): An RHEL-based container base image with **YellowDog Updater Modified**\
    \ (**YUM**)/**Dandified YUM** (**DNF**) in the image. It can be used in a similar\
    \ way to any other Linux base image. This image is targeted \Lat 80% of people's\
    \ use cases and can easily be consumed from within a Dockerfile \Lor Containerfile.\
    \ The trade-off with this image is that it is larger than some of the other images."
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ubi8/ubi-minimal`): This base image minimizes the size by using a small package
    manager called `microdnf` that is written in C instead of Python, like for standard
    YUM/DNF. This C implementation makes it smaller and pulls fewer dependencies into
    a container image. This base image can be used in any Dockerfile or Containerfile
    simply by using the `microdnf` command instead of `yum`. This image saves about
    80 **megabytes** (**MB**) in memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ubi8/ubi-micro`): This base image is built without a package manager. It cannot
    be used with a standard Dockerfile or Containerfile. Users instead add software
    to this image using the Buildah tool on the container host. This image is the
    smallest base image provided in RHEL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ubi8/ubi-init`): Based on the RHEL standard image, this image also supports
    the use of `systemd` in the container. This makes it easy to install a few pieces
    of software, start them with `systemd`, and treat the container in a similar way
    to a VM. This image is best for users who don''t mind slightly larger images and
    just want ease of use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that you understand the basics of the four types of base images, let''s
    start a container in the background so that we can inspect it while it''s running.
    Start it in the background with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when we start the container, the shell returns to normal and we
    can't type commands in the container. Our terminal doesn't enter a shell in the
    container. The `-d` option specified that the container should run in the background.
    This is how most server-based software such as web servers runs on a Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can still connect our shell to a container running in the background if
    we need to troubleshoot one, but we have to determine which container we want
    to connect to. To do this, list all of the containers that are running with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We could reference the container using the CONTAINER ID value, but we have
    started the container with the name background to make it easier to reference.
    We can enter the container and see what is going on inside it with the exec subcommand,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After you type a few commands, exit the container by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s stop the containerized process by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Check to make sure it''s really stopped by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the state is `Exited`. This means the process has been stopped and is
    no longer in memory, but the storage is still available on disk. The container
    could be restarted, or we can delete it permanently with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This deleted the storage and the container has now gone forever. Verify this
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This section taught you some basic commands, but let's now move on to attaching
    storage.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching persistent storage to a container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember that the storage in a container is ephemeral. Once the `podman rm`
    command is executed, the storage is deleted. If you have data that you need to
    save after the container is removed, you need to use a volume. To run a container
    with a volume, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command has mounted `/mnt` into the container, and the `Z` option
    has told it to appropriately change the SELinux labels so that data can be written
    to it. The `--rm` option ensures that the container is removed as soon as you
    exit the shell. You can now save data on this volume, and it won''t be removed
    when you exit the container. Add some data by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inspect the test file you created by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice the file is still on the system although the container has been removed,
    and its internal storage has been deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a container on a production system with systemd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since Podman is not a daemon, it relies on `systemd` to start a container when
    the system boots. Podman makes it easy to start a container with `systemd` by
    creating a `systemd` `systemd` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Run a container with Podman exactly how you want it to run in production.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Export a `systemd` unit file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure `systemd` to use this unit file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, let''s run an example container, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s export the `systemd` unit file that we''ll use to start this container,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable and start the service by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Test that the container is running by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, check that the container is running by using the `podman` command, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This container will now start every time the system boots; even if you kill
    the container with Podman, `systemd` will always make sure this container is running.
    Podman and `systemd` make it easy to run containers in production. Now, let''s
    stop the container with `systemctl` and disable it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Building a container image using a Dockerfile or Containerfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we know how to run containers, let''s learn how to build our own container
    images. Container images are commonly built with a file that serves as a blueprint
    for how to build it the same way every time. A `Containerfile` with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple Containerfile pulls the UBI standard base image and applies all
    of the latest updates to it. Now, let''s build a container image by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You now have a new image called `test-build` that has a new layer with all
    of the updated packages from the Red Hat UBI repositories, as illustrated in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The workflow for building images from a Dockerfile or Containerfile is nearly
    identical to how Docker was in RHEL 7 or any other operating system. This makes
    it easy for system administrators and developers to move to Podman.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Podman to search registry servers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Container registries** are like file servers for container images. They allow
    users to build and share container images, resulting in better collaboration.
    Often, it''s useful to pull container images from public registry servers that
    are located on the internet, but in many instances, corporations have private
    registries that are not public. Podman makes it easy to search multiple registries,
    including private registries, on your company''s network.'
  prefs: []
  type: TYPE_NORMAL
- en: Podman comes with a configuration file that allows users and administrators
    to select which registries are searched by default. This makes it easy for users
    to find the container images that administrators want them to find.
  prefs: []
  type: TYPE_NORMAL
- en: 'A set of default registries to search are defined in `/etc/containers/registries.conf`.
    Let''s take a quick look at this file by filtering all the comments in it, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have the `registries.search` section for secure registries
    that includes the two main Red Hat registries, `registry.access.redhat.com` and
    `registry.redhat.io`, as well as the `docker.io` Docker registry. All of these
    registries are secured with `registries.insecure` section.
  prefs: []
  type: TYPE_NORMAL
- en: Separately from TLS, all images provided by Red Hat are signed and provide a
    signature store that can be used to verify them. This is not configured by default
    and is beyond the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that Podman is using and searching the proper registries, run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to publish your own images, you can do this in the service that
    Red Hat offers to do so: [https://quay.io](https://quay.io). You can also configure
    `registries.conf` to search `quay.io` for images you store there.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary of Podman options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s review the options used with Podman in this chapter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_1.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see while reviewing the table, Podman includes options to manage
    the full container life cycle. Most Podman commands are compatible with `docker`.
    Podman even provides a package (`podman-docker`) that supplies an alias from `podman`
    to `docker` so that users can continue to type a command they are familiar with.
    While Podman and Docker feel quite similar to use, Podman can be run as a regular
    user and does not require a daemon to be continuously running. Let's move on to
    the next section to explore some advanced use cases.
  prefs: []
  type: TYPE_NORMAL
- en: When to use Buildah and Skopeo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Podman is a general-purpose container tool and should solve 95% of a user's
    needs. Podman leverages Buildah and Skopeo as libraries and pulls these tools
    together under one interface. That said, there are edge cases when a user may
    want to leverage Buildah or Skopeo separately. We will explore two such use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Building container images with Buildah
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Building from a Dockerfile or Containerfile is quite easy, but it does come
    with some trade-offs. For example, Buildah is good in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: When you need granular control over committing image layers. This can be necessary
    when you want two or three commands to run, and then commit a single layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you have difficult-to-install software—for example, some third-party software
    comes with standardized installers that don't understand they are being run in
    a Dockerfile. Many of these `install.sh` installers assume they have access to
    the entire filesystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a container image does not provide a package manager. UBI Micro builds
    very small images because it does not have a Linux package manager installed,
    nor any of the dependencies of a package manager.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this example, let''s build on top of UBI Micro to demonstrate why Buildah
    is such a great tool. First, create a new container to work with, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command created a reference to a new container called `ubi-micro-working-container`.
    Once Buildah creates this reference, you can build upon it. To make it easier,
    let''s start over and save the reference in a shell variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then mount the new container as a volume. This lets you modify the
    container image by changing files in a directory. Run the following command to
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the container storage is mounted, you can modify it in any way you would
    like. These changes will eventually be saved as a new layer in the container image.
    This is where you could run an installer (`install.sh`), but in the following
    example, we will use the package manager on the host to install packages in UBI
    Micro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When the package installation completes, we will unmount the storage and commit
    the new image layer as a new container image called `ubi-micro-httpd`, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You now have a new container image with `httpd` installed, built on UBI Micro.
    Only a minimal set of dependencies have been pulled in. Look here at how small
    the image is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Buildah is a wonderful tool that gives you a lot of control over how builds
    are done. Now, we will move on to Skopeo.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting a remote container with Skopeo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Skopeo is specifically designed and built to work on remote container repositories.
    With the following command, you can easily remotely inspect the available tags
    for an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Remote inspection is useful to determine if you want to pull an image, and if
    so, with which tag. Skopeo can also be used to copy between two remote registry
    servers without caching a copy in the local storage. For more information, see
    the `skopeo` man pages.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have reviewed the basics of how to run, build, and share
    containers on RHEL 8\. You are prepared to create your own containers, run them,
    manage them, and even use `systemd` to ensure they're always running in a production
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: You are now ready to leverage the functionality and ease of deployment that
    containers provide. While a deep dive into all of the intricacies of migrating
    software into containers is outside the scope of this book, containers simplify
    packaging and delivery of applications ready to be executed with all of their
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Containers are now a strong focus within the **Information Technology** (**IT**)
    industry. Containers alone simplify the packaging and delivery of applications,
    but orchestration platforms such as OpenShift (based on Kubernetes) make it easier
    to deploy, upgrade, and manage containerized applications at scale.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations—you have come to the end of this chapter! It's now time to move
    to the next chapter and take a self-assessment to ensure you've absorbed the material
    and to practice your skills. There are two more chapters to go.
  prefs: []
  type: TYPE_NORMAL
