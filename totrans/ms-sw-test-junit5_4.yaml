- en: Simplifying Testing With Advanced JUnit Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simplicity is the ultimate sophistication.
  prefs: []
  type: TYPE_NORMAL
- en: '- Leonardo da Vinci'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have discovered the basics of Jupiter, the brand-new programming
    model provided by the JUnit 5 framework. Moreover, Jupiter provides a rich range
    of possibilities which allows to create different types of test cases. In this
    chapter, we review these advanced features. To that aim, this chapter is structured
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency injection**: This section first takes a look at dependency injection
    for constructors and methods in test classes. Then, it reviews the three parameter
    resolvers provided out of the box in Jupiter. These resolvers allow to inject
    objects of `TestInfo`, `RepetitionInfo`, and `TestReporter` inside tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic tests**: This section discusses how dynamic tests are implemented
    in JUnit 5, using the methods `dynamicTest` and `stream`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test interfaces**: The section reviews the Jupiter annotations that can be
    declared on test interfaces and default methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test templates**: JUnit 5 introduces the concept of a template for tests
    cases. These templates will be invoked multiple times, depending on the invocation
    contexts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameterized tests**: In the same way as JUnit 4, JUnit 5 provides capabilities
    to create tests driven by different input data, that is, a parametrized test.
    We will discover that the support for this kind of test has been significantly
    enhanced in the Jupiter programming model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java 9**: On September 21, 2017, Java 9 released. As we will discover, JUnit
    5 has been implemented to be compatible with Java 9, with special emphasis on
    the modularity feature of Java 9.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In former JUnit versions, test constructors and methods were not allowed to
    have parameters. One of the major changes in JUnit 5 is that both test constructors
    and methods are now allowed to include parameters. This feature enables the dependency
    injection for constructors and methods.
  prefs: []
  type: TYPE_NORMAL
- en: As introduced in [Chapter 2](part0051.html#1GKCM0-ef8404ed083f459d860f84cc8198f8bb),
    *What's New In JUnit 5* of this book, the extension model has an extension that
    provides dependency injections for Jupiter tests, called `ParameterResolver`,
    which defines an API for test extensions that wish to dynamically resolve parameters
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a test constructor or a method annotated with `@Test,` `@TestFactory`, `@BeforeEach`,
    `@AfterEach`, `@BeforeAll`, or `@AfterAll` accepts a parameter, that parameter
    is resolved at runtime by a resolver (object with parent class `ParameterResolver`).
    There are three built-in resolvers registered automatically in JUnit 5: `TestInfoParameterResolver`,
    and `RepetitionInfoParameterResolver`, `TestReporterParameterResolver`. We review
    each one of these resolvers in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: TestInfoParameterResolver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given a test class, if a method parameter is of type `TestInfo`, the JUnit 5
    resolver `TestInfoParameterResolver` supplies an instance of `TestInfo` corresponding
    to the current test as the value for the declared parameter. The `TestInfo` object
    is used to retrieve information about the current test, such as the test display
    name, the test class, the test method, or associated tags.
  prefs: []
  type: TYPE_NORMAL
- en: '`TestInfo` acts as a drop-in replacement for the `TestName` rule from JUnit
    4.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The class `TestInfo` is placed in the package `org.junit.jupiter.api` and offers
    the following API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String getDisplayName()` : This returns the display name of the test or container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set<String> getTags()` : This gets the set of all tags for the current test
    or container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Optional<Class<?>> getTestClass()` : This gets the class associated with the
    current test or container, if available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Optional<Method> getTestMethod()` : This gets the method associated with the
    current test, if available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00067.jpeg)*TestInfo* API'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example. Notice that in the following class, both the methods
    annotated with `@BeforeEach` and `@Test` accepts a parameter of `TestInfo`. This
    parameter is injected by `TestInfoParameterResolver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, in the body of each method, we are able to use the `TestInfo` API
    to get the test information at runtime, as the following screenshot demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00068.gif)'
  prefs: []
  type: TYPE_IMG
- en: Console output of dependency injection of *TestInfo* objects
  prefs: []
  type: TYPE_NORMAL
- en: RepetitionInfoParameterResolver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second resolver provided out of the box in JUnit 5 is called `RepetitionInfoParameterResolver`.
    Given a test class, if a method parameter in a `@RepeatedTest`, `@BeforeEach`,
    or `@AfterEach` method is of type `RepetitionInfo`, the `RepetitionInfoParameterResolver`
    will supply an instance of `RepetitionInfo`.
  prefs: []
  type: TYPE_NORMAL
- en: '`RepetitionInfo` can be used to retrieve information about the current repetition
    and the total number of repetitions for the corresponding `@RepeatedTest`. The
    API of `RepetitionInfo` offers two methods, as shown in the screenshot after the
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int getCurrentRepetition()`: Gets the current repetition of the corresponding
    `@RepeatedTest` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int getTotalRepetitions()`: Gets the total number of repetitions of the corresponding
    `@RepeatedTest` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00069.jpeg)*RepetitionInfo* API'
  prefs: []
  type: TYPE_NORMAL
- en: 'The class here contains a simple example for the use of `RepetitionInfo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be seen in the test output, we are able to read the information about
    the repeated test at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00070.gif)'
  prefs: []
  type: TYPE_IMG
- en: The console output of dependency injection of *RepetitionInfo* objects.
  prefs: []
  type: TYPE_NORMAL
- en: TestReporterParameterResolver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last built-in resolver in JUnit 5 is `TestReporterParameterResolver`. Again,
    given a test class, if a method parameter is of type `TestReporter`, the `TestReporterParameterResolver` 
    supplies an instance of `TestReporter`.
  prefs: []
  type: TYPE_NORMAL
- en: '`TestReporter` is used to publish additional data about the test execution.
    The data can be consumed through the method `reportingEntryPublished`, and then,
    it can be requested by IDEs or included in test reports. Each `TestReporter` object
    stores information as a map, that is, a key-value collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00071.jpeg)*TestReporter* API'
  prefs: []
  type: TYPE_NORMAL
- en: 'This test provides a simple example of `TestReporter`. As we can see, we use
    the injected `testReporter` object to add custom information using key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Dynamic tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we know, in JUnit 3, we identified tests by parsing method names and checking
    whether they started with the word test. Then, in JUnit 4, we identified tests
    by collecting methods annotated with `@Test`. Both of these techniques share the
    same approach: tests are defined at compile time. This concept is what we call
    static testing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Static tests are considered a limited approach, especially for the common scenario
    in which the same test is supposed to be executed for a variety of input data.
    In JUnit 4, this limitation was addressed in several ways. A very simple solution
    to the problem is to loop the input test data and exercising the same test logic
    (JUnit 4 example here). Following this approach, one test is executed until the
    first assertion fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A more elaborate solution is to use the JUnit 4 support for parameterized tests,
    using the parameterized runner. This approach does not create tests at runtime
    either, it simply repeats the same test several times depending on the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the execution of the preceding example in the Eclipse IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Execution of JUnit 4’s parameterized test in Eclipse
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, JUnit 5 allows to generate test at runtime by a factory method
    that is annotated with `@TestFactory`. In contrast to `@Test`, a `@TestFactory`
    method is not a test but a factory. A `@TestFactory` method must return a `Stream`,
    `Collection`, `Iterable`, or `Iterator` of `DynamicTest` instances. These `DynamicTest`
    instances are executed lazily, enabling dynamic generation of test cases.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a dynamic test, we can use the static method `dynamicTest`
    of the class `DynamicTest` located in the `org.junit.jupiter.api` package. If
    we inspect the source code of this class, we can see that a `DynamicTest` is composed
    of a display name in form of the String and one executable object, which can be
    provided as lambda expressions or as method references.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see several examples of dynamic tests. In the following example, the
    first dynamic test will fail, due to the fact we are not returning the expected
    collection of `DynamicTests`. The next three methods are very simple examples
    that demonstrate the generation of `Collection`, `Iterable`, and `Iterator` of
    `DynamicTest` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'These examples do not really exhibit dynamic behavior, but merely demonstrate
    the supported return types. Note that the first test is going to fail due to `JUnitException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00073.gif)'
  prefs: []
  type: TYPE_IMG
- en: Console output of the first example for dynamic test execution
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates how easy it is to generate dynamic tests
    for a given set of input data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that, in the end, three tests were executed, and these three tests were
    created at runtime by JUnit 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00074.gif)'
  prefs: []
  type: TYPE_IMG
- en: Console output of the second example for dynamic test execution
  prefs: []
  type: TYPE_NORMAL
- en: There is another possibility to create dynamic tests in JUnit 5, using the static
    method `stream` of the class `DynamicTest`. This method needs an input generator,
    a function that generates a display name based on an input value, and a test executor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see another example. We create a test factory, providing the input data
    as an `Iterator`, a display name function using a lambda expression, and finally,
    a test executor implemented with another lambda expression. In this example, the
    test executor basically asserts whether or not the input integer is even or odd:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The test will fail for odd inputs. As we can see, two out of three tests will
    fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00075.gif)'
  prefs: []
  type: TYPE_IMG
- en: Console output of dynamic test execution (example three)
  prefs: []
  type: TYPE_NORMAL
- en: Test interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In JUnit 5, there are different rules relative to the use of annotations in
    Java interfaces. First of all, we need to be aware that `@Test`, `@TestFactory`,
    `@BeforeEach`, and `@AfterEach` can be declared on interface default methods.
  prefs: []
  type: TYPE_NORMAL
- en: Default methods is a feature of Java introduced in version 8\. These methods
    (declared using the reserve keyword `default`) allows to define a default implementation
    for a given method within a Java interface. This capability can be useful for
    backward compatibility with existing interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The second rule regarding JUnit 5 and interfaces is that `@BeforeAll` and `@AfterAll`
    can be declared on `static` methods in a test interface. Moreover, if the test
    class, which implements a given interface, is annotated with `@TestInstance(Lifecycle.PER_CLASS)`,
    the methods `@BeforeAll` and `@AfterAll` declared on the interface do not need
    to be `static`, but `default` methods.
  prefs: []
  type: TYPE_NORMAL
- en: The third and final rule concerning interfaces in JUnit 5 is `@ExtendWith` and
    `@Tag` can be declared on test interfaces to configure extensions and tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see some simple examples. In the following class, we are creating an
    interface, not a class. In this interface, we use the annotations `@BeforeAll`,
    `@AfterAll`, `@BeforeEach`, and `@AfterEach`. On the one hand, we define `@BeforeAll`,
    `@AfterAll` as static methods. On the other hand, we are defining `@BeforeEach`
    and `@AfterEach` as Java 8 default methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We are using the library Simple Logging Facade for Java (SLF4J) in this example.
    Take a look at the code on GitHub ([https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5))
    for details on the declaration of dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are using the annotation `TestFactory` to define a default
    method in a Java interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we use the annotation `@Tag` and `@ExtendWith` in another interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'All in all, we can use these interfaces in our Jupiter tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this test, the fact of implementing all the previously defined interfaces
    will provide the logging capabilities implemented in the default methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00076.gif)'
  prefs: []
  type: TYPE_IMG
- en: Console output of test implementing several interfaces
  prefs: []
  type: TYPE_NORMAL
- en: Test templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `@TestTemplate` method is not a regular test case but a template for test
    cases. Method annotated like this will be invoked multiple times, depending on
    the invocation context returned by the registered providers. Thus, test templates
    are used together with a registered `TestTemplateInvocationContextProvider` extension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The required provided implements the Jupiter interface `TestTemplateInvocationContextProvider`.
    Inspecting the code of this class, we can see how two `String` parameters are
    provided to the test template (in this case, the value for these parameters are
    `parameter-1` and `parameter-2`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When the test is executed, each invocation of the test template behaves like
    a regular `@Test`. In this example, the test is only writing the parameter in
    the standard output.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00077.gif)'
  prefs: []
  type: TYPE_IMG
- en: Console output of test template example
  prefs: []
  type: TYPE_NORMAL
- en: Parameterized tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parameterized tests are a special kinds of tests in which the data input is
    injected in the test in order to reuse the same test logic. This concept was already
    addressed in JUnit 4, as explained in [Chapter 1](part0021.html#K0RQ0-ef8404ed083f459d860f84cc8198f8bb),
    *Retrospective On Software Quality And Java Testing*. As we would expect, parameterized
    tests are also implemented in JUnit 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, in order to implement a parameterized test in Jupiter, we need
    to add the `junit-jupiter-params` to our project. When using Maven, that means
    adding the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As usual, as a general rule, it is recommended to use the latest version of
    the artifacts. To find out that, we can check out the Maven central repository
    ([http://search.maven.org/](http://search.maven.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Gradle, the `junit-jupiter-params dependency` can be declared as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Then, we need to use the annotation `@ParameterizedTest` (located in the package
    `org.junit.jupiter.params`) to declare a method within a Java class as a parameterized
    test. This type of test behaves exactly the same as a regular `@Test`, meaning
    that all the life cycle callbacks (`@BeforeEach`, `@AfterEach`, and so on) and
    extensions continue working in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, the use of `@ParameterizedTest` is not enough to implement a
    parameterized test. Together with `@ParameterizedTest`, we need to specify at
    least one argument provider. As we will discover in this section, JUnit 5 implements
    different annotations to provide data input (that is, parameters for tests) from
    different sources. These argument providers (implemented as annotations in JUnit
    5) are summarized in the following table (each of these annotations are located
    in the package `org.junit.jupiter.params.provider`):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Arguments provider annotation** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `@ValueSource` | Used to specify an array of literal values of `String`,
    `int`, `long`, or `double` |'
  prefs: []
  type: TYPE_TB
- en: '| `@EnumSource` | Argument source for constants of a specified enumeration
    (`java.lang.Enum`) |'
  prefs: []
  type: TYPE_TB
- en: '| `@MethodSource` | Provides access to values returned by static methods of
    the class in which this annotation is declared |'
  prefs: []
  type: TYPE_TB
- en: '| `@CsvSource` | Argument source which reads comma-separated values (CSV) from
    its attribute |'
  prefs: []
  type: TYPE_TB
- en: '| `@CsvFileSource` | Argument source which is used to load CSV files from one
    or more classpath resources |'
  prefs: []
  type: TYPE_TB
- en: '| `@ArgumentsSource` | Used to specify a custom argument provider (that is,
    a Java class that implements the interface) `org.junit.jupiter.params.provider.ArgumentsProvider`)
    |'
  prefs: []
  type: TYPE_TB
- en: '@ValueSource'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The annotation `@ValueSource` is used in conjunction with `@ParameterizedTest`
    to specify a parameterized test in which the argument source is an array of literal
    values of `String`, `int`, `long`, or `double`. These values are specified inside
    the annotation, using the elements `strings`, `ints`, `longs`, or `doubles`. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The method of this class (`testWithStrings`) defines a parameterized test in
    which an array of String is specified. Due to the fact that two String arguments
    are specified in the annotation `@ValueSource` (in this example `"Hello"` and
    `"World"`), the test logic will be exercised twice, once per value. This data
    is injected in the test method using the argument of the method, in this case
    through the `String` variable named argument. All in all, when executing this
    test class, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00078.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of a parameterized test using *@ValueSource* and String argument provider
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use integer primitive types (`int`, `long`, and `double`) within
    the `@ValueSource` annotation. The following example demonstrates how. The methods
    of this example class (named `testWithInts`, `testWithLongs`, and `testWithDoubles`)
    use the annotation `@ValueSource` to define the arguments in the form of integer
    values, using the primitive types int, long, and double, respectively. To that
    aim, the elements `ints`, `longs`, and `doubles` of `@ValueSource` need to be
    specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen in the picture here, each test is executed twice, since in each
    `@ValueSource` annotation we specify two different input parameters (type `int`,
    `long`, and `double`, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00079.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of a parameterized test using *@ValueSource* and primitive types
  prefs: []
  type: TYPE_NORMAL
- en: '@EnumSource'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The annotation `@EnumSource` allows to specify a parameterized test in which
    the argument source is a Java enumeration class. By default, each value of the
    enumeration will be used to feed the parameterized test, one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following test class, the method `testWithEnum` is annotated
    with `@ParameterizedTest` in conjunction with `@EnumSource`. As we can see, the
    value of this annotation is `TimeUnit.class`, which is a standard Java annotation
    (package java.util.concurrent) used to represent time duration. The possible values
    defined in this enumeration are `NANOSECONDS`, `MICROSECONDS`, `MILLISECONDS`,
    `SECONDS`, `MINUTES`, `HOURS`, and `DAYS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, the execution of this test will be carried out seven times, that
    is, one per `TimeUnit` enumeration value. We can check this in the trace of the
    output console when executing the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00080.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of parameterized test using *@EnumSource* and *TimeUnit.class*
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, the `@EnumSource` annotation allows to filter the members of the
    enumeration in several ways. To implement this selection, the following elements
    can be specified within a `@EnumSource` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mode`: Constant value which determines the type of filtering. This is defined
    as an enumeration in the inner class `org.junit.jupiter.params.provider.EnumSource.Mode`,
    and the possible values are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INCLUDE`: Used to select those values whose names are supplied via the `names`
    element. This is the default option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXCLUDE`: Used to select all values except those supplied with the `names`
    element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MATCH_ALL`: Used to select those values whose names match the patterns in
    `names` element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MATCH_ANY`: Used to select those values whose names match any pattern in the
    `names` element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`names`: The array of string which allows to select a group of `enum` constants.
    The criteria for inclusion/exclusion is directly linked to the value of mode.
    In addition, this element also allows to define regular expressions to select
    the names of `enum` constants to be matched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following example. In this class, there are three parameterized
    tests. First one, named `testWithFilteredEnum`, uses the class `TimeUnit` to feed
    the `@EnumSource` argument provider. Moreover, the enum constant set is filtered
    using the element names. As we can see, only the constant `"DAYS"` and `"HOURS"`
    will be used to feed this test (take into account that the default mode is `INCLUDE`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, when executing this class in the console, the output we obtain is the
    following. Regarding the first test, we can see that only traces for `"DAYS"`
    and `"HOURS"` are present:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00081.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of parameterized test using *@EnumSource* using filtering capabilities
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider now the second test method, named `testWithExcludeEnum.` This test
    is exactly the same as before with a difference: the mode here is `EXCLUSION`
    (instead of `INCLUSION`, chosen by default in the previous test). All in all,
    in the execution (see screenshot before) when can see that this test is executed
    five times, per one of the enum constant different to `DAYS` and `HOURS`. To check
    that, track the traces with the sentence `"Parameterized test with excluded (TimeUnit)
    argument"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third and last method of this class (called `testWithRegexEnum`) defines
    an inclusion mode, `MATCH_ALL`, using a regular expression to filter the enumeration
    (in this case, it is also `TimeUnit`). The concrete regular expression used in
    this example is `^(M|N).+SECONDS$`, which means that only will be included in
    those enum constants starting with `M` or `N` and ending with `SECONDS`. As can
    be checked in the execution screenshot, there are three `TimeUnit` constants matching
    these conditions: `NANOSECONDS`, `MICROSECONDS`, and `MILISECONDS`.'
  prefs: []
  type: TYPE_NORMAL
- en: '@MethodSource'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The annotation `@MethodSource` allows to define the name of the static method
    in which the arguments for the test are provided as a Java 8 `Stream.` For instance,
    in the following example, we can see a parameterized test in which the argument
    provider is a static method called `stringProvider`. In this example, this method
    returns a `Stream` of `String`''s and therefore the argument of the test method
    (callled `testWithStringProvider`) accepts one `String` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When running the example, we can see how the test is execute twice, once per
    `String` contained in the `Stream`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00082.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of a parameterized test using *@MethodSource* and String argument
    provider
  prefs: []
  type: TYPE_NORMAL
- en: The type of the objects contained in the `Stream` is not required to be `String`.
    In fact, this type can be anything. Let's consider another example, in which `@MethodSource`
    is linked to a static method, which returns as `Stream` of custom objects. In
    this example, this type is named `Person`, and here it is implemented as an inner
    class with two properties (`name` and `surname`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As the following screenshot shows, when executing this example, the parameterized
    test is exercise twice, once per `Person` objects contained in the `Stream` (`"John
    Doe"` and `"Jane Roe"`).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00083.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of parameterized test using *@MethodSource* and custom object argument
    provider
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use `@MethodSource` to specify argument providers which contain
    integer primitive types, concretely of `int`, `double`, and `long`. The following
    class contains an example. We can see three parameterized tests. The first one
    (named `testWithIntProvider`) uses the annotation `@MethodSource` to link with
    the static method `intProvider`. In the body of this method, we use the standard
    Java class `IntStream` to return an Stream of `int` values. The second and third
    test (called `testWithDoubleProvider` and `testWithLongProvider`) are quite similar,
    but using a `Stream` of `double` and `long` values, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Thus, when executing this class, there will be six tests executed (three parameterized
    tests with two arguments each).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can check this by following the traces written
    by each test to the standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00084.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of parameterized test using *@MethodSource* and primitive types argument
    provider
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, with regards to `@MethodSource` parameterized tests, it is worth it
    to know that the method providers are allowed to return a Stream of different
    types (objects or primitive types). This is very convenient for real-world test
    cases. For example, the following class implements a parameterized test in which
    the argument provider is a method returning arguments of mixed types: `String`
    and `int`. These parameters are injected in the test as method arguments (called
    first and second in the example).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, there will be test executions as entries contained in the Stream.
    In this case, there are two: `"Mastertering"` and `10`, and then `"JUnit 5"` and
    `20`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00085.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of parameterized test using *@MethodSource* with different types of
    arguments
  prefs: []
  type: TYPE_NORMAL
- en: '@CsvSource and @CsvFileSource'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to specify the source of arguments for parameterized tests is using
    comma-separated values (CSV). This can be done using the annotation `@CsvSource`,
    which allows to embed CSV content as String in the value of the annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following example. It contains a Jupiter parameterized test (named
    `testWithCsvSource`), which is using the annotation `@CsvSource`. This annotation
    contains an array of Strings. In each element of the array, we can see there is
    a different value separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: The content of the CSV is automatically converted to String and int. To find
    out more about the implicit type conversion made in parameters by JUnit 5, take
    a look to the section *Argument conversion* in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: All in all, when executing this test class, there will be three single tests,
    each per entry in the array. Each execution will be invoked, passing two arguments
    to the test. The first one is named `first` and its type is `String`, and second
    one is called `second` and its type is `int`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00086.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of parameterized test using *@CsvSource*
  prefs: []
  type: TYPE_NORMAL
- en: 'If the amount of CSV data is big, it might be more convenient using the annotation
    `@CsvFileSource` instead. This annotation allows to feed the parameterized test
    with a CSV file located in the classpath of the project. In the following example,
    we use the file `input.csv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Internally, the annotation `@CsvFileSource` locates the file using the method
    `getResourceAsStream()` of the standard Java class `java.lang.Class`. Therefore,
    the path of the file is interpreted as a path local to the package class we are
    calling it from. Since our resource is located in the root of the classpath (in
    the example it is located in the folder `src/test/resources`), we need to locate
    it as `/input.csv`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Location and content of input.csv in the example with *@CsvFileSource*
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the test when it is executed with
    Maven. Since the CSV has three rows of data, there are three test executions,
    each one with two parameters (first one as `String` and second one as `int`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00088.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of parameterized test using *@CsvFileSource*
  prefs: []
  type: TYPE_NORMAL
- en: '@ArgumentsSource'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last annotation aimed to specify the source of arguments for parameterized
    tests in JUnit 5 is `@ArgumentsSource`. With this annotation, we can specify a
    custom (and reusable in different tests) class, which will contain the parameters
    for the test. This class must implement the interface `org.junit.jupiter.params.provider.ArgumentsProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example. The following class implements a Jupiter parameterized
    test, in which the arguments source will be defined in the class `CustomArgumentsProvider1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This class (named `CustomArgumentsProvider1`) has been implemented on our side,
    and due to the fact that it implements the interface `ArgumentsProvider`, must
    override the method `provideArguments`, in which the actual definition of parameters
    for the test is implemented. Looking at the code of the example, we can see that
    this method returns a `Stream` of `Arguments`. In this example, we are returning
    a couple of entries in the `Stream`, each one with two arguments (`String` and
    `int`, respectively):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Notice also that this argument has an argument of type `ExtensionContext` (package
    `org.junit.jupiter.api.extension`). This argument is very useful to know the context
    in which the test is executed. As illustrated in the screenshot here, `ExtensionContext`
    API offers different methods to find out different attributes of the test instance
    (test method name, display name, tags, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example (`CustomArgumentsProvider1`), the context is used to write the
    test method name in the standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00089.jpeg)*ExtensionContext* API'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, when executing this example, we can see two tests being executed. Moreover,
    we can check the log trace with the test method, thanks to the `ExtensionContext`
    object inside, out `ArgumentsProvider` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00090.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of parameterized test using *@ArgumentsSource*
  prefs: []
  type: TYPE_NORMAL
- en: 'Several argument sources can be applied to the same parameterized test. In
    fact, this can be done in two different ways in the Jupiter programming model:'
  prefs: []
  type: TYPE_NORMAL
- en: Using several annotation of `@ArgumentsSource` together with the same `@ParameterizedTest`.
    This can be done since `@ArgumentsSource` is a `java.lang.annotation.Repeatable`
    annotation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the annotation `@ArgumentsSources` (notice the source is plural here).
    This annotation is simply a container for one or more `@ArgumentsSource`. The
    following class shows a simple example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Supposing that the second argument provider (`CustomArgumentsProvider2.**class**`)
    specifies two or more sets of argument, when executing the test class there will
    be four test executions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00091.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of parameterized test using *@ArgumentsSources*
  prefs: []
  type: TYPE_NORMAL
- en: Argument conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To support use cases such as `@CsvSource` and `@CsvFileSource`, Jupiter provides
    a number of built-in implicit converters. Moreover, these converters can be implemented
    based on specific needs by means of explicit converters. This section covers both
    types of conversions.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Internally, JUnit 5 handles a set of rules for the conversion of parameters
    from `String` to the actual argument type. For example, if `@ParameterizedTests`
    declares a parameter of type `TimeUnit`, but the declared source is a `String`,
    internally this `String` will be converted to `TimeUnit`. The following table
    summarizes the rules of implicit conversions in JUnit 5 for parameterized test
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Target Type** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean/Boolean` | `"false"` -> `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `byte/Byte` | `"1"` -> `(byte) 1` |'
  prefs: []
  type: TYPE_TB
- en: '| `char/Character` | `"a"` -> `''a''` |'
  prefs: []
  type: TYPE_TB
- en: '| `short/Short` | `"2"` -> `(short) 2` |'
  prefs: []
  type: TYPE_TB
- en: '| `int/Integer` | `"3"` -> `3` |'
  prefs: []
  type: TYPE_TB
- en: '| `long/Long` | `"4"` -> `4L` |'
  prefs: []
  type: TYPE_TB
- en: '| `float/Float` | `"5.0"` -> `5.0f` |'
  prefs: []
  type: TYPE_TB
- en: '| `double/Double` | `"6.0"` -> `6.0d` |'
  prefs: []
  type: TYPE_TB
- en: '| `Enum subclass` | `"SECONDS"` -> `TimeUnit.SECONDS` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.time.Instant` | `"1970-01-01T00:00:00Z"` -> `Instant.ofEpochMilli(0)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `java.time.LocalDate` | `"2017-10-24"` -> `LocalDate.of(2017, 10, 24)` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.time.LocalDateTime` | `"2017-03-14T12:34:56.789"` -> `LocalDateTime.of(2017,
    3, 14, 12, 34, 56, 789_000_000)` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.time.LocalTime` | `"12:34:56.789"` -> `LocalTime.of(12, 34, 56, 789_000_000)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `java.time.OffsetDateTime` | `"2017-03-14T12:34:56.789Z"` -> `OffsetDateTime.of(2017,
    3, 14, 12, 34, 56, 789_000_000, ZoneOffset.UTC)` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.time.OffsetTime` | `"12:34:56.789Z"` -> `OffsetTime.of(12, 34, 56,
    789_000_000, ZoneOffset.UTC)` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.time.Year` | `"2017"` -> `Year.of(2017)` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.time.YearMonth` | `"2017-10"` -> `YearMonth.of(2017, 10)` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.time.ZonedDateTime` | `"2017-10-24T12:34:56.789Z"` -> `ZonedDateTime.of(2017,
    10, 24, 12, 34, 56, 789_000_000, ZoneOffset.UTC)` |'
  prefs: []
  type: TYPE_TB
- en: 'The following example shows several examples of implicit conversion. The first
    test (`testWithImplicitConversionToBoolean`) declares a `String` source as `"true"`,
    but then, the expected argument type is `Boolean`. Similarly, the second test
    (`"testWithImplicitConversionToInteger"`) makes an implicit conversion from `String`
    to `Integer`. The third test (`testWithImplicitConversionToEnum`) converts the
    input `String` to `TimeUnit` (enumeration), and finally the fourth test (`testWithImplicitConversionToLocalDate`)
    produces a conversion to `LocalDate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check the actual type of the argument in the console. Each test writes
    a line in the standard output with the value and the type of each argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00092.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of parameterized tests using implicit argument conversion
  prefs: []
  type: TYPE_NORMAL
- en: Explicit conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the implicit conversion provided by JUnit 5 is not enough to cover our needs,
    we can use the explicit conversion capability. Thanks to this feature, we can
    specify a class which is going to make the custom conversion of parameter types.
    This custom converter is identified with the annotation `@ConvertWith`, referring
    to the argument to be converted with. Consider the following example. This parameterized
    test declares a custom converter for its test method argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Our custom converted is a class that extends the JUnit 5's `SimpleArgumentConverter`.
    This class overrides the method convert, in which the actual conversion takes
    place. In the example, we simply transform whatever argument source to `String`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'All in all, when the test is executed, the seven enumeration constants defined
    in `TimeUnit` will be passed as arguments to the test, prior conversion to `String`
    in `CustomArgumentsConverter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00093.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of parameterized tests using explicit argument conversion
  prefs: []
  type: TYPE_NORMAL
- en: Custom names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last feature related with parameterized tests in JUnit 5 has to do with
    the display name of each execution of tests. As we learned, a parameterized test
    is usually executed as several single tests. Therefore, for the shake of traceability,
    it is good practice to link each test execution with the argument source.
  prefs: []
  type: TYPE_NORMAL
- en: 'To that aim, the annotation `@ParameterizedTest` accepts an element called
    name in which we can specify a custom name (`String`) for the test execution.
    Moreover, in this String, we can use several built-in placeholders, as described
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Placeholder** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `{index}` | Current invocation index (first one is 1, second is 2, …) |'
  prefs: []
  type: TYPE_TB
- en: '| `{arguments}` | Comma-separated arguments complete list |'
  prefs: []
  type: TYPE_TB
- en: '| `{0}, {1}, …` | Value for an individual argument (first one is 0, second
    is 2, …) |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see a simple example. The following class contains a parameterized test
    whose arguments are defined using a `@CsvSource` annotation. The test method accepts
    two arguments (`String` and `int`). In addition, we are specifying the element
    name of the annotation `@ParameterizedTest` with a custom message, using the placeholders
    for the current test invocation (`{index}`) and also for the values of each argument:
    the first one (`{0}`) and the second one (`{1}`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When executing this test in an IDE (IntelliJ in the following screenshot),
    we can see how the display name is different for each test execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Execution of parameterized tests using custom names in IntelliJ IDE
  prefs: []
  type: TYPE_NORMAL
- en: Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 9 was released for **General Availability** (**GA**) on September 21, 2017\.
    There are many new features shipped with Java 9\. Among them, modularity is the
    defining feature for Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, there has been a problem of modularity in Java, especially significant
    for large codebases. Every public class can be accessed by any other class in
    the classpath, leading to inadvertent usage of classes. In addition, the classpath
    presents potential problems, such as the inability to know whether or not there
    are duplicated JARs. To solve these problems, Java 9 provides the Java Platform
    Module System, which allows to create modular JAR files. This type of modules
    contains an additional module descriptor called `module-info.java`. The content
    of such files is quite simple: it declares dependencies to other modules using
    the keyword requires, and exports its own packages with the keyword `exports`.
    All non-exported packages are encapsulated in the module by default, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can represent the relationship between these modules as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Example of relationship between modules in Java 9
  prefs: []
  type: TYPE_NORMAL
- en: 'Other new capabilities of Java 9 are summarized in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: The use modules allow to create a minimal runtime JDK optimized for the given
    application, instead of using a fully JDK installation. This can be achieve using
    the tool the *jlink* shipped with JDK 9.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java 9 provides an interactive environment to execute Java code, directly from
    the shell. This type of utility is commonly known as **Read-Eval-Print-Loop**
    (**REPL**), which is called **JShell** in JDK 9.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Collection factory methods, Java 9 provides the capability of creating collections
    (for example, lists or sets) and populates them in a single line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '**Stream API improvements**: Streams was introduced in Java 8, and they allow
    to create declarative pipelines of transformations on collections. In Java 9,
    the methods `dropWhile`, `takeWhile`, and `ofNullable` are added to the Stream
    API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private interface methods**: Java 8 provides default methods on interfaces.
    The limitation so far is that default methods in Java 8 must be public. Now, in
    Java 9, these default methods can be also private, helping to structure better
    their implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP/2**: Java 9 supports out of the box, version 2 of HTTP and also WebSockets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi release JARs**: This feature allows to create alternative versions
    of classes, depending on the version of the JRE executing the JAR. To that aim,
    under the folder `META-INF/versions/<java-version>`, we can specify different
    versions of compiled classes, which will used only when the JRE version matches
    the version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved Javadoc**: Last but not least, Java 9 allows to create HTML5 compliant
    Javadoc with an integrated search capability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JUnit 5 and Java 9 compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since M5, all JUnit 5 artifacts are shipped with compiled module descriptors
    for Java 9, declared in its JAR manifest (file `MANIFEST.MF`). For example, the
    content of the manifest for the artifact `junit-jupiter-api` M6 is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With regards to Java 9, the interesting thing is the declaration `Automatic-Module-Name`.
    This allows to test modules to require the JUnit 5 module simply by adding the
    following lines to its module descriptor file (`module-info.java`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Beyond JUnit 5.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JUnit 5.0 GA (General Availability) was released on September 10, 2017\. Furthermore,
    JUnit is a living project, and new features are planned for the next release,
    that is, 5.1 (with no release agenda scheduled at the time of writing). The backlog
    for the next release of JUnit 5 can be seen on GitHub: [https://github.com/junit-team/junit5/milestone/3](https://github.com/junit-team/junit5/milestone/3).
    Among other, the following features are planned for JUnit 5.1:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario tests: This feature has to do with the capability of ordering different
    test methods within a class. To do that, the following annotations are planned:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ScenarioTest`: A class-level annotation used to denote that a test class
    contains steps that make up a single scenario test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Step`: A method-level annotation used to denote that a test method is a single
    step within the scenario test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Support for parallel tests execution: Concurrency is one of the main aspects
    to be improved in JUnit 5.1, and therefore the support of out of the box concurrent
    test execution is planned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mechanism for terminating dynamic tests early: This is an enhancement of the
    JUnit 5.0 support for dynamic tests, introducing a timeout to stop the execution
    before it terminates itself (to avoid uncontrolled non-deterministic executions).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several improvements in test reporting, such as capturing `stdout`/`stderr`
    and include in test reports, provide reliable way to get the class (classname)
    of executed test methods, or specify the order of tests in test reports, among
    others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter contains a comprehensive summary of the advance capabilities to
    write rich Jupiter tests driven by examples. First, we have learned that parameters
    can be injected in constructor and methods in test classes. JUnit 5 provides three
    parameter resolvers out of the box, namely resolver for parameters of the type
    `TestInfo` (to retrieve information about the current test), resolver for parameters
    of the type `RepetitionInfo` (to retrieve information about the current repetition),
    and resolver for parameters of the type `TestReporter` (to publish additional
    data about the current test run).
  prefs: []
  type: TYPE_NORMAL
- en: Another new feature implemented in Jupiter is the concept of dynamic tests.
    So far in JUnit 3 and 4, tests are defined at compile time (that is static tests).
    Jupiter introduces the annotation `@TestFactory` that allows to generate test
    at runtime. Another new concept provided by the Jupiter programming model are
    the test templates. These templates re defined using the annotation `@TestTemplate` and
    are not regular test cases but rather a template for test cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'JUnit 5 implements an enhancement support for parameterized tests. In order
    to implement this type of tests, the annotation `@ParameterizedTest` must be used.
    Together with this annotation, an argument provider should be also specified.
    To that aim, several annotations are provided in Jupiter: `@ValueSource`, `@EnumSource`,
    `@MethodSource`, `@CsvSource`, `@CsvFileSource`, and `@ArgumentSource`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the [chapter 5](part0122.html#3KB4K0-ef8404ed083f459d860f84cc8198f8bb), *Integration
    Of JUnit 5 With External Frameworks*, we are going to learn how JUnit 5 interacts
    with external frameworks. Concretely, we are going to review several JUnit 5 extension,
    which provides capabilities to use Mockito, Spring, Selenium, Cucumber, or Docker.
    Moreover, we present a Gradle plugin, which allows to execute tests within an
    Android project. Finally, we find out how to use several REST libraries (for example,
    REST Assured or WireMock) to test RESTful services.
  prefs: []
  type: TYPE_NORMAL
