- en: Chapter 12. Production Readiness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though our application lacks a significant amount of feature functionality,
    our (albeit imaginary) deadlines are approaching and our (also imaginary) client
    is getting anxious about getting the application into a production environment.
    Even though it may be some time before our application actually sees the light
    of day in production, it is time to get the application "production ready". In
    this, our final chapter of development, we are going to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: Feature planning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to achieve the goal of preparing our application for a production
    environment, we are going to focus on the following granular tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement Yii's application logging framework to ensure we are logging information
    about critical production errors and events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement Yii's application error handling framework to ensure we properly handle
    errors in production and understand how this works differently in a production
    environment rather than in a development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement application data caching to help improve performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging is a topic that should arguably have been covered before this late stage
    in the application development. Informational, warning, and severe error messages
    are invaluable when it comes to troubleshooting in software applications, and
    most certainly for those in a production environment being used by real users.
  prefs: []
  type: TYPE_NORMAL
- en: As developers, we are all familiar with this story. You have met all of the
    functional requirements of the application you are building. All of the unit and
    functional tests are passing. The application has been approved by QA, and everyone
    feels great about it being ready for production. But as soon as it goes in and
    is under real production load, with real users interacting with it, it behaves
    unexpectedly. A good logging strategy could make the difference between a swift
    resolution and rolling back weeks or even months of hard work.
  prefs: []
  type: TYPE_NORMAL
- en: Yii provides flexible and extensible logging capabilities. The data logged can
    be classified according to log levels and message categories. Using level and
    category filters, log messages can be further routed to different destinations,
    such as written to files on disc, stored in a database, sent to administrators
    as emails, or displayed in browser windows.
  prefs: []
  type: TYPE_NORMAL
- en: Message logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our application has actually been logging many informational messages upon each
    request the entire time. When the initial application was created it was configured
    to be in *debug* mode and while in this mode, the Yii framework itself logs information
    messages. We can't actually see these messages because, by default, they are being
    logged to memory. So, they are around only for the lifetime of the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether or not the application is in this debug mode is controlled by the following
    line in the root `index.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To see what is being logged, let''s whip up a quick little action method in
    our `SiteController` class to display the messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here we are using Yii's `CVarDumper` helper class, which is an improved version
    of `var_dump` or `print_r`, due to its ability to properly handle recursive reference
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we invoke this action by making the request `http://localhost/trackstar/site/showLog`,
    we see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Message logging](graphics/8727_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we comment out our global application debug variable, defined in `index.php`,
    and refresh the page, we'll notice an empty array; that is, nothing was logged.
    This is because this system-level debugging information level logging is accomplished
    by calling `Yii::trace`, which only logs these messages if the application is
    in this special debug mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can log messages in a Yii application using one of two static application
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Yii::log($message, $level, $category);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Yii::trace($message, $category);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned, the main difference between these two methods is that `Yii::trace`
    logs the message only when the application is in debug mode.
  prefs: []
  type: TYPE_NORMAL
- en: Categories and levels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When logging a message using `Yii::log()`, we need to specify its category and
    level. **Category** is a string and is used to provide extra context to the message
    being logged. This string can be anything you like, but a convention that many
    use is a string in the format of `xxx.yyy.zzz`, which resembles the path alias.
    For example, if a message is logged in our application's `SiteController` class,
    we may choose to use the category `application.controllers.SiteController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to specifying the category, when using `Yii::log`, we can also
    specify a level for the message. The level can be thought of as the severity of
    the message. You can define your own levels, but typically they take on one of
    the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trace**: This level is commonly used for tracing the execution flow of the
    application during development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Info**: This is for logging general information. This is the default level
    if none is specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Profile**: This is to be used with the performance profile feature, which
    is described later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warning**: This is for warning messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error**: This is for fatal error messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a login message log
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an example, let's add some logging to our user login method. We'll provide
    some basic debugging information at the beginning of the method to indicate that
    the method is being executed. We'll then log an informational message upon a successful
    login, as well as a warning message if the login fails. Alter our `SiteController::actionLogin()`
    method as the following highlighted code suggests (the entire method is present
    in the downloadable code or you can download the standalone method from [https://gist.github.com/3791860](https://gist.github.com/3791860)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If we now successfully log in (or perform a failed attempt) and visit our page
    to view the logs, we don't see them (if you commented out the debug mode declaration,
    make sure you have put the application back in debug mode for this exercise).
    Again, the reason is that, by default, the logging implementation in Yii simply
    stores the messages in memory. They disappear when the request completes. This
    is not terribly useful. We need to route them to a more persistent storage area
    so we can view them outside of the request in which they are generated.
  prefs: []
  type: TYPE_NORMAL
- en: Message routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned earlier, by default, messages logged using `Yii::log` or `Yii::trace`
    are kept in memory. Typically, these messages are more useful if they are displayed
    in browser windows, saved to some persistent storage (such as in a file), in a
    database, or sent as an email. Yii's *message routing* allows for the log messages
    to be routed to different destinations.
  prefs: []
  type: TYPE_NORMAL
- en: In Yii, message routing is managed by a `CLogRouter` application component.
    It allows you to define a list of destinations to which the log messages should
    be routed.
  prefs: []
  type: TYPE_NORMAL
- en: In order to take advantage of this message routing, we need to configure the
    `CLogRouter` application component in our `protected/config/main.php` configuration
    file. We do this by setting its routes property with the desired log message destinations.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open up the main configuration file, we see that some configuration has
    already been provided (again, courtesy of using the `yiic webapp` command to initially
    create our application). The following is already defined in our configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `log` application component is configured to use the framework class `CLogRouter`.
    Certainly, you could also create and use a custom child class of this if you have
    logging requirements not fully met by the base framework implementation; but in
    our case, this will work just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'What follows the class definition in the previous configuration is the definition
    of the `routes` property. In this case, there is just one route specified. This
    one is using the Yii framework message routing class, `CFileLogRoute`. The `CFileLogRoute`
    message routing class uses the filesystem to save the messages. By default, messages
    are logged in a file under the application runtime directory, `/protected/runtime/application.log`.
    In fact, if you have been following along with us and have your own application,
    you can take a peek at this file and will see several messages that have been
    logged by the framework. The `levels` specification dictates that only messages
    whose log level is either `error` or `warning` will be routed to this file. The
    part of the configuration in the previous code that is commented out specifies
    another route, `CWebLogRoute`. If used, this will route the message to be displayed
    on the currently requested web page. The following is a list of message routes
    currently available in Version 1.1 of Yii:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CDbLogRoute`: Saves messages in a database table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CEmailLogRoute`: Sends messages to specified e-mail addresses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CFileLogRoute`: Saves messages in a file under the application''s `runtime`
    directory or any other directory of your choice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CWebLogRoute`: Displays messages at the end of the current web page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CProfileLogRoute`: Displays profiling messages at the end of the current web
    page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The logging that we added to our `SiteController::actionLogin()` method used
    `Yii::trace` for one message and then used `Yii::log` for two more. When using
    `Yii::trace` the log level is automatically set to `trace`. When using the `Yii::log`
    we specified an `info` log level if the login was successful, but a `warning`
    level if the login attempt failed. Let''s alter our log routing configuration
    to write the `trace` and `info` level messages to a new, separate file called
    `infoMessages.log` in the same directory as our `application.log` file. Also,
    let''s configure it to write the warning messages to the browser. To do that,
    we will make the following changes (highlighted) to the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, after saving these changes, let''s try out the different scenarios. First,
    try a successful login. Doing so will write our two login messages out to our
    new `/protected/runtime/infoMessages.log` file, one for the trace and the other
    one logging the successful login. After successfully logging in, viewing that
    file reveals the following (the full listing was truncated to save a few trees):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is a lot more in there than just our two messages! But
    our two did show up; they are in bold in the previous listing. Now that we are
    routing all trace messages to this new file, all framework trace messages are
    showing up here as well. This is actually very informative and really helps you
    get a picture of the lifecycle of a request as it makes its way through the framework.
    There is a lot going on under the covers. We would obviously turn off this verbose
    level of logging when moving this application to production. In non-debug mode,
    we would only see our single `info` level message. But this level of detail can
    be very informative when trying to track down bugs and just figuring out what
    the application is doing. It is very comforting to know it is here when/if ever
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s try the failed login attempt scenario. If we now log back out and
    try our login again, but this time specify incorrect credentials to force a failed
    login, we see our **warning** level display along the bottom of the returned web
    page just as we configured it to do. The following screenshot shows this warning
    being displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Message routing](graphics/8727_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When using the `CFileLogRouter` message router, the log files are stored under
    the `logPath` property and the filename is specified by the `logFile` method.
    Another great feature of this log router is automatic logfile rotation. If the
    size of the logfile is greater than the value set in the `maxFileSize` property
    (in kilobytes) a rotation is performed, which renames the current log file by
    suffixing the filename with `.1`. All existing logfiles are moved backwards one
    place, that is, `.2` to `.3`, `.1` to `.2`. The property `maxLogFiles` can be
    used to specify how many files are to be kept.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you use `die;` or `exit;` in your application to terminate the execution,
    log messages may not be properly written to their intended destinations. If you
    need to explicitly terminate the execution of your Yii applications, use `Yii::app()->end().`
    This provides the application an opportunity to write out log messages successfully.
    Also, the `CLogger` component has an `$autoDump` property that, if set to `true`,
    will allow the writing of log messages to their destinations in real time (that
    is, as `->log()` is called). This should only be used for debugging purposes due
    to its potential performance impact, but can be a very valuable debugging option.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Properly handling the errors that invariably occur in software applications
    is of utmost importance. This, again, is a topic that arguably should have been
    covered prior to coding our application, rather than at this late stage. Luckily,
    though, since we have been leaning on tools within the Yii framework to autogenerate
    much of our core application skeleton, our application is already taking advantage
    of some of Yii's error handling features.
  prefs: []
  type: TYPE_NORMAL
- en: Yii provides a complete error handling framework based on PHP 5 exceptions,
    a built-in mechanism for handling exceptional circumstances in the program through
    centralized points. When the main Yii application component is created to handle
    an incoming user request, it registers its `CApplication::handleError()` method
    to handle PHP warnings and notices, and it registers its `CApplication::handleException()`
    method to handle uncaught PHP exceptions. Consequently, if a PHP warning/notice
    or an uncaught exception occurs during the application execution, one of the error
    handlers will take over the control and start the necessary error handling procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The registration of error handlers is done in the application's constructor
    by calling the PHP functions `set_exception_handler` and `set_error_handler`.
    If you prefer not to have Yii handle these types of errors and exceptions, you
    may override this default behavior by defining the global constants `YII_ENABLE_ERROR_HANDLER`
    and `YII_ENABLE_EXCEPTION_HANDLER` to be false in the main `index.php` entry script.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the application will use the framework class `CErrorHandler` as
    the application component tasked with handling PHP errors and uncaught exceptions.
    Part of the task of this built-in application component is displaying these errors
    using appropriate view files based on whether or not the application is running
    in *debug* mode or in *production* mode. This allows you to customize your error
    messages for these different environments. It makes sense to display much more
    verbose error information in a development environment to help troubleshoot problems.
    But allowing users of a production application to view this same information could
    compromise security. Also, if you have implemented your site in multiple languages,
    `CErrorHandler` also selects the preferred language for displaying the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'You raise exceptions in Yii in the same way you would normally raise a PHP
    exception. One uses the following general syntax to raise an exception when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The two exception classes Yii provides are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CHttpException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CException` is a generic exception class. `CHttpException` represents an HTTP
    error and also carries a `statusCode` property to represent the HTTP status code.
    Errors are displayed differently in the browser, depending on the exception class
    that is thrown.'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As was previously mentioned, when the `CErrorHandler` application component
    is handling an error, it makes a decision as to which view file to use when displaying
    the error. If the error is meant to be displayed to end users, as is the case
    when using `CHttpException`, the default behavior is to use a view named `errorXXX`,
    where `XXX` represents the HTTP status code (for example, 400, 404, or 500). If
    the error is an internal one and should only be displayed to developers, it will
    use a view named `Exception`. When the application is in debug mode, a complete
    call stack as well as the error line in the source file will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: However, when the application is running in production mode, all errors will
    be displayed using the `errorXXX` view files. This is because the call stack of
    an error may contain sensitive information that should not be displayed to just
    any end user.
  prefs: []
  type: TYPE_NORMAL
- en: When the application is in production mode, developers should rely on the error
    logs to provide more information about an error. A message of level error will
    always be logged when an error occurs. If the error is caused by a PHP warning
    or notice, the message will be logged with the category `php`. If the error is
    caused by an uncaught `exception`, the category will be `exception.ExceptionClassName`,
    where the exception class name is one of, or a child class of, either `CHttpException`
    or `CException`. One can thus take advantage of the logging features discussed
    in the previous section to monitor errors that occur within a production application.
    Of course, if fatal PHP errors occur you will still need to check your error log
    defined by your PHP configuration settings instead of Yii's error log.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `CErrorHandler` searches for the location of the corresponding
    view file in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WebRoot/themes/ThemeName/views/system`: The system view directory under the
    currently active theme'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebRoot/protected/views/system`: The default system view directory for an
    application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`YiiRoot/framework/views`: The standard system view directory provided by the
    Yii framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can customize the error display by creating custom error view files under
    the system view directory of the application or theme.
  prefs: []
  type: TYPE_NORMAL
- en: Yii also allows you to define a specific controller action method to handle
    the display of the error. This is actually how our application is configured.
    We'll see this as we go through a couple of examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the code that was generated for us as a by-product of using the Gii
    Crud Generator tool to create our CRUD scaffolding is already taking advantage
    of Yii''s error handling. One such example is the `ProjectController::loadModel()`
    method. That method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that it is attempting to load the appropriate project model AR instance
    based on the input `id` querystring parameter. If it is unable to locate the requested
    project, it throws a `CHttpException` as a way to let the user know that the page
    they are requesting, in this case the project details page, does not exist. We
    can test this in our browser by explicitly requesting a project that we know does
    not exist. Since we know our application does not have a project associated with
    an `id` of `99`, a request for `http://localhost/trackstar/project/view/id/99`
    will result in the following page being returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying errors](graphics/8727_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is nice, because the page looks like any other page in our application,
    with the same theme, header, footer, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is actually not the default behavior for rendering this type of error
    page. Our initial application was configured to use a specific controller action
    for the handling of such errors. We mentioned this was another option as to how
    to handle errors in an application. If we take a peek into our main configuration
    file, `/protected/config/main.php`, we see the following application component
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This configures our error handler application component to use the `SiteController::actionError()`
    method to handle all of the exceptions intended to be displayed to users. If we
    take a look at that action method, we notice that it is rendering the `protected/views/site/error.php`
    view file. This is just a normal controller view file, so it will also render
    any relevant application layout files and will apply the appropriate theme. This
    way, we are able to provide the user with a very friendly experience when certain
    errors happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what the default behavior is, without this added configuration, let''s
    temporarily comment out the previous lines of configuration code (in `protected/config/main.php`)
    and request the nonexistent project again. Now we see the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying errors](graphics/8727_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since we have not explicitly defined any custom error pages following the convention
    outlined earlier, this is the `framework/views/error404.php` file in the Yii framework
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and revert these changes to the configuration file to have the error
    handling use the `SiteController::actionError()` method once again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how this compares to throwing a `CException` class, rather than
    the HTTP exception class. Let''s comment out the current line of code throwing
    the HTTP exception and add a new line to throw this other exception class. Make
    the highlighted changes to the `protected/controllers/ProjectController.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we make our request for a nonexistent project, we see a very different
    result. This time we see a system generated error page with a full stack trace
    error info dump along with the specific source file where the error occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying errors](graphics/8727_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It displays the fact that a `CException` class was thrown along with the description
    **This is an example of throwing a CException**, the source file, specific line
    in the file where the error occurred, and then the full stack trace.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, throwing this different exception class, along with the fact the application
    is in debug mode, has a different result. This is the type of information we would
    like to display to help troubleshoot the problem, but only as long as our application
    is running in a private development environment. Let''s temporarily comment out
    the debug setting in the root `index.php` file in order to see how this would
    display when in "production" mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With this commented out, if we refresh our request for our nonexistent project,
    we see that the exception is displayed as an end user friendly HTTP 500 error,
    as depicted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying errors](graphics/8727_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So we see that none of our sensitive code or stack trace information is displayed
    when in the "production" mode.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Caching** data is a great method for helping to improve the performance of
    a production web application. If there is specific content that is not expected
    to change upon every request, using a cache to store and serve this content can
    decrease the time it takes to retrieve and process that data.'
  prefs: []
  type: TYPE_NORMAL
- en: Yii provides some nice features when it comes to caching. To take advantage
    of Yii's caching features, you begin with configuring a cache application component.
    Such a component is one of several child classes extending `CCache`, the base
    class for cache classes with different cache storage implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yii provides many specific cache component class implementations that store
    the data utilizing different approaches. The following is a list of the current
    cache implementations that Yii provides as of Version 1.1.12:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CMemCache`: Uses the PHP memcache extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CApcCache`: Uses the PHP APC extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CXCache`: Uses PHP XCache extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CEAcceleratorCache`: Uses the PHP EAccelerator extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CDbCache`: Uses a database table to store cached data. By default, it will
    create and use a SQLite3 database under the runtime directory. You can explicitly
    specify a database for it to use by setting its `connectionID` property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CZendDataCache`: Uses Zend Data Cache as the underlying caching medium.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CFileCache`: Uses files to store cached data. This is particularly suitable
    to cache a large chunk of data (such as pages).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CDummyCache`: Presents the consistent cache interface, but does not actually
    perform any caching. The reason for this implementation is that if you are faced
    with a situation where your development environment does not have cache support,
    you can still execute and test your code that will need to use cache once available.
    This allows you to continue to code to a consistent interface, and when the time
    comes to actually implement a real caching component you will not need to change
    the code written to write or retrieve data from cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CWinCache`: `CWinCache` implements a cache application component based on
    WinCache. For more information visit [http://www.iis.net/expand/wincacheforphp](http://www.iis.net/expand/wincacheforphp).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these components extend from the same base class, `CCache`, and expose
    a consistent API. This means that you can change the implementation of the application
    component in order to use a different caching strategy without having to change
    any of the code that is using the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Cache configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As was mentioned, using cache in Yii typically involves choosing one of these
    implementations and then configuring the application component for use in the
    `/protected/config/main.php` file. The specifics of the configuration will, of
    course, depend on the specific cache implementation. For example, if one were
    to use the memcached implementation, that is `CMemCache`, which is a distributed
    memory object caching system that allows you to specify multiple host servers
    as your cache servers, configuring it to use two servers might look something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To keep things relatively simple for the reader following along with the TrackStar
    development, we'll use the filesystem implementation `CFileCache` as we go through
    some examples. This should be readily available on any development environment
    that allows read and write access to files from the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If for some reason this is not an option for you but you still want to follow
    along with the code examples, simply use the `CDummyCache` option. As mentioned,
    it won't actually store any data in the cache, but you can still write code against
    its API and change the implementation at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: '`CFileCache` provides a file-based caching mechanism. When using this implementation,
    each data value being cached is stored in a separate file. By default, these files
    are stored under the `protected/runtime/cache/` directory, but one can easily
    change this by setting the `cachePath` property when configuring the component.
    For our purposes this default is fine, so we simply need to add the following
    to the `components` array in our `/protected/config/main.php` configuration file,
    as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we can access this new application component anywhere in
    our running application via `Yii::app()->cache`.
  prefs: []
  type: TYPE_NORMAL
- en: Using a file-based cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's try out this new component. Remember that system message we added as part
    of our administrative functionality in the previous chapter? Rather than retrieving
    it from the database upon every request, let's store the value initially returned
    from the database in our cache for a limited amount of time so that not every
    request has to retrieve the data from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a new public method to our `SysMessage` (`/protected/modules/admin/models/SysMessage.php`)
    AR model class to handle the retrieval of the latest system messages. Let's make
    this new method both `public` and `static` so that other parts of the application
    can easily use this method to access the latest system message without having
    to explicitly create an instance of `SysMessage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add our method to the `SysMessage` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll cover the details in just a minute. First, let''s change our application
    to use this new method to verify whether caching is working. We still need to
    change the `ProjectController::actionIndex()` method to use this newly created
    method. This is easy. Just replace the code that was generating the system message
    from the database, with a call to this new method. That is, in `ProjectController::actionIndex()`,
    simply change the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now the system message being displayed on the projects listing page should be
    taking advantage of the file cache. We can check the cache directory to verify.
  prefs: []
  type: TYPE_NORMAL
- en: If we do a directory listing for the default location being used for file caching,
    `protected/runtime/cache/`, we do indeed see that a couple of files were created.
    Both of them rather strangely named (yours may be slightly different) `18baacd814900e9b36b3b2e546513ce8.bin`
    and `2d0efd21cf59ad6eb310a0d70b25a854.bin`.
  prefs: []
  type: TYPE_NORMAL
- en: One holds our system message data and the other is from our configuration of
    `CUrlManager` from previous chapters. By default, `CUrlManager` will use the cache
    component to cache the parsed URL rules. You can set the `cacheId` parameter of
    `CUrlManager` to `false` to disable caching for this component.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open up the `18baacd814900e9b36b3b2e546513ce8.bin` file as text, we can
    see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is the serialized cached value of our most recently updated `SysMessage`
    AR class instance, which is exactly what we would expect to be there. So, we see
    that the caching is actually working.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s revisit the code for our new `SysMessage::getLatest()` method in
    a bit more detail. The first thing the code is doing is checking to see if the
    requested data is already in the cache, and if so returning that value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned, we configured the cache application component to be available
    anywhere in the application via `Yii::app()->cache`. So, it first checks to see
    if there even is such a component defined. If so, it attempts to look up the data
    in the cache via the `$cache->get($key)` method. This does more or less what you
    would expect. It attempts to retrieve a value from the cache based on the specified
    key. The key is a unique string identifier that is used to map to each piece of
    data stored in the cache. In our system message example, we only need to display
    one message at a time and therefore can have a fairly simple key identify the
    single system message to display. The key can be any string value as long as it
    remains unique for each piece of data we want to cache. In this case we have chosen
    the descriptive string `TrackStar.ProjectListing.SystemMessage` as the key used
    when storing and retrieving our cached system message.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this code is executed for the very first time, there will not yet be any
    data associated with this key value in the cache. Therefore, a call to `$cache->get()`
    for this key will return `false`. So, our method will continue to the next bit
    of code, which simply attempts to retrieve the appropriate system message from
    the database, using the AR class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We then proceed with the following code that first checks if we did get anything
    back from the database. If we did, it stores it in the cache before returning
    the value; otherwise, `null` is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If a valid system message was returned, we use the `$cache->set()` method to
    store the data into the cache. This method has the following general form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When placing a piece of data into the cache, one must specify a unique key as
    well as the data to be stored. The key is a unique string value, as discussed
    previously, and the value is whatever data is desired to be cached. This can be
    in any format as long as it can be serialized. The duration parameter specifies
    an optional **time-to-live** (**TTL**) requirement. This can be used to ensure
    that the cached value is refreshed after some period of time. The default is `0`,
    which means it will never expire. (Actually, internally, Yii translates a value
    of `<=0` for the duration to expire in one year. So, not exactly *never*, but
    definitely a long time.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the `set()` method in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We set the key to be what we had defined it before, `TrackStar.ProjectListing.SystemMessage`;
    the data being stored is the message attribute of our returned `SystemMessage`
    AR class, that is the message column of our `tbl_sys_message` table; and then
    we set the duration to be `300` seconds. This way, the data in the cache will
    expire every 5 minutes, at which time the database is queried again for the most
    recent system message. We did not specify a dependency when we set the data. We'll
    discuss this optional parameter next.
  prefs: []
  type: TYPE_NORMAL
- en: Cache dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dependency parameter allows for an alternative and much more sophisticated
    approach to deciding whether or not the stored data in the cache should be refreshed.
    Rather than declaring a simple time period for the expiration of cached data,
    your caching strategy may require that the data become invalid based on things
    such as the specific user making the request, the general mode, state of the application,
    or whether a file on the file system has been recently updated. This parameter
    allows you to specify such cache validation rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dependency is an instance of `CCacheDependency` or its child class. Yii
    makes available the following specific cache dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CFileCacheDependency`: The data in the cache will be invalid if the specified
    file''s last modification time has changed since the previous cache lookup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CDirectoryCacheDependency`: Similar to the previous one for the file cache
    dependency, but this checks all the files and subdirectories within a given specified
    directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CDbCacheDependency`: The data in the cache will be invalid if the query result
    of a specified SQL statement is changed since the previous cache lookup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CGlobalStateCacheDependency`: The data in the cache will be invalid if the
    value of the specified global state is changed. A global state is a variable that
    is persistent across multiple requests and multiple sessions in an application.
    It is defined via `CApplication::setGlobalState()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CChainedCacheDependency`: This allows you to chain together multiple dependencies.
    The data in the cache will become invalid if any of the dependencies on the chain
    are changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CExpressionDependency`: The data in the cache will be invalid if the result
    of the specified PHP expression is changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To provide a concrete example, let's use a dependency to expire the data in
    the cache whenever a change to the `tbl_sys_message` database table is made. Rather
    than arbitrarily expiring our cached system message after five minutes, we'll
    expire it exactly when we need to, that is, when there has been a change to the
    `update_time` column for one of the system messages in the table. We'll use the
    `CDbCacheDependency` implementation to achieve this, since it is designed to invalidate
    cached data based on a change in the results of a SQL query.
  prefs: []
  type: TYPE_NORMAL
- en: 'We alter our call to the `set()` method to set the duration time to `0` so
    that it won''t expire based on time but pass in a new dependency instance with
    our specified SQL statement, as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Changing the duration TTL time to `0` is not at all a prerequisite of using
    a dependency. We could have just as easily left the duration in as `300` seconds.
    This would just stipulate another rule to render the data in the cache invalid.
    The data would only be valid in the cache for a maximum of 5 minutes, but would
    also be regenerated prior to this time limit if there is a newer message, that
    is, a later `update_time` value in the table.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, the cache will only expire when the results of the query
    statement are changed. This example is a little contrived, since we were originally
    caching the data to avoid a database call altogether. Now we have configured it
    to execute a database query every time we attempt to retrieve data from the cache.
    However, if the cached data was a much more complex data set that involved much
    more overhead to retrieve and process, a simple SQL statement for cache validity
    could make a lot of sense. The specific caching implementation, the data stored,
    the expiration time, as well as any other data validation in the form of these
    dependencies, will all depend on the specific requirements of the application
    being built. It is good to know that Yii has many options available to help meet
    our varied requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Query caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The query caching approach of caching a database result is so often needed in
    database driven applications that Yii provides an even easier implementation for
    this, called **query caching**. As its name implies, query caching stores the
    results of a database query in cache and saves the query execution time on subsequent
    requests as these are served directly from cache. In order to enable a query,
    you need to ensure the `queryCacheID` property of the `CDbConnection` property
    refers to the `ID` attribute of a valid cache component. It refers to `'cache'`
    by default, which is what we already have configured from the preceding cache
    example.
  prefs: []
  type: TYPE_NORMAL
- en: To use query caching, we simply call the `cache()` method of `CDbConnection`.
    This method takes in a duration, to specify the number of seconds the query is
    to remain in cache. If the duration is set to `0`, caching is disabled. You can
    also specify a `CCacheDependency` instance as a second argument, and specify how
    many subsequent queries should be cached as a third argument. This third argument
    defaults to `1`, which means that only the next SQL query will be cached.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s change our previous cache implementation to use this cool query
    caching feature. Using the query caching, our implementation of the `SysMessage::getLatest()`
    method is greatly simplified. All we need to do is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here we have the same basic approach as before, but we don't have to deal with
    the explicit checking and setting of the cached values. We called the `cache()`
    method to indicate we want to cache the result for 30 minutes or, by specifying
    the dependency, refresh the value before that time if a more recent message becomes
    available.
  prefs: []
  type: TYPE_NORMAL
- en: Fragment caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous examples demonstrate the use of data caching. This is where we
    take a single piece of data and store it in the cache. There are other approaches
    available in Yii to store fragments of pages generated by a portion of a view
    script or even the entire page itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fragment caching refers to caching a fragment of a page. We can take advantage
    of fragment caching inside view scripts. To do so, we use the `CController::beginCache()`
    and `CController::endCache()` methods. These two methods are used to mark the
    beginning and the end of the rendered page content that should be stored in cache.
    Just as is the case when using a data caching approach, we need a unique key to
    identify the content being cached. In general, the syntax for using fragment caching
    inside a view script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The method `beginCache()` returns `false` when there is a cached version available,
    and the cached content will be automatically inserted at that place; otherwise,
    the content inside the if-statement will be executed and will be cached when `endCache()`
    is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring fragment caching options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When calling `beginCache()`, we can supply an array as the second parameter
    consisting of caching options to customize the fragment caching. As a matter of
    fact, the `beginCache()` and `endCache()` methods are a convenient wrapper of
    the `COutputCache` filter/widget. Therefore, the caching options can be initial
    values for any properties of the `COutputCache` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arguably one of the most common options specified when caching data is the
    duration, which specifies how long the content can remain valid in the cache.
    It is similar to the `duration` parameter we used when caching our system messages.
    You can specify the `duration` parameter when calling `beginCache()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The default setting for this fragment caching approach is different than that
    for the data caching. If we do not set the duration it defaults to 60 seconds,
    meaning the cached content will be invalidated after 60 seconds. There are many
    other options you can set when using fragment caching. For more information, refer
    to the API documentation for `COutputCache` as well as the fragment caching section
    of the Yii definitive guide, available on the Yii framework site: [http://www.yiiframework.com/doc/guide/1.1/en/caching.fragment](http://www.yiiframework.com/doc/guide/1.1/en/caching.fragment)'
  prefs: []
  type: TYPE_NORMAL
- en: Using fragment cache
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's implement this in our TrackStar application. We'll again focus on the
    project listings page. As you may recall, towards the bottom of the project listings
    page there is a list of the comments that users have left on the issues associated
    with each project. This list just indicates who left a comment on which issue.
    Rather than regenerating this list upon each request, let's use fragment caching
    to cache this list for, say, two minutes. The application can tolerate this data
    being slightly stale, and two minutes is really not that long to have to wait
    for an updated comment list.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we make our changes to the listing view file, `protected/views/project/index.php`.
    We''ll wrap the call to our entire recent comments portlet inside this fragment
    caching approach, as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, if we visit the project listings page for the first time,
    our comments list will be stored in the cache. If we then quickly (by quickly,
    we mean before two minutes have elapsed) add a new comment to one of the issues
    within a project, and then toggle back to the project listings page, we won't
    immediately see the newly added comment. But if we keep refreshing the page, once
    the content in the cache expires (a maximum of two minutes in this case), the
    data will be refreshed and our new comment will be displayed in the listing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You could also simply add an `echo time();` PHP statement to the previously
    cached content to see if it is working as expected. If the content is properly
    caching, the time display will not update until the cache is refreshed. When using
    the file cache, remember to ensure that your `/protected/runtime/` directory is
    writable by the web server process, as this is where the cache content is stored
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could avoid this situation by declaring a cache dependency, rather than
    a fixed duration. Fragment caching also supports cache dependencies. So, we could
    change the `beginCache()` method call, seen previously, to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here we have used the `CDbCacheDependency` method to cache the content until
    an update is made to our comments table.
  prefs: []
  type: TYPE_NORMAL
- en: Page caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to fragment caching, Yii offers options to cache the results of
    the entire page request. The page caching approach is similar to the fragment
    caching approach. However, because the content of an entire page is often generated
    by applying additional layouts to a view, we can't simply call `beginCache()`
    and `endCache()` in the layout file. The reason is that the layout is applied
    within the call to the `CController::render()` method after the content view is
    evaluated. So, we would always miss the opportunity to retrieve the content from
    the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, to cache a whole page, we should entirely skip the execution of the
    action generating the page content. To accomplish this, we can use the `COutputCache`
    class as an action filter in our controller class.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s use the page caching approach to cache the page results
    for every project detail page. The project detail pages in TrackStar are rendered
    by requesting URLs of the format `http://localhost/trackstar/project/view/id/[id]`,
    where `[id]` is the specific project ID we are requesting the details of. What
    we want to do is set up a page caching filter that will cache the entire contents
    of this page separately for every ID requested. We need to incorporate the project
    ID into the key value when we cache the content. That is, we don''t want to make
    a request for the details of project #1 and have the application return a cached
    result for project #2\. The `COutputCache` filter allows us to do just that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up `protected/controllers/ProjectController.php` and alter the existing
    `filters()` method as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This filter configuration utilizes the `COutputCache` filter to cache the entire
    output generated by the application from a call to `ProjectController::actionView()`.
    The `+ view` parameter added just after the `COutputCache` declaration, as you
    may recall, is the standard way we include specific action methods to which a
    filter should apply. The duration parameter specifies a TTL of 120 seconds (two
    minutes), after which the page content will be regenerated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `varyByParam` configuration is a really great option that we alluded to
    before. Rather than putting the responsibility on you, the developer, to come
    up with a unique key strategy for the content being cached, this feature allows
    the variation to be handled automatically. For example, in this case, by specifying
    a list of names that correspond to `GET` parameters in the input request. Since
    we are caching the page content of requests for projects by `project_id`, it makes
    perfect sense to use this ID as part of the unique key generation for caching
    the content. By specifying `''varyByParam''=>array(''id'')`, `COutputCache` does
    this for us based on the input querystring parameter `id`. There are more options
    available to achieve this type of autocontent variation strategy when using `COutputCache`
    to cache our data. As of Yii 1.1.12, the following variation features are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**varyByRoute**: By setting this option to `true`, the specific request route
    will be incorporated into the unique identifier for the cached data. Therefore,
    you can use the combination of the requested controller and action to distinguish
    cached content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**varyBySession**: By setting this option to `true`, a unique session ID is
    used to distinguish the content in the cache. Each user session may see different
    content, but all of this content can still be served from the cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**varyByParam**: As discussed earlier, this uses the input `GET` querystring
    parameters to distinguish the content in the cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**varyByExpression**: By setting this option to a PHP expression, we can use
    the result of this expression to distinguish the content in the cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, with the above filter configured in our `ProjectController` class, each
    request for a specific project details page is stored in the cache for two minutes
    before being regenerated and again stored in the cache. You can test this out
    by first viewing a specific project, then updating that project in some way. Your
    updates will not be immediately displayed if done within the cache duration time
    of two minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Caching entire page results is a great way to improve site performance, however
    it certainly does not make sense for every page in every application to be cached.
    Even in our example, caching the entire page for the project details page does
    not allow us to correctly use our pagination implementation for our issues listing.
    We used this as a quick example of how to implement page caching, but it is not
    always the right approach in every case. A combination of these three approaches,
    data, fragment, and page caching, allows you to adjust your caching strategy to
    meet your application requirements. We have really just scratched the surface
    of all caching options available within Yii. Hopefully this has whet your appetite
    to further investigate the full caching landscape available.
  prefs: []
  type: TYPE_NORMAL
- en: General performance tuning tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you are preparing your application for production, there are a few other
    things to take into consideration. The following sections briefly outline some
    other areas of consideration when working to tweak the performance of a Yii-based
    web application.
  prefs: []
  type: TYPE_NORMAL
- en: Using APC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enabling the PHP APC extension is perhaps the easiest way to improve the overall
    performance of an application. The extension caches and optimizes PHP intermediate
    code and avoids the time spent in parsing PHP scripts for every incoming request.
  prefs: []
  type: TYPE_NORMAL
- en: It also provides a very fast storage mechanism for cached content. With APC
    enabled, you can use the `CApcCache` implementation for caching content, fragments,
    and pages.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling the debug mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We discussed the debug mode earlier in the chapter, but it won't hurt to hear
    it again. Disabling debug mode is another easy way to improve performance and
    security. A Yii application runs in debug mode if the constant `YII_DEBUG` is
    defined as `true` in the main `index.php` entry script. Many components, including
    those down in the framework itself, incur extra overhead when running in the debug
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as was mentioned way back in [Chapter 2](ch02.html "Chapter 2. Getting
    Started"), *Getting Started*, when we first created a Yii application, most of
    your Yii application files do not need to be, nor should they be, in the publically
    accessible web directory. A Yii application has just one entry script, which is
    often the only file that needs to be placed in the web directory. Other PHP scripts,
    including all of the Yii framework files, should be protected. This is why the
    default name of the primary application directory is called `protected/`. To avoid
    security issues, it is recommended to keep it from being publicly accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Using yiilite.php
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the PHP APC extension is enabled, one can replace `yii.php` with a different
    Yii bootstrap file named `yiilite.php`. This can help to further boost the performance
    of a Yii-powered application. The file `yiilite.php` comes with every Yii release.
    It is the result of merging some commonly used Yii class files. Both comments
    and trace statements are stripped from the merged file. Therefore, using `yiilite.php`
    would reduce the number of files being included and avoid execution of trace statements.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that using `yiilite.php` without APC may actually reduce performance. This
    is because `yiilite.php` contains some classes that are not necessarily used in
    every request and would take extra parsing time. It is also observed that using
    `yiilite.php` is slower with some server configurations; even when APC is turned
    on. The best way to judge whether to use `yiilite.php` or not is to run a benchmark
    using the "Hello World" demo that is included in the code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Using caching techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we described and demonstrated in this chapter, Yii provides many caching
    solutions that may improve the performance of a web application significantly.
    If the generation of some data takes a long time, we can use the data caching
    approach to reduce the data generation frequency; if a portion of page remains
    relatively static, we can use the fragment caching approach to reduce its rendering
    frequency; if a whole page remains relative static, we can use the page caching
    approach to save the rendering cost for the whole page.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling schema caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the application is using **Active Record** (**AR**), you can turn on the
    schema caching in a production environment to save the time of parsing database
    schema. This can be done by configuring the `CDbConnection::schemaCachingDuration`
    property to be a value greater than zero.
  prefs: []
  type: TYPE_NORMAL
- en: Besides these application-level caching techniques, we can also use server-side
    caching solutions to boost the application's performance. The enabling of APC
    caching that we described here, belongs to this category. There are other server-side
    techniques, such as Zend Optimizer, eAccelerator, and Squid, just to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: These, for the most part, just provide some good practice guidelines as you
    work to prepare your Yii application for production or troubleshoot an existing
    application for bottlenecks. General application performance tuning is much more
    of an art than a science, and there are many, many factors outside of the Yii
    framework that play into the overall performance. Yii has been built with performance
    in mind since its inception and continues to outperform many other PHP-based application
    development frameworks by a long shot (see [http://www.yiiframework.com/performance/](http://www.yiiframework.com/performance/)
    for more details). Of course, every single web application will need to be tweaked
    to enhance the performance, but making Yii the development framework of choice
    certainly puts your application on a great performance footing from the onset.
  prefs: []
  type: TYPE_NORMAL
- en: For further details, see the *Performance Tuning* section of the Yii definitive
    guide at [http://www.yiiframework.com/doc/guide/1.1/en/topics.performance](http://www.yiiframework.com/doc/guide/1.1/en/topics.performance).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have turned our attention to making changes to our application
    in order to help improve its maintainability and performance in a production environment.
    We first covered application logging strategies available in Yii, and how to log
    and route messages based on varying severity levels and categories. We then turned
    our focus to error handling and how Yii exploits the underlying exception implementation
    in PHP 5 to provide a flexible and robust error handling framework. We then learned
    about some different caching strategies available in Yii. We learned about the
    caching of application data and content at varying levels of granularity. Data
    caching for specific variables or individual pieces of data, fragment caching
    for content areas within pages, and full page caching to cache the entire rendered
    output of a page request. Finally, we provided a list of good practices to follow
    when working to improve the performance of a Yii-powered web application.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! We should pat ourselves on the back. We have created an entire
    web application from conception to production readiness. Of course we should pat
    Yii on the back as well, as it helped ease and quicken the process at every turn.
    Our TrackStar application is already pretty great; but as is the case with all
    such projects, there is always room for enhancement and improvement. A nice foundation
    has been laid on which to build, and now that you have the power of Yii on your
    side you could very quickly turn this into a much more useable and feature-rich
    application. Also a great many of the examples covered will translate well to
    other types of web applications you may be building. I hope you now feel confident
    using Yii and will enjoy the benefits of doing so on your future projects. Happy
    developing!
  prefs: []
  type: TYPE_NORMAL
