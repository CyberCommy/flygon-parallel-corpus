- en: Building a Django Application with Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to create a Django based image gallery app where
    a user can create a photo album and upload images. While working in Django, it's
    really interesting and challenging to serve the static and media content. Usually,
    developers store the images in file storage and servers via the URL. Here, we
    are going to store images in AWS S3 and serve via the CDN network provided by
    the AWS CloudFront service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics we will cover in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Django
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing an image gallery application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving static and media files via AWS CloudFront CDN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up static and media files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Zappa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building, testing, and deploying the Django application using Zappa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django management command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before moving ahead, let''s fulfill some prerequisites required for this chapter.
    We are going to develop a Django based serverless application, so we need to meet
    the following requirements, which are being used for developing this application:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu 16.04/Mac/Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipenv tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django Imagekit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boto3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zappa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These packages are the required packages for this chapter, and we will be installing
    and configuring these packages using the pipenv tool. Now we will explore the
    configuration in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuring any Python project requires following a standard for maintaining
    the necessary package's versions. Many developers prefer to maintain the `requriements.txt`
    file, which helps them to keep the application stable. Any version upgrade of
    specific packages as mentioned in the `requirements.txt` may break the whole application.
    That's the reason developers strictly follow this standard to maintain a stable
    version of their application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a virtual environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I was following the traditional pattern until I came across a very cool tool
    that changed my traditional approach to maintaining the `requirements.txt` file.
    Now you won't need the `requirements.txt` anymore. It's called **pipenv**; I love
    to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Pipenv is a Python package management tool inspired by numerous package management
    tools of different languages, such as npm, Yarm, cargo, composer, builder, and
    so on. Pipenv is officially recommended by Python.org ([https://www.python.org/](https://www.python.org/)).
    This tool entitled the standard to manage Python packages.
  prefs: []
  type: TYPE_NORMAL
- en: Installing pipenv
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can initialize the virtual environment from anywhere and it will keep track
    of every package installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we need to install `pipenv` at the system level. So, if you are using
    macOS then you can simply install the `pipenv` using Homebrew as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using Ubuntu 17.10, then you can simply add a PPA repository and
    install using the `apt` command, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can simply install it via `pip` at the system level, instead of using `pip`
    from an active virtual environment. Take a look at this code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The system-level installation will be the installation without using any virtual
    environment. It installed in the system's `bin` directive and should be executable
    from the Terminal console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can see the detailed information on the `pipenv` commands by just
    executing the `pipenv` command at the Terminal console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can see there are several commands available that provide a very flexible
    way to deal with the virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring and installing packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we are going to create a virtual environment for our project and install
    the required packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot mentions the virtual environment creation process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from the preceding screenshot, we have created a virtual environment
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We explicitly mentioned the Python version that would be required; you can
    mention any Python version as well. If you are in hurry and just wanted to initialize
    with Python version 2 or 3, then you can just run the command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It has different sections for managing all packages. Now you can install any
    package using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are going to use the Django framework, we will install Django using pipenv
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once we install any package, then `pipenv` creates a `Pipfile.lock` file. The
    `Pipfile.lock` file maintains the commit hashes and dependencies of each installed
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you were thinking of activating the virtual environment, don't worry
    about it. You can relay everything to `pipenv` itself.  The `pipenv` provides
    a command named `pipenv shell` that internally invokes the virtual environment
    `activate` command. Now, you would be using the activated virtual environment
    shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of being inside the shell or activating the virtual environment, you
    can execute any command under the virtual environment by using the command `pipenv
    run <command as an argument>`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It's really interesting, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing all the required packages, the `Pipfile` will look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`Pipfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are done with the configuration and installation of the required packages.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next section, where we will be creating an image gallery
    application, using Django.
  prefs: []
  type: TYPE_NORMAL
- en: Designing an image gallery application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we are done with configuration, then we can start implementing the application.
    The `ImageGallery` application will be straightforward—a user can create a new
    photo album record and can upload multiple images at once. Once the photo album
    is created, we will display all existing album records in list view along with
    associated images as thumbnail views.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see the implementation phase, as per our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Design overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I am going to create an image gallery application based on Django. We are going
    to use Django admin for the purpose of the UI. Django admin has a very pretty
    UI/UX design. So we are going to create some models, such as a `PhotoAlbum` model
    that will have a one-to-many relationship with the `Photo` model.
  prefs: []
  type: TYPE_NORMAL
- en: Then we are simply going to register these models with the Django admin panel.
    Once we are done with the admin configuration, we will configure the static and
    media settings to upload the dynamic images to an Amazon S3 bucket and serve these
    static files via the CloudFront CDN network.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a close look at the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have configured the `pipenv`, you need to enable the virtual environment
    using the command `pipenv` shell. Assuming that you are in the `pipenv` shell,
    which is nothing but an activated virtual environment. Once you enable the virtual
    environment, you have access to already installed packages. Hence, we are going
    to create the Django project scaffolding by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a screenshot of the project creation process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: I have created the project and an app as well. From the previous screenshot,
    you can see the project and app files.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Django enables the admin panel in the root `urls.py` file. Hence,
    we do not need to configure it again.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's move to the model creation process in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to create two models—`PhotoAlbum` and `Photo` model, with a relationship
    of one-to-many. The following is the code snippet of the `gallery/models.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`gallery/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As planned, I have created two models, along with their relationship. Here,
    `PhotoAlbum` is straightforward, as it acts as a parent class. The `Photo` model
    is more interesting, as we are going to store images through it.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Photo` model, I am using the `django-imagekit` ([https://github.com/matthewwithanm/django-imagekit](https://github.com/matthewwithanm/django-imagekit))
    library to create and store a thumbnail image of the original uploaded image.
    It is quite interesting, as it has many features to allow us to work on an image
    as needed. My intention is to create a thumbnail of an uploaded image; hence,
    I configured it accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are done with model creation, you will need to run `makemigrations`
    and migrate the command to create the actual database tables. Have a look at the
    following screenshot to see the process of the `makemigrations` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once we run the `makemigrations` command, then we are ready to configure these
    models with the admin panel. Let's move on to the next section on configuring
    the admin panel.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with the admin panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Integrating models with the Django admin panel requires enabling the admin
    URL configurations in the root `urls.py` file. Let''s have a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`imageGalleryProject/urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'File—`gallery/admin.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we configure the `Photo` model as `TabularInline` so that we can add multiple
    photos or images under one album. We will have a complete workflow demo after
    deploying the application on AWS Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: At this point in time, you can run the application and store the images on your
    local machine. But later on, we want to deploy on AWS Lambda and then store images
    in an Amazon S3 bucket and serve via the Amazon CloudFront CDN network.
  prefs: []
  type: TYPE_NORMAL
- en: Application demonstration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already configured the models with the admin panel. Now we are going to run
    the Django's local server by using the `python manage.py runserver` command. It
    will start the Django server on `http://locahost:8000 URL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As mentioned in the preceding screenshot, we are creating a photo album. We
    defined the one-to-many relationship and used the `TabularInline` to accept multiple
    photos while creating the album. Take a look at this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The list page will appear once we are done with the adding process. Now, you
    can select the newly created album to view or edit the existing details. Take
    a look at this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can check that the previously uploaded images are displaying as thumbnails.
    We used the `django-imagekit` library for configuring the thumbnail image process.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will see in next section the required process for configuring the Amazon
    CloudFront CDN and integrating it with our application.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Amazon CloudFront CDN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amazon CloudFront is one of the more popular services. It provides the feature
    to serve static files through the CDN network, which helps static contents to
    be distributed in a very efficient way with lower latency to enhance the performance.
  prefs: []
  type: TYPE_NORMAL
- en: To configure Amazon CloudFront, we create a CloudFront distribution through
    the AWS user console.
  prefs: []
  type: TYPE_NORMAL
- en: Creating CloudFront distributions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assuming you have a valid AWS account, you can log in the AWS web console using
    your credentials. Select the CloudFront service from the services dropdown and
    click on the Create Distribution button, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: While creating a distribution, Amazon provides two different methods, such as
    web and RTMP. The web method is used for static content that needs to be served
    through the CDN network and when all static files are residing in an Amazon S3
    bucket. The RTMP method is used to distribute the streaming media files, which
    allow a user to play the file before it finishes the download.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we will choose the web method, as we want to distribute the static
    files. You can select the method as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you select the web method, the Create Distribution form page will open.
    On this page, we will select the required fields to configure the distribution.
    Take a look at this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After successful creation of the cloud distribution, we are going to integrate
    the distribution with our Django application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next section, where we will configure the static and media
    files in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up static and media files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuring the static and dynamic files in Django is essential. How we configure
    and serve static and media files does impact on the overall performance of the
    application. Hence, configuring the static and media files should be taken care
    of in an optimized way. Let's have a detailed discussion about it.
  prefs: []
  type: TYPE_NORMAL
- en: Standard configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django has a standard pattern to configure the static and media files. Static
    and media are two different concerns, where static files refer to fixed content,
    such as HTML, JS, CSS, and images. Django defines some configuration related to
    static files in `settings.py` and URL configured in `urls.py`. Media files refer
    to any files that are handled dynamically by uploading. Django has a very good
    mechanism to configure and manage static HTML, JS, CSS, and images files.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, the default Django static file configuration assumes that you will
    have static files along with your code base under a static directory, but, in
    our case, we want to put all static content under an Amazon S3 bucket and serve
    it through Amazon CloudFront distribution.
  prefs: []
  type: TYPE_NORMAL
- en: django-storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to use the `django-storage` ([http://django-storages.readthedocs.io/en/latest/](http://django-storages.readthedocs.io/en/latest/)),
    a third-party plugin for implementing a custom storage backend. With the help
    of Django storage, we are going set up the static and media configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code snippet, which is required to set up the custom storage
    for static and media files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`gallery/utils.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are going to configure these two custom storage classes in the `settings.py`
    file as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`imageGalleryProject/settings.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the settings you will be required to put into `settings.py`, and
    now its time to configure the `urls.py`. I would recommend that you update the
    root `urls.py`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`imageGalleryProject/urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you configure the URLs, then you are all set. To verify the configuration,
    you can run the command `collectstatic` to collect all your static files at the
    configured location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This command will retrieve all the static files belonging to the mentioned `INSTALL_APPS`
    and upload them to the `STATIC_ROOT`. Now, when you upload any file, it will be
    uploaded to Amazon S3 and serve via Amazon CloudFront.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to configure Zappa and process the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Building, testing, and deploying the Django application using Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Zappa configuration is straightforward. The Zappa package is available in the
    pip repository as well. But we are going to install it with pipenv, which helps
    us to keep track of the version management. The following is the command you will
    need to install Zappa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After the Zappa installation, you will need to initialize Zappa with the command
    `zappa init`. This command will prompt a shell questioner to configure Zappa with
    the required, basic information. Let's have a look at the next section, where
    we will discuss Zappa's basic configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we defined the configuration as per the requirements. As the key defines
    each configuration, we can see the usages of it. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aws_region`: The AWS region where the Lambda will get uploaded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django_settings`: The import path of Django''s settings file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`profile_name`: The AWS CLI configuration profile which is defined in the `~/.aws/credentials`
    file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`project_name`: The project name for the uploading Lambda function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runtime`: The python runtime interpreter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s3_bucket`: Creates an Amazon s3 bucket and uploads the deployment packages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remote_env`: Sets the environment variable of all the key-value pairs mentioned
    in the uploaded JSON file at the Amazon S3 location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the help of this configuration information, we will proceed with the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Building and deploying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we are done with the configuration, then we can process the deployment.
    Zappa provides two different commands to perform the deployment, such as `zappa
    deploy <stage_name>` and `zappa update <stage_name>`. Initially, we will use the
    `zappa deploy <stage_name>` command, as it is the first time that we are deploying
    this Lambda application.
  prefs: []
  type: TYPE_NORMAL
- en: If you have already deployed the application and want to redeploy it, then you
    would use the `zappa update <stage_name>` command. In the previous chapter, we
    had a detailed discussion about the deployment process of Zappa, so you can refer
    to this, if you need to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the screenshot of our deployment process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, after successful deployment, we got the API gateway endpoint
    URL. Let''s check how the deployment happened by visiting the admin panel at the
    mentioned URL. Take a look at this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Oops! We encountered an error. This error says that we have an invalid `HTTP_HOST`,
    and this is true because we have not configured it into the list of `ALLOWED_HOSTS`
    in the `settings.py` file, as mentioned here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This would resolve the issue. Now, let''s move on to check out the admin panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Oops! It seems as though we failed to load the static contents. But we configured
    the static and media content with Amazon S3 and Amazon CloudFront.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to resolve this error, we will need to run the command `python manage.py
    collectstatic`. This command will upload all the static content to Amazon S3 and
    it will be available via Amazon CloudFront. Take a look at this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Wow! We resolved the issue, and our application is live and serverless. That
    was really easy to deploy. I hope you did enjoy the deployment of the Django based
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we never dealt with any server software, such as Apache or Nginx and other
    complex configuration. Zappa makes it really easy to deploy your application as
    serverless.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will see what more we can do with the help of Zappa. Refer our next section
    for more excitement!
  prefs: []
  type: TYPE_NORMAL
- en: Django management command using Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zappa provides a feature to perform the Django's `manage` command operations
    on deployed Lamdba instances, directly from your Terminal console. With the help
    of `zappa mange <stage_name> <manage-command>`, you can execute and check the
    status of your Django application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the execution of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There are some limitations though. It is only for Django's `manage` command
    to use, hence it's bound to Django projects only.
  prefs: []
  type: TYPE_NORMAL
- en: 'For passing any arguments, you can use the `manage` command in string format,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'But it will not be useful for those commands that require user input, such
    as `createsuperuser`. So, in this kind of situation, you can write a Python script
    in string format and pass it as an argument for `zappa invoke <env> ''<raw_script>''
    --raw`. Take a look at this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: That's it.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you enjoyed it. It makes a developer's life easy. We may require these
    feature as we are dealing with serverless environments.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned how to build a serverless Django application. Zappa makes it very
    easy to perform the build operation and helps you to make a serverless deployment,
    which is very handy.
  prefs: []
  type: TYPE_NORMAL
- en: We covered all essential details we needed while implementing the serverless
    Django application. I explained the code written for this application; I am also
    sharing the entire code base at our GitHub repository ([https://github.com/PacktPublishing/Building-Serverless-Python-Web-Services-with-Zappa/tree/master/chapter_5/imageGalleryProject](https://github.com/PacktPublishing/Building-Serverless-Python-Web-Services-with-Zappa/tree/master/chapter_5/imageGalleryProject)).
  prefs: []
  type: TYPE_NORMAL
- en: I hope you enjoyed this chapter. In the next chapter, we will implement the
    same application, but as a RESTful API, and see what challenges we come across.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Amazon CloudFront?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is pipenv used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
