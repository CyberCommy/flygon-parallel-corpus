- en: Other Peoples' Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Humans, being complex and fickle, create complex and fickle things. However,
    dealing with other people and their code is an unavoidable part of being a programmer.
    Whether we deal with libraries and frameworks constructed by someone else or inherit
    entire legacy code bases, the challenges are similar. The first step should always
    be to seek an understanding of the code and its paradigms. When we have a full
    understanding of the code, we can begin to interface with it in a clean way, enabling
    us to create new functionality or make improvements on top of existing work. In
    this chapter, we'll be exploring this topic in more detail and, through the lens
    of clean code, considering how we can individually take actions to make other
    people's code less of a pain to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with third-party code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we join a new team or take on a new project, we are usually inheriting
    a large amount of code. Our ability to be productive in these inherited code bases
    is dependent on our understanding of them. So, before we even seek to make the
    first change, we need to build in our minds a conceptual model of how things work.
    It's not necessary for it to be exhaustive and complete, but it must enable us,
    at a very minimum, to make a change and understand exactly what effect that change
    may have on all the moving parts of the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring and understanding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding a code base fully is not strictly necessary to make use of it
    nor to make changes to it, but if we don't have a sufficient understanding of
    the complexity of all its interrelated parts, then we can fall into a trap. The
    trap occurs when we, believing we have a good understanding, start making changes.
    Without understanding the full effects of our actions, we can end up wasting time,
    implementing things poorly, and producing accidental bugs. Therefore, it is vital
    that we become properly informed. To do this, we must first gauge how complete
    or incomplete our *view* is of the complexity of the system or code base.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/54e09dd6-a47a-400a-ae30-b5ec6e93ba46.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Often the things we cannot see are completely unknown to us, and we are therefore
    unaware that we lack any understanding at all. This is encapsulated by the common
    expression *we don''t know what we don''t know*. It''s therefore helpful, when
    exploring a new code base, to proactively and enthusiastically push to discover
    and highlight our areas of ignorance. We can do this by following a three-step
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gather available information**: Talk to informed colleagues, read documentation,
    use the software, internalize the conceptual structures and hierarchies, and read
    the source code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Make informed assumptions**: Fill the gaps of what you aren''t sure about
    with informed assumptions. If you''re told that the app has a registration page,
    you can intuitively assume that this means user registration involves typical
    personal data fields such as name, email, password, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prove or disprove assumptions**: Seek to prove or disprove your assumptions
    by inquiring the system directly (for example, writing and executing tests), or
    asking someone who is informed (for example, a colleague who has experience of
    the code base).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a few specific approaches that are worth employing when it comes to
    creating and expanding an understanding of a new code base. These include making
    a flowchart, internalizing the timeline of changes, stepping through the code
    with a debugger, and confirming your assumptions via tests. We'll explore each
    of these individually.
  prefs: []
  type: TYPE_NORMAL
- en: Making a flowchart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One useful method we can employ almost immediately when encountering a new
    code base is to populate a mind map or flowchart that highlights not only the
    things we know but the things we aren''t yet sure about. Here''s a simplified
    example of such a diagram for a piece of medical software I once worked on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d8683dc7-070c-4423-8444-2af714c11deb.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, I have tried to outline my *current* understanding of the user
    flow and have also added questions or areas of confusion I am personally experiencing
    in the *cloud* annotations. Over time, as my understanding grows, I can add to
    this flowchart.
  prefs: []
  type: TYPE_NORMAL
- en: People learn in a huge variety of ways. This visual aid may be more useful for
    some people but less for others. There are also countless ways of composing such
    flowcharts. For the goal of personal understanding, it is best to *use whatever
    works for you*.
  prefs: []
  type: TYPE_NORMAL
- en: Finding structure and observing history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine you''re faced with a large JavaScript application code base that includes
    several specialized types of *views* or *components*. We''ve been tasked with
    adding a new drop-down to one of the payment forms within the application. We
    do a quick search through the code base and identify a number of different dropdown-related
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GenericDropdownComponent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DropdownDataWidget`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EnhancedDropdownDataWidget`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextDropdown`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImageDropdown`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They're confusingly named and so we'd like to get a better understanding of
    them before making changes or utilizing them. To do this, we can just open the
    source code of each component to establish how it may relate to the others (or
    how it does not relate).
  prefs: []
  type: TYPE_NORMAL
- en: 'We end up discovering that `TextDropdown` and `ImageDropdown`, for example,
    both appear to inherit from `GenericDropdownComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We also observe that both `DropdownDataWidget` and `EnhancedDropdownDataWidget`
    are sub-classes of `TextDropdown`. The naming of the *enhanced* drop-down widget
    might confuse us, and it may be something that we seek to change in the near future,
    but, for now, we'll need to hold our breath and just work on doing the work we've
    been tasked with.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid getting side tracked when you're completing a task within a legacy or
    unfamiliar code base. Many things may appear odd or wrong, but your task must
    remain the most important thing. Early on, it is unlikely that you have the level
    of exposure to the code base that would be necessary to make informed changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'By stepping through each dropdown-related source file, we can build up a solid
    understanding of them without having to make any changes. If the code base employs
    source control, then we can also *blame* each file to discover who originally
    authored it and when. This can inform us how things have changed over time. In
    our case, we discover the following timeline of changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9c313041-fba8-4a0d-910b-2653a05fadaf.png)'
  prefs: []
  type: TYPE_IMG
- en: This is incredibly helpful to us. We can see how, originally, there was only
    one class (named `DropdownComponent`), which later got changed to `GenericDropdownComponent`
    with two sub-classes, `TextDropdownComponent` and `ImageDropdownComponent`. Each
    of these got renamed to `TextDropdown` and `ImageDropdown`. Over time, these various
    changes illuminate the *why* of how things are at the present time.
  prefs: []
  type: TYPE_NORMAL
- en: When looking at a code base, we often make an implicit assumption that it was
    created *all at once* and with complete foresight; however, as our timeline illustrates,
    the truth is far more complex. Code bases change over time in reaction to new
    needs. The set of people who work on a code base also changes, and each individual
    will inevitably have their own way of solving problems. Our acceptance of the
    slowly evolving nature of every code base will help us to come to terms with its
    imperfections.
  prefs: []
  type: TYPE_NORMAL
- en: Stepping through the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When building an understanding of a singular piece of code within a large application,
    we can use tooling to debug and study how it functions. In JavaScript, we can
    simply place a `debugger;` statement, and then execute the part of the application
    that we know activates that particular code. We can then step through the code,
    line by line, to answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Where is this code called****?** A clear expectation of how an abstraction
    is activated can help us to build up a model of the *flow* or *order* of the application
    in our head, enabling us to make more accurate judgements about how to fix or
    change certain things.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What is passed to this code?** An example of what input an abstraction receives
    can help us to build up a clear concept about what it does, and how it expects
    to be interfaced with. This can directly guide our usage of the abstraction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What is outputted by this code?** Seeing the output of an abstraction, partnered
    with its input, can give us a really solid idea of what it does, computationally,
    and can help us to discern how we may wish to go about using it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What levels of misdirection or complexity exist here?** Observing complex
    and tall stack traces (meaning that, *functions that are called by functions that
    are called by functions, ad infinitum...*) can indicate that we may have difficulty
    in navigating and understanding the flow of control and information within a certain
    area. This would tell us that we may need to augment our understanding with additional
    documentation or communication with informed colleagues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of doing so in a browser environment (using Chrome Inspector):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/27b23d2e-e4c0-4dd3-a74c-11c43c095c7c.png)'
  prefs: []
  type: TYPE_IMG
- en: You can use Chrome's debugger even if you're implementing server-side JavaScript
    in Node.js. To do this, use the `--inspect` flag when executing your JavaScript, for
    example, `node --inspect index.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Using a debugger like this can present us with a *call stack* or *stack trace*,
    informing us of what path was taken through the code base to get to our `debugger;`
    statement. If we are trying to understand how an unfamiliar class or module fits
    into the larger picture of a code base, this can be very helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Asserting your assumptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the best ways to expand our knowledge of unfamiliar code is to write
    tests to confirm that the code behaves in the way we believe it does. Imagine
    we are given this piece of obscure code to maintain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is only used in a couple of places, but the various inputs are dynamically
    generated in a difficult-to-debug area of the application. Additionally, there
    is no documentation and absolutely no tests. It is quite unclear exactly what
    this code does, but, as we study the code line by line, we can begin to make some
    basic assumptions and encode these assumptions as assertions. For example, we
    can plainly see that the `makeExtractor` static function itself returns a function.
    We can specify this truth as a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also see some type of regular expression replacement occurring; it seemingly
    looks for patterns where the letter `o` is followed by a string of digits (`\bo(\d+?)\b`).
    We can begin to explore this extraction functionality by writing a simple assertion
    in which we give the extractor a string matching that pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add additional assertions as we slowly discover what the code does.
    We may never arrive at 100% understanding, but this is OK. Here, we''re asserting
    the fact that the extractor is able to correctly extract multiple OOIDs present
    within a single string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When running these tests, we observe the following successful results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note how we're still not entirely sure what the original code does. We have
    only scraped the surface, but in doing so, we are building a valuable foundation
    of understanding that will make it far easier for us to interface with or change
    this code in the future. With each new successful assertion, we get closer to
    a complete and accurate understanding of what the code does. And if we commit
    these assertions as a new test, then we are also improving the test coverage of
    the code base and providing assistance for future colleagues who may have been
    similarly confused by the code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a solid grasp of how to explore and understand an inherited
    piece of code, we can now look into how we might *make changes* to that code.
  prefs: []
  type: TYPE_NORMAL
- en: Making changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have a good level of understanding about an area of a code base, we
    can begin to make changes. Even at this stage, however, we should be cautious.
    We are still relatively new to the code base and the system it relates to and
    so we''re probably still unaware of many of its parts. Any change could potentially
    create unforeseen effects. To move forward we must, therefore, go slowly and considerately,
    ensuring our code is well designed and well-tested. There are two specific methodologies
    we should be aware of here:'
  prefs: []
  type: TYPE_NORMAL
- en: The delicate *surgical* process of making isolated changes in an unfamiliar
    setting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The confirmation of changes via tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's explore these, one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Minimally invasive surgery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When changes are needed in an area of the code base that is old or unfamiliar,
    it can be useful to imagine that you are performing a kind of *minimally invasive
    surgery*. The aim in doing this is to maximize the positive effect of a change
    while minimizing the footprint of the change itself, ensuring not to damage or
    have too much impact on other parts of the code base. The hope with doing this
    is that we will be able to produce the necessary changes (*upsides*) without exposing
    ourselves too much to the possibility of breakages or bugs (*downsides*). This
    is also useful when we aren't sure whether the change is entirely necessary, so
    we want to only expend minimal effort on it initially.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine that we have inherited a `GalleryImage` component that is responsible
    for rendering singular images. There are many places in our web application where
    it is used. The task is to add the ability for videos to be rendered when the
    URL of the asset indicates that it is a video. The two types of CDN URLs are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://cdn.example.org/VIDEO/{ID}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://cdn.example.org/IMAGE/{ID}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, there is a clear difference between image and video URLs. This
    gives us an easy way of differentiating how we render these pieces of media on
    the page. Ideally, it is reasonable to say that we should implement a new component
    named `GalleryVideo` to handle this new type of media. A new component like this
    would be able to cater uniquely to the *problem domain* of a video, which is notably
    different from that of an image. At the very least, a video must be rendered via
    a `<VIDEO>` element, while an image must be rendered via `<IMG>`.
  prefs: []
  type: TYPE_NORMAL
- en: We discover that many of the situations where `GalleryImage` is used are not
    well tested and some rely on obscure internal implementation details that would
    be difficult to discern in bulk (for example, it would be hard to do a find and
    replace if we wanted to change all `GalleryImage` usages).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our available options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a *container* `GalleryAsset` component that itself makes a decision
    about whether to render a `GalleryImage` or `GalleryVideo` based on the CDN URL.
    This would involve having to replace every current usage of `GalleryImage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Time estimate: **1-2 weeks**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Footprint across the code base: **Significant**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Possibility of unforeseen breakages: **Significant**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Architectural *cleanliness*: **High**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add a condition within `GalleryImage` that optionally renders a `<video>` instead
    of an `<img>` tag based on the  CDN URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Time estimate: **1-2 days**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Footprint across the code base: **Minimal**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Possibility of unforeseen breakages: **Minimal**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Architectural *cleanliness*: **Medium**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In ideal circumstances, if we consider the long-term architecture of the code
    base, it is clear that the first option of creating a new `GalleryAsset` component
    is the best one. It gives us a clearly defined abstraction that intuitively caters
    to the two cases of images and videos and also provides us with the possibility
    of adding different asset types in the future (for example, *audio*). It will,
    however, take longer to implement, and carries quite a significant amount of risk.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is far simpler to implement. In fact, it may only involve
    the following four-line change set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is not necessarily a good long-term choice, but it gives us something we
    can immediately ship to users, fulfilling their needs and the needs of our stakeholders.
    Once shipped, we can then plan future time to complete the larger necessary change.
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate, the value of a *minimally invasive* change like this is that it
    reduces the immediate downsides (*risks*) to the code base in terms of implementation
    time and potential breakages. Obviously it is vital to ensure that we are balancing
    short-term gains with long-term. Often, stakeholders will pressure programmers
    to implement a change quickly, but if there is no *technical* *dept* or reconciliation
    process, then all of these *minimally invasive *changes can gather into quite
    a terrifying beast.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that the code we change is not too delicate or liable to future regressions,
    it is wise to write tests alongside them, encoding our expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding changes as tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already explored how we can write tests to discover and specify current
    functionality, and, in previous chapters, we discussed the obvious benefits of
    following a **Test-Driven-Development** (**TDD**) approach. It follows that we
    should, when operating in an unfamiliar code base, always confirm our changes
    via cleanly written tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests alongside your changes is definitely a need when there are no
    existing tests. Writing the first test in an area of code can be burdensome in
    terms of setting up libraries and necessary mocks, but it is absolutely worth
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our previous example of introducing the capability of rendering videos to
    `GalleryImage`, it would be wise to add a simple test to confirm that `<VIDEO>`
    is correctly rendered when the URL contains the `"/VIDEO/"` substring. This prevents
    the possibility of future regressions and gives us a strong level of confidence
    that it works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is a rather simple test; however, it completely encodes the expectations
    we have after making our changes. When making small and self-contained changes
    or larger systemic changes, it's so incredibly valuable to verify and communicate
    our intent via tests like these. As well as preventing regressions, they aid our
    colleagues in terms of immediate code review, and the entire team in terms of
    documentation and general reliability. As such, it's quite normal and preferable
    to have a team mandate or policy that says *you cannot commit a change if it does
    not come with a test*. Enforcing this will, over time, create a code base that
    produces more reliable functionality for users and is more pleasant to work with
    for fellow programmers.
  prefs: []
  type: TYPE_NORMAL
- en: We've now completed the section on *Inheriting code*, and so you should have
    a good foundational knowledge of how to deal with such a situation. Another challenge
    in dealing with *other people's code* is the selection and integration of third-party
    code, meaning libraries and frameworks. We'll explore this now.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with third-party code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The landscape of JavaScript is filled with a myriad of frameworks and libraries
    that can ease the burden of implementing all types of functionality. In [Chapter
    12](5df59321-fd46-4504-93ed-5e8555b33b01.xhtml), *Real-World Challenges,* we had
    a look at the difficulties involved in including external dependencies in our
    JavaScript projects. The modern JavaScript ecosystem provides a rich variety of
    solutions here, and so dealing with third-party code is far less burdensome than
    it was before. Nonetheless, the nature of having to interface with this code hasn't
    really changed. We must still hope that our selected third-party library or framework
    provides an interface that is intuitive and well-documented, and functionality
    that fulfills our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with third-party code, there are two crucial processes that will
    define the ongoing risks or benefits we receive. The first is the *selection*
    process, where we make a choice as to which library to use, and the second is
    our integration and adaptation of the library into our code base. We'll now go
    over both of these in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Selection and understanding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Picking a library or framework can be a risky decision. Pick the wrong one
    and it can end up driving much of the architecture of your system. Frameworks
    are especially notorious for this because, by their nature, they dictate the structure
    and conceptual underpinning of your architecture. Picking the wrong one and then
    seeking to change it can be a considerable effort; one that involves changes to
    almost every single piece of code within an application. As such, it is vital
    to practice the skill of careful consideration and selection of third-party code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/85b09dc5-0500-4a1d-90d6-4b9c8a36e280.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a number of useful considerations we can make in order to help us
    in the process of selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functionality**: The library or framework must fulfill a set of fixed functional
    expectations. It''s important to specify these in a sufficiently detailed way
    so that different options can be quantifiably compared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compatibility**: The library or framework must be mostly compatible with
    the way the code base currently works, and must be able to integrate in a way
    that it is technically simple and easy to understand for colleagues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usability**: The library or framework must be easily usable and understandable.
    It should have good documentation and a level of intuitiveness that allows immediate
    productivity without pain or confusion. The consideration of what occurs when
    you have a problem or question related to usage is also under the umbrella of
    usability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintenance and security**: The library or framework should be maintained
    and have a clear and trusted process for reporting and resolving bugs, especially
    those that may have security ramifications. The changelogs should be exhaustive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The four criteria here can be informed, as well, by heuristics such as *who
    is the project backed by?*, *how many people are making use of the project?*,
    or *am I familiar with the team who built it?*. Be warned though, these are only
    heuristics and so are not perfect ways of measuring the suitability of *third-party
    code*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even using these four criteria, however, we may fall into traps. If you''ll
    recall, in [Chapter 3](4aede822-c58b-4e6b-81cd-ba27582e9aa7.xhtml), *The Enemies
    of Clean Code*, we discussed the most notable *Self* (or *ego*) and *The cargo
    cult*. These are also relevant when selecting third-party code. Remember to specifically
    watch out for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Powerful opinions**: It''s crucial to separate ourselves from the decision
    process as much as possible, and to be very wary of our ignorances and biases.
    Programmers are well known for their opinionated nature. It''s important in these
    moments to step back from ourselves and reason with pure logic about what we believe
    would be best. It''s key to give everyone a voice as well, and to weigh people''s
    opinions and anecdotes according to their own merits, not according to their seniority
    (or other personal characteristics).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The popularity cult**: Don''t get too swayed by popularity. It''s easy to
    get drawn into a popular abstraction due to the size and zealotry of its community,
    but once again, it is vital to take a step back and consider the merits of the
    framework in isolation. Naturally, popularity may indicate an ease of integration
    and more abundant learning resources, so in that way, it is reasonable to talk
    about, but just be wary of using popularity as a sole indicator of superiority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analysis paralysis**: There are a lot of choices out there, so it is possible
    to end up in a situation where you are seemingly unable to make a choice out of
    fear of making the wrong one. Most of the time, these decisions are reversible,
    so it''s not the end of the world to make a less than optimal choice. It''s easy
    to end up in a situation where a lot of time is being used up deciding which framework
    or library to pick when it would be far more efficient to just pick *anything*
    and then iterate or pivot according to changing needs at a later point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key thing when making decisions about third-party libraries is to fully
    appreciate their eventual effects on the code base. The amount of time we sink
    into making a decision should be proportional to their potential effects. Deciding
    on a client-side framework for component rendering may be a rather impactful choice
    as it may prescribe a significant portion of the code base, whereas, for example,
    a small URL-parsing utility does not have a great impact and can be easily swapped
    out in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can discuss how we might integrate and encapsulate a piece of third-party
    code, following a well-informed selection process.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating and adapting third-party code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The downside of picking a third-party abstraction, especially a framework, is
    that you can end up changing your code base to suit the arbitrary conventions
    and design decisions of the abstraction's authors. Often, we are made to *speak
    the same language* of these third-party interfaces, instead of having them *speak
    our language*. Indeed, in many cases, it may be the abstraction's conventions
    and design that is appealing to us, and so we are more than happy for it to drive
    the design and nature of our code base. But, in other situations, we may want
    to be more protected from our chosen abstractions. We may want the option to easily
    swap them out for other abstractions in the future, or we may already have a set
    of conventions that we prefer to use.
  prefs: []
  type: TYPE_NORMAL
- en: In such cases, it may be useful to encapsulate these third-party abstractions
    and deal with them purely through an abstraction layer of our own. Such a layer
    would typically be called an *Adapter:*
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d6120549-ec8a-4d87-9b7f-600f3e363ec3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Very simply, an *Adapter* will provide an interface that we design, and will
    then delegate to the third-party abstraction to accomplish its tasks. Imagine
    if we wished to use a URL-parsing utility called `YOORL`. We''ve decided it works
    perfectly for our needs, and has complete compliance with RFC 3986 (the URI standard).
    The only issue is that its API is rather burdensome and verbose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This would return the following *Object*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We would prefer it if the API was far simpler. The length and complexity of
    the current API, we feel, would expose our code base to needless complexity and
    risk (the risk of calling it the wrong way, for example). Using an *Adapter* would
    allow us to wrap up this non-ideal interface into an interface of our own design:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that any modules within our code base can now interface with this
    simplified *Adapter, *insulating them from the unideal API of YOORL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Adapters can be thought of as *translation mediums*, allowing our code base
    to *speak the language* of its choice, not having to be slowed down by the arbitrary
    and inconsistent design decisions of third-party libraries. This not only aids
    the usability and intuitiveness of the code base but also enables us to very easily
    make changes to the underlying third-party library without having to change many
    lines of code at all.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored the tricky topic of *other people's code*.
    We've considered how we can deal with legacy code that we inherit; how we can
    build our understanding of it, how we can debug and make changes without difficult,
    and how we can confirm our changes with a good testing approach. We've also covered
    the difficulty of dealing with third-party code, including how to select it and
    how to interface with it in a risk-averse way via the *Adapter* pattern. There
    are plenty of other things that we could have spoken about in this chapter, but
    hopefully the topics and principles we have been able to explore have given you
    a sufficient understanding of how to navigate other people's code with an eye
    toward a clean code base.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the topic of communication. It may not appear
    relevant but communication, both within our workplaces and toward our users, is
    an absolutely vital skill for the programmer, and without it there is little possibility
    of clean code. We'll specifically be exploring how to plan and set requirements,
    how to collaborate and communicate with colleagues, and how to drive change within
    our projects and workplaces.
  prefs: []
  type: TYPE_NORMAL
