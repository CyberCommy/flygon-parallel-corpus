- en: '*Chapter 13*: Intrusion Prevention Systems on Linux'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll build on packet capture and logging to explore intrusion
    prevention options on the Linux platform. An **Intrusion Prevention System** (**IPS**)
    does exactly what it sounds like – it monitors traffic, and either alerts on or
    blocks suspicious or known malicious traffic. This can be done in a variety of
    ways, depending on what traffic you are trying to monitor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is an IPS?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture/IPS placement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classic IPS solutions for Linux – Snort and Suricata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPS evasion techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suricata IPS example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing an IPS rule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passive traffic monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zeek example – collecting network metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter's examples, we will use pre-packaged virtual machines, either
    based on **Suricata-Elasticsearch-Logstash-Kibana-Scurius** (**SELKS**) or Security
    Onion (two different pre-packaged Linux distributions). As in our packet capture
    examples, IPS solutions often operate against captured traffic, so you may need
    to refer to [*Chapter 11*](B16336_11_Final_NM_ePub.xhtml#_idTextAnchor192), *Packet
    Capture and Analysis in Linux*, to ensure you have an appropriate SPAN port configuration.
    More commonly, though, IPS solutions operate in line with the packet stream, usually
    with some decryption functionality – so, you may find yourself comparing the architecture
    more to our load balancer examples from [*Chapter 10*](B16336_10_Final_NM_ePub.xhtml#_idTextAnchor170),
    *Load Balancer Services for Linux*.
  prefs: []
  type: TYPE_NORMAL
- en: As IPS installations change frequently, this reflects on the installations for
    these two distributions. Because of this, we won't walk through installing packages
    and so on in this chapter, so please refer to the online installation for whichever
    solution you want to explore in your lab. Or, as always, you have the option to
    follow along as we proceed through the chapter. While you likely do want to implement
    some of the tools we will discuss in this chapter, they are mostly on the complex
    side – you might not want to build a test IPS, for instance, until you are close
    to building one for production.
  prefs: []
  type: TYPE_NORMAL
- en: What is an IPS?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IPS started as Intrusion Detection Systems in the 1990s. The most commonly used
    IDS/IPS product from the beginning (way back in the 1990s) was Snort, which is
    still a product (both open source and commercial), and which many other modern
    IPS products are now based on.
  prefs: []
  type: TYPE_NORMAL
- en: 'An IPS watches network traffic for known attacks and then blocks them. Of course,
    there are a few failings in this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Enumerating badness* is a solid losing proposition, which the anti-virus industry
    has long realized. No matter what signature pattern you enumerate for, an attacker
    can mount the same attack with only minor modifications to evade signature-based
    detections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: False positives are a milestone around the neck of these products. If they're
    not configured properly, it can be easy for a signature to mistakenly flag normal
    traffic as malicious and block it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the other end of the spectrum, if the configuration is too permissive, it
    can be easy to not alert or block attack traffic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, deploying an IPS is usually a balancing act that needs frequent
    tinkering. Luckily, modern IPS systems mostly have good defaults set, blocking
    a reasonable segment of known attacks with false positives.
  prefs: []
  type: TYPE_NORMAL
- en: When adjusting the rules for your organization, you'll normally see that each
    rule will have a severity rating, which gives you some indication of how serious
    the associated attack is. Rules will also have a fidelity rating, which tells
    you how "solid" the rule is in detecting the attack, i.e., how likely is this
    rule to falsely trigger in normal traffic. You can usually use these two ratings
    to make decisions about which rules to enable in your circumstance.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've provided a bit of a background on IPS solutions, let's look at
    where you might want to insert an IPS into your data center.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture options – where does an IPS fit in your data center?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Where you should place an IPS in your data center is an important decision,
    so we'll discuss this decision while providing a dose of IPS/IDS history.
  prefs: []
  type: TYPE_NORMAL
- en: Back in the day, data centers were configured with a "crunchy shell, soft chewy
    center" architecture. In other words, protections were focused on the perimeter,
    to protect against external attacks. Internal systems were mostly trusted (usually
    trusted too much).
  prefs: []
  type: TYPE_NORMAL
- en: This put the IDS at the perimeter, often on a SPAN port or on a network tap.
    If you review the tap options that we discussed in [*Chapter 11*](B16336_11_Final_NM_ePub.xhtml#_idTextAnchor192),
    *Packet Capture and Analysis in Linux*, if deployed this way, it was normally
    a one-way tap, electrically preventing the IDS from sending traffic. This was
    to minimize the possibility that the IDS itself might be compromised.
  prefs: []
  type: TYPE_NORMAL
- en: A second, trusted interface would be used to manage the IDS.
  prefs: []
  type: TYPE_NORMAL
- en: 'This configuration evolved to eventually include the ability of the IDS to
    send an **RST** (**TCP Reset**) packet to the attacker, defender, or both to terminate
    any attack traffic with extreme prejudice, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – IPS located outside the firewall, SPAN port for traffic collection,
    and a RESET packet to block detected attacks](img/B16336_13_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – IPS located outside the firewall, SPAN port for traffic collection,
    and a RESET packet to block detected attacks
  prefs: []
  type: TYPE_NORMAL
- en: This configuration evolved as attacks became better understood and the internet
    became more hostile. Watching for malicious traffic on the internet became much
    less productive, as watching external traffic was likely to just generate constant
    alerts as attackers began to monetize malware and their associated attacks.
  prefs: []
  type: TYPE_NORMAL
- en: You still wanted to monitor inbound attacks, but where possible, you only wanted
    to monitor for attacks that can be applied to any given host. For instance, if
    your firewall only allowed mail traffic to inbound to a mail server, looking for
    and alerting on web-based attacks against that host just didn't make sense anymore.
    With that methodology in place for inbound attacks, we now see IDS and IPS systems
    being deployed more frequently behind the firewall.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that same timeframe, we began to see malware being distributed more in emails
    – in particular, as macros in office documents. It was difficult to effectively
    protect an organization against these attacks, especially as many organizations
    had built workflows around macros and refused to disable them. What this meant
    was that it became very effective to look for outbound traffic from compromised
    workstations and servers, which would indicate a successful attack. Normally,
    this traffic took the form of **Command and Control** (**C2**) traffic, where
    the compromised workstation reaches out to the attacker for instructions regarding
    what to do next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – IPS inside the firewall detecting C2 traffic. Also, some internet
    "noise" is filtered out](img/B16336_13_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – IPS inside the firewall detecting C2 traffic. Also, some internet
    "noise" is filtered out
  prefs: []
  type: TYPE_NORMAL
- en: The rise of encryption meant that having the IPS in a semi-passive mode became
    less and less effective. To effectively detect attack traffic, in today's internet,
    at least some of it needs to be decrypted. What this means is that the IPS must
    be in line, often running on the firewall itself. This change in architecture
    was paired with cheaper processors, allowing people to allocate more CPU to their
    firewalls (usually with disk and memory to match).
  prefs: []
  type: TYPE_NORMAL
- en: 'For inbound traffic, this means that the IPS now hosts a certificate that matches
    the destination server. It is decrypted at the IPS, inspected for suspicious content,
    and then forwarded on (usually re-encrypted) if it gets the green light. This
    should look familiar, as we discussed a very similar architecture when we discussed
    load balancers in [*Chapter 10*](B16336_10_Final_NM_ePub.xhtml#_idTextAnchor170),
    *Load Balancer Services for Linux*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – IPS on a perimeter firewall. The web server certificate allows
    inbound HTTPS decryption](img/B16336_13_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – IPS on a perimeter firewall. The web server certificate allows
    inbound HTTPS decryption
  prefs: []
  type: TYPE_NORMAL
- en: Outbound decryption is a bit more complicated. For this to work, the IPS needs
    a **Certificate Authority** (**CA**) to be hosted on it, which the internal workstations
    must trust. As outbound traffic transits, the IPS dynamically creates a certificate
    for the destination, which is what the user now sees if they look at an HTTPS
    certificate in their browser.
  prefs: []
  type: TYPE_NORMAL
- en: This allows the IPS to decrypt the outbound traffic. The traffic that is outbound
    from the IPS to the destination host then proceeds as normal with a new encrypted
    session, using the real certificate on that destination host.
  prefs: []
  type: TYPE_NORMAL
- en: When an attack is detected, any resulting alert will have the IP address of
    the client workstation. In a Windows/Active Directory environment, usually, the
    IPS will have a matching "agent" that monitors the security log of each domain
    controller. This allows the IPS to then match up IP addresses with the user account
    names that are in use on that station at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the IPS and firewall share a common platform, this also allows the firewall
    to add rules based on the user account, groups, certificate information (which
    includes the domain name and often the FQDN of the destination host), in addition
    to the traditional rules based on the source and destination IP address, ports,
    and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – IPS on a perimeter firewall. A CA certificate allows outbound
    client traffic to be decrypted](img/B16336_13_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – IPS on a perimeter firewall. A CA certificate allows outbound
    client traffic to be decrypted
  prefs: []
  type: TYPE_NORMAL
- en: A special case of IPS grew at the same time, known as **Web Application Firewalls**
    (**WAFs**). These were appliances that focused primarily on inbound web-based
    attacks. As the internet has moved to almost exclusively HTTPS content for web
    destinations, these WAF solutions also needed decryption to detect most attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the beginning, these WAF solutions took the form of dedicated appliances,
    but have since moved to be features that are available on most load balancers.
    The most prevalent open source WAF solutions include ModSecurity (available for
    both Apache and Nginx), but many others exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Inbound IPS (WAF) and decryption hosted on a load balancer,
    inside the firewall](img/B16336_13_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – Inbound IPS (WAF) and decryption hosted on a load balancer, inside
    the firewall
  prefs: []
  type: TYPE_NORMAL
- en: The main issue with WAF solutions is the same as we saw for traditional IPS
    – coverage that is either too aggressive or too lax. At one end of the spectrum,
    there are WAF solutions that don't require a lot of configuration – these tend
    to protect against specific attacks such as cross-site scripting or SQL injection,
    where the syntax is often predictable, but not against other common attacks. At
    the other end of the spectrum, we have products that need to be configured for
    the individual fields in the application, frontending the app with full input
    validation. These products work well but need to be matched to the application
    as changes and new features are implemented. If this isn't done, the application
    can be broken by the tool that was put there to protect it.
  prefs: []
  type: TYPE_NORMAL
- en: Newer WAF options consider the fact that larger cloud-based websites often don't
    operate with load balancer appliances or firewalls. In some cases, they deliver
    their content via **Content Delivery Networks** (**CDN**), but even if they operate
    directly from one of the larger cloud service providers, they might on the internet.
    Also, for larger sites where the uplink is 10, 40, or 100 Gbps, WAF appliance
    solutions simply don't scale that well.
  prefs: []
  type: TYPE_NORMAL
- en: For these sites, the firewall is pushed to the host itself (as we discussed
    in [*Chapter 4*](B16336_04_Final_NM_ePub.xhtml#_idTextAnchor071), *The Linux Firewall*),
    and the WAF moves to the host as well. Here, each host or container becomes a
    work unit unto itself, and scaling up the capacity for the site becomes a matter
    of just adding another work unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'For these situations, our WAF has morphed to a **Runtime Application Self Protection**
    (**RASP**) solution. As the name implies, not only is the RASP software on the
    same platform as the application, but it''s tied much more tightly to the application.
    The RASP code appears on each page of the site, usually as a simple tag that loads
    the RASP component with each page. This not only protects against known attacks
    but in many cases, it protects against "unusual" inputs and traffic and even the
    site or site code from being modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Cloud web service hosting a local firewall and RASP IPS solution](img/B16336_13_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – Cloud web service hosting a local firewall and RASP IPS solution
  prefs: []
  type: TYPE_NORMAL
- en: 'These RASP solutions have proven to be so effective that they are replacing
    traditional WAF products in many corporate sites. In these situations, the firewall
    is typically at the perimeter rather than on the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – RASP in a corporate environment with the perimeter firewall
    shown](img/B16336_13_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.7 – RASP in a corporate environment with the perimeter firewall shown
  prefs: []
  type: TYPE_NORMAL
- en: RASP solutions include OpenRASP on the free/open source side of the equation
    and products such as Signal Sciences or Imperva on the commercial side.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have some background on various IPS systems, let's take a minute
    and look at them from an attacker's or penetration tester's point of view.
  prefs: []
  type: TYPE_NORMAL
- en: IPS evasion techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inbound evasion takes advantage of the differences between how the IPS (which
    is Linux-based) interprets the malicious packets and data streams, and how the
    target interprets these packets. This is true of both traditional IPS systems
    and WAF systems.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting a WAF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a WAF, it's handy for an attacker to know that a WAF is in play, and what
    it's based on. Wafw00f is a good starting point here. Wafw00f is a free scanner
    that can detect over 150 different WAF systems, many of which are also load balancers.
    It is written in Python and is hosted at [https://github.com/EnableSecurity/wafw00f](https://github.com/EnableSecurity/wafw00f),
    but is also packaged within Kali Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'By testing a few sites, we can see different WAF solutions being hosted by
    hosting providers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And for a third site, we can see a commercial WAF (which is also cloud-based):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we noted, if you know what WAF is in play, then you have a better chance
    of evading that WAF. Of course, if you are an attacker or a penetration tester,
    you still have to compromise the website behind that WAF, but that's a whole different
    story.
  prefs: []
  type: TYPE_NORMAL
- en: Since the inbound targets are often web servers and are also often Windows hosts,
    evasion on this traffic often takes advantage of handling fragmented packets.
  prefs: []
  type: TYPE_NORMAL
- en: Fragmentation and other IPS evasion methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Artificially fragmenting packets, then sending them out of order, and, in some
    cases, sending duplicate fragment numbers with different information in them is
    a favorite way to evade or detect an IPS.
  prefs: []
  type: TYPE_NORMAL
- en: This takes advantage of differences between how the IPS's operating system (usually
    a Linux variant) might handle fragments, compared to the host behind the operating
    system, which might be a different operating system entirely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even something as simple as breaking `maliciousdomain.com` into `malic` and
    `iousdomain.com` can make all the difference if the IPS doesn''t reassemble fragments
    at all. More commonly, though, you''ll see a sequence of packet fragments similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_13_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The goal for the attacker is to manage how duplicate fragments are reassembled.
    If Linux reassembles this as `MalicASDFdomain.com` and Windows reassembles this
    as `mailicousdomain.com`, then an attacker has a way to infiltrate from or exfiltrate
    to a malicious domain through the Linux-based IPS. Most modern IPSes will reassemble
    fragments in several different ways or will identify the operating system of the
    target host and reassemble based on that.
  prefs: []
  type: TYPE_NORMAL
- en: This is an older attack, pioneered by *Dug Song* in his `fragroute` tool in
    the early 2000s. While this tool will no longer work on a properly configured
    modern IPS, some vendors don't have the proper settings for fragment reassembly
    enabled by default in their commercial products. So, while it isn't supposed to
    work, it's always a handy thing for a penetration tester to try because sometimes,
    you'll be in luck and get an IPS bypass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Outbound evasion often takes advantage of decisions that are made when installing
    and configuring the IPS; take the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: IPS systems might bypass anything that looks like a Windows update – this can
    allow attackers to use the BITS protocol to bypass the IPS to transfer files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, streaming media services will be bypassed for performance reasons.
    This setting can allow attackers to, for instance, embed C2 information into the
    comments for a specific YouTube video.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If decryption is not in place, attackers can simply use HTTPS and sail right
    on through, so long as their external host isn't flagged as suspicious by its
    IP or DNS name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if decryption is in play, if the attacker uses a valid pinned certificate,
    the decryption will fail, which will often mean that the IPS will fall back to
    an "allow" rather than a "drop" response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will always be protocols that aren't handled well by decryption and re-sign
    mechanisms; those are also often options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Roll your own" encryption is also something that we see attackers use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tunneling data in or out using DNS is also a time-honored option. You can simply
    stream data on port `53/udp`, and you'll be surprised how often this works, even
    though the packets themselves won't look anything like DNS packets. However, even
    if the IPS inspects the DNS packets to ensure validity, you can tunnel a surprising
    amount of data out using valid DNS queries – `TXT` queries especially for inbound
    transfers (the data being in the `TXT` response) or `A` queries for outbound queries
    (the data being in the queried DNS hostname).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or, most commonly, attackers will simply use a **C and C framework** to set
    up their channel. There are several options for this, with commercial, pirated,
    or open source tools falling in and out of favor, depending on how effective they
    are at any given time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long story short, if your IPS doesn't understand a particular data stream, you
    might consider setting it to block that traffic. This method will block some production
    traffic, but you'll find that this is an ongoing tightrope that needs to be walked,
    weighing the needs of the community that you are protecting against the effectiveness
    of the IPS.
  prefs: []
  type: TYPE_NORMAL
- en: With the attacker's point of view covered (at least at a high level), let's
    look at some practical applications – starting with network-based IDS/IPS systems.
  prefs: []
  type: TYPE_NORMAL
- en: Classic/network-based IPS solutions – Snort and Suricata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed previously, the traditional IPS story started in the 1990s when
    *Martin Roesch* wrote Snort. Snort turned into a commercial offering when Sourcefire
    was created, but even today, after Cisco acquired Sourcefire, Snort still has
    an open source version that can be installed on any Linux platform.
  prefs: []
  type: TYPE_NORMAL
- en: Because Snort was so prevalent, it was widely used both directly, within Sourcefire
    products, as well as being licensed in many (many) **next-generation firewall**
    (**NGFW**) products. This last situation changed after the Cisco acquisition;
    no commercial firewall wanted to have an IPS from a competing company on their
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Marketing aside, the "traditional" version of Snort (2.x) had several shortfalls:'
  prefs: []
  type: TYPE_NORMAL
- en: It was completely text-based, there was no GUI. However, there are several web
    frontend projects available for Snort.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The messages were often cryptic – often, you'd need to be a security expert
    to fully understand Snort messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It was single-threaded. This had a huge impact as network bandwidth uplinks
    went from hundreds of Mbps to Gbps, then to 10, 40, and 100 Gbps. Snort simply
    could not keep up at those volumes, no matter what combination of CPU, memory,
    and disk was thrown at it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, the Snort approach and, in particular, the Snort signature ruleset
    has been invaluable, and almost all IPS solutions can use Snort signatures.
  prefs: []
  type: TYPE_NORMAL
- en: This combination of factors pushed the industry toward alternatives. In many
    cases, this has been Suricata, an IPS that was released in 2009 and has only improved
    since then. Suricata is attractive because from the start it was multi-threaded,
    so more CPU cores effectively turned into more usable CPU. This made it much more
    scalable than Snort. Suricata uses Snort rules directly with no modification,
    so those years of work in creating both the signatures and the industry expertise
    in manipulating them remains intact.
  prefs: []
  type: TYPE_NORMAL
- en: There are Suricata plugins and integrations for many other security products,
    including Splunk, Logstash, and Kibana/Elasticsearch. Suricata can be integrated
    directly into many popular firewalls, such as pfSense or Untangle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, many distributions bundle Suricata with an underlying Linux operating
    system, a reasonable web interface, and a database for a backend – you can install
    Suricata and have a workable system within a few hours if your hardware and network
    have been prepared.
  prefs: []
  type: TYPE_NORMAL
- en: The Snort team has since released version 3.0 of their IPS (January 2021); however,
    it still has no GUI (unless you buy the commercial version as part of a Cisco
    Firepower installation). Snort is still an excellent product and an industry favorite,
    but they're now having to make up ground against the Suricata solution.
  prefs: []
  type: TYPE_NORMAL
- en: Enough background and theory – let's build and use an actual IPS!
  prefs: []
  type: TYPE_NORMAL
- en: Suricata IPS example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we''ll use SELKS from Stamus Networks ([https://www.stamus-networks.com/selks](https://www.stamus-networks.com/selks)).
    The **SELKS** name reflects its major components: **Suricata, Elasticsearch, Logstash,
    Kibana, and Stamus** Scirius Community Edition. This is packaged on Debian Linux,
    so things should look familiar if you''ve been following along in this book, as
    Ubuntu is rooted in the Debian "parent" distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: SELKS has a **live** option and an **install** option. The **live** option runs
    the entire solution off the ISO image. This is handy for small labs or to quickly
    evaluate the tool, and you may choose to go this way in this chapter. In production,
    however, you'll want to work with an installed-on-real-disk (preferably on an
    SSD or an other fast storage option) image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation guide for SELKS is located here: [https://github.com/StamusNetworks/SELKS/wiki/First-time-setup](https://github.com/StamusNetworks/SELKS/wiki/First-time-setup).
    As this does change fairly frequently, we won''t do an actual installation in
    this chapter (if we did, it would be out of date within months).'
  prefs: []
  type: TYPE_NORMAL
- en: Having two NICs is a requirement for most IPS solutions. The first NIC is for
    the actual IPS function, which requires promiscuous mode and will do the packet
    captures – this adapter should not have an IP when you are done. The other NIC
    is used to manage the platform – normally, the web UI for the solution is on this
    NIC.
  prefs: []
  type: TYPE_NORMAL
- en: With Suricata running, make sure that it's in a position to capture packets,
    either with a SPAN port, a tap, or a hypervisor vSwitch that has `promiscuous
    mode` enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start using the system, it's best to define the various hosts and
    subnets that define your environment. This information is all in `/etc/suricata/suricata.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the key variables to set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_13_Table_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In many environments, these defaults can all be left as is, but as noted, defining
    the various server variables can help in optimizing rule processing. For instance,
    if you can narrow things down so that HTTP checks aren't done on domain controllers
    or SQL servers, this can help lower the CPU requirements of processing checks
    that aren't required.
  prefs: []
  type: TYPE_NORMAL
- en: MODBUS protocols, which are used in SCADA systems and commonly found in manufacturing
    or public utilities, are also something that are usually very tightly defined.
    Often, these servers and clients are segregated to their own subnet(s).
  prefs: []
  type: TYPE_NORMAL
- en: Also, defining the various DNS servers internal to the organization can help.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other options in this file that govern how Suricata and its related
    products operate, but to demonstrate the IPS (and even in many production environments),
    you won't need to modify them. I do invite you to review the file, though; it's
    well-commented so that you can see what each variable does.
  prefs: []
  type: TYPE_NORMAL
- en: 'After some period of normal activity – likely within minutes – you''ll start
    to see activity in EveBox, the web interface for the alerts in SELKS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8 – Basic alerts in Suricata (EveBox events dashboard)](img/B16336_13_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.8 – Basic alerts in Suricata (EveBox events dashboard)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at one of the **Fake Firefox Font Update** alerts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9 – Rule details (1) – basic information and geo-IP information](img/B16336_13_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.9 – Rule details (1) – basic information and geo-IP information
  prefs: []
  type: TYPE_NORMAL
- en: Of particular interest in this display are the source and destination IP – if
    this is outbound traffic, it might indicate an infected host. More importantly
    in our case however is the **signature ID** (usually shortened to **SID**), which
    uniquely identifies this attack signature. We'll get back to this value in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: Below that is the geo-IP information on the remote address. This is not always
    100% accurate, but if you are in a business where espionage (corporate or national)
    is of concern, this location information might be important. If the IP is local(ish),
    you might be collecting evidence for law enforcement, especially if you suspect
    that the attack is coming from an "insider."
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll down a bit; since this attack was done over HTTPS, we''ll see the TLS
    information that was involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10 – Rule details (2) – TLS and fingerprint information and payload
    displays](img/B16336_13_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.10 – Rule details (2) – TLS and fingerprint information and payload
    displays
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that the `self.events.data.microsoft.com`, and that the certificate
    was issued by a valid Microsoft Azure CA. These things in combination tell us
    that while attacks using fake font updates are a real issue, this signature is
    being triggered with false positives, over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just for interest, looking down one section further, we''ll see the **Payload**
    section. This displays the string values in the packet(s) on the left, and a hex
    representation of the packet on the right. Something of interest is the **PCAP**
    button, so let''s click that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.11 – Packet capture invoked from the event display](img/B16336_13_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.11 – Packet capture invoked from the event display
  prefs: []
  type: TYPE_NORMAL
- en: As expected, clicking the `server_name/SNI` section.
  prefs: []
  type: TYPE_NORMAL
- en: Back on the alert page, scrolling down even further, we'll see the JSON representation
    of the rule. Going back to the rule name, remember how it referenced the word
    `JA3`? `JA` signatures are hashes of the various values that are exchanged in
    the initial handshake packets of encrypted traffic. Using `JA` values, we can
    identify the source and destination applications and often also the server names
    (in this case, using the `JA3` signatures was pioneered by *John Althouse*, *Jeff
    Atkinson*, and *Josh Atkins* (hence the name JA3) from Salesforce. More information
    on this approach can be found at the end of this chapter. The HASSH framework
    performs a similar function for SSH traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the `JA3` section in the JSON rule display, we can see detailed
    information regarding the network event that triggered the IPS alert:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.12 – JSON details of the network event that triggered the IPS alert
    ](img/B16336_13_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.12 – JSON details of the network event that triggered the IPS alert
  prefs: []
  type: TYPE_NORMAL
- en: Note that this JSON display is a mix of "what we are looking for" and "what
    we saw." You'd have to look at the rule itself to see what is triggering the rule
    (though in this case, it's the JA3 hashes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''re done exploring this alert and have deemed it a false positive,
    we have two possible courses of action:'
  prefs: []
  type: TYPE_NORMAL
- en: We can disable this alert. Likely, you'll find yourself doing this a lot with
    a new IPS until things level out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can edit the alert, perhaps have it trigger as expected, but not for SNIs
    that end in `Microsoft.com`. Note that we said *end with*, not *contain*. It's
    common for attackers to look for definition mistakes – for instance, the `foo.microsoft.com.maliciousdomain.com`
    SNI would qualify as `contains microsofot.com`, whereas the actual `self.events.data.microsoft.com`
    will only qualify as *ends with*. If you remember our regular expression discussion
    in [*Chapter 11*](B16336_11_Final_NM_ePub.xhtml#_idTextAnchor192), *Packet Capture
    and Analysis in Linux*, ends with `Microsoft.com` would look like `*.microsoft.com$`
    (one or more characters, followed by `Microsoft.com`, immediately followed by
    the end of the string).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, we''ll disable the alert. From the command line, edit the `/etc/suricata/disable.conf`
    file and add the SID to this file. A comment is customary so that you can keep
    track of why various signatures were deleted, when, and by who:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To add a rule that is being ignored, you can simply add the SID to the `/etc/suricata/enable.conf`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, run `suricata_update` again to update the running configuration of
    the IPS. You''ll see that the `disable.conf` file has been processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The second choice for editing the SID so that it doesn't trigger on a specific
    SNI might make more sense, but you can't edit the SID directly; the next update
    will simply clobber your update. To edit an SID, make a copy of it so that it's
    an SID in the "custom" or "local" range, then edit that. Add that new SID to the
    `enable.conf` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our main EveBox display, open any event and go exploring. You can click
    on any linked value and get more information about it. For instance, if you suspect
    that an internal host has been compromised, you can click on that host''s IP in
    any display and get details about all the traffic to and from that host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.13 – EveBox display of all the events that were triggered by one
    target host](img/B16336_13_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.13 – EveBox display of all the events that were triggered by one target
    host
  prefs: []
  type: TYPE_NORMAL
- en: Note the search field at the top – you can manually input those as needed as
    you get more familiar with the interface. In this case, we can see a bunch of
    "nonsense" DNS requests (lines 4, 5, and 6 in the display, as well as lines 8,
    9, and 10). Nonsense queries like this often appear in attacks that use **fast
    flux DNS**, where the C2 server DNS names will change several times in a day.
    Often, the clients compute the DNS names based on the date and time or retrieve
    them periodically. Unfortunately, our friends in the advertising world use many
    of the same techniques as our malware friends do, so this is not as clear-cut
    as it used to be.
  prefs: []
  type: TYPE_NORMAL
- en: Changing displays (click on the top-right icon next to your user ID) lets you
    navigate to the **Hunting** display.
  prefs: []
  type: TYPE_NORMAL
- en: In this display, you'll see the same alerts but summarized rather than listed
    serially by timestamp. This lets you look for the most frequent alerts or look
    for the outliers – the least frequent alerts that might indicate more unusual
    situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at our Firefox font alerts once more – open that line for more
    details. In particular, you will see a timeline display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.14 – Hunting display, main dashboard](img/B16336_13_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.14 – Hunting display, main dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this gives us the actual rule that is being triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Essentially, this is the "outbound traffic that matches this JA3 hash." Looking
    this hash value up on [https://ja3er.com](https://ja3er.com), we will find that
    this is a basic Windows 10 TLS negotiation, reported from the following user agents:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Excel/16.0 (count: 375, last seen: 2021-02-26 07:26:44)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'WebexTeams (count: 38, last seen: 2021-06-30 16:17:14)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:40.0) Gecko/20100101 Firefox/40.1 (count:
    31, last seen: 2020-06-04 09:58:02)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This reenforces the fact that this signature is of limited value; we were well
    advised to simply disable it. As we discussed previously, you might decide to
    edit it as a different rule, but in this particular case, you'd be forever playing
    whack-a-mole trying to get the right combination of SNI strings or CAs to get
    the rule just right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another display that is well worth exploring is the **Management** display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.15 – Management view, all alerts](img/B16336_13_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.15 – Management view, all alerts
  prefs: []
  type: TYPE_NORMAL
- en: 'This shows the same data in yet another format. Clicking the same Firefox font
    alert (2028371), we get an even more comprehensive view of the activity behind
    this alert:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.16 – Management view of the example Firefox font alert](img/B16336_13_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.16 – Management view of the example Firefox font alert
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that in the left-hand column, we can now see selections for **Disable
    rule** and **Enable rule**. As the IPS interface is mostly in the UI, this is
    more likely to be your main rule management method, at least as far as disabling
    and enabling rules goes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.17 – Disabling a Suricata rule from the web UI](img/B16336_13_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.17 – Disabling a Suricata rule from the web UI
  prefs: []
  type: TYPE_NORMAL
- en: As noted previously, the IPS function is one area where your mileage may vary.
    If you are deploying on a home network, different doorbells, thermostats, or gaming
    platforms will dramatically influence your mix of traffic and the resultant things
    that the IPS will find. This is even more dramatic in a corporate environment.
  prefs: []
  type: TYPE_NORMAL
- en: The best advice is to learn the basics, some of which we've covered here, and
    explore what your IPS is telling you about what's going on over your network.
    You'll find a mix of signatures to delete or modify, messages that you want to
    leave in play but suppress from the display, and real security alerts of various
    priorities.
  prefs: []
  type: TYPE_NORMAL
- en: Something else that you'll see in this platform is that Suricata's severity
    levels might not match yours. The rule that we explored was a great example of
    this – Suricata flagged it as a high priority, but after some investigation, we
    classed it as a false positive and disabled it.
  prefs: []
  type: TYPE_NORMAL
- en: We've mentioned rules a few times. So, let's dive a bit deeper into how a rule
    is built, and then build one of our own from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing an IPS rule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve mentioned IPS signatures several times, in particular Snort rules –
    let''s take a look at how they are constructed. Let''s look at an example rule,
    which alerts us of a suspicious DNS request that contains the text `.cloud`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The rule is broken into several sections. Starting from the beginning of the
    rule, we have our **rule header**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_13_Table_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Flow** section is not shown – Suricata normally only detects flows for
    TCP data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is followed by the rule''s **Message** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_13_Table_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Detection** section outlines what the rule is looking for and what traffic
    will trigger the alert:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_13_Table_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **References** section normally contains URLs, CVE numbers, or vendor security
    advisories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_13_Table_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Signature ID** section contains the SID value and revision number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_13_Table_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Metadata** section includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_13_Table_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Many of these are optional, and in some cases, the section''s order can be
    changed. For a full explanation of Suricata rule formatting, the product documentation
    is a good starting point: [https://suricata.readthedocs.io/en/suricata-6.0.3/rules/intro.html](https://suricata.readthedocs.io/en/suricata-6.0.3/rules/intro.html).'
  prefs: []
  type: TYPE_NORMAL
- en: As Suricata rules are essentially the same as Snort rules, you might find the
    Snort documentation useful as well.
  prefs: []
  type: TYPE_NORMAL
- en: If you are adding custom rules for your organization, the SID range for local
    rules is `1000000`-`1999999`.
  prefs: []
  type: TYPE_NORMAL
- en: By convention, local rules are usually put in a file called `local.rules`, or
    at least in rules files that have a name reflecting this custom status. Also,
    the rule message usually starts with the word `LOCAL`, your organization name,
    or some other indicator that makes it obvious that this is an internally developed
    rule. Populating the rule metadata is also considered good practice – adding the
    rule's author, date, and version number can be very helpful.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's create a set of rules that detects telnet traffic – both
    inbound and outbound. You might have added this rule to address a cohort of administrators
    in an organization that persist in deploying sensitive systems that have telnet
    enabled. Using telnet to log in, then run or administer an application, is a dangerous
    approach, as all of the credentials and all of the application data are transmitted
    in clear text over the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break this into two rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that the protocol is TCP and that the destination ports include `23/tcp`,
    as well as many of the other common ports people might put telnet in to "hide"
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The text of these rules gets put into `/etc/suricata/rules/local.rules` (or
    wherever you want to store your local rules).
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `/etc/suricata/suricata.yaml` to reflect this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, to recompile the rule list, run `sudo selks-update`. You may also need
    to run `sudo suricata-update –local /etc/suricata/rules/local.rules`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have updated this, you can verify that your rules are in place by
    listing the final ruleset, filtering for your SIDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to reload the ruleset, do one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reload Suricata by executing `sudo kill -USR2 $(pidof suricata)`. This is not
    recommended as it reloads the entire application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reload the rules with `suricatasc -c reload-rules`. This is a blocking reload;
    Suricata is still offline for the duration of the reload. This is not recommended
    if your IPS is in line with traffic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reload the rules with `suricatasc -c ruleset-reload-nonblocking`. This reloads
    the ruleset without blocking traffic, which is "friendly" to an in-line deployment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What does this alert look like when it is triggered? The alert for this rule
    in EveBox will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.18 – Alerts generated by the triggered custom IPS rule](img/B16336_13_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.18 – Alerts generated by the triggered custom IPS rule
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that one of the alerts is from an internal to an internal host,
    whereas the other is outbound to the internet. The first rule is triggered twice
    – look back at the rule definition; can you see why? This shows that it makes
    good sense to trigger any custom rules and optimize them so that each condition
    triggers an alert or block only once, and that they trigger on all conditions
    and variations that you can think of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s expand the first one (note the SID):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.19 – Event details for alert 1](img/B16336_13_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.19 – Event details for alert 1
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s expand the second – note that this is the same event, but it triggered
    a second time with a different SID:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.20 – Event details for alert 2](img/B16336_13_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.20 – Event details for alert 2
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, expand the last one (again, note the SID):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.21 – Event details for alert 3](img/B16336_13_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.21 – Event details for alert 3
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have the full packet capture for both – be very careful with these,
    as you will see valid credentials if you browse those PCAP files.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've looked at how a network IPS works, let's see what we can find
    by passively monitoring packets as they pass through the network.
  prefs: []
  type: TYPE_NORMAL
- en: Passive traffic monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to add to an IPS solution is to use a **Passive Vulnerability Scanner**
    (**PVS**). Rather than looking for attack traffic, PVS solutions collect packets
    and look for traffic or handshake data (such as JA3, SSH fingerprints, or anything
    it can collect in clear text) that might help identify operating systems or applications
    in play. You can use this method to identify problem applications that might not
    appear using other methods, or even hosts that were missed using other inventory
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, a PVS solution might identify out-of-date browsers or SSH clients.
    SSH clients on Windows are often out of date, as many of the more prevalent clients
    (such as PuTTY) don't have auto-update capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: PVS solutions are also great tools for finding hosts that might not have been
    inventoried. If it reaches out to the internet or even to other internal hosts,
    PVS tools can collect a surprising amount of data just from "stray" packets.
  prefs: []
  type: TYPE_NORMAL
- en: P0F is one of the more commonly seen open source PVS solutions. Commercially,
    Teneble's PVS server is commonly deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Passive monitoring with P0F – example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run P0f, put the Ethernet interface that you will be using into `promiscuous
    mode`. This means that the interface will read and process all packets, not just
    the ones destined for the host we''re working on. This is a common mode that is
    set automatically by most utilities that depend on packet capture, but P0F is
    still "old school" enough to need it to be set manually. Then, run the tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Of more use, you can redirect the `p0f` output to a file, then process the
    file''s contents. Note that we need root rights to capture packets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can collect the data that was collected on various hosts, using `grep`
    to filter for only those where `p0f` was able to identify the operating system.
    Note that since we created `pvsout.txt` as root, we''ll need root rights to read
    that file as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can parse this for a quick inventory listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that we had to use `sed` to remove the source port for each of the hosts
    so that the `uniq` command would work. Also, note that host `192.168.122.181`
    registers as three different Windows versions – that host bears some looking into!
  prefs: []
  type: TYPE_NORMAL
- en: 'Of more concern are the hosts at `192.168.122.113`, `129`, and `160`, which
    appear to be running older Linux kernels. It turns out that the following is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '`192.168.122.160` is a doorbell camera – auto-update is enabled for it, so
    it''s an older kernel but is as new as the vendor can make it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`192.168.122.129` is a carrier''s PVR/TV controller. This is the same situation
    as the previous one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`192.168.122.113` is an Ubuntu 20.04.2 host, so this one is a false positive.
    After connecting to that host, `uname –r` tells us that this is running kernel
    version 5.8.0.55.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've now got basic IPS services and PVSes in place, so let's expand on this
    and add some metadata to make our IPS information more relevant. What do I mean
    by "metadata"? Read on and we'll describe that data, and how Zeek can be used
    to collect it.
  prefs: []
  type: TYPE_NORMAL
- en: Zeek example – collecting network metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Zeek** (formerly known as Bro) isn''t really an IPS, but it makes a nice
    adjunct server for your IPS, for your logging platform, as well as for network
    management. You''ll see why that is as we move forward in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, there are a couple of installation options:'
  prefs: []
  type: TYPE_NORMAL
- en: You can install on an existing Linux host ([https://docs.zeek.org/en/master/install.html](https://docs.zeek.org/en/master/install.html)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can install the Security Onion distribution and choose Zeek during the installation
    ([https://download.securityonion.net](https://download.securityonion.net), [https://docs.securityonion.net/en/2.3/installation.html](https://docs.securityonion.net/en/2.3/installation.html)).
    Security Onion might be attractive because it installs several other components
    along with Zeek, which might make for a more useful toolset for you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Security Onion install, by default, installs Suricata with Zeek, so in a
    smaller environment, this can make some good sense – also, it's handy to have
    the information from these two apps on the same host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember we said that Zeek was a "metadata" collector? Once we have Security
    Onion running for a few minutes on a live network, poke around and you''ll see
    what I mean. To plant some "interesting" data, I fired up a browser and navigated
    to [https://badssl.com](https://badssl.com). From there, I tested various SSL
    error conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.22 – Testing SSL error detection using BADSSL.com](img/B16336_13_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.22 – Testing SSL error detection using BADSSL.com
  prefs: []
  type: TYPE_NORMAL
- en: 'What shows up in Bro? From the Security Onion main interface, choose Kibana,
    then pick the SSL protocol in the `443`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.23 – Displaying only SSL data](img/B16336_13_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.23 – Displaying only SSL data
  prefs: []
  type: TYPE_NORMAL
- en: Note that each page can be paged through independently, and that the raw logs
    are immediately below these panes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll over to that `443` in the `443` and you''ll see some options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.24 – Filtering out port 443/tcp](img/B16336_13_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.24 – Filtering out port 443/tcp
  prefs: []
  type: TYPE_NORMAL
- en: 'You can click **+** to filter just for that value, or **-** to remove this
    value from the report. Let''s remove it, then scroll down to the log pane. Expand
    any of the events in the log by clicking the **>** icon to get pages and pages
    of details about that particular session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.25 – Expanding an event to show full metadata](img/B16336_13_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.25 – Expanding an event to show full metadata
  prefs: []
  type: TYPE_NORMAL
- en: 'Scrolling down, you''ll see geolocation data (a good estimate of where exactly
    on the planet this IP exists), as well as the SSL certificate details for this
    particular session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.26 – Scrolling down, showing just SSL/TLS certificate metadata](img/B16336_13_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.26 – Scrolling down, showing just SSL/TLS certificate metadata
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the screen, click the `ssl` to see what we have there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.27 – SSL dashboards](img/B16336_13_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.27 – SSL dashboards
  prefs: []
  type: TYPE_NORMAL
- en: 'Pick **Security Onion – SSL**; we''ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.28 – Security Onion – SSL dashboard](img/B16336_13_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.28 – Security Onion – SSL dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that in the middle of the page, we''ll see actual server names. These
    are mostly all harvested from the SSL certificates involved in each interaction
    (though reverse DNS is used in some other dashboards). Let''s look at the **Validation
    Status** pane – note that we have a few status descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_13_Table_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on **certificate has expired** and choose **+** to drill down to just
    that data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.29 – Narrowing the search – expired SSL certificates only](img/B16336_13_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.29 – Narrowing the search – expired SSL certificates only
  prefs: []
  type: TYPE_NORMAL
- en: This gets us the exact transaction that was involved, along with the IP of the
    person involved!
  prefs: []
  type: TYPE_NORMAL
- en: Note that as we navigate and drill down, you'll see the **search term** field
    displayed on many of the screens, which shows the raw query against Elasticsearch.
    You can always add them manually, but using the UI can be a big help on this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the **Kibana** | **Discover Analytics** page. Right off the
    bat, we will see all kinds of new information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.30 – Discover view of the traffic](img/B16336_13_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.30 – Discover view of the traffic
  prefs: []
  type: TYPE_NORMAL
- en: In the `ssl` to narrow down the search terms. You'll see it give you matching
    searches as you type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, click **ssl.version** and **ssl.certificate.issuer**, then press **Update**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.31 – Showing selected SSL/TLS information](img/B16336_13_031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.31 – Showing selected SSL/TLS information
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the field area, type `source` and add **source.ip** to our report:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.32 – Building our query by adding more information](img/B16336_13_032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.32 – Building our query by adding more information
  prefs: []
  type: TYPE_NORMAL
- en: You can quickly see how we can narrow our display down to just what we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can filter by geography. Build a listing that shows the TLS
    version, source IP, destination IP, country, and city:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.34 – Removing "US" destinations](img/B16336_13_033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.33 – Adding geo-lookup information to the query
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, highlight a **US** entry in the **Country** column and choose **-** to
    filter out US destinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_13_034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.34 – Removing "US" destinations
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us a more interesting listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.35 – Final query](img/B16336_13_035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.35 – Final query
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down and noodling with the data can quickly and easily get you displays
    such as "TLSv1.0 or lower with a destination in China, Russia, or North Korea."
  prefs: []
  type: TYPE_NORMAL
- en: 'Even filtering out TLS versions can quickly get you to a shortlist of "unknown"
    TLS versions. Note that at any time, we can expand any of the lines to get the
    full metadata for that session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.36 – Only TLS versions of "unknown"](img/B16336_13_036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.36 – Only TLS versions of "unknown"
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the destination IP in the first line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.37 – Details of a suspicious IP](img/B16336_13_037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.37 – Details of a suspicious IP
  prefs: []
  type: TYPE_NORMAL
- en: 'Who else has connected to that problem host using SSL? In a real security incident,
    you can use this approach to answer important questions such as "we know that
    client X was affected; who else had similar traffic so we can see whether this
    issue is more widespread?":'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.38 – Other internal hosts with the same suspicious traffic](img/B16336_13_038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.38 – Other internal hosts with the same suspicious traffic
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see how metadata such as SSL versions, issuers of SSL certificates,
    and the country codes of destination IPs can quickly get you some interesting
    information. Think how much deeper you can dig with thousands of search terms
    that are available!
  prefs: []
  type: TYPE_NORMAL
- en: If you are exploring traffic to solve a problem or are working through a security
    incident, you can see how collecting traffic metadata can be very effective in
    getting useful information – not only about the identified hosts and sessions
    involved but in finding similar hosts and sessions that might also be affected!
  prefs: []
  type: TYPE_NORMAL
- en: This is just the tip of the iceberg. Not only can you dig deeper into SSL/TLS
    traffic, but you can also explore hundreds of other protocols!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed several methods of detecting and preventing intrusion
    events. We started by discussing where in our architecture these various technologies
    would best fit, then went into specific solutions. We discussed classic network-based
    IPS solutions, namely Snort and Suricata. We also briefly touched on web-specific
    IPSes – in particular, WAF and RASP solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In our examples, we went through how an IPS (Suricata) might be used to find
    and prevent security issues, to the point of creating a custom rule to detect
    or prevent telnet sessions. Passively collecting traffic for hardware and software
    inventories, as well as security issues, was illustrated using P0f. Finally, we
    used Zeek to take our collected data, and both collect and compute metadata to
    make that data more meaningful. Zeek in particular is extremely useful for drilling
    into network traffic to find those unusual situations that might indicate a security
    event or an operational problem.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll expand on this approach further, moving from a more
    passive collection model to using "honeypot" approaches, using network-based "deception"
    to find malicious hosts with extremely high fidelity.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  prefs: []
  type: TYPE_NORMAL
- en: If I suspected a data exfiltration event was occurring using an "unknown" TLS
    version to a specific country, which tool should I use to find what internal hosts
    were affected?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you know that you have a large contingent of Windows client machines using
    the PuTTY SSH client, how could you inventory those without searching each machine's
    local storage?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would you decide to place an IPS on the inside network or the actual firewall?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more on the topics covered in this chapter, you can refer to the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'SELKS installation: [https://github.com/StamusNetworks/SELKS/wiki/First-time-setup](https://github.com/StamusNetworks/SELKS/wiki/First-time-setup)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Security Onion installation: [https://docs.securityonion.net/en/2.3/installation.html](https://docs.securityonion.net/en/2.3/installation.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suricata installation (6.0.0): [https://suricata.readthedocs.io/en/suricata-6.0.0/install.html](https://suricata.readthedocs.io/en/suricata-6.0.0/install.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suricata documentation: [https://suricata.readthedocs.io](https://suricata.readthedocs.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Snort documentation: [https://www.snort.org/documents](https://www.snort.org/documents)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Snort rules: [https://snort.org/downloads/#rule-downloads](https://snort.org/downloads/#rule-downloads)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JA3 fingerprinting: [https://ja3er.com](https://ja3er.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://engineering.salesforce.com/tls-fingerprinting-with-ja3-and-ja3s-247362855967](https://engineering.salesforce.com/tls-fingerprinting-with-ja3-and-ja3s-247362855967)'
  prefs: []
  type: TYPE_NORMAL
- en: 'HASSH: [https://github.com/salesforce/hassh](https://github.com/salesforce/hassh)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenRASP: [https://github.com/baidu/openrasp](https://github.com/baidu/openrasp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ModSecurity: [https://github.com/SpiderLabs/ModSecurity/wiki/Reference-Manual-(v2.x)modsemodse](https://github.com/SpiderLabs/ModSecurity/wiki/Reference-Manual-(v2.x)modsemodse)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'WAF services on load balancer: [https://www.haproxy.com/haproxy-web-application-firewall-trial/](https://www.haproxy.com/haproxy-web-application-firewall-trial/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Zeek documentation: [https://docs.zeek.org/en/master/](https://docs.zeek.org/en/master/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Security Onion: [https://securityonionsolutions.com/software](https://securityonionsolutions.com/software)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
