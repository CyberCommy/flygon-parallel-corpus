- en: Chapter 2. Configuring Persistence with MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will show you how to configure the persistence layer of
    your app, which is responsible for the provision of the central data storage and
    retrieval services. For this, we will use MongoDB, the widely popular NoSQL database,
    and its associated driver and interface for Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring documents, collections, and databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to MongoDB using a product order database as an example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating relations between documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying data and displaying results in the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning outcomes of MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you will have a solid understanding of the basics
    of how MongoDB stores data. You will also learn how to run queries against a MongoDB
    instance in order to store, manipulate, and retrieve data on it. You will also
    understand how to use the Node.js MongoDB driver for the same ends in order to
    manipulate your data directly from Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will have a healthy dose of refreshment of memory as regards the
    internal workings of Node.js in order to help you understand how it interconnects
    with MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with a short but informative tour of MongoDB, which will give you
    the essential knowledge that you need in order to effectively work with it.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's get a good grasp of how data is organized in a MongoDB instance.
    This will give us the foundation that is required to understand how storage and
    retrieval operations work later on.
  prefs: []
  type: TYPE_NORMAL
- en: Documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MongoDB is a NoSQL **Database Management System** (**DBMS**). This means that
    it eschews the traditional table-based data storage model used by SQL-oriented
    systems such as MySQL, Oracle, and Microsoft SQL Server. Instead, it stores data
    as documents, which are data structures that are almost identical to standard
    JSON objects. For example, a MongoDB document can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This document represents a pharmacy, with some basic information such as the
    name, address, and national license number. If you are familiar with JSON, you
    will feel right at home; this is the standard object notation. However, note an
    unusual datatype in here—the `ObjectId`. This is a built-in datatype in MongoDB,
    and it is the default method that is used to uniquely identify a single document.
    Every single document you store in a MongoDB database is guaranteed to have a
    unique `_id` member with respect to that database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are familiar with SQL, you may be tempted to think about it as a column
    ID. Don't! An `_id` uniquely identifies a document in the entire database, whereas
    an SQL column ID only uniquely identifies a row in a table.
  prefs: []
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though you can uniquely identify a document by its `_id`, life would be
    a lot simpler if we could somehow organize documents according to some common
    characteristics. This is where the concept of a collection comes into play. Simply
    put, a collection is nothing more than a group of documents that exist in a common
    folder. For example, we can have a collection named `Pharmacies`, which will store
    documents like our preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: If you are used to SQL, you may instinctively feel that the documents in the
    same collection must somehow have the same structure, just like rows in an SQL
    table do. Surprisingly, this is not even remotely true. Collections only group
    documents; they do not impose any structural demands on them (apart from the need
    to have an `_id`, but this holds for all the documents and has nothing to do with
    a particular collection). This means that in the collection that we store our
    pharmacy-related data in, we may also store documents that describe fruit, people,
    cars, or movies. Whether we should do so is left entirely up to the programmer.
    This great freedom of structure is one of the most powerful aspects of MongoDB
    and a key factor that sets it apart from the more traditional DBMS.
  prefs: []
  type: TYPE_NORMAL
- en: Databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now know that MongoDB stores data as documents in collections. The last storage
    concept that we need to mention is the database itself. Simply put, a database
    in MongoDB is a top-level organizational structure, which holds a group of collections
    along with information about users who may access the database, security settings,
    optimizations, and other configuration options. A single MongoDB instance can
    manage as many databases as server resources will allow.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is easy to be misled into thinking that MongoDB itself is the database. Rather,
    MongoDB is a DBMS, which can manage an arbitrary number of databases.
  prefs: []
  type: TYPE_NORMAL
- en: An example – a product order database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's put what we have learned so far into practice and construct a simple MongoDB
    database that contains data about products, customers, and the orders that the
    customers have made for specific products. If you are accustomed to other DBMS
    such as MySQL, you may be surprised to see how simple and intuitive the process
    is.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to be able to interact with a MongoDB instance, we first need to be
    sure that our server is running it. Then, we can access it through the Mongo shell
    application. In [Chapter 1](ch01.html "Chapter 1. Setting Up Your Workspace"),
    *Setting Up Your Workspace*, we covered in some detail how to install and get
    MongoDB running on your specific operating system. You should go through these
    steps if you have not done so already. Once you have verified that MongoDB is
    running, open the MongoDB shell for your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Linux and Mac OS X
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start a console and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start your command prompt and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You will see a prompt starting with the `>` character. From here, we can issue
    commands to MongoDB interactively and read the resulting output.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by defining the database that we are going to work with. In your
    shell, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will ask MongoDB to switch to a new database, called `OrderBase`, that
    we wish to run the commands against. The response will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: But wait, how can we switch to a database that does not exist yet? MongoDB flexibility
    to the rescue! When you tell MongoDB to use a database, it will create that database
    for you automatically before switching to it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have created a database, let''s populate it with some collections
    by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following to create a collection for `Products`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'MongoDB will respond with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code indicates that the command was executed successfully. Note
    that the response is returned to us in the JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s pause for a minute and break down the preceding command so that we understand
    what we just did:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `db` is a JavaScript object that represents the currently selected database.
    In our case, it is `OrderBase`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `createCollection('Products')` function is one of the many member methods
    of `db`. Needless to say, it creates a new collection and adds it to `db`. Its
    parameter, a string, is the name of the new collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, working with MongoDB is actually a matter of issuing commands
    in pure JavaScript. Not only that, but the data itself and the responses to the
    commands are encoded as JSON! It's obvious right away why MongoDB makes a perfect,
    seamless fit for JavaScript projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create two other collections as well to store our orders while we are
    at it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You will get the same **ok** responses as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add some products to our `Product` collection. In our case, let''s
    say that a product has the following defining characteristics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A name of the string type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A price of the float type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can represent this as a simple JSON object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Inserting name and price into the `Products` collection is equally simple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The response will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding result contains a `WriteResult` object, giving details about the
    outcome of a write operation against the MongoDB instance. This particular `WriteResult`
    instance tells us that the write was successful (as no error was returned), and
    that we inserted a total of one new document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, let''s take a closer look at the command that we just issued:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `db` is still the database that we are operating on, which is `OrderBase`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Products` is our products collection that belongs to `db`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `insert()`method belongs to the products collection (note that even collections
    are represented as plain JavaScript objects with properties and methods). It takes
    a JSON object, such as the one that we defined in the preceding code, and inserts
    it into the collection as a new document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that one of our collections actually contains a document, we can ask MongoDB
    to tell us what is in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Issue the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `find()`method tells MongoDB to look up in the documents from the associated
    collection. If you pass no parameters to it (an empty find), it will return all
    the documents in the collection. Fortunately for us, we do not have enough documents
    (yet) to cause too much screen-scrolling from doing so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is the same apple that we inserted earlier...or is it? Note that MongoDB
    created an `ObjectId` instance for it and automatically added it to the objects
    members. This will always be done (unless you specify a manual `_id`), since all
    the documents in a MongoDB database are required to have their own unique `_id`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are running this example on your own machine, you will quickly note that
    the `_id` values for your objects will differ from the ones seen here since the
    IDs are randomly generated at the time of insertion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and insert two more products. However, rather than executing
    one `insert` statement for each of them, we can instead perform a bulk insertion
    this time by passing all the objects that we want to insert in a JSON array, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The response will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This response, a `BulkWriteResult` method, is clearly a lot more complex than
    an ordinary `WriteResult`. We do not need to concern ourselves with what its properties
    mean just yet. It is enough that we can read from it that two documents were written
    to the database (`"nInserted" : 2`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s issue another `find()` method to make sure that our database contains
    what we expect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s wrap up by adding some customers as well. We will add our orders
    a bit later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, verify that we now have customers to work with by executing the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The response will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Creating relations between documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now know how to create documents in the collections of a database. However,
    in real life, it is usually never enough to simply have standalone documents.
    We will also want to establish some kind of relations between the documents.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in our database, we store information about customers and products,
    but we also want to store information about orders, which essentially are bills
    of sale stating that customer *X* has ordered product *Y*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that *Jane* wants to order an *Pear*. To achieve this, we could
    let our orders look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: However, the disadvantages of this become clear immediately. It leads to massive
    data bloating, since the same customer or product can occur in several orders.
    Hence, its data will need to be repeated in each of the orders. It also makes
    maintenance a nightmare. If we want to update, say, the price of a product, we
    need to comb through the database for every single instance where that product
    appears and make the change.
  prefs: []
  type: TYPE_NORMAL
- en: A much better approach, as recommended by the MongoDB developers, is to use
    manual references. In this approach, we only store the `_id` of the document that
    we wish to refer to rather than the full document.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are alternative methods built into MongoDB, but generally, they deal with
    corner cases and are not optimal for general use. Throughout this book, we will
    only use the method described here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then let the application accessing the database retrieve information about
    the other document(s), which are referred to as needed. Going back to our order
    example, this means that the final order document will instead look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that we appended `Id` to the property names in the preceding code. This
    is a normal convention when dealing with references to other documents, and it
    is highly recommended that you follow it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have come to expect from MongoDB by now, inserting this new document
    is no harder than the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then run `db.Orders.find()`to assure ourselves that everything went
    as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that even though our order serves no other purpose but
    to tie two other documents together, it still has its own unique ID.
  prefs: []
  type: TYPE_NORMAL
- en: That's it! We have now constructed a simple database for the storage of information
    about customers, products, and orders. Next, we will learn how to query it in
    order to retrieve data for it.
  prefs: []
  type: TYPE_NORMAL
- en: Querying MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now familiar with the overall structure of data storage in MongoDB as
    well as how to insert and perform some rudimentary retrieval using the `find()`method.
    Here, we will look at the more advanced usage of `find()`in order to do some more
    fine-grained data retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: Searching by ID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most common operations on a MongoDB instance is lookups based on
    ID. As you may recall, every document in a database has a unique `_id` field,
    and MongoDB makes it easy to find documents using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this out! Start your Mongo shell and open the `OrderBase` database
    again. If you closed it after the last example, you can reopen the database by
    issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the database has been selected, let''s say that we want to look up a given
    product by ID. We select an ID from the earlier example at random and see what
    we end up with. Remember that the ID will be different on your own machine. So,
    you will need to select the one that is associated with your own objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The response that we will get for our example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Sure looks like our pear! Now, let''s backtrack a bit and see how the lookup
    works. Note that we essentially did the same thing as we did when we wanted to
    see all the available `Products`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we qualified what we want to find this time by passing a parameter
    to `find()`. As we have grown accustomed to this process by now, the parameter,
    like most things in MongoDB, is just in JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: What we do through this parameter is tell MongoDB that we want to find all the
    documents in the `Products` collection whose `_id` property is equal to the corresponding
    value in our JSON parameter, which is `ObjectId("54f8f6b8598e782be72d6295")`in
    this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `find()` method can return several results. When searching for
    an ID, this makes little sense, since only one ID can belong to any given document
    and as such, there can be at the most one result. To accommodate situations like
    this, MongoDB provides another method for collections—`findOne()`. It works like
    find(), with the sole exception being that it returns at most one result, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Searching by property value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen how easy it is to find documents by ID, and it should come as
    no surprise that searching by general property values is equally simple. For example,
    let''s say that we want to find all the products with the name `Orange`. We can
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'MongoDB will return the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, several documents in a collection will have the same value for
    the property that we are searching for. In that case, MongoDB will return all
    the matching ones. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return all the products with a price of `3.0`. In our case, it will
    return the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Advanced queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we have covered here barely scratches the surface of everything that you
    can possibly do with `find()`, but it is all that we need to know to be able to
    configure a basic persistence layer. Throughout the remainder of this book, we
    will incrementally introduce more advanced queries as the need arises.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting MongoDB and Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a solid understanding of the most basic concepts of how MongoDB
    works, and it is high time we put them to good work by integrating MongoDB with
    Node.js. In this section, we will cover this process step-by-step, and see how
    we can interact with the MongoDB databases directly from within a running Node.js
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a basic project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start, please make sure that you have Node.js and **Node Package Manager**
    (**NPM**) installed on your system. Refer to [Chapter 1](ch01.html "Chapter 1. Setting
    Up Your Workspace"), *Setting Up Your Workspace*, for the steps for your particular
    operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are set, start off by creating a basic project to experiment a bit
    with the MongoDB instance. Create a folder somewhere and call it MongoNode. Next,
    open a terminal (OS X/Linux) or the command prompt (Windows), navigate to this
    folder, and issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This will launch an interactive wizard for the bootstrapping of a basic Node.js
    application. In the following code, we provide some standard answers to the questions
    that the wizard will ask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the bootstrapping finishes, create a new file named `index.js`. Open it
    in your favorite text editor and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and then open a terminal. Navigate into the folder that we just
    created and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following familiar output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hello World!**'
  prefs: []
  type: TYPE_NORMAL
- en: We are now assured that Node.js works as expected. So, let's go ahead and see
    how we can get in touch with the database that we constructed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s set up the bare metal to interface with a MongoDB instance. The
    first thing that we will need to do is install the official MongoDB driver for
    Node.js. Inside your project folder, issue the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This will make `npm` carry out the complete installation procedure. Once this
    is done, we will have all the basic functionalities that we need to interact with
    the MongoDB instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the install finishes, create a new file named `database.js`, open it
    in your text editor, and insert the following. Don''t worry if it is quite a lot
    of code as compared to what we have seen so far; I added quite a lot of commentary
    to explain what is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s import the database module in the `index.js` file. Remove everything
    from this file and insert the following in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This will allow us to use our database interface like a regular Node.js module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s give it a run and make sure that everything works. Insert the
    following line in the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command should immediately seem familiar to you; it is the same
    as when we ran the following command in our earlier example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply wrapped the parameters in logic so that it can be run in the
    Node.js instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the Node.js instance, issue the following command in your terminal again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You should receive something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Successfully connected to MongoDB instance!**'
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB returned the following documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That's it! You just wrote your first Node.js app by making use of MongoDB! It
    is very simple. Note that as we go ahead, we will structure our code a bit differently,
    but now, you have the basic know-how that is needed to make it work. Next, we
    will study some advanced topics and look at how we can use Node.js and MongoDB
    in order to construct a full-fledged API.
  prefs: []
  type: TYPE_NORMAL
- en: With this chapter, we provided you with the basic knowledge that is needed to
    start building your very own database for your Ionic mobile application, which
    is one of the first stepping stones in building your very own backend for your
    cross-platform mobile application.
  prefs: []
  type: TYPE_NORMAL
- en: As we move further along, you will realize that the essentials that we learned
    through this chapter will provide us with the necessary knowledge that is required
    to start building our own API, which will be done in the next chapter.
  prefs: []
  type: TYPE_NORMAL
