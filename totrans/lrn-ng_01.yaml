- en: Creating Our First Component in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to Angular development, there are some things that are good to
    know and some things that we need to know to embark on our great journey. One
    of the things that is good to know is **semantic versioning**. This is good to
    know because it is the way the Angular team has chosen to deal with changes. This
    will hopefully make it easier to find the right solutions to future app development
    challenges when you go to [https://angular.io/](https://angular.io/) or Stack
    Overflow and other sites to search for solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Another important, but sometimes painful, topic is that of project setup. It
    is a necessary evil that needs to be done in the beginning of a project, but getting
    this right early on can reduce a lot of friction as your application grows with
    you. Therefore, a large part of this chapter is dedicated to demystifying and
    enabling you as a developer to save you from future frustrations and migraines.
  prefs: []
  type: TYPE_NORMAL
- en: We will also be able to create our first application at the end of this chapter
    and get a feel for the anatomy of an Angular application. To sum up, here are
    the main themes that we will explore in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about semantic versioning, why it matters, and Angular's take on it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover how we set up our project using Angular CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create our first application and begin to understand the core concepts in Angular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's just Angular – introducing semantic versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using semantic versioning is about managing expectations. It's about managing
    how the user of your application, or library, will react when a change happens
    to it. Changes will happen for various reasons, either to fix something broken
    in the code or add/alter/remove a feature. The way authors of frameworks or libraries
    use to convey what impact a certain change has is by incrementing the version
    number of the software.
  prefs: []
  type: TYPE_NORMAL
- en: A production-ready software usually has version 1.0 or 1.0.0 if you want to
    be more specific.
  prefs: []
  type: TYPE_NORMAL
- en: There are three different levels of change that can happen when updating your
    software. Either you patch it and effectively correct something. Or you make a
    minor change, which essentially means you add functionality. Or lastly you make
    a major change, which might completely change how your software works. Let's describe
    these changes in more detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Patch change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A patch change means we increment the right most digit by one. Changing the
    said software from 1.0.0 to 1.0.1 is a small change, usually a bug fix. As a user
    of that software you don't really have to worry; if anything, you should be happy
    that something is suddenly working better. The point is, you can safely start
    using 1.0.1.
  prefs: []
  type: TYPE_NORMAL
- en: Minor change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This means the software is increased from 1.0.0 to 1.1.0\. We are dealing with
    a more severe change as we increase the middle digit by one. This number should
    be increased when functionality is added to the software and it should still be
    backwards compatible. Also in this case it should be safe adapting the 1.1.0 version
    of the software.
  prefs: []
  type: TYPE_NORMAL
- en: Major change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this stage, the version number increases from 1.0.0 to 2.0.0\. Now this is
    where you need to look out. At this stage, things might have changed so much that
    constructs have been renamed or removed. It might not be compatible to earlier
    versions. I'm saying *it might* because a lot of software authors still ensure
    that there is a decent backwards compatibility, but the main point here is that
    there is no warranty, no contract, guaranteeing that it will still work.
  prefs: []
  type: TYPE_NORMAL
- en: What about Angular?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first version of Angular was known by most people as Angular 1; it later
    became known as AngularJS. It did not use semantic versioning. Most people actually
    still refer to it as Angular 1.
  prefs: []
  type: TYPE_NORMAL
- en: Then Angular came along and in 2016 it reached production readiness. Angular decided
    to adopt semantic versioning and this caused a bit of confusion in the developer
    community, especially when it was announced that there would be an Angular 4 and
    5, and so on. Google, as well as the Google Developer Experts, started to explain
    to people that it wanted people to call the latest version of the framework Angular
    - just Angular. You can always argue on the wisdom of that decision, but the fact
    remains, the new Angular is using semantic versioning. This means Angular is the
    same platform as Angular 4, as well as Angular 11, and so on, if that ever comes
    out. Adopting semantic versioning means that you as a user of Angular can rely
    on things working the same way until Google decides to increase the major version.
    Even then it's up to you if you want to remain on the latest major version or
    want to upgrade your existing apps.
  prefs: []
  type: TYPE_NORMAL
- en: A fresh start
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned before, Angular represents a full rewrite of the AngularJS framework,
    introducing a brand new application architecture completely built from scratch
    in TypeScript, a strict superset of JavaScript that adds optional static typing
    and support for interfaces and decorators.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, Angular applications are based on an architecture design that
    comprises of trees of web components interconnected by their own particular I/O
    interface. Each component takes advantage under the covers of a completely revamped
    dependency injection mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: To be fair, this is a simplistic description of what Angular really is. However,
    the simplest project ever made in Angular is cut out by these definition traits.
    We will focus on learning how to build interoperable components and manage dependency
    injection in the next chapters, before moving on to routing, web forms, and HTTP
    communication. This also explains why we will not make explicit references to
    AngularJS throughout the book. Obviously, it makes no sense to waste time and
    pages referring to something that will not provide any useful insights on the
    topic, besides the fact we assume that you might not know about Angular 1.x, so
    such knowledge does not have any value here.
  prefs: []
  type: TYPE_NORMAL
- en: Web components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Web components is a concept that encompasses four technologies designed to
    be used together to build feature elements with a higher level of visual expressivity
    and reusability, thereby leading to a more modular, consistent, and maintainable
    web. These four technologies are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Templates**: These are pieces of HTML that structure the content we aim'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: to render
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom elements**: These templates not only contain traditional HTML elements,
    but also the custom wrapper items that provide further presentation elements or
    API functionalities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shadow DOM**: This provides a sandbox to encapsulate the CSS layout rules
    and JavaScript behaviors of each custom element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTML imports**: HTML is no longer constrained to host HTML elements, but
    to other HTML documents as well'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In theory, an Angular component is indeed a custom element that contains a
    template to host the HTML structure of its layout, the latter being governed by
    a scoped CSS style sheet encapsulated within a shadow DOM container. Let''s try
    to rephrase this in plain English. Think of the range input control type in HTML5\.
    It is a handy way to give our users a convenient input control for entering a
    value ranging between two predefined boundaries. If you have not used it before,
    insert the following piece of markup in a blank HTML template and load it in your
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You will see a nice input control featuring a horizontal slider in your browser.
    Inspecting such control with the browser developer tools will unveil a concealed
    set of HTML tags that were not present at the time you edited your HTML template.
    There you have an example of shadow DOM in action, with an actual HTML template
    governed by its own encapsulated CSS with advanced dragging functionality. You
    will probably agree that it would be cool to do that yourself. Well, the good
    news is that Angular gives you the toolset required for delivering this very same
    functionality, so we can build our own custom elements (input controls, personalized
    tags, and self-contained widgets) featuring the inner HTML markup of our choice
    and our very own style sheet that does not affect (nor is impacted) by the CSS
    of the page hosting our component.
  prefs: []
  type: TYPE_NORMAL
- en: Why TypeScript over other syntaxes?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular applications can be coded in a wide variety of languages and syntaxes:
    ECMAScript 5, Dart, ECMAScript 6, TypeScript, or ECMAScript 7.'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript is a typed superset of ECMAScript 6 (also known as ECMAScript 2015)
    that compiles to plain JavaScript and is widely supported by modern OSes. It features
    a sound object-oriented design and supports annotations, decorators, and type
    checking.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why we picked (and obviously recommend) TypeScript as the syntax
    of choice for instructing how to develop Angular applications in this book is
    based on the fact that Angular itself is written in this language. Being proficient
    in TypeScript will give the developer an enormous advantage when it comes to understanding
    the guts of the framework.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, it is worth remarking that TypeScript's support for annotations
    and type introspection turns out to be paramount when it comes to managing dependency
    injection and type binding between components with a minimum code footprint, as
    we will see further down the line in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, you can carry out your Angular projects in plain ECMAScript 6 syntax
    if that is your preference. Even the examples provided in this book can be easily
    ported to ES6 by removing type annotations and interfaces, or replacing the way
    dependency injection is handled in TypeScript with the most verbose ES6 way.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of brevity, we will only cover examples written in TypeScript and
    actually recommend its use because of its higher expressivity thanks to type annotations,
    and its neat way of approaching dependency injection based on type introspection
    out of such type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our workspace with Angular CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different ways to get started, either using the Angular quickstart repository
    on the [https://angular.io/](https://angular.io/) site, or installing the scaffolding
    tool Angular CLI, or lastly, you could use Webpack to set up your project. It
    is worth pointing out that the standard way of creating a new Angular project
    is through using *Angular CLI* and scaffold your project. Systemjs, used by the
    quickstart repository, is something that used to be the default way of building
    Angular projects. It is now rapidly diminishing, but it is still a valid way of
    setting up an Angular project. The interested reader is therefore recommended
    to check the Appendix A, *SystemJS* for more information on it.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a frontend project today is more cumbersome than ever. We used to
    just include the necessary script with our JavaScript code and a `link` tag for
    our CSS and `img` tag for our assets and so on. Life used to be simple. Then frontend
    development became more ambitious and we started splitting up our code in modules,
    we started using preprocessors for both our code and CSS. All in all, our projects
    became more complicated and we started to rely on build systems such as Grunt,
    Gulp, Webpack, and so on. Most developers out there are not huge fans of configuration,
    they just want to focus on building apps. Modern browsers, however, do more to
    support the latest ECMAScript standard and some browsers have even started to
    support modules, which are resolved at runtime. This is far from being widely
    supported though. In the meantime, we still have to rely on tools for bundling
    and module support.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a project with leading frameworks such as React or Angular can be
    quite difficult. You need to know what libraries to import and ensure that files
    are processed in the correct order, which leads us into the topic of scaffolding
    tools. For AngularJS, it was quite popular to use Yeoman to scaffold up a new
    application quickly and get a lot of nice things preconfigured. React has a scaffolder
    tool called *create-react-app*, which you probably have saved and it saves countless
    hours for React developers. Scaffolder tools becomes almost a necessity as complexity
    grows, but also where every hour counts towards producing business value rather
    than fighting configuration problems.
  prefs: []
  type: TYPE_NORMAL
- en: The main motivation behind creating the Angular CLI tool was to help developers
    focus on app building and not so much on configuration. Essentially, with a simple
    command, you should be able to scaffold an application, add a new construct to
    it, run tests, or create a production grade bundle. Angular CLI supports all that.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What you need to get started is to have Git and Node.js installed. Node.js will
    also install something called NPM, a node package manager that you will use later
    to install files you need for your project. After this is done, you are ready
    to set up your Angular application. You can find installation files to Node.js
    at [https://nodejs.org](https://nodejs.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to have it installed is to go to the site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Installing Node.js will also install something called NPM, Node Package Manager,
    which you will need to install dependencies and more. The Angular CLI requires Node
    6.9.0 and NPM 3 or higher. Currently on the site, you can choose between an LTS
    version and the current version. The LTS version should be enough.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installing the Angular CLI is as easy as running the following command in your
    Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'On some systems, you may need to have elevated permissions to do so; in that
    case, run your Terminal window as an administrator and on Linux/macOS instead
    run the command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the Angular CLI is in place the time has come to create your first project.
    To do so place yourself in a directory of your choice and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a directory called `TodoApp`. After you have run the preceding
    command, there are two things you need to do to see your app in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the just created directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serve up the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This will be accomplished by the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, open up your browser on `http://localhost:4200` and you should
    see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cc3798ac-f306-4687-a4a5-4186198885c3.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Angular CLI doesn''t just come with code that makes your app work. It also
    comes with code that sets up testing and includes a test. Running the said test
    is as easy as typing the following in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/11371fd2-d676-4ca5-b1e1-78a4c89fd915.png)'
  prefs: []
  type: TYPE_IMG
- en: 'How come this works? Let''s have a look at the `package.json` file that was
    just created and the `scripts` tag. Everything specified here can be run using
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, it is not necessary to type `run` and it will be enough to just
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is the case with the `start` and `test` commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following listing makes it clear that it is possible to run more commands
    than `start` and `test` that we just learned about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'So far we have learned how to install the Angular CLI. Using the Angular CLI
    we have learned to:'
  prefs: []
  type: TYPE_NORMAL
- en: Scaffold a new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Serve up the project and see it displayed in a browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That is quite an accomplishment. We will revisit the Angular CLI in a later
    chapter as it is a very competent tool, capable of a lot more.
  prefs: []
  type: TYPE_NORMAL
- en: Hello Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are about to take the first trembling steps into building our first component.
    The Angular CLI has already scaffolded our project and thereby carried out a lot
    of heavy lifting. All we need to do is to create new file and starting filling
    it with content. The million dollar question is what to type?
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s venture into building our first component. There are three steps
    you need to take in creating a component. Those are:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the component decorator construct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decorate a class with a component decorator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a component to its module ( this might be in two different places).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First off, let''s import the component decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create the class for your component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then decorate your class using the `Component` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We give the `Component` decorator, which is function, an object literal as an
    input parameter. The object literal consists at this point of the `selector` and `template` keys, so
    let's explain what those are.
  prefs: []
  type: TYPE_NORMAL
- en: Selector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `selector` is what it should be referred to if used in a template somewhere
    else. As we call it `app`, we would refer to it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Template/templateUrl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `template` or `templateUrl` is your view. Here you can write HTML markup.
    Using the   `template`keyword, in our object literal, means we get to define the
    HTML markup in the same file as the component class. Were we to use `templateUrl`,
    we would then place our HTML markup in a separate file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding  example also lists the following double curly braces, in the
    markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be treated as an interpolation and the expression will be replaced
    with the value of `AppComponent`''s `title`field. The component, when rendered,
    will therefore look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Telling the module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we need to introduce a completely new concept, an Angular module. All types
    of constructs that you create in Angular should be registered with a module. An
    Angular module serves as a facade to the outside world and it  is nothing more
    than a class that is decorated by the decorate `@NgModule`. Just like the `@Component` decorator,
    the `@NgModule`decorator takes an object literal as an input parameter. To register
    our component with our Angular module, we need to give the object literal the
    property `declarations`. The `declarations` property is of a type array and by
    adding our component to that array we are registering it with the Angular module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the creation of an Angular module and the component
    being registered with it by being added to `declarations` keyword array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, our Angular module knows about the component. We need to add
    one more property to our module, `bootstrap`. The `bootstrap`keyword states that
    whatever is placed in here serves as the entry component for the entire application.
    Because we only have one component, so far, it makes sense to register our component
    with this `bootstrap` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It's definitely possible to have more than one entry component, but the usual
    scenario is that there is only one.
  prefs: []
  type: TYPE_NORMAL
- en: For any future components, however, we will only need to add them to the `declarations` property,
    to ensure the module knows about them.
  prefs: []
  type: TYPE_NORMAL
- en: So far we have created a component and an Angular module and registered the
    component with said the module. We don't really have a working application yet,
    as there is one more step we need to take. We need to set up the bootstrapping.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a bootstrap file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `main.ts` file is your bootstrap file and it should have the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'What we do in the preceding code snippet is to provide the recently created
    module as an input parameter to the method call `bootstrapModule()`. This will
    effectively make the said module, the entry module of the application. This is
    all we need to create a working application. Let''s summarize the steps we took
    to accomplish that:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a module and register our created component in its declaration property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also register our component in the modules bootstrap property to make it serve
    as an application entry point. Future components we create just need to be added
    to the `declarations` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bootstrap our created module by using the said module as an input parameter
    to the `bootstrapModule()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You as a reader have had to swallow a lot of information at this point and take
    our word for it. Don't worry, you will get a chance to get more acquainted with
    components in this chapter as well as Angular modules in upcoming chapters. For
    now, the focus was just to get you up and running by giving you a powerful tool
    in the form of the Angular CLI and show you how few steps are actually needed
    to have an app rendered to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Diving deeper into Angular components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have come a long way now, from tapping on TypeScript for the first time to
    learning how to code the basic scripting schema of an Angular component. However,
    before jumping into more abstract topics, let's try to build another component
    so we really get the hang of how creating it really works.
  prefs: []
  type: TYPE_NORMAL
- en: Component methods and data updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `timer.component.ts` file in the same folder and populate it with
    the following basic implementation of a very simple component. Don''t worry about
    the added complexity, as we will review each and every change made after the code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have created a whole new component by creating the `TimerComponent`class
    and decorated it with `@Component`, just as we learned how to do in a previous
    section. We learned in the previous section that there is more to be done, namely
    to tell an Angular module that this new component exists. The Angular module is
    already created so you just need to add our fresh new component to its `declarations` property,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As long as we only had the `AppComponent`we didn't really see the point of having
    an Angular module. With two components registered with our module, this changes. 
    When a component is registered with an Angular module it becomes available to
    other constructs in the module. It becomes available to their `template/templateUrl`.
    This means that we can have `TimerComponent` rendered inside of our `AppComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s therefore go back to our `AppComponent` file and update its template
    to show just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we highlight in bold how we add the `TimerComponent` to
    the `AppComponents`template. Or rather we refer to the `TimerComponent` by its `selector` property
    name, which is `timer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s show the `TimerComponent` again, in it''s entirety, and highlight the `selector` property
    because this is a really important thing to understand; that is, how to place
    a component in another component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to do more than just display a handful of numbers, right? We actually
    want them to represent a time countdown, and we can achieve that by introducing
    these changes. Let''s first introduce a function we can iterate on in order to
    update the countdown. Add this function after the constructor function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Selectors in Angular are case sensitive. As we will see later in this book,
    components are a subset of directives that can support a wide range of selectors.
    When creating components, we are supposed to set a custom tag name in the `selector`
    property by enforcing a dash-casing naming convention. When rendering that tag
    in our view, we should always close the tag as a non-void element. So `<custom-element></custom-element>` is
    correct, while `<custom-element />`will trigger an exception. Last but not least,
    certain common camel case names might conflict with the Angular implementation,
    so avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: Going from static to actual data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you can see here, functions in TypeScript need to be annotated with the
    type of the value they return, or just void if none. Our function assesses the
    current value of both minutes and seconds, and then either decreases their value
    or just resets it to the initial value. Then this function is called every second
    by triggering a time interval from the class constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, we spot for the first time in our code an arrow function (also known as
    a lambda function, fat arrow, and so on), a new syntax for functions brought by
    ECMAScript 6, which we will cover in more detail in [Chapter 3](9b3ddd80-6ddf-43e5-92d7-a9260c11ff6d.xhtml),
    *Introducing TypeScript*. The `tick` function is also marked as private, so it
    cannot be inspected or executed outside a `PomodoroTimerComponent` object instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far so good! We have a working Pomodoro timer that countdowns from 25 minutes
    to 0, and then starts all over again. The problem is that we are replicating code
    here and there. So, let''s refactor everything a little bit to prevent code duplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We have wrapped the initialization (and reset) of minutes and seconds inside
    our function `resetPomodoro`, which is called upon instantiating the component
    or reaching the end of the countdown. Wait a moment though! According to the Pomodoro
    technique, Pomodoro practitioners are allowed to rest in between Pomodoros or
    even pause them should an unexpected circumstance get in the way. We need to provide
    some sort of interactivity so the user can start, pause, and resume the current
    Pomodoro timer.
  prefs: []
  type: TYPE_NORMAL
- en: Adding interactivity to the component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular provides top-notch support for events through a declarative interface.This
    means it is easy to hook up events and have the point to method. It's also easy
    to bind data to different HTML attributes, as you are about to learn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first modify our template definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We used a multiline text string! ECMAScript 6 introduced the concept of
  prefs: []
  type: TYPE_NORMAL
- en: template strings, which are string literals with support for embedded expressions,
    interpolated text bindings, and multiline content. We will look into them in more
    detail in [Chapter 3](9b3ddd80-6ddf-43e5-92d7-a9260c11ff6d.xhtml), *Introducing
    TypeScript*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the meantime, just focus on the fact that we introduced a new chunk of HTML
    that contains a button with an event handler that listens to click events and
    executes the `togglePause()` method upon clicking. This `(click)` attribute is
    something you might not have seen before, even though it is fully compliant with
    the W3C standards. Again, we will cover this in more detail in [Chapter 4](41335dde-9066-4998-a0a9-3c42f97cdd9e.xhtml),
    *Implementing Properties and Events in Our Components*. Let''s focus on the `togglePause()`
    method and the new `buttonLabel` binding. First, let''s modify our class properties
    so that they look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We introduced two new fields. The first is `buttonLabel`, which contains the
    text that will later on be displayed on our newly-created button. `isPaused` is
    a newly-created variable that will assume a`true`/`false`value, depending on the
    state of our timer. So, we might need a place to toggle the value of such a field.
    Let''s create the `togglePause()` method we mentioned earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In a nutshell, the `togglePause()` method just switches the value of `isPaused`
    to its opposite and then, depending on such a new value and whether the timer
    has started (which would entail that any of the time variables has a value lower
    than the initialisation value) or not, we assign a different label to our button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to initialize these values, and it seems there is no better place
    for it. So, the `reset()` function is the place where variables affecting the
    state of our class are initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'By executing `togglePause()` every time, we reset it the to make sure that
    whenever it reaches a state where it requires to be reset, the countdown behavior
    will switch to the opposite state it had previously. There is only one tweak left
    in the controller method that handles the countdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, we do not want the countdown to continue when the timer is supposed
    to be paused, so we wrap the whole script in a conditional. In addition to this,
    we will want to display a different text on our button whenever the countdown
    is not paused and once again when the countdown reaches its end; stopping and
    then resetting the Pomodoro to its initial values will be the expected behavior.
    This reinforces the need of invoking the `togglePause` function within `resetPomodoro`.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the data output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have reloaded the browser and played around with the newly created
    toggle feature. However, there is apparently something that still requires some
    polishing: when the seconds counter is less than 10, it displays a single-digit
    number instead of the usual two-digit numbers we are used to seeing in digital
    clocks and watches. Luckily, Angular implements a set of declarative helpers that
    format the data output in our templates. We call them pipes, and we will cover
    them in detail later in [Chapter 4](41335dde-9066-4998-a0a9-3c42f97cdd9e.xhtml),
    *Implementing Properties and Events in Our Components*. For the time being, let''s
    just introduce the number pipe in our component template and configure it to format
    the seconds output to display two digits all the time. Update our template so
    that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Basically, we appended the pipe name to the interpolated binding in our template
    separated by a pipe (`|`) symbol, hence the name. Reload the template and you
    will see how the seconds figure always displays two digits, regardless of the
    value it assumes.
  prefs: []
  type: TYPE_NORMAL
- en: We have created a fully functional Pomodoro timer widget that we can reuse or
    embed in more complex applications. [Chapter 6](93b8f637-859e-4e12-aaa0-4cec5f02c2c3.xhtml),
    *Building an Application with Angular Components*, will guide us through the process
    of embedding and nesting our components in the context of larger component trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the meantime, let''s add some UI beautification to make our component more
    appealing. We already introduced a class attribute in our button tag as an anticipation
    of the implementation of the Bootstrap CSS framework in our project. Let''s import
    the actual style sheet we downloaded through npm when installing the project dependencies.
    Open `timer.html` and add this snippet at the end of the `<head>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s beautify our UI by inserting a nice page header right before our
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Tweaking the component button with a Bootstrap button class will give it more
    personality and wrapping the whole template in a centering container will definitely
    compound up the UI. So let''s update the template in our template to look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We looked at web components according to modern web standards and how Angular
    components provide an easy and straightforward API to build our own components.
    We covered TypeScript and some basic traits of its syntax as a preparation for
    [Chapter 3](9b3ddd80-6ddf-43e5-92d7-a9260c11ff6d.xhtml), *Introducing TypeScript*.
    We saw how to set up our working space and where to go to find the dependencies
    we need to bring TypeScript into the game and use the Angular library in our projects,
    going through the role of each dependency in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Our first component taught us the basics of creating a component and also allowed
    us to get more familiar with another important concept, Angular modules, and also
    how to bootstrap the application. Our second component gave us the opportunity
    to discuss the form of a controller class containing property fields, constructors,
    and utility functions, and why metadata annotations are so important in the context
    of Angular applications to define how our component will integrate itself in the
    HTML environment where it will live. Our first web component features its own
    template and such templates host property bindings declaratively in the form of
    variable interpolations, conveniently formatted by pipes. Binding event listeners
    is now easier than ever and its syntax is standards-compliant.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover, in detail, all the TypeScript features we need
    to know to get up to speed with Angular in no time.
  prefs: []
  type: TYPE_NORMAL
