- en: Screens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One screen with a plain user interface is not exciting at all. However, before
    you go into eye candy styling and *wow* effects, you need to create more screens
    containing all the elements a professionally developed application must have.
    You see all this in modern applications you use in your everyday life. In the
    previous chapter, we built and ran our project. This skill is important so we
    can continue with our progress. Now you will add a UI in your application!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing mockup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining application activities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android Context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fragments, fragment manager, and stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View pager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction, dialog fragments, and notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other important UI components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the mockup plan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Things are getting hooked! We are ready to begin with some serious development!
    We will create all of the screens for our application. However, before we create
    them, we will create and analyze a mockup so we know what exactly we will create.
    The mockup will represent the basic application wireframe with no design. It will
    be just a layout for the screens and the relationship between them. To create
    a good mockup with wireframes, you will need a tool. Any tool capable of drawing
    lines will do the job. To draw our mockup, we used **Pencil**. Pencil is a free
    open source application providing GUI prototyping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at our mockup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a326c99-c11c-47a3-8633-6e16ed711c6b.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the mockup presents a relatively simple application with a few
    screens. There are different components that will be included in these screens,
    and we will explain these along with each screen. Let's go through the mockup.
  prefs: []
  type: TYPE_NORMAL
- en: The first screen, titled Landing screen, will be our main application screen.
    Every time we enter the application, this screen will appear. We already defined
    the `MainActivity` class. This activity will represent the screen. Soon, we will
    extend the code so the activity follows the mockup exactly as described.
  prefs: []
  type: TYPE_NORMAL
- en: The central part of the screen will be the list containing all the items we
    created. Each item will contain basic properties, such as title or date and time.
    We will be able to filter items by type. We will be able to filter only Notes
    or TODOs. The difference between Notes and TODOs is that TODOs will represent
    tasks with the *date* and *time* assigned. We will also support some functionalities
    such as the onLongPress events. The onLongPress event on each item will present
    a Popup menu with the Edit, Remove, or Complete options. Clicking on Edit will
    open the screen for updating.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom-right corner, we will have a + button. The purpose of the button
    is to open the option Dialog on which a user can choose if they want to create
    a Note or TODO task. Depending on the option, a user can choose one of the screens
    that appear--Add note screen or Add TODO screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Landing screen also contains the Sliding menu button positioned at its top-left
    corner. Clicking on that button will open the Sliding menu with the following
    items in it:'
  prefs: []
  type: TYPE_NORMAL
- en: An application icon with the application title and version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Today button to filter only TODO items assigned for the current date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Next 7 Days button to filter TODO items assigned in the Next 7 Days including
    the current one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A TODOs button filter only TODO items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Notes button will filter only the Note items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying some of these filters will affect the checkboxes from the Popup menu
    we get by clicking on the top-right corner of the Landing screen. Also, checking
    and unchecking those will modify the currently applied filter.
  prefs: []
  type: TYPE_NORMAL
- en: The last item in the sliding menu is Synchronize now. This button will trigger
    synchronization and synchronize all unsynchronized items with backend if there
    are any.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will explain two screens responsible for the creation (or editing) of
    Notes and TODOs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add/Edit note screen: This is used to create a new note or to update the content
    of an existing one. Keyboard will be opened as edit text field is focused. There
    is no save or update button since we plan that all changes we make are applied
    immediately. The top-left and top-right buttons are disabled while we are on this
    screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add/Edit TODO screen: This is used to create a new TODO application or to update
    the content of an existing one. Keyboard will open as in the previous example.
    There is no save or update button as shown in the previous example, either. The
    top-left and top-right buttons are disabled too. Following are the title view,
    we have buttons to pick date and time. By default, they will be set to the current
    date and time. Opening keyboard will push these buttons up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We covered the basic UI and what we want to achieve by analyzing this mockup.
    The time has come to create some new screens.
  prefs: []
  type: TYPE_NORMAL
- en: Defining application activities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To sum up, we will have three activities:'
  prefs: []
  type: TYPE_NORMAL
- en: Landing activity (`MainActivty.kt`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add/Edit note screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add/Edit TODO screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's common practice in Android development to create an activity that will
    be a parent class to all other activities because, like this, we will reduce code
    base and share it at the same time with multiple activites. In most cases, Android
    developers call it `BaseActivity`. We will define our version of `BaseActivity`.
    Create a new class called `BaseActivity`; the `BaseActivity.kt` file is created.
    Make sure the newly created class is located under the `Activity` package of your
    project.
  prefs: []
  type: TYPE_NORMAL
- en: The `BaseActivity` class must extend the `FragmentActivity` class of Android
    SDK. We will extend `FragmentActivity` because we plan to use fragments inside
    our `MainActivity` class. Fragments will be used with ViewPager to navigate between
    different filters (Today, Next 7 Days, and so on). We plan that when the user
    clicks on one of those from our sliding menu, ViewPager automatically swipes to
    position with the fragment containing the data filtered by the chosen criteria.
    We will extend `FragmentActivity` from the package as follows--`android.support.v4.app.FragmentActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android provides a way to support multiple API versions. Since we plan to do
    so, we will use the `FragmentActivity` version from the support library. Like
    this, we maximize our compatibility! To add support for the Android support library,
    include the following directive in the `build`.`gradle` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you probably remember, we did so!
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue! Since we are introducing a base class for all activities, we
    have to do some small refactoring to the only activity we have now. We will move
    the `tag` field from `MainActivity` to `BaseActivity`. Since it must be accessible
    to children of `BaseActivity`, we will update its visibility to `protected`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want each `Activity` class to have its unique tag. We will use activity
    concretization to choose the value for its tag. So, the `tag` field becomes `abstract`
    with no default value assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Beside this, we have some more common stuff in all activities. Each activity
    will have a layout. A layout is Android identified by the ID of the integer type.
    In the `BaseActivity` class, we will create an `abstract` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To optimize the code, we will move `onCreate` from `MainActivity` to `BaseActivity`.
    Instead of passing the ID of the layout from the Android generated resource directly,
    we will pass the result value of the `getLayout()` method. We will move all other
    lifecycle method overrides as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your classes according to these changes and build and run the application
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready to define the rest of the screens. We have to create a screen
    for adding and editing Notes and a screen that does the same for TODOs. There
    is a lot of common between these screens. The only difference for now is that
    the TODOs screen has buttons for date and time. We will create a common class
    for everything that these screens share. Each concretization will extend it. Create
    a class called `ItemActivity`. Make sure it's located in the `Activity` package.
    Create two more classes--`NoteActivity` and `TodoActivity`. `ItemActivity` extends
    our `BaseActivity` class and `NoteActivity` and `TodoActivity` activity classes
    extend `ItemActivity` class. You will be asked to override members. Please do
    so. Give some meaningful value for the tag we will use in logging. To assign a
    proper layout ID first we must create it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate the layout we created for the main screen. Now, using the same principle,
    create two more layouts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`activity_note.xml`, let it be the `LinearLayout` class if asked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`activity_todo.xml`, let it be the `LinearLayout` class if asked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Any layout or layout member in Android gets a unique ID as `integer` representation
    in the `R` class that Android generates during the build. The `R` class for our
    application is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the layout, use the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We use static access. So, let''s update our class concretizations to access
    layout IDs. Classes now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Last step is to register our screens (activities) in `view groups`. Open the
    `manifest` file and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Both activities are locked to `portrait` orientation.
  prefs: []
  type: TYPE_NORMAL
- en: We made progress! We defined our application screens. In the next section, we
    will populate the screens it with UI components.
  prefs: []
  type: TYPE_NORMAL
- en: Android layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will continue our work by defining layouts for each screen. Layouts in Android
    are defined in XML. We will mention the most commonly used layout types and populate
    them with commonly used layout components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each layout file has one of the layout types as its top-level container. Layouts
    can contain other layouts with UI components and so on. We can nest it. Let''s
    mention the most commonly used layout types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Linear layout**: This aligns UI components in a linear order, vertically
    or horizontally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relative layout**: These UI components are aligned relatively to each other'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**List view layout**: All items are organized in the form of a list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grid view layout**: All items are organized in the form of a grid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scroll view layout**: This is used to enable scrolling when its content becomes
    higher than the actual height of the screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layout elements that we just mentioned are `view groups`. Each view group contains
    other views. `View groups` extend the `ViewGroup` class. At the top, everything
    is a `View` class. Classes (views) that are extending the `View` class, but do
    not extend `ViewGroup`, can't contain other elements (children). Such examples
    are `Button`, `ImageButton`, `ImageView`, and similar classes. Therefore, it's
    possible, for example, to define a `RelativeLayout` that contains a `LinearLayout`,
    which contains other multiple views aligned vertically or horizontally and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now highlight some commonly used views:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Button`: This is a `Base` class that represents a button linked to the `onClick`
    action we define'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImageButton`: This is a button with an image used as its visual representation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImageView`: This is a view that displays an image loaded from different sources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextView`: This is a view that contains single or multiline non-editable text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EditText`: This is a view that contains single or multiline editable text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebView`: This is a view that presents rendered HTML pages loaded from different
    sources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CheckBox`: This is a main two-states choice view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every `View` and `ViewGroup` supports misc XML attributes. Some attributes are
    specific to only certain view types. There are also attributes that are the same
    for all views. We will highlight the most commonly used view attributes through
    the examples of our screens later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To assign a unique identifier by which you can access a view through the code
    or other layout members, you must define an ID. To assign an ID to a view, use
    the syntax like in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we assigned the `my_button` ID to a view. To access it from
    code, we will use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`R` is a generated class providing us access to resources. To create an instance
    of the button, we will use the `findViewById()` method defined in the Android
    `Activity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we used Kotlin, we can access it directly, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The IDE will ask you about a proper import. Keep in mind that other layout resource
    files can have an ID with the same name defined. In that case, it can happen that
    you have a wrong import! If that happens, your application will crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@` symbol at the beginning of the string indicates that the XML parser
    should parse and expand the rest of the ID string and identify it as an ID resource.
    The `+` symbol means that this is a new resource name. When referencing an Android
    resource ID, you do not need the `+` symbol, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build our UI for the main application screen! We will start with some
    prerequisites. In the values resource directory, create `dimens.xml` to define
    some dimensions we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Android defines dimensions in the following units:'
  prefs: []
  type: TYPE_NORMAL
- en: '**px (pixels)**: This corresponds to actual pixels on the screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**in (inches)**: This is based on the physical size of the screen, that is,
    1 inch = 2.54 centimeters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mm (millimeters)**: This is based on the physical size of the screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pt (points)**: This is the 1/72 of an inch based on the physical size of
    the screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And the most important for us is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dp (Density-independent Pixels)**: This represents an abstract unit that
    is based on the physical density of the screen. They are relative to a 160 DPI
    screen. One dp is one pixel on a 160 DPI screen. The ratio of dp-to-pixel will
    change with the screen density, but not necessarily in direct proportion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sp (Scale-independent Pixels)**: These are like the dp unit and generally
    used for font size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have to define a header layout that will be included on all screens. Create
    the `activity_header.xml` file and define it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let's explain the most important parts of it. First of all, we have defined
    `RelativeLayout` as our main container. Since all elements are positioned relatively
    to the parent and to each other, we will use some special attributes to express
    these relationships.
  prefs: []
  type: TYPE_NORMAL
- en: 'For every view, we must have width and height attributes. Values for it can
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dimension defined in the dimension resource file, for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Directly defined dimension value, for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Match the size of the parent (`match_parent`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or wrap the content of the view (`wrap_content`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we will populate the layout with children views. We have three children
    views. We will define two buttons and one text view. Text view is aligned to the
    center of the layout. Buttons are aligned with edges of the layout--one to the
    left and the other to the right. To achieve central alignment of the text view,
    we used the `layout_centerInParent` attribute. The value passed to it is the Boolean
    true. To align a button at the layout''s left edge, we used the `layout_alignParentStart`
    attribute. For the right edge, we used the `layout_alignParentEnd` attribute.
    Each child has a proper ID assigned. We will include this in `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The main container for `Main activity` is `LinearLayout`. An orientation attribute
    for `LinearLayout` is mandatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Values that can be assigned to it are vertical and horizontal. As the first
    child of the `Main activity`, we included the `activity_header` layout. Then we
    defined `RelativeLayout`, which fills the rest of screen.
  prefs: []
  type: TYPE_NORMAL
- en: '`RelativeLayout` has two members, `ListView` that will present all our items.
    We assigned a background to it. We did not define our own color in the colors
    resource file, but the one predefined in Android. Last view we have here is `FloatingActionButton`,
    the same one you can see in the Gmail Android application. The button will be
    positioned over the list with items at the bottom of the screen aligned to the
    right. We also set a margin that will surround the button from all sides. Take
    a look at the attributes we used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we run our application again, we will make a few more changes. Open
    `BaseActivity` and update its code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We introduced the `abstract` method that will provide a proper title for each
    activity. We will `access` the `activity_title` view defined in `activity_header.xml`,
    which is included in our activity, and assign the value we get by executing the
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `MainActivity` and override the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the same line to `ItemActivity`. Finally, run the application. Your main
    screen should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ff9331e-6609-466a-9375-7fbeb062a8af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s define layouts for the rest of the screens. For the Notes, Add/Edit
    note screen, we will define the following layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There are a few important things that we must highlight. We will explain them
    one by one. We introduced `ScrollView` as our top container for the layout. Since
    we will populate multiline notes, it will happen that its content goes below the
    physical limit of the screen. If that happens, we will be able to scroll the content.
    We used one very important attribute--`fillViewport`. This attribute tells the
    container to stretch to the whole screen. All children use that space.
  prefs: []
  type: TYPE_NORMAL
- en: Using EditText views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We introduced the `EditText` views to enter editable text content. You can
    see some new attributes here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**hint**: This defines the default string value that will be presented to the
    user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**padding**: This is the space between the view itself and its content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**gravity**: This defines direction for the content; in our case, all text
    will stick to the top of the parent view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that, for all strings and dimensions, we defined proper entries in the
    `strings.xml` file and the `dimens.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The strings resource file now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the top container is `ScrollView`. Compared to the previous screen,
    we have introduced some differences. We added the container to hold buttons for
    date and time picking. The orientation is horizontal. We set the parent container
    attribute, `weightSum`, to define the weight value that can be divided by children
    views so each child takes the amount of space defined by its own weight. So, `weightSum`
    is one. First button has a `layout_weight` of `0.5`. It will consume 50% of the
    horizontal space. The second button has the same value. We achieved view splitting
    in two halves. Locate the bottom of your XML and click on Design to switch to
    Design view. Your buttons should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f065d15d-1b8e-4818-a721-f6a7c5532f48.png)'
  prefs: []
  type: TYPE_IMG
- en: We defined layouts for our screens. To express how these screens should look,
    we relied on many different attributes. This is just a small portion of the available
    attributes we can use. To make this section complete, we will present you with
    some other important attributes that you will use in everyday development.
  prefs: []
  type: TYPE_NORMAL
- en: The margins attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Margins accept dimension resources or direct dimension values in one of the
    following supported units:'
  prefs: []
  type: TYPE_NORMAL
- en: '`layout_margin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout_marginTop`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout_marginBottom`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout_marginStart`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout_marginEnd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The padding attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Padding accepts dimension resources or direct dimension values in one of the
    following supported units:'
  prefs: []
  type: TYPE_NORMAL
- en: '`padding`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paddingTop`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paddingBottom`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paddingStart`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paddingEnd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking out the gravity attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'View Gravity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**gravity (direction of the content inside the view)**: This accepts the following--`top`,
    `left`, `right`, `start`, `end`, `center`, `center_horizontal`, `center_vertical`,
    and many other'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**layout_gravity (direction of the content inside the view parent)**: This
    accepts the following--`top`, `left`, `right`, `left`, `start`, `end`, `center`,
    `center_horizontal`, `center_vertical`, and many others'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s possible to combine values for gravity as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Looking at other attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We just saw the most important attributes we will use. It is time to see other
    attributes you may find handy. Other attributes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src`: This is the resource to use:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`background`: Background for the view, hex color, or color resource is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`onClick`: This is the method to be invoked when a user clicks on the view
    (usually a button)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`visibility`: This is the visibility of the view, which accepts the following
    parameters--gone (invisible and does not consume any layout space), invisible
    (invisible but consumes layout space), and visible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hint`: This is the hint text for the view, and it accepts a string value or
    a string resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text`: This is the text for the view, and it accepts a string value or a string
    resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`textColor`: This is the color for the text, hex color, or color resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`textSize`: This is the size for the text in supported units--direct unit value
    or dimension resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`textStyle`: This is the style resource that defines attributes to assign to
    view, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we covered working with attributes. Without them, we can't
    develop our UI. In the rest of this chapter, we will introduce you to Android
    Context.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Android Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All our main screens now have their layouts defined. We will now explain Android
    Context since each screen we just created represents one `Context` instance. If
    you go through the class definition and follow class extension, you will realize
    that each activity we create extends the `Context` class.
  prefs: []
  type: TYPE_NORMAL
- en: '`Context` represents the current state of the application or object. It is
    used to access specific classes and resources of the application. For example,
    consider the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Access we showed is provided by the `Context` class, which shows our activities
    are extending. `Context` is needed when we have to launch another activity, start
    a service, or send broadcast messages. We will show use of these methods when
    the time is proper. We already mentioned that each screen (`Activity`) of an Android
    application represents a `Context` instance. Activities are not the only classes
    that represent context. Except activities, we have the service context type too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android Context has the following purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Showing a dialog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting an activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inflating layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding to a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending a broadcast message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering for broadcast messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, like we already showed in the preceding example, loading resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Context` is an important part of Android and one of the most frequently used
    classes of the framework. Later in this book, you will meet other `Context` classes.
    However, before that, we will be focused on fragments and their explanation.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have mentioned that the central part of our main screen will contain a list
    of filtered items. We want to have several pages with a different set of filters
    applied. A user will be able to swipe left or right to change the filtered content
    and navigate through the following pages:'
  prefs: []
  type: TYPE_NORMAL
- en: All displayed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Items for Today
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Items for Next 7 Days
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only Notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only TODOs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To achieve this functionality, we will need to define fragments. What are fragments
    and what is their purpose?
  prefs: []
  type: TYPE_NORMAL
- en: A fragment is a portion of the interface of an `Activity` instance. You can
    use fragments to create multiplane screens or screens with view paging, like in
    our case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like activities, fragments have their own lifecycle. Fragment lifecycle
    is presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d658d3db-bfe9-469b-a79a-d1736ce31949.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are some additional methods that activities do not have:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onAttach()`: This is executed when a fragment is associated to an activity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onCreateView()`: This instantiates and returns a fragment''s view instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onActivityCreated()`: This executes when an activity''s `onCreate()` is executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onDestroyView()`: This executes when a view is destroyed; it is convenient
    when some cleanup is needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onDetach()`: This is executed when a fragment is unassociated from an activity.
    To demonstrate the use of fragments, we will put the central part of our `MainActivity`
    into one single fragment. Later, we will move it to `ViewPager` and add more pages
    to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a new package called `fragment`. Then, create a new class called `BaseFragment`.
    Update your `BaseFragment` class according to this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay attention to imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We want maximal compatibility, so we are importing fragments from the Android
    support library.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we did something similar to what we did with `BaseActivity`.
    Create a new fragment, a class named `ItemsFragment`. Update its code according
    to this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We introduced a new layout that actually contains the list view we had in `activity_main`.
    Create a new layout resource called `fragment_items`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You already saw this. It is just a part we extracted from the `activity_main`
    layout. Instead of this, we put the following in the `activity_main` layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`FrameLayout` will be our `fragment` container. To show the new fragment in
    `fragment_container``FrameLayout`, update the code of `MainActivity` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We accessed `supportFragmentManager`. If we did not choose to use the Android
    support library, we would use `fragmentManager`. Then, we start fragment transaction,
    to which, we add a new fragment instance that will be associated to `fragment_container`
    `FrameLayout`. The `commit` method executes this transaction. If we run our application
    now, we will not notice anything different, but, if we take a look at the logs,
    we may notice that the fragment lifecycle has been executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We added a simple fragment to our interface. In the next section, you will learn
    more about fragment manager and its purpose. Then, we will do something very interesting--we
    will create a `ViewPager`.
  prefs: []
  type: TYPE_NORMAL
- en: Fragment manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The component that is responsible for interacting with fragments from your
    current activity is **fragment manager**. We can use the `FragmentManager` form
    in two different imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '`android.app.FragmentManager`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android.support.v4.app.Fragment`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import from the Android support library is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: To perform a series of edit operations, start the fragment transaction using
    the `beginTransaction()` method. It will return an instance of transaction. To
    add a fragment (usually the first), use the `add` method, like in our example.
    The method takes the same arguments, but replaces the current fragment if already
    added. If we are planning to navigate backwards through fragments, it is needed
    to add the transaction to back stack by using the `addToBackStack` method. It
    takes a name parameter or null if we do not want to assign a name.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we schedule a transaction by executing `commit()`. This is a not momental
    operation. It schedules operations on the application's main thread. When the
    main thread is ready, the transaction will be executed. Think about it when planning
    and implementing your code!
  prefs: []
  type: TYPE_NORMAL
- en: Fragments stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To illustrate examples of fragments and the back stack, we will extend our
    application further. We will create a fragment to display a user manual containing
    the text, `Lorem ipsum`. First we need to create a new fragment. Create a new
    layout named `fragment_manual`. Update the layout as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple layout containing the text view stretched across the whole
    parent view. The fragment that will use this layout will be called `ManualFragment`.
    Create a class for the fragment and make sure it has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s add it to the fragment back stack. Update the `onCreate()`
    method of `MainActivity` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Build and run the application. The top-right header button will have label `H`;
    click on it. The fragment containing the `Lorem ipsum` text fills the view. Tap
    on the back button and the fragment disappears. This means that you successfully
    added and removed the fragment from the back stack.
  prefs: []
  type: TYPE_NORMAL
- en: We have to try one more thing--click on the same button two to three times in
    the row. Click on the back button. Then again. And again. You will go through
    the back stack until you reach the first fragment. If you tap on the back button
    once more, you will leave the application. Observe your Logcat.
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember the order in which lifecycle methods are executed? You can recognize
    that each time a new fragment is added to the top, the one below pauses. When
    we start going back by pressing the back button, the fragment on the top pauses
    and the one below resumes. Fragments that are removed from the back stack enter
    the `onDestroy()` method at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Creating View Pager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned, we want our items to display on several pages that can be
    swiped. To do so, we need `ViewPager`. `ViewPager` makes it possible to swipe
    between different fragments as a part of the fragment collection. We will make
    some changes to our code. Open the `activity_main` layout and update it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of `FrameLayout`, we put the `ViewPager` view. Then, open the `MainActivity`
    class and update it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The main part of our work is to define the `adapter` class for the pager. We
    must extend the `FragmentStatePagerAdapter` class; its constructor accepts the
    fragment manager that will deal with fragment transactions. To complete work properly,
    override the `getItem()` methods that returns an instance of the fragment and
    `getCount()` that returns the total number of expected fragments. The rest of
    the code is very clear--we access to pager (the ID of `ViewPager` we assigned)
    and assign to it a new instance of the adapter.
  prefs: []
  type: TYPE_NORMAL
- en: Run your application and try swiping left and right. While you're swiping, observe
    Logcat and the lifecycle logs.
  prefs: []
  type: TYPE_NORMAL
- en: Making animations with transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To animate transactions between fragments, it''s needed to assign some animation
    resources to the transaction instance. As you remember, after we begin the fragment
    transaction, we get one transaction instance. We can then access this instance
    and execute the method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setCustomAnimations (int enter, int exit, int popEnter, int popExit)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Or, we can use this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setCustomAnimations (int enter, int exit)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, each parameter represents the animation used in this transaction. We
    can define our own animation resources or use one of the predefined ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26f2bac6-99df-4c27-9afa-f482bdfd75d1.png)'
  prefs: []
  type: TYPE_IMG
- en: Dialog fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you need to display any of your fragments floating above the rest of application''s
    UI, then `DialogFragment` is perfect for you. All you need to do is define the
    fragment very similarly to what we did so far. Define the class that is extending
    `DialogFragment`. Override the `onCreateView()` method so you can define the layout.
    You can override `onCreate()` as well. The last thing you have to do is to display
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we passed the instance and the name for the transaction to
    the fragment manager.
  prefs: []
  type: TYPE_NORMAL
- en: Notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the content you are planning to present to the end user is short, then, instead
    of dialogs, you should try notifications. We can customize notifications in many
    different ways. Here, we will present some basic customizations. Creating and
    displaying notifications is easy. It requires more knowledge of Android than we
    have learned so far. Don't worry; we will do our best to explain it. You will
    face many of these classes in the later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will demonstrate how to use notifications as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a `notificationBuilder` and pass a small icon, content title, and content
    text as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Define `Intent` for activity of your application. (More about intents, will
    be discussed in the next chapter):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now define the stack builder object that will contain the back stack for the
    activity as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Add back stack for the intent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Add intent at the top of the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Other important UI components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android Framework is large and powerful. So far, we have covered `View` classes,
    which are most frequently used. However, there are a lot of `View` classes that
    we did not cover. Some of them will be covered later, but some that are not so
    frequently used will be just mentioned. Anyway, it''s good to know that these
    views exist and it is a good starting point for your further learning. Let''s
    give some examples to give you an idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ConstraintLayout**: This views and positions child elements in a flexible
    way'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CoordinatorLayout**: This is a very advanced version of FrameLayout'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SurfaceView**: This is a view used for drawing (especially when high performance
    is needed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VideoView**: This is set to play video content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create screens divided into sections, and
    now you are able to create basic and complex layouts containing buttons and images.
    You also learned how to create dialogs and notifications. In the following chapter,
    you will connect all your screens and navigation actions.
  prefs: []
  type: TYPE_NORMAL
