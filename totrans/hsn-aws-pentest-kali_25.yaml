- en: Using Pacu for AWS Pentesting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we have used Pacu throughout this book, this chapter will take the
    approach of discussing Pacu from the ground up. Ideally, at the end of this chapter,
    you should understand and be able to utilize the majority of Pacu's offered functionality.
    That means that you'll be able to take advantage of some of the more advanced
    features of Pacu and can contribute your own modules and research to the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll dive deeper into the AWS exploitation toolkit, Pacu,
    where we will develop an understanding of the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: What Pacu is, why it is important, and how to set it up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The commands that are offered by Pacu and how we can use them for our benefit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we can automate our own tasks and add them to Pacu as a module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A short introduction into PacuProxy and its purpose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For anything in the pentesting field, it is helpful to automate things as much
    as possible, where possible. This allows us to perform attacks and enumeration
    of an environment without requiring the manual work of running multiple AWS **command-line
    interface** (**CLI**) commands over and over again across different environments.
    This kind of toolage allows us to save time, allowing us more time to spend on
    the manual aspect of our testing process. Sometimes these tools are involved and
    complicated though, and a thorough understanding of the tool and its target are
    required to utilize it to its full potential. That's why this chapter was written,
    to help you get a better understanding of what Pacu has to offer and how you can
    best take advantage of those offerings.
  prefs: []
  type: TYPE_NORMAL
- en: Pacu history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start from the very beginning, Pacu is an offensive AWS exploitation framework,
    written by a small group of developers and researchers at Rhino Security Labs.
    Open source and available on GitHub under the BSD-3 license ([https://github.com/RhinoSecurityLabs/pacu](https://github.com/RhinoSecurityLabs/pacu)),
    Pacu and its modules are written in Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: The original idea for Pacu was born out of an accumulation of research within
    Rhino's penetration testing team. It was found that more and more clients are
    using cloud server providers, such as AWS, and that there were a lot of unexplored
    areas that seemed ripe for exploitation. As ideas, attack vectors, and scripts
    piled up within the Rhino team, it became clear that some sort of framework was
    required to aggregate all of this research and make it easy to work with. Being
    penetration testers, it was also decided that it should be able to handle projects
    and pentests well, even if separate ones are being worked on simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: After an internal proposal and prototype of the proposed project, Pacu was accepted
    and the team began the process that resulted in what Pacu is today. To mirror
    similar projects and to ensure Pacu stays up to date with the evolving services
    of AWS and associated attack vectors, Pacu was developed with extensibility in
    mind. This was to allow for easy, external contribution to the project, as well
    as a simple, managed infrastructure that handled problems and allowed for easy
    solutions to those problems.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Pacu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing that is needed when setting up Pacu is to ensure that Git,
    Python 3, and Pip 3 are installed. When that''s done, you can follow a simple
    three-step process to get Pacu installed and running. From the CLI of your operating
    system (we are using Kali Linux), run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that Pacu is not officially supported for Windows operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now Pacu should start up and go through the process of configuration and database
    creation. It should first tell you that it created a new `settings.py` file, followed
    by a message that it created a new local database file. Finally, it will ask you
    for a name for your new Pacu session. In this example, we named the session `ExampleSession`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32f8f0c4-6a29-47af-bf15-92b8ef57e024.png)'
  prefs: []
  type: TYPE_IMG
- en: Pacu being started for the first time on Kali Linux
  prefs: []
  type: TYPE_NORMAL
- en: Now our new session is created; `session` within Pacu is essentially a way to
    isolate data, activity, and credentials between different projects that you are
    working on. Pacu uses a local SQLite database to manage sessions and the data
    within them, and it allows the creation of any number of sessions. As a pentester,
    sessions can be thought of as engagements or companies, in the sense that you
    can be working on two different AWS pentests at once, so you will need two Pacu
    sessions to separate the two. Each Pacu session will then hold all the data, activity,
    and credentials that belong to that specific engagement or company. This allows
    you to work with the same data across multiple different uses of Pacu, requiring
    fewer API calls to the AWS API, meaning you are that much more hidden in the logs.
  prefs: []
  type: TYPE_NORMAL
- en: The `SQLAlchemy` Python library is used to manage interaction between Pacu and
    the database, but we will jump into that later on.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing you should see is a large output of help information from Pacu
    that explains the different commands and abilities that Pacu has enabled. We'll
    skip that for now and come back to it later.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, if you are running Kali Linux like we are, you should see a message
    that is similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a04cee23-563a-4bf9-be70-84f20df56a59.png)'
  prefs: []
  type: TYPE_IMG
- en: Built-in GuardDuty defense in Pacu
  prefs: []
  type: TYPE_NORMAL
- en: Just as we discussed in [Chapter 16](14f5f864-8cf1-4232-86f5-8d0fa4ec28e4.xhtml),
    *GuardDuty*, this message is shown because Pacu detects that it is running on
    a Kali Linux host. GuardDuty can detect when AWS API calls are made from a Kali
    Linux server, and flags an alert based on that, so Pacu automatically resolves
    this by modifying the user agent that is sent to the AWS servers. As a result,
    GuardDuty won't alert us immediately when we start attacking. This same check
    and solution process applies to Parrot and Pentoo Linux as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you should land in the Pacu CLI, which looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This line is waiting for us to enter a command, and it is showing us that we
    are in the `ExampleSession` Pacu session, without any AWS keys set. For most of
    Pacu''s functionality, a set of AWS keys is required, so we will go ahead and
    add some in with the `set_keys` Pacu command. While running this, we will be asked
    for the key alias, access key ID, secret access key, and session token of our
    AWS credentials. As we have previously discussed in the book, the session token
    field is optional, because only temporary AWS credentials use a session token.
    Regular IAM users only have an access key ID and secret access key, so in that
    case, you will leave the session token field empty. The key alias is an arbitrary
    name that we can assign to the set of access keys that we are adding in. It is
    for our (and Pacu''s) reference only, so choose something that makes sense to
    you. The following screenshot shows the output and input provided when running
    the `set_keys` command to add our AWS access tokens in the Pacu database. In our
    example, we chose `ExampleUser`, because that is the username of the user that
    the keys were created for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6ebcbb3-d9b8-4d24-a573-daee72dd788c.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding our example user to the Pacu database
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have named the set of keys as `ExampleUser`, which then replaced
    `No Keys Set` at the Pacu CLI prompt, which indicates that the `ExampleUser` key
    pair is our active set. The active set of keys is used for any authentication
    that Pacu makes with the AWS APIs. You can add additional sets of keys with the
    same `set_keys` command, but with a different key alias. If you specify an existing
    key alias when setting a pair of keys, it will overwrite any existing values under
    that key alias with what you input.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to swap between key pairs while within Pacu, we can use the aptly
    named `swap_keys` Pacu command. This will allow us to choose from a list of key
    pairs we have set up within this Pacu session. Let''s say that for this example
    we have `ExampleUser` and `SecondExampleUser` set up as key pairs within Pacu
    and we want to switch from `ExampleUser` to `SecondExampleUser`. All we will need
    to do is run the `swap_keys` command and select our desired key pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f459a94e-9572-4b29-85c4-dc9777c24727.png)'
  prefs: []
  type: TYPE_IMG
- en: Swapping between Pacu keys within a session
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, `ExampleUser` on the Pacu CLI changed
    to `SecondExampleUser`, which indicates that we have a new set of activated AWS
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: Pacu is essentially set up and ready to go at this point, but there are a few
    more things that we can do to customize our session if we wish, but we will cover
    that in the next section as we pass by those commands.
  prefs: []
  type: TYPE_NORMAL
- en: Pacu commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pacu has a variety of CLI commands that allow for flexible customization and
    interaction with your current session and any available modules that Pacu offers.
    In its current state, Pacu offers the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`list/ls`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`help`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`whoami`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`services`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regions`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update_regions`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_regions`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run/exec`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_keys`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`swap_keys`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import_keys`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exit/quit/Ctrl+C`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aws`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`proxy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following subsections will cover each of these commands, including a description,
    usage examples, and real-world use cases.
  prefs: []
  type: TYPE_NORMAL
- en: list/ls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `list` and `ls` commands are the same, and they list all the available
    Pacu modules, along with their categories. The following screenshot shows part
    of the output that is returned when running the `ls` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dddc4680-b77a-4155-994a-8178fe373ca2.png)'
  prefs: []
  type: TYPE_IMG
- en: Some of the modules and categories returned when running ls or list
  prefs: []
  type: TYPE_NORMAL
- en: search [[cat]egory] <search term>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `search` command does exactly what you might think – it searches modules.
    It is essentially the same as the `ls` command by returning the categories and
    modules, but it also returns a one-line description of each module that was searched
    to give you a better idea of what a certain module does. The reason for this is
    that the output of a search will almost certainly be smaller than just running
    `ls`, so there is room for a more specific output.
  prefs: []
  type: TYPE_NORMAL
- en: You can also search by category to list all the modules within that category
    by using the `cat` or `category` keyword as the section string in your search.
  prefs: []
  type: TYPE_NORMAL
- en: 'This following example will return all the modules that have `ec2` in their
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This following example will return all the modules that are in the `PERSIST` category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `category` can also be specified as `cat`, the shorthand way of getting
    all the modules in the `PERSIST` category will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the `search cat PERSIST` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b2cd999-c152-43c0-a9b1-e53993f20c90.png)'
  prefs: []
  type: TYPE_IMG
- en: All modules in the PERSIST category are returned
  prefs: []
  type: TYPE_NORMAL
- en: help
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `help` command simply outputs the help information for Pacu, which includes
    available commands and descriptions for each one. This prints the same data that
    is auto-printed on every Pacu startup.
  prefs: []
  type: TYPE_NORMAL
- en: help <module name>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `help` command also has another variation, where you can provide a module
    name and it will return the help information for that specific module. This data
    includes a long description (longer than the one-line description that shows up
    when you `search` a module), prerequisite modules, credits to who wrote the module,
    and all the available or required arguments. It's always a good idea to read the
    help documentation for a specific module before moving forward and using it because
    of the features and quirks you might miss otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `help` output for the `iam__enum_permissions` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af996bc7-d0b1-412f-9b8d-32d118abe09a.png)'
  prefs: []
  type: TYPE_IMG
- en: The help output for the iam__enum_permissions module
  prefs: []
  type: TYPE_NORMAL
- en: whoami
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `whoami` command will output all the information about the current set
    of active AWS keys. This means that if our active set is the `SecondExampleUser` user,
    then I will see information for that user and no one else. The following screenshot
    shows the output of the `whoami` command as the `SecondExampleUser` user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb7934a5-1125-4c2c-b548-d3db068f499d.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8*: The output of whoami for the SecondExampleUser user'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, almost everything is empty or null. This is because no modules
    have yet been run in the current session. As modules are run that provide information
    within this list, it will get filled in. As an example, I just ran the `iam__detect_honeytokens` module,
    which fills in some identifying information about my user. The following screenshot
    shows the updated output of the `whoami` command after collecting this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14bfe22a-46c8-4778-95e4-d5afe4ebfb41.png)'
  prefs: []
  type: TYPE_IMG
- en: Some of the output that has been populated from the iam__detect_honeytokens
    module
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the `UserName`, `Arn`, and `AccountId` fields have been updated,
    because that is the information that the `iam__detect_honeytokens` module fetches
    when it is run. Other modules fill in different information within this output,
    but the `iam__enum_permissions` module will fill out the most, because it enumerates
    a large amount of information about the current user and saves them to the local
    database.
  prefs: []
  type: TYPE_NORMAL
- en: data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `data` command will output all data that is stored in the currently active
    session, which includes AWS service data that has been enumerated, as well as
    configuration settings that have been defined during the duration of the session.
    The following screenshot shows the output of the `data` command at the point that
    we are at right now (that is, not having enumerated any AWS service data yet):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28418fa3-18f0-449e-8eac-7c0404bbe52e.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10*: The output of the data command without having enumerated any AWS
    data'
  prefs: []
  type: TYPE_NORMAL
- en: We can see both AWS keys that we have added to our session, some identifying
    information about the session, our modified user agent (because we are on Kali
    Linux), our active set of keys, session regions (discussed under the `set_regions` command
    section), and proxy data (discussed under the `proxy` command section).
  prefs: []
  type: TYPE_NORMAL
- en: 'If I run the `run ec2__enum --instances` command to enumerate EC2 instances
    in my target account, I should be able to fill up some EC2 data in the database,
    which will change the output of the `data` command. The following screenshot shows
    the new output of the `data` command, after enumerating EC2 instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d2b75b7-d1e6-492b-b645-9c110e309ad3.png)'
  prefs: []
  type: TYPE_IMG
- en: The new output of the data command, after enumerating EC2 instances
  prefs: []
  type: TYPE_NORMAL
- en: services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `services` command will output any AWS service that has data stored in
    the database. Given that we only have enumerated EC2 instances, EC2 should be
    the only service that has data stored in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c0feb06-9f71-48dd-aee3-0391a2ca3a05.png)'
  prefs: []
  type: TYPE_IMG
- en: The services command showing us that there is EC2 data in the database
  prefs: []
  type: TYPE_NORMAL
- en: This command goes nicely with the alternate form of the `data` command, which
    is explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: data <service>|proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This version of the `data` command allows you to request more specific information
    than the broad `data` command, especially because as multiple services and data
    types are stored in the database, the `data` command''s output can become rather
    large. We can pass this command any AWS service that has data in the database
    to get information on that particular service, or we can pass it the `proxy` keyword
    to get information on `PacuProxy` (as outlined under the `proxy` command section).
    We know that `services` output `EC2` as the only service we have data for, so
    we can run `data EC2` to fetch the associated EC2 data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18a2833d-61c7-4e68-a1d0-6dde243ab8d0.png)'
  prefs: []
  type: TYPE_IMG
- en: Fetching EC2 data with the data command
  prefs: []
  type: TYPE_NORMAL
- en: We can also run `data proxy`, but we won't get into that until later.
  prefs: []
  type: TYPE_NORMAL
- en: regions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `regions` command will list all the regions that Pacu supports, which generally
    is every public region available to AWS users. This command can help when running
    modules against a certain set of regions, or when using the `set_regions` command,
    which will be discussed in a later section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42b1c50c-e561-4d7b-87ef-bfa0dfc9677f.png)'
  prefs: []
  type: TYPE_IMG
- en: All the regions that are supported at this time are listed when running the
    regions command
  prefs: []
  type: TYPE_NORMAL
- en: update_regions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `update_regions` command generally does not need to be run by a regular
    Pacu user, but it is important to understand what it does for when you think you
    might need to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command runs a bash script that will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `python3 -m pip install --upgrade botocore` to update your botocore Python3
    library to the latest available version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `python3 -m pip show botocore` to locate the botocore installation folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it will read the `endpoints.json` file that is stored in the botocore
    folder to parse out what services are available and what regions are supported
    for those services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it will save that parsed data to the `./modules/service_regions.json` file
    in the Pacu folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pacu uses this as its guide for supported services and regions. The Pacu developers
    will update the region list along with any updates that are pushed to the GitHub
    repository, but there may be times between two Pacu updates that new regions become
    supported. In that case, it might make sense to run the `update_regions` command,
    but otherwise, you probably can leave it to the developers. The following screenshot
    shows the output of running the `update_regions` command, which fetches the latest
    version of the botocore Python library, then extracts the most up-to-date region
    list from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da5e472f-8c1f-47d5-be28-d896b271e3d0.png)'
  prefs: []
  type: TYPE_IMG
- en: Botocore being updated by the update_regions command
  prefs: []
  type: TYPE_NORMAL
- en: set_regions <region> [<region>...]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `set_regions` command is one of the most important to understand while learning
    to use Pacu. When used correctly, it can greatly reduce the amount of API calls
    that are made to a target environment, ultimately keeping our footprint in the
    environment smaller.
  prefs: []
  type: TYPE_NORMAL
- en: The `set_regions` command is what controls the value of the `session regions` configuration
    option. Basically, this command is used to tell Pacu that you only want to target
    region's *x*, *y*, and *z* in your current session. An example scenario of where
    this could come in handy is when you are attacking an environment that only uses
    a couple of regions for its entire infrastructure. By default, Pacu will prompt
    you to ensure whether you would like to target every region when running a module
    with the `--regions` argument omitted, but why do that if you already know that
    only a couple of the regions will have valid results? Ultimately, it ends up in `wasted` API
    calls that risk us being detected by a defender and provide us virtually no benefit.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the `set_regions` command, you supply it one or more AWS regions
    (which are listed in the output of the `regions` command). Then, Pacu will only
    ever target those regions with API calls. If you know that your target only uses
    EC2 in two regions, `us-west-2` and `us-east-1`, then you will run `set_regions
    us-west-2 us-east-1`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87072c16-8f31-4f3e-8d03-69ae743dba24.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting our session regions to us-west-2 and us-east-1
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we want, we can run the `data` command again, which will have a different
    value for `session_regions` than we saw earlier. It will now contain two strings: `us-west-2` and
    `us-east-1`.
  prefs: []
  type: TYPE_NORMAL
- en: When session regions are set, Pacu will react accordingly when running a module.
    When you run a module that accepts `--regions` as an argument, but omit that argument,
    Pacu will first fetch all the supported regions for the service that is being
    targeted, then compare that list to the list of session regions set by the user.
    Then, it will only target regions that are in both lists. This prevents you from
    ever running a module against a region that is not supported by the specific AWS
    service, and it prevents you from ever running a module against any regions that
    you did not intend.
  prefs: []
  type: TYPE_NORMAL
- en: 'The set of session regions can be changed at any time and the `all` keyword
    can be used to go back to targeting every region (the default). It will be used
    just like a region is, as `set_regions all`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21f9406b-955e-4c16-b441-a2087b10ea12.png)'
  prefs: []
  type: TYPE_IMG
- en: A warning that we are targeting every AWS region, prior to using the set_regions
    command to modify our targets
  prefs: []
  type: TYPE_NORMAL
- en: run/exec <module name>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `run` and `exec` commands do the same thing, in that they run modules. Let's
    say we want to run the `ec2__enum` module. We could first run `help ec2__enum` to
    get some information about it, including what arguments are supported. Then, we
    could run the module with `run` or `exec` and pass any arguments in with that
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to enumerate EC2 instances in the `us-east-1` region, we could
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/b798613a-9831-4b8b-9ca8-bfa250874c96.png)'
  prefs: []
  type: TYPE_IMG
- en: Running the ec2__enum module with the instances and regions arguments
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we specified the `--instances` argument to only enumerate EC2
    instances, and we specified the `--regions` argument to only enumerate EC2 instances
    in the `us-east-1` region.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot also brings up another important point of module output
    – the module summary section. Every module has a module summary and the point
    of this is to provide output from the module in a small section of output. Sometimes,
    depending on the configuration of the module that you are running, the output
    can span multiple screens and potentially be so long that it goes beyond your
    Terminal's history. To help try and solve this problem, module summaries were
    introduced to provide a summary of the findings or actions that the module performed
    throughout its execution.
  prefs: []
  type: TYPE_NORMAL
- en: set_keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've used the `set_keys` command a few times now throughout this book. This
    command is used to add sets of keys to the current Pacu session, or to update
    any existing sets of keys. As we've seen before, if you run the `set_keys` command
    without any keys already set, you will be setting up the first or default set
    of keys in Pacu. After that, the `set_keys` command will automatically try and
    update the active set of keys with the default values it supplies, but you can
    change that to add another set of keys by modifying the key alias that you are
    prompted for.
  prefs: []
  type: TYPE_NORMAL
- en: The key alias associated with a set of keys is essentially only for yourself,
    so you can identify what keys they are when it is ready. Usually, this means it
    makes the most sense to set the key alias to the name of the user or role who
    owns the keys. In other situations, it might make more sense to describe the access
    that the set of keys was provided. Say that a client who are doing a pentest for
    sends you two sets of keys, one that has administrator level access and one that
    has developer level access. In that case, it could make more sense to name them
    `Administrator` and `Developer`, or something along those lines, rather than what
    their usernames are.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have already noticed, any place that Pacu is storing your secret
    access key and it needs to be reflected onto the screen, Pacu will censor that
    value. This is so that secret access keys are not logged to the Pacu command/error
    log, so that any other logs or over-the-shoulder peekers do not have access either.
  prefs: []
  type: TYPE_NORMAL
- en: swap_keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've also already looked at the `swap_keys` command, but this command is useful
    when working with a session that contains multiple sets of active keys. By running
    `swap_keys`, you will be presented with a list of available keys that you have
    previously added to your session, from which you then can choose which becomes
    the active set. The active set is the set of keys that is used to authenticate
    to AWS when running any modules that do so.
  prefs: []
  type: TYPE_NORMAL
- en: import_keys <profile name>|--all
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `import_keys` command is meant to make it a bit easier to bridge the gap
    between Pacu and the AWS CLI. This command will import credential profiles from
    the AWS CLI and create a new set of keys in the active session with that information.
    If we want to import a single AWS CLI profile, you can just name it in the command,
    like in the following screenshot, where `import_keys default` is run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac5d1799-fb00-43b6-acb4-d76a73d61450.png)'
  prefs: []
  type: TYPE_IMG
- en: Importing the keys for the default profile of the AWS CLI
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, we imported the `default` AWS CLI profile
    as the `imported-default` key alias to indicate that these keys were imported,
    and the profile name was `default`. We can also see that the active key set switched
    from `SecondExampleUser` to `imported-default`. We could just use the `swap_keys` command
    to switch them back if required.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the `--all` flag instead of an AWS CLI profile name, to which
    Pacu will import every AWS CLI profile that it can find:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3e45c17-beba-42cf-b7de-5778c061baab.png)'
  prefs: []
  type: TYPE_IMG
- en: Importing multiple key pairs from the AWS CLI with the --all argument
  prefs: []
  type: TYPE_NORMAL
- en: exit/quit/Ctrl + C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Entering the `exit` or `quit` commands, or pressing the *Ctrl* + *C* keys on
    your keyboard, will cause Pacu to exit gracefully if you are at the main menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84c2dcd7-79d2-4ed2-ab73-eab27ae7f84e.png)'
  prefs: []
  type: TYPE_IMG
- en: Quitting Pacu and returning to my Terminal
  prefs: []
  type: TYPE_NORMAL
- en: '*Ctrl* + *C* also has another use; when a module is mid-execution and *Ctrl*
    + *C* is pressed, that module''s execution will exit, and you will drop back to
    the main Pacu CLI. The following screenshot shows the use of *Ctrl* + *C* to exit
    the execution of the `ec2__enum` module (`^C` is how *Ctrl* + *C* shows up in
    the Terminal):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6ee2ff2-9bc4-472f-917f-3e39beddfe14.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the *Ctrl* + *C* key combination to exit the ec2__enum module
  prefs: []
  type: TYPE_NORMAL
- en: aws <command>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `aws` command is a little different than the other Pacu commands. This is
    essentially a command that directly integrates the AWS CLI into Pacu, so you can
    run AWS CLI commands without needing to exit out of Pacu. The way it works is
    if Pacu detects a command that is run that starts with `aws` as the first word,
    it will drop the entire command to the bash shell on the host. This means you
    can treat any `aws` command within Pacu as if it were a `bash` command, because
    it is. This allows you to pipe or redirect the output of your AWS CLI command
    to wherever you need it on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Something extremely important to note is that Pacu and the AWS CLI use two separate
    methods of credential storage. Pacu handles its credentials independently, and
    the AWS CLI handles its credentials separately. This means that if you are within
    Pacu with `SecondExampleUser` as your active set of keys, the AWS CLI will **not**
    use those same credentials, unless you specify it correctly within the AWS CLI.
    The AWS CLI will act normally, as if you ran it from the `bash` command line,
    so that means the `default` AWS CLI profile will be used automatically, unless
    you specify a separate profile with the `--profile` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `aws ec2 describe-instances` command being
    run from within Pacu, and because it is passed to the bash shell, it is then piped
    into `grep` so that the output can be searched for the `ImageId` word and we can
    see the image ID of the EC2 instance that was found:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad90bcfd-220b-49fc-aec1-5c9d19c3ce68.png)'
  prefs: []
  type: TYPE_IMG
- en: Grepping ImageId from the output of an ec2 describe-instances API call
  prefs: []
  type: TYPE_NORMAL
- en: We didn't specify an AWS CLI profile to use, so it automatically used the default
    profile, not the `SecondExampleUser` Pacu key pair.
  prefs: []
  type: TYPE_NORMAL
- en: proxy <command>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `proxy` command is associated with the built-in command and control feature
    known as `PacuProxy`. The `proxy` command accepts a few different sub-commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`start <ip> [port]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stop`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kill <agent_id>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list/ls`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`use none|<agent_id>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shell <agent_id> <command>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetch_ec2_keys <agent_id>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stager sh|ps`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We aren't going to dive deep into what each of these commands do, but we will
    look at PacuProxy in the *An introduction to PacuProxy* section at the end of
    this chapter at a higher level. This is because `PacuProxy` is still in development
    and the current release version is not necessarily final, but the overarching
    theme and goal of it is staying the same. If you are interested in reading about
    the more advanced offerings of Pacu and PacuProxy, you can visit the *Advanced
    Capabilities* section of the Pacu Wiki on GitHub here: [https://github.com/RhinoSecurityLabs/pacu/wiki/Advanced-Capabilities](https://github.com/RhinoSecurityLabs/pacu/wiki/Advanced-Capabilities).
  prefs: []
  type: TYPE_NORMAL
- en: These proxy commands will be used when trying to deal with compromised EC2 hosts
    within a target AWS account, but we'll explore that later.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pacu was designed to allow external contribution to itself and the modules included
    with it. That's why it was built the way it was and released under the BSD-3 open
    source license. It is written in Python3 so all of its modules are written in
    Python3 as well.
  prefs: []
  type: TYPE_NORMAL
- en: Pacu comes with a template that is stored in the `./modules/template.py` file,
    which makes it easy to get started on your own modules. It includes everything
    that is required to make your module work, along with some examples of how you
    might use different APIs exposed by the Pacu core program to make building your
    module easier.
  prefs: []
  type: TYPE_NORMAL
- en: The API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before getting started, it is useful to understand what methods are available
    to you through the Pacu core API. Some of the more important methods are listed
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`session/get_active_session`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_proxy_settings`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print/input`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`key_info`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetch_data`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_regions`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install_dependencies`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_boto3_client/get_boto3_resource`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: session/get_active_session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `session` variable is created at the beginning of the main function of every
    Pacu module. It is defined by calling the `get_active_session` Pacu API (which
    is imported as `pacu_main`). This variable contains all the information about
    the current Pacu session, including authentication information, AWS service data,
    and really anything else that is stored by Pacu.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could copy all the data that is stored for the EC2 service with something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you could make modifications to `ec2_data`, and when you are ready to
    write that to the database, you can use the `update` method on `session`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This line essentially updates the `EC2` section of the `pacu_main.database` database
    with what is stored in `ec2_data`. It is best to treat the session object as if
    the data is immutable, and then to update it at the end, after you have made your
    data modifications. This prevents issues with the database content when the module
    encounters an error during execution.
  prefs: []
  type: TYPE_NORMAL
- en: get_proxy_settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `pacu_main.get_proxy_settings` method is used to pull information about
    `PacuProxy` in the current session. This method will likely not be used in any
    normal use case module and will likely make more sense in a `PacuProxy` specific
    module that needs to interact with/read from the proxy settings of the session.
  prefs: []
  type: TYPE_NORMAL
- en: print/input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `print` and `input` methods are imported from `pacu_main`, and they are
    used to override the default `print` and `input` methods that come with Python.
    Both overrides allow for any text or output that is printed to the screen to also
    be written to the Pacu activity log. They add a few arguments as well, which let
    you customize how things will be printed. For instance, perhaps you just want
    to print something to the command log, but not the screen; in this case, you could
    use the `output='file'` argument. Or, maybe you want to only print to the output
    to the screen, but keep it out of the command log, in which case you could use
    the `output='screen'` argument.
  prefs: []
  type: TYPE_NORMAL
- en: The `print` command will also accept JSON dictionaries as its value, where it
    will then use the `json` library to dump the output in a formatted, easy-to-read
    view. In these cases where the output is a dictionary, the `print` function will
    recursively scan the dictionary for any occurrences of `SecretAccessKey`. If it
    finds any, it will censor the value of it prior to printing or logging, so that
    your secret keys are not logged to the Pacu screen/command log in cleartext.
  prefs: []
  type: TYPE_NORMAL
- en: key_info
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `key_info` method is used to fetch information about the active set of AWS
    keys in your current session. The data returned closely resembles the output of
    the `whoami` command in the Pacu CLI, but this provides a programmatic interface
    for retrieving the data. You could set the value of the variable named `user` to
    `key_info()`, where you will then be able to access identifying information for
    the current user (such as name, ARN, and account ID), as well as permissions that
    have been enumerated from the `iam__enum_permissions` module.
  prefs: []
  type: TYPE_NORMAL
- en: fetch_data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fetch_data` method is used to allow module developers to write modules
    with a specific goal in mind. For example, someone who is writing a module that
    changes a setting on EC2 instances shouldn't have to worry about enumerating EC2
    instances. They should be able to just assume the data is available and write
    their code to work with it like that. Behind the scenes, the `fetch_data` function
    takes the arguments you pass in, which include the data being requested, the module
    that enumerates that data if it isn't available, and any additional arguments
    to pass to that module when running it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: On the first line, we see that an `if` statement is checking if the return value
    of `fetch_data` is false, and then reporting that the prerequisite module did
    not run successfully, so it is quitting the current module.
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted to work with EC2 security groups in your own module, you will
    use this code block to fetch that data. First, the `fetch_data` method will check
    the local Pacu database to see if it has enumerated anything for EC2 security
    groups yet. If it has, it will return `true` and the module-writer can assume
    that data is in the database now. If `fetch_data` does not find the data in the
    database, it will then run the module that is passed in as the second argument,
    with the flags passed in as the third argument. In this case, if EC2 security
    groups are not found, it will run the `ec2__enum` module and pass it the `--security-groups` argument.
  prefs: []
  type: TYPE_NORMAL
- en: The module will then execute and enumerate the required data. If it is successful
    it will return `true` and the original module will continue its own execution.
    However, if it is not successful, it will return `false` to indicate that it could
    not enumerate the necessary data for a reason that should be displayed to the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: get_regions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `get_regions` method is provided so that as a module developer, you never
    need to worry about what regions you need or want to target. All you need to do
    is write your module as if every single time it runs, it runs against a list of
    regions. You can use `get_regions` to fetch that list of regions and you only
    need to provide it with an AWS service name. The line `get_regions('EC2')` will
    return all regions that support the EC2 service.
  prefs: []
  type: TYPE_NORMAL
- en: If the user has set session regions with the `set_regions` command, then `get_regions('EC2')` will
    return only the regions that support EC2 and are in the list of session regions.
    For this reason, you never really need to think about regions as a module developer,
    you just need to assume that there could be any number that you might need to
    target and that you aren't provided with this information at the time of writing
    your module.
  prefs: []
  type: TYPE_NORMAL
- en: install_dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `install_dependencies` method is essentially deprecated, because at the
    time of writing, only one module uses it and there has been talk of plans to integrate
    this functionality in a different way. Right now, it is used to install external
    dependencies that a module requires.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the one module that uses this method is the `s3__bucket_finder` module
    that uses Git to clone a third-party tool that it uses, and it also downloads
    a wordlist that it requires. This can be helpful if a dependency is another Git
    repository itself, or is too large to regularly include in Pacu.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the lack of use of this method and other safety concerns, this feature
    will likely be removed from Pacu soon.
  prefs: []
  type: TYPE_NORMAL
- en: get_boto3_client/get_boto3_resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `get_boto3_client` and `get_boto3_resource` methods allow you to interact
    with the boto3 Python library without having to worry about a bunch of configuration
    options. Due to the requirements for `PacuProxy`, the GuardDuty Kali/Parrot/Pentoo
    user agent bypass, and authentication, all the complicated configuration options
    have been abstracted from what module developers see. On the back side, it is
    still possible to modify those configurations if you really need to, but it is
    highly unlikely that a module will require this type of granularity.
  prefs: []
  type: TYPE_NORMAL
- en: 'These functions make it so that creating a `boto3` client in a single region
    could begin with this following mess:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can turn it into this much cleaner, shorter line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Both of those lines of code essentially do the same thing within Pacu, but the
    first one is much longer and requires lots of information that you shouldn't have
    to worry about as a module developer.
  prefs: []
  type: TYPE_NORMAL
- en: Module structure and implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is easy to learn about the Pacu module structure by just reviewing the content
    in the template module file that is included with Pacu. Each line and section
    in this file is commented to describe what it is doing and why you would do it
    that way. If you're more into a concrete example, then it might make sense to
    check out the code of some of the enumeration modules, as they tend to be a bit
    simpler, and they all interact with the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we wanted to write a module that enumerates what buckets exist in
    the account, and then save that information to the Pacu database. Overall, this
    should be a pretty simple module to make. We''ll go one step further, and even
    consider that have a script written that enumerates S3 buckets and prints them
    out already. That script might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is a very simple script with some small error handling, but it is not very
    flexible in its usage, as currently it will only use the default AWS CLI profile
    to authenticate, because no credentials were specified when creating the boto3
    client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at a clean module template. This is what the template
    looks like after removing all the commands and some of the example script that
    we won''t be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have already filled in the `module_info` variable with the necessary data
    that explains our S3 enumeration module, so all we need to do now is port our
    code over. Also, we have removed any imports from `pacu_main` that weren't going
    to be used in this module, such as the `input` override. This is because we won't
    be asking the user for input in the module, but we will be printing text, so we
    are keeping the `print` override.
  prefs: []
  type: TYPE_NORMAL
- en: If we go back to the original S3 script that we have, we can basically just
    copy over the try/except block into the Pacu module's `main` method. Then, we
    will need to make a couple of changes. We don't want to create a boto3 client
    with `boto3.client` anymore, but instead, we want to use `pacu_main.get_boto3_client`,
    so we will replace `client = boto3.client('s3')` with `client = pacu_main.get_boto3_client('s3')`.
    You may have noticed at the top of the `from botocore.exceptions import ClientError` template
    file, which means we can change our error handling from `botocore.exceptions.ClientError` to
    `ClientError` and it will work the same as before.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of printing out the buckets, we want to store them somewhere that we
    can reference in the summary, in the function, and within the Pacu database.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we will declare a `data` variable that will hold all the relevant
    data during the module's execution, and it will have a `Buckets` key that holds
    the bucket information returned from AWS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now our S3 script has changed from what we previously saw to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now we have the list of bucket names, so we will use the `session` variable
    to store them in the database. In this case, we don't care about what S3 data
    was already stored in the database, because we are enumerating a new list rather
    than updating anything existing. For this reason, we don't need to copy the data
    out of the database, update it, and then put it back in. We can just overwrite
    it with our update.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once that is complete, the database will hold an object with a list of S3 buckets
    in the S3 section, and will be fetchable for any user of the current session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the module is done. To integrate it into Pacu, we can just create a new
    folder named `s3__enum` in the modules folder of Pacu (because that''s what we
    named it in the `module_info` section), save the module script as `main.py` within
    that folder, create an empty `__init__.py` file in that folder as well, and start
    Pacu up. We should not be able to see our module when listing them or searching
    through them, which means we should also now be able to execute it and receive
    valid results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79831874-b3d2-4189-9228-0962625218fd.png)'
  prefs: []
  type: TYPE_IMG
- en: Searching for and running our new module
  prefs: []
  type: TYPE_NORMAL
- en: It is simple, but within minutes we were able to convert a regular Python script
    to a Pacu module with very little trouble.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final code of the entire module turned out to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as a final note, if we run the `services` command within the same session
    we were working in earlier, it should now contain data for both EC2 and S3, as
    expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96714861-a45d-4d2b-8c0f-15f566bcdc4f.png)'
  prefs: []
  type: TYPE_IMG
- en: Services outputs both EC2 and S3 because they each have data in the database
    now
  prefs: []
  type: TYPE_NORMAL
- en: This also means we could run the `data S3` command to fetch any S3 data if we
    were so inclined.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to PacuProxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**PacuProxy** has been brought up a number of times in this book, but usually
    it has been casually glanced over. This is because PacuProxy aims to solve a very
    specific problem when attacking AWS environments that is generally beyond the
    security posture of most companies moving to the cloud. At a very basic level,
    PacuProxy is just another command and control framework, such as PowerShell Empire
    and Meterpreter, but PacuProxy is more cloud-oriented than other similar tools.'
  prefs: []
  type: TYPE_NORMAL
- en: The important feature of PacuProxy (outside of just general C2 features, such
    as payload generation, agent handling, and modules) is that it directly integrates
    into Pacu's workflow. This means that when you compromise a server, such as an
    EC2 instance, you can use PacuProxy as your C2 channel and basically proxy your
    Pacu traffic through the compromised instance. This allows you to use all the
    features that Pacu offers from your own computer, but all the traffic is routed
    through the compromised host. When a defender looks at the logs and notices your
    malicious traffic, the compromised EC2 instance will show up as the source of
    the traffic, which will look a lot less suspicious than a random IP address they
    are unfamiliar with.
  prefs: []
  type: TYPE_NORMAL
- en: PacuProxy also has its own set of modules that can be run, along with the ability
    to integrate functionality into normal Pacu modules. One example is the `systemsmanager__rce_ec2` module.
    The module abuses the AWS Systems Manager service to try and execute code remotely
    on EC2 instances, but integration with PacuProxy is built in, so if you run that
    module without specifying what command to run on an instance and you have PacuProxy
    listening, it will automatically generate a one-line stager and execute that on
    the host, giving you full control of it.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a PacuProxy specific module is stealing credentials from the EC2
    metadata service. You could run the module and it will make HTTP requests to the
    metadata service on that server to fetch any credentials that might live there,
    then create a new set of keys within Pacu, using those credentials. Then, you'd
    be able to route all those requests through the compromised host, never alerting
    GuardDuty or anyone else that a compromise has happened, even though everything
    is installed and being run on your own host machine.
  prefs: []
  type: TYPE_NORMAL
- en: PacuProxy is still in the early stages of what was in mind when it was first
    created, so the more technical details have been withheld in this section, because
    any of those that are supplied may become outdated soon.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pacu offers a wide range of capabilities and the ability to extend upon existing
    functionality. It was the first modular attack tool created for penetration testing
    AWS environments, and due to its backing should be in development for a long time
    to come. It is a great asset to take advantage of when attacking AWS environments,
    but it is not a catch-all, so it is important to learn the fundamentals of attacking
    AWS as well, rather than relying on someone else to automate everything for you.
  prefs: []
  type: TYPE_NORMAL
- en: Pacu is still in active development, so features may change, be added, or be
    removed since the time of writing, so it is important to take that into account
    when running into issues. The Pacu developers are available to respond to issues
    and pull requests that are opened in GitHub, so that is likely to be the best
    resource for support with running Pacu.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered the basic usage of Pacu and the commands that it
    offers. We also took a look at writing our first module for it. Hopefully, you
    can walk away from this chapter and be able to use Pacu efficiently and effectively
    to perform various attacks during your AWS pentests.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to take it a step further and cover the process
    of an AWS pentest from start to beginning. This will help us get a grasp on real-world
    AWS pentesting scenarios, how and when we will use tools such as Pacu, and how
    to work around our client's needs and desires.
  prefs: []
  type: TYPE_NORMAL
