- en: Thinking Functionally - A First Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [chapter 1](395f5897-0ecc-4841-86ed-21521e148beb.xhtml), *Becoming Functional
    - Several Questions*, we went over what FP is, mentioned some advantages of applying
    it, and listed some tools we'd be needing in JS... but let's now leave theory
    behind, and start out by considering a simple problem, and how to solve it in
    a functional way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will see:'
  prefs: []
  type: TYPE_NORMAL
- en: A simple, common, e-commerce related problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several usual ways to solve it, with their associated defects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way to solve the problem by looking at it functionally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A higher-order solution, which can be applied to other problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do unit testing for the functional solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In future chapters, We'll be coming back to some of the topics listed here,
    so we won't be getting very much into details. We'll just show how FP can give
    a different outlook for our problem, and leave further details for afterward.
  prefs: []
  type: TYPE_NORMAL
- en: The problem - do something only once
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s consider a simple, but common situation. You have developed an e-commerce
    site: the user can fill their shopping cart, and at the end, they must click on
    a BILL ME button, so their credit card will be charged. However, the user shouldn''t
    click twice (or more) or they would be billed several times.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML part of your application might have something like this, somewhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And, among the scripts you''d have something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Assigning the events handler directly in HTML, the way I did it, isn't recommended.
    Rather, in *unobtrusive* fashion, you should assign the handler through code.
    So... *Do as I say, not as I do*!
  prefs: []
  type: TYPE_NORMAL
- en: This is a very barebones explanation of the problem and your web page, but it's
    enough for our purposes. Let's now get to think about ways of avoiding repeated
    clicks on that button... *How can we manage to avoid the user clicking more than
    once?*
  prefs: []
  type: TYPE_NORMAL
- en: Some bad solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OK, how many ways can you think of, in order to solve our problem? Let's go
    over several solutions, and analyze their quality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution #1 - hope for the best!'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How can we solve the problem? The first *solution* may seem like a joke: do
    nothing, tell the user *not* to click twice, and hope for the best! Your page
    might look as Figure 2.1.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dee3094d-17b8-4d14-8b95-e3d3145d180a.png)Figure 2.1\. An actual
    screenshot of a page, just warning you against clicking more than once'
  prefs: []
  type: TYPE_NORMAL
- en: This is a weasel way of avoiding the problem, but I've seen several websites
    that just warn the user about the risks of clicking more than once (see Figure
    2.1) and actually do nothing to prevent the situation... *the user got billed
    twice? we warned them... it's their fault!* Your solution might simply look as
    the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: OK, so this isn't actually a solution; let's move on to more serious proposals...
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution #2 - use a global flag'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The solution most people would probably think of first, is using some global
    variable to record whether the user has already clicked on the button. You''d
    define a flag named something like `clicked`, initialized with `false`. When the
    user clicks on the button, if `clicked` was `false`, you change it to `true`,
    and execute the function; otherwise, you don''t do anything at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For more good reasons NOT to use global variables,
  prefs: []
  type: TYPE_NORMAL
- en: read [http://wiki.c2.com/?GlobalVariablesAreBad](http://wiki.c2.com/?GlobalVariablesAreBad).
  prefs: []
  type: TYPE_NORMAL
- en: 'This obviously works, but it has several problems that must be addressed:'
  prefs: []
  type: TYPE_NORMAL
- en: You are using a global variable, and you could change its value by accident.
    Global variables aren't a good idea, neither in JS nor in other languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must also remember to re-initialize it to `false` when the user starts buying
    again. If you don't, the user won't be able to do a second buy, because paying
    will have become impossible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will have difficulties testing this code, because it depends on external
    things (that is, the `clicked` variable).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, this isn't a very good solution... let's keep thinking!
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution #3 - remove the handler'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We may go for a lateral kind of solution, and instead of having the function
    avoid repeated clicks, we might just remove the possibility of clicking altogether:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This solution also has some problems:'
  prefs: []
  type: TYPE_NORMAL
- en: The code is tightly coupled to the button, so you won't be able to reuse it
    elsewhere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must remember to reset the handler, otherwise the user won't be able to
    make a second buy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing will also be harder, because you'll have to provide some DOM elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can enhance this solution a bit, and avoid coupling the function to the
    button, by providing the latter''s ID as an extra argument in the call. (This
    idea can also be applied to some of the following solutions.) The HTML part would
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '(note the extra argument) and the called function would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This solution is somewhat better. But, in essence, we are still using a global
    element: not a variable, but the `onclick` value. So, despite the enhancement,
    this isn''t a very good solution either. Let''s move on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution #4 - change the handle'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A variant to the previous solution would be not removing the click function,
    and rather assign a new one instead. We are using functions as first class objects
    here, when we assign the `alreadyBilled()` function to the click event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a good point to this solution: if the user clicks a second time, they''ll
    get a warning not to do that, but they won''t be billed again. (From the point
    of view of the user experience, it''s better.) However, this solution still has
    the very same objections as the previous one (code coupled to the button, need
    to reset the handler, harder testing), so we won''t consider it to be quite good
    anyway.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution #5 - disable the button'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A similar idea: instead of removing the event handler, disable the button,
    so the user won''t be able to click. You might have a function like the following.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This also works, but we still have objections as for the previous solutions
    (coupling the code to the button, need to re-enable the button, harder testing),
    so we don't like this solution either.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution #6 - redefine the handler'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another idea: instead of changing anything in the button, let''s have the event
    handler change itself. The trick is in the second line; by assigning a new value
    to the `billTheUser` variable, we are actually dynamically changing what the function
    does! The first time you call the function, it will do its thing... but it will
    also change itself out of existence, by giving its name to a new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There's a special trick in the solution. Functions are global, so the line `billTheUser=...`
    actually changes the function's inner workings; from that point on, `billTheUser`
    will be the new (null) function. This solution is still hard to test. Even worse,
    how would you restore the functionality of `billTheUser`, setting it back to its
    original objective?
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution #7- use a local flag'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can go back to the idea of using a flag, but instead of making it global
    (which was our main objection) we can use a *Immediately Invoked Function Expression
    (IIFE)*: we''ll see more on this in [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting Out with Functions - A Core Concept*, and in [Chapter 11](24b391f7-abaf-439e-9bfc-a71d989cfd48.xhtml),
    *Implementing Design Patterns - The Functional Way*. With this, we can use a closure,
    so `clicked` will be local to the function, and not visible anywhere else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: See how `clicked` gets its initial `false` value, from the call at the end.
  prefs: []
  type: TYPE_NORMAL
- en: This solution is along the lines of the global variable solution, but using
    a private, local variable is an enhancement. About the only objection we could
    find, is that you'll have to rework every function that needs to be called only
    once, to work in this fashion. (And, as we'll see in the following section, our
    FP solution is similar in some ways to it.) OK, it's not too hard to do, but don't
    forget the *Don't Repeat Yourself (D.R.Y)* advice!
  prefs: []
  type: TYPE_NORMAL
- en: A functional solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try to be more general: after all, requiring that some function or other
    be executed only once, isn''t that outlandish, and may be required elsewhere!
    Let''s lay down some principles:'
  prefs: []
  type: TYPE_NORMAL
- en: The original function (the one that may be called only once) should do that
    thing, and no other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't want to modify the original function in any way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to have a new function that will call the original one only once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want a general solution that we can apply to any number of original functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first principle listed previously is the *single responsibility principle*
    (the *S* in S.O.L.I.D.), which states that every function should be responsible
    over a single functionality. For more on S.O.L.I.D., check the article by *Uncle
    Bob* (Robert C. Martin, who wrote the five principles) at [http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod).
  prefs: []
  type: TYPE_NORMAL
- en: Can we do it? Yes; and we'll write a *higher-order function*, which we'll be
    able to apply to any function, to produce a new function that will work only once.
    Let's see how!
  prefs: []
  type: TYPE_NORMAL
- en: A higher-order solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we don't want to modify the original function, we'll create a higher-order
    function, which we'll, inspiredly, name `once()`. This function will receive a
    function as a parameter and will return a new function, which will work only a
    single time. (We'll be seeing more of higher-order functions in [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher-Order Functions*; in particular, see section *Doing
    things once, revisited*.)
  prefs: []
  type: TYPE_NORMAL
- en: Underscore and LoDash already has a similar function, invoked as `_.once()`.
    Ramda also provides `R.once()`, and most FP libraries include similar functionality,
    so you wouldn't have to program it on your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `once()` function way seems imposing at first, but as you get accustomed
    to working in FP fashion, you''ll get used to this sort of code, and will find
    it to be quite understandable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go over some of the finer points of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line shows that `once()` receives a function (`fn()`) as its parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are defining an internal, private `done` variable, by taking advantage of
    a closure, as in Solution #7, previously. We opted *not* to call it `clicked`,
    as previously, because you don''t necessarily need to click on a button to call
    the function; we went for a more general term.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The line `return (...args) => ...` says that `once()` will return a function,
    with some (0, 1, or more) parameters. Note that we are using the spread syntax
    we saw in [Chapter 1](395f5897-0ecc-4841-86ed-21521e148beb.xhtml), *Becoming Functional
    - Several Questions*. With older versions of JS you'd have to work with the `arguments`
    object; see [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments)
    for more on that. The ES8 way is simpler and shorter!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We assign `done = true` before calling `fn()`, just in case that function throws
    an exception. Of course, if you don't want to disable the function unless it has
    successfully ended, then you could move the assignment just below the `fn()` call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the setting is done, we finally call the original function. Note the use
    of the spread operator to pass along whatever parameters the original `fn()` had.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, how would we use it? We don''t even need to store the newly generated function
    in any place; we can simply write the `onclick` method, as shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Pay close attention to the syntax! When the user clicks on the button, the function
    that gets called with the `(some, sales, data)` argument isn't `billTheUser()`,
    but rather the result of having called `once()` with `billTheUser` as a parameter.
    That result is the one that can be called only a single time.
  prefs: []
  type: TYPE_NORMAL
- en: Note that our `once()` function uses functions as first-class objects, arrow
    functions, closures, and the spread operator; back in [Chapter 1](395f5897-0ecc-4841-86ed-21521e148beb.xhtml),
    *Becoming Functional - Several Questions*, we said we'd be needing those, so we're
    keeping our word! All we are missing here from that chapter is recursion... but
    as the Rolling Stones sing, *You Can't Always Get What You Want!*
  prefs: []
  type: TYPE_NORMAL
- en: Testing the solution manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can run a simple test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Check out the results at CodePen, or see Figure 2.2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9da8b8c3-1f00-43a6-aa85-f5775c217d61.png)Figure 2.2 - Testing our
    once() higher-order function'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the solution automatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running tests by hand is no good; it gets tiresome, boring, and that leads,
    after time, to not running the tests any longer. Let''s do better, and write some
    automatic tests with Jasmine. Following the instructions over at [https://jasmine.github.io/pages/getting_started.html](https://jasmine.github.io/pages/getting_started.html),
    I set up a standalone runner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `src/once.js` file has the `once()` definition that we just saw, and `tests/once.test.js`
    has the actual suite of tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several points to note here:'
  prefs: []
  type: TYPE_NORMAL
- en: In order to spy on a function, it must be associated with an object. (Alternatively,
    you can also directly create a spy using Jasmine's `.createSpy()` method.) Global
    functions are associated with the window object, so `window.fn` is a way of saying
    that `fn` is actually global.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you spy on a function, Jasmine intercepts your calls and registers that
    the function was called, with what arguments, and how many times it was called.
    So, for all we care, `window.fn` could simply be `null`, because it will never
    be executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first test only checks that if we call the function several times, it gets
    called that number of times. This is trivial, but if that didn't happen, we'd
    be doing something really wrong!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second group of tests, we want to see that the `once()`-ed function (`window.onceFn()`)
    gets called, but only once. So, we tell Jasmine to spy on `onceFn`, but let calls
    pass through. Any calls to `fn()` will also get counted. In our case, as expected,
    despite calling `onceFn()` three times, `fn()` gets called only once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see the results in Figure 2.3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6e6a785f-7021-4ca4-96ec-08040b7ea624.png)Figure 2.3 - Running automatic
    tests on our function, with Jasmine'
  prefs: []
  type: TYPE_NORMAL
- en: An even better solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In one of the previous solutions, we mentioned that it would be a good idea
    to do something every time after the first, and not silently ignoring the user''s
    clicks. We''ll write a new higher-order function, that takes a second parameter;
    a function to be called every time from the second call onward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We have ventured further in higher-order functions; `onceAndAfter` takes *two*
    functions as parameters and produces a third one, which includes the other two
    within.
  prefs: []
  type: TYPE_NORMAL
- en: You could make `onceAndAfter` more powerful, by giving a default value for `g`,
    along the lines of `const onceAndAfter = (f, g = ()=>{})` ... so if you didn't
    want to specify the second function, it would still work fine, because it would
    call a *do nothing* function, instead of causing an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do a quick-and-dirty test, along with the same lines as we did earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing a test for this new function isn''t hard, only a bit longer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we always check that `func1` is called only once. Similarly, we
    check `func2`; the count of calls starts at zero (the time that `func1` is called),
    and from then on, it goes up by one on each call.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2.1\. **No extra variables**: Our functional implementation required using
    an extra variable, `done`, to mark whether the function had already been called.
    Not that it matters... but could you make do without using any extra variables?
    Note that we aren''t telling you *not* to use any variables; it''s just a matter
    of not adding any new ones, such as `done`, and only as an exercise!'
  prefs: []
  type: TYPE_NORMAL
- en: '2.2\. **Alternating functions**: In the spirit of our `onceAndAfter()` function,
    could you write an `alternator()` higher-order function that gets two functions
    as arguments, and on each call, alternatively calls one and another? The expected
    behavior should be as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '2.3\. **Everything has a limit!**: As an extension of `once()`, could you write
    a higher-order function `thisManyTimes(fn,n)` that would let you call the `fn()`
    function up to `n` times, but would afterwards do nothing? To give an example,
    `once(fn)` and `thisManyTimes`(fn,1) would produce functions that behave in exactly
    the same way.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've seen a common, simple problem, based on a real-life situation,
    and after analyzing several usual ways of solving that, we went for a *functional
    thinking* solution. We saw how to apply FP to our problem, and we also found a
    more general higher-order way that we could apply to similar problems, with no
    further code changes. We saw how to write unit tests for our code, to round out
    the development job. Finally, we even produced an even better solution (from the
    point of view of the user experience) and saw how to code it and how to unit test
    it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next [chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml), *Starting
    Out with Functions - A Core Concept*, we'll be delving more deeply into functions,
    which are at the core of all FP.
  prefs: []
  type: TYPE_NORMAL
