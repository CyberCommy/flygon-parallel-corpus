- en: Chapter 3. Testability – Writing Testable Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered a very important architectural attribute
    of software, namely, Modifiability and its related aspects. In this chapter, the
    topic is a closely related quality attribute of **testability** of software.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We briefly covered testability in the first chapter of this book, where we understood
    what testability is, and how it relates to the complexity of the code. In this
    chapter, we will look into the different aspects of software testability in detail.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Software testing by itself has developed into a large field with its own standards
    and unique set of tools and processes. The focus of this chapter is not to cover
    the formal aspects of software testing. Instead, what we will strive to do here
    is to understand software testing from an architectural perspective, understand
    its relation to the other quality attributes, and in the second half of the chapter,
    discuss the Python tools and libraries relevant to our discussion on software
    testing using Python.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Understanding testability
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The testability can be defined as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '*"The degree of ease with which a software system exposes its faults through
    execution-based testing"*'
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A software system with a high level of testability provides a high degree of
    exposure of its faults through testing, thereby giving the developers higher accessibility
    to the system's issues, and allowing them to find and fix bugs faster. A less
    testable system, on the other hand, would make it difficult for the developers
    to figure out issues with it, and can often lead to unexpected failures in production.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: The testability is, thus, an important aspect in ensuring the quality, stability,
    and predictability of the software system in production.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Software testability and related attributes
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A software system is testable if it gives up (exposes) its faults easily to
    the tester. Not only that, the system should behave in a predictable way for the
    tester to develop useful tests. An unpredictable system would give varying outputs
    to a fixed input at varying times, hence, is not testable (or very useful for
    that matter!).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: More than unpredictability, complex or chaotic systems are also less amenable
    to testing. For example, a system whose behavior varies wildly across a spectrum
    under load doesn't make a good candidate for load testing. Hence, deterministic
    behavior is also important to assure the testability of a system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect is the amount of control that the tester has on the substructures
    of the system. In order to design meaningful tests, a system should be easily
    identifiable to subsystems with their well-defined APIs, for which tests can be
    written . A software system that is complex, and doesn't provide easy access to
    its subsystems, by definition, becomes much less testable than the one which does.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: This means that systems which are more structurally complex are more difficult
    to test than ones which aren't.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Let us list this down in an easy-to-read table.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '| Determinism | Complexity | Testability |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| High | Low | High |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| Low | High | Low |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: Testability – architectural aspects
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Software testing generally implies that the software artifact being tested is
    being assessed for its functionality. However, in practical software testing,
    functionality is just one of the aspects that can fail. Testing implies assessing
    the software for other quality attributes such as performance, security, robustness,
    and so on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Due to these different aspects of testing, software testability is usually grouped
    at different levels. We will take a look at these from the point of view of software
    architecture.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a brief listing of the different aspects that usually fall under software
    testing:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional testing**: This involves testing the software for verifying its
    functionality. A unit of software passes its functional test if it behaves exactly
    the way it is supposed to as per its development specifications. Functional testing
    is usually of two types:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试：这涉及测试软件以验证其功能。如果软件单元按照其开发规范的预期行为，它通过了功能测试。功能测试通常有两种类型：
- en: '**White-box testing**: These are usually tests implemented by the developers,
    who have visibility into the software code, themselves. The units being tested
    here are the individual functions, methods, classes, or modules that make up the
    software rather than the end user functionality. The most basic form of white-box
    testing is **Unit testing**. Other types are **integration testing** and **system
    testing**.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 白盒测试：这些通常是由开发人员实施的测试，他们可以看到软件代码。这里测试的单元是组成软件的个别函数、方法、类或模块，而不是最终用户功能。白盒测试的最基本形式是单元测试。其他类型包括集成测试和系统测试。
- en: '**Black-box testing**: This type of testing is usually performed by someone
    who is outside the development team. The tests have no visibility into the software
    code, and treat the entire system like a black box. Black-box testing tests the
    end user functionality of the system without bothering about its internal details.
    Such tests are usually performed by dedicated testing or QA engineers. However,
    nowadays, a lot of black-box tests on web-based applications can be automated
    by using testing frameworks like Selenium.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑盒测试：这种类型的测试通常由开发团队之外的人员执行。测试对软件代码没有可见性，将整个系统视为黑盒。黑盒测试测试系统的最终用户功能，而不关心其内部细节。这些测试通常由专门的测试或QA工程师执行。然而，如今，许多基于Web的应用程序的黑盒测试可以通过使用Selenium等测试框架进行自动化。
- en: Other than functional testing, there are a lot of testing methodologies, which
    are used to assess the various architectural quality attributes of a system. We
    will discuss these next.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了功能测试之外，还有许多测试方法，用于评估系统的各种架构质量属性。我们将在下面讨论这些。
- en: '**Performance testing**: Tests which measure how a software performs with respect
    to its responsiveness and robustness (stability) under high workloads come within
    this category. Performance tests are usually categorized into the following:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能测试：衡量软件在高负载下的响应性和鲁棒性（稳定性）的测试属于这一类别。性能测试通常分为以下几种：
- en: '**Load testing**: Tests that assess how a system performs under a certain specific
    load, either in terms of the number of concurrent users, input data, or transactions.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载测试：评估系统在特定负载下的性能，无论是并发用户数量、输入数据还是事务。
- en: '**Stress testing**: Tests the robustness and response of the system when some
    inputs present a sudden or high rate of growth and go to extreme limits. Stress
    tests typically tend to test the system slightly beyond its prescribed design
    limits. A variation of stress testing is running the system under a certain specified
    load for extended periods of time, and measuring its responsiveness and stability.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压力测试：当某些输入突然或高速增长并达到极限时，测试系统的鲁棒性和响应。压力测试通常倾向于在规定的设计极限之外轻微测试系统。压力测试的变体是在一定的负载下长时间运行系统，并测量其响应性和稳定性。
- en: '**Scalability testing**: Measure how much the system can scale out or scale
    up when the load is increased. For example, if a system is configured to use a
    cloud service, this can test the horizontal scalability—as in how the system auto
    scales to a certain number of nodes upon increased load, or vertical scalability—in
    terms of the degree of utilization of CPU cores and/or RAM of the system.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性测试：衡量系统在负载增加时能够扩展或扩大多少。例如，如果系统配置为使用云服务，这可以测试水平可扩展性——即系统在负载增加时如何自动扩展到一定数量的节点，或垂直可扩展性——即系统CPU核心和/或RAM的利用程度。
- en: '**Security testing**: Tests that verify the system''s security fall into this
    category. For web-based applications, this usually involves verifying authorization
    of roles by checking that a given login or role can only perform a specified set
    of actions and nothing more (or less). Other tests that fall under security would
    be to verify proper access to data or static files to make sure that all sensitive
    data of an application is protected by proper authorization via logins.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全测试：验证系统安全性的测试属于这一类别。对于基于Web的应用程序，这通常涉及通过检查给定的登录或角色只能执行指定的一组操作而不多（或更少）来验证角色的授权。属于安全性的其他测试包括验证对数据或静态文件的适当访问，以确保应用程序的所有敏感数据都受到适当的登录授权保护。
- en: '**Usability testing**: Usability testing involves testing how much the user
    interface of a system is easy to use, is intuitive, and understandable by its
    end users. Usability testing is usually done via target groups comprising selected
    people who fall into the definition of the intended audience or end users of the
    system.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性测试：可用性测试涉及测试系统的用户界面对其最终用户是否易于使用、直观和可理解。可用性测试通常通过包括符合预期受众或系统最终用户定义的选定人员的目标群体来进行。
- en: '**Installation testing**: For software that is shipped to the customer''s location
    and is installed there, installation testing is important. This tests and verifies
    that all the steps involved in building and/or installing the software at the
    customer''s end work as expected. If the development hardware differs from the
    customer''s, then the testing also involves verifying the steps and components
    in the end user''s hardware. Apart from a regular software installation, installation
    testing is also important when delivering software updates, partial upgrades,
    and so on.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装测试：对于运送到客户位置并在那里安装的软件，安装测试很重要。这测试并验证了在客户端构建和/或安装软件的所有步骤是否按预期工作。如果开发硬件与客户的不同，那么测试还涉及验证最终用户硬件中的步骤和组件。除了常规软件安装外，当交付软件更新、部分升级等时，安装测试也很重要。
- en: '**Accessibility testing**: Accessibility, from a software standpoint, refers
    to the degree of usability and inclusion of a software system towards end users
    with disabilities. This is usually done by incorporating support for accessibility
    tools in the system, and designing the user interface by using accessible design
    principles. A number of standards and guidelines have been developed over the
    years, which allow organizations to develop software with a view to making the
    software accessible to such an audience. Examples are the **Web Content Accessibility
    Guidelines** (**WCAG**) of W3C, Section 508 of the Government of USA, and the
    like.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可访问性测试**：从软件角度来看，可访问性指的是软件系统对残障用户的可用性和包容性程度。通常通过在系统中加入对可访问性工具的支持，并使用可访问性设计原则设计用户界面来实现。多年来已经制定了许多标准和指南，允许组织开发软件以使其对这样的受众具有可访问性。例如，W3C的**Web内容可访问性指南**（**WCAG**）、美国政府的第508节等。'
- en: Accessibility testing aims to assess the accessibility of software with respect
    to these standards, wherever applicable.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 可访问性测试旨在根据这些标准评估软件的可访问性，适用时。
- en: There are various other types of software testing, which involves different
    approaches, and are invoked at various phases of software development, such as
    Regression testing, Acceptance testing, Alpha or Beta testing, and so on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 还有各种其他类型的软件测试，涉及不同的方法，并在软件开发的各个阶段调用，例如回归测试、验收测试、Alpha或Beta测试等。
- en: However, since our focus of discussion is on the architectural aspects of software
    testing, we will limit our attention to the topics mentioned in the previous list.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们讨论的重点是软件测试的架构方面，我们将把注意力限制在前面列表中提到的主题上。
- en: Testability – strategies
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可测试性 - 策略
- en: We saw in a previous section how testability varies according to the complexity
    and determinism of the software system under testing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的部分中看到，测试性根据正在测试的软件系统的复杂性和确定性而变化。
- en: Being able to isolate and control the artifacts that are being tested is critical
    to software testing. Separation of concerns on the system being tested, as in
    being able to test components independently and without too much external dependency,
    is key to this.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 能够隔离和控制正在测试的工件对软件测试至关重要。在测试系统的关注点分离中，即能够独立测试组件并且不过多地依赖外部是关键。
- en: Let us look at the strategies that the Software architect can employ in order
    to make sure that the components he is subjecting to tests provide predictable
    and deterministic behavior, which will provide valid and useful test results.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看软件架构师可以采用的策略，以确保他正在测试的组件提供可预测和确定的行为，从而提供有效和有用的测试结果。
- en: Reduce system complexity
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 减少系统复杂性
- en: 'As mentioned earlier, a complex system has lower testability. The system complexity
    can be reduced by techniques such as splitting systems into subsystems, providing
    well-defined APIs for systems to be tested, and so on. Here is a list of these
    techniques in some detail:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，复杂系统的可测试性较低。系统复杂性可以通过将系统拆分为子系统、为系统提供明确定义的API以进行测试等技术来减少。以下是这些技术的一些详细列表：
- en: '**Reducing coupling**: To isolate components so that coupling is reduced in
    the system. Inter-component dependencies should be well defined, and if possible,
    documented.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**减少耦合**：隔离组件，以减少系统中的耦合。组件间的依赖关系应该被明确定义，并且如果可能的话，应该被记录下来。'
- en: '**Increasing cohesion**: To increase cohesion of modules, that is, to make
    sure that a particular module or class performs only a well-defined set of functions.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**增加内聚性**：增加模块的内聚性，即确保特定模块或类只执行一组明确定义的功能。'
- en: '**Providing well-defined interfaces**: Try to provide well-defined interfaces
    for getting/setting the state of the components and classes involved. For example,
    getters and setters allow one to provide specific methods for getting and setting
    the value of a class''s attributes. A reset method allows to set the internal
    state of an object to its state at the time of creation. In Python, this can be
    done by defining properties.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**提供明确定义的接口**：尝试为获取/设置组件和类的状态提供明确定义的接口。例如，getter和setter允许提供用于获取和设置类属性值的特定方法。重置方法允许将对象的内部状态设置为其创建时的状态。在Python中，可以通过定义属性来实现这一点。'
- en: '**Reducing class complexity**: To reduce the number of classes a class derives
    from. A metric called **Response For Class** (**RFC**) is a set of methods of
    a class C, plus the methods on other classes called by the methods of class C.
    It is suggested to keep the RFC of a class in manageable limits, usually not more
    than 50 for small- to medium-sized systems.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**减少类的复杂性**：减少一个类派生的类的数量。一个称为**类响应**（**RFC**）的度量是类C的一组方法，以及类C的方法调用的其他类的方法。建议将类的RFC保持在可管理的限制范围内，通常对于小到中等规模的系统，不超过50。'
- en: Improving predictability
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提高可预测性
- en: 'We saw that having a deterministic behavior is very important to design tests
    that provide predictable results, and hence, can be used to build a test harness
    for repeatable testing. Here are some strategies to improve the predictability
    of the code under test:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，具有确定性行为对设计提供可预测结果的测试非常重要，因此可以用于构建可重复测试的测试工具。以下是一些改善被测试代码可预测性的策略：
- en: '**Correct exception handling**: – Missing or improperly-written exception handlers
    is one of the main reasons for bugs and thence, unpredictable behavior in software
    systems. It is important to find out places in the code where exceptions can occur,
    and then handle errors. Most of the time, exceptions occur when a code interacts
    with an external resource such as performing a database query, fetching a URL,
    waiting on a shared mutex, and the like.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正确的异常处理**：缺少或编写不当的异常处理程序是软件系统中错误和不可预测行为的主要原因之一。重要的是找出代码中可能发生异常的地方，然后处理错误。大多数情况下，异常发生在代码与外部资源交互时，例如执行数据库查询、获取URL、等待共享互斥锁等。'
- en: '**Infinite loops and/or blocked wait**: When writing loops that depend on specific
    conditions such as availability of an external resource, or getting handle to
    or data from a shared resource, say a shared mutex or queue, it is important to
    make sure that there are always safe exit or break conditions provided in the
    code. Otherwise, the code can get stuck in infinite loops that never break, or
    on never-ending blocked waits on resources causing bugs which are hard to troubleshoot
    and fix.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无限循环和/或阻塞等待：当编写依赖于特定条件的循环时，比如外部资源的可用性，或者从共享资源（如共享互斥锁或队列）获取句柄或数据时，重要的是要确保代码中始终提供安全的退出或中断条件。否则，代码可能会陷入永远不会中断的无限循环，或者在资源上永远阻塞等待，导致难以排查和修复的错误。
- en: '**Logic that is time dependent**: When implementing logic that is dependent
    on certain times of the day (hours or specific weekdays), make sure that the code
    works in a predictable fashion. When testing such code, one often needs to isolate
    such dependencies by using mocks or stubs.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间相关的逻辑：在实现依赖于一天中特定时间（小时或特定工作日）的逻辑时，确保代码以可预测的方式工作。在测试这样的代码时，通常需要使用模拟或存根来隔离这些依赖关系。
- en: '**Concurrency**: When writing code that uses concurrent methods such as multiple
    threads and/or processes, it is important to make sure that the system logic is
    not dependent on threads or processes starting in any specific order. The system
    state should be initialized in a clean and repeatable way via well-defined functions
    or methods which allow the system behavior to be repeatable, and hence, testable.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发：在编写使用并发方法（如多线程和/或进程）的代码时，重要的是确保系统逻辑不依赖于线程或进程以任何特定顺序启动。系统状态应该通过定义良好的函数或方法以一种干净和可重复的方式初始化，从而使系统行为可重复，因此可测试。
- en: '**Memory Management**: A very common reason for software errors and unpredictability
    is incorrect usage and mismanagement of memory. In modern runtimes with dynamic
    memory management, such as Python, Java, or Ruby, this is less of a problem. However,
    memory leaks and unreleased memory leading to bloated software are still very
    much a reality in modern software systems.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存管理：软件错误和不可预测性的一个非常常见的原因是内存的错误使用和管理不当。在具有动态内存管理的现代运行时环境中，如Python、Java或Ruby，这不再是一个问题。然而，内存泄漏和未释放的内存导致软件膨胀仍然是现代软件系统中非常真实的问题。
- en: It is important to analyze and be able to predict the maximum memory usage of
    your software system so that you allocate enough memory for it, and run it in
    the right hardware. Also, software should be periodically evaluated and tested
    for memory leaks and better memory management, and any major issues should be
    addressed and fixed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要分析并能够预测软件系统的最大内存使用量，以便为其分配足够的内存，并在正确的硬件上运行。此外，软件应定期进行内存泄漏和更好的内存管理的评估和测试，并且应该解决和修复任何主要问题。
- en: Control and isolate external dependencies
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制和隔离外部依赖
- en: Tests usually have some sort of external dependency. For example, a test may
    need to load/save data to/from a database. Another may depend on the test running
    on specific times of the day. A third may require fetching data from a URL on
    the Web.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通常具有某种外部依赖。例如，一个测试可能需要从数据库中加载/保存数据。另一个可能依赖于一天中特定的时间运行测试。第三个可能需要从Web上的URL获取数据。
- en: However, having external dependencies usually complicates a test scenario. This
    is because external dependencies are usually not within the control of the test
    designer. In the aforementioned cases, the database may be in another data center,
    or the connection may fail, or the website may not respond within the configured
    time, or give a 50X error.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，具有外部依赖通常会使测试场景变得更加复杂。这是因为外部依赖通常不在测试设计者的控制范围内。在上述情况下，数据库可能位于另一个数据中心，或者连接可能失败，或者网站可能在配置的时间内不响应，或者出现50X错误。
- en: 'Isolating such external dependencies is very important in designing and writing
    repeatable tests. The following are a few techniques for the same:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计和编写可重复的测试时，隔离这些外部依赖非常重要。以下是一些相同的技术：
- en: '**Data sources**: Most realistic tests require data of some form. More often
    than not, data is read from a database. However, a database being an external
    dependency, cannot be relied upon. The following are a few techniques to control
    data source dependencies:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据源：大多数真实的测试都需要某种形式的数据。往往情况下，数据是从数据库中读取的。然而，数据库作为外部依赖，不能被依赖。以下是一些控制数据源依赖的技术：
- en: 'Using local files instead of a database: Quite often, test files with prefilled
    data can be used instead of querying a database. Such files could be text, JSON,
    CSV, or YAML files. Usually, such files are used with mock or stub objects.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本地文件而不是数据库：经常可以使用预填充数据的测试文件，而不是查询数据库。这些文件可以是文本、JSON、CSV或YAML文件。通常，这些文件与模拟或存根对象一起使用。
- en: 'Using an in-memory database: Rather than connecting to a real database, a small
    in-memory database could be used. A good example is the SQLite DB, a file or memory-based
    database which implements a good, but minimal, subset of SQL.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内存数据库：与连接到真实数据库不同，可以使用一个小型的内存数据库。一个很好的例子是SQLite DB，它是一个基于文件或内存的数据库，实现了一个良好但是最小的SQL子集。
- en: 'Using a test database: If the test really requires a database, the operation
    can use a test database which uses **transactions**. The database is set up in
    the `setUp()` method of the test case, and rolled back in the `tearDown()` method
    so that no real data remains at the end of the operation.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试数据库：如果测试确实需要数据库，操作可以使用一个使用事务的测试数据库。数据库在测试用例的`setUp()`方法中设置，并在`tearDown()`方法中回滚，以便在操作结束时不留下真实数据。
- en: '**Resource virtualization**: In order to control the behavior of resources
    which are outside the system, one can virtualize them, that is, build a version
    of these resources which mimic their APIs, but not the internal implementation.
    Some common techniques for resource virtualization are as follows:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源虚拟化**: 为了控制系统外部资源的行为，可以对它们进行虚拟化，即构建这些资源的版本，模仿它们的API，但不是内部实现。一些常见的资源虚拟化技术如下：'
- en: '**Stubs**: Stubs provide standard (canned) responses to function calls made
    during a test. A `Stub()` function replaces the details of the function it replaces,
    only returning the response as required.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存根**: 存根为测试期间进行的函数调用提供标准（预定义）响应。`Stub()`函数替换了它替代的函数的细节，只返回所需的响应。'
- en: 'For example, here is a function that returns `data` for a given URL:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个根据给定URL返回`data`的函数：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And the following is the stub that replaces it, which internalizes the external
    dependency of the URL:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是替代它的存根，它内部化了URL的外部依赖：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A more common way to write such a function is to combine both the original request
    and the file cache in the same code. The URL is requested just once—the first
    time the function is called—and in subsequent requests, the data from the file
    cache is returned.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这样一个函数的更常见的方法是将原始请求和文件缓存合并到同一代码中。URL只被请求一次——在第一次调用函数时——在后续请求中，从文件缓存返回数据。
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Mocks**: Mocks fake the API of the real-world objects they replace. One programs
    mock objects directly in the test by setting expectations—in terms of the type
    and order of the arguments the functions will expect and the responses they will
    return. Later, the expectations can be optionally verified in a verification step.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟**: 模拟对象是对它们替代的真实世界对象的API进行伪装。一个程序可以通过设置期望来直接在测试中模拟对象——期望函数将期望的参数类型和顺序以及它们将返回的响应。稍后，可以选择性地在验证步骤中验证这些期望。'
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The main difference between Mocks and Stubs is that a Stub implements just enough
    behavior for the object under test to execute the test. A Mock usually goes beyond
    by also verifying that the object under test calls the Mock as expected—for example,
    in terms of number and order of arguments.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟和存根之间的主要区别在于存根只实现了足够的行为，使得被测试对象能够执行测试。模拟通常会超出范围，还会验证被测试对象是否按预期调用模拟——例如，参数的数量和顺序。
- en: When using a Mock object, part of the test involves verifying that the Mock
    was used correctly. In other words, both Mocks and Stubs answer the question,
    *What is the result?*, but Mocks also answer the question, *How has the result
    been achieved?*
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟对象时，测试的一部分涉及验证模拟是否被正确使用。换句话说，模拟和存根都回答了问题，“结果是什么？”，但模拟还回答了问题，“结果是如何实现的？”
- en: We will see examples of writing unit test via mocks with Python later.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面看到使用Python进行模拟的单元测试的示例。
- en: '**Fakes**: The `Fake` objects have working implementations, but fall short
    of production usage because they have some limitations. A `Fake` object provides
    a very lightweight implementation, which goes beyond just stubbing the object.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**伪造**: `Fake`对象具有工作实现，但由于存在一些限制，不足以用于生产。`Fake`对象提供了一个非常轻量级的实现，不仅仅是存根对象。'
- en: 'For example, here is a `Fake` object that implements a very minimal logging,
    mimicking the API of the `Logger` object of the Python''s logging module:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个实现非常简单的日志记录的`Fake`对象，模仿了Python的日志记录模块的`Logger`对象的API：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `FakeLogger` class in the preceding code implements some main methods of
    the `logging.Logger` class, which it is trying to fake.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的`FakeLogger`类实现了`logging.Logger`类的一些主要方法，它试图伪装。
- en: It is ideal as a fake object for replacing the `Logger` object for implementing
    tests.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 它作为替换`Logger`对象来实现测试的伪造对象是理想的。
- en: White-box testing principles
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 白盒测试原则
- en: From a software architecture perspective, one of the most important steps of
    testing is at the time the software is developed. The behavior or functionality
    of a software, which is apparent only to its end users, is an artifact of the
    implementation details of the software.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从软件架构的角度来看，测试的一个最重要的步骤是在软件开发时进行。软件的行为或功能，只对最终用户可见，是软件实现细节的产物。
- en: Hence, it follows that a system which is tested early and tested often has a
    higher likelihood to produce a testable and robust system, which provides the
    required functionality to the end user in a satisfactory manner.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个早期进行测试并经常进行测试的系统更有可能产生一个可测试和健壮的系统，以满意的方式为最终用户提供所需的功能。
- en: The best way, therefore, to start implementing testing principles is right from
    the source, that is, where the software is written, and by the developers. Since
    the source code is visible to the developer, this testing is often called White-box
    testing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，实施测试原则的最佳方式是从源头开始，也就是软件编写的地方，由开发人员来实施。由于源代码对开发人员可见，这种测试通常被称为白盒测试。
- en: So, how do we make sure that we can follow the correct testing principles, and
    perform due diligence while the software is getting developed? Let us take a look
    at the different types of testing that are involved during the development stage
    before the software ends up in front of the customer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何确保我们可以遵循正确的测试原则，并在软件开发过程中进行尽职调查呢？让我们来看看在软件最终呈现给客户之前，在开发阶段涉及的不同类型的测试。
- en: Unit testing
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit testing is the most fundamental type of testing performed by developers.
    A unit test applies the most basic unit of software code—typically, functions
    or class methods—by using executable assertions, which check the output of the
    unit being tested against an expected outcome.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是开发人员执行的最基本的测试类型。单元测试通过使用可执行的断言来应用软件代码的最基本单元——通常是函数或类方法——来检查被测试单元的输出与预期结果是否一致。
- en: In Python, support for unit testing is provided by the `unittest` module in
    the standard library.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，通过标准库中的`unittest`模块提供对单元测试的支持。
- en: The unit test module provides the following high-level objects.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试模块提供以下高级对象。
- en: '**Test cases**: The `unittest` module provides the `TestCase` class, which
    provides support for test cases. A new test case class can be set up by inheriting
    from this class, and setting up the test methods. Each test method will implement
    unit tests by checking the response against an expected outcome.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试用例**：`unittest`模块提供了`TestCase`类，它提供了对测试用例的支持。可以通过继承这个类并设置测试方法来设置一个新的测试用例类。每个测试方法将通过检查响应与预期结果是否匹配来实现单元测试。'
- en: '**Test fixtures**: Test fixtures represent any setup or preparation required
    for one or more tests followed by any cleanup actions. For example, this may involve
    creating temporary or in-memory databases, starting a server, creating a directory
    tree, and the like. In the `unittest` module, support for fixtures is provided
    by the `setUp()` and `tearDown()` methods of the `TestCase` class and the associated
    class and module methods of the `TestSuite` class.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试固件**：测试固件代表一个或多个测试所需的任何设置或准备工作，然后是任何清理操作。例如，这可能涉及创建临时或内存数据库，启动服务器，创建目录树等。在`unittest`模块中，通过`TestCase`类的`setUp()`和`tearDown()`方法以及`TestSuite`类的相关类和模块方法提供了对固件的支持。'
- en: '**Test suites**: A test suite is an aggregation of related test cases. A test
    suite can also contain other test suites. A test suite allows to group test cases
    that perform functionally similar tests on a software system, and whose results
    should be read or analyzed together. The `unittest` module provides support for
    test suites through the `TestSuite` class.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试套件**：测试套件是相关测试用例的聚合。测试套件还可以包含其他测试套件。测试套件允许将在软件系统上执行功能相似的测试的测试用例分组，并且其结果应该一起阅读或分析。`unittest`模块通过`TestSuite`类提供了对测试套件的支持。'
- en: '**Test runners**: A test runner is an object that manages and runs the test
    cases, and provides the results to the tester. A test runner can use a text interface
    or a GUI.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试运行器**：测试运行器是一个管理和运行测试用例，并向测试人员提供结果的对象。测试运行器可以使用文本界面或图形界面。'
- en: '**Test results**: Test result classes manage the test result output shown to
    the tester. Test results summarize the number of successful, failed, and erred-out
    test cases. In the `unittest` module, this is implemented by the `TestResult`
    class with a concrete, default implementation of the `TextTestResult` class.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试结果**：测试结果类管理向测试人员显示的测试结果输出。测试结果总结了成功、失败和出错的测试用例数量。在`unittest`模块中，这是通过`TestResult`类实现的，具体的默认实现是`TextTestResult`类。'
- en: Other modules that provide support for Unit testing in Python are nose (nose2)
    and **py.test**. We will discuss each of these briefly in the following sections.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中提供支持单元测试的其他模块包括nose（nose2）和**py.test**。我们将在接下来的部分简要讨论每一个。
- en: Unit testing in action
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试实例
- en: Let us take a specific unit-testing task, and then try to build a few test cases
    and test suites. Since the `unittest` module is the most popular, and available
    by default in the Python standard library, we will start with it first.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来做一个具体的单元测试任务，然后尝试构建一些测试用例和测试套件。由于`unittest`模块是最流行的，并且在Python标准库中默认可用，我们将首先从它开始。
- en: For our test purposes, we will create a class that has a few methods, which
    are used for date/time conversions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的测试目的，我们将创建一个具有一些用于日期/时间转换的方法的类。
- en: 'The following code shows our class:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了我们的类：
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our class `DateTimeHelper` has a few methods, which are as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`DateTimeHelper`类有一些方法，如下所示：
- en: '`date`: Returns the day''s timestamp in the dd/mm/yyyy format'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date`：以dd/mm/yyyy格式返回当天的时间戳'
- en: '`weekday`: Returns the day''s weekday, for example, Sunday, Monday, and so
    on'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weekday`：返回当天的星期几，例如，星期日，星期一等等'
- en: '`us_to_indian`: Converts a US date format (mm/dd/yy(yy)) to the Indian format
    (dd/mm/yyyy)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`us_to_indian`：将美国日期格式（mm/dd/yy(yy)）转换为印度格式（dd/mm/yyyy）'
- en: 'Here is a `unittest TestCase` class, which implements a test for the last method:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`unittest TestCase`类，它实现了对最后一个方法的测试：
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that in the main part of the testcase code, we just invoke `unittest.main()`.
    This automatically figures out the test cases in the module, and executes them.
    The following image shows the output of the test run:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在测试用例代码的主要部分中，我们只是调用了`unittest.main()`。这会自动找出模块中的测试用例，并执行它们。以下图片显示了测试运行的输出：
- en: '![Unit testing in action](../Images/image00386.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![单元测试实例](../Images/image00386.jpeg)'
- en: 'Output of the unit-test case for datetimehelper module - version #1'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`datetimehelper`模块的单元测试案例输出 - 版本#1'
- en: As we can see from the output, this simple test case passes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，这个简单的测试用例通过了。
- en: Extending our unit test case
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展我们的单元测试用例
- en: You may have noted that the first version of the unit test case for the `datetimehelper`
    module contained a test only for one method, namely, the method that converts
    the US date format to the Indian one.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到`datetimehelper`模块的第一个版本的单元测试用例只包含了一个方法的测试，即将美国日期格式转换为印度日期格式的方法。
- en: However, what about the other two methods? Shouldn't we write unit tests for
    them too?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，其他两种方法呢？难道我们也不应该为它们编写单元测试吗？
- en: The problem with the other two methods is that they get data from today's date.
    In other words, the output is dependent on the exact day that the code is run.
    Hence, it is not possible to write a specific test case for them by feeding in
    a date value, and expecting the result to match an outcome as the code is time
    dependent. We need a way to control this external dependency.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 其他两种方法的问题在于它们获取来自今天日期的数据。换句话说，输出取决于代码运行的确切日期。因此，无法通过输入日期值并期望结果与预期结果匹配来为它们编写特定的测试用例，因为代码是时间相关的。我们需要一种方法来控制这种外部依赖。
- en: Here is where Mocking comes to our rescue. Remember that we had discussed Mock
    objects as a way to control external dependencies. We can use the patching support
    of `unittest.mock` library, and patch the method that returns today's date to
    return a date that we control. This way, we are able to test the methods that
    depend on it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Mocking来拯救我们。记住我们曾讨论过Mock对象作为控制外部依赖的一种方式。我们可以使用`unittest.mock`库的修补支持，并修补返回今天日期的方法，以返回我们控制的日期。这样，我们就能够测试依赖于它的方法。
- en: 'Here is the modified test case with support added for the two methods using
    this technique:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是修改后的测试用例，使用了这种技术来支持两种方法：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we have patched the `today` method to return a specific date
    in the two test methods. This allows us to control the method's output, and, in
    turn, compare the result with a specific outcome.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们已经对`today`方法进行了修补，使其在两个测试方法中返回特定日期。这使我们能够控制该方法的输出，并将结果与特定结果进行比较。
- en: 'Here is the new output of the test case:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是测试用例的新输出：
- en: '![Extending our unit test case](../Images/image00387.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![扩展我们的单元测试用例](../Images/image00387.jpeg)'
- en: 'Output of the unit-test case for datetimehelper module with two more tests
    - version #2'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试用例的输出，用于datetimehelper模块，增加了两个测试 - 版本＃2
- en: Tip
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'NOTE: `unittest.main` is a convenience function on the `unittest` module, which
    makes it easy to load a set of test cases automatically from a module and run
    them.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`unittest.main`是`unittest`模块上的一个便利函数，它可以轻松地从一个模块中自动加载一组测试用例并运行它们。
- en: 'To find out more details of what is happening when the tests are run, we can
    make the test runner show more information by increasing the verbosity. This can
    be done either by passing the `verbosity` argument to `unittest.main`, or by passing
    the `-v` option on the command line as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解测试运行时发生了什么的更多细节，我们可以通过增加冗长度来让测试运行器显示更多信息。可以通过将`verbosity`参数传递给`unittest.main`，或者通过在命令行上传递`-v`选项来实现。
- en: '![Extending our unit test case](../Images/image00388.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![扩展我们的单元测试用例](../Images/image00388.jpeg)'
- en: Producing verbose output from the unit-test case by passing the -v argument
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递`-v`参数来从单元测试用例中生成冗长输出
- en: Nosing around with nose2
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用nose2四处嗅探
- en: There are other unit-testing modules in Python which are not part of the standard
    library, but are available as third-party packages. We will look at the first
    one named `nose`. The most recent version (at the time of writing) is version
    2, and the library has been renamed as nose2.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Python中还有其他单元测试模块，它们不是标准库的一部分，但作为第三方包可用。我们将看一下第一个名为`nose`的模块。最新版本（写作时）是版本2，该库已更名为nose2。
- en: The nose2 package can be installed by using the Python package installer, pip.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Python包安装程序pip来安装nose2包。
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Running nose2 is very simple. It automatically detects Python test cases to
    run in the folder that it is run from by looking for classes derived from `unittest.TestCase`,
    and also functions starting with `test`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 运行nose2非常简单。它会自动检测要从中运行的Python测试用例所在的文件夹，方法是查找从`unittest.TestCase`派生的类，以及以`test`开头的函数。
- en: 'In the case of our datetimehelper test-case, nose2 picks it up automatically.
    Simply run it from the folder containing the module. Here is the test output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的datetimehelper测试用例中，nose2会自动捡起它。只需从包含模块的文件夹中运行它。以下是测试输出：
- en: '![Nosing around with nose2](../Images/image00389.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![用nose2四处嗅探](../Images/image00389.jpeg)'
- en: Running unit-tests using nose2
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用nose2运行单元测试
- en: The preceding output doesn't, however, report anything, since, by default, nose2
    runs quietly. We can turn on some reporting of tests by using the verbose option
    (`-v`).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前面的输出并没有报告任何内容，因为默认情况下，nose2会静默运行。我们可以通过使用冗长选项（`-v`）来打开一些测试报告。
- en: '![Nosing around with nose2](../Images/image00390.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![用nose2四处嗅探](../Images/image00390.jpeg)'
- en: Running unit-tests using nose2, with verbose output
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用nose2运行单元测试，带有冗长输出
- en: The nose2 also supports reporting code coverage by using plugins. We will look
    at code coverage in a later section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: nose2还支持使用插件来报告代码覆盖。我们将在后面的部分看到代码覆盖。
- en: Testing with py.test
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用py.test进行测试
- en: The py.test package, commonly known as pytest, is a full-featured, mature testing
    framework for Python. Like nose2, py.test also supports test discovery by looking
    for files starting with certain patterns.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: py.test包，通常称为pytest，是Python的一个功能齐全、成熟的测试框架。与nose2一样，py.test也支持通过查找以特定模式开头的文件来发现测试。
- en: The py.test can also be installed with pip.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: py.test也可以使用pip安装。
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Like nose2, test execution with py.test is also easy. Simply run the executable
    pytest in the folder containing the test cases.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 像nose2一样，使用py.test进行测试也很容易。只需在包含测试用例的文件夹中运行可执行文件pytest。
- en: '![Testing with py.test](../Images/image00391.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![使用py.test进行测试](../Images/image00391.jpeg)'
- en: Test discovery and execution with py.test
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用py.test进行测试发现和执行
- en: Like nose2, pytest also comes with its own plugin support, the most useful among
    them being the code coverage plugin. We will see examples in a later section.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 像nose2一样，pytest也具有自己的插件支持，其中最有用的是代码覆盖插件。我们将在后面的部分看到示例。
- en: It is to be noted that pytest doesn't require test cases to be derived formally
    from the `unittest.TestCase` module. Py.test automatically discovers tests from
    any modules containing classes prefixed with `Test`, or from functions prefixed
    with `test_`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，pytest不要求测试用例正式派生自`unittest.TestCase`模块。Py.test会自动从包含以`Test`为前缀的类或以`test_`为前缀的函数的模块中发现测试。
- en: For example, here is a new test case without any dependency on the `unittest`
    module but with the test case class derived from object, the most base type in
    Python. The new module is called `test_datetimehelper_object`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里有一个新的测试用例，没有依赖于`unittest`模块，但测试用例类是从Python中最基本的类型object派生的。新模块名为`test_datetimehelper_object`。
- en: '[PRE9]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note how this class has zero dependency on the `unittest` module, and defines
    no fixtures. Here is the output of running pytest on the folder now:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个类与`unittest`模块没有任何依赖关系，并且没有定义任何固定装置。以下是现在在文件夹中运行pytest的输出：
- en: '![Testing with py.test](../Images/image00392.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![使用py.test进行测试](../Images/image00392.jpeg)'
- en: Test case discovery and execution without unittest module support using py.test
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用py.test进行测试用例发现和执行，而不使用unittest模块支持
- en: The pytest has picked up the test case in this module, and executed it automatically
    as the output shows.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: pytest已经捕捉到了这个模块中的测试用例，并自动执行了它，正如输出所示。
- en: The nose2 also has similar capabilities to pick up such test cases. The next
    image shows the output of nose2 with the new test case defined.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: nose2也具有类似的功能来捕捉这样的测试用例。下一张图片显示了nose2对新测试用例的输出。
- en: '![Testing with py.test](../Images/image00393.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![使用py.test进行测试](../Images/image00393.jpeg)'
- en: Test case discovery and execution without unittest module support using nose2
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用nose2进行测试用例发现和执行，而不使用unittest模块支持
- en: The preceding output shows that the new test has been picked up and executed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示了新测试已被捕捉并执行。
- en: The `unittest` module, nose2, and py.test packages provide a lot of support
    for developing and implementing test cases, fixtures, and test suites in a very
    flexible and customizable manner. Discussing all the multitude of options of these
    tools is beyond the scope of this chapter, as our focus is on getting to know
    these tools to understand how we can use them to satisfy the architectural quality
    attribute of testability.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`模块、nose2和py.test包提供了大量支持，以非常灵活和可定制的方式开发和实现测试用例、固定装置和测试套件。讨论这些工具的多种选项超出了本章的范围，因为我们的重点是了解这些工具，以理解我们如何使用它们来满足测试性的架构质量属性。'
- en: So, at this point, we will go on to the next major topic in unit testing, that
    of **code coverage**. We will look at these three tools, namely, `unittest`, nose2,
    and py.test, and see how they allow the architect to help his developers and testers
    find information about the code coverage in their unit tests.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将继续讨论单元测试的下一个重要主题，即**代码覆盖率**。我们将看看这三个工具，即`unittest`、nose2和py.test，以及它们如何允许架构师帮助他的开发人员和测试人员找到有关他们单元测试中代码覆盖率的信息。
- en: Code coverage
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: Code coverage is measured as the degree to which the source code under test
    is covered by a specific test suite. Ideally, test suites should aim for higher
    code coverage, as this would expose a larger percentage of the source code to
    tests, and help to uncover bugs.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是衡量被测试的源代码被特定测试套件覆盖的程度。理想情况下，测试套件应该追求更高的代码覆盖率，因为这将使更大比例的源代码暴露给测试，并有助于发现错误。
- en: Code coverage metrics are reported typically as a percentage of **Lines of Code**
    (**LOC**), or a percentage of the subroutines (functions) covered by a test suite.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率指标通常报告为**代码行数**（**LOC**）的百分比，或者测试套件覆盖的子程序（函数）的百分比。
- en: Let us now look at different tools support for measuring code coverage. We will
    continue to use our test example (`datetimehelper`) for these illustrations too.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看不同工具对于测量代码覆盖率的支持。我们将继续使用我们的测试示例（`datetimehelper`）进行这些说明。
- en: Measuring coverage using coverage.py
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用coverage.py进行覆盖率测量
- en: Coverage.py is a third-party Python module, which works with test suites and
    cases written with the `unittest` module, and reports their code coverage.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Coverage.py是一个第三方的Python模块，它与使用`unittest`模块编写的测试套件和测试用例一起工作，并报告它们的代码覆盖率。
- en: Coverage.py can be installed, like other tools shown here so far, using pip.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Coverage.py可以像其他工具一样使用pip进行安装。
- en: '[PRE10]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This last command installs the coverage application, which is used to run and
    report code coverages.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的命令安装了coverage应用程序，用于运行和报告代码覆盖率。
- en: 'Coverage.py has two stages: first, where it runs a piece of source code, and
    collects coverage information, and next, where it reports the coverage data.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Coverage.py有两个阶段：首先，它运行一段源代码，并收集覆盖信息，然后报告覆盖数据。
- en: 'To run coverage.py, use the following syntax:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行coverage.py，请使用以下语法：
- en: '[PRE11]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once the run is complete, report the coverage using this command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 运行完成后，使用此命令报告覆盖率：
- en: '[PRE12]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For example, here is the output with our test modules:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是我们测试模块的输出：
- en: '![Measuring coverage using coverage.py](../Images/image00394.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![使用coverage.py进行覆盖率测量](../Images/image00394.jpeg)'
- en: Test coverage report for datetimehelper module using coverage.py
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用coverage.py对datetimehelper模块进行测试覆盖率报告
- en: Coverage.py reports that our tests cover `93%` of the code in the `datetimehelper`
    module, which is pretty good code coverage. (You can ignore the report on the
    test module itself.)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Coverage.py报告称我们的测试覆盖了`datetimehelper`模块中`93%`的代码，这是相当不错的代码覆盖率。（您可以忽略关于测试模块本身的报告。）
- en: Measuring coverage using nose2
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用nose2进行覆盖率测量
- en: 'The nose2 package comes with plugin support for code coverage. This is not
    installed by default. To install the code coverage plugin for nose2, use this
    command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: nose2包带有用于代码覆盖率的插件支持。这不是默认安装的。要为nose2安装代码覆盖插件，请使用此命令：
- en: '[PRE13]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, nose2 can be run with the code coverage option to run the test cases,
    and to report coverage in one shot. This can be done as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，nose2可以使用代码覆盖选项运行测试用例，并一次性报告覆盖率。可以这样做：
- en: '[PRE14]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'NOTE: Behind the scenes cov-core makes use of coverage.py to get its work done,
    so the metric report of coverage by both coverage.py and nose2 is the same.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在幕后，cov-core利用coverage.py来完成其工作，因此coverage.py和nose2的覆盖度度量报告是相同的。
- en: 'Here is the output of running test coverage using nose2:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用nose2运行测试覆盖率的输出：
- en: '![Measuring coverage using nose2](../Images/image00395.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![使用nose2进行覆盖率测量](../Images/image00395.jpeg)'
- en: Test coverage report for datetimehelper module using nose2
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用nose2对datetimehelper模块进行测试覆盖率报告
- en: By default, the coverage report is written to the console. To produce other
    forms of output, the `–coverage-report` option can be used. For example, `--coverage-report
    html` will write the coverage report in the HTML format to a subfolder named `htmlcov`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，覆盖率报告会被写入控制台。要生成其他形式的输出，可以使用`–coverage-report`选项。例如，`--coverage-report
    html`将以HTML格式将覆盖率报告写入名为`htmlcov`的子文件夹。
- en: '![Measuring coverage using nose2](../Images/image00396.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![使用nose2进行覆盖率测量](../Images/image00396.jpeg)'
- en: Producing HTML coverage output using nose2
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用nose2生成HTML覆盖率输出
- en: 'Here is how the HTML output looks in the browser:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是浏览器中的HTML输出效果：
- en: '![Measuring coverage using nose2](../Images/image00397.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: HTML coverage report as viewed in the browser
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Measuring coverage using py.test
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pytest also comes with its own coverage plugin for reporting code coverage.
    Like nose2, it utilizes coverage.py behind the scenes to get the work done.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide support for code coverage for py.test, the package `pytest-cov`
    needs to be installed as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To report code coverage of test cases in the current folder, use the following
    command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is a sample output of pytest code coverage:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![Measuring coverage using py.test](../Images/image00398.jpeg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: Running code coverage for current folder using py.test
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Mocking things up
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw an example of using the patch support of `unittest.mock` in our test
    example earlier. However, the Mock support provided by `unittest` is even more
    powerful than this, so let us look at one more example to understand its power
    and applicability in writing unit tests.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of this illustration, we will consider a class that performs
    keyword search on a large dataset, and returns the results ordered by weightage.
    Assume that the dataset is stored in a database, and the results are returned
    as a list of (sentence, relevance) tuples, where sentence is the original string
    with a match for the keyword, and relevance is its hit weightage in the result
    set.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The class has the following three methods:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__`: The initializer, it accepts an object that acts as a handle to
    the data source (database); also initializes a few attributes, and connects to
    the database'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setup`: It sets up the searcher, and also configures the database object'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_results`: It performs a search using the data source (database), and returns
    the results for a given keyword'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now want to implement a unit test case for this searcher. Since the database
    is an external dependency, we will virtualize the database object by mocking it.
    We will test only the searcher's logic, callable signatures, and return data.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: We will develop this program step by step so that each step of Mocking is clear
    to you. We will use a Python interactive interpreter session for the same.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: First, the mandatory imports.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since we want to Mock the DB, the first step is to do that exactly.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now let us create the `searcher` object. We are not going to Mock this, as we
    need to test the calling signature and the return value of its methods.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: At this point, the database object has been passed to the `__init__` method
    of the `searcher`, and `connect` has been called on it. Let's verify this expectation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: No issues, so the assertion has succeeded! Let us now set up the `searcher`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Looking at the code of the `TextSearcher` class, we realize that the preceding
    call should have called `configure` on the database object with the parameter
    `max_items` set to the value `100`. Let's verify this.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Bravo!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let us try and test the logic of the `get_results` method. Since our
    database is a Mock object, it won't be able to do any actual query, so we pass
    some canned results to its `query` method, effectively mocking it.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now we set up the keyword and the number of results, and call `get_results`
    using these parameters.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's inspect the data.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Looks good!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we verify that `get_results` has indeed called `query` with
    the given keyword.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Finally, we verify that the data returned has been sorted right and truncated
    to the number of results (`num`) value we passed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: All good!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: The example shows how to use Mock support in the `unittest` module in order
    to mock an external dependency and effectively virtualize it, at the same time
    testing the program's logic, control flow, callable arguments, and return values.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Here is a test module combining all these tests into a single test module, and
    the output of nose2 on it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here is the output of nose2 on this test case:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![Mocking things up](../Images/image00399.jpeg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: Running testsearcher test-case using nose2
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: For good measure, let us also look at the coverage of our mock test example,
    the `test_textsearch` module, using the py.test coverage plugin.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '![Mocking things up](../Images/image00400.jpeg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
- en: Measuring coverage of textsearcher module via test_textsearch test-case using
    py.test
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: So our Mock test has a coverage of *90%*, missing just two statements out of
    *20*. Not bad!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Tests inline in documentation – doctests
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has unique support for another form of inline code tests, which are commonly
    called **doctests**. These are inline unit tests in a function, class or module
    documentation, which add a lot of value by combining code and tests in one place
    without having to develop or maintain separate test suites.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: The doctest module works by looking for pieces of text in code documentation
    that look like Python strings, and executing those sessions to verify that they
    work exactly as found. Any test failures are reported on the console.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at a code example to see this in action. The following piece of
    code implements the simple factorial function by using an iterative approach:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let's look at the output of executing this module.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '![Tests inline in documentation – doctests](../Images/image00401.jpeg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: Output of doctest for the factorial module
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: The doctest reports that one out of four tests failed.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: A quick scan of the output tells us that we forgot to code in the special case
    to compute the factorial for zero. The error occurs because the code tries to
    compute range(1, 1), which raises an exception with `reduce`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'The code can be easily rewritten to fix this. Here is the modified code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The next image shows the fresh output of executing the module now:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '![Tests inline in documentation – doctests](../Images/image00402.jpeg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: Output of doctest for factorial module after the fix
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Now all the tests pass.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NOTE: We turned on the verbose option of the doctest module''s `testmod` function
    in this example in order to show the details of the tests. Without this option,
    doctest would be silent if all the tests passed, producing no output.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The doctest module is very versatile. Rather than just Python code, it can also
    load Python interactive sessions from sources like text files, and execute them
    as tests.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Doctest examines all docstrings including function, class, and module doc-strings
    to search for Python interactive sessions.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NOTE: The pytest package comes with built-in support for doctests. To allow
    pytest to discover and run doctests in the current folder, use the following command:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Integration tests
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit tests, though very useful to discover and fix bugs during white-box testing
    early on in the software development life cycle, aren't enough by themselves.
    A software system is fully functional only if the different components work together
    in expected ways in order to deliver the required functionality to the end user,
    satisfying the pre-defined architectural quality attributes. This is where integration
    tests assume importance.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of integration tests is to verify the functional, performance, and
    other quality requirements on the different functional subsystems of a software
    system, which act as a logical unit, providing certain functionality. Such subsystems
    deliver some piece of functionality through the cumulative action of their individual
    units. Though each component may have defined its own unit test, it is also important
    to verify the combined functionality of the system by writing integration tests.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests are usually written after unit testing is completed, and before
    validation testing is done.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: It would be instructional to list down the advantages provided by integration
    tests at this point, as this could be useful for any software architect who is
    at a phase where he has designed and implemented his unit tests for the different
    components.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing component interoperability**: Each unit in a functional subsystem
    could be written by different programmers. Though each programmer is aware of
    how his component should perform, and may have written unit tests for the same,
    the entire system may have issues working in unison, as there could be errors
    or misunderstanding in the integration points where components talk to each other.
    Integration testing would reveal such mistakes.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing for system requirement modifications**: The requirements may have
    changed during the time of implementation. These updated requirements may not
    have been unit tested, hence, an integration test becomes very useful to reveal
    issues. Also some parts of the system may not have implemented the requirements
    correctly, which can also be revealed by an appropriate Integration test.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing external dependencies and APIs**: Software components these days
    use a lot of third-party APIs, which are usually mocked or stubbed during unit
    tests. Only an integration test would reveal how these APIs would perform and
    expose any issues either in the calling convention, response data, or performance
    with them.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debugging hardware issues**: Integration tests are helpful in getting information
    about any hardware problems, and debugging such tests gives the developer(s) data
    about whether an update or change in the hardware configuration is required.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uncovering exceptions in code paths**: Integration tests can also help developers
    figure out exceptions that they may not have handled in their code, as unit tests
    wouldn''t have executed paths or conditions which raised such errors. Higher code
    coverage can identify and fix a lot of such issues. However, a good integration
    test combining known code paths for each functionality with high coverage is a
    good formula for making sure most potential errors that may occur during usage
    are uncovered and executed during testing.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are three approaches to writing integration tests. These are as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '**Bottom-up**: In this approach, components at the lower level are tested first,
    and these test results are used to integrate tests of the higher-level components
    in the chain. The process repeats until we reach the top of the hierarchy of the
    components with respect to the control flow. In this approach, critical modules
    at the top of the hierarchy may be tested inadequately.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the top-level components are under development, Drivers may be required to
    simulate (Mock) them.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '![Integration tests](../Images/image00403.jpeg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
- en: Bottom-Up strategy of integration testing
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '**Top-down**: Test development and testing happens top-down, following the
    workflow in the software system. Hence, components at the top level of the hierarchy
    are tested first and the lower-level modules are tested last. In this approach,
    critical modules are tested on priority, so we can identify major design or development
    flaws first and fix them. However, lower-level modules may be tested inadequately.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lower-level modules can be replaced by Stubs which mock their functionality.
    Early prototypes are possible in this approach, as lower-level module logic can
    be stubbed out.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '![Integration tests](../Images/image00404.jpeg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
- en: Top-Down strategy of integration testing
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '**Big-bang**: This is the approach is one where all the components are integrated
    and tested at the very end of development. Since the integration tests come at
    the end, this approach saves time for development. However, this may not give
    enough time to test critical modules, as there may not be enough time to spend
    equally on all the components.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no specific software for general integration testing. A certain class
    of applications, such as web frameworks, define their own specific integration
    test frameworks. For example, some web frameworks like Django, Pyramid, and Flask
    have some specific testing frameworks developed by their own communities.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Another example is the popular `webtest` framework, which is useful for automated
    testing of the Python WSGI applications. A detailed discussion of such frameworks
    is outside the scope of this chapter and this book.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Test automation
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of tools on the Internet that are useful for automating integration
    testing of software applications. We will take a quick look at some of the popular
    ones here.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Test automation using Selenium Web Driver
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Selenium has been a popular choice for automating Integration, Regression, and
    Validation tests for a number of software applications. Selenium is free and open
    source, and comes with support for most popular web browser engines.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: In Selenium, the primary object is a **web driver**, which is a stateful object
    on the client side, representing a browser. The web driver can be programmed to
    visit URLs, perform actions (such as clicking, filling forms, and submitting forms),
    effectively replacing the human test subject, who usually performs these steps
    manually.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Selenium provides client driver support for most popular programming languages
    and runtimes.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the Selenium web driver in Python, use the following command:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We will look at a small example that uses Selenium along with pytest in order
    to implement a small automation test, which will test the Python website ([http://www.python.org](http://www.python.org))
    for some simple test cases.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Here is our test code. The module is named `selenium_testcase.py`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Before running the preceding example and showing the output, let us inspect
    the functions a bit.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Function `setUp` is a test fixture, which sets up the main object required for
    our test, that is, the Selenium Web driver for Firefox. We convert the `setUp`
    function to a context manager by decorating it with the `contextmanager` decorator
    from the `contextlib` module. At the end of the `setUp` function, the driver exits,
    since its `quit` method is called.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the test function `test_python_dot_org`, we set up a rather simple, contrived
    test for visiting the main Python website URL, and checking its title via an assertion.
    We then load the URL for the Python community by locating it on the main page,
    and then visit this URL. We finally assert its title and URL before ending our
    tests.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us see the program in action. We will specifically ask pytest to load only
    this module, and run it. The command line for this is as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The Selenium driver will launch the browser (Firefox), and open a window automatically,
    visiting the Python website URL while running the tests. The console output for
    the test is shown in the following image:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '![Test automation using Selenium Web Driver](../Images/image00405.jpeg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
- en: Console output of simple selenium test case on the Python programming language
    website
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Selenium can be used for more complex test cases, as it provides a number of
    methods for inspecting the HTML of pages, locating elements, and interacting with
    them. There are also plugins for Selenium, which can execute the JavaScript content
    of the pages to make the testing support complex interactions via JavaScript (such
    as AJAX requests).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Selenium can also be run on the server. It provides support for remote clients
    via its remote driver support. Browsers are instantiated on the server (typically,
    using virtual X sessions), whereas, the tests can be run and controlled from client
    machines via the network.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Test-Driven Development
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Test-Driven Development** (**TDD**), is an agile practice of software development,
    which uses a very short development cycle, where code is written to satisfy an
    incremental test case.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: In TDD, a functional requirement is mapped to a specific test case. Code is
    written to pass the first test case. Any new requirement is added as a new test
    case. Code is refactored to support the new test case. The process continues till
    the code is able to support the entire spectrum of user functionality.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps in TDD are as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Define a few starting test cases as a specification for the program.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write code to make the early test cases pass.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new test case defining new functionality.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run all the tests, and see if the new test fails or passes.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the new test fails, write some code for the test to pass.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests again.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 4 to 6 till the new test passes.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 3 to 7 to add a new functionality via test cases.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In TDD, the focus is on keeping everything simple, including the unit test cases
    and the new code that is added to support the test cases. TDD practitioners believe
    that writing tests upfront allows the developer to understand the product requirements
    better, allowing a focus on software quality from the very beginning of the development
    lifecycle.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: In TDD, often, a final refactoring step is also done after many tests have been
    added to the system in order to make sure no coding smells or antipatterns are
    introduced, and to maintain code readability and maintainability.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: There is no specific software for TDD, rather, it is a methodology and process
    for software development. Most of the time, TDD uses unit tests, so, the toolchain
    support is mostly the `unittest` module and the related packages that we've discussed
    in this chapter.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: TDD with palindromes
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us understand TDD as discussed earlier with a simple example of developing
    a program in Python, which checks whether an input string is a palindrome.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Palindrome is a string that reads the same in both directions. For example,
    *bob*, *rotator*, and *Malayalam* are palindromes. So is the sentence, *Madam,
    I'm Adam* when you get rid of the punctuations.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us follow the steps of TDD. Initially, we need a test case that defines
    the basic specification of the program. Our first version of the test code looks
    like this:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that the preceding code not only gives us a specification for the program
    in terms of its early functionality, but also gives a function name and signature—in
    terms of the argument and return value. We can list down the requirements for
    the first version by looking at the test.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: The function is named is `_palindrome`. It should accept a string, and return
    True if it is a palindrome, and False otherwise. The function sits in the module
    `palindrome`.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function should treat strings as case-insensitive.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these specifications, here is our first version of the `palindrome` module:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Let us check if this passes our test. We will run py.test on the test module
    to verify this.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '![TDD with palindromes](../Images/image00406.jpeg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
- en: 'Test output of test_palindrome.py version #1'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the last image, the basic test passes; so, we've got a first
    version of `palindrome` module, which works and passes its tests.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'Now as per the TDD step, let''s go to step (3), and add a new test case. This
    adds a check for testing palindrome strings with spaces. Here is the new test
    module with this extra test:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Let's run the updated test and see the results.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '![TDD with palindromes](../Images/image00407.jpeg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
- en: 'Test output of test_palindrome.py version #2'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: The test fails, because the code is not enabled to process palindrome strings
    with spaces in them. So let us do as TDD step (5) says, and write some code to
    make this test pass.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'Since it is clear we need to ignore spaces, a quick fix is to purge all spaces
    from the input string. Here is the modified palindrome module with this simple
    fix:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Let's now repeat step (4) of TDD to see if the updated code makes the test pass.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '![TDD with palindromes](../Images/image00408.jpeg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
- en: 'Console output of test_palindrome.py version #2, after code updates'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Surely, the code passes the test now!
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: What we just saw was an instance of TDD with one update cycle for implementing
    a module in Python, which checks strings for palindromes. In a similar way, one
    can keep adding tests, and keep updating the code as per step (8) of TDD, thereby
    adding new functionality while maintaining the updated tests naturally via the
    process.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: We conclude this section with the final version of our palindrome test case,
    which adds a testcase for checking for strings with extra punctuations.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And here is the updated palindrome module which makes this test pass:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Let's inspect the final output of the test `_palindrome` module on the console.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '![TDD with palindromes](../Images/image00409.jpeg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
- en: 'Console output of test_palindrome.py version #3, with matching code updates'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we revisited the definition of testability and its related
    architectural quality aspects, such as complexity and determinism. We looked at
    the different architectural aspects that are tested and got an understanding of
    the type of tests that are usually performed by the software testing process.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: We then discussed the various strategies for improving the testability of software,
    and looked at techniques to reduce system complexity, improve predictability,
    and to control and manage external dependencies. Along the way, we learned the
    different ways to virtualize and manage external dependencies, such as fakes,
    mocks and stubs, by way of examples.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at unit testing and its various aspects mainly from the perspective
    of the Python `unittest` module. We saw an example by using a datetime helper
    class, and explained how to write effective unit tests—a simple example followed
    by an interesting example of patching functions using the Mock library of `unittest`.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: We then introduced, and learned quite a bit about, the two other well-known
    testing frameworks in Python, namely, nose2 and py.test. Next we discussed the
    very important aspect of code coverage, and saw examples of measuring code coverage
    using the coverage.py package directly, and also by using it via plugins of nose2
    and pytest.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we sketched an example of a textsearch class for using
    advanced mock objects, where we mocked its external dependency and wrote a unit
    test case. We went on to discuss the Python doctest support of embedding tests
    in the documentation of classes, modules, methods, and functions via the doctest
    module while looking at examples.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: The next topic was integration tests, where we discussed the different aspects
    and advantages of integration tests, and looked at the three different ways in
    which tests can be integrated in a software organization. Test automation via
    Selenium was discussed next with an example of automating a couple of tests on
    the Python language website using Selenium and py.test.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: We ended the chapter with a quick overview of TDD, and discussed an example
    of writing a program for detecting palindromes in Python using the TDD principles,
    where we developed the program using tests in a step-by-step fashion.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at one of the most critical quality attribute
    of architecture when developing software—namely, Performance.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
