- en: Adding Advanced Animations to Your App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing items from a list component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Facebook reactions widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying images in fullscreen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we covered the basics of using the two main animation
    helpers in React Native: `Animated` and `LayoutAnimation`. In this chapter, we''ll
    take these concepts further by building out more complicated recipes that exhibit
    common native UX patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: Removing items from a list component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll learn how to create list items in a `ListView` with an
    animated sideways slide. If the user slides the item past a threshold, the item
    is removed. This is a common pattern in many mobile apps with editable lists.
    We are also going to see how to use `PanResponder` to handle drag events.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to create an empty app. For this recipe, we'll name it `removing-list-items`.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to create a new `ContactList` folder and two files inside it: `index.js` and `ContactItem.js`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by importing the dependencies for the main `App` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This component will be simple. All we need to render is a `toolbar` and the `ContactList` component
    that we imported in the previous step, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is all we need in order to start working on the actual list. Let''s open
    the file at `ContactList/index.js` and import all of the dependencies, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to define some data. In a real-world app, we would fetch the data
    from an API, but to keep things simple and focused only on the drag functionality,
    let''s just define the data in this same file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `state` for this component will only contain two properties: the data for
    the list and a Boolean value that will be updated when the dragging starts or
    ends. If you are not familiar with how `ListView` works, checkout the *Displaying
    a list of items* recipe in [Chapter 2](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml),
    *Creating a Simple React Native App*. Let''s define the data as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `render` method only needs to display the list. In the `renderScrollComponent` property,
    we''ll enable scrolling only when the user is not swiping an item on the list.
    If the user is swiping, we want to disable vertical scrolling, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `renderItem` method will return each item in the list. Here, we need to
    send the contact information as a property, along with three callbacks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to toggle the value of the swiping property on the `state` object,
    which will toggle whether vertical scroll on the list is locked or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When removing an item, we need to find the `index` of the given `contact` and
    then remove it from the original list. After that, we need to update `dataSource` on
    the state to re-render the list with the resulting data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We are done with the list, so now let''s focus on the list items. Let''s open
    the `ContactList/ContactItem.js` file and import the dependencies we''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to define `defaultProps` for this component. The `defaultProps` object
    will need an empty function for each of the four props being passed into it from
    the parent `ListView` element. The `onPress` function will execute when the item
    is pressed, the `onRemove` function will execute when the contact gets removed,
    and two drag functions will listen for drag events. On `state` , we only need
    to define an animated value to hold the *x*  and *y* coordinates of the dragging,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When the component is created, we need to configure `PanResponder`. We will
    do this in the `componentWillMount` life cycle hook. `PanResponder` is responsible
    for handling gestures. It provides a simple API to capture the events generated
    by the user''s finger, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s define the actual functions that will get executed for each callback
    defined in the previous step. We can start with the `handleShouldDrag` method,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`handleReleaseItem` is a little bit more complicated. We are going to split
    this method into two steps. First, we need to figure out whether the current item
    needs to be removed or not. In order to do that, we need to set a threshold. If
    the user slides the element beyond our threshold, we''ll remove the item, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the configurations for the animation, we are ready to move the
    item! First, we''ll execute the `onDragEnd` callback and, if the item should be
    removed, we''ll  run the `onRemove` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the full dragging system in place. Now we need to define the `render` method.
    We just need to display the contact name within the `TouchableHighlight` element,
    wrapped inside an `Animated.View`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We need one more method on this class, which is fired on layout change via
    the `View` element''s `onLayout` prop. `setThreshold` will get the current `width` of `row` and
    set `threshold`. In this case, we''re setting it to be a third of the width of
    the screen. These values are required to decide whether to remove the item or
    not, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll add some styles to the rows, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The final app should look something like this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/55bfe95b-94b3-4398-8c7e-660e00cd7dad.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 5*, we defined the `swiping` property on the `state`. This property
    is just a Boolean that will be set to `true` when the dragging starts and to `false` when
    it has completed. We need this information in order to lock the vertical scrolling
    on the list while dragging around the item.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 7*, we defined the content of each row in the list. The `onDragStart` property
    receives the `handleToggleSwipe` method, which will be executed when the dragging
    starts. We are also going to execute the same method when the dragging is completed.
  prefs: []
  type: TYPE_NORMAL
- en: In the same step, we also send the `handleRemoveContact` method to each item.
    As the name suggests, we are going to remove the current item from the list when
    the user swipes it out.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 11*, we defined `defaultProps` and `state` for the item component.
    In past recipes, we have been creating animations using a single value, but for
    this case we need to handle the *x* and *y* coordinates, so we'll need an instance
    of `Animated.ValueXY`. Internally, this class handles two `Animated.Value` instances,
    and therefore the API is almost identical to those we've seen before.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 12*, `PanResponder` gets created. The gesture system in React Native,
    like the event system in the browser, handles gestures in two phases when there''s
    a touch event: the capture and the bubble. In our case, we need to use the capture
    phase to figure out whether the current event is pressing the item or whether
    it''s trying to drag it. `onMoveShouldSetPanResponderCapture` will capture the
    event. Then, we need to decide whether we''ll drag the item or not by returning `true` or `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `onPanResponderMove` prop will get the values from the animation on each
    frame, which will be applied to the `pan` object in the `state`. We need to use `Animated.event` to
    access the animation values for each frame. In this case, we only need the `x` value.
    Later, we'll use this value to run a different animation while returning the element
    to its original place or removing it from the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The `onPanResponderRelease` function will be executed when the user releases
    the item. If, for any other reason, the dragging gets interrupted, `onPanResponderTerminate` will
    get executed instead.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 13*, we need to check whether the current event is a simple press or
    a drag. We can do this by checking the delta on the *x*-axis. If the touch event
    has been moved more than two pixels, then the user is trying to drag the item,
    otherwise, they're trying to press the button. We evaluate the difference as an
    absolute number because the movement could be from left to right or right to left,
    and we want to accommodate both movements.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 14*, we need to get the distance the item has moved with respect to
    the width of the device. If this distance is below our threshold we defined in `setThreshold`,
    then we need to remove these items. We are defining the `config` object for each
    animation, which will otherwise return the item to the original position. But
    if we need to remove the item, we check the direction and set the configuration
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 16*, we defined the JSX. We set the styles that we want to animate
    on `Animated.View`. In this case, it's the `left` property, but instead of manually
    creating an object, we can call the `getLayout` method from our instance of `Animated.ValueXY` that
    we stored in `state.pan`, which returns the top and left properties with their
    existing values.
  prefs: []
  type: TYPE_NORMAL
- en: In the same step, we also set the event handlers for `Animated.View` by spreading
    out `this.panResponder.panHandlers` with a spread operator, which binds the dragging
    configuration we defined in the previous steps to `Animated.View`.
  prefs: []
  type: TYPE_NORMAL
- en: We also defined a call to the `onPress` callback from `props`, passing in the
    current `contact` information.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the `PanResponder` API documentation at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/panresponder.html](https://facebook.github.io/react-native/docs/panresponder.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Facebook reactions widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll be creating a component that emulates the Facebook reaction
    widget. We will have a like button image which, when pressed, will show five icons.
    The row of icons will use a staggered slide-in animation while increasing opacity
    from `0` to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create an empty app called `facebook-widget`.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to need some images to display a fake timeline. A few pictures
    of your cat will work, or you can use the cat pictures included in the corresponding
    repository on GitHub ([https://github.com/warlyware/react-native-cookbook/tree/master/chapter-7/facebook-widget](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-7/facebook-widget)).
    We'll also need five icons to display the five reactions, such as, angry, laughing,
    heart, and surprised, which can also be found in the corresponding repository.
  prefs: []
  type: TYPE_NORMAL
- en: To start we'll create two JavaScript files in our empty app: `Reactions/index.js` and `Reactions/Icon.js`.
    We need to copy our cat pictures to an `images/` folder in the root of the app,
    and the reaction icons should be placed in `Reactions/images`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to be creating a fake Facebook timeline on the `App` class. Let''s
    start by importing the dependencies, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll need to import some images to render in our timeline. The JSX in this
    step is very simple: it''s just a `toolbar`, a `ScrollView` with two `Image`,
    and two `Reaction` components, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add some basic `styles` for this component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We are ready to start working on the `Reactions` component of this recipe.
    Let''s start by importing dependencies, as follows. We will build out the imported `Icon` component
    in later steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define `defaultProps` and the initial `state` next. We''ll also need
    to require the `like` icon image to display it on screen, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define two methods: one that sets the selected value of `state` to the
    selected `reaction`, and another that toggles the `show` value of `state` to show
    or hide the row of reactions accordingly, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll define the `render` method for this component. We are going to display
    an image, which when pressed, will call the `toggleReactions` method that we defined
    previously, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll notice in this step that we''re calling the `renderReactions` method.
    Next, we''ll render all of the icons that we want to display when the user presses
    the main reaction button, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to set `styles` for this component. We''ll set sizes for the reaction
    icon images and define some padding. The `reactions` container will have a height
    of `0`, since the icons will be floating, and we don''t want any extra space added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Icon` component is currently missing, so if we try to run our app at this
    point, it will fail. Let''s build out this component by opening the `Reactions/Icon.js` file
    and adding the imports for the component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define the icons we''ll be using. We are going to use an object for
    the icons so that we can easily retrieve each image by its key name, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we should define `defaultProps` for this component. We don''t need to define
    an initial state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The icons should appear on screen via an animation, so we''ll need to create
    and run the animation when the component is mounted, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When the icon is pressed, we need to execute the `onPress` callback to inform
    the parent that a reaction was selected. We will send the name of the reaction
    as a parameter, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The last piece of the puzzle is the `render` method, where we''ll define the
    JSX for this component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As the final step, we''ll add styles for each `icon`. We need the icons to
    float, so we''ll set `position` to `absolute` and `width` and `height` to `40` pixels.
    After this change, we should be able to run our app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The final app should look something like this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/6667bd05-b197-4847-85db-88e66021c454.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 2*, we defined the `Reactions` component in the timeline. For now,
    we are not focusing on handling data, but rather on displaying the UI. Therefore,
    we are not sending any callback via `Reactions` props to get the selected value.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, we defined `defaultProps` and the initial `state`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two properties in the state:'
  prefs: []
  type: TYPE_NORMAL
- en: The `show` prop is a Boolean. We use it to toggle the reactions icons when the
    user presses the main button. When `false`, we hide the reactions, and when `true`,
    we run the animation to show each icon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selected` contains the current selection. Every time a new reaction gets selected,
    we are going to update this prop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *step 8*, we render the icons. Here, we need to send the name of the icon
    to every instance created. We also send a `delay` of 100 milliseconds for each
    icon, which will create a nice stagger animation. The `onPress` prop receives
    the `onSelectReaction` method defined in *step 6*, which sets the selected reaction
    on `state`.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 13*, we create the animation. First, we define the `animatedValue` variable
    using the `Animated.Value` helper, which, as mentioned in previous recipes, is
    the class responsible for holding the value for each frame in the animation. As
    soon as the component is mounted, we run the animation. The animations progress
    from `0` to `1`, with a duration of 200 milliseconds and using an elastic easing
    function, and we delay the animation based on the received `delay` prop.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 15*, we defined the JSX for the `Icon` component. Here we animate the `top` and `opacity` properties.
    For the `top` property, we need to interpolate the values from `animatedValue`,
    so that the icon moves 95 pixels up from its original position. The required values
    for the `opacity` property are from `0` to `1`, and since we don't need to interpolate
    anything to accomplish this, we can use `animatedValue` directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `left` value is calculated based on the `index`: we just move the icon
    50 pixels to the left of the previous icon, which will avoid rendering the icons
    all in the sample place.'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying images in fullscreen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll create a timeline of images. When the user presses any
    of the images, it will fullscreen the image with a black background.
  prefs: []
  type: TYPE_NORMAL
- en: We will use an opacity animation for the background, and we'll slide the image
    in from its original position.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create an empty app called `photo-viewer`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we'll also create `PostContainer/index.js` for showing each image
    in the timeline, and `PhotoViewer/index.js` for showing the selected image in
    fullscreen.
  prefs: []
  type: TYPE_NORMAL
- en: You can either use the images included in this recipe's repository hosted on
    GitHub ([https://github.com/warlyware/react-native-cookbook/tree/master/chapter-7/photo-viewer](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-7/photo-viewer)),
    or use a few photos of your own. Place them in an `images` folder in the root
    of the project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to display a timeline with images in the `App` class. Let''s import
    all of the dependencies, including the two other components we''ll build out in
    later steps, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In this step, we''ll define the data that we are going to render. It''s just
    a simple array of objects containing `title` and `image`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to declare the initial `state` of this component. We will update
    the `selected` and `position` properties when any of the images gets pressed,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to update `state`, we are going to declare two methods: one to set
    the value of the image that has been pressed and another to remove those values
    when the viewer gets closed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to work on the `render` method. Here we''ll need to render
    each image inside `ScrollView` so the list will be scrollable, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous step, we are calling the `renderViewer` method. Here we''ll
    show the viewer component only if there''s a post `selected` in the state. We
    are also sending the initial position to start the animation and a callback to
    close the viewer, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The styles for this component are very simple, only some colors and padding,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The timeline is complete, but if we try to run our app, it will fail. Let''s
    work on the `PostContainer` component. We''ll start by importing the dependencies,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We only need two `props` for this component. The `post` prop will receive the
    image data, `title` and `image`, and the `onPress` prop is a callback that we''ll
    execute when the image gets pressed, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This component will be inside of `ScrollView`. This means its position will
    be changing when the user starts scrolling the content. When pressing the image,
    we need to get the current position on the screen and send this information to
    the parent component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to define the JSX for this component. To keep things simple, we
    are only going to render `image` and `title`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As always, we need to define some styles for this component. We are going to
    add some colors and padding, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the app now, we should be able to see the timeline, however if we
    press any of the images, an error will be thrown. We need to define the viewer,
    so let''s open the `PhotoViewer/index.js` file and import the dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define `props` for this component. In order to center the image on the
    screen, we need to know the `height` of the current device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to run two animations when showing this component, so we''ll need to
    initialize and run the animation after the component is mounted. The animation
    is simple: it just goes from `0` to `1` in `400` milliseconds with some easing
    applied, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user presses the close button, we need to execute the `onClose` callback
    to inform the parent that this component needs to be removed, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to split the `render` method into two steps. First, we need to
    interpolate the values for the animations, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We only need to define three elements: `Animated.View` to animate the background,
    `Animated.Image` to display the image, and a close button. We are setting the `opacity` style
    to the main view, which will animate the image background from transparent to
    black. The image will slide in at the same time, creating a nice effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We are almost done! The last step in this recipe is to define the styles. We
    need to set the position of the main container to absolute so that the image is
    on top of everything else. We''ll also move the close button to the top-right
    of the screen, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The final app should look similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/83d6acab-c119-4b20-88a1-d986453c805f.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 4*, we defined two properties on `state`: `selected` and `position`.
    The `selected` property holds the image data for the pressed image, which can
    be any of the `timeline` objects defined in *step 3*. The `position` property
    will hold the current *y-*coordinate on the screen, which is used later to animate
    the image from its original position to the center of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, we `map` over the `timeline` array to render each `post`. We used
    the `PostContainer` element for each post, sending the `post` information and
    using the `onPress` callback to set the pressed image.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 10*, we need the current position of the image. To achieve this, we
    use the `measure` method from the component we want to get the information from.
    This method receives a callback function and retrieves, among other properties, `width`, `height`,
    and the current position on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We are using a reference to access the component, declared in the JSX on the
    next step.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 11*, we declared the JSX for the component. In the main wrapper container,
    we set the `ref` property, which is used to get the current position of the image.
    Whenever we want to access a component on any of the methods of the current class,
    we use a reference. We can create references by simply setting the `ref` property
    and assigning a name to any component.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 18*, we interpolate the animation values to get the correct top value
    for each frame. The output of that interpolation will start from the current position
    of the image and progress to the middle of the screen. This way, depending on
    whether the values are negative or positive, the animation will run from bottom
    to top, or the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: We don't need to interpolate `opacity`, since the current animated value already
    goes from `0` to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An in depth explanation of Refs and the DOM can be found at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://reactjs.org/docs/refs-and-the-dom.html](https://reactjs.org/docs/refs-and-the-dom.html).'
  prefs: []
  type: TYPE_NORMAL
