- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coroutines and Lazy Generators
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computing has become a world of waiting, and we need support in our programming
    languages to be able to express *wait*. The general idea is to suspend (temporarily
    pause) the current flow and hand execution over to some other flow, whenever it
    reaches a point where we know that we might have to wait for something. This *something*
    that we need to wait for could be a network request, a click from a user, a database
    operation, or even a memory access that is taking too long for us to block at.
    Instead, we say in our code that we will wait, continue some other flow, and then
    come back when ready. Coroutines allow us to do that.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're mainly going to focus on coroutines added to C++20\.
    You will learn what they are, how to use them, and their performance characteristics.
    But we will also spend some time looking at coroutines in a broader sense, since
    the concept is apparent in many other languages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: C++ coroutines come with very little support from the standard library. Adding
    standard library support for coroutines is a high-priority feature for the C++23
    release. In order to use coroutines effectively in our day-to-day code, we need
    to implement some general abstractions. This book will show you how to implement
    these abstractions for the purpose of learning C++ coroutines rather than providing
    you with production-ready code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: It's also important to understand the various types of coroutines that exist,
    what coroutines can be used for, and what motivated C++ to add new language features
    to support coroutines.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers a lot of ground. The next chapter is also about coroutines
    but with a focus on asynchronous applications. In summary, this chapter will guide
    you through:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: General theory about coroutines, including the difference between stackful and
    stackless coroutines, and how they are transformed by the compiler and executed
    on a computer.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to stackless coroutines in C++. The new language support for
    coroutines in C++20 using `co_await`, `co_yield`, and `co_return` will be discussed
    and demonstrated.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The abstractions that are needed for using C++20 coroutines as generators.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few real-world examples that show the benefits in terms of readability and
    simplicity of using coroutines and how we can write composable components that
    will evaluate lazily by using coroutines.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you have been working with coroutines in other languages, you need to be
    prepared for two things before reading the rest of this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Some content may feel basic to you. Although the details about how C++ coroutines
    work are far from trivial, the usage examples might feel trivial to you.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some terms we will use in this chapter (coroutines, generators, tasks, and so
    forth) might not align with your current view of what these are.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, if you are completely new to coroutines, parts of this chapter
    may very well look like magic and take some time to grasp. I will therefore begin
    by showing you a few examples of how C++ code can look when using coroutines.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: A few motivating examples
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coroutines are one of those features, similar to lambda expressions, that offer
    a way to completely change the way we write and think about C++ code. The concept
    is very general and can be applied in many different ways. To give you a taste
    of how C++ can look when using coroutines, we will here look briefly at two examples.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Yield-expressions can be used for implementing generators—objects that produce
    sequences of values lazily. In this example, we will use the keywords `co_yield`
    and `co_return` to control the flow:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, `iota()` and `take_until()` are coroutines. `iota()`
    generates a sequence of integers and `take_until()` yields values until it finds
    the specified value. The `Generator` template is a custom type that I will show
    you how to design and implement later on in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Building generators is one common use case for coroutines, another one is implementing
    asynchronous tasks. The next example will demonstrate how we can use the operator
    `co_await` to wait for something without blocking the currently executing thread:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 构建生成器是协程的一个常见用例，另一个是实现异步任务。下一个示例将演示我们如何使用操作符`co_await`来等待某些内容，而不会阻塞当前执行的线程：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Instead of blocking, `co_await` suspends the execution until it gets resumed
    and the asynchronous read and write functions have completed. The example presented
    here is incomplete because we don't know what `Task`, `socket`, `buffer`, and
    the asynchronous I/O functions are. But we will get there in the next chapter
    when focusing on asynchronous tasks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`co_await`不会阻塞，而是在异步读写函数完成并恢复执行之前暂停执行。这里介绍的示例是不完整的，因为我们不知道`Task`、`socket`、`buffer`和异步I/O函数是什么。但是在下一章中，当我们专注于异步任务时，我们会了解到这些内容。'
- en: Don't worry if it is not clear how these examples work at this point—we will
    spend a lot of time delving into the details later on in this chapter. The examples
    are here to give you a hint about what coroutines allow us to do if you have never
    encountered them before.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目前还不清楚这些示例是如何工作的，不要担心——我们将在本章后面花费大量时间深入了解细节。这些示例是为了给你一个关于协程允许我们做什么的提示，如果你以前从未遇到过它们。
- en: Before digging into C++20 coroutines, we need to discuss some terminology and
    common foundational ground to better understand the design and motivation for
    adding a rather complicated language feature to C++ in 2020.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究C++20协程之前，我们需要讨论一些术语和共同的基础知识，以更好地理解为什么在2020年向C++中添加一个相当复杂的语言特性的设计和动机。
- en: The coroutine abstraction
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程抽象
- en: We will now take a step back and talk about coroutines in general and not just
    focus on the coroutines added to C++20\. This will give you a better understanding
    of why coroutines are useful but also what types of coroutines there are and how
    they differ. If you are already familiar with stackful and stackless coroutines
    and how they are executed, you can skip this section and jump right to the next
    section, *Coroutines in C++*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将退后一步，谈论一般的协程，而不仅仅是专注于添加到C++20的协程。这将让你更好地理解为什么协程是有用的，以及有哪些类型的协程以及它们之间的区别。如果你已经熟悉了有栈和无栈协程以及它们是如何执行的，你可以跳过这一部分，直接转到下一部分，*C++中的协程*。
- en: The coroutine abstraction has been around for more than 60 years and many languages
    have adopted some sort of coroutines into their syntax or standard libraries.
    This means that coroutines can denote slightly different things in different languages
    and environments. Since this is a book about C++, I will use the terminology used
    in the C++ standard.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 协程抽象已经存在了60多年，许多语言已经将某种形式的协程纳入其语法或标准库中。这意味着协程在不同的语言和环境中可能表示不同的东西。由于这是一本关于C++的书，我将使用C++标准中使用的术语。
- en: Coroutines are very similar to subroutines. In C++, we don't have anything explicitly
    called subroutines; instead, we write functions (free functions or member functions,
    for example) to create subroutines. I will use the terms **ordinary functions**
    and **subroutines** interchangeably.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 协程与子例程非常相似。在C++中，我们没有明确称为子例程的东西；相反，我们编写函数（例如自由函数或成员函数）来创建子例程。我将交替使用术语**普通函数**和**子例程**。
- en: Subroutines and coroutines
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子例程和协程
- en: 'To understand the difference between coroutines and subroutines (ordinary functions),
    we will here focus on the most basic properties of subroutines and coroutines,
    namely, how to start, stop, pause, and resume them. A subroutine is started when
    some other part of our program calls it. When the subroutine returns back to the
    caller, the subroutine stops:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解协程和子例程（普通函数）之间的区别，我们将在这里专注于子例程和协程的最基本属性，即如何启动、停止、暂停和恢复它们。当程序的其他部分调用子例程时，子例程就会启动。当子例程返回到调用者时，子例程就会停止：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The call chain of subroutines is strictly nested. In the diagram that follows,
    subroutine `f()` cannot return to `main()` until subroutine `g()` has returned:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 子例程的调用链是严格嵌套的。在接下来的图表中，子例程`f()`在子例程`g()`返回之前无法返回到`main()`：
- en: '![](img/B15619_12_01.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_01.png)'
- en: 'Figure 12.1: A chain of subroutine calls and returns'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：子例程调用和返回的链
- en: 'Coroutines can also be started and stopped just like subroutines, but they
    can also be **suspended** (paused) and **resumed**. If you haven''t worked with
    coroutines before, this may seem very strange at first. The point where a coroutine
    is suspended and resumed is called a **suspend/resume point**. Some suspend points
    are implicit whereas others are explicitly marked in the code in one way or another.
    The following pseudo code shows three explicit suspend/resume points marked using
    `await` and `yield`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 协程也可以像子例程一样启动和停止，但它们也可以被**挂起**（暂停）和**恢复**。如果你以前没有使用过协程，这一点可能一开始看起来很奇怪。协程被挂起和恢复的地方称为**挂起/恢复点**。有些挂起点是隐式的，而其他挂起点则以某种方式在代码中明确标记。以下伪代码显示了使用`await`和`yield`标记的三个显式挂起/恢复点：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In C++, the explicit suspend points are marked using the keywords `co_await`
    and `co_yield`. The diagram that follows shows how a coroutine is invoked (called)
    from one subroutine and then later resumed from different parts of the code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，使用关键字`co_await`和`co_yield`标记显式的挂起点。下面的图表显示了协程如何从一个子例程中调用，然后稍后从代码的不同部分恢复：
- en: '![](img/B15619_12_02.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_02.png)'
- en: 'Figure 12.2: An invocation of a coroutine can suspend and resume. The coroutine
    invocation maintains its internal state while being suspended.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：协程的调用可以挂起和恢复。协程调用在被挂起时保持其内部状态。
- en: The states of local variables inside a coroutine are preserved while the coroutine
    is suspended. The states belong to a certain invocation of a coroutine. That is,
    they are not like static local variables, which are globally shared among all
    invocations of a function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 协程被挂起时，协程内部的局部变量状态会被保留。这些状态属于协程的某次调用。也就是说，它们不像静态局部变量那样，静态局部变量在函数的所有调用之间是全局共享的。
- en: To summarize, coroutines are subroutines that also can be suspended and resumed.
    Another way to look at it is to say that subroutines are a specialization of coroutines
    that cannot be suspended or resumed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，协程是可以被挂起和恢复的子例程。另一种看待它的方式是说，子例程是无法被挂起或恢复的协程的一种特例。
- en: From now on, I will be very strict when distinguishing between *call* and *resume*,
    and *suspend* and *return*. They mean completely different things. Calling a coroutine
    creates a new instance of a coroutine that can be suspended and resumed. Returning
    from a coroutine destroys the coroutine instance and it can no longer be resumed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我将在区分*调用*和*恢复*，以及*挂起*和*返回*时非常严格。它们意味着完全不同的事情。调用协程会创建一个可以被挂起和恢复的协程的新实例。从协程返回会销毁协程实例，它将无法再恢复。
- en: To really understand how coroutines can help us write efficient programs, you
    need to be aware of some low-level details about how functions in C++ are usually
    transformed to machine code and then executed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正理解协程如何帮助我们编写高效的程序，您需要了解一些关于C++函数通常如何转换为机器代码然后执行的低级细节。
- en: Executing subroutines and coroutines on the CPU
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在CPU上执行子例程和协程
- en: We have talked about memory hierarchies, caches, virtual memory, scheduling
    of threads, and other hardware and operating system concepts in this book. But
    we haven't really talked about how instructions are being executed on the CPU
    using CPU registers and the stack. These concepts are important to understand
    when comparing subroutines with various flavors of coroutines.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们已经讨论了内存层次结构、缓存、虚拟内存、线程调度和其他硬件和操作系统概念。但我们并没有真正讨论指令是如何使用CPU寄存器和堆栈在CPU上执行的。当比较子例程与各种协程时，了解这些概念是很重要的。
- en: CPU registers, instructions, and the stack
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CPU寄存器、指令和堆栈
- en: This section will provide a very simplified model of a CPU for the purpose of
    understanding context switching, function calls, and a few more details regarding
    the call stack. When I say CPUs in this context, I refer to some CPUs that are
    similar to the x86 family of CPUs equipped with multiple general-purpose registers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将提供一个非常简化的CPU模型，以便理解上下文切换、函数调用以及关于调用堆栈的更多细节。在这种情况下，当我提到CPU时，我指的是一些类似于带有多个通用寄存器的x86系列CPU的CPU。
- en: A program contains a sequence of instructions that the CPU executes. The sequence
    of instructions is stored somewhere in the memory of the computer. The CPU keeps
    track of the address of the currently executing instruction in a register called
    a **program counter**. In that way, the CPU knows what instruction to execute
    next.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 程序包含CPU执行的一系列指令。指令序列存储在计算机的某个地方的内存中。CPU通过一个称为**程序计数器**的寄存器跟踪当前执行指令的地址。这样，CPU就知道下一个要执行的指令是什么。
- en: The CPU contains a fixed number of registers. A register is similar to a variable
    with a predefined name that can store a value or a memory address. Registers are
    the fastest data storage available on a computer and sit closest to the CPU. When
    the CPU manipulates data, it uses the registers. Some of the registers have a
    special meaning to the CPU, whereas other registers can be used more freely by
    the currently executing program.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: CPU包含固定数量的寄存器。寄存器类似于具有预定义名称的变量，可以存储值或内存地址。寄存器是计算机上最快的数据存储器，并且最接近CPU。当CPU操作数据时，它使用寄存器。一些寄存器对CPU具有特殊意义，而其他寄存器可以由当前执行的程序更自由地使用。
- en: 'Two very important registers that have a special meaning to the CPU are:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对CPU具有特殊意义的两个非常重要的寄存器是：
- en: '**Program counter** (**PC**): The register that stores the memory address of
    the currently executing instruction. This value is automatically incremented whenever
    an instruction is executed. Sometimes it is also called an *instruction pointer*.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序计数器**（**PC**）：存储当前执行指令的内存地址的寄存器。每当执行一条指令时，该值会自动递增。有时它也被称为*指令指针*。'
- en: '**Stack pointer** (**SP**): It stores the address of the top of the currently
    used call stack. Allocating and deallocating stack memory is a matter of changing
    the value stored in this single register.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆栈指针**（**SP**）：它存储当前使用的调用堆栈顶部的地址。分配和释放堆栈内存只是改变这个单个寄存器中存储的值的问题。'
- en: '![](img/B15619_12_03.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_03.png)'
- en: 'Figure 12.3: A CPU with registers'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：带有寄存器的CPU
- en: 'Assume that the registers are called **R0**, **R1**, **R2**, and **R3** as
    in the preceding diagram. A typical arithmetic instruction could then look like
    this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 假设寄存器被称为**R0**、**R1**、**R2**和**R3**，如前图所示。典型的算术指令可能如下所示：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Data can also be copied between registers and memory:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 数据也可以在寄存器和内存之间复制：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A set of instructions refers implicitly to the call stack. The CPU knows where
    the top of the call stack is through the stack pointer. Allocating memory on the
    stack is only a matter of updating the stack pointer. The value increases or decreases
    depending on whether the stack grows towards higher or lower addresses.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一组指令隐含地指向调用堆栈。CPU通过堆栈指针知道调用堆栈的顶部在哪里。在堆栈上分配内存只是更新堆栈指针的问题。该值增加或减少取决于堆栈是向更高地址还是更低地址增长。
- en: 'The following instruction uses the stack:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下指令使用了堆栈：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The push instruction copies the value in the register to the place in memory
    pointed at by the stack pointer *and* increments (or decrements) the stack pointer.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: push指令将寄存器中的值复制到由堆栈指针指向的内存位置，并递增（或递减）堆栈指针。
- en: 'We can also pop values from the stack by using the `pop` instruction, which
    also reads and updates the stack pointer:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`pop`指令从堆栈中弹出值，并读取和更新堆栈指针：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Whenever an instruction is executed, the CPU automatically increments the program
    counter. But the program counter can also be explicitly updated through instructions,
    for example, the `jump` instruction:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每当执行一条指令时，CPU会自动递增程序计数器。但程序计数器也可以通过指令明确更新，例如`jump`指令：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The CPU can operate in two modes: user mode or kernel mode. The CPU registers
    are used differently when running in user mode and kernel mode. When the CPU is
    executing in user mode, it runs with restricted privileges that cannot access
    hardware. The operating system provides system calls that run in kernel mode.
    A C++ library function such as `std::puts()`, which prints values to `stdout`,
    must therefore make a system call to complete its task, forcing the CPU to switch
    between user mode and kernel mode.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: CPU可以以两种模式运行：用户模式或内核模式。当CPU在用户模式下运行时，它以不同的方式使用CPU寄存器。当CPU在用户模式下执行时，它以无法访问硬件的受限权限运行。操作系统提供在内核模式下运行的系统调用。因此，C++库函数（例如`std::puts()`）必须进行系统调用才能完成其任务，迫使CPU在用户模式和内核模式之间切换。
- en: Transitioning between user and kernel mode is expensive. To understand why,
    let's think about our schematic CPU again. The CPU operates efficiently by using
    its registers and therefore avoids spilling values onto the stack unnecessarily.
    But the CPU is a shared resource among all user processes and the operating system,
    and whenever we need to switch between tasks (for example, when entering kernel
    mode), the state of the processor, including all of its registers, needs to be
    saved in memory so that it can be resumed later on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户模式和内核模式之间转换是昂贵的。要理解原因，让我们再次考虑我们的示意CPU。CPU通过使用其寄存器高效运行，因此避免不必要地将值溢出到堆栈上。但是CPU是所有用户进程和操作系统之间共享的资源，每当我们需要在任务之间切换时（例如，进入内核模式时），处理器的状态，包括其所有寄存器，都需要保存在内存中，以便以后可以恢复。
- en: Call and return
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用和返回
- en: Now that you have a basic understanding of how the CPU uses registers and the
    stack, we can discuss subroutine invocations. There are a lot of mechanisms involved
    when calling and returning from a subroutine that we might take for granted. Our
    compilers are doing an excellent job when they transform a C++ function to highly
    optimized machine code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经基本了解了CPU如何使用寄存器和堆栈，我们可以讨论子例程调用。在调用和返回子例程时涉及许多机制，我们可能会认为这是理所当然的。当编译器将C++函数转换为高度优化的机器代码时，它们的工作非常出色。
- en: 'The following list shows the aspects that need to be considered when calling,
    executing, and returning from a subroutine:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了调用、执行和从子例程返回时需要考虑的方面：
- en: Calling and returning (jumping between points in the code).
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用和返回（在代码中跳转）。
- en: Passing parameters—parameters can be passed through registers or on the stack,
    or both.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递参数——参数可以通过寄存器或堆栈传递，也可以两者兼而有之。
- en: Allocating storage for local variables on the stack.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在堆栈上为局部变量分配存储空间。
- en: Returning a value—the value returned from a subroutine needs to be stored in
    a place where the caller can find it. Typically, this is a dedicated CPU register.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值——从子例程返回的值需要存储在调用者可以找到的地方。通常，这是一个专用的CPU寄存器。
- en: Using registers without interfering with other functions—the registers that
    a subroutine uses need to be restored to the state they were in before the subroutine
    was called.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不干扰其他函数的情况下使用寄存器——子例程使用的寄存器需要在调用子例程之前恢复到其调用之前的状态。
- en: The exact details about how function calls are carried out are specified by
    something called **calling conventions**. They provide a protocol for the caller/callee
    to agree on who is responsible for which parts. Calling conventions differ among
    CPU architectures and compilers and are one of the major parts that constitutes
    an **application binary interface** (**ABI**).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何执行函数调用的确切细节由称为**调用约定**的东西指定。它们为调用者/被调用者提供了一个协议，以便双方就谁负责哪些部分达成一致。调用约定在CPU架构和编译器之间不同，并且是构成**应用程序二进制接口**（**ABI**）的主要部分之一。
- en: 'When a function is being called, a **call frame** (or activation frame) for
    that function is being created. The call frame contains:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用函数时，该函数的**调用帧**（或激活帧）被创建。调用帧包含：
- en: The *parameters* passed to the function.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给函数的*参数*。
- en: The *local variables* of the function.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的*局部变量*。
- en: A *snapshot of the registers* that we intend to use and therefore need to restore
    before returning.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们打算使用的寄存器的*快照*，因此需要在返回之前恢复。
- en: A *return address* that links back to the place in memory where the caller invoked
    the function from.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*返回地址*，它链接回调用者从中调用函数的内存位置。'
- en: An optional *frame pointer* that points back to the top of the caller's call
    frame. Frame pointers are useful for debuggers when inspecting the stack. We will
    not discuss frame pointers further in this book.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的*帧指针*，指向调用者的调用帧顶部。在检查堆栈时，帧指针对调试器很有用。我们在本书中不会进一步讨论帧指针。
- en: Thanks to the strictly nested nature of subroutines, we can save the call frames
    of the subroutines on the stack to support nested calls very efficiently. A call
    frame stored on the stack is usually called a **stack frame**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于子例程的严格嵌套性质，我们可以将子例程的调用帧有效地保存在堆栈上，以支持嵌套调用。存储在堆栈上的调用帧通常称为**堆栈帧**。
- en: 'The following diagram shows multiple call frames on a call stack and highlights
    the contents of a single call frame:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了调用堆栈上的多个调用帧，并突出显示了单个调用帧的内容：
- en: '![](img/B15619_12_04.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_04.png)'
- en: 'Figure 12.4: A call stack with multiple call frames. The call frame on the
    right-hand side is a zoomed-in version of a single call frame.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：具有多个调用帧的调用堆栈。右侧的调用帧是单个调用帧的放大版本。
- en: When a subroutine returns back to its caller, it uses the return address to
    know where to jump, restores the registers it has mutated, and pops (deallocates)
    the entire call frame off the stack. In this way, both the stack and the registers
    are restored to the states they were in before the call of the subroutine was
    invoked. However, there are two exceptions. Firstly, the program counter (PC)
    has moved to the instruction after the call. Secondly, a subroutine that returns
    a value back to its caller usually stores that value in a dedicated register where
    the caller knows where to find it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当子程序返回给调用者时，它使用返回地址来知道要跳转到哪里，恢复它已经改变的寄存器，并弹出（释放）整个调用帧。通过这种方式，堆栈和寄存器都恢复到调用子程序被调用之前的状态。但是，有两个例外。首先，程序计数器（PC）已经移动到调用后的指令。其次，将值返回给其调用者的子程序通常将该值存储在一个专用寄存器中，调用者知道在哪里找到它。
- en: After understanding how a subroutine is executed by temporarily using the stack
    and then restoring the CPU registers before returning control back to its caller,
    we can now start to look at how it's possible to suspend and resume coroutines.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 理解了子程序是如何通过临时使用堆栈来执行，然后在将控制返回给调用者之前恢复CPU寄存器，我们现在可以开始看看如何挂起和恢复协程。
- en: Suspend and resume
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挂起和恢复
- en: 'Consider the following pseudo code that defines a coroutine with multiple suspend/resume
    points:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下伪代码，定义了一个具有多个挂起/恢复点的协程：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When `coroutine()` suspends, we can no longer remove the call frame as we do
    when a subroutine returns back to its caller. Why? Because we need to keep the
    current value of the variable, `x`, and also remember *where* in the coroutine
    we should continue executing the next time the coroutine is resumed. This information
    is placed into something called a **coroutine frame**. The coroutine frame contains
    all the information that is needed in order to resume a paused coroutine. This
    raises several new questions, though:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当`coroutine()`挂起时，我们无法像子程序返回给调用者时那样删除调用帧。为什么？因为我们需要保留变量`x`的当前值，并且还需要记住在协程中应该在*何处*继续执行下次协程恢复时。这些信息被放入一个称为**协程帧**的东西中。协程帧包含恢复暂停协程所需的所有信息。然而，这引发了一些新问题：
- en: Where is the coroutine frame stored?
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程帧存储在哪里？
- en: How big is the coroutine frame?
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程帧有多大？
- en: When a coroutine calls a subroutine, it needs a stack to manage the nested call
    frames. What happens if we try to resume from within a nested call frame? Then
    we would need to restore the entire stack when the coroutine resumes.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当协程调用子程序时，它需要一个堆栈来管理嵌套的调用帧。如果我们尝试从嵌套的调用帧内恢复会发生什么？那么当协程恢复时，我们需要恢复整个堆栈。
- en: What is the runtime overhead of calling and returning from a coroutine?
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用和从协程返回的运行时开销是多少？
- en: What is the runtime overhead of suspending and resuming a coroutine?
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂起和恢复协程的运行时开销是多少？
- en: 'The short answer to these questions is that it depends on what type of coroutine
    we are discussing: stackless or stackful coroutines.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些问题的简短回答是，这取决于我们讨论的协程类型：无堆栈或有堆栈的协程。
- en: 'Stackful coroutines have a separate side stack (similar to a thread) that contains
    the coroutine frame and the nested call frames. This makes it possible to suspend
    from nested call frames:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有堆栈的协程有一个单独的侧堆栈（类似于线程），其中包含协程帧和嵌套的调用帧。这使得可以从嵌套的调用帧中挂起：
- en: '![](img/B15619_12_05.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_05.png)'
- en: 'Figure 12.5: Each call to a stackful coroutine creates a separate side stack
    with a unique stack pointer'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：对堆栈协程的每次调用都会创建一个具有唯一堆栈指针的单独侧堆栈
- en: Suspending and resuming stackless coroutines
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挂起和恢复无堆栈协程
- en: Stackless coroutines need to store the coroutine frame somewhere else (typically
    on the heap) and then use the stack of the currently executing thread to store
    nested call frames.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 无堆栈协程需要在其他地方（通常在堆上）存储协程帧，然后使用当前执行线程的堆栈来存储嵌套调用帧。
- en: 'But this is not the entire truth. The caller is the one responsible for creating
    the call frame, saving the return address (current value of the program counter),
    and the parameters on the stack. The caller doesn''t know that it is calling a
    coroutine that will suspend and resume. Therefore, the coroutine itself needs
    to create the coroutine frame and copy the parameters and registers from the call
    frame to the coroutine frame when it is called:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是全部真相。调用者负责创建调用帧，保存返回地址（程序计数器的当前值）和堆栈上的参数。调用者不知道自己正在调用一个会挂起和恢复的协程。因此，协程本身在被调用时需要创建协程帧，并将参数和寄存器从调用帧复制到协程帧中：
- en: '![](img/B15619_12_06.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_06.png)'
- en: 'Figure 12.6: A stackless coroutine has a separate coroutine frame (usually
    on the heap) that contains the state necessary for resuming the coroutine'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：无堆栈协程具有单独的协程帧（通常在堆上），其中包含恢复协程所需的状态
- en: 'When a coroutine initially suspends, the stack frame for the coroutine is popped
    from the stack, but the coroutine frame continues to live on. A memory address
    (handle/pointer) to the coroutine frame is returned back to the caller:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当协程最初挂起时，协程的堆栈帧从堆栈中弹出，但协程帧继续存在。协程帧的内存地址（句柄/指针）被返回给调用者：
- en: '![](img/B15619_12_07.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_07.png)'
- en: 'Figure 12.7: A suspended coroutine. The coroutine frame contains all the information
    required for resuming the coroutine.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：挂起的协程。协程帧包含恢复协程所需的所有信息。
- en: 'To resume a coroutine, the caller uses the handle it received earlier and calls
    a resume function and passes the coroutine handle as a parameter. The resume function
    uses the suspend/resume point stored in the coroutine frame to continue executing
    the coroutine. The call to the resume function is also an ordinary function call
    that will generate a stack frame as illustrated in the following diagram:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要恢复协程，调用者使用先前收到的句柄，并调用一个恢复函数，并将协程句柄作为参数传递。恢复函数使用存储在协程帧中的挂起/恢复点来继续执行协程。对恢复函数的调用也是一个普通的函数调用，将生成一个堆栈帧，如下图所示：
- en: '![](img/B15619_12_08.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.8: Resuming a coroutine creates a new call frame for the resume call.
    The resume function uses the handle to the coroutine state to resume from the
    right suspend point.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, when a coroutine returns, it is usually suspended and eventually deallocated.
    The state of the stack is shown in the following diagram:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15619_12_09.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.9: The coroutine frame is deallocated when it returns'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: An important consequence of not having a separate side stack per coroutine invocation
    is that when a stackless coroutine is suspended, it cannot have any nested call
    frames left on the stack. Remember, when the control is transferred back to the
    caller, the caller's call frame must be on the top of the stack.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: As a final note, it should also be mentioned that the memory needed for the
    coroutine frame could be allocated *within* the call frame of the caller under
    some circumstances. We will discuss that in more detail when looking at C++20
    coroutines.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Stackless versus stackful coroutines
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated in the previous section, stackless coroutines use the stack of the
    currently running thread to handle nested function calls. The effect of this is
    that a stackless coroutine can never suspend from a nested call frame.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Stackful coroutines are sometimes called **fibers**, and in the programming
    language Go, they are called **goroutines**. Stackful coroutines remind us of
    threads, where each thread manages its own stack. There are two big differences
    between stackful coroutines (or fibers) and OS threads, though:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: OS threads are scheduled by the kernel and switching between two threads is
    a kernel mode operation.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most OSes switch OS threads **preemptively** (the thread is interrupted by the
    scheduler), whereas a switch between two fibers happens **cooperatively**. A running
    fiber keeps running until it passes control over to some manager that can then
    schedule another fiber.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also a category of threads called **user-level threads** or **green
    threads**. These are lightweight threads that don't involve kernel mode switching
    (because they run in user mode and are therefore unknown to the kernel). Fibers
    are one example of user-level threads. But it is also possible for user-level
    threads to be scheduled preemptively by a user library or by a virtual machine.
    Java threads are one example of preemptive user-level threads.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Stackless coroutines also allow us to write and compose multiple concurrently
    running tasks but without the need for an individual side stack per flow. Stackless
    coroutines and state machines are tightly related. It's possible to transform
    a state machine into a coroutine and vice versa. Why is this useful to know? Firstly,
    it gives you a better understanding of what stackless coroutines are. Secondly,
    if you are already good at identifying problems that can be solved using state
    machines, you can more easily see where coroutines might fit in as an appropriate
    solution. State machines are very general abstractions and can be applied to a
    great variety of problems. However, some areas where state machines are usually
    applied are parsing, gesture recognition, and I/O multiplexing, to mention a few.
    These are all areas where stackless coroutine can really shine both in terms of
    expressiveness and performance.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Performance cost
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Coroutines are an abstraction that allow us to write lazy evaluated code and
    asynchronous programs in a clear and concise way. But there is a performance cost
    related to creating and destroying coroutines as well as suspending and resuming
    coroutines. When comparing the performance cost of stackless and stackful coroutines,
    two main aspects need to be addressed: *memory footprint* and *context switching*.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Memory footprint
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Stackful coroutines need a separate call stack in order to handle suspension
    from within nested call frames. When calling a coroutine, we therefore need to
    dynamically allocate a chunk of memory for this new side stack. This immediately
    raises the question: how big a stack do we need to allocate? Unless we have some
    policy regarding how much stack a coroutine and its nested call frames can consume,
    we probably need to have a stack of approximately the same size as a normal call
    stack of a thread.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有栈协程需要一个单独的调用栈来处理来自嵌套调用帧的挂起。因此，在调用协程时，我们需要动态分配一块内存来存储这个新的侧栈。这立即引发了一个问题：我们需要分配多大的栈？除非我们有关于协程及其嵌套调用帧可以消耗多少栈的一些策略，否则我们可能需要一个大约与线程的正常调用栈大小相同的栈。
- en: Some implementations have experimented with a segmented stack, which would allow
    the stack to grow if necessary. Another alternative is to start with a small contiguous
    stack and then copy the stack to a bigger newly allocated memory region when needed
    (similar to how `std::vector` grows). The coroutine implementation in Go (goroutines)
    has switched from using a segmented stack to a dynamically growing contiguous
    stack.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一些实现已经尝试使用分段栈，这将允许栈在必要时增长。另一种选择是从一个小的连续栈开始，然后在需要时将栈复制到一个更大的新分配的内存区域（类似于`std::vector`的增长）。Go语言中的协程实现（goroutines）已经从使用分段栈切换到了动态增长的连续栈。
- en: Stackless coroutines do not need to allocate memory for a separate side stack.
    Instead, they need a single allocation for storing each coroutine frame in order
    to support suspend and resume. This allocation happens when the coroutine is called
    (but not on suspend/resume). The call frame is deallocated when the coroutine
    returns.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 无栈协程不需要为单独的侧栈分配内存。相反，它们需要为每个协程帧分配一个单独的内存以支持挂起和恢复。这种分配发生在调用协程时（但不是在挂起/恢复时）。当协程返回时，调用帧被释放。
- en: 'In summary, stackful coroutines demand a big initial memory allocation for
    the coroutine frame and the side stack, or need to support a growing stack. Stackless
    coroutines only need to allocate memory for the coroutine frame. The memory footprint
    of calling a coroutine can be summarized as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，有栈协程需要为协程帧和侧栈进行大量的初始内存分配，或者需要支持一个增长的栈。无栈协程只需要为协程帧分配内存。调用协程的内存占用可以总结如下：
- en: 'Stackless: Coroutine frame'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无栈：协程帧
- en: 'Stackful: Coroutine frame + call stack'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有栈：协程帧+调用栈
- en: The next aspect of performance cost relates to suspending and resuming coroutines.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 性能成本的下一个方面与挂起和恢复协程有关。
- en: Context switching
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上下文切换
- en: Context switching can occur at different levels. In general, a context switch
    happens when we need the CPU to switch between two or many ongoing tasks. The
    task that is about to be paused needs to save the entire state of the CPU so that
    it can be restored at a later stage.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文切换可以发生在不同的级别。一般来说，当我们需要CPU在两个或多个正在进行的任务之间切换时，就会发生上下文切换。即将暂停的任务需要保存CPU的整个状态，以便在以后恢复时可以恢复。
- en: Switching between different processes and OS threads are fairly expensive operations
    that involve system calls, requiring the CPU to enter kernel mode. Memory caches
    are invalidated and, for process switching, the tables that contain the mappings
    between the virtual memory and physical memory need to be replaced.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同进程和操作系统线程之间切换是相当昂贵的操作，涉及系统调用，需要CPU进入内核模式。内存缓存被使无效，对于进程切换，包含虚拟内存和物理内存映射的表需要被替换。
- en: Suspending and resuming coroutines is also a kind of context switch because
    we are switching between multiple concurrent flows. Switching between coroutines
    is substantially faster than switching between processes and OS threads, partly
    because it doesn't involve any system calls that require the CPU to run in kernel
    mode.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 挂起和恢复协程也是一种上下文切换，因为我们在多个并发流之间切换。在协程之间切换比在进程和操作系统线程之间切换要快得多，部分原因是它不涉及需要CPU在内核模式下运行的任何系统调用。
- en: However, there is still a difference when switching between stackful coroutines
    and switching between stackless coroutines. The relative runtime performance of
    the context switches of stackful versus stackless coroutines can depend on the
    call patterns. But, in general, a stackful coroutine has a more expensive context
    switch operation since it has more information to save and restore during suspend
    and resume compared to a stackless coroutine. Resuming a stackless coroutine is
    comparable to a normal function call.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当在有栈协程和无栈协程之间切换时仍然存在差异。有栈协程和无栈协程的上下文切换的相对运行时性能可能取决于调用模式。但总的来说，有栈协程的上下文切换操作更昂贵，因为在挂起和恢复时需要保存和恢复更多的信息，而无栈协程的恢复类似于正常的函数调用。
- en: The stackless versus stackful debate has been going on in the C++ community
    for quite a few years now and I will do my best to stay away from the debate by
    concluding that they both have valid use cases—some use cases will favor stackful
    coroutines and other use cases will favor stackless coroutines.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 关于有栈与无栈的辩论在C++社区已经进行了好几年，我会尽力避开这场辩论，总结它们都有有效的用例——有些用例会偏向有栈协程，而其他用例会偏向无栈协程。
- en: This section took a little detour for the purpose of you having a better understanding
    of how coroutines execute and perform. Let's have a short recap of what you have
    learned.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你更好地理解协程的执行和性能，这一部分稍微偏离了一下。让我们简要回顾一下你学到的内容。
- en: What you have learned so far
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 到目前为止你学到的内容
- en: Coroutines are functions that can be suspended and resumed. An ordinary function
    does not have this ability, which makes it possible to remove the call frame of
    a function that returns. However, a coroutine that is suspended needs to keep
    the call frame alive to be able to restore the state of the coroutine once it
    gets resumed. Coroutines are more powerful than subroutines and involve more bookkeeping
    in the generated machine code. However, thanks to the close relationship between
    coroutines and ordinary functions, the compilers of today are very good at optimizing
    stackless coroutines.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是可以挂起和恢复的函数。普通函数没有这种能力，这使得可以删除返回的函数的调用帧。然而，一个被挂起的协程需要保持调用帧活动，以便在恢复时能够恢复协程的状态。协程比子例程更强大，并且在生成的机器代码中涉及更多的簿记工作。然而，由于协程与普通函数之间的密切关系，今天的编译器非常擅长优化无堆栈协程。
- en: Stackful coroutines can be seen as non-preemptive user-level threads, whereas
    stackless coroutines offer a way to write state machines in a direct imperative
    fashion using the keywords `await` and `yield` to specify the suspend points.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈式协程可以看作是非抢占式用户级线程，而无堆栈协程提供了一种以直接命令方式编写状态机的方法，使用关键字`await`和`yield`来指定挂起点。
- en: After this introduction to the general coroutine abstraction, it's now time
    to understand how stackless coroutines are implemented in C++.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在对协程的一般抽象介绍之后，现在是时候了解C++中如何实现无堆栈协程。
- en: Coroutines in C++
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的协程
- en: The coroutines added to C++20 are stackless coroutines. There are options to
    use stackful coroutines in C++ as well by using third-party libraries. The most
    well-known cross-platform library is Boost.Fiber. C++20 stackless coroutines introduce
    new language constructs, while Boost.Fiber is a library that can be used with
    C++11 and onward. We will not discuss stackful coroutines any further in this
    book but will instead focus on the stackless coroutines that have been standardized
    in C++20\.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: C++20中添加的协程是无堆栈协程。也有使用第三方库在C++中使用堆栈式协程的选项。最知名的跨平台库是Boost.Fiber。C++20无堆栈协程引入了新的语言构造，而Boost.Fiber是一个可以在C++11及以后版本中使用的库。在本书中我们不会进一步讨论堆栈式协程，而是专注于C++20中标准化的无堆栈协程。
- en: 'The stackless coroutines in C++20 were designed with the following goals:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: C++20中的无堆栈协程设计有以下目标：
- en: Scalable in the sense that they add very little memory overhead. This makes
    it possible to have many more coroutines alive compared to the possible number
    of threads or stackful coroutines alive.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内存开销方面可扩展，这使得可以有更多的协程同时存在，与可能存在的线程或堆栈式协程数量相比。
- en: Efficient context switching, which means that suspending and resuming a coroutine
    should be about as cheap as an ordinary function call.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效的上下文切换，这意味着挂起和恢复协程应该与普通函数调用一样廉价。
- en: Highly flexible. C++ coroutines have more than 15 customization points, which
    gives application developers and library writers a lot of freedom to configure
    and shape coroutines as they like. Decisions about how coroutines are supposed
    to work can be determined by us developers rather than being hardcoded in a language
    specification. One example is whether a coroutine should be suspended directly
    after being called or continue executing to the first explicit suspend point.
    Such questions are usually hard-coded in other languages, but in C++ we can customize
    this behavior using customization points.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度灵活。C++协程有15多个自定义点，这为应用程序开发人员和库编写人员提供了很大的自由度，可以根据自己的喜好配置和塑造协程。关于协程应该如何工作的决定可以由我们开发人员确定，而不是硬编码在语言规范中。一个例子是协程在被调用后是否应该直接挂起，还是继续执行到第一个显式挂起点。在其他语言中，这些问题通常是硬编码的，但在C++中，我们可以使用自定义点来定制这种行为。
- en: Do not require C++ exceptions to handle errors. This means that you can use
    coroutines in environments where exceptions are turned off. Remember that coroutines
    are a low-level feature comparable to ordinary functions, which can be highly
    useful in embedded environments and systems with real-time requirements.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要求C++异常来处理错误。这意味着您可以在关闭异常的环境中使用协程。请记住，协程是一种低级功能，类似于普通函数，在嵌入式环境和具有实时要求的系统中非常有用。
- en: With these goals in mind, it's probably not a surprise that C++ coroutines can
    be a bit complicated to grasp at first.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些目标，C++协程可能一开始会有点复杂。
- en: What's included in standard C++ (and what's not)?
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准C++中包含了什么（以及不包含什么）？
- en: Some C++ features are pure library features (such as the Ranges library) whereas
    other features are pure language features (such as type inference with the help
    of the `auto` keyword). However, some features require additions to both the core
    language and the standard library. C++ coroutines are one of those features; they
    introduce new keywords to the language, but also add new types to the standard
    library.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一些C++特性是纯库特性（例如Ranges库），而其他特性是纯语言特性（例如使用`auto`关键字进行类型推断）。然而，有些特性需要对核心语言和标准库进行补充。C++协程就是其中之一；它们为语言引入了新的关键字，同时也向标准库添加了新的类型。
- en: 'On the language side, to recap, we have the following keywords related to coroutines:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在语言方面，总结一下，我们有以下与协程相关的关键字：
- en: '`co_await`: An operator that suspends the current coroutine'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`co_await`：挂起当前协程的运算符'
- en: '`co_yield`: Returns a value to the caller and suspends the coroutine'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`co_yield`：向调用者返回一个值并挂起协程'
- en: '`co_return`: Completes the execution of a coroutine and can, optionally, return
    a value'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`co_return`：完成协程的执行，并且可以选择返回一个值'
- en: 'On the library side, there is a new `<coroutine>` header including the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在库方面，有一个新的`<coroutine>`头文件，其中包括以下内容：
- en: '`std::coroutine_handle`: A template class that refers to the coroutine state,
    enabling the suspending and resuming of the coroutine'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::coroutine_handle`：引用协程状态的模板类，使协程能够挂起和恢复'
- en: '`std::suspend_never`: A trivial awaitable type that never suspends'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::suspend_never`：一个从不挂起的平凡等待类型'
- en: '`std::suspend_always`: A trivial awaitable type that always suspends'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::coroutine_traits`: Used to define the promise type of a coroutine'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The library types that comes with C++20 are the absolute minimum. For example,
    the infrastructure for communicating between the coroutine and the caller is not
    part of the C++ standard. Some of the types and functions that we need in order
    to use coroutines effectively in our application code have already been suggested
    in new C++ proposals, for example the template classes `task` and `generator`
    and the functions `sync_wait()` and `when_all()`. The library part of C++ coroutines
    will most likely be complemented in C++23.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: In this book, I will provide some simplified types for filling this gap instead
    of using a third-party library. By implementing those types, you will get a deep
    understanding of how C++ coroutines work. However, designing robust library components
    that can be used with coroutines is hard to get right without introducing lifetime
    issues. So, if you are planning to use coroutines in your current project, using
    a third-party library may be a better alternative to implementing them from scratch.
    At the time of writing, the **CppCoro** library is the de facto standard for these
    general-purpose primitives. The library was created by Lewis Baker and is available
    at [https://github.com/lewissbaker/cppcoro](https://github.com/lewissbaker/cppcoro).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: What makes a C++ function a coroutine?
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A C++ function is a coroutine if it contains any of the keywords `co_await`,
    `co_yield`, or `co_return`. In addition, the compiler puts special requirements
    on the return type of a coroutine. But, nevertheless, we need to inspect the definition
    (the body) and not only the declaration to know whether we are facing a coroutine
    or an ordinary function. This means that the caller of a coroutine doesn't need
    to know whether it calls a coroutine or an ordinary function.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to ordinary functions, a coroutine also has the following restrictions:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: A coroutine cannot use variadic arguments like `f(const char*...)`
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A coroutine cannot return `auto` or a concept type: `auto f()`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A coroutine cannot be declared `constexpr`
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructors and destructors cannot be coroutines
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `main()` function cannot be a coroutine
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the compiler has decided that a function is a coroutine, it associates
    the coroutine with a number of types for making the coroutine machinery work.
    The following diagram highlights the different components that are involved when
    a *caller* uses a *coroutine*:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15619_12_10.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.10: Relationship between a coroutine and its caller'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The caller and the coroutine are the actual functions we will normally implement
    in our application code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The **Return Object** is the type that the coroutine returns and is typically
    a general class template designed for some specific use case, for example, *generators*
    or *asynchronous tasks*. The *caller* interacts with the return object to resume
    the coroutine and to get values emitted from the coroutine. The return object
    usually delegates all its calls to the coroutine handle.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The **Coroutine Handle** is a non-owning handle to the **Coroutine State**.
    Through the coroutine handle we can resume and destroy the coroutine state.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The *coroutine state* is what I have previously referred to as the coroutine
    frame. It's an opaque object, which means that we don't know its size and we cannot
    access it in any other way than through the handle. The coroutine state stores
    everything necessary in order to resume the coroutine where it was last suspended.
    The coroutine state also contains the **Promise**.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The promise object is what the coroutine itself communicates with indirectly
    through the keywords `co_await`, `co_yield`, and `co_return`. If values or errors
    are submitted from the coroutine, they will first reach the promise object. The
    promise object acts like a channel between the coroutine and the caller, but neither
    of them have direct access to the promise.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Admittedly, this can look pretty dense at first sight. A complete but minimal
    example will help you understand the different parts a little better.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: A minimal but complete example
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with a minimal example for the purpose of understanding how coroutines
    work. Firstly, we implement a small *coroutine* that is suspended and resumed
    before it returns:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Secondly, we create the *caller* of the coroutine. Pay attention to the output
    and the control flow of this program. Here it is:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Thirdly, the return object of the coroutine, `Resumable`, needs to be defined:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, the promise type is implemented as a nested class inside the `Resumable`,
    like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This example is minimal, but walks through a lot of things that are worth paying
    attention to and need to be understood:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The function `coroutine()` is a coroutine because it contains the explicit suspend/resume
    point using `co_await`
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The coroutine doesn't yield any values but still needs to return a type (the
    `Resumable`) with certain constraints so that the caller can resume the coroutine
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are using an *awaitable type* called `std::suspend_always`
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `resume()` function of the `resumable` object resumes the coroutine from
    the point it was suspended
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Resumable` is the owner of the coroutine state. When the `Resumable` object
    is destructed, it destroys the coroutine using the `coroutine_handle`
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The relationship between the caller, the coroutine, the coroutine handle, the
    promise, and the resumable is illustrated in the following diagram:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15619_12_11.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.11: Relationship between the functions/coroutines and objects involved
    in the resumable example'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to look a little closer at each part. We'll begin with the `Resumable`
    type.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The coroutine return object
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our coroutine returns an object of type `Resumable`. This `Resumable` class
    is very simple. This is the object that the coroutine returns and which the caller
    can use in order to resume and destroy the coroutine. Here is the complete definition
    again for your convenience:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`Resumable` is a move-only type that is the owner of the coroutine handle (and
    therefore controls the lifetime of the coroutine). The move constructor ensures
    that the coroutine handle is cleared in the source object by using `std::exchange()`.
    When a `Resumable` object is destructed, it destroys the coroutine if it still
    owns it.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: The `resume()` member function delegates the resume call to the coroutine handle
    if the coroutine is still alive.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need the member type alias `promise_type = Promise` inside `Resumable`?
    With each coroutine there is also an associated promise object. When the compiler
    sees a coroutine (by inspecting the body of a function), it needs to figure out
    the associated promise type. For that, the compiler uses the `std::coroutine_traits<T>`
    template, where `T` is the return type of your coroutine. You can provide a template
    specialization of `std::coroutine_traits<T>` or exploit the fact that the default
    implementation of `std::coroutine_traits` will look for a `public` member type
    or alias named `promise_type` in the return type `T` of the coroutine. In our
    case, the `Resumable::promise_type` is an alias for `Promise`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The promise type
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The promise type controls the behavior of the coroutine. Again, here is the
    full definition reproduced for convenience:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We should not call these functions directly; instead, the compiler inserts
    calls to the promise objects when it transforms a coroutine into machine code.
    If we don''t provide these member functions, the compiler doesn''t know how to
    generate code for us. You can think about the promise as a coroutine controller
    object that is responsible for:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应直接调用这些函数；相反，编译器在将协程转换为机器代码时会插入对promise对象的调用。如果我们不提供这些成员函数，编译器就不知道如何为我们生成代码。您可以将promise视为协程控制器对象，负责：
- en: Producing the value returned from the invocation of the coroutine. This is handled
    by the function `get_return_object()`.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产生从协程调用返回的值。这由函数`get_return_object()`处理。
- en: Defining the behavior when the coroutine is created and before it gets destroyed
    by implementing the functions `initial_suspend()` and `final_supsend()`. In our
    `Promise` type, we say that the coroutine should be suspended at these points
    by returning `std::suspend_always` (see the next section).
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实现函数`initial_suspend()`和`final_supsend()`定义协程创建时和销毁前的行为。在我们的`Promise`类型中，我们通过返回`std::suspend_always`（见下一节）来表示协程应在这些点挂起。
- en: Customizing the behavior when the coroutine finally returns. If a coroutine
    uses a `co_return` with an expression that evaluates to a value of type `T`, the
    promise must define a member function named `return_value(T)`. Our coroutine returns
    no value, but the C++ standard requires us to provide the customization point
    called `return_void()`, which we leave empty here.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义协程最终返回时的行为。如果协程使用带有类型`T`的值的表达式的`co_return`，则promise必须定义一个名为`return_value(T)`的成员函数。我们的协程不返回任何值，但C++标准要求我们提供称为`return_void()`的定制点，我们在这里留空。
- en: Handling exceptions that are not handled inside the coroutine body. In the function
    `unhandled_exception()`, we simply call `std::terminate()`, but we will handle
    it more gracefully in later examples.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理在协程体内未处理的异常。在函数`unhandled_exception()`中，我们只是调用`std::terminate()`，但在后面的示例中我们将更优雅地处理它。
- en: There are some final pieces of the code that require some more attention, namely
    the `co_await` expression and awaitable types.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些代码的最后部分需要更多的关注，即`co_await`表达式和可等待类型。
- en: Awaitable types
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可等待类型
- en: 'We added one explicit suspend point in our code using `co_await` and passed
    it an instance of the awaitable type, `std::suspend_always`. The implementation
    of `std::suspend_always` looks something like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中使用`co_await`添加了一个显式的挂起点，并传递了一个可等待类型`std::suspend_always`的实例。`std::suspend_always`的实现大致如下：
- en: '[PRE16]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`std::suspend_always` is called a trivial awaitable type because it will always
    make a coroutine suspend by saying that it is never ready. There is another trivial
    awaitable type that always reports that it is ready, called `std::suspend_never`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::suspend_always`被称为微不足道的可等待类型，因为它总是使协程挂起，说它永远不会准备好。还有另一种微不足道的可等待类型，总是报告自己准备好的，称为`std::suspend_never`：'
- en: '[PRE17]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We could create our own awaitable types, which we will cover in the next chapter,
    but for now we can manage with those two trivial standard types.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建自己的可等待类型，这将在下一章中介绍，但现在我们可以使用这两种微不足道的标准类型。
- en: This completes the example. But we can do some more experimenting when we have
    the `Promise` and the `Resumable` types in place. Let's see what we can do with
    a started coroutine.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了示例。但是当我们有了`Promise`和`Resumable`类型时，我们可以进行更多的实验。让我们看看在启动的协程中我们能做些什么。
- en: Passing our coroutine around
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递我们的协程
- en: 'Once the `Resumable` object is created, we can pass it to other function and
    resume it from there. We can even pass the coroutine to another thread. The following
    example shows some of this flexibility:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`Resumable`对象被创建，我们可以将它传递给其他函数，并从那里恢复它。我们甚至可以将协程传递给另一个线程。下面的示例展示了一些这种灵活性：
- en: '[PRE18]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding example demonstrates that once we have called our coroutine and
    have got a handle to it, we can move it around just like any other moveable type.
    This ability to pass it to other threads is actually very useful in situations
    where we need to avoid the possible heap allocation of the coroutine state on
    a specific thread.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例表明，一旦我们调用了我们的协程并获得了对它的句柄，我们就可以像任何其他可移动类型一样移动它。将它传递给其他线程的能力实际上在需要避免在特定线程上对协程状态进行可能的堆分配的情况下非常有用。
- en: Allocating the coroutine state
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配协程状态
- en: The coroutine state, or the coroutine frame, is where the coroutine stores its
    state while it is suspended. The lifetime of the coroutine state starts when the
    coroutine is invoked by a call, and is destroyed when the coroutine executes a
    `co_return` statement (or the control flows off the end of the coroutine body),
    unless it was destroyed earlier through the coroutine handle.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 协程状态，或协程帧，是协程在挂起时存储其状态的地方。协程状态的生命周期始于协程被调用时，并在协程执行`co_return`语句（或控制流离开协程体的末尾）时被销毁，除非它在此之前通过协程句柄被销毁。
- en: The coroutine state is normally allocated on the heap. A separate heap allocation
    is inserted by the compiler. In some cases, though, this separate heap allocation
    can be elided by inlining the coroutine state into the frame of the caller (which
    could be an ordinary stack frame or another coroutine frame). Unfortunately, there
    is never any guarantee of this elision of the heap allocation.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 协程状态通常在堆上分配。编译器会插入一个单独的堆分配。然而，在某些情况下，可以通过将协程状态内联到调用者的帧中（可以是普通的堆栈帧或另一个协程帧）来省略这个单独的堆分配。不幸的是，永远不能保证省略堆分配。
- en: For the compiler to be able to elide the heap allocation, the complete lifetime
    of the coroutine state must be strictly nested within the lifetime of the caller.
    In addition, the compiler needs to figure out the total size of the coroutine
    state and generally needs to have visibility of the body of the called coroutine
    so that parts of it can be inlined. Situations like virtual function calls, and
    calls to functions in other translation units or shared libraries, typically make
    this impossible. If the compiler is missing the information it needs, it will
    insert a heap allocation.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使编译器能够省略堆分配，协程状态的完整生存期必须严格嵌套在调用者的生存期内。此外，编译器需要找出协程状态的总大小，并且通常需要能够看到被调用协程的主体，以便其中的部分可以内联。像虚函数调用和调用其他翻译单元或共享库中的函数的情况通常会使这种情况变得不可能。如果编译器缺少所需的信息，它将插入堆分配。
- en: 'The heap allocation of the coroutine state is performed using `operator` `new`.
    It is possible to provide a custom class-level `operator new` on the promise type,
    which will then be used instead of global `operator new`. It''s therefore possible
    to check whether the heap allocation was elided or not. And if it wasn''t, we
    can find out how much memory is needed for the coroutine state. Here is an example
    using the `Promise` type we defined earlier:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 协程状态的堆分配是使用`operator new`执行的。可以在promise类型上提供自定义的类级`operator new`，然后将其用于全局`operator
    new`。因此，可以检查堆分配是否被省略。如果没有，我们可以找出协程状态需要多少内存。以下是使用我们之前定义的`Promise`类型的示例：
- en: '[PRE19]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Another trick to verify that the heap allocations are completely elided for
    all coroutines using some specific promise type would be to declare `operator
    new` and `operator delete` but leave out their definitions. If the compiler then
    inserts calls to these operators, the program will fail to link due to unresolved
    symbols.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个验证使用特定promise类型的所有协程完全省略了堆分配的技巧是声明`operator new`和`operator delete`，但不包括它们的定义。如果编译器插入了对这些操作符的调用，程序将由于未解析的符号而无法链接。
- en: Avoiding dangling references
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免悬空引用
- en: The fact that a coroutine can be passed around in our code means that we need
    to be very careful about the lifetime of parameters we pass to a coroutine to
    avoid dangling references. The coroutine frame contains copies of the objects
    that normally live on the stack, such as local variables and parameters passed
    to the coroutine. If a coroutine accepts an argument by reference, the *reference*
    is copied, not the object. This means that we can easily end up with dangling
    references when following the usual guidelines for function parameters; that is,
    pass objects that are expensive to copy by reference to `const`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 协程可以在我们的代码中传递，这意味着我们需要非常小心地处理传递给协程的参数的生存期，以避免悬空引用。协程帧包含通常存储在堆栈上的对象的副本，例如局部变量和传递给协程的参数。如果协程通过引用接受参数，则*引用*被复制，而不是对象。这意味着当遵循函数参数的通常指导方针时，即通过引用传递`const`对象，我们很容易遇到悬空引用。
- en: Passing parameters to coroutines
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向协程传递参数
- en: 'The following coroutine uses a reference to a `const std::string`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下协程使用了对`const std::string`的引用：
- en: '[PRE20]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Suppose we have a factory function that creates and returns the coroutine,
    like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个创建并返回协程的工厂函数，就像这样：
- en: '[PRE21]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And finally, a `main()` function that uses the coroutine:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个使用协程的`main()`函数：
- en: '[PRE22]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This code exhibits undefined behavior as the `std::string` object containing
    the string `"ABC"` is no longer alive when the coroutine tries to access it. Hopefully,
    this doesn''t come as a surprise to you. This problem is similar to having a lambda
    capture a variable by reference, and then passing the lambda to some other code
    without keeping the referenced object alive. A similar example can be achieved
    when passing around a lambda capturing variables by reference:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码表现出未定义的行为，因为包含字符串“ABC”的`std::string`对象在协程尝试访问它时已经不再存在。希望这对你来说不是什么意外。这个问题类似于让lambda通过引用捕获变量，然后将lambda传递给其他代码而不保持引用对象的生存。当传递捕获变量的lambda时也可以实现类似的例子：
- en: '[PRE23]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, the same problem can happen with lambdas. In *Chapter 2*, *Essential
    C++ Techniques*, I warned you about capturing references with lambdas, and it
    is usually better to avoid this by capturing by value instead.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用lambda也可能出现相同的问题。在*第2章*，*基本的C++技术*中，我警告过你使用lambda捕获引用的问题，通常最好通过值捕获来避免这个问题。
- en: 'The solution to avoid dangling references with coroutines is similar: avoid
    passing parameters by reference when using coroutines. Instead, use pass by value,
    and the entire parameter object will be placed safely in the coroutine frame:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 避免悬空引用的解决方案与协程类似：在使用协程时避免通过引用传递参数。而是使用按值传递，整个参数对象将安全地放置在协程帧中：
- en: '[PRE24]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Parameters are an important and common source of lifetime issues when using
    coroutines, but they are not the only source. Now we will explore some other pitfalls
    related to coroutines and dangling references.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是使用协程时生存期问题的一个重要且常见的来源，但并不是唯一的来源。现在我们将探讨一些与协程和悬空引用相关的其他陷阱。
- en: Member functions that are coroutines
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为协程的成员函数
- en: 'A member function can also be a coroutine. For example, there is nothing that
    stops us from using `co_await` inside a member function, as in the following example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 成员函数也可以是协程。例如，我们可以在成员函数中使用`co_await`，就像下面的例子一样：
- en: '[PRE25]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It's important to understand that it's the responsibility of the caller of `coroutine()`
    (in this case, `main()`) to ensure that the `Widget` object, `w`, is kept alive
    during the entire lifetime of the coroutine. The coroutine is accessing data members
    from the object it belongs to, but the `Widget` object itself is *not* kept alive
    by the coroutine. This can easily become a problem if we pass the coroutine to
    some other part of the program.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，调用者`coroutine()`（在这种情况下是`main()`）有责任确保`Widget`对象`w`在整个协程的生命周期内保持存活。协程正在访问所属对象的数据成员，但`Widget`对象本身*不*由协程保持存活。如果我们将协程传递给程序的其他部分，这很容易成为一个问题。
- en: 'Let''s say we are using some coroutine factory function as demonstrated earlier,
    but instead return a member function coroutine:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在使用一些协程工厂函数，就像之前演示的那样，但是返回一个成员函数协程：
- en: '[PRE26]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code exhibits undefined behavior because we now have a dangling reference
    from the coroutine to the `Widget` object created and destructed in the `widget_coro_factory()`
    function. In other words, we end up with two objects with distinct lifetimes,
    whereas one of the objects references the other but without any explicit ownership.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码表现出未定义的行为，因为我们现在有一个从协程到在`widget_coro_factory()`函数中创建和销毁的`Widget`对象的悬空引用。换句话说，我们最终得到了两个具有不同生命周期的对象，其中一个对象引用另一个对象，但没有明确的所有权。
- en: Lambdas that are coroutines
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为协程的lambda
- en: Not only member functions can become coroutines. It's also possible to create
    coroutines using lambda expressions by inserting `co_await`, `co_return`, and/or
    `co_yield` in the body of a lambda.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅成员函数可以成为协程。还可以通过在lambda的主体中插入`co_await`、`co_return`和/或`co_yield`来使用lambda表达式创建协程。
- en: Coroutine lambdas can be a little extra tricky to deal with. One way to understand
    the most common lifetime issue with coroutine lambdas is to think about function
    objects. Recall from *Chapter 2*, *Essential C++ Techniques*, that a lambda expression
    is transformed into a function object by the compiler. The type of this object
    is a class with the call operator implemented. Now, let's say we use `co_return`
    inside the body of a lambda; it means that the call operator `operator()()` becomes
    a coroutine.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 协程lambda可能会有一些额外的棘手问题。更好地理解协程lambda最常见的生命周期问题的一种方法是考虑函数对象。回想一下*第2章*，*Essential
    C++ Techniques*，lambda表达式被编译器转换为函数对象。这个对象的类型是一个实现了调用运算符的类。现在，假设我们在lambda的主体中使用`co_return`；这意味着调用运算符`operator()()`变成了一个协程。
- en: 'Consider the following code using a lambda:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下使用lambda的代码：
- en: '[PRE27]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The type that the lambda corresponds to looks something like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: lambda对应的类型看起来像这样：
- en: '[PRE28]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The important thing to note here is that the actual coroutine is a *member
    function*, namely the call operator `operator()()`. The previous section already
    demonstrated the pitfalls of having coroutine member functions: we need to keep
    the object alive during the lifetime of the coroutine. In the preceding example,
    it means we need to keep the function object named `lambda` alive as long as the
    coroutine frame is alive.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的重要事情是，实际的协程是一个*成员函数*，即调用运算符`operator()()`。前面的部分已经展示了拥有协程成员函数的陷阱：我们需要在协程的生命周期内保持对象的存活。在前面的例子中，这意味着我们需要在协程帧存活期间保持名为`lambda`的函数对象存活。
- en: 'Some usages of lambdas make it really easy to accidentally destruct the function
    object before the coroutine frame is destroyed. For example, by using an *immediately
    invoked lambda*, we can easily get into trouble:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一些lambda的用法很容易在协程帧被销毁之前意外销毁函数对象。例如，通过使用*立即调用lambda*，我们很容易陷入麻烦：
- en: '[PRE29]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This code looks innocent; the lambda is not capturing anything by reference.
    However, the function object created by the lambda expression is a temporary object
    that will be destructed once it has been invoked and the coroutine captures a
    reference to it. When the coroutine is resumed, the program will likely crash
    or produce garbage.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来无害；lambda没有通过引用捕获任何东西。然而，lambda表达式创建的函数对象是一个临时对象，一旦被调用并且协程捕获了对它的引用，它将被销毁。当协程恢复时，程序很可能会崩溃或产生垃圾。
- en: 'Again, a way to understand this better is to transform the lambda to an ordinary
    class with `operator()` defined:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，更好地理解这一点的方法是将lambda转换为具有定义的`operator()`的普通类：
- en: '[PRE30]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now you can see that this is very similar to the case where we had a member
    function that was a coroutine. The function object is not kept alive by the coroutine
    frame.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到，这与我们有一个成员函数是协程的情况非常相似。函数对象不会被协程帧保持存活。
- en: Guidelines to prevent dangling references
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防止悬空引用的指导方针
- en: Unless you have good reasons for accepting arguments by reference, choose to
    accept arguments by value if you are writing a coroutine. The coroutine frame
    will then keep a full copy of the object you pass to it, and the object is guaranteed
    to live as long as the coroutine frame.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你有接受引用参数的充分理由，如果你正在编写一个协程，选择通过值接受参数。协程帧将保持你传递给它的对象的完整副本，并且保证对象在协程帧存活期间存活。
- en: If you are using lambdas or member functions that are coroutines, pay special
    attention to the lifetime of the object that the coroutine belongs to. Remember
    that the object (or function object) is *not* stored in the coroutine frame. It's
    the responsibility of the caller of the coroutine to keep it alive.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用lambda或成员函数作为协程，特别注意协程所属对象的生命周期。记住对象（或函数对象）*不*存储在协程帧中。调用协程的责任是保持其存活。
- en: Handling errors
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理错误
- en: There are different ways to transfer errors from a coroutine back to the part
    of the code that called it or resumed it. We are not forced to use exceptions
    for signaling errors. Instead, we can customize error handling as we want.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法将错误从协程传递回调用它或恢复它的代码部分。我们不必使用异常来标志错误。相反，我们可以根据需要自定义错误处理。
- en: A coroutine can pass an error back to the client using the coroutine by either
    throwing an exception or returning an error code when the client gets a value
    back from the coroutine (when the coroutine yields or returns).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: If we are using exceptions and an exception is propagated out of the body of
    the coroutine, the function `unhandled_exception()` of the promise object is called.
    This call happens inside a catch block inserted by the compiler, so that it is
    possible to use `std::current_exception()` to get hold of the exception that was
    thrown. The result from `std::current_exception()` can then be stored in the coroutine
    as a `std::exception_ptr` and rethrown later on. You will see examples of this
    in the next chapter when using asynchronous coroutines.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Customization points
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have already seen many customization points, and I think a valid question
    is: why so many customization points?'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '**Generality**: The customization points make it possible to use coroutines
    in various ways. There are very few assumptions about how to use the C++ coroutines.
    Library writers can customize the behavior of `co_await`, `co_yield`, and `co_return`.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency**: Some of the customization points are there for enabling possible
    optimizations depending on use cases. One example is `await_ready()`, which can
    return `true` to avoid an unnecessary suspension if a value is already computed.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should also be said that we are exposed to these customization points because
    the C++ standard doesn't provide any types (except for the `std::coroutine_handle`)
    to communicate with a coroutine. Once they are in place, we can reuse those types
    and not worry too much about some of those customization points. Nevertheless,
    knowing the customization points is valuable in order to fully understand how
    to use C++ coroutines efficiently.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Generators
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A generator is a type of coroutine that yields values back to its caller. For
    example, at the beginning of this chapter, I demonstrated how the generator `iota()`
    yielded increasing integer values. By implementing a general-purpose generator
    type that can act as an iterator, we can simplify the work of implementing iterators
    that are compatible with range-based `for`-loops, standard library algorithms,
    and ranges. Once we have a generator template class in place, we can reuse it.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: So far in this book, you have mostly seen iterators in the context of accessing
    container elements and when using standard library algorithms. However, an iterator
    does not have to be tied to a container. It's possible to write iterators that
    produce values.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a generator
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The generator we are about to implement is based on the generator from the
    CppCoro library. The generator template is intended to be used as a return type
    for coroutines that produces a sequence of values. It should be possible to use
    objects of this type together with a range-based `for` - loop and standard algorithms
    that accept iterators and ranges. To make this possible, we will implement three
    components:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: The `Generator`, which is the return object
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Promise`, which acts as the coroutine controller
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Iterator`, which is the interface between the client and the `Promise`
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These three types are tightly coupled and the relationships between them and
    the coroutine state are presented in the following diagram:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15619_12_12.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.12: The relationships between the Iterator, Generator, Promise, and
    the coroutine state'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'The return object, in this case the `Generator` class, is tightly coupled with
    the `Promise` type; the `Promise` type is responsible for creating the `Generator`
    object, and the `Generator` type is responsible for exposing the correct `promise_type`
    to the compiler. Here is the implementation of `Generator`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The implementation of `Promise` and `Iterator` will follow soon. The `Generator`
    is not that different from the `Resumable` class we defined earlier. The `Generator`
    is the return object of the coroutine and the owner of the `std::coroutine_handle`.
    The generator is a moveable type. When being moved, the coroutine handle is transferred
    to the newly constructed `Generator` object. When a generator that owns a coroutine
    handle is destructed, it destroys the coroutine state by calling `destroy` on
    the coroutine handle.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'The `begin()` and `end()` functions make it possible to use this generator
    in range-based `for`-loops and algorithms that accept ranges. The `Sentinel` type
    is empty—it''s a dummy type—and the `Sentinel` instance is there to be able to
    pass something to the comparison operators of the `Iterator` class. The implementation
    of the `Iterator` looks like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The iterator needs to store the coroutine handle in a data member so that it
    can delegate the calls to the coroutine handle and the promise object:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: When the iterator is dereferenced, it returns the current value held by the
    promise
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the iterator is incremented, it resumes the coroutine
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the iterator is compared with the sentinel value, the iterator ignores
    the sentinel and delegates the call to the coroutine handle, which knows whether
    there are more elements to be generated
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now there is only the `Promise` type left for us to implement. The complete
    definition of `Promise` looks like this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The promise object for our generator is responsible for:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Creating the `Generator` object
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the behavior when the initial and final suspend points are reached
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping track of the last value that was yielded from the coroutine
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling exceptions thrown by the coroutine body
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That''s it! We now have all the pieces in place. A coroutine that returns some
    `Generator<T>` type can now yield values lazily using `co_yield`. The caller of
    the coroutine interacts with the `Generator` and `Iterator` objects to retrieve
    values. The interaction between the objects is illustrated next:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15619_12_13.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.13: The caller communicates with the Generator and Iterator objects
    to retrieve values from the coroutine'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how we can use the new `Generator` template and how it can simplify
    the implementation of various iterators.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Using the Generator class
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example is inspired from the talk *C++ Coroutines: Under the covers*,
    by Gor Nishanov at CppCon 2016 ([https://sched.co/7nKt](https://sched.co/7nKt)).
    It clearly demonstrates how we can benefit from the generator types we just implemented.
    Small composable generators can now be implemented like this:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A small usage example demonstrates that we can pass our generators to range-based
    `for`-loops:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The generators are lazily evaluated. No values are produced until the program
    reaches the `for`-loop, which pulls the values out from the chain of generators.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting aspect of this program is that when I compile it using
    Clang 10 with optimizations turned on, the assembly code for the *entire* program
    looks like this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Amazing! The program simply defines a main function that returns the value `75`.
    In other words, the compiler optimizer has been able to completely evaluate the
    chain of generators at compile time and come up with the single value `75`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Generator` class can also be used with range algorithms. In the following
    example we use the algorithm `includes()` to see if the sequence `{5,6,7}` is
    a subrange of the numbers produced by the generator:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With the `Generator` template implemented, we can reuse it for all sorts of
    generator functions. We have implemented a general and highly useful library component
    that application code can benefit from in a great many places when building lazy
    generators.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Solving generator problems
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I will now present a small problem and we will try to solve it using different
    techniques for the purpose of understanding which programming idioms we can potentially
    replace with generators. We are about to write a small utility for generating
    linearly spaced sequences between a start value and a stop value.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: If you have been using MATLAB/Octave or Python NumPy, you might recognize this
    way of generating evenly (linearly) spaced numbers using a function called `linspace()`.
    It's a handy utility that can be used in various contexts with arbitrary ranges.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'We will call our generator `lin_space()`. Here is a usage example of generating
    five equally spaced values between `2.0` and `3.0`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When generating floating-point values, we have to be a little bit cautious because
    we cannot simply compute the size of each step (0.25 in the preceding example)
    and accumulate it, since the step size might not be possible to represent exactly
    using a floating-point data type. The possible rounding error will add up at each
    iteration and eventually we may end up with completely nonsensical values. What
    we instead need to do is to calculate a number between the start and stop value
    at a specific increment using linear interpolation.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'C++20 added a handy utility to `<cmath>` called `std::lerp()`, which computes
    the linear interpolation between two values with a specified amount. In our case,
    the amount will be a value between 0.0 and 1.0; an amount of 0 returns the `start`
    value and a value of 1.0 returns the `stop` value. Here are a few examples of
    using `std::lerp()`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `lin_space()` functions we are about to write will all use the following
    small utility function template:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The function returns a value in the linear sequence in the range [`start`, `stop`].
    The `index` parameter is the current number in the sequence of the `n` total numbers
    we are about to generate.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `lin_value()` helper in place, we can now easily implement the `lin_space()`
    generator. Before seeing a solution using a coroutine, we will examine other common
    techniques. The sections to follow will explore the following different approaches
    when implementing `lin_space()`:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Eagerly generate and return all values
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a callback (lazy)
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a custom iterator (lazy)
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Ranges library (lazy)
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using coroutines with our `Generator` class (lazy)
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each example, there will be a short reflection of the strengths and weaknesses
    of each approach.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: An eager linear range
  id: totrans-346
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We''ll begin by implementing a simple eager version that computes all the values
    in the range and returns a vector with all values:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Since this version returns a standard container, it''s possible to use the
    return value with range-based `for`-loops and other standard algorithms:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This version is straightforward, and fairly easy to read. The downside is that
    we need to allocate a vector and fill it with *all* values, although the caller
    is not necessarily interested in all values. This version also lacks composability
    as there is no way to filter out elements in the middle without first generating
    all values.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Now let's try to implement a lazy version of the `lin_space()` generator.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: A lazy version using a callback
  id: totrans-353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In *Chapter 10,* *Proxy Objects and Lazy Evaluation*, we concluded that lazy
    evaluation can be accomplished by using callback functions. The lazy version we
    will implement will be based on passing a callback to `lin_space()` and invoking
    the callback function when emitting values:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If we want to print the values produced by the generator, we can call this
    function like this:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The iteration now take places within the `lin_space()` function. There is no
    way to cancel the generator, but with some changes we could have the callback
    function return a `bool` to indicate whether it wants more elements to be generated.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: This approach works but is not very elegant. The problem with this design becomes
    more apparent when trying to compose generators. If we wanted to add a filter
    that would select some special values, we would end up having nested callback
    functions.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: We will now move on to see how we can implement an iterator-based solution to
    our problem.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: An iterator implementation
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another alternative is to implement a type that conforms to the range concept
    by exposing the `begin()` and `end()` iterators. The class template `LinSpace`,
    defined here, makes it possible to iterate over the linear range of values:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This implementation is very efficient. However, it is afflicted with a lot
    of boilerplate code and the small algorithm we are trying to encapsulate is now
    spread out into different parts: the `LinSpace` constructor implements the initial
    work of setting up the start and stop values, whereas the work needed for computing
    the values ends up in the member functions of the `Iterator` class. This makes
    the implementation of the algorithm harder to understand compared with the other
    versions we have looked at.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: A solution using the Ranges library
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Yet another alternative is to compose our algorithm using building blocks from
    the Ranges library (C++20), as shown here:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here we have the entire algorithm encapsulated inside a small function. We are
    using `std::views::iota` to generate the indexes for us. Converting an index to
    a linear value is a simple transformation that can be chained after the `iota`
    view.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: This version is efficient and composable. The object returned from `lin_space()`
    is a random-access range of type `std::ranges::view`, which can be iterated over
    using range-based `for`-loops or passed to other algorithms.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it's time to use our `Generator` class to implement our algorithm as
    a coroutine.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: A solution using a coroutine
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After looking at no less than four versions of this very same problem, we have
    now reached the last solution. Here I will present a version that uses the general
    `Generator` class template implemented earlier:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It's compact, straightforward, and easy to understand. By using `co_yield`,
    we can write the code in such a way that it looks similar to the simple eager
    version, but without the need for collecting all the values in a container. It's
    possible to chain multiple generators based on coroutines, as you will see at
    the end of this chapter.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: This version is also compatible with range-based `for`-loops and standard algorithms.
    However, this version exposes an input range, so it's not possible to skip ahead
    arbitrary number of elements, which is possible with the version using the Ranges
    library.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Obviously, there is more than one way to do it. But why did I show all these
    approaches?
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, if you are new to coroutines, you will hopefully start to see the patterns
    where it can be advantageous to use coroutines.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, the `Generator` template and the use of `co_yield` allows us to implement
    lazy generators in a very clear and concise way. This becomes obvious when we
    compare the solution with other versions.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, some approaches might look very contrived for this example problem but
    are frequently being used in other contexts. C++ is by default an eager language,
    and many (myself included) have become accustomed to creating code similar to
    the eager version. The version using a callback might look very strange but is
    a commonly used pattern in asynchronous code, where coroutines can wrap or replace
    those callback-based APIs.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: The generator type we implemented is partly based on the synchronous generator
    template from the CppCoro library. CppCoro also provides an `async_generator`
    template, which makes it possible to use the `co_await` operator within the generator
    coroutine. I provided the `Generator` template in this chapter for the purpose
    of demonstrating how a generator can be implemented and how we can interact with
    coroutines. But if you plan to start using generators in your code, consider using
    a third-party library.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: A real-world example using generators
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using coroutines for simplifying iterators really shines when the examples are
    a little bit more advanced. Using `co_yield` with the `Generator` class allows
    us to implement and combine small algorithms efficiently and without the need
    for boilerplate code to glue it all together. This next example will try to prove
    that.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: The problem
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will here go through an example of how we can use our `Generator` class to
    implement a compression algorithm that can be used in search engines to compress
    the search index typically stored on disk. The example is thoroughly described
    in the book *Introduction to Information Retrieval* by Manning et al, which is
    freely available at [https://nlp.stanford.edu/IR-book/](https://nlp.stanford.edu/IR-book/).
    Here follows a brief background and a short description of the problem.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Search engines use some variant of a data structure called an **inverted index**.
    It is like an index at the end of a book. Using the index, we can find all pages
    that contain the terms we are searching for.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'Now imagine that we have a database full of recipes and that we build an inverted
    index for this database. Parts of this index might look something like this:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15619_12_14.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.14: An inverted index with three terms and their corresponding lists
    of document references'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'Each term is associated with a sorted list of document identifiers. (For example,
    the term **apple** is included in the recipes with IDs **4**, **9**, **67**, and
    **89**.) If we want to find recipes that contain both **beans** *and* **chili**,
    we can run a merge-like algorithm to find the intersection of the lists for **beans**
    and **chili**:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15619_12_15.png)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
- en: Figure 12.15 Intersection of the document lists for the terms "beans" and "chili"
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine that we have a big database and we choose to represent the document
    identifier with a 32-bit integer. The lists of document identifiers can become
    very long for terms that appear in many documents and therefore we need to compress
    those lists. One possible way to do that is to use delta encoding combined with
    a variable byte encoding scheme.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Delta encoding
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since the lists are sorted, we could, instead of saving the document identifiers,
    store the **gap** between two adjacent elements. This technique is called **delta
    encoding** or **gap encoding**. The following diagram shows an example using document
    IDs and gaps:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15619_12_16.png)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.16: Gap encoding stores the gap between two adjacent elements in
    a list'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Gap encoding is well-suited for this type of data; frequently used terms will
    consequently have many small gaps. The really long lists will only contain very
    small gaps. After the lists have been gap encoded, we can use a variable byte
    encoding scheme to actually compress the lists by using fewer bytes for smaller
    gaps.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, let''s start implementing the gap encoding functionality. We will
    begin by writing two small coroutines that will do the gap encoding/decoding.
    The encoder transforms a sorted sequence of integers to a sequence of gaps:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: By using `co_yield`, there is no need to eagerly pass a complete list of numbers
    and allocate a big output list of gaps. Instead, the coroutine lazily handles
    one number at a time. Note how the function `gap_encode()` contains everything
    that there is to know about how to convert document IDs to gaps. Implementing
    this as a traditional iterator would be possible, but this would have logic spread
    out in constructors and operators on iterators.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'We can build a small program to test our gap encoder:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The decoder does the opposite; it takes as input a range of gaps and transforms
    it to the list of ordered numbers:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'By using gap encoding, we will on average, store much smaller numbers. But
    since we are still using `int` values for storing the small gaps, we haven''t
    really gained anything if we save these gaps to disk. Unfortunately, we cannot
    just use a smaller fixed-size data type, because there is still a possibility
    that we will encounter a really big gap that would require a full 32-bit `int`.
    What we want is a way to store small gaps using fewer bits, as illustrated in
    the following diagram:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15619_12_17.png)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.17: Small numbers should use fewer bytes'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: In order to make this list physically smaller, we can use **variable byte encoding**
    so that small gaps are encoded with fewer bytes than bigger gaps, as illustrated
    in the preceding diagram.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Variable byte encoding
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Variable byte encoding is a very common compression technique. UTF-8 and MIDI
    message are some of the well-known encodings that uses this technique. In order
    to use a variable number of bytes when encoding, we use 7-bits of each byte for
    the actual payload. The first bit of each byte represents a **continuation bit**.
    It is set to `0` if there are more bytes to read, or `1` for the last byte of
    the encoded number. The encoding scheme is exemplified in the following diagram:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15619_12_18.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.18: Using variable byte encoding, only one byte is required to store
    the decimal value 3 and two bytes for encoding the decimal value 1025'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to implement the variable byte encoding and decoding scheme.
    This is a little bit more complicated than delta encoding. The encoder should
    transform a number into a sequence of one or multiple bytes:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The continuation bit, named `cont` in the code, is either 0 or 128, which corresponds
    to the bit sequence 10000000\. The details in this example are not that important
    to understand, but to make the encoding easier, the bytes are generated in reverse
    order so that the least significant byte comes first. This is not a problem since
    we can handle that easily during the decoding.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'With the number encoder in place, it''s easy to encode a sequence of numbers
    and transform them into a sequence of bytes:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The decoder is probably the most complicated part. But again, it is fully encapsulated
    into one single function with a clean interface:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you can see, there is very little boilerplate code needed in this code. Each
    coroutine encapsulates all states and describes clearly how to process one piece
    at a time.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: 'The last piece we need is to combine the gap encoder with the variable byte
    encoder in order to compress our sorted list of document identifiers:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Decompress is a simple chaining of `vb_decode()` followed by `gap_decode()`:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Since the `Generator` class exposes iterators, we can take this example even
    further and easily stream the values to and from disk using iostreams. (Although,
    a more realistic approach would be to use memory-mapped I/O for better performance.)
    Here are two small functions that writes and reads the compressed data to and
    from disk:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'A small test program will wrap this example up:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This example aims to show that we can divide lazy programs into small encapsulated
    coroutines. The low overhead of C++ coroutines makes them suitable for building
    efficient generators. The `Generator` we implemented initially is a fully reusable
    class that helps us with minimizing the amount of boilerplate code in examples
    like this.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: This ends the section about generators. We will now move on to discuss some
    general performance considerations when using coroutines.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each time a coroutine is created (when it is first called) a coroutine frame
    is allocated to hold the coroutine state. The frame can be allocated on the heap,
    or on the stack in some circumstances. However, there are no guarantees to completely
    avoid the heap allocation. If you are in a situation where heap allocations are
    forbidden (for example, in a real-time context) the coroutine can be created and
    immediately suspended in a different thread, and then passed to the part of the
    program that needs to actually use the coroutine. Suspend and resume are guaranteed
    to not allocate any memory and have a cost comparable with an ordinary function
    call.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, compilers have experimental support for coroutines.
    Small experiments have shown promising results related to performance, showing
    that coroutines are friendly to the optimizer. However, I will not provide you
    with any benchmarks of coroutines in this book. Instead, I have shown you how
    stackless coroutines are evaluated and how it's possible for coroutines to be
    implemented with minimal overheads.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: The generator example demonstrated that coroutines can potentially be very friendly
    to the compiler. The chain of generators we wrote in that example was completely
    evaluated at runtime. In practice, this is a very good property of C++ coroutines.
    They allow us to write code that is easy for both compilers and human beings to
    understand. C++ coroutines usually produce clean code that is easy to optimize.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines that execute on the same thread can share state without using any
    locking primitives and can therefore avoid the performance overhead incurred by
    synchronizing multiple threads. This will be demonstrated in the next chapter.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have seen how to use C++ coroutines for building generators
    using the keywords `co_yield` and `co_return`. To better understand how C++ stackless
    coroutines differ from stackful coroutines, we compared the two and also looked
    at the customization points that C++ coroutines offer. This gave you a deep understanding
    of how flexible C++ coroutines are, as well as how they can be used to achieve
    efficiency. Stackless coroutines are closely related to state machines. By rewriting
    a traditionally implemented state machine into code that uses coroutines, we explored
    this relationship and you saw how well compilers can transform and optimize our
    coroutines to machine language.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue to discuss coroutines by focusing on asynchronous
    programming and will deepen your understanding of the `co_await` keyword.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
