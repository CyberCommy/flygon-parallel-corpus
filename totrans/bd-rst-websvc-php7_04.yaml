- en: Reviewing Design Flaws and Security Threats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will review our work, the endpoints we implemented, and
    will look into two different aspects in which our current work can be improved
    and should be improved. We will also look at:'
  prefs: []
  type: TYPE_NORMAL
- en: Our code structure and design flaws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security threats and how we can mitigate them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we will look at ways to move forward to implement a RESTful API with the
    improvements discussed in the preceding two sections.
  prefs: []
  type: TYPE_NORMAL
- en: Finding problems in the current code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Till now, we have written our blog post's endpoint-related code, and I left
    you to do the same with the comment-related endpoints. If you haven't done that,
    then I insist that you do that first, or at least try to do so because without
    practice, it doesn't last for much time, so keep practicing at least when some
    code examples are provided or there are some tasks to do.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, as we have written code to implement RESTful web service endpoints in
    the last chapter, we are going to dig into that and identify what is missing and
    what types of improvements are required.
  prefs: []
  type: TYPE_NORMAL
- en: Structural and design flaws
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now in our code, there are some flaws that we can identify very clearly.
  prefs: []
  type: TYPE_NORMAL
- en: Missing query builder layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we are using PDO, we still always need to write a query and need to
    carry out many low level things such as being aware of SQL injection (due to which
    we have to use the prepare statement, then bind values), to perform database-related
    operations. We should use some sort of query builder layer, which can make queries
    for us. So once we have that layer, we don't need to write SQL queries again and
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Although PDO makes it easy to swap one database connection with another, still
    there are some SQL queries which will need to be changed for different databases.
    In fact, it is not only good for changing the DBMS but also, having a sort of
    query builder is time saving because using query builder, we are not always dealing
    with strings to build queries as with query builder we can also use arrays or
    associative arrays to build queries.
  prefs: []
  type: TYPE_NORMAL
- en: Incomplete router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The router we implemented is just routing different files, such as `/posts`
    which was being served through `posts.php`. Our router did not specify which function
    of `posts.php` will serve that request. We were specifying this from inside `posts.php`,
    based on the URL pattern. Just to remind you, here is that conditional portion
    of `posts.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Doing that isn''t difficult. We can simply put such conditions in `router.php`
    and call an appropriate function in `posts.php`. However, if you remember our
    `routes.php` file, it was a very simple file having key value pairs. Putting that
    here again for your ease:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are not specifying the Request method anywhere in `routes.php`,
    so we will need to specify that in `routes.php` as well. Other than that, we will
    also need to use a regular expression in `routes.php` instead of a plain URL.
    Doing this is easy in `routes.php`, but the actual place where we will need to
    add implementation will be `core/router.php`. It can be done, but we will not
    do that. We don't make components such as routers from scratch, because it is
    not something that is being done for the first time in the world. So how do we
    do it? We can use a router from open source components or packages which are already
    available. Later on, we will see how we can reuse already present open source
    packages or components.
  prefs: []
  type: TYPE_NORMAL
- en: Usage of OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should use an object-oriented paradigm as it is not only good to make code
    better and cleaner, but it also makes development faster with the passage of time
    because clean code reduces the friction in our way to code for more features or
    to modify code.
  prefs: []
  type: TYPE_NORMAL
- en: Separate Configurations from Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configurations should be better. It is good that we have a `config` file which
    has database connection information, but there are many other things which should
    be in configurations, for example, whether to show errors or not should be controlled
    through the `config` file.
  prefs: []
  type: TYPE_NORMAL
- en: So the rule of thumb is that we should separate configurations from implementations.
    This is important so that we can always change configurations without being worried
    about the implementation of code responsible for logic and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Should write tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No matter if you are writing a RESTful web service or making a website, writing
    test cases is always important. For that purpose, code must also be testable.
    So tests (unit tests) not only test the code against requirements, but also check
    if the code is flexible enough and loosely coupled. Tightly coupled code can not
    be that much testable as compared to loosely coupled code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing test cases in code also makes code cleaner and more agile, which can
    be modified easily. In the case of a web service, API tests are also convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Input validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated in the last chapter, we didn't validate data coming from input sources
    although we avoided SQL injection as we were using the PDO `prepare()` and `bindValue()`
    methods. It was because we only wrote code in the last chapter to understand and
    learn. Otherwise, not having input validation is not only inconvenient but also
    insecure for applications.
  prefs: []
  type: TYPE_NORMAL
- en: To apply validation, we can either use manual checks or write a validator where
    we can simply pass input parameters and check against particular rules. This type
    of validator is very convenient, but writing a good validator also takes time,
    so it is better to use an already present open source validator. As you can see,
    we tried to write a router and then found issues. These issues could be fixed,
    but we would need to write more code and writing more code takes time.
  prefs: []
  type: TYPE_NORMAL
- en: In later chapters, we will see how we can use someone else's written validator,
    and we will use that to make RESTful web service endpoints. We are not only trying
    to save or time to write code but we are trying to avoid to have more code, whose
    maintenance will become our responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Handling 404 and other errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, we haven't handled 404 if there is a wrong URL or ID for a blog post
    or comment so we will need to deal with that, not only by sending the not found
    error, but also by sending the HTTP status code as 404\. So for different responses,
    we will need to send different HTTP status codes.
  prefs: []
  type: TYPE_NORMAL
- en: Meta information missing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, there is no record count, no pagination is there. All records are
    being shown there. So if there will be lot of records, let's say a few million
    records, then returning all records will not make sense. In that case, we should
    apply pagination and there should be a proper place in response where meta information
    should be shown.
  prefs: []
  type: TYPE_NORMAL
- en: DB fields abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, all data coming from the database is being shown to the user as it
    is. What if field names will change and the client side developer is using that
    DB field? It will start giving an error at the client side as well.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember, one of the important constraints of REST is abstraction between
    what the server returns to the client and how a server actually stores data. So,
    we need to keep this abstraction. In upcoming chapters, we will see how we can
    keep that abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, we haven't applied any type of security at all. In fact, we
    haven't made all endpoints login protected. But, it isn't possible in the real
    world to not have a login or authentication. So, we will need to make some endpoints
    login protected.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are only going to see how we can implement security for
    our endpoints, but we will not implement that yet and will implement it in later
    chapters. Right now we are looking at how we will make some resources login protected,
    because based on that, we will be able to identify other security risks as well.
    So in the next section of this chapter, we are going to see how authentication
    will work.
  prefs: []
  type: TYPE_NORMAL
- en: Securing API endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we need to understand how authentication and login works. The first time
    client side application sends login credentials (that is mostly email address
    and password). On the basis of those credentials, the server-side login endpoint
    makes the user's login and returns a token against that authenticated user. That
    token is stored on the client side. On every request, the client side has that
    token either in a request body or in a request header. It can be more clearly
    seen in the following diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first client will hit the login endpoint on the server with the login credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4c7cf776-46b5-4f69-9ee1-e0d5b2b5d8c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the client gets the token, the client will store it for later use. Then
    with every request, the client will send the same token so that the server can
    consider the client as authenticated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6e2fc7a8-9cce-4453-b4f5-a143317c9d10.png)'
  prefs: []
  type: TYPE_IMG
- en: When a server will find the client authenticated, it will return data based
    on the authenticated user.
  prefs: []
  type: TYPE_NORMAL
- en: If there is no token sent with a request where only authenticated user is allowed
    then server should return 401 HTTP status code that is unauthenticated or unauthorized.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider **POST** endpoints. There are endpoints such as create
    post, modify post, and delete post; these need to be protected, so there should
    be an **Auth middleware** protecting these endpoints, while other endpoints such
    as show post and list posts and some other **GET**-based endpoints shouldn''t
    be login protected, so **Auth middleware** should be there for protected endpoints.
    It is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9f27415b-6938-483e-ad41-e743cec4b566.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in this diagram, the server will respond based on the provided
    authentication token and **Auth middleware** is just there to resolve a user from
    the authentication token. However, if **Auth middleware** will not able to resolve
    a user from the authentication token, it will simply return a 401 unauthorized
    error.
  prefs: []
  type: TYPE_NORMAL
- en: What is Auth middleware?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Auth middleware will be nothing more than a piece of code that will validate
    an authentication token and will try to resolve the user against that authentication
    token. It will be just a piece of code that will be attached to some endpoints
    in the routes or place from where the data for the endpoint is being returned.
    In any case, it will execute before the actual code for the endpoint and will
    validate and resolve the user from the `auth` token in Request.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 6](2c7fef92-d01a-4eef-8b1a-22a4adefc658.xhtml), *Illuminating RESTful
    Web Services with Lumen*, we will look into middleware and in [Chapter 7](f5b89fd4-5e88-40e7-aadd-760f2e64a2ec.xhtml),
    *Improving RESTful Web Services*, we will write code for authentication middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Common security threats in RESTful web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have looked at problems in our current code and how we will be implementing
    security in some of our endpoints and use authentication middleware, now it is
    the time to see what the common security threats that we need to consider while
    building RESTful web services are.
  prefs: []
  type: TYPE_NORMAL
- en: Use of HTTPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTPS is HTTP with SSL. As our data is being transferred over the internet,
    we need to make our connection secure; for that reason, we should use HTTPS. The
    purpose of HTTPS is to make sure that the server is who it claims to be and that
    data is transferred between the client and server with a secure connection in
    an encrypted form.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't want to buy an SSL certificate as it is costly for you, then you
    can simply go for [https://letsencrypt.org/.](https://letsencrypt.org/) Let's
    Encrypt is a free certificate authority. So, you can use it without paying for
    an SSL certificate.
  prefs: []
  type: TYPE_NORMAL
- en: Securing an API key/token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As our sessions will be based on a token, we need to secure that authentication
    token. There are different things that need to be done for that:'
  prefs: []
  type: TYPE_NORMAL
- en: Not passing an access token in the URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access token expiration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Not passing an access token in the URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API key or token or whatever sensitive information needs to be sent to the
    server, should not be passed in the URL as this can be captured in web server
    logs. So, it must be passed in the POST body or Request Headers.
  prefs: []
  type: TYPE_NORMAL
- en: Access token expiration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An access token should be expired in two cases. First, it should be expired
    on logout. Second, the access token should expire after a fixed amount of time,
    and this duration shouldn't be long. The reason for expiring a token is that it
    is safer to have an access token valid for less time. If we have many access tokens
    which are not in use, then there are more chances that those tokens can be misused.
  prefs: []
  type: TYPE_NORMAL
- en: The expiration period can be around two hours or less. Although it depends on
    how you want to implement it, a shorter expiration period is more secure. Expiration
    does not mean that the user will need to log in again, instead there will be a
    token refresh endpoint. That will be hit with the last expired token against a
    particular user to get a new token. Please note that last token should be usable
    for refresh token endpoint till a limited time, after that last token shouldn't
    be usable to refresh token. Otherwise, what's the point in expiring a token. Remember
    that there are trade offs between both ways. Refresh token on every request is
    more secure but cause more overhead for server. So it is always up to you that
    which way you prefer in your scenario.
  prefs: []
  type: TYPE_NORMAL
- en: The other way to expire a token is not to expire it by time, but by refreshing
    a token on every request. For example, if a request is sent with one token, the
    server will validate that token, refresh the token, and send a new token in response.
    So the old token will not be usable. The token will be refreshed on every request.
    It can be done in both ways; it is up to you how you prefer it.
  prefs: []
  type: TYPE_NORMAL
- en: Limited scope access token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is also a good idea to limit the scope of the access token to avoid problems
    if some one unauthorized has got the token. Also, if a service is being provided
    to a client-side application that is not specific to some user or access, then
    it should still have some sort of API key, by which we can identify who is asking
    for information. So, if there is a suspicious attempt to access an API endpoint
    with some API key, we can simply revoke the specific API key, so it will be no
    longer valid for future requests. It is only possible if there are multiple API
    keys having the limit access level.
  prefs: []
  type: TYPE_NORMAL
- en: Public and private endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like public web pages, we can have public endpoints for RESTful web services
    as well. All endpoints that are available to the user before authentication are
    not public. Sometimes, we make endpoints which are open to use before login, or
    without login, but they are only intended to be accessible through our application.
    Those endpoints are not public, so we do not want those endpoints to be accessible
    through other applications. For that purpose, we will be using some sort of API
    key, as discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: We can use an `oauth2`-based access token. A big advantage of using an `oauth2`
    access token is that if we are making different applications to access similar
    endpoints, then we can have different access tokens for different applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example:** We can have an online book store API exposed as a RESTful web
    service, and we can have two applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Book selling `app.` For customers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Book selecting `app.` For teachers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now through a customer's `app.`, users can browse different books and add to
    cart and buy. While in the teachers `app.`, users can browse and select different
    books to forward to a person who will buy books later. These two different apps.
    will have some endpoints in common and some endpoints different to each other.
    But, we don't want any endpoint to be publicly available to everyone. So, we can
    have two different access levels and will make two different mobile `apps.` having
    two different API keys, each having different access levels. When a user logs
    in, we will return an access token with limited access. Different tokens can have
    different access levels based on the user role.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say in the teacher `app.`, there can be some teachers who can only select
    books while some other teachers, let's say the **HOD** (**Head of Department**)
    can also buy books. So after login, both of these users can have a different access
    token translating into a different access level. This access level will be on
    the basis of the access token which will be translated into a user who is logged
    in, and we will get a role from the user on the basis of which we will decide
    the access level.
  prefs: []
  type: TYPE_NORMAL
- en: Public API endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So even before login, these endpoints were private. What if we have some API
    endpoints that are public, such as a weather forecast giving forecast data to
    everyone. It is better to still have an API key to track who is getting data to
    the server, but what if this is not the case and we are just giving data without
    any API keys? Does that mean that we are giving that data publicly, so we don't
    need to worry about anything? Actually, no.
  prefs: []
  type: TYPE_NORMAL
- en: If a client is passing any information to the server, then it is better to have
    TLS that should be used to encrypt data. Other than that, we also can't allow
    anyone to keep hitting an endpoint; to make usage fair, we need to apply throttling,
    which means an API endpoint can be hit only a limited number of times in a specific
    period of time from one client.
  prefs: []
  type: TYPE_NORMAL
- en: Insecure direct object reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Insecure direct object reference refers to getting or providing sensitive information
    based on data coming from Request. This is not a problem in only RESTful web services
    but also in websites. To understand that, let''s consider an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we are going to change a user''s first name or billing address.
    It is better to refer it to an endpoint such as: `PATCH /api/users/me?fist_name=Ali
    (having token in header)`, rather than `PATCH /api/users/2?fist_name=Ali (having
    token in header)`.'
  prefs: []
  type: TYPE_NORMAL
- en: To let a user modify his/her own data, it will have a token in the header by
    which a server will make sure that this user can modify a record. But, which record?
    In the endpoint with `me`, it will just get a user based on the token and will
    modify its `first_name`.
  prefs: []
  type: TYPE_NORMAL
- en: While in the second case, we have the user's `id=2`, so the user can be fetched
    or updated based on the user `id=2`, which is not secure as the user can pass
    any user ID in the URL. So, the problem is not this type of URL, the problem is
    getting or updating the record based on the reference directly from user input
    or the request from a client. No matter what user ID is provided, if we intend
    to modify a logged in user's first name, then it should get or update the user
    based on token and not the user ID in the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting allowable verbs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to restrict allowable verbs. For example if a web service endpoint is
    only for read purpose and not for modification, then on the URL, `/api/post/3`,
    we should only allow `GET method/verb` but shouldn't allow `PATCH. PUT`, `DELETE`,
    or `POST`. If someone hits `/api/post/3` with `PATCH`, `PUT`, `DELETE`, or `POST`,
    it shouldn't serve it, instead it should return an "405 Method Not Allowed" error.
  prefs: []
  type: TYPE_NORMAL
- en: However, if their client has an access token and based on that, the user is
    only allowed to use the `GET` method (although there are other methods available)
    and not other methods, and the client with that user hits the same URL with other
    methods, then there should be an "403 Forbidden" error, because there are methods
    allowed but just not to the current user based on its role or permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Input validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It seems that input validation is probably not very related to technology, but
    it is very important to validate input because it is not only beneficial to have
    clean data in a database, but it is also useful to protect against different threats
    such as XSS and SQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, XSS prevention and different input validation is an important part
    of input validation, while SQL injection is mainly prevented while entering data
    in a database. Another type of threat which needs to be prevented is CSRF, but
    that will already be prevented by the API key or authentication token usage. However,
    a separate CSRF token can also be used.
  prefs: []
  type: TYPE_NORMAL
- en: Available reusable code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We haven't discussed each and every security threat, but we used some things
    which needed to be taken care of to avoid security-related problems. We have discussed
    how we should secure our endpoints and how to implement authentication for RESTful
    web services. We also discussed flaws in our current code that we wrote in the
    previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: However, we haven't written code to make our code better and more secure. We
    can do this, but we should understand that there is already a lot of stuff to
    utilize instead of doing everything from scratch. So instead of writing everything
    in plain PHP by ourselves, we will use available code. It is not only to save
    time but also to use something that is available in the community and is time
    tested by the community.
  prefs: []
  type: TYPE_NORMAL
- en: So if we have made up our minds to use a third-party code snippet, package,
    or class, then we should understand that in PHP there is not one group of developers
    writing code in one framework. There are lots of PHP classes available as individual
    classes. Some are written for some frameworks. Some are written for Open Source
    CMS such as WordPress. There are also some packages available in **PEAR** (**PHP
    Extension and Application Repository**). So code available in one place may not
    be useful or compatible with other code.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, just loading different code snippets together could also be a problem,
    especially when there are a lot of dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: So, here comes the revolution in the PHP community. It isn't a framework or
    CMS or open source class or extension. It is a dependency manager for PHP, known
    as Composer. We can install Composer packages in a standard way and Composer has
    been a standard for most of PHP's popular frameworks. We will not talk more about
    Composer here because Composer is the topic of the next chapter, so we will talk
    about it in detail as we will be using Composer a lot for package installations,
    dependency management, auto-loading, and more. Not only in this book but if you
    are going to make any proper application in PHP, you will need a composer. So
    the reusable code that we will use will be mostly through Composer packages.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already have discussed problems and missing parts in our current code and
    security threats, and we have discussed how we will implement authentication.
    We also discussed that we will use reusable components or code to save our time
    and effort. Also, because the code will be written by ourselves, we will be responsible
    for its maintenance and testing, so using open source stuff which is not only
    available but in many cases is tested, as well as maintained by the community,
    makes more sense. For that purpose, we will be mostly using Composer as it has
    become a standard tool for packaging and using reusable packages in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn more about Composer. What it is, how it
    works, and how we can use it for different purposes.
  prefs: []
  type: TYPE_NORMAL
- en: We have talked about security threats in this chapter, but we have not covered
    them in lots of detail because we only had one chapter to discuss them. But, web
    application and RESTful Web service security is a wide topic. There is a lot more
    to learn about it. I would recommend you to go and check [https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project](https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project)
    as a starting point. There is a lot of stuff you will learn from there and you
    will learn from a different perspective.
  prefs: []
  type: TYPE_NORMAL
