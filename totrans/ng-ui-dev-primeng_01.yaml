- en: Getting Started with Angular and PrimeNG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book presupposes some basic knowledge of TypeScript and Angular 2\. Anyway,
    we would like to give the readers an overview of the most important TypeScript
    and Angular key concepts used in this book. We will summarize TypeScript and Angular
    features and present them in understandable, simple, but deeply explained portions.
    At the time of writing the book, the current TypeScript and Angular Versions are
    2.3.x and 4.2.x, respectively. Readers will also meet the PrimeNG UI library for
    the first time and gain experience with project setups in three various ways.
    At the end of this chapter, readers will be able to run the first Angular- and
    PrimeNG-based web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript fundamentals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced types, decorators, and compiler options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular cheat sheet - overview of key concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular modularity and lifecycle hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running PrimeNG with SystemJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up PrimeNG project with Webpack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up PrimeNG project with Angular CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular 2 and higher is built with features of ECMAScript 2015/2016 and TypeScript.
    The new ECMAScript standards target evergreen browsers and helps to write more
    powerful, clean, and concise code. You can also use these features in any other
    less modern browsers with Polyfills such as `core-js` ([https://github.com/zloirock/core-js](https://github.com/zloirock/core-js)).
    But, why do we need to use TypeScript?
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript ([http://www.typescriptlang.org](http://www.typescriptlang.org))
    is a typed language and a super set of JavaScript developed by Microsoft. One
    can say that TypeScript is an advanced JavaScript with optional static typing.
    TypeScript code is not processed by browsers, it has to be translated into JavaScript
    by means of a TypeScript compiler. This translation is called *compilation* or
    *transpilation*. The TypeScript compiler transpiles `.ts` files into `.js` files.
    The main advantages of TypeScript are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Types help you find and fix a lot of errors during development time. That means,
    you have less errors at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many modern ECMAScript features are supported out of the box. More features
    are expected according to the roadmap ([https://github.com/Microsoft/TypeScript/wiki/Roadmap](https://github.com/Microsoft/TypeScript/wiki/Roadmap)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Great tooling and IDE support with IntelliSense makes the coding a pleasure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easier to maintain and refactor a TypeScript application than one written
    in untyped JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers feel comfortable with TypeScript due to object-oriented programming
    patterns, such as interfaces, classes, enums, generics, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last but not least, Angular 2+ and PrimeNG are written in TypeScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is also important to keep the following points in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: The Typescript Language Specification says, *<q>every JavaScript program is
    also a TypeScript program</q>*. Hence, a migration from JavaScript to TypeScript
    code is easily done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript compiler emits output even when any errors are reported. In the next
    section, *Advanced types, decorators, and compiler options*, we will see how we
    can forbid emitting JavaScript on errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What is the best way to learn the TypeScript language? There is an official
    handbook on the TypeScript''s homepage, which is aligned with the last released
    version. Hands-on learning is possible with the TypeScript playground ([http://www.typescriptlang.org/play](http://www.typescriptlang.org/play)),
    which compiles on-the-fly TypeScript code entered in a browser and shows it side
    by side with the generated JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/beff0870-ae1c-47bc-9a63-8c5e9b71e2e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, you can install the TypeScript globally by typing the following
    command in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Global installation means, the TypeScript compiler `tsc` can be reached and
    used in any of your projects. Installed Node.js and npm are presupposed. Node.js
    is the JavaScript runtime environment ([https://nodejs.org](https://nodejs.org)).
    npm is the package manager. It is shipped with Node.js, but can be installed separately
    as well. After that, you can transpile one or more `.ts` files into `.js` files
    by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will result in two files, `some.js` and `another.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Basic types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript exposes the basic types, as well as a couple of extra types. Let's
    explore the type system with these examples.
  prefs: []
  type: TYPE_NORMAL
- en: '`Boolean`: The type is a primitive JavaScript boolean:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`Number`: The type is a primitive JavaScript number:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`String`: The type is a primitive JavaScript string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`Array`: The type is an array of value. There are two equivalent notations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`Tuple`: The type represents a heterogeneous array of values. `Tuple` enables
    storing multiple fields of different types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`Any`: The type is *anything*. It is useful when you need to describe the type
    of variables that you do not know at the time of writing your application. You
    can assign a value of arbitrary type to a variable of type `any`. A value of type
    `any` in turn can be assigned to a variable of arbitrary type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`Void`: The type represents the absence of having an `any` type. This type
    is normally used as the return type of functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`Nullable`: These types denote two specific types, `null` and `undefined` that
    are valid values of every type. That means, they can be assigned to any other
    type. It is not always desired. TypeScript offers a possibility to change this
    default behavior by setting the compiler options `strictNullChecks` to `true`.
    Now, you have to include the `Nullable` types explicitly using a union type (explained
    later on), otherwise, you will get an error:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, you would like to tell compiler that you know the type better than
    it does and it should trust you. For instance, imagine a situation where you receive
    data over HTTP and know exactly the structure of the received data. The compiler
    doesn't know such structure of course. In this case, you want to turn off the
    type checking when assigning the data to a variable. It is possible with so called
    **type assertions**. A type assertion is like a type cast in other languages,
    but without the checking of data. You can do that either with *angle bracket*
    or the `as` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Interfaces, classes, and enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An *interface* is a way to take a particular structure/shape and give it a
    name so that we can reference it later as a type. It defines a contract within
    our code. Interfaces begin with the keyword `interface`. Let''s take an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The specified interface `Person` has the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `name` property of type `string`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optional property `children` of type `number`. Optional properties are denoted
    by a question mark and can be omitted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `isMarried` method that returns a `boolean` value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anonymous (unnamed) method that returns nothing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Typescript allows you to use the syntax `[index: type]` to specify a `string`
    or `number` type based collection of key/value pairs. Interfaces perfectly fit
    such data structures. For example, consider the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: An interface is only used by TypeScript compiler at compile time, and is then
    removed. Interfaces don't end up in the final JavaScript output. General, no types
    appear in the output. You can see that in the TypeScript playground mentioned
    earlier.![](assets/5f81e48d-5e0e-447b-8782-272b7fb9a4aa.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Beside interfaces, there are *classes* that describe objects. A class acts
    as a template for instantiating specific objects. The syntax for TypeScript''s
    classes is almost identical to that of native classes in ECMAScript 2015 with
    some handy additions. In TypeScript, you can use `public`, `private`, `protected`,
    and `readonly` access modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Members with omitted modifiers are `public` by default. If a property or method
    is declared with the `static` keyword, there is no need to create an instance
    to access them.
  prefs: []
  type: TYPE_NORMAL
- en: 'A class can be abstract, that means, it may not be instantiated directly. Abstract
    classes begin with the keyword `abstract`. A class can implement an interface
    as well as extend another class. We can achieve that using the `implements` and
    `extends` keywords, respectively. If a class implements some interface, it must
    adopt all properties from this interface; otherwise, you will get an error about
    missing properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Derived classes that contain constructor functions must call `super()`. The
    `super()` call executes the constructor function on the base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to declare a `constructor` parameter with a modifier. As result,
    a member will be created and initialized in one place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This shortened syntax is often used in Angular when we inject services into
    components. Angular's services are normally declared in the component's constructor
    with the `private` modifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last basic type to be mentioned here is *enum*. Enums allow us to define
    a set of named constants. Enum members have numeric values associated with them
    (started with 0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Parameters and return values in the function signature can be typed too. Types
    protects you against JavaScript errors during function execution because the compiler
    warns you punctually at build time when the wrong types are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Function type* is a way to declare the type of a function. To explicitly declare
    a function type, you should use the keywords `var` or `let`, a variable name,
    a colon, a parameter list, a fat arrow `=>`, and the function''s return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you must provide an implementation of this declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This technique is especially useful for callbacks. Imagine a filter function
    which filters arrays by some criterion. An exact criterion can be encapsulated
    in the passed in callback function that acts as predicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A possible function call with a specific callback could appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In TypeScript, every function parameter is assumed to be required. There are
    two ways to mark a parameter as optional (optional parameters can be omitted when
    calling the function).
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a question mark after the parameter name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the parameter''s default value (ECMAScript 2015 feature), which gets applied
    when no value is provided:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, you are able to call this function with just one value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In TypeScript, you can define generic functions, interfaces, and classes like
    in other programming languages. A generic function has type parameters listed
    in angle brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Such generic functions can be defined with generic interfaces as well. The
    function signature for `reverseAndMerge` is compatible with the following generic
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the generic type parameter list in angle brackets follows the name
    of the function and interface. This is also true for classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ECMAScript 2015 has introduced built-in modules. The features of modules are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Each module is defined in its own file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions or variables defined in a module are not visible outside unless you
    explicitly export them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can place the `export` keyword in front of any variable, function, or class
    declaration to export it from the module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the `import` keyword to consume the exported variable, function,
    or class declaration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules are singletons. Only a single instance of a module exists, even if it
    was imported multiple times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some exporting possibilities are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can declare a variable, function, or class and export it later. You can
    also use the `as` keyword to rename exports. A new name is the name used for importing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have a module with exports, you can access its functionality in another
    module using the `import` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a special case that allows you to import the entire module as a single
    object. All exported variables, functions, and classes are available on that object
    as properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Imports can be renamed with the `as` keyword and used under the new name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Advanced types, decorators, and compiler options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript has more types and advanced constructs such as decorators and type
    definition files. This chapter gives an overview on advanced topics and shows
    how to customize the compiler configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Union types and type aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *union type* describes a value that can be one of many types. The vertical
    bar `|` is used as separator for each type the value can have. For instance, `number
    | string` is the type of a value that can be a number or string. For such values,
    we can only access members that are common to all types in the union. The following
    code works because the `length` property exists on both strings and arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The next code snippet gives an error because the `model` property does not
    exist on the `Bike` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '*Type alias* is used as alternative name for the existing type or combination
    of types. It doesn''t create a new type. A type alias begins with the `type` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Type aliases can be used for better code readability, for example, in the function
    parameter list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Type aliases can also be generic and make tricky types, which can not be made
    with interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Type inference* is used when the type is not provided explicitly. For instance
    in the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'These don''t have explicit type annotations. TypeScript can infer that `x`
    is a string and `y` is a number. As you see, the type can be omitted if the compiler
    is able to infer it. TypeScript improves the type inference continuously. It tries
    to guess a best common type when elements of several types are present in an array.
    The type of the following variable `animal`, where `Sheepdog extends Dog`, is
    `Dog[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The best common type of the next array is `(Dog | Fish)[]` because the class
    `Fish` doesn''t extend to any other class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Type inference is also used for functions. In the next example, the compiler
    can figure out the types of the function''s parameter (`string`) and the return
    value (`boolean`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Decorators* were proposed in ECMAScript 2016 ([https://github.com/wycats/javascript-decorators](https://github.com/wycats/javascript-decorators)).
    They are similar to Java annotations--they also add metadata to class declaration,
    method, property, and the function''s parameter, but they are more powerful. They
    add new behaviors to their targets. With decorators, we can run arbitrary code
    before, after, or around the target execution, like in aspect-oriented programming,
    or even replace the target with a new definition. In TypeScript, you can decorate
    constructors, methods, properties, and parameters. Every decorator begins with
    the `@` character followed by the name of the decorator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'How does it work under the hood that takes its target as argument? Let''s implement
    a classic example with a logging functionality. We would like to implement a method
    decorator `@log`. A method decorator accepts three arguments: an instance of the
    class on which the method is defined, a key for the property, and the property
    descriptor ([https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the method decorator returns a value, it will be used as a new property
    descriptor for this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This decorator logs received arguments and return values. Decorators can be
    composed and customized with parameters too. You can write the following, for
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Angular offers different types of decorators that are used for dependency injection
    or adding metadata information at compilation time:'
  prefs: []
  type: TYPE_NORMAL
- en: Class decorators such as `@NgModule`, `@Component`, and `@Injectable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property decorators such as `@Input` and `@Output`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method decorators such as `@HostListener`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameter decorators such as `@Inject`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TypeScript compiler is able to emit some design-time type metadata for decorators.
    To access this information, we have to install a Polyfill called `reflect-metadata`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can access, for example, the type of the property (`key`) on the `target`
    object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the official TypeScript documentation to learn more about decorators
    and reflect metadata API ([http://www.typescriptlang.org/docs/handbook/decorators.html](http://www.typescriptlang.org/docs/handbook/decorators.html)).In
    TypeScript, Angular applications, decorators are enabled by setting the compiler
    options `emitDecoratorMetadata` and `experimentalDecorators` to `true` (compiler
    options are described later on).
  prefs: []
  type: TYPE_NORMAL
- en: Type definition files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript programs written in native JavaScript don't have any type information.
    If you add a JavaScript library such as jQuery or Lodash to your TypeScript-based
    application and try to use it, the TypeScript compiler can find any type information
    and warn you with compilation errors. Compile-time safety, type checking, and
    context-aware code completion get lost. That is where *type definition files*
    come into play.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type definition files provide type information for JavaScript code that is
    not statically typed. Type definition files ends with `.d.ts` and only contain
    definitions which are not emitted by TypeScript. The `declare` keyword is used
    to add types to JavaScript code that exists somewhere. Let''s take an example.
    TypeScript is shipped with the `lib.d.ts` library describing ECMAScript API. This
    type definition file is used automatically by the TypeScript compiler. The following
    declaration is defined in this file without implementation details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you use the `parseInt` function in your code, the TypeScript compiler
    ensures that your code uses the correct types and IDEs show context-sensitive
    hints when you''re writing code. Type definition files can be installed as dependencies
    under the `node_modules/@types` directory by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'A concrete example for jQuery library is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In Angular, all type definition files are bundled with Angular npm packages
    and located under `node_modules/@angular`. There is no need to install such files
    separately like we did for jQuery. TypeScript finds them automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, you have the compile target ES5 (generated JavaScript version,
    which is widely supported), but want to use some ES6 (ECMAScript 2015) features
    by adding Polyfills. In this case, you must tell the compiler that it should look
    for extended definitions in the `lib.es6.d.ts` or `lib.es2015.d.ts` file. This
    can be achieved in compiler options by setting the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Compiler options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typically, the first step in a new TypeScript project is to add in a `tsconfig.json`
    file. This file defines the project and compiler settings, for instance, files
    and libraries to be included in the compilation, output structure, module code
    generation, and so on. A typical configuration in `tsconfig.json` for Angular
    2+ projects looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The listed compiler settings are described as follows. A full list of all options
    is available at the TypeScript documentation page ([https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html)).
  prefs: []
  type: TYPE_NORMAL
- en: '| **Option** | **Type** | **Default** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `target` | `string` | `ES3` | This specifies ECMAScript target version: `ES3`,
    `ES5`, `ES2015`, `ES2016`, and `ES2017`. |'
  prefs: []
  type: TYPE_TB
- en: '| `module` | `string` | `ES6` if target is "ES6" and `CommonJS` otherwise |
    This specifies the format of module code generation: `None`, `CommonJS`, `AMD`,
    `System`, `UMD`, `ES6`, or `ES2015`. |'
  prefs: []
  type: TYPE_TB
- en: '| `moduleResolution` | `string` | `Classic` if module is "AMD," `System`, `ES6`,
    and `Node` otherwise | This determines how modules get resolved. Either `Node`
    for Node.js style resolution or `Classic`. |'
  prefs: []
  type: TYPE_TB
- en: '| `noImplicitAny` | `boolean` | `false` | This raises errors on expressions
    and declarations with an implied `any` type. |'
  prefs: []
  type: TYPE_TB
- en: '| `sourceMap` | `boolean` | `false` | This generates the corresponding `.map`
    file. This is useful if you want to debug original files. |'
  prefs: []
  type: TYPE_TB
- en: '| `emitDecoratorMetadata` | `boolean` | `false` | This emits design type metadata
    for decorated declarations in source. You have to set this value to `true` if
    you want to develop web applications with Angular. |'
  prefs: []
  type: TYPE_TB
- en: '| `experimentalDecorators` | `boolean` | `false` | This enables experimental
    support for ECMAScript decorators. You have to set this value to `true` if you
    want to develop web applications with Angular. |'
  prefs: []
  type: TYPE_TB
- en: '| `outDir` | `string` | - | This is the output directory for compiled files.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `lib` | `string[]` | Refer to the documentation for more information. | This
    is the list of library files to be included in the compilation. Refer to the documentation
    for more information. |'
  prefs: []
  type: TYPE_TB
- en: '| `types` | `string[]` | - | This is the list of names of type definitions
    to include. |'
  prefs: []
  type: TYPE_TB
- en: '| `exclude` | `string[]` | - | This is the list of (sub) directories excluded
    from the compilation. |'
  prefs: []
  type: TYPE_TB
- en: You can stop the compiler from emitting JavaScript on errors by setting the
    `--noEmitOnError` option to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Angular cheat sheet - overview of key concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular 2 introduces completely new concepts for building web applications.
    The new Angular platform is complex. It is not possible to explain numerous Angular
    features in detail. Instead, we will concentrate on the most important key concepts
    such as dependency injection, components, and communication between them, built-in
    directives, services, template syntax, forms, and routing.
  prefs: []
  type: TYPE_NORMAL
- en: Components, services, and dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Normally, you write Angular applications by composing HTML templates with the
    Angular-specific markup and component classes to manage those templates. A **component**
    is simply a TypeScript class annotated with `@Component`. The `@Component` decorator
    is used to define the associated metadata. It expects an object with the following
    most used properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`selector`: This is the name of the HTML tag representing this component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template`: This is an inline-defined template with HTML/Angular markup for
    the view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templateUrl`: This is the path to an external file where the template resides'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`styles`: An inline-defined styles to be applied to this component''s view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`styleUrls`: An array of paths to external files with styles to be applied
    to this component''s view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`providers`: An array of providers available to this component and its children'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exportAs`: This is the name under which the component instance is exported
    in a template'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`changeDetection`: This is the change detection strategy used by this component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`encapsulation`: This is the style encapsulation strategy used by this component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A component class interacts with the view through an API of properties and
    methods. Component classes should delegate complex tasks to services where the
    business logic resides. **Services** are just classes that Angular instantiates
    and then injects into components. If you register services at the root component
    level, they act as singletons and share data across multiple components. In the
    next section, *Angular modularity and lifecycle hooks*, we will see how to register
    services. The following example demonstrates how to use components and services.
    We will write a service class `ProductService` and then specify an argument of
    type `ProductService` in the constructor of `ProductComponent`. Angular will automatically
    inject that service into the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we applied the `@Injectable()` decorator to the service class. This
    is necessary for emitting metadata that Angular needs to inject other dependencies
    into this service. Using `@Injectable` is a good programming style even if you
    don't inject other services into your service.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is good to know what an item in the `providers` array looks like. An item
    is an object with the `provide` property (symbol used for dependency injection)
    and one of the three properties `useClass`, `useFactory`, or `useValue` that provide
    implementation details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Templates and bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A template tells Angular how to render the component''s view. Templates are
    HTML snippets with the specific Angular''s template syntax, such as interpolation,
    property, attribute, and event bindings, built-in directives, and pipes to mention
    just a few. We will give you a quick overview of the template syntax starting
    with interpolation. **Interpolation** is used to evaluate expressions in double
    curly braces. The evaluated expression is then converted to a string. The expression
    can contain any mathematical calculations, component''s properties and methods,
    and many more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Angular evaluates template expressions after every change detection cycle.
    Change detection cycles are triggered by many asynchronous activities such as
    HTTP responses, key and mouse events, and many more. The next fundamental template
    syntax is related to various bindings. *Property binding* sets an element property
    to a component property value. The element property is defined in square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `imageUrl` and `formValid` are a component''s properties. Note that this
    is a *one-way* binding because the data flow occurs in one direction, from the
    component''s properties into target element properties. *Attribute binding* allows
    us to set an attribute. This kind of binding is used when there is no element
    property to bind. The attribute binding uses square brackets too. The attribute
    name itself is prefixed with `attr.`, for example, consider ARIA attributes for
    web accessibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'User interactions result in a data flow from an element to a component. In
    Angular, we can listen for certain key, mouse, and touch events by means of *event
    binding*. The event binding syntax consists of a target event name within parentheses
    on the left and a quoted template statement on the right. In particular, you can
    call a component''s method. In the next code snippet, the `onSave()` method is
    called on a click:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The method (generally template statement) gets a parameter--an event object
    named `$event`. For native HTML elements and events, `$event` is a DOM event object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Two-way binding is possible as well. The `[(value)]` syntax combines the brackets
    of property binding with the parentheses of event binding. Angular''s directive
    `NgModel` is best suited for the two-way binding on native or custom input elements.
    Consider the following sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Two-way binding in a nutshell: a property gets displayed and updated at the
    same time when the user makes changes. A *template reference variable* is another
    example of handy template syntax. You can declare a variable with the hash symbol
    (`#`) on any DOM element and reference this variable anywhere in the template.
    The next example shows the `username` variable declared on an `input` element.
    This reference variable is consumed on a button--it is used to get an input value
    for the `onclick` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'A template reference variable can also be set to a directive. A typical example
    is the `NgForm` directive which provides useful details about the `form` elements.
    You can, for example, disable the submit button if the form is not valid (required
    fields are not filled in and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, the *pipe* operator (`|`). It is used for the transformation
    of the expression''s result. The pipe operator passes the result of an expression
    on the left to a pipe function on the right. For example, the pipe `date` formats
    JavaScript `Date` object according to the specified format ([https://angular.io/docs/ts/latest/api/common/index/DatePipe-pipe.html](https://angular.io/docs/ts/latest/api/common/index/DatePipe-pipe.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Multiple chained pipes can be applied as well.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular has a lot of built-in directives: `ngIf`, `ngFor`, `ngSwitch`, `ngClass`,
    and `ngStyle`. The first three directives are so called *structural directives*,
    which are used to transform the DOM''s structure. Structural directives start
    with an asterisk (`*`). The last two directives manipulate the CSS classes and
    styles dynamically. Let''s explain the directives in the examples.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ngIf` directive adds and removes elements in the DOM, based on the Boolean
    result of an expression. In the next code snippet, `<h2>ngIf</h2>` is removed
    when the `show` property evaluates to `false` and gets recreated otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Angular 4 has introduced a new `else` clause with the reference name for a
    template defined by `ng-template`. The content within `ng-template` is shown when
    the `ngIf` condition evaluates to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '`ngFor` outputs a list of elements by iterating over an array. In the next
    code snippet, we iterate over the `people` array and store each item in a template
    variable called `person`. This variable can be then accessed within the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '`ngSwitch` conditionally swaps the contents dependent on condition. In the
    next code snippet, `ngSwitch` is bound to the `choice` property. If `ngSwitchCase`
    matches the value of this property, the corresponding HTML element is displayed.
    If no matching exists, the element associated with `ngSwitchDefault` is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '`ngClass` adds and removes CSS classes on an element. The directive should
    receive an object with class names as keys and expressions as values that evaluate
    to `true` or `false`. If the value is `true`, the associated class is added to
    the element. Otherwise, if `false`, the class is removed from the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '`ngStyle` adds and removes inline styles on an element. The directive should
    receive an object with style names as keys and expressions as values that evaluate
    to style values. A key can have an optional `.<unit>` suffix (for example, `top.px`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In order to be able to use built-in directives in templates, you have to import
    `CommonModule` from `@angular/common` and add it to the root module of your application.
    Angular's modules are explained in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Communication between components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Components can communicate with each other in a loosely coupled manner. There
    are various ways Angular''s components can share data, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Passing data from parent to child using `@Input()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing data from child to parent using `@Output()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using services for data sharing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `ViewChild`, `ViewChildren`, `ContentChild`, and `ContentChildren`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the child component using a local variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will only describe the first three ways. A component can declare input and
    output properties. To pass the data from a parent to a child component, the parent
    binds the values to the input properties of the child. The child''s input property
    should be decorated with `@Input()`. Let''s create `TodoChildComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the parent component can use `todo-child` in its template and bind the
    parent''s `todo` object to the child''s `todo` property. The child''s property
    is exposed as usual in square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If a component needs to pass the data to its parent, it emits custom events
    via the output property. The parent can create a listener to a particular component''s
    event. Let''s see that in action. The child component `ConfirmationChildComponent`
    exposes an `EventEmitter` property decorated with `@Output()` to emit events when
    the user clicks on buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The parent subscribes an event handler to that event property and reacts to
    the emitted event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: A bi-directional communication is possible via services. Angular leverages RxJS
    library ([https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS))
    for asynchronous and event-based communication between several parts of an application
    as well as between an application and remote backend. The key concepts in the
    asynchronous and event-based communication are `Observer` and `Observable`. They
    provide a generalized mechanism for push-based notification, also known as the
    observer design pattern. `Observable` represents an object that sends notifications,
    and `Observer` represents an object that receives them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular implements this design pattern everywhere. For example, Angular''s
    `Http` service returns an `Observable` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'In case of the inter-component communication, an instance of the `Subject`
    class can be used. This class inherits both `Observable` and `Observer`. That
    means it acts as a message bus. Let''s implement `TodoService` that allows us
    to emit and receive `Todo` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Components can use this service in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Forms are the main building blocks in every web application. Angular offers
    two approaches to build forms: *template-driven forms* and *reactive forms*. This
    section gives you a short overview of template-driven forms.'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive forms are suitable when you need to create dynamic forms programmatically
    in the component's class. Refer to the official Angular documentation to learn
    reactive forms ([https://angular.io/docs/ts/latest/guide/reactive-forms.html](https://angular.io/docs/ts/latest/guide/reactive-forms.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We already mentioned two directives: `NgForm` and `NgModel`. The first directive
    creates a `FormGroup` instance and binds it to a form in order to track aggregate
    form value and validation status. The second one creates a `FormControl` instance
    and binds it to the corresponding `form` element. The `FormControl` instance tracks
    the value and the status of the `form` element. Each input element should have
    a `name` property that is required to register the `FormControl` by the `FormGroup`
    under the name you assigned to the `name` attribute. How to deal with this tracked
    data? You can export the `NgForm` and `NgModel` directives into local template
    variables such as `#f="ngForm"` and `#i="ngModel"`, respectively. Here, `f` and
    `i` are local template variables that give you access to the value and status
    of `FormGroup` and `FormControl`, respectively. This is possible because the properties
    from `FormGroup` and `FormControl` are duplicated on the directives themselves.
    With this knowledge in hand, you can now check if the whole form or a particular
    `form` element:'
  prefs: []
  type: TYPE_NORMAL
- en: Is valid (`valid` and `invalid` properties)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has been visited (`touched` and `untouched` properties)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has some changed value (`dirty` and `pristine` properties)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next example illustrates the basic concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The `NgModel` directive also updates the corresponding `form` element with
    specific CSS classes that reflect the element''s state. The following classes
    are added/removed dependent on the current state:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **State** | **Class if true** | **Class if false** |'
  prefs: []
  type: TYPE_TB
- en: '| Element has been visited | `ng-touched` | `ng-untouched` |'
  prefs: []
  type: TYPE_TB
- en: '| Element''s value has changed | `ng-dirty` | `ng-pristine` |'
  prefs: []
  type: TYPE_TB
- en: '| Element''s value is valid | `ng-valid` | `ng-invalid` |'
  prefs: []
  type: TYPE_TB
- en: 'This is handy for styling. For example, in case of validation errors, you can
    set red borders around input elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular''s `router` module allows you to configure navigation in a single page
    application without a full page reload. The router can display different views
    (compiled component templates) within a special tag called `<router-outlet>`.
    During navigation, one view will be replaced by another one. A simple routing
    configuration looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'When you navigate to the web context root, you will be redirected to `/home`.
    As a reaction to that, the view of the `HomeComponent` will be displayed in `<router-outlet>`.
    It is obvious that a direct navigation to `/home` displays the same view. A navigation
    to `/books` displays the view of `BooksComponent`. Such router configuration should
    be converted to an Angular''s module by `RouterModule.forRoot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'This is then imported in a root module class. In addition to the root module,
    an Angular application can consist of a lot of feature or lazy-loaded modules.
    Such separate modules can have their own router configurations which should be
    converted to Angular''s modules with `RouterModule.forChild(router)`. The next
    section, *Angular modularity and lifecycle hooks,* discusses modules in detail.
    Angular offers two strategies for implementing client-side navigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HashLocationStrategy`: This strategy adds a hash sign (`#`) to the base URL.
    Everything after this sign represents a hash fragment of the browser''s URL. The
    hash fragment identifies the route. For example, `http://somehost.de:8080/#/books`.
    Changing the route doesn''t cause a server-side request. Instead, the Angular
    application navigates to a new route and view. This strategy works with all browsers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PathLocationStrategy`: This strategy is based on the **History API** and only
    works in browsers that support HTML5\. This is the default location strategy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The details are to be mentioned here. If you want to use the `HashLocationStrategy`,
    you have to import two classes, `LocationStrategy` and `HashLocationStrategy`
    from `''@angular/common''` and configure providers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Providers are described in the next section, *Angular modularity and lifecycle
    hooks.* The `PathLocationStrategy` class requires a configuration of the base
    URL for the entire application. The best practice is to import `APP_BASE_HREF`
    constant from `''@angular/common''` and use it as a provider in order to configure
    the base URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'How to trigger a navigation? You can achieve that in two ways, either by a
    link with a `routerLink` property, which specifies an array consisting of route
    (path) and optional parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Or programmatically, by invoking the `navigate` method on Angular''s `Router`
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also pass parameters to a route. Placeholders for parameters start
    with a colon (`:`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when navigating to a book with real parameters, for example, programmatically
    as `this.router.navigate([''/books/2''])`, the real parameter can be accessed
    by `ActivatedRoute`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The router outlet can be named as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The associated configuration should contain the `outlet` property with the
    name of the router outlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Angular modularity and lifecycle hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular modularity with NgModules provides a great way to organize the code
    in a web application. Many third-party libraries, such as PrimeNG, Angular Material,
    Ionic, are distributed as NgModules. *Lifecycle hooks* allow us to perform custom
    logic at component level at a well-defined time. This section covers these major
    concepts in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Modules and bootstrapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular modules make it possible to consolidate components, directives, services,
    pipes, and many more into cohesive blocks of functionality. Angular''s code is
    modularized. Every module has its own functionality. There are `FormsModule`,
    `HttpModule`, `RouterModule`, and many other modules as well. What does a module
    look like? A module is a class annotated with the `@NgModule` decorator (imported
    from `@angular/core`). `@NgModule` takes a configuration object that tells Angular
    how to compile and run the module code. The most significant properties of the
    the configuration object are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`declarations`: The array with components, directives, and pipes, which are
    implemented in that module and belong to that module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imports`: The array with dependencies in form of other modules which need
    to be made available to that module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exports`: The array of components, directives, and pipes to be exported and
    permitted to be imported by another modules. The rest is private. This is the
    module''s public API and similar to how the `export` keyword works in ECMAScript
    modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`providers`: This is the array of services (service classes, factories, or
    values), which are available in that module. Providers are parts of the module
    and can be injected into components (inclusive sub-components), directives, and
    pipes defined within the module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bootstrap`: Every Angular application has at least one module--the root module.
    The `bootstrap` property is only used in the root module and contains the component
    which should be instantiated first when bootstrapping the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entryComponents`: This is the array of components that Angular generates component
    factories for. Normally, you need to register a component as an entry component
    when it is intended to be created dynamically at runtime. Such components can
    not be figured out automatically by Angular at template compilation time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A typical module configuration for any separate example in this book looks
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '`BrowserModule` is needed to get access to the browser-specific renderers and
    Angular standard directives such as `ngIf` and `ngFor`. Don''t import `BrowserModule`
    in any other modules except the root module. Feature modules and lazy-loaded modules
    should import `CommonModule` instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of how to bootstrap an Angular application in the
    JIT mode (just in time compilation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'In the **ahead-of-time** mode (**AOT** compilation), you need to provide a
    factory class. To generate the factory class, you must run the `ngc` compiler
    instead of the TypeScript `tsc` compiler. In the last two sections of this chapter,
    you will see how to use AOT with Webpack and Angular CLI. The bootstrapping code
    in the AOT mode looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Templates with bindings written in Angular need to be compiled. With AOT, the
    compiler runs once at build time. With JIT, it runs every time at runtime. Browsers
    load a pre-compiled version of the application much faster and there is no need
    to download the Angular compiler if the app is already compiled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modules can also be lazy loaded when they get requested (on demand). This approach
    reduces the size of web resources loaded on initial page display. The page appears
    faster. If you want to enable lazy loading, you have to configure the router to
    load the module lazy. All you need is a `path` object with a `loadChildren` property,
    which points to the path and name of the lazy loaded module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Note that the value of `loadChildren` property is a string. Furthermore, the
    module importing this router configuration should not declare the lazy loaded
    module as dependency in the `imports` property of the configuration object.
  prefs: []
  type: TYPE_NORMAL
- en: Lifecycle hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular components come with lifecycle hooks, which get executed at specific
    times in the component''s life. For this purpose, Angular offers different interfaces.
    Each interface has a method of the same name as the interface name with the prefix
    `ng`. Each method is executed when the corresponding lifecycle event occurs. They
    are also called lifecycle hook methods. Angular calls the lifecycle hook methods
    in the following sequence after the constructor has been called:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **The lifecycle hook method** | **Purpose and timing** |'
  prefs: []
  type: TYPE_TB
- en: '| `ngOnChanges` | This is called whenever one or more data-bound input properties
    change. This method is called on initial changes (before `ngOnInit`) and any other
    subsequent changes. This method has one parameter--an object with keys of type
    `string` and values of type `SimpleChange`. The keys are the component''s property
    names. The `SimpleChange` object contains current and previous values. A usage
    example is shown next. |'
  prefs: []
  type: TYPE_TB
- en: '| `ngOnInit` | This is called once, after the first `ngOnChanges`. Note that
    the constructor of a component should only be used for dependency injection because
    data-bound input values are not yet set in the constructor. Everything else should
    be moved to the `ngOnInit` hook. A usage example is shown next. |'
  prefs: []
  type: TYPE_TB
- en: '| `ngDoCheck` | This is called during every change detection run. It is a good
    place for custom logic, which allows us to do a fine-grained check of which property
    on our object changed. |'
  prefs: []
  type: TYPE_TB
- en: '| `ngAfterContentInit` | This is called once, after Angular puts external content
    into the component''s view. A placeholder for any external content is marked with
    the `ngContent` directive (the `ng-content` tag). A usage example of the `ngContent`
    directive is demonstrated afterwards. |'
  prefs: []
  type: TYPE_TB
- en: '| `ngAfterContentChecked` | This is called after Angular checks the content
    put into the component''s view. |'
  prefs: []
  type: TYPE_TB
- en: '| `ngAfterViewInit` | This is called once, after Angular initializes the component''s
    and child''s views. |'
  prefs: []
  type: TYPE_TB
- en: '| `ngAfterViewChecked` | This is called after Angular checks the component''s
    views and child views. |'
  prefs: []
  type: TYPE_TB
- en: '| `ngOnDestroy` | This is called just before Angular destroys the component''s
    instance. This happens when you remove the component with built-in structural
    directives such as `ngIf`, `ngFor`, `ngSwitch`, or when you navigate to another
    view. This is a good place for cleanup operations such as unsubscribing observables,
    detaching event handlers, canceling interval timers, and so on. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s see an example of how to use `ngOnInit` and `ngOnChanges`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Usage in HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now see how to use the `ngContent` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Usage in HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'After the component''s initialization, the following hook methods get always
    executed on every change detection run: `ngDoCheck` -> `ngAfterContentChecked`
    -> `ngAfterViewChecked` -> `ngOnChanges`.'
  prefs: []
  type: TYPE_NORMAL
- en: Running PrimeNG with SystemJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PrimeNG ([https://www.primefaces.org/primeng](https://www.primefaces.org/primeng))
    is an open source library of rich UI components for Angular 2+. PrimeNG is derived
    from PrimeFaces--the most popular **JavaServer Faces** (**JSF**) component suite.
    If you know PrimeFaces, you will feel at home with PrimeNG due to similar API.
    Currently, PrimeNG has 80+ visually stunning widgets that are easy to use. They
    are divided into several groups such as input and select components, buttons,
    data iteration components, panels, overlays, menus, charts, messages, multimedia,
    drag-and-drop, and miscellaneous. There are also 22+ free and premium themes.
  prefs: []
  type: TYPE_NORMAL
- en: PrimeNG fits perfectly with the mobile and desktop development because it is
    a responsive and touch optimized framework. PrimeNG showcase is a good place to
    play with the components, try them in action, study documentation, and code snippets.
    Anyway, we need a systematic approach for getting started with PrimeNG. This is
    what this book tries to convey. In this chapter, we will set up and run PrimeNG
    with SystemJS ([https://github.com/systemjs/systemjs](https://github.com/systemjs/systemjs))--universal
    module loader supporting various module formats. SystemJS is a good choice for
    learning purposes if you want to try TypeScript, Angular, PrimeNG code snippets,
    or write small applications in Plunker ([https://plnkr.co](https://plnkr.co))
    because it can load your files, transpile them (if needed) and resolve module
    dependencies on-the-fly. In the real applications, you should choose Webpack or
    Angular CLI-based setups that have more power and advanced configurations. They
    also bundle your application in order to reduce the amount of HTTP requests. Those
    setups will be discussed in the next two sections.
  prefs: []
  type: TYPE_NORMAL
- en: The SystemJS configuration for Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, you need to install Node.js and npm, which we already mentioned
    in the *TypeScript fundamentals you need to know* section. Why do we need npm?
    In HTML and SystemJS configuration, we could reference all dependencies from [https://unpkg.com](https://unpkg.com).
    But, we prefer to install all dependencies locally so that IDEs are fine with
    autocompletion. For instance, to install SystemJS, you have to run the following
    command in a console of your choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: For readers, we created a complete demo seed project where all dependencies
    are listed in the `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: The complete seed project with PrimeNG and SystemJS is available on GitHub at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-systemjs-setup](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-systemjs-setup).'
  prefs: []
  type: TYPE_NORMAL
- en: 'All dependencies in the seed project can be installed by running `npm install`
    in the project root. If you explore the `index.html` file, you can see that the
    SystemJS library is included in the `<head>` tag. After that, it becomes available
    as a global `System` object, which exposes two static methods: `System.import()`
    and `System.config()`. The first method is used to load a module. It accepts one
    argument--a module name, which can be either a file path or a logical name mapped
    to the file path. The second method is used for setting configuration. It accepts
    a configuration object as an argument. Normally, the configuration is placed within
    the `systemjs.config.js` file. Complete scripts to be included in `index.html`
    are TypeScript compiler, Polyfills, and SystemJS related files. The bootstrapping
    occurs by executing `System.import(''app'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'An excerpt from the configuration object for Angular projects is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'A brief explanation gives an overview of the most important configuration options:'
  prefs: []
  type: TYPE_NORMAL
- en: The `transpiler` option specifies a transpiler for TypeScript files. Possible
    values are `typescript`, `babel`, and `traceur`. The transpilation happens in
    browser on-the-fly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `typescriptOptions` option sets the TypeScript compiler options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `map` option creates aliases for module names. When you import a module,
    the module name is replaced by an associated value according to the mapping. In
    the configuration, all entry points for Angular files are in UMD format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `packages` option sets meta information for imported modules. For example,
    you can set the main entry point of the module. Furthermore, you can specify default
    file extensions to be able to omit them when importing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding PrimeNG dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every project using PrimeNG needs the locally installed library. You can achieve
    this by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, PrimeNG is installed in your project root under the `node_modules`
    folder as well as added in `package.json` as a dependency. Here again, you can
    skip this step if you use the seed project hosted on GitHub--just run `npm install`.
    The next step is to add two new entries to the SystemJS configuration file. For
    shorter `import` statements, it is recommended to map `primeng` to `node_modules/primeng`.
    PrimeNG components are distributed as CommonJS modules ending with `.js`. That
    means we should set the default extension too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you are able to import PrimeNG modules from `primeng/primeng`. For instance,
    write this line to import `AccordionModule` and `MenuItem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'This way of importing is not recommended in production because all other available
    components will be loaded as well. Instead of that, only import what you need
    using a specific component path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'In the demo application, we will only use `ButtonModule` and `InputTextModule`
    so that we need to import them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The demo project we want to create consists of application code and assets.
    A detailed description of every file would go beyond the scope of this book. We
    will only show the project structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4605bc24-7519-403c-a3fe-6c70f72f6293.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A typically PrimeNG application needs a theme. We would like to take the B*ootstrap*
    theme. The file `index.html` must have three CSS dependencies included within
    the `<head>` tag--the theme, the PrimeNG file, and the FontAwesome file for SVG
    icons ([http://fontawesome.io](http://fontawesome.io)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'All FontAwesome files were placed under `src/assets/icons`. Mostly PrimeNG
    components are native, but there is a list of components with third-party dependencies.
    These are explained in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Component** | **Dependency** |'
  prefs: []
  type: TYPE_TB
- en: '| Schedule | FullCalendar and Moment.js |'
  prefs: []
  type: TYPE_TB
- en: '| Editor | Quill editor |'
  prefs: []
  type: TYPE_TB
- en: '| GMap | Google Maps |'
  prefs: []
  type: TYPE_TB
- en: '| Charts | Charts.js |'
  prefs: []
  type: TYPE_TB
- en: '| Captcha | Google Recaptcha |'
  prefs: []
  type: TYPE_TB
- en: Exact links to those dependencies will be shown later in concrete examples.
    For now, we have finished our setup. Let's start our first application by running
    `npm start` in the project root.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application gets launched in browser with two PrimeNG components, as shown
    in the following screenshot. As you can see, a lot of single web resources (CSS
    and JS files) are being loaded in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bb6b4b11-9524-4017-8463-5c0a98ca5e1b.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up PrimeNG project with Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Webpack ([https://webpack.js.org](https://webpack.js.org)) is a de facto standard
    bundler for single-page applications. It analyzes dependencies between JavaScript
    modules, assets (styles, icons, and images) as well as other files in your application
    and bundles everything together. In Webpack, everything is a module . You can,
    for example, import a CSS file like a JavaScript file using `require('./myfile.css')`
    or `import './myfile.css'`.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack can figure out the right processing strategy for imported files by means
    of the file extension and associated loader. It is not always reasonable to build
    one big bundle file. Webpack has various plugins to split your code and generate
    multiple bundle files. It can also load parts of your application asynchronously
    on demand (lazy loading). All these features make it a power tool. In this section,
    we will give a high-level overview of Webpack 2 core concepts and show essential
    steps for creating a Webpack-based Angular, PrimeNG application.
  prefs: []
  type: TYPE_NORMAL
- en: The complete seed project with PrimeNG and Webpack is available on GitHub at
    [https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-webpack-setup](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-webpack-setup).
  prefs: []
  type: TYPE_NORMAL
- en: The project structure was kept the same as in the SystemJS-based setup.
  prefs: []
  type: TYPE_NORMAL
- en: Entry point and output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript and other files imported into each other are closely interwoven.
    Webpack creates a graph of all such dependencies. The starting point of this graph
    is called *entry point*. An entry point tells Webpack where to start to resolve
    all dependencies and creates a bundle. Entry points are created in the Webpack
    configuration file using the `entry` property. In the seed project on GitHub,
    we have two configuration files, one for the development mode (`webpack.dev.js`)
    and one for the production (`webpack.prod.js`) mode, each with two entry points.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the development mode, we use the main entry point for JIT compilation. The
    `main.jit.ts` file contains quite normally bootstrapping code. The second entry
    point combines files from `core-js` (Polyfills for modern ECMAScript features)
    and `zone.js` (the basis for Angular''s change detection):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'In the production mode, we use the main entry point for AOT compilation. JIT
    and AOT were mentioned in the *Angular modularity and lifecycle hooks* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The `output` property tells Webpack where to bundle your application. You can
    use placeholders such as `[name]` and `[chunkhash]` to define what the names of
    output files look like. The `[name]` placeholder will be replaced by the name
    defined in the `entry` property. The `[chunkhash]` placeholder will be replaced
    by the hash of the file content at project build time. The `chunkFilename` option
    determines the names of on-demand (lazy) loaded chunks--files loaded by `System.import()`.
    In the development mode, we don''t use `[chunkhash]` because of performance issues
    during hash generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The `[chunkhash]` placeholder is used in the production mode to achieve so
    called *long term caching*--every file gets cached in the browser and will be
    automatically invalidated and reloaded when the hash changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: A hash in the filename changes every compilation when the file content is changed.
    That means, files with hashes in names can not be included manually in the HTML
    file (`index.html`). `HtmlWebpackPlugin` ([https://github.com/jantimon/html-webpack-plugin](https://github.com/jantimon/html-webpack-plugin))
    helps us to include generated bundles with `<script>` or `<link>` tags in the
    HTML. The seed project makes use of this plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Loaders and plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Webpack only understands JavaScript files as modules. Every other file (`.css`,
    `.scss`, `.json`, `.jpg`, and many more) can be transformed into a module while
    importing. *Loaders* transform these files and add them to the dependency graph.
    Loader configuration should be done under `module.rules`. There are two main options
    in the loader configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: The `test` property with a regular expression for testing files the loader should
    be applied to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loader` or `use` property with the concrete loader name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that loaders should be registered in `package.json` so that they can be
    installed under `node_modules`. Webpack homepage has a good overview of some popular
    loaders ([https://webpack.js.org/loaders](https://webpack.js.org/loaders)). For
    TypeScript files, it is recommended to use the following sequence of loaders in
    the development mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple loaders are applied from right to left. The `angular2-template-loader`
    searches for `templateUrl` and `styleUrls` declarations and inlines HTML and styles
    inside of the `@Component` decorator. The `awesome-typescript-loader` is mostly
    for speeding up the compilation process. For AOT compilation (production mode),
    another configuration is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Webpack has not only loaders, but also *plugins* which take responsibility
    for custom tasks beyond loaders. Custom tasks could be the compression of assets,
    extraction of CSS into a separate file, generation of a source map, definition
    of constants configured at compile time, and so on. One of the helpful plugins
    used in the seed project is the `CommonsChunkPlugin`. It generates chunks of common
    modules shared between entry points and splits them into separate bundles. This
    results in page speed optimizations as the browser can quickly serve the shared
    code from cache. In the seed project, we moved Webpack''s runtime code to a separate
    `manifest` file in order to support long-term caching. This will avoid hash recreation
    for vendor files when only application files are changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, configuration of plugins is done in the `plugins` option. There
    are two plugins for production configuration yet to be mentioned here. The `AotPlugin`
    enables AOT compilation. It needs to know the path of `tsconfig.json` and the
    path with module class used for bootstrapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '`UglifyJsPlugin` is used for code minification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Adding PrimeNG, CSS, and SASS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to finish the setup. First, make sure that you have PrimeNG and
    FontAwesome dependencies in the `package.json` file. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, bundle all CSS files into one file. This task is accomplished by `ExtractTextPlugin`,
    which is needed for loaders and plugin configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: For production, you should set the filename to `"[name].[chunkhash].css"`. The
    bundled CSS file gets automatically included into `index.html` by `HtmlWebpackPlugin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We prefer not to use `styleUrls` in the components. The seed project imports
    a CSS und SASS files in one place--inside of `main.scss` file located under `src/assets/css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the tilde `~` points to the `node_modules`. More precisely the Sass
    preprocessor interprets it as the `node_modules` folder. Sass is explained in
    [Chapter 2](f3278626-cfa5-4c6f-8ff2-97df3a45778f.xhtml), *Theming Concepts and
    Layouts*. The `main.scss` file should be imported in the entry points `main.jit.ts`
    and `main.aot.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Webpack takes care of the rest. There are more goodies from Webpack--a development
    server with live reloading `webpack-dev-server` ([https://webpack.js.org/configuration/dev-server](https://webpack.js.org/configuration/dev-server)).
    It detects changes made to files and recompiles automatically. You can start it
    with `npm start` or `npm run start:prod`. These commands represent npm scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: When running `webpack-dev-server`, the compiled output is served from memory.
    This means, the application being served is not located on disk in the `dist`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: That's all. More configuration options for unit and end-to-end testing will
    be added in [Chapter 10](b5fd2c81-a93b-4c32-a2a6-4978019f283a.xhtml), *Creating
    Robust Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up PrimeNG project with Angular CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular CLI ([https://cli.angular.io](https://cli.angular.io)) is a comfortable
    tool to create, run, and test Angular applications out of the box. It generates
    the code in no time. We will describe some useful commands and show you how to
    integrate PrimeNG with Angular CLI. First, the tool should be installed globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'When it is installed, every command can be executed in the console with prepended
    `ng`. For instance, to create a new project, run `ng new [projectname] [options]`.
    Let''s create one. Navigate to a directory that will be the parent directory of
    your project and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: This command will create an Angular 4 project within the folder `primeng-angularcli-setup`.
    The option `--style` sets a CSS preprocessor. Here, we want to use SASS files
    and need a Sass preprocessor. The preprocessor compiles SASS files whenever we
    make changes. You don't need to set a preprocessor if you only have CSS files.
  prefs: []
  type: TYPE_NORMAL
- en: The complete preconfigured seed project with PrimeNG and Angular CLI is available
    on GitHub at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-angularcli-setup](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-angularcli-setup).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The created project has the following top directories and files:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Directory/file** | **Short description** |'
  prefs: []
  type: TYPE_TB
- en: '| `e2e` | Folder with e2e tests (`.e2e-spec.ts` files) and page objects (`.po.ts`
    files). |'
  prefs: []
  type: TYPE_TB
- en: '| `src` | Source code folder where the application code should be written.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `.angular-cli.json` | Set up configuration file. PrimeNG dependencies can
    be listed here. |'
  prefs: []
  type: TYPE_TB
- en: '| `karma.conf.js` | Karma configuration file for unit testing. |'
  prefs: []
  type: TYPE_TB
- en: '| `protractor.conf.js` | Protractor configuration file for e2e testing. |'
  prefs: []
  type: TYPE_TB
- en: '| `package.json` | Standard file for package management of npm-based projects.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `tsconfig.json` | Settings for TypeScript compiler. |'
  prefs: []
  type: TYPE_TB
- en: '| `tslint.json` | Settings for TSLint. |'
  prefs: []
  type: TYPE_TB
- en: 'You can now start the application by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will run a local server at `http://localhost:4200` by default.
    You will see the text app works! in the browser. The `ng serve` command uses `webpack-dev-server`
    internally. The server is running in the watch mode. It refreshes the page automatically
    when any changes occur. There are a lot of configuration options. You can, for
    example, set a custom port by the `--port` option. Refer to the official documentation
    for more details at [https://github.com/angular/angular-cli/wiki](https://github.com/angular/angular-cli/wiki).
    To compile the application into an output directory, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: The build artifacts will be stored in the `dist` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The `--prod` option in `ng build` or `ng serve` will minify the files and remove
    unused (dead) code. The `--aot` option will use AOT compilation and produce even
    more smaller and optimized artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: To run unit and e2e tests, execute `ng test` and `ng e2e` commands, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Generating scaffolding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular CLI allows us to generate components, services, directives, routes,
    pipes, and many more with `ng generate`. Here is how you would generate a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if we run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Four files will be generated and one updated. The produced output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The new component is registered in `app.module.ts` automatically. The generation
    of other scaffoldings is identical. For example, to generate a service, run this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: There are plenty of useful options. You can set, for example, `--spec=false`
    to skip test file generation.
  prefs: []
  type: TYPE_NORMAL
- en: Adding PrimeNG dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Integrating PrimeNG with Angular CLI is straightforward. First, install and
    save the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, edit the `.angular-cli.json` file and add three more CSS files to the
    `styles` section. These are the same files as in the SystemJS- and Webpack-based
    setups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can import desired PrimeNG modules. Refer to the *Running PrimeNG with
    SystemJS* section to see how to import PrimeNG modules. In the seed project on
    GitHub, we have imported the `MessagesModule` and put some demo code into `message.component.html`
    and `message.component.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/030e2299-dbdf-4a52-a096-d608b39d0077.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you got an overview of TypeScript and Angular concepts
    you need to understand for the upcoming chapters. TypeScript introduces types
    which help to recognize errors at development time. There are primitive types,
    types known from object-oriented programming languages, custom types, and so on.
    By default, TypeScript compiler always emits an JavaScript code, even in the presence
    of type errors. In this way, you can quickly migrate any existing JavaScript code
    to TypeScript just by renaming `.js` file to `.ts` without having to fix all compilation
    errors at once.
  prefs: []
  type: TYPE_NORMAL
- en: A typically Angular application is written in TypeScript. Angular provides a
    component-based approach which decouples your UI logic from the application (business)
    logic. It implements a powerful dependency injection system that makes reusing
    services a breeze. Dependency injection also increases the code testability because
    you can easily mock your business logic. An Angular application consists of hierarchical
    components, which communicate with each other in various ways such as `@Input`,
    `@Output` properties, shared services, local variables, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Angular is a modular framework. Module classes annotated with `@NgModule` provide
    a great way to keep the code clean and organized. Angular is flexible--lifecycle
    hooks allow us to perform custom logic at several stages in the in the component's
    life. Last but not least, it is fast due to smart change detection algorithm.
    Angular doesn't offer any rich UI components. It is just a platform for developing
    single page applications. You need a third-party library to create rich UI interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'PrimeNG is a collection of such rich UI components for Angular 2+. In comparison
    with competitors, PrimeNG was created for enterprise applications and provides
    80+ components. Adding PrimeNG dependencies is easy done. You only need to add
    PrimeNG and FontAwesome dependencies to the `package.json` file, and three CSS
    files: `primeng.min.css`, `font-awesome.min.css`, and `theme.css` for any theme
    you like. The next chapter will cover the theming concept in detail.'
  prefs: []
  type: TYPE_NORMAL
- en: An Angular and PrimeNG application consists of ES6 (ECMAScript 2015) modules.
    Modules can be exported and imported. All modules in an application build a dependency
    graph. Therefore, you need a specific tool to resolve such modules starting at
    some entry point(s) and to output a bundle. There are some tools doing this and
    other tasks such as loading modules on demand, and similar.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, SystemJS and Webpack loaders were discussed. SystemJS is only
    recommended for demo applications for the purpose of learning. Webpack-based builds
    are more sophisticated. Webpack has a combination of loaders for every file type
    and plugins. Plugins include useful behaviors into the Webpack build process,
    for example, creating common chunks, minification of web resources, copying files
    and directories, creating SVG sprites, and more. To quickly start the development
    in TypeScript and Angular, generate your projects with Angular CLI. This is a
    scaffolding tool, which makes it easy to create an application that works out
    of the box.
  prefs: []
  type: TYPE_NORMAL
