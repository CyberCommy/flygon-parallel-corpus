- en: Getting Started with Angular and PrimeNG
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Angular和PrimeNG
- en: This book presupposes some basic knowledge of TypeScript and Angular 2\. Anyway,
    we would like to give the readers an overview of the most important TypeScript
    and Angular key concepts used in this book. We will summarize TypeScript and Angular
    features and present them in understandable, simple, but deeply explained portions.
    At the time of writing the book, the current TypeScript and Angular Versions are
    2.3.x and 4.2.x, respectively. Readers will also meet the PrimeNG UI library for
    the first time and gain experience with project setups in three various ways.
    At the end of this chapter, readers will be able to run the first Angular- and
    PrimeNG-based web application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假定读者具有一些TypeScript和Angular 2的基本知识。无论如何，我们希望向读者概述本书中使用的最重要的TypeScript和Angular关键概念。我们将总结TypeScript和Angular的特性，并以可理解、简单但深入解释的方式呈现它们。撰写本书时，当前的TypeScript和Angular版本分别为2.3.x和4.2.x。读者还将首次接触PrimeNG
    UI库，并通过三种不同的方式获得项目设置经验。在本章结束时，读者将能够运行第一个基于Angular和PrimeNG的Web应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: TypeScript fundamentals
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript基础知识
- en: Advanced types, decorators, and compiler options
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级类型、装饰器和编译器选项
- en: Angular cheat sheet - overview of key concepts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular速查表-关键概念概述
- en: Angular modularity and lifecycle hooks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular的模块化和生命周期钩子
- en: Running PrimeNG with SystemJS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SystemJS运行PrimeNG
- en: Setting up PrimeNG project with Webpack
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Webpack设置PrimeNG项目
- en: Setting up PrimeNG project with Angular CLI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular CLI设置PrimeNG项目
- en: TypeScript fundamentals
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript基础知识
- en: Angular 2 and higher is built with features of ECMAScript 2015/2016 and TypeScript.
    The new ECMAScript standards target evergreen browsers and helps to write more
    powerful, clean, and concise code. You can also use these features in any other
    less modern browsers with Polyfills such as `core-js` ([https://github.com/zloirock/core-js](https://github.com/zloirock/core-js)).
    But, why do we need to use TypeScript?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2及更高版本使用了ECMAScript 2015/2016和TypeScript的功能。新的ECMAScript标准针对现代浏览器，并有助于编写更强大、干净和简洁的代码。您还可以在任何其他不太现代的浏览器中使用这些功能，例如`core-js`（[https://github.com/zloirock/core-js](https://github.com/zloirock/core-js)）等Polyfills。但是，为什么我们需要使用TypeScript呢？
- en: 'TypeScript ([http://www.typescriptlang.org](http://www.typescriptlang.org))
    is a typed language and a super set of JavaScript developed by Microsoft. One
    can say that TypeScript is an advanced JavaScript with optional static typing.
    TypeScript code is not processed by browsers, it has to be translated into JavaScript
    by means of a TypeScript compiler. This translation is called *compilation* or
    *transpilation*. The TypeScript compiler transpiles `.ts` files into `.js` files.
    The main advantages of TypeScript are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript（[http://www.typescriptlang.org](http://www.typescriptlang.org)）是由微软开发的一种带类型的语言，也是JavaScript的超集。可以说TypeScript是一种带有可选静态类型的高级JavaScript。TypeScript代码不会被浏览器处理，而是需要通过TypeScript编译器将其转换为JavaScript。这种转换被称为*编译*或*转译*。TypeScript编译器将`.ts`文件转译为`.js`文件。TypeScript的主要优点如下：
- en: Types help you find and fix a lot of errors during development time. That means,
    you have less errors at runtime.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型有助于在开发过程中找到并修复许多错误。这意味着在运行时会有更少的错误。
- en: Many modern ECMAScript features are supported out of the box. More features
    are expected according to the roadmap ([https://github.com/Microsoft/TypeScript/wiki/Roadmap](https://github.com/Microsoft/TypeScript/wiki/Roadmap)).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多现代ECMAScript功能都被原生支持。根据路线图，预计会有更多功能被支持（[https://github.com/Microsoft/TypeScript/wiki/Roadmap](https://github.com/Microsoft/TypeScript/wiki/Roadmap)）。
- en: Great tooling and IDE support with IntelliSense makes the coding a pleasure.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出色的工具和IDE支持使编码成为一种愉悦。
- en: It is easier to maintain and refactor a TypeScript application than one written
    in untyped JavaScript.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护和重构TypeScript应用比使用无类型的JavaScript编写的应用更容易。
- en: Developers feel comfortable with TypeScript due to object-oriented programming
    patterns, such as interfaces, classes, enums, generics, and so on.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员喜欢TypeScript，因为它支持面向对象的编程模式，如接口、类、枚举、泛型等。
- en: Last but not least, Angular 2+ and PrimeNG are written in TypeScript.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，Angular 2+和PrimeNG都是用TypeScript编写的。
- en: 'It is also important to keep the following points in mind:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住以下几点很重要：
- en: The Typescript Language Specification says, *<q>every JavaScript program is
    also a TypeScript program</q>*. Hence, a migration from JavaScript to TypeScript
    code is easily done.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript语言规范表示，*<q>每个JavaScript程序也是一个TypeScript程序</q>*。因此，从JavaScript迁移到TypeScript代码很容易。
- en: TypeScript compiler emits output even when any errors are reported. In the next
    section, *Advanced types, decorators, and compiler options*, we will see how we
    can forbid emitting JavaScript on errors.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使报告了任何错误，TypeScript编译器也会生成输出。在下一节*高级类型、装饰器和编译器选项*中，我们将看到如何在出现错误时禁止生成JavaScript。
- en: 'What is the best way to learn the TypeScript language? There is an official
    handbook on the TypeScript''s homepage, which is aligned with the last released
    version. Hands-on learning is possible with the TypeScript playground ([http://www.typescriptlang.org/play](http://www.typescriptlang.org/play)),
    which compiles on-the-fly TypeScript code entered in a browser and shows it side
    by side with the generated JavaScript code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 学习TypeScript语言的最佳方法是什么？TypeScript官方主页上有一本官方手册，与最新发布的版本保持一致。可以通过TypeScript playground（[http://www.typescriptlang.org/play](http://www.typescriptlang.org/play)）进行实践学习，该工具可以即时编译在浏览器中输入的TypeScript代码，并将其与生成的JavaScript代码并排显示：
- en: '![](assets/beff0870-ae1c-47bc-9a63-8c5e9b71e2e4.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/beff0870-ae1c-47bc-9a63-8c5e9b71e2e4.png)'
- en: 'Alternatively, you can install the TypeScript globally by typing the following
    command in the command line:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在命令行中输入以下命令全局安装TypeScript。
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Global installation means, the TypeScript compiler `tsc` can be reached and
    used in any of your projects. Installed Node.js and npm are presupposed. Node.js
    is the JavaScript runtime environment ([https://nodejs.org](https://nodejs.org)).
    npm is the package manager. It is shipped with Node.js, but can be installed separately
    as well. After that, you can transpile one or more `.ts` files into `.js` files
    by typing the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 全局安装意味着TypeScript编译器`tsc`可以在任何项目中被访问和使用。需要安装Node.js和npm。Node.js是JavaScript运行时环境（[https://nodejs.org](https://nodejs.org)）。npm是包管理器。它随Node.js一起发布，但也可以单独安装。之后，您可以通过输入以下命令将一个或多个`.ts`文件转译为`.js`文件：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will result in two files, `some.js` and `another.js`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成两个文件，`some.js`和`another.js`。
- en: Basic types
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本类型
- en: TypeScript exposes the basic types, as well as a couple of extra types. Let's
    explore the type system with these examples.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript公开了基本类型，以及一些额外的类型。让我们通过这些例子来探索类型系统。
- en: '`Boolean`: The type is a primitive JavaScript boolean:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boolean`：该类型是原始的JavaScript布尔值：'
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`Number`: The type is a primitive JavaScript number:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number`：该类型是原始的JavaScript数字：'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`String`: The type is a primitive JavaScript string:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`：该类型是原始的JavaScript字符串：'
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Array`: The type is an array of value. There are two equivalent notations:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array`：该类型是一个值的数组。有两种等价的表示法：'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`Tuple`: The type represents a heterogeneous array of values. `Tuple` enables
    storing multiple fields of different types:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tuple`：该类型表示值的异构数组。`Tuple`可以存储不同类型的多个字段：'
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`Any`: The type is *anything*. It is useful when you need to describe the type
    of variables that you do not know at the time of writing your application. You
    can assign a value of arbitrary type to a variable of type `any`. A value of type
    `any` in turn can be assigned to a variable of arbitrary type:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Any`：该类型是*任何*类型。在编写应用程序时需要描述不知道的变量类型时非常有用。您可以将任意类型的值赋给`any`类型的变量。反过来，`any`类型的值可以赋给任意类型的变量：'
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Void`: The type represents the absence of having an `any` type. This type
    is normally used as the return type of functions:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Void`：该类型表示没有`any`类型。这种类型通常用作函数的返回类型：'
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`Nullable`: These types denote two specific types, `null` and `undefined` that
    are valid values of every type. That means, they can be assigned to any other
    type. It is not always desired. TypeScript offers a possibility to change this
    default behavior by setting the compiler options `strictNullChecks` to `true`.
    Now, you have to include the `Nullable` types explicitly using a union type (explained
    later on), otherwise, you will get an error:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nullable`：这些类型表示两种特定类型，`null`和`undefined`，它们是每种类型的有效值。这意味着它们可以分配给任何其他类型。这并不总是理想的。TypeScript提供了一种通过将编译器选项`strictNullChecks`设置为`true`来更改此默认行为的可能性。现在，您必须显式使用联合类型（稍后解释）包含`Nullable`类型，否则将会出错：'
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Sometimes, you would like to tell compiler that you know the type better than
    it does and it should trust you. For instance, imagine a situation where you receive
    data over HTTP and know exactly the structure of the received data. The compiler
    doesn't know such structure of course. In this case, you want to turn off the
    type checking when assigning the data to a variable. It is possible with so called
    **type assertions**. A type assertion is like a type cast in other languages,
    but without the checking of data. You can do that either with *angle bracket*
    or the `as` syntax.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望告诉编译器，您比它更了解类型，它应该信任您。例如，想象一种情况，您通过HTTP接收数据，并且确切地知道接收到的数据的结构。当然，编译器不知道这样的结构。在这种情况下，您希望在将数据分配给变量时关闭类型检查。这可以通过所谓的**类型断言**来实现。类型断言类似于其他语言中的类型转换，但不检查数据。您可以使用*尖括号*或`as`语法来实现。
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Interfaces, classes, and enums
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口、类和枚举
- en: 'An *interface* is a way to take a particular structure/shape and give it a
    name so that we can reference it later as a type. It defines a contract within
    our code. Interfaces begin with the keyword `interface`. Let''s take an example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*接口*是一种将特定结构/形状命名的方式，以便我们以后可以引用它作为一种类型。它在我们的代码中定义了一个合同。接口以关键字`interface`开头。让我们举个例子：'
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The specified interface `Person` has the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 指定的接口`Person`具有以下内容：
- en: The `name` property of type `string`.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型为`string`的`name`属性。
- en: The optional property `children` of type `number`. Optional properties are denoted
    by a question mark and can be omitted.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型为`number`的可选属性`children`。可选属性由问号表示，可以省略。
- en: The `isMarried` method that returns a `boolean` value.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回`boolean`值的`isMarried`方法。
- en: Anonymous (unnamed) method that returns nothing.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回空值的匿名（未命名）方法。
- en: 'Typescript allows you to use the syntax `[index: type]` to specify a `string`
    or `number` type based collection of key/value pairs. Interfaces perfectly fit
    such data structures. For example, consider the following syntax:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 'Typescript允许您使用`[index: type]`语法来指定基于`string`或`number`类型的键/值对集合。接口非常适合这样的数据结构。例如，考虑以下语法：'
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: An interface is only used by TypeScript compiler at compile time, and is then
    removed. Interfaces don't end up in the final JavaScript output. General, no types
    appear in the output. You can see that in the TypeScript playground mentioned
    earlier.![](assets/5f81e48d-5e0e-447b-8782-272b7fb9a4aa.png)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接口仅在编译时由TypeScript编译器使用，然后被移除。接口不会出现在最终的JavaScript输出中。通常，在输出中不会出现类型。您可以在前面提到的TypeScript
    playground中看到这一点！[](assets/5f81e48d-5e0e-447b-8782-272b7fb9a4aa.png)
- en: 'Beside interfaces, there are *classes* that describe objects. A class acts
    as a template for instantiating specific objects. The syntax for TypeScript''s
    classes is almost identical to that of native classes in ECMAScript 2015 with
    some handy additions. In TypeScript, you can use `public`, `private`, `protected`,
    and `readonly` access modifiers:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了接口，还有描述对象的*类*。类充当实例化特定对象的模板。TypeScript类的语法几乎与ECMAScript 2015中的原生类完全相同，并带有一些方便的附加功能。在TypeScript中，您可以使用`public`、`private`、`protected`和`readonly`访问修饰符：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Members with omitted modifiers are `public` by default. If a property or method
    is declared with the `static` keyword, there is no need to create an instance
    to access them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 省略修饰符的成员默认为`public`。如果使用`static`关键字声明属性或方法，则无需创建实例即可访问它们。
- en: 'A class can be abstract, that means, it may not be instantiated directly. Abstract
    classes begin with the keyword `abstract`. A class can implement an interface
    as well as extend another class. We can achieve that using the `implements` and
    `extends` keywords, respectively. If a class implements some interface, it must
    adopt all properties from this interface; otherwise, you will get an error about
    missing properties:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以是抽象的，这意味着它可能不能直接实例化。抽象类以关键字`abstract`开头。类可以实现一个接口，也可以扩展另一个类。我们可以使用`implements`和`extends`关键字分别实现这一点。如果一个类实现了某个接口，它必须采用该接口的所有属性；否则，您将收到有关缺少属性的错误：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Derived classes that contain constructor functions must call `super()`. The
    `super()` call executes the constructor function on the base class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 包含构造函数的派生类必须调用`super()`。`super()`调用在基类上执行构造函数。
- en: 'It is possible to declare a `constructor` parameter with a modifier. As result,
    a member will be created and initialized in one place:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用修饰符声明`constructor`参数。结果，一个成员将在一个地方被创建和初始化：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This shortened syntax is often used in Angular when we inject services into
    components. Angular's services are normally declared in the component's constructor
    with the `private` modifier.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，当我们将服务注入到组件中时，经常会使用这种简化的语法。Angular的服务通常在组件的构造函数中使用`private`修饰符声明。
- en: 'The last basic type to be mentioned here is *enum*. Enums allow us to define
    a set of named constants. Enum members have numeric values associated with them
    (started with 0):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要提到的最后一个基本类型是*枚举*。枚举允许我们定义一组命名常量。枚举成员与数字值相关联（从0开始）：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Functions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'Parameters and return values in the function signature can be typed too. Types
    protects you against JavaScript errors during function execution because the compiler
    warns you punctually at build time when the wrong types are used:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 函数签名中的参数和返回值也可以进行类型化。类型保护您免受JavaScript错误的影响，因为编译器会在构建时及时警告您使用错误类型：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Function type* is a way to declare the type of a function. To explicitly declare
    a function type, you should use the keywords `var` or `let`, a variable name,
    a colon, a parameter list, a fat arrow `=>`, and the function''s return type:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数类型*是声明函数类型的一种方式。要显式声明函数类型，您应该使用关键字`var`或`let`，一个变量名，一个冒号，一个参数列表，一个fat箭头`=>`，和函数的返回类型：'
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, you must provide an implementation of this declaration:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您必须提供此声明的实现：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This technique is especially useful for callbacks. Imagine a filter function
    which filters arrays by some criterion. An exact criterion can be encapsulated
    in the passed in callback function that acts as predicate:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术对于回调特别有用。想象一个根据某些标准过滤数组的过滤函数。一个确切的标准可以封装在传入的回调函数中，作为谓词：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A possible function call with a specific callback could appear as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的函数调用与特定回调可以如下所示：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In TypeScript, every function parameter is assumed to be required. There are
    two ways to mark a parameter as optional (optional parameters can be omitted when
    calling the function).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，假定每个函数参数都是必需的。有两种方法可以将参数标记为可选的（可选参数在调用函数时可以省略）。
- en: 'Use a question mark after the parameter name:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在参数名称后使用问号：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Use the parameter''s default value (ECMAScript 2015 feature), which gets applied
    when no value is provided:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参数的默认值（ECMAScript 2015功能），当没有提供值时会应用默认值：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, you are able to call this function with just one value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以只使用一个值调用此函数。
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Generics
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: 'In TypeScript, you can define generic functions, interfaces, and classes like
    in other programming languages. A generic function has type parameters listed
    in angle brackets:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，您可以像其他编程语言一样定义通用函数、接口和类。通用函数在尖括号中列出类型参数：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Such generic functions can be defined with generic interfaces as well. The
    function signature for `reverseAndMerge` is compatible with the following generic
    interface:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的通用函数也可以使用通用接口来定义。`reverseAndMerge`的函数签名与以下通用接口兼容：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that the generic type parameter list in angle brackets follows the name
    of the function and interface. This is also true for classes:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尖括号中的通用类型参数列表跟随函数和接口的名称。对于类也是如此：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Modules
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: 'ECMAScript 2015 has introduced built-in modules. The features of modules are
    as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 2015引入了内置模块。模块的特性如下：
- en: Each module is defined in its own file.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个模块都在自己的文件中定义。
- en: Functions or variables defined in a module are not visible outside unless you
    explicitly export them.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块中定义的函数或变量在外部是不可见的，除非你明确导出它们。
- en: You can place the `export` keyword in front of any variable, function, or class
    declaration to export it from the module.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在任何变量、函数或类声明前放置`export`关键字来从模块中导出它。
- en: You can use the `import` keyword to consume the exported variable, function,
    or class declaration.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`import`关键字来使用导出的变量、函数或类声明。
- en: Modules are singletons. Only a single instance of a module exists, even if it
    was imported multiple times.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块是单例的。即使多次导入，模块的实例也只有一个。
- en: 'Some exporting possibilities are listed here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了一些导出的可能性：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can declare a variable, function, or class and export it later. You can
    also use the `as` keyword to rename exports. A new name is the name used for importing:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以声明一个变量、函数或类，并稍后导出它。您还可以使用`as`关键字来重命名导出。新名称是用于导入的名称：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once you have a module with exports, you can access its functionality in another
    module using the `import` keyword:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了带有导出的模块，您可以使用`import`关键字在另一个模块中访问其功能：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There is a special case that allows you to import the entire module as a single
    object. All exported variables, functions, and classes are available on that object
    as properties:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊情况允许您将整个模块作为单个对象导入。所有导出的变量、函数和类都作为该对象的属性可用：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Imports can be renamed with the `as` keyword and used under the new name:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 导入可以使用`as`关键字重命名，并在新名称下使用：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Advanced types, decorators, and compiler options
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级类型、装饰器和编译器选项
- en: TypeScript has more types and advanced constructs such as decorators and type
    definition files. This chapter gives an overview on advanced topics and shows
    how to customize the compiler configuration.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript具有更多类型和高级构造，例如装饰器和类型定义文件。本章概述了高级主题，并展示了如何自定义编译器配置。
- en: Union types and type aliases
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合类型和类型别名
- en: 'A *union type* describes a value that can be one of many types. The vertical
    bar `|` is used as separator for each type the value can have. For instance, `number
    | string` is the type of a value that can be a number or string. For such values,
    we can only access members that are common to all types in the union. The following
    code works because the `length` property exists on both strings and arrays:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*联合类型*描述了可以是多种类型之一的值。竖线`|`用作值可以具有的每种类型的分隔符。例如，`number | string`是一个可以是数字或字符串的值的类型。对于这样的值，我们只能访问联合中所有类型的公共成员。以下代码有效，因为`length`属性存在于字符串和数组中：'
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The next code snippet gives an error because the `model` property does not
    exist on the `Bike` type:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码片段出现错误，因为`model`属性在`Bike`类型上不存在：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Type alias* is used as alternative name for the existing type or combination
    of types. It doesn''t create a new type. A type alias begins with the `type` keyword.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型别名*用作现有类型或类型组合的替代名称。它不创建新类型。类型别名以`type`关键字开头。'
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Type aliases can be used for better code readability, for example, in the function
    parameter list.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名可用于提高代码可读性，例如，在函数参数列表中。
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Type aliases can also be generic and make tricky types, which can not be made
    with interfaces.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名也可以是通用的，并创建棘手的类型，这些类型无法使用接口创建。
- en: Type inference
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断
- en: '*Type inference* is used when the type is not provided explicitly. For instance
    in the following statements:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型推断*在类型没有明确提供时使用。例如在以下语句中：'
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'These don''t have explicit type annotations. TypeScript can infer that `x`
    is a string and `y` is a number. As you see, the type can be omitted if the compiler
    is able to infer it. TypeScript improves the type inference continuously. It tries
    to guess a best common type when elements of several types are present in an array.
    The type of the following variable `animal`, where `Sheepdog extends Dog`, is
    `Dog[]`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些没有显式类型注释。TypeScript可以推断出`x`是一个字符串，`y`是一个数字。正如你所看到的，如果编译器能够推断出类型，那么类型可以被省略。TypeScript不断改进类型推断。当数组中存在多种类型的元素时，它会尝试猜测最佳公共类型。变量`animal`的类型是`Dog[]`，其中`Sheepdog
    extends Dog`：
- en: '[PRE38]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The best common type of the next array is `(Dog | Fish)[]` because the class
    `Fish` doesn''t extend to any other class:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个数组的最佳公共类型是`(Dog | Fish)[]`，因为类`Fish`没有扩展到任何其他类：
- en: '[PRE39]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Type inference is also used for functions. In the next example, the compiler
    can figure out the types of the function''s parameter (`string`) and the return
    value (`boolean`):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断也用于函数。在下一个示例中，编译器可以推断出函数的参数类型（`string`）和返回值类型（`boolean`）：
- en: '[PRE40]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Decorators
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: '*Decorators* were proposed in ECMAScript 2016 ([https://github.com/wycats/javascript-decorators](https://github.com/wycats/javascript-decorators)).
    They are similar to Java annotations--they also add metadata to class declaration,
    method, property, and the function''s parameter, but they are more powerful. They
    add new behaviors to their targets. With decorators, we can run arbitrary code
    before, after, or around the target execution, like in aspect-oriented programming,
    or even replace the target with a new definition. In TypeScript, you can decorate
    constructors, methods, properties, and parameters. Every decorator begins with
    the `@` character followed by the name of the decorator.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*装饰器*在ECMAScript 2016中提出（[https://github.com/wycats/javascript-decorators](https://github.com/wycats/javascript-decorators)）。它们类似于Java注解--它们还向类声明、方法、属性和函数的参数添加元数据，但它们更加强大。它们为它们的目标添加了新的行为。使用装饰器，我们可以在目标执行之前、之后或周围运行任意代码，就像面向方面的编程一样，甚至用新定义替换目标。在TypeScript中，您可以装饰构造函数、方法、属性和参数。每个装饰器都以`@`字符开头，后面跟着装饰器的名称。'
- en: 'How does it work under the hood that takes its target as argument? Let''s implement
    a classic example with a logging functionality. We would like to implement a method
    decorator `@log`. A method decorator accepts three arguments: an instance of the
    class on which the method is defined, a key for the property, and the property
    descriptor ([https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何在底层工作的，以其目标作为参数？让我们实现一个具有日志功能的经典示例。我们想要实现一个方法装饰器`@log`。方法装饰器接受三个参数：定义方法的类的实例，属性的键和属性描述符（[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)）。
- en: 'If the method decorator returns a value, it will be used as a new property
    descriptor for this method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法装饰器返回一个值，它将被用作此方法的新属性描述符：
- en: '[PRE41]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This decorator logs received arguments and return values. Decorators can be
    composed and customized with parameters too. You can write the following, for
    instance:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器记录接收到的参数和返回值。装饰器也可以组合和定制参数。例如，您可以编写以下内容：
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Angular offers different types of decorators that are used for dependency injection
    or adding metadata information at compilation time:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了不同类型的装饰器，用于依赖注入或在编译时添加元数据信息：
- en: Class decorators such as `@NgModule`, `@Component`, and `@Injectable`
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类装饰器，如`@NgModule`，`@Component`和`@Injectable`
- en: Property decorators such as `@Input` and `@Output`
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性装饰器，如`@Input`和`@Output`
- en: Method decorators such as `@HostListener`
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法装饰器，如`@HostListener`
- en: Parameter decorators such as `@Inject`
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数装饰器，如`@Inject`
- en: 'TypeScript compiler is able to emit some design-time type metadata for decorators.
    To access this information, we have to install a Polyfill called `reflect-metadata`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器能够为装饰器发出一些设计时类型元数据。要访问这些信息，我们必须安装一个名为`reflect-metadata`的Polyfill：
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we can access, for example, the type of the property (`key`) on the `target`
    object as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以访问，例如，在`target`对象上的属性（`key`）的类型如下：
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Refer to the official TypeScript documentation to learn more about decorators
    and reflect metadata API ([http://www.typescriptlang.org/docs/handbook/decorators.html](http://www.typescriptlang.org/docs/handbook/decorators.html)).In
    TypeScript, Angular applications, decorators are enabled by setting the compiler
    options `emitDecoratorMetadata` and `experimentalDecorators` to `true` (compiler
    options are described later on).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Type definition files
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript programs written in native JavaScript don't have any type information.
    If you add a JavaScript library such as jQuery or Lodash to your TypeScript-based
    application and try to use it, the TypeScript compiler can find any type information
    and warn you with compilation errors. Compile-time safety, type checking, and
    context-aware code completion get lost. That is where *type definition files*
    come into play.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Type definition files provide type information for JavaScript code that is
    not statically typed. Type definition files ends with `.d.ts` and only contain
    definitions which are not emitted by TypeScript. The `declare` keyword is used
    to add types to JavaScript code that exists somewhere. Let''s take an example.
    TypeScript is shipped with the `lib.d.ts` library describing ECMAScript API. This
    type definition file is used automatically by the TypeScript compiler. The following
    declaration is defined in this file without implementation details:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, when you use the `parseInt` function in your code, the TypeScript compiler
    ensures that your code uses the correct types and IDEs show context-sensitive
    hints when you''re writing code. Type definition files can be installed as dependencies
    under the `node_modules/@types` directory by typing the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'A concrete example for jQuery library is:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In Angular, all type definition files are bundled with Angular npm packages
    and located under `node_modules/@angular`. There is no need to install such files
    separately like we did for jQuery. TypeScript finds them automatically.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, you have the compile target ES5 (generated JavaScript version,
    which is widely supported), but want to use some ES6 (ECMAScript 2015) features
    by adding Polyfills. In this case, you must tell the compiler that it should look
    for extended definitions in the `lib.es6.d.ts` or `lib.es2015.d.ts` file. This
    can be achieved in compiler options by setting the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Compiler options
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typically, the first step in a new TypeScript project is to add in a `tsconfig.json`
    file. This file defines the project and compiler settings, for instance, files
    and libraries to be included in the compilation, output structure, module code
    generation, and so on. A typical configuration in `tsconfig.json` for Angular
    2+ projects looks like the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在新的 TypeScript 项目中的第一步是添加一个 `tsconfig.json` 文件。该文件定义了项目和编译器的设置，例如要包含在编译中的文件和库，输出结构，模块代码生成等。`tsconfig.json`
    中用于 Angular 2+ 项目的典型配置如下：
- en: '[PRE49]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The listed compiler settings are described as follows. A full list of all options
    is available at the TypeScript documentation page ([https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html)).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所列的编译器设置如下所述。所有选项的完整列表可在 TypeScript 文档页面上找到（[https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html)）。
- en: '| **Option** | **Type** | **Default** | **Description** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **选项** | **类型** | **默认** | **描述** |'
- en: '| `target` | `string` | `ES3` | This specifies ECMAScript target version: `ES3`,
    `ES5`, `ES2015`, `ES2016`, and `ES2017`. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `target` | `string` | `ES3` | 这指定了 ECMAScript 的目标版本：`ES3`, `ES5`, `ES2015`,
    `ES2016`, 和 `ES2017`。 |'
- en: '| `module` | `string` | `ES6` if target is "ES6" and `CommonJS` otherwise |
    This specifies the format of module code generation: `None`, `CommonJS`, `AMD`,
    `System`, `UMD`, `ES6`, or `ES2015`. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `module` | `string` | `ES6` if target is "ES6" and `CommonJS` otherwise |
    这指定了模块代码生成的格式：`None`, `CommonJS`, `AMD`, `System`, `UMD`, `ES6`, 或 `ES2015`。 |'
- en: '| `moduleResolution` | `string` | `Classic` if module is "AMD," `System`, `ES6`,
    and `Node` otherwise | This determines how modules get resolved. Either `Node`
    for Node.js style resolution or `Classic`. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `moduleResolution` | `string` | `Classic` if module is "AMD," `System`, `ES6`,
    and `Node` otherwise | 这确定了模块的解析方式。要么是 `Node` 用于 Node.js 风格的解析，要么是 `Classic`。'
- en: '| `noImplicitAny` | `boolean` | `false` | This raises errors on expressions
    and declarations with an implied `any` type. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `noImplicitAny` | `boolean` | `false` | 这会在具有隐含的 `any` 类型的表达式和声明上引发错误。 |'
- en: '| `sourceMap` | `boolean` | `false` | This generates the corresponding `.map`
    file. This is useful if you want to debug original files. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `sourceMap` | `boolean` | `false` | 这会生成相应的 `.map` 文件。如果你想要调试原始文件，这是很有用的。'
- en: '| `emitDecoratorMetadata` | `boolean` | `false` | This emits design type metadata
    for decorated declarations in source. You have to set this value to `true` if
    you want to develop web applications with Angular. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `emitDecoratorMetadata` | `boolean` | `false` | 这会为源代码中装饰的声明发出设计类型元数据。如果你想要开发带有
    Angular 的 Web 应用程序，你必须将这个值设置为 `true`。'
- en: '| `experimentalDecorators` | `boolean` | `false` | This enables experimental
    support for ECMAScript decorators. You have to set this value to `true` if you
    want to develop web applications with Angular. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `experimentalDecorators` | `boolean` | `false` | 这启用了对 ECMAScript 装饰器的实验性支持。如果你想要开发带有
    Angular 的 Web 应用程序，你必须将这个值设置为 `true`。'
- en: '| `outDir` | `string` | - | This is the output directory for compiled files.
    |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `outDir` | `string` | - | 这是编译文件的输出目录。 |'
- en: '| `lib` | `string[]` | Refer to the documentation for more information. | This
    is the list of library files to be included in the compilation. Refer to the documentation
    for more information. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `lib` | `string[]` | 更多信息请参考文档。 | 这是要包含在编译中的库文件列表。更多信息请参考文档。 |'
- en: '| `types` | `string[]` | - | This is the list of names of type definitions
    to include. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `types` | `string[]` | - | 这是要包含的类型定义名称列表。 |'
- en: '| `exclude` | `string[]` | - | This is the list of (sub) directories excluded
    from the compilation. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `exclude` | `string[]` | - | 这是编译时排除的（子）目录列表。 |'
- en: You can stop the compiler from emitting JavaScript on errors by setting the
    `--noEmitOnError` option to `true`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将 `--noEmitOnError` 选项设置为 `true` 来阻止编译器在出错时发出 JavaScript。
- en: Angular cheat sheet - overview of key concepts
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 速查表 - 关键概念概述
- en: Angular 2 introduces completely new concepts for building web applications.
    The new Angular platform is complex. It is not possible to explain numerous Angular
    features in detail. Instead, we will concentrate on the most important key concepts
    such as dependency injection, components, and communication between them, built-in
    directives, services, template syntax, forms, and routing.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2 引入了完全新的概念来构建 Web 应用程序。新的 Angular 平台是复杂的。不可能详细解释众多的 Angular 特性。相反，我们将集中讨论最重要的关键概念，如依赖注入、组件及其之间的通信、内置指令、服务、模板语法、表单和路由。
- en: Components, services, and dependency injection
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件、服务和依赖注入
- en: 'Normally, you write Angular applications by composing HTML templates with the
    Angular-specific markup and component classes to manage those templates. A **component**
    is simply a TypeScript class annotated with `@Component`. The `@Component` decorator
    is used to define the associated metadata. It expects an object with the following
    most used properties:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您通过使用 Angular 特定的标记和组件类来组合 HTML 模板来编写 Angular 应用程序。**组件**只是一个使用 `@Component`
    注释的 TypeScript 类。`@Component` 装饰器用于定义相关的元数据。它期望一个具有以下最常用属性的对象：
- en: '`selector`: This is the name of the HTML tag representing this component'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selector`：这是表示该组件的 HTML 标签的名称'
- en: '`template`: This is an inline-defined template with HTML/Angular markup for
    the view'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template`：这是包含 HTML/Angular 标记的内联定义模板，用于视图'
- en: '`templateUrl`: This is the path to an external file where the template resides'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templateUrl`：这是模板所在的外部文件的路径'
- en: '`styles`: An inline-defined styles to be applied to this component''s view'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`styles`：内联定义的样式，应用于该组件的视图'
- en: '`styleUrls`: An array of paths to external files with styles to be applied
    to this component''s view'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`styleUrls`：外部文件路径数组，其中包含要应用于该组件视图的样式'
- en: '`providers`: An array of providers available to this component and its children'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`providers`：可用于该组件及其子级的提供者数组'
- en: '`exportAs`: This is the name under which the component instance is exported
    in a template'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exportAs`：这是组件实例在模板中导出的名称'
- en: '`changeDetection`: This is the change detection strategy used by this component'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`changeDetection`：这是该组件使用的变更检测策略'
- en: '`encapsulation`: This is the style encapsulation strategy used by this component'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encapsulation`：这是该组件使用的样式封装策略'
- en: 'A component class interacts with the view through an API of properties and
    methods. Component classes should delegate complex tasks to services where the
    business logic resides. **Services** are just classes that Angular instantiates
    and then injects into components. If you register services at the root component
    level, they act as singletons and share data across multiple components. In the
    next section, *Angular modularity and lifecycle hooks*, we will see how to register
    services. The following example demonstrates how to use components and services.
    We will write a service class `ProductService` and then specify an argument of
    type `ProductService` in the constructor of `ProductComponent`. Angular will automatically
    inject that service into the component:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 组件类通过属性和方法的API与视图进行交互。组件类应该将复杂的任务委托给业务逻辑所在的服务。**服务**只是 Angular 实例化然后注入到组件中的类。如果在根组件级别注册服务，它们将作为单例并在多个组件之间共享数据。在下一节中，*Angular
    模块化和生命周期钩子*，我们将看到如何注册服务。以下示例演示了如何使用组件和服务。我们将编写一个名为 `ProductService` 的服务类，然后在 `ProductComponent`
    的构造函数中指定一个类型为 `ProductService` 的参数。Angular 将自动将该服务注入到组件中：
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Notice that we applied the `@Injectable()` decorator to the service class. This
    is necessary for emitting metadata that Angular needs to inject other dependencies
    into this service. Using `@Injectable` is a good programming style even if you
    don't inject other services into your service.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将`@Injectable()`装饰器应用到了服务类上。这对于发出Angular需要将其他依赖项注入到此服务中的元数据是必要的。即使您不将其他服务注入到您的服务中，使用`@Injectable`也是一种良好的编程风格。
- en: 'It is good to know what an item in the `providers` array looks like. An item
    is an object with the `provide` property (symbol used for dependency injection)
    and one of the three properties `useClass`, `useFactory`, or `useValue` that provide
    implementation details:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 了解`providers`数组中的项是什么样子是很好的。一个项是一个带有`provide`属性（用于依赖注入的符号）和`useClass`、`useFactory`或`useValue`中的一个的对象，提供实现细节：
- en: '[PRE51]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Templates and bindings
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板和绑定
- en: 'A template tells Angular how to render the component''s view. Templates are
    HTML snippets with the specific Angular''s template syntax, such as interpolation,
    property, attribute, and event bindings, built-in directives, and pipes to mention
    just a few. We will give you a quick overview of the template syntax starting
    with interpolation. **Interpolation** is used to evaluate expressions in double
    curly braces. The evaluated expression is then converted to a string. The expression
    can contain any mathematical calculations, component''s properties and methods,
    and many more:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 模板告诉Angular如何渲染组件的视图。模板是具有特定Angular模板语法的HTML片段，例如插值、属性、属性和事件绑定、内置指令和管道等。我们将为您快速概述模板语法，从插值开始。**插值**用于在双大括号中评估表达式。然后将评估的表达式转换为字符串。表达式可以包含任何数学计算、组件的属性和方法等：
- en: '[PRE52]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Angular evaluates template expressions after every change detection cycle.
    Change detection cycles are triggered by many asynchronous activities such as
    HTTP responses, key and mouse events, and many more. The next fundamental template
    syntax is related to various bindings. *Property binding* sets an element property
    to a component property value. The element property is defined in square brackets:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Angular在每次变更检测周期之后评估模板表达式。变更检测周期由许多异步活动触发，例如HTTP响应、键盘和鼠标事件等。下一个基本模板语法与各种绑定相关。*属性绑定*将元素属性设置为组件属性值。元素属性在方括号中定义：
- en: '[PRE53]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here, `imageUrl` and `formValid` are a component''s properties. Note that this
    is a *one-way* binding because the data flow occurs in one direction, from the
    component''s properties into target element properties. *Attribute binding* allows
    us to set an attribute. This kind of binding is used when there is no element
    property to bind. The attribute binding uses square brackets too. The attribute
    name itself is prefixed with `attr.`, for example, consider ARIA attributes for
    web accessibility:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`imageUrl`和`formValid`是组件的属性。请注意，这是*单向*绑定，因为数据流只在一个方向上，从组件的属性到目标元素属性。*属性绑定*允许我们设置属性。当没有元素属性可绑定时，使用这种绑定。属性绑定也使用方括号。属性名称本身以`attr.`为前缀，例如，考虑用于Web可访问性的ARIA属性：
- en: '[PRE54]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'User interactions result in a data flow from an element to a component. In
    Angular, we can listen for certain key, mouse, and touch events by means of *event
    binding*. The event binding syntax consists of a target event name within parentheses
    on the left and a quoted template statement on the right. In particular, you can
    call a component''s method. In the next code snippet, the `onSave()` method is
    called on a click:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 用户交互导致元素到组件的数据流。在Angular中，我们可以通过*事件绑定*来监听特定的键盘、鼠标和触摸事件。事件绑定语法由左侧括号中的目标事件名称和右侧的带引号的模板语句组成。特别是，您可以调用组件的方法。在下一个代码片段中，`onSave()`方法在点击时被调用：
- en: '[PRE55]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The method (generally template statement) gets a parameter--an event object
    named `$event`. For native HTML elements and events, `$event` is a DOM event object:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法（通常是模板语句）接收一个参数--一个名为`$event`的事件对象。对于本机HTML元素和事件，`$event`是一个DOM事件对象：
- en: '[PRE56]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Two-way binding is possible as well. The `[(value)]` syntax combines the brackets
    of property binding with the parentheses of event binding. Angular''s directive
    `NgModel` is best suited for the two-way binding on native or custom input elements.
    Consider the following sample:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 双向绑定也是可能的。`[(value)]`语法将属性绑定的括号与事件绑定的括号结合在一起。Angular的指令`NgModel`最适合用于本机或自定义输入元素的双向绑定。考虑以下示例：
- en: '[PRE57]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Is equivalent to:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于：
- en: '[PRE58]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Two-way binding in a nutshell: a property gets displayed and updated at the
    same time when the user makes changes. A *template reference variable* is another
    example of handy template syntax. You can declare a variable with the hash symbol
    (`#`) on any DOM element and reference this variable anywhere in the template.
    The next example shows the `username` variable declared on an `input` element.
    This reference variable is consumed on a button--it is used to get an input value
    for the `onclick` handler:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，双向绑定是指当用户进行更改时，属性同时显示和更新。*模板引用变量*是方便的模板语法的另一个例子。您可以在任何DOM元素上使用井号（`#`）声明一个变量，并在模板中的任何位置引用此变量。下一个示例显示了在`input`元素上声明的`username`变量。这个引用变量在按钮上被使用--它用于获取`onclick`处理程序的输入值：
- en: '[PRE59]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'A template reference variable can also be set to a directive. A typical example
    is the `NgForm` directive which provides useful details about the `form` elements.
    You can, for example, disable the submit button if the form is not valid (required
    fields are not filled in and so on):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引用变量也可以设置为指令。一个典型的例子是`NgForm`指令，它提供了关于`form`元素的有用细节。例如，如果表单无效（必填字段未填写等），您可以禁用提交按钮：
- en: '[PRE60]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Last but not least, the *pipe* operator (`|`). It is used for the transformation
    of the expression''s result. The pipe operator passes the result of an expression
    on the left to a pipe function on the right. For example, the pipe `date` formats
    JavaScript `Date` object according to the specified format ([https://angular.io/docs/ts/latest/api/common/index/DatePipe-pipe.html](https://angular.io/docs/ts/latest/api/common/index/DatePipe-pipe.html)):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有*管道*运算符（`|`）。它用于转换表达式的结果。管道运算符将左侧表达式的结果传递给右侧的管道函数。例如，管道`date`根据指定的格式格式化JavaScript
    `Date`对象（[https://angular.io/docs/ts/latest/api/common/index/DatePipe-pipe.html](https://angular.io/docs/ts/latest/api/common/index/DatePipe-pipe.html)）：
- en: '[PRE61]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Multiple chained pipes can be applied as well.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以应用多个链接的管道。
- en: Built-in directives
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置指令
- en: 'Angular has a lot of built-in directives: `ngIf`, `ngFor`, `ngSwitch`, `ngClass`,
    and `ngStyle`. The first three directives are so called *structural directives*,
    which are used to transform the DOM''s structure. Structural directives start
    with an asterisk (`*`). The last two directives manipulate the CSS classes and
    styles dynamically. Let''s explain the directives in the examples.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Angular有很多内置指令：`ngIf`、`ngFor`、`ngSwitch`、`ngClass`和`ngStyle`。前三个指令被称为*结构指令*，用于转换DOM的结构。结构指令以星号（`*`）开头。最后两个指令动态地操作CSS类和样式。让我们在示例中解释这些指令。
- en: 'The `ngIf` directive adds and removes elements in the DOM, based on the Boolean
    result of an expression. In the next code snippet, `<h2>ngIf</h2>` is removed
    when the `show` property evaluates to `false` and gets recreated otherwise:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngIf`指令根据表达式的布尔结果在DOM中添加和删除元素。在下一个代码片段中，当`show`属性计算为`false`时，`<h2>ngIf</h2>`被移除，否则重新创建：'
- en: '[PRE62]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Angular 4 has introduced a new `else` clause with the reference name for a
    template defined by `ng-template`. The content within `ng-template` is shown when
    the `ngIf` condition evaluates to `false`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 4引入了一个新的`else`子句，其引用名称为`ng-template`定义的模板。当`ngIf`条件求值为`false`时，`ng-template`中的内容将显示出来：
- en: '[PRE63]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`ngFor` outputs a list of elements by iterating over an array. In the next
    code snippet, we iterate over the `people` array and store each item in a template
    variable called `person`. This variable can be then accessed within the template:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngFor`通过对数组进行迭代来输出元素列表。在下一个代码片段中，我们对`people`数组进行迭代，并将每个项目存储在名为`person`的模板变量中。然后可以在模板中访问此变量：'
- en: '[PRE64]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`ngSwitch` conditionally swaps the contents dependent on condition. In the
    next code snippet, `ngSwitch` is bound to the `choice` property. If `ngSwitchCase`
    matches the value of this property, the corresponding HTML element is displayed.
    If no matching exists, the element associated with `ngSwitchDefault` is displayed:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngSwitch`根据条件有条件地交换内容。在下一个代码片段中，`ngSwitch`绑定到`choice`属性。如果`ngSwitchCase`匹配此属性的值，则显示相应的HTML元素。如果没有匹配项，则显示与`ngSwitchDefault`关联的元素：'
- en: '[PRE65]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`ngClass` adds and removes CSS classes on an element. The directive should
    receive an object with class names as keys and expressions as values that evaluate
    to `true` or `false`. If the value is `true`, the associated class is added to
    the element. Otherwise, if `false`, the class is removed from the element:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngClass`在元素上添加和删除CSS类。指令应接收一个带有类名作为键和表达式作为值的对象，这些表达式求值为`true`或`false`。如果值为`true`，则将关联的类添加到元素中。否则，如果为`false`，则从元素中删除类：'
- en: '[PRE66]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`ngStyle` adds and removes inline styles on an element. The directive should
    receive an object with style names as keys and expressions as values that evaluate
    to style values. A key can have an optional `.<unit>` suffix (for example, `top.px`):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngStyle`在元素上添加和删除内联样式。指令应接收一个带有样式名称作为键和表达式作为值的对象，这些表达式求值为样式值。键可以有一个可选的`.<unit>`后缀（例如，`top.px`）：'
- en: '[PRE67]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In order to be able to use built-in directives in templates, you have to import
    `CommonModule` from `@angular/common` and add it to the root module of your application.
    Angular's modules are explained in the next chapter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在模板中使用内置指令，您必须从`@angular/common`导入`CommonModule`并将其添加到应用程序的根模块中。Angular的模块将在下一章中进行解释。
- en: Communication between components
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件之间的通信
- en: 'Components can communicate with each other in a loosely coupled manner. There
    are various ways Angular''s components can share data, including the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以以松散耦合的方式相互通信。Angular组件可以共享数据的各种方式，包括以下方式：
- en: Passing data from parent to child using `@Input()`
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@Input()`从父组件向子组件传递数据
- en: Passing data from child to parent using `@Output()`
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@Output()`从子组件向父组件传递数据
- en: Using services for data sharing
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务进行数据共享
- en: Calling `ViewChild`, `ViewChildren`, `ContentChild`, and `ContentChildren`
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`ViewChild`，`ViewChildren`，`ContentChild`和`ContentChildren`
- en: Interacting with the child component using a local variable
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本地变量与子组件交互
- en: 'We will only describe the first three ways. A component can declare input and
    output properties. To pass the data from a parent to a child component, the parent
    binds the values to the input properties of the child. The child''s input property
    should be decorated with `@Input()`. Let''s create `TodoChildComponent`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只描述前三种方式。组件可以声明输入和输出属性。要将数据从父组件传递到子组件，父组件将值绑定到子组件的输入属性。子组件的输入属性应该用`@Input()`装饰。让我们创建`TodoChildComponent`：
- en: '[PRE68]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, the parent component can use `todo-child` in its template and bind the
    parent''s `todo` object to the child''s `todo` property. The child''s property
    is exposed as usual in square brackets:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，父组件可以在其模板中使用`todo-child`并将父组件的`todo`对象绑定到子组件的`todo`属性。子组件的属性像往常一样用方括号暴露出来：
- en: '[PRE69]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If a component needs to pass the data to its parent, it emits custom events
    via the output property. The parent can create a listener to a particular component''s
    event. Let''s see that in action. The child component `ConfirmationChildComponent`
    exposes an `EventEmitter` property decorated with `@Output()` to emit events when
    the user clicks on buttons:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件需要将数据传递给其父组件，它会通过输出属性发出自定义事件。父组件可以创建一个监听器来监听特定组件的事件。让我们看看它的实现。子组件`ConfirmationChildComponent`暴露了一个带有`@Output()`装饰的`EventEmitter`属性，以便在用户点击按钮时发出事件：
- en: '[PRE70]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The parent subscribes an event handler to that event property and reacts to
    the emitted event:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 父组件订阅事件处理程序到该事件属性，并对发出的事件做出反应：
- en: '[PRE71]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: A bi-directional communication is possible via services. Angular leverages RxJS
    library ([https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS))
    for asynchronous and event-based communication between several parts of an application
    as well as between an application and remote backend. The key concepts in the
    asynchronous and event-based communication are `Observer` and `Observable`. They
    provide a generalized mechanism for push-based notification, also known as the
    observer design pattern. `Observable` represents an object that sends notifications,
    and `Observer` represents an object that receives them.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通过服务可以实现双向通信。Angular利用RxJS库（[https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS)）在应用程序的各个部分之间以及应用程序与远程后端之间进行异步和基于事件的通信。异步和基于事件的通信中的关键概念是“观察者”和“可观察对象”。它们提供了一种推送式通知的通用机制，也称为观察者设计模式。“可观察对象”表示发送通知的对象，“观察者”表示接收通知的对象。
- en: 'Angular implements this design pattern everywhere. For example, Angular''s
    `Http` service returns an `Observable` object:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Angular在各处实现了这种设计模式。例如，Angular的`Http`服务返回一个`Observable`对象：
- en: '[PRE72]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In case of the inter-component communication, an instance of the `Subject`
    class can be used. This class inherits both `Observable` and `Observer`. That
    means it acts as a message bus. Let''s implement `TodoService` that allows us
    to emit and receive `Todo` objects:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件间通信的情况下，可以使用`Subject`类的一个实例。这个类同时继承了`Observable`和`Observer`。这意味着它充当了一个消息总线。让我们实现`TodoService`，它允许我们发出和接收`Todo`对象：
- en: '[PRE73]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Components can use this service in the following way:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以以以下方式使用此服务：
- en: '[PRE74]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Forms
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表格
- en: 'Forms are the main building blocks in every web application. Angular offers
    two approaches to build forms: *template-driven forms* and *reactive forms*. This
    section gives you a short overview of template-driven forms.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 表单是每个Web应用程序中的主要构建块。Angular提供了两种构建表单的方法：*模板驱动表单*和*响应式表单*。本节为您提供了模板驱动表单的简要概述。
- en: Reactive forms are suitable when you need to create dynamic forms programmatically
    in the component's class. Refer to the official Angular documentation to learn
    reactive forms ([https://angular.io/docs/ts/latest/guide/reactive-forms.html](https://angular.io/docs/ts/latest/guide/reactive-forms.html)).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要在组件类中以编程方式创建动态表单时，响应式表单是合适的。请参考官方的Angular文档来学习响应式表单（[https://angular.io/docs/ts/latest/guide/reactive-forms.html](https://angular.io/docs/ts/latest/guide/reactive-forms.html)）。
- en: 'We already mentioned two directives: `NgForm` and `NgModel`. The first directive
    creates a `FormGroup` instance and binds it to a form in order to track aggregate
    form value and validation status. The second one creates a `FormControl` instance
    and binds it to the corresponding `form` element. The `FormControl` instance tracks
    the value and the status of the `form` element. Each input element should have
    a `name` property that is required to register the `FormControl` by the `FormGroup`
    under the name you assigned to the `name` attribute. How to deal with this tracked
    data? You can export the `NgForm` and `NgModel` directives into local template
    variables such as `#f="ngForm"` and `#i="ngModel"`, respectively. Here, `f` and
    `i` are local template variables that give you access to the value and status
    of `FormGroup` and `FormControl`, respectively. This is possible because the properties
    from `FormGroup` and `FormControl` are duplicated on the directives themselves.
    With this knowledge in hand, you can now check if the whole form or a particular
    `form` element:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Is valid (`valid` and `invalid` properties)
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has been visited (`touched` and `untouched` properties)
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has some changed value (`dirty` and `pristine` properties)
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next example illustrates the basic concept:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `NgModel` directive also updates the corresponding `form` element with
    specific CSS classes that reflect the element''s state. The following classes
    are added/removed dependent on the current state:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '| **State** | **Class if true** | **Class if false** |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: '| Element has been visited | `ng-touched` | `ng-untouched` |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
- en: '| Element''s value has changed | `ng-dirty` | `ng-pristine` |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
- en: '| Element''s value is valid | `ng-valid` | `ng-invalid` |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
- en: 'This is handy for styling. For example, in case of validation errors, you can
    set red borders around input elements:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Routing
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular''s `router` module allows you to configure navigation in a single page
    application without a full page reload. The router can display different views
    (compiled component templates) within a special tag called `<router-outlet>`.
    During navigation, one view will be replaced by another one. A simple routing
    configuration looks as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'When you navigate to the web context root, you will be redirected to `/home`.
    As a reaction to that, the view of the `HomeComponent` will be displayed in `<router-outlet>`.
    It is obvious that a direct navigation to `/home` displays the same view. A navigation
    to `/books` displays the view of `BooksComponent`. Such router configuration should
    be converted to an Angular''s module by `RouterModule.forRoot`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This is then imported in a root module class. In addition to the root module,
    an Angular application can consist of a lot of feature or lazy-loaded modules.
    Such separate modules can have their own router configurations which should be
    converted to Angular''s modules with `RouterModule.forChild(router)`. The next
    section, *Angular modularity and lifecycle hooks,* discusses modules in detail.
    Angular offers two strategies for implementing client-side navigation:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '`HashLocationStrategy`: This strategy adds a hash sign (`#`) to the base URL.
    Everything after this sign represents a hash fragment of the browser''s URL. The
    hash fragment identifies the route. For example, `http://somehost.de:8080/#/books`.
    Changing the route doesn''t cause a server-side request. Instead, the Angular
    application navigates to a new route and view. This strategy works with all browsers.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PathLocationStrategy`: This strategy is based on the **History API** and only
    works in browsers that support HTML5\. This is the default location strategy.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The details are to be mentioned here. If you want to use the `HashLocationStrategy`,
    you have to import two classes, `LocationStrategy` and `HashLocationStrategy`
    from `''@angular/common''` and configure providers as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Providers are described in the next section, *Angular modularity and lifecycle
    hooks.* The `PathLocationStrategy` class requires a configuration of the base
    URL for the entire application. The best practice is to import `APP_BASE_HREF`
    constant from `''@angular/common''` and use it as a provider in order to configure
    the base URL:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'How to trigger a navigation? You can achieve that in two ways, either by a
    link with a `routerLink` property, which specifies an array consisting of route
    (path) and optional parameters:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Or programmatically, by invoking the `navigate` method on Angular''s `Router`
    service:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'You can also pass parameters to a route. Placeholders for parameters start
    with a colon (`:`):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, when navigating to a book with real parameters, for example, programmatically
    as `this.router.navigate([''/books/2''])`, the real parameter can be accessed
    by `ActivatedRoute`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The router outlet can be named as well:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The associated configuration should contain the `outlet` property with the
    name of the router outlet:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Angular modularity and lifecycle hooks
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular modularity with NgModules provides a great way to organize the code
    in a web application. Many third-party libraries, such as PrimeNG, Angular Material,
    Ionic, are distributed as NgModules. *Lifecycle hooks* allow us to perform custom
    logic at component level at a well-defined time. This section covers these major
    concepts in detail.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Modules and bootstrapping
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular modules make it possible to consolidate components, directives, services,
    pipes, and many more into cohesive blocks of functionality. Angular''s code is
    modularized. Every module has its own functionality. There are `FormsModule`,
    `HttpModule`, `RouterModule`, and many other modules as well. What does a module
    look like? A module is a class annotated with the `@NgModule` decorator (imported
    from `@angular/core`). `@NgModule` takes a configuration object that tells Angular
    how to compile and run the module code. The most significant properties of the
    the configuration object are:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '`declarations`: The array with components, directives, and pipes, which are
    implemented in that module and belong to that module.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imports`: The array with dependencies in form of other modules which need
    to be made available to that module.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exports`: The array of components, directives, and pipes to be exported and
    permitted to be imported by another modules. The rest is private. This is the
    module''s public API and similar to how the `export` keyword works in ECMAScript
    modules.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`providers`: This is the array of services (service classes, factories, or
    values), which are available in that module. Providers are parts of the module
    and can be injected into components (inclusive sub-components), directives, and
    pipes defined within the module.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bootstrap`: Every Angular application has at least one module--the root module.
    The `bootstrap` property is only used in the root module and contains the component
    which should be instantiated first when bootstrapping the application.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entryComponents`: This is the array of components that Angular generates component
    factories for. Normally, you need to register a component as an entry component
    when it is intended to be created dynamically at runtime. Such components can
    not be figured out automatically by Angular at template compilation time.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A typical module configuration for any separate example in this book looks
    something like this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '`BrowserModule` is needed to get access to the browser-specific renderers and
    Angular standard directives such as `ngIf` and `ngFor`. Don''t import `BrowserModule`
    in any other modules except the root module. Feature modules and lazy-loaded modules
    should import `CommonModule` instead.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of how to bootstrap an Angular application in the
    JIT mode (just in time compilation):'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In the **ahead-of-time** mode (**AOT** compilation), you need to provide a
    factory class. To generate the factory class, you must run the `ngc` compiler
    instead of the TypeScript `tsc` compiler. In the last two sections of this chapter,
    you will see how to use AOT with Webpack and Angular CLI. The bootstrapping code
    in the AOT mode looks like the following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Templates with bindings written in Angular need to be compiled. With AOT, the
    compiler runs once at build time. With JIT, it runs every time at runtime. Browsers
    load a pre-compiled version of the application much faster and there is no need
    to download the Angular compiler if the app is already compiled.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'Modules can also be lazy loaded when they get requested (on demand). This approach
    reduces the size of web resources loaded on initial page display. The page appears
    faster. If you want to enable lazy loading, you have to configure the router to
    load the module lazy. All you need is a `path` object with a `loadChildren` property,
    which points to the path and name of the lazy loaded module:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Note that the value of `loadChildren` property is a string. Furthermore, the
    module importing this router configuration should not declare the lazy loaded
    module as dependency in the `imports` property of the configuration object.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Lifecycle hooks
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular components come with lifecycle hooks, which get executed at specific
    times in the component''s life. For this purpose, Angular offers different interfaces.
    Each interface has a method of the same name as the interface name with the prefix
    `ng`. Each method is executed when the corresponding lifecycle event occurs. They
    are also called lifecycle hook methods. Angular calls the lifecycle hook methods
    in the following sequence after the constructor has been called:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '| **The lifecycle hook method** | **Purpose and timing** |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
- en: '| `ngOnChanges` | This is called whenever one or more data-bound input properties
    change. This method is called on initial changes (before `ngOnInit`) and any other
    subsequent changes. This method has one parameter--an object with keys of type
    `string` and values of type `SimpleChange`. The keys are the component''s property
    names. The `SimpleChange` object contains current and previous values. A usage
    example is shown next. |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
- en: '| `ngOnInit` | This is called once, after the first `ngOnChanges`. Note that
    the constructor of a component should only be used for dependency injection because
    data-bound input values are not yet set in the constructor. Everything else should
    be moved to the `ngOnInit` hook. A usage example is shown next. |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
- en: '| `ngDoCheck` | This is called during every change detection run. It is a good
    place for custom logic, which allows us to do a fine-grained check of which property
    on our object changed. |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
- en: '| `ngAfterContentInit` | This is called once, after Angular puts external content
    into the component''s view. A placeholder for any external content is marked with
    the `ngContent` directive (the `ng-content` tag). A usage example of the `ngContent`
    directive is demonstrated afterwards. |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
- en: '| `ngAfterContentChecked` | This is called after Angular checks the content
    put into the component''s view. |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
- en: '| `ngAfterViewInit` | This is called once, after Angular initializes the component''s
    and child''s views. |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
- en: '| `ngAfterViewChecked` | This is called after Angular checks the component''s
    views and child views. |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
- en: '| `ngOnDestroy` | This is called just before Angular destroys the component''s
    instance. This happens when you remove the component with built-in structural
    directives such as `ngIf`, `ngFor`, `ngSwitch`, or when you navigate to another
    view. This is a good place for cleanup operations such as unsubscribing observables,
    detaching event handlers, canceling interval timers, and so on. |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
- en: 'Let''s see an example of how to use `ngOnInit` and `ngOnChanges`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Usage in HTML:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Let''s now see how to use the `ngContent` directive:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Usage in HTML:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'After the component''s initialization, the following hook methods get always
    executed on every change detection run: `ngDoCheck` -> `ngAfterContentChecked`
    -> `ngAfterViewChecked` -> `ngOnChanges`.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Running PrimeNG with SystemJS
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PrimeNG ([https://www.primefaces.org/primeng](https://www.primefaces.org/primeng))
    is an open source library of rich UI components for Angular 2+. PrimeNG is derived
    from PrimeFaces--the most popular **JavaServer Faces** (**JSF**) component suite.
    If you know PrimeFaces, you will feel at home with PrimeNG due to similar API.
    Currently, PrimeNG has 80+ visually stunning widgets that are easy to use. They
    are divided into several groups such as input and select components, buttons,
    data iteration components, panels, overlays, menus, charts, messages, multimedia,
    drag-and-drop, and miscellaneous. There are also 22+ free and premium themes.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: PrimeNG fits perfectly with the mobile and desktop development because it is
    a responsive and touch optimized framework. PrimeNG showcase is a good place to
    play with the components, try them in action, study documentation, and code snippets.
    Anyway, we need a systematic approach for getting started with PrimeNG. This is
    what this book tries to convey. In this chapter, we will set up and run PrimeNG
    with SystemJS ([https://github.com/systemjs/systemjs](https://github.com/systemjs/systemjs))--universal
    module loader supporting various module formats. SystemJS is a good choice for
    learning purposes if you want to try TypeScript, Angular, PrimeNG code snippets,
    or write small applications in Plunker ([https://plnkr.co](https://plnkr.co))
    because it can load your files, transpile them (if needed) and resolve module
    dependencies on-the-fly. In the real applications, you should choose Webpack or
    Angular CLI-based setups that have more power and advanced configurations. They
    also bundle your application in order to reduce the amount of HTTP requests. Those
    setups will be discussed in the next two sections.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: The SystemJS configuration for Angular
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, you need to install Node.js and npm, which we already mentioned
    in the *TypeScript fundamentals you need to know* section. Why do we need npm?
    In HTML and SystemJS configuration, we could reference all dependencies from [https://unpkg.com](https://unpkg.com).
    But, we prefer to install all dependencies locally so that IDEs are fine with
    autocompletion. For instance, to install SystemJS, you have to run the following
    command in a console of your choice:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: For readers, we created a complete demo seed project where all dependencies
    are listed in the `package.json` file.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: The complete seed project with PrimeNG and SystemJS is available on GitHub at
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-systemjs-setup](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-systemjs-setup).'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'All dependencies in the seed project can be installed by running `npm install`
    in the project root. If you explore the `index.html` file, you can see that the
    SystemJS library is included in the `<head>` tag. After that, it becomes available
    as a global `System` object, which exposes two static methods: `System.import()`
    and `System.config()`. The first method is used to load a module. It accepts one
    argument--a module name, which can be either a file path or a logical name mapped
    to the file path. The second method is used for setting configuration. It accepts
    a configuration object as an argument. Normally, the configuration is placed within
    the `systemjs.config.js` file. Complete scripts to be included in `index.html`
    are TypeScript compiler, Polyfills, and SystemJS related files. The bootstrapping
    occurs by executing `System.import(''app'')`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'An excerpt from the configuration object for Angular projects is listed here:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'A brief explanation gives an overview of the most important configuration options:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: The `transpiler` option specifies a transpiler for TypeScript files. Possible
    values are `typescript`, `babel`, and `traceur`. The transpilation happens in
    browser on-the-fly.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `typescriptOptions` option sets the TypeScript compiler options.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `map` option creates aliases for module names. When you import a module,
    the module name is replaced by an associated value according to the mapping. In
    the configuration, all entry points for Angular files are in UMD format.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `packages` option sets meta information for imported modules. For example,
    you can set the main entry point of the module. Furthermore, you can specify default
    file extensions to be able to omit them when importing.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding PrimeNG dependencies
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every project using PrimeNG needs the locally installed library. You can achieve
    this by running the following command:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'As a result, PrimeNG is installed in your project root under the `node_modules`
    folder as well as added in `package.json` as a dependency. Here again, you can
    skip this step if you use the seed project hosted on GitHub--just run `npm install`.
    The next step is to add two new entries to the SystemJS configuration file. For
    shorter `import` statements, it is recommended to map `primeng` to `node_modules/primeng`.
    PrimeNG components are distributed as CommonJS modules ending with `.js`. That
    means we should set the default extension too:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Now, you are able to import PrimeNG modules from `primeng/primeng`. For instance,
    write this line to import `AccordionModule` and `MenuItem`:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'This way of importing is not recommended in production because all other available
    components will be loaded as well. Instead of that, only import what you need
    using a specific component path:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'In the demo application, we will only use `ButtonModule` and `InputTextModule`
    so that we need to import them as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The demo project we want to create consists of application code and assets.
    A detailed description of every file would go beyond the scope of this book. We
    will only show the project structure:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4605bc24-7519-403c-a3fe-6c70f72f6293.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
- en: 'A typically PrimeNG application needs a theme. We would like to take the B*ootstrap*
    theme. The file `index.html` must have three CSS dependencies included within
    the `<head>` tag--the theme, the PrimeNG file, and the FontAwesome file for SVG
    icons ([http://fontawesome.io](http://fontawesome.io)):'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'All FontAwesome files were placed under `src/assets/icons`. Mostly PrimeNG
    components are native, but there is a list of components with third-party dependencies.
    These are explained in the following table:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '| **Component** | **Dependency** |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
- en: '| Schedule | FullCalendar and Moment.js |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
- en: '| Editor | Quill editor |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
- en: '| GMap | Google Maps |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
- en: '| Charts | Charts.js |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
- en: '| Captcha | Google Recaptcha |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
- en: Exact links to those dependencies will be shown later in concrete examples.
    For now, we have finished our setup. Let's start our first application by running
    `npm start` in the project root.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'The application gets launched in browser with two PrimeNG components, as shown
    in the following screenshot. As you can see, a lot of single web resources (CSS
    and JS files) are being loaded in the browser:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bb6b4b11-9524-4017-8463-5c0a98ca5e1b.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
- en: Setting up PrimeNG project with Webpack
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Webpack ([https://webpack.js.org](https://webpack.js.org)) is a de facto standard
    bundler for single-page applications. It analyzes dependencies between JavaScript
    modules, assets (styles, icons, and images) as well as other files in your application
    and bundles everything together. In Webpack, everything is a module . You can,
    for example, import a CSS file like a JavaScript file using `require('./myfile.css')`
    or `import './myfile.css'`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Webpack can figure out the right processing strategy for imported files by means
    of the file extension and associated loader. It is not always reasonable to build
    one big bundle file. Webpack has various plugins to split your code and generate
    multiple bundle files. It can also load parts of your application asynchronously
    on demand (lazy loading). All these features make it a power tool. In this section,
    we will give a high-level overview of Webpack 2 core concepts and show essential
    steps for creating a Webpack-based Angular, PrimeNG application.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: The complete seed project with PrimeNG and Webpack is available on GitHub at
    [https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-webpack-setup](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-webpack-setup).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: The project structure was kept the same as in the SystemJS-based setup.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Entry point and output
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript and other files imported into each other are closely interwoven.
    Webpack creates a graph of all such dependencies. The starting point of this graph
    is called *entry point*. An entry point tells Webpack where to start to resolve
    all dependencies and creates a bundle. Entry points are created in the Webpack
    configuration file using the `entry` property. In the seed project on GitHub,
    we have two configuration files, one for the development mode (`webpack.dev.js`)
    and one for the production (`webpack.prod.js`) mode, each with two entry points.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'In the development mode, we use the main entry point for JIT compilation. The
    `main.jit.ts` file contains quite normally bootstrapping code. The second entry
    point combines files from `core-js` (Polyfills for modern ECMAScript features)
    and `zone.js` (the basis for Angular''s change detection):'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'In the production mode, we use the main entry point for AOT compilation. JIT
    and AOT were mentioned in the *Angular modularity and lifecycle hooks* section:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The `output` property tells Webpack where to bundle your application. You can
    use placeholders such as `[name]` and `[chunkhash]` to define what the names of
    output files look like. The `[name]` placeholder will be replaced by the name
    defined in the `entry` property. The `[chunkhash]` placeholder will be replaced
    by the hash of the file content at project build time. The `chunkFilename` option
    determines the names of on-demand (lazy) loaded chunks--files loaded by `System.import()`.
    In the development mode, we don''t use `[chunkhash]` because of performance issues
    during hash generation:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The `[chunkhash]` placeholder is used in the production mode to achieve so
    called *long term caching*--every file gets cached in the browser and will be
    automatically invalidated and reloaded when the hash changes:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: A hash in the filename changes every compilation when the file content is changed.
    That means, files with hashes in names can not be included manually in the HTML
    file (`index.html`). `HtmlWebpackPlugin` ([https://github.com/jantimon/html-webpack-plugin](https://github.com/jantimon/html-webpack-plugin))
    helps us to include generated bundles with `<script>` or `<link>` tags in the
    HTML. The seed project makes use of this plugin.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Loaders and plugins
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Webpack only understands JavaScript files as modules. Every other file (`.css`,
    `.scss`, `.json`, `.jpg`, and many more) can be transformed into a module while
    importing. *Loaders* transform these files and add them to the dependency graph.
    Loader configuration should be done under `module.rules`. There are two main options
    in the loader configuration:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: The `test` property with a regular expression for testing files the loader should
    be applied to
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loader` or `use` property with the concrete loader name'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Note that loaders should be registered in `package.json` so that they can be
    installed under `node_modules`. Webpack homepage has a good overview of some popular
    loaders ([https://webpack.js.org/loaders](https://webpack.js.org/loaders)). For
    TypeScript files, it is recommended to use the following sequence of loaders in
    the development mode:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Multiple loaders are applied from right to left. The `angular2-template-loader`
    searches for `templateUrl` and `styleUrls` declarations and inlines HTML and styles
    inside of the `@Component` decorator. The `awesome-typescript-loader` is mostly
    for speeding up the compilation process. For AOT compilation (production mode),
    another configuration is required:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Webpack has not only loaders, but also *plugins* which take responsibility
    for custom tasks beyond loaders. Custom tasks could be the compression of assets,
    extraction of CSS into a separate file, generation of a source map, definition
    of constants configured at compile time, and so on. One of the helpful plugins
    used in the seed project is the `CommonsChunkPlugin`. It generates chunks of common
    modules shared between entry points and splits them into separate bundles. This
    results in page speed optimizations as the browser can quickly serve the shared
    code from cache. In the seed project, we moved Webpack''s runtime code to a separate
    `manifest` file in order to support long-term caching. This will avoid hash recreation
    for vendor files when only application files are changed:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'As you can see, configuration of plugins is done in the `plugins` option. There
    are two plugins for production configuration yet to be mentioned here. The `AotPlugin`
    enables AOT compilation. It needs to know the path of `tsconfig.json` and the
    path with module class used for bootstrapping:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '`UglifyJsPlugin` is used for code minification:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Adding PrimeNG, CSS, and SASS
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to finish the setup. First, make sure that you have PrimeNG and
    FontAwesome dependencies in the `package.json` file. For example:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Second, bundle all CSS files into one file. This task is accomplished by `ExtractTextPlugin`,
    which is needed for loaders and plugin configuration:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: For production, you should set the filename to `"[name].[chunkhash].css"`. The
    bundled CSS file gets automatically included into `index.html` by `HtmlWebpackPlugin`.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'We prefer not to use `styleUrls` in the components. The seed project imports
    a CSS und SASS files in one place--inside of `main.scss` file located under `src/assets/css`:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Note that the tilde `~` points to the `node_modules`. More precisely the Sass
    preprocessor interprets it as the `node_modules` folder. Sass is explained in
    [Chapter 2](f3278626-cfa5-4c6f-8ff2-97df3a45778f.xhtml), *Theming Concepts and
    Layouts*. The `main.scss` file should be imported in the entry points `main.jit.ts`
    and `main.aot.ts`:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Webpack takes care of the rest. There are more goodies from Webpack--a development
    server with live reloading `webpack-dev-server` ([https://webpack.js.org/configuration/dev-server](https://webpack.js.org/configuration/dev-server)).
    It detects changes made to files and recompiles automatically. You can start it
    with `npm start` or `npm run start:prod`. These commands represent npm scripts:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: When running `webpack-dev-server`, the compiled output is served from memory.
    This means, the application being served is not located on disk in the `dist`
    folder.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: That's all. More configuration options for unit and end-to-end testing will
    be added in [Chapter 10](b5fd2c81-a93b-4c32-a2a6-4978019f283a.xhtml), *Creating
    Robust Applications*.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Setting up PrimeNG project with Angular CLI
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular CLI ([https://cli.angular.io](https://cli.angular.io)) is a comfortable
    tool to create, run, and test Angular applications out of the box. It generates
    the code in no time. We will describe some useful commands and show you how to
    integrate PrimeNG with Angular CLI. First, the tool should be installed globally:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'When it is installed, every command can be executed in the console with prepended
    `ng`. For instance, to create a new project, run `ng new [projectname] [options]`.
    Let''s create one. Navigate to a directory that will be the parent directory of
    your project and run the following command:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: This command will create an Angular 4 project within the folder `primeng-angularcli-setup`.
    The option `--style` sets a CSS preprocessor. Here, we want to use SASS files
    and need a Sass preprocessor. The preprocessor compiles SASS files whenever we
    make changes. You don't need to set a preprocessor if you only have CSS files.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: The complete preconfigured seed project with PrimeNG and Angular CLI is available
    on GitHub at
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-angularcli-setup](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-angularcli-setup).'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'The created project has the following top directories and files:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '| **Directory/file** | **Short description** |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
- en: '| `e2e` | Folder with e2e tests (`.e2e-spec.ts` files) and page objects (`.po.ts`
    files). |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
- en: '| `src` | Source code folder where the application code should be written.
    |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
- en: '| `.angular-cli.json` | Set up configuration file. PrimeNG dependencies can
    be listed here. |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
- en: '| `karma.conf.js` | Karma configuration file for unit testing. |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
- en: '| `protractor.conf.js` | Protractor configuration file for e2e testing. |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
- en: '| `package.json` | Standard file for package management of npm-based projects.
    |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
- en: '| `tsconfig.json` | Settings for TypeScript compiler. |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
- en: '| `tslint.json` | Settings for TSLint. |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
- en: 'You can now start the application by typing the following:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'This command will run a local server at `http://localhost:4200` by default.
    You will see the text app works! in the browser. The `ng serve` command uses `webpack-dev-server`
    internally. The server is running in the watch mode. It refreshes the page automatically
    when any changes occur. There are a lot of configuration options. You can, for
    example, set a custom port by the `--port` option. Refer to the official documentation
    for more details at [https://github.com/angular/angular-cli/wiki](https://github.com/angular/angular-cli/wiki).
    To compile the application into an output directory, run the following command:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The build artifacts will be stored in the `dist` directory.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: The `--prod` option in `ng build` or `ng serve` will minify the files and remove
    unused (dead) code. The `--aot` option will use AOT compilation and produce even
    more smaller and optimized artifacts.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: To run unit and e2e tests, execute `ng test` and `ng e2e` commands, respectively.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Generating scaffolding
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular CLI allows us to generate components, services, directives, routes,
    pipes, and many more with `ng generate`. Here is how you would generate a component:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'For example, if we run the following command:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Four files will be generated and one updated. The produced output will be:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The new component is registered in `app.module.ts` automatically. The generation
    of other scaffoldings is identical. For example, to generate a service, run this
    command:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: There are plenty of useful options. You can set, for example, `--spec=false`
    to skip test file generation.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: Adding PrimeNG dependencies
  id: totrans-460
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Integrating PrimeNG with Angular CLI is straightforward. First, install and
    save the dependencies:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Second, edit the `.angular-cli.json` file and add three more CSS files to the
    `styles` section. These are the same files as in the SystemJS- and Webpack-based
    setups:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Now, you can import desired PrimeNG modules. Refer to the *Running PrimeNG with
    SystemJS* section to see how to import PrimeNG modules. In the seed project on
    GitHub, we have imported the `MessagesModule` and put some demo code into `message.component.html`
    and `message.component.ts`.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/030e2299-dbdf-4a52-a096-d608b39d0077.png)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you got an overview of TypeScript and Angular concepts
    you need to understand for the upcoming chapters. TypeScript introduces types
    which help to recognize errors at development time. There are primitive types,
    types known from object-oriented programming languages, custom types, and so on.
    By default, TypeScript compiler always emits an JavaScript code, even in the presence
    of type errors. In this way, you can quickly migrate any existing JavaScript code
    to TypeScript just by renaming `.js` file to `.ts` without having to fix all compilation
    errors at once.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: A typically Angular application is written in TypeScript. Angular provides a
    component-based approach which decouples your UI logic from the application (business)
    logic. It implements a powerful dependency injection system that makes reusing
    services a breeze. Dependency injection also increases the code testability because
    you can easily mock your business logic. An Angular application consists of hierarchical
    components, which communicate with each other in various ways such as `@Input`,
    `@Output` properties, shared services, local variables, and so on.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: Angular is a modular framework. Module classes annotated with `@NgModule` provide
    a great way to keep the code clean and organized. Angular is flexible--lifecycle
    hooks allow us to perform custom logic at several stages in the in the component's
    life. Last but not least, it is fast due to smart change detection algorithm.
    Angular doesn't offer any rich UI components. It is just a platform for developing
    single page applications. You need a third-party library to create rich UI interfaces.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: 'PrimeNG is a collection of such rich UI components for Angular 2+. In comparison
    with competitors, PrimeNG was created for enterprise applications and provides
    80+ components. Adding PrimeNG dependencies is easy done. You only need to add
    PrimeNG and FontAwesome dependencies to the `package.json` file, and three CSS
    files: `primeng.min.css`, `font-awesome.min.css`, and `theme.css` for any theme
    you like. The next chapter will cover the theming concept in detail.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: An Angular and PrimeNG application consists of ES6 (ECMAScript 2015) modules.
    Modules can be exported and imported. All modules in an application build a dependency
    graph. Therefore, you need a specific tool to resolve such modules starting at
    some entry point(s) and to output a bundle. There are some tools doing this and
    other tasks such as loading modules on demand, and similar.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, SystemJS and Webpack loaders were discussed. SystemJS is only
    recommended for demo applications for the purpose of learning. Webpack-based builds
    are more sophisticated. Webpack has a combination of loaders for every file type
    and plugins. Plugins include useful behaviors into the Webpack build process,
    for example, creating common chunks, minification of web resources, copying files
    and directories, creating SVG sprites, and more. To quickly start the development
    in TypeScript and Angular, generate your projects with Angular CLI. This is a
    scaffolding tool, which makes it easy to create an application that works out
    of the box.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
