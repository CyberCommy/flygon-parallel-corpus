- en: Developer Environment for Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go is a modern programming language built for the 21st century application development.
    Hardware and technology have advanced significantly over the past decade, and
    most of the other languages do not take advantage of these technical advancements.
    As we shall see throughout the book, Go allows us to build network applications
    that take advantage of concurrency and parallelism made available with multicore
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at some of the topics required to work through
    rest of the book, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Go configuration—`GOROOT`, `GOPATH`, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go package management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project structure used throughout the book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container technology and how to use Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GOROOT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to run or build a Go project, we need to have access to the Go binary
    and its libraries. A typical installation of Go (instructions can be found at [https://golang.org/dl/](https://golang.org/dl/))
    on Unix-based systems will place the Go binary at `/usr/bin/go`. However, it is
    possible to install Go on a different path. In that case, we need to set the `GOROOT` environment
    variable to point to our Go installation path and also append it to our `PATH`
    environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: GOPATH
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programmers tend to work on many projects and it is good practice to have the
    source code separate from nonprogramming-related files. It is a common practice
    to have the source code in a separate location or workspace. Every programming
    language has its own conventions on how the language-related projects should be
    set up and Go is no exception to this.
  prefs: []
  type: TYPE_NORMAL
- en: '`GOPATH` is the most important environment variable the developer has to set.
    It tells the Go compiler where to find the source code for the project and its
    dependencies. There are conventions within the `GOPATH` that need to be followed,
    and they have to deal with folder hierarchies.'
  prefs: []
  type: TYPE_NORMAL
- en: src/
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the directory that will contain the source code of our projects and
    their dependencies. In general, we want our source code to have version control
    and be hosted on the cloud. It would also be great if we or anyone else could
    easily use our project. This requires a little extra setup on our part.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine that our project is hosted at `http://git-server.com/user-name/my-go-project`.
    We want to clone and build this project on our local system. To make it properly
    work, we need to clone it to `$GOPATH/src/git-server.com/user-name/my-go-project`.
    When we build a Go project with dependencies for the first time, we will see that
    the `src/` folder has many directories and subdirectories that contain the dependencies
    of our project.
  prefs: []
  type: TYPE_NORMAL
- en: pkg/
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go is a compiled programming language; we have the source code and code for
    the dependencies that we want to use in our project. In general, every time we
    build a binary, the compiler has to read the source code of our project and dependencies
    and then compile it to machine code. Compiling unchanged dependencies every time
    we compile our main program would lead to a very slow build process. This is the
    reason that **object files** exist; they allow us to compile dependencies into
    reusable machine code that can be readily included in our Go binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'These object files are stored in `$GOPATH/pkg`; they follow a directory structure
    similar to that of `src/`, except that they are within a subdirectory. These directories
    tend to follow the naming pattern of `<OS>_<CPU-Architecture>`, because we can
    build executable binaries for multiple systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: bin/
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go compiles and builds our projects into executable binaries and places them
    in this directory. Depending on the build specs, they might be executable on your
    current system or other systems. In order to use the binaries that are available
    in the `bin/` directory, we need to set the corresponding `GOBIN=$GOPATH/bin` environment
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Package management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the days of yore, all programs were written from scratch—every utility function
    and every library to run the code had to written by hand. Now a days, we don't
    want to deal with the low level details on a regular basis; it would be unimaginable
    to write all the required libraries and utilities from scratch. Go comes with
    a rich library, which will be enough for most of our needs. However, it is possible
    that we might need a few extra libraries or features not provided by the standard
    library. Such libraries should be available on the internet, and we can download
    and add them into our project to start using them.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, *GOPATH*, we discussed how all our projects are saved
    into qualified paths of the `$GOPATH/src/git-server.com/user-name/my-go-project` form.
    This is true for any and all dependencies we might have. There are multiple ways
    to handle dependencies in Go. Let's look at some of them.
  prefs: []
  type: TYPE_NORMAL
- en: go get
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `go get` is the utility provided by the standard library for package management.
    We can install a new package/library by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will download and build the source code and then install it as a binary
    executable (if it can be used as a standalone executable). The `go get` utility
    also installs all the dependencies required by the dependency retrieved for our
    project.
  prefs: []
  type: TYPE_NORMAL
- en: The `go get` utility is a very simple tool. It will install the latest master
    commit on the Git repository. For simple projects, this might be enough. However,
    as projects start growing in size and complexity, keeping track of the version
    of dependency being used might become critical. Unfortunately, `go get` is not
    great for such projects, and we might want to look at other package management
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: glide
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `glide` is one of the most widely used package management tool in Go community.
    It addresses the limitations of `go get`, but it needs to be installed manually
    by the developer. The following is a simple way to install and use `glide`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In case you do not wish to install `glide` via `curl` and `sh`, other options
    are available and described in better detail on the project page, available at [https://github.com/masterminds/glide](https://github.com/masterminds/glide).
  prefs: []
  type: TYPE_NORMAL
- en: go dep
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `go dep` is a new dependency management tool being developed by the Go community.
    Right now, it requires Go 1.7 or newer to compile, and it is ready for production
    use. However, it is still undergoing changes and hasn't yet been merged into Go's
    standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring a project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A project might have more than just the source code for the project, for example,
    configuration files and project documentation. Depending upon preferences, the
    way the project is structured can drastically change. However, the most important
    thing to remember is that the entry point to the whole program is through the
    `main` function, which is implemented within `main.go` as a convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application we will be building in this book, will have the following initial
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Working with book's code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The source code discussed throughout the book can be obtained in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `go get -u github.com/last-ent/distributed-go`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading the code bundle from the website and extracting it to `$GOPATH/src/github.com/last-ent/distributed-go`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for complete book should now be available at `$GOPATH/src/github.com/last-ent/distributed-go` and
    the code specific for each chapter will be available in that particular chapter
    number's directory.
  prefs: []
  type: TYPE_NORMAL
- en: For example,
  prefs: []
  type: TYPE_NORMAL
- en: Code for Chapter 1 -> `$GOPATH/src/github.com/last-ent/distributed-go/chapter1`
  prefs: []
  type: TYPE_NORMAL
- en: Code for Chapter 2 -> `$GOPATH/src/github.com/last-ent/distributed-go/chapter2`
  prefs: []
  type: TYPE_NORMAL
- en: And so on.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we discuss code in any particular chapter, it is implied that we are
    in the respective chapter's folder.
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout the book, we will be writing Go programs that will be compiled to
    binaries and run directly on our system. However, in the latter chapters we will
    be using `docker-compose` to build and run multiple Go applications. These applications
    can run without any real problem on our local system; however, our ultimate goal
    is to be able to run these programs on servers and to be able to access them over
    the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the 1990s and early 2000s, the standard way to deploy applications to
    the internet was to get a server instance, copy the code or binary onto the instance,
    and then start the program. This worked great for a while, but soon complications
    began to arise. Here are a few of them:'
  prefs: []
  type: TYPE_NORMAL
- en: Code that worked on the developer's machine might not work on the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programs that ran perfectly on a server instance might fail upon applying the
    latest patch to the server's OS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For every new instance added as part of a service, various installation scripts
    had to be run so that we can bring the new instance to be on par with all the
    other instances. This can be a very slow process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extra care had to be taken to ensure that the new instance and all the software
    versions installed on it are compatible with the APIs being used by our program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It was also important to ensure that all config files and important environment
    variables were copied to the new instance; otherwise, the application might fail
    with little or no clue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually the version of the program that ran on local system versus test system
    versus production system were all configured differently, and this meant that
    it was possible for our application to fail on one of the three types of systems.
    If such a situation occurred, we would end up having to spend extra time and effort
    trying to figure out whether the issue is specific to one particular instance,
    one particular system, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It would be great if we could avoid such a situation from arising, in a sensible
    manner. **Containers** try to solve this problem using OS-level virtualization.
    What does this mean?
  prefs: []
  type: TYPE_NORMAL
- en: All programs and applications are run in a section of memory known as **user
    space**. This allows the operating system to ensure that a program is not able
    to cause major hardware or software issues. This allows us to recover from any
    program crashes that might occur in the user space applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The real advantage of containers is that they allow us to run applications
    in isolated user spaces, and we can even customize the following attributes of
    user spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: Connected devices such as network adapters and TTY
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU and RAM resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files and folders accessible from host OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, how does this help us solve the problems we stated earlier? For that,
    let's take a deeper look at **Docker**.
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modern software development makes extensive use of containers for product development
    and product deployment to server instances. Docker is a container technology promoted
    by Docker, Inc ([https://www.docker.com](https://www.docker.com/)), and as of
    this writing, it is the most predominantly used container technology. The other
    major alternative is **rkt** developed by CoreOS ([https://coreos.com/rkt](https://coreos.com/rkt)),
    though in this book, we will only be looking at Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Docker versus Virtual Machine (VM)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Looking at the description of Docker so far, we might wonder if it is yet another
    Virtual Machine. However, this is not the case, because a VM requires us to run
    a complete guest OS on top of our machine, or hypervisor, as well as all the required
    binaries. In the case of Docker, we use OS level virtualization, which allows
    us to run our containers in isolated user spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The biggest advantage of a VM is that we can run different types of OSes on
    a system, for example, Windows, FreeBSD, and Linux. However, in the case of Docker,
    we can run any flavor of Linux, and the only limitation is that it has to be Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6fa5f9a-7c70-4dd4-99be-a7baebfe3499.png)'
  prefs: []
  type: TYPE_IMG
- en: Docker container versus VM
  prefs: []
  type: TYPE_NORMAL
- en: The biggest advantage of Docker containers is that since it runs natively on
    Linux as a discrete process making it lightweight and unaware of all the capabilities
    of the host OS.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Docker
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start using Docker, let's take a brief look at how the Docker is meant
    to be used, how it is structured, and what are the major components of the complete
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list and the accompanying image should help understand the architecture
    of Docker pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dockerfile**: It consists of instructions on how to build an image that runs
    our program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker client**: This is a command-line program used by the user to interact
    with Docker daemon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker daemon**: This is the Daemon application that listens for commands
    to manage building or running containers and pushing containers to Docker registry.
    It is also responsible for configuring container networks, volumes, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker images**: Docker images contain all the steps necessary to build a
    container binary that can be executed on any Linux machine with Docker installed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker registry**: The Docker registry is responsible for storing and retrieving
    the Docker images. We can use a public Docker registry or a private one. Docker
    Hub is used as the default Docker registry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Container**: The Docker container is different from the Container
    we have been discussing so far. A Docker container is a runnable instance of a
    Docker image. A Docker container can be created, started, stopped, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker API**: The Docker client we discussed earlier is a command-line interface
    to interact with Docker API. This means that the Docker daemon need not be running
    on the same machine as does the Docker client. The default setup that we will
    be using throughout the book talks to the Docker daemon on the local system using
    UNIX sockets or a network interface:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/142493fb-c42c-4468-994f-7ff76fcd91e4.png)'
  prefs: []
  type: TYPE_IMG
- en: Docker architecture
  prefs: []
  type: TYPE_NORMAL
- en: Testing Docker setup
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's ensure that our Docker setup works perfectly. For our purpose, Docker
    Community Edition should suffice ([https://www.docker.com/community-edition](https://www.docker.com/community-edition)).
    Once we have it installed, we will check if it works by running a few basic commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by checking what version we have installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to dig deeper into details about our Docker installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: On Linux, when you try to run docker commands, you might get **Permission denied** error.
    In order to interact with Docker, you can either prefix the command with `sudo`
    or you can create a "docker" user group and add your user to this group. See link
    for more details [https://docs.docker.com/install/linux/linux-postinstall/.](https://docs.docker.com/install/linux/linux-postinstall/)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to run a Docker image. If you remember the discussion regarding
    the Docker registry, you know that we do not need to build a Docker image using
    Dockerfile, to run a Docker container. We can directly pull it from Docker Hub
    (the default Docker registry) and run the image as a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command could also have been executed, as shown here though,
    merely using `docker run ...`, which is more convenient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have a long set of built images, we can list them all and similarly
    for Docker containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it is important to note that as we keep using docker to build and
    run images and containers, we will start creating a backlog of "dangling" images,
    which we might not really use again. However, they will end up eating storage
    space. In order to get rid of such "dangling" images, we can use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Dockerfile
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we have the basics of Docker under our belt, let's look at the `Dockerfile` file
    we will be using as a template in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: main.go
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let''s create a bare minimum Go program so that we can use it in the Docker
    image. It will take the `NAME` environmental variable and print `<NAME> is your
    uncle.` and then quit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have all the code in place, let''s build the Docker image using
    the `Dockerfile` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Testing in Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing is an important part of programming, whether it is in Go or in any other
    language. Go has a straightforward approach to writing tests, and in this section,
    we will look at some important tools to help with testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are certain rules and conventions we need to follow to test our code.
    They can be listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Source files and associated test files are placed in the same package/folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the test file for any given source file is `<source-file-name>_test.go`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test functions need to have the "Test" prefix, and the next character in the
    function name should be capitalized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the remainder of this section, we will look at three files and their associated
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '`variadic.go` and `variadic_test.go`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addInt.go` and `addInt_test.go`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nil_test.go` (there isn''t any source file for these tests)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along the way, we will introduce any further concepts we might use.
  prefs: []
  type: TYPE_NORMAL
- en: variadic.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to understand the first set of tests, we need to understand what a
    variadic function is and how Go handles it. Let''s start with the definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Variadic function is a function that can accept any number of arguments during
    function call.*'
  prefs: []
  type: TYPE_NORMAL
- en: Given that Go is a statically typed language, the only limitation imposed by
    the type system on a variadic function is that the indefinite number of arguments
    passed to it should be of the same data type. However, this does not limit us
    from passing other variable types. The arguments are received by the function
    as a slice of elements if arguments are passed, else `nil`, when none are passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the code to get a better idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We use the `...` prefix before the data type to define a functions as a variadic
    function. Note that we can have only one variadic parameter per function and it
    has to be the last parameter. We can see this error if we uncomment the line for
    `badVariadic` and try to test the code.
  prefs: []
  type: TYPE_NORMAL
- en: variadic_test.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We would like to test the two valid functions, `simpleVariadicToSlice` and `mixedVariadicToSlice`,
    for various rules defined in the previous section. However, for the sake of brevity,
    we will test these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`simpleVariadicToSlice`: This is for no arguments, three arguments, and also
    to look at how to pass a slice to a variadic function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mixedVariadicToSlice`: This is to accept a simple argument and a variadic
    argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s now look at the code to test these two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Running tests in variadic_test.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s run these tests and see the output. We''ll use the `-v` flag while running
    the tests to see the output of each individual test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: addInt.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The tests in `variadic_test.go` elaborated on the rules for the variadic function.
    However, you might have noticed that `TestSimpleVariadicToSlice` ran three tests
    in its function body, but `go test` treats it as a single test. Go provides a
    good way to run multiple tests within a single function, and we shall look them
    in `addInt_test.go`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we will use a very simple function as shown in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: addInt_test.go
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You might have also noticed in `TestSimpleVariadicToSlice` that we duplicated
    a lot of logic, while the only varying factor was the input and expected values.
    One style of testing, known as **Table-driven development**, defines a table of
    all the required data to run a test, iterates over the "rows" of the table and
    runs tests against them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the tests we will be testing against no arguments and variadic
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Running tests in addInt_test.go
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s now run the tests in this file, and we are expecting each of the row
    in the `testCases` table, which we ran, to be treated as a separate test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: nil_test.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also create tests that are not specific to any particular source file;
    the only criteria is that the filename needs to have the `<text>_test.go` form. The
    tests in `nil_test.go` elucidate on some useful features of the language which
    the developer might find useful while writing tests. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`httptest.NewServer`*:* Imagine the case where we have to test our code against
    a server that sends back some data. Starting and coordinating a full blown server
    to access some data is hard. The `http.NewServer` solves this issue for us.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t.Helper`: If we use the same logic to pass or fail a lot of `testCases`,
    it would make sense to segregate this logic into a separate function. However,
    this would skew the test run call stack. We can see this by commenting `t.Helper()`
    in the tests and rerunning `go test`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also format our command-line output to print pretty results. We will
    show a simple example of adding a tick mark for passed cases and cross mark for
    failed cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the test, we will run a test server, make GET requests on it, and then test
    the expected output versus actual output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Running tests in nil_test.go
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We run three tests, where two test cases will pass and one will fail. This
    way we can see the tick mark and cross mark in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we started by looking at the fundamental setup for running
    Go projects successfully. Then we looked at how to install dependencies for our
    Go projects and how to structure our project. We also looked at the important
    concepts behind Containers, what problems they solve, and how we will be using
    them in the book along with an example. Next, we looked at how to write tests
    in Go, and along the way, we learned a few interesting concepts when dealing with
    a variadic function and other useful test functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start looking at one of the core fundamentals of
    Go programming—goroutines and the important details to keep in mind when using
    them.
  prefs: []
  type: TYPE_NORMAL
